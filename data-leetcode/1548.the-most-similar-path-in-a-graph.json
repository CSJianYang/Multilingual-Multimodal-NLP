[
    {
        "title": "Can Convert String in K Moves",
        "question_content": "Given two strings&nbsp;s&nbsp;and&nbsp;t, your goal is to convert&nbsp;s&nbsp;into&nbsp;t&nbsp;in&nbsp;k&nbsp;moves or less.\nDuring the&nbsp;ith&nbsp;(1 <= i <= k)&nbsp;move you can:\n\n\tChoose any index&nbsp;j&nbsp;(1-indexed) from&nbsp;s, such that&nbsp;1 <= j <= s.length&nbsp;and j&nbsp;has not been chosen in any previous move,&nbsp;and shift the character at that index&nbsp;i&nbsp;times.\n\tDo nothing.\n\nShifting a character means replacing it by the next letter in the alphabet&nbsp;(wrapping around so that&nbsp;'z'&nbsp;becomes&nbsp;'a'). Shifting a character by&nbsp;i&nbsp;means applying the shift operations&nbsp;i&nbsp;times.\nRemember that any index&nbsp;j&nbsp;can be picked at most once.\nReturn&nbsp;true&nbsp;if it's possible to convert&nbsp;s&nbsp;into&nbsp;t&nbsp;in no more than&nbsp;k&nbsp;moves, otherwise return&nbsp;false.\n&nbsp;\nExample 1:\n\nInput: s = \"input\", t = \"ouput\", k = 9\nOutput: true\nExplanation: In the 6th move, we shift 'i' 6 times to get 'o'. And in the 7th move we shift 'n' to get 'u'.\n\nExample 2:\n\nInput: s = \"abc\", t = \"bcd\", k = 10\nOutput: false\nExplanation: We need to shift each character in s one time to convert it into t. We can shift 'a' to 'b' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\n\nExample 3:\n\nInput: s = \"aab\", t = \"bbb\", k = 27\nOutput: true\nExplanation: In the 1st move, we shift the first 'a' 1 time to get 'b'. In the 27th move, we shift the second 'a' 27 times to get 'b'.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length, t.length <= 10^5\n\t0 <= k <= 10^9\n\ts, t contain&nbsp;only lowercase English letters.",
        "solutions": [
            {
                "id": 779903,
                "title": "java-python-3-o-n-count-the-shift-displacement-w-brief-explanation-and-analysis",
                "content": "**Q & A:**\\nQ1: Where in the problem do you derive to get the following step `3`?\\nA1: From the following description:\\n\" ...\\nDuring the ith (1 <= i <= k) move you can:\\n\\n1. Choose any index j (1-indexed) from s, such that 1 <= j <= s.length and j has not been chosen in any previous move, and shift the character at that index i times.\\n2. Do nothing.\\n\\n...\"\\n\\n**End of Q & A**\\n\\n----\\n\\n# Brief Explanation:\\n\\n\\n1. Check if the 2 strings `s` and `t` have same length, if not, return `false`; \\n2. Loop through the input strings and count the shift displacement, in case negative, plus 26 to make it positive;\\n3. If same displacement appears multiple times, the 1st time use the displacement itself, the 2nd time add `26 `to it, the 3rd time add `26 * (3 - 1) = 52 `, the 4th time add `26 * (4 - 1) = 78`, etc.; if after adding the result is greater than `k`, return `false`;\\n4. If never encounter `false` in the above 3, return `true`.\\n\\n```java\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            int diff = (t.charAt(i) - s.charAt(i) + 26) % 26;\\n            if (diff > 0 && diff + count[diff] * 26 > k) {\\n                return false;\\n            }\\n            ++count[diff];\\n        }\\n        return true;\\n    }\\n```\\n```python\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        cnt = [0] * 26\\n        for cs, ct in zip(s, t):\\n            diff = (ord(ct) - ord(cs)) % 26\\n            if diff > 0 and cnt[diff] * 26 + diff > k:\\n                return False\\n            cnt[diff] += 1\\n        return True\\n```\\n**Analysis:**\\n\\nTime: O(n), space: O(1), where n = s.length().",
                "solutionTags": [],
                "code": "```java\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            int diff = (t.charAt(i) - s.charAt(i) + 26) % 26;\\n            if (diff > 0 && diff + count[diff] * 26 > k) {\\n                return false;\\n            }\\n            ++count[diff];\\n        }\\n        return true;\\n    }\\n```\n```python\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        cnt = [0] * 26\\n        for cs, ct in zip(s, t):\\n            diff = (ord(ct) - ord(cs)) % 26\\n            if diff > 0 and cnt[diff] * 26 + diff > k:\\n                return False\\n            cnt[diff] += 1\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 779908,
                "title": "c-o-n-track-multiplier",
                "content": "#### Intuition\\nYou can only shift a letter once, and you cannot change more than once letter by the same number of shifts (`i`). In other words, if you shift one letter by `1`, no other letters can be shifted by `1`. If you need to shift by `1` again, you need to use \"wrapping\" and shift by `27` (which is `1 + 26`).\\n\\nTherefore, if our strings are `\"aaa\"` and `\"bbb\"`, we need to shift the first letter by `1`, the second by `27` (`1 + 26`), and the third - by `53` (`1 + 2 * 26`). So, you  can accomplish the task if `k` is equal or greater than `53`.\\n\\n#### Algorithm\\nGo through the strings and determine `shift` for each letter. If letter in `t` is smaller, we need to \"wrap\" it by adding 26 (e.g. changing `b` into `a` needs 25 shifts).\\n\\nAfter we use a certain number of shifts, we need to add 26, 52, and so on if we need to use it again. So we track the multiplier for each number of shifts in `mul`. If, at any time, the needed number of shifts exceeds `k`, we return `false`.\\n\\n```cpp\\nbool canConvertString(string s, string t, int k) {\\n    if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool canConvertString(string s, string t, int k) {\\n    if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779932,
                "title": "o-n-c-simple-solution-with-explanation",
                "content": "Basic idea is to convert str1 to str2 using less or equal to k iterations where in ith iteration you can choose **atmost** one character to shift **exactly** i places.\\n\\nIntuition :\\n1. if string size is not equal, return false;\\n2. use a hashmap to check how many times the diff is same and keep using the iteration with the formula (26 *(num of occurreces of same diff) + diff;\\n\\nFor eg. \"abc\" -> \"bcd\", diff for a -> b is 1 and we can check hashmap for occurences of diff as following:\\n\\n\\n```hashMap = {....... {1 = 0}....}```\\nWe can use iteration 1 in this case and we update the hashmap to the following to denote that 1 iteration has already been used.\\n```hashMap = {....... {1 = 1}....}```\\n\\nNow to shift b -> c also we need 1 Iteration,which is already being used.\\n```hashMap = {....... {1 = 1}....}```\\n\\nSince 1 iteration is already being used, we can use 26 + 1, and update hash map :\\n```hashMap = {....... {1 = 2}....}```\\nand we also keep track of the maximum iteration found so far.\\n...\\n...\\nand so on.\\n\\nFinally if max iteration <= k return true.\\n\\nNote: Please upvote if you find this useful, this motivates me to write more descriptive solutions\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int m = s.length(), n = t.length(), count = 0;\\n        if (m != n) return false;\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < m; i++) {\\n            if (t[i] == s[i]) continue;\\n            int diff = t[i] - s[i] < 0 ? 26 + t[i] - s[i] : t[i] - s[i];\\n            if (mp.find(diff) == mp.end()) {\\n                count = max(count, diff);\\n            } else {\\n                count = max(count, (mp[diff] * 26) + diff);\\n            }\\n            mp[diff]++;\\n            if (count > k) return false;\\n        }\\n        return count <= k;\\n    }\\n    \\n}; \\n```\\n\\nMore Concise solution\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int m = s.length(), n = t.length(), count = 0;\\n        if (m != n) return false;\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < m; i++) {\\n            if (t[i] == s[i]) continue;\\n            int diff = t[i] - s[i] < 0 ? 26 + t[i] - s[i] : t[i] - s[i];\\n            count = max(count, (mp[diff] * 26) + diff);\\n            mp[diff]++;\\n            if (count > k) return false;\\n        }\\n        return count <= k;\\n    }\\n    \\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```hashMap = {....... {1 = 0}....}```\n```hashMap = {....... {1 = 1}....}```\n```hashMap = {....... {1 = 1}....}```\n```hashMap = {....... {1 = 2}....}```\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int m = s.length(), n = t.length(), count = 0;\\n        if (m != n) return false;\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < m; i++) {\\n            if (t[i] == s[i]) continue;\\n            int diff = t[i] - s[i] < 0 ? 26 + t[i] - s[i] : t[i] - s[i];\\n            if (mp.find(diff) == mp.end()) {\\n                count = max(count, diff);\\n            } else {\\n                count = max(count, (mp[diff] * 26) + diff);\\n            }\\n            mp[diff]++;\\n            if (count > k) return false;\\n        }\\n        return count <= k;\\n    }\\n    \\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 779938,
                "title": "python-o-n-explained",
                "content": "The logic is as follows:\\nFirst we need to calculate the difference of the conversion. for example conversion from a to be will have difference of 1.\\nThen we hold a hash map ```diff``` to see how many times we want to convert each difference.\\nFor example to go from \"aa\" to \"bb\" we want to go ```difference 1``` for 2 times.\\nThis is possible only if we will have k of 27 or above, because to go from ```a``` to ```b``` we need 1, and each loop starts at 26 (alphabet count).\\n\\nQuick way to check that is: ``` ((diff[d] - 1) * 26) + d > k ```\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        # We calculate the differences\\n        diff = defaultdict(int)\\n        for sc, tc in zip(s, t):\\n            d = (ord(tc) - ord(sc)) % 26\\n            if d == 0: continue\\n            if d > k: return False\\n            diff[d] += 1\\n            if ((diff[d] - 1) * 26) + d > k:\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```diff```\n```difference 1```\n```a```\n```b```\n``` ((diff[d] - 1) * 26) + d > k ```\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        # We calculate the differences\\n        diff = defaultdict(int)\\n        for sc, tc in zip(s, t):\\n            d = (ord(tc) - ord(sc)) % 26\\n            if d == 0: continue\\n            if d > k: return False\\n            diff[d] += 1\\n            if ((diff[d] - 1) * 26) + d > k:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780012,
                "title": "can-anyone-explain",
                "content": "I didnt understand the second test case\\n\\n```\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n```\\n\\nWhy is the answer false? Shouldnt this be possible in three moves?",
                "solutionTags": [],
                "code": "```\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 782335,
                "title": "python-simple-array-lookup-o-n-time-o-1-space",
                "content": "**Idea:**\\n\\nTest Cases:\\n* Check if length of strings are equal \\n\\nLogic\\n* Check the distance between between the s[i] and t[i] using the ord()\\n* Record the distance in an array which tracks used shifts\\n* Check the array to see if shift has been used\\n* If shift has been used take the number of times it has been used and multiply by 26\\n* If shift > k return False \\n\\n**Tricks**\\n* Use mod 26 when taking the ord() difference between the chars\\n* Example: s[i] = \\'b\\' and t[i] = \\'a\\' which requires 25 shifts\\n* ord(s[i]) - ord(t[i]) = -1\\n* (-1) % 26 = 25 \\n*  Makes logic simpler \\n\\n**Code:**\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n        # Check uneven lengths \\n        if len(s) != len(t):\\n            return False \\n        \\n\\t\\t# Track used shifts\\n        shifts = [0 for x in range(1,27)]\\n      \\n        for i in range(len(s)):\\n            \\n\\t\\t\\t# No shift required\\n            if t[i] == s[i]:\\n                continue\\n\\t\\t\\t\\n\\t\\t\\t# Number of shifts calculation\\n            diff = (ord(t[i]) - ord(s[i])) % 26\\n\\t\\t\\t\\n\\t\\t\\t# Check if number of shift is permitted \\n            if ((shifts[diff]) *26 + diff) > k:\\n                return False\\n            shifts[diff] += 1\\n\\n        return True\\n```\\n\\nLike if this helped!\\nCheers,\\nArgent",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n        # Check uneven lengths \\n        if len(s) != len(t):\\n            return False \\n        \\n\\t\\t# Track used shifts\\n        shifts = [0 for x in range(1,27)]\\n      \\n        for i in range(len(s)):\\n            \\n\\t\\t\\t# No shift required\\n            if t[i] == s[i]:\\n                continue\\n\\t\\t\\t\\n\\t\\t\\t# Number of shifts calculation\\n            diff = (ord(t[i]) - ord(s[i])) % 26\\n\\t\\t\\t\\n\\t\\t\\t# Check if number of shift is permitted \\n            if ((shifts[diff]) *26 + diff) > k:\\n                return False\\n            shifts[diff] += 1\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780269,
                "title": "java-simple-hashmap",
                "content": "```\\n    public boolean canConvertString(String s, String t, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int m = s.length(), n = t.length(), prev = 0;\\n        if (m != n) return false;\\n        for (int i = 0; i < m; i++) {\\n            int dist = getDist(s.charAt(i), t.charAt(i)), prevCnt = map.getOrDefault(dist, 0);\\n            if (dist > 0) map.put(dist, prevCnt + 1);\\n            if (prevCnt * 26 + dist > k) return false;  // find next available move\\n        }\\n        return true;\\n    }\\n    \\n    private int getDist(char a, char b) {\\n        int dist = b - a;\\n        return (dist + 26) % 26;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canConvertString(String s, String t, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int m = s.length(), n = t.length(), prev = 0;\\n        if (m != n) return false;\\n        for (int i = 0; i < m; i++) {\\n            int dist = getDist(s.charAt(i), t.charAt(i)), prevCnt = map.getOrDefault(dist, 0);\\n            if (dist > 0) map.put(dist, prevCnt + 1);\\n            if (prevCnt * 26 + dist > k) return false;  // find next available move\\n        }\\n        return true;\\n    }\\n    \\n    private int getDist(char a, char b) {\\n        int dist = b - a;\\n        return (dist + 26) % 26;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779955,
                "title": "simple-c-solution-with-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if(s.size() != t.size()) return false;\\n        \\n        int n = s.size();\\n        vector<int> v(n,0);\\n        map<int,int> mp;\\n        \\n        for(int i = 0;i < n;i++){\\n            int x = t[i] - s[i];\\n            if(x < 0) x = 26 + x;   // s[i] > t[i] then we have to roll back\\n            if(x != 0)\\n                v[i] = mp[x]*26 + x;    //if same x comes then we can roll for another 26 times if we have moves\\n            else v[i] = x;\\n            if(v[i] > k) return false;  // if moves are more then limit then return false\\n            mp[x]++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if(s.size() != t.size()) return false;\\n        \\n        int n = s.size();\\n        vector<int> v(n,0);\\n        map<int,int> mp;\\n        \\n        for(int i = 0;i < n;i++){\\n            int x = t[i] - s[i];\\n            if(x < 0) x = 26 + x;   // s[i] > t[i] then we have to roll back\\n            if(x != 0)\\n                v[i] = mp[x]*26 + x;    //if same x comes then we can roll for another 26 times if we have moves\\n            else v[i] = x;\\n            if(v[i] > k) return false;  // if moves are more then limit then return false\\n            mp[x]++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779906,
                "title": "transform-to-math-question",
                "content": "imagine the first round we can do x steps, x is min(26, k)\\nfor each different char, we can change it to the destination char in the first round, after that, we have to always wait for another 26 times\\n\\nfor example, \"ab\" -> \"cd\"\\n\\n\\'a\\' to \\'c\\' needs 2 steps;\\n\\'b\\' to \\'d\\' needs 2 steps;\\n\\nbut we can only do ONE replacing with 2 steps to make \\'a\\' to \\'c\\'\\nto make \\'b\\' to \\'d\\' happen, we will need to wait for next round, which is 2+26 = 28. \\n\\nso simply check how many cases(C) exist for a N steps operation.\\nif N + (c-1)*26 > K then we can\\'t make it happen. \\n\\n```\\nbool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size())\\n            return false;\\n        if(s == t)\\n            return true;\\n        vector<int> times(26);\\n        int n = s.size();\\n        for(int i = 0; i < n; ++i) {\\n            int ti = (t[i] - s[i] + 26) % 26;\\n            ++times[ti];\\n        }\\n        \\n        for(int i = 1; i < 26; ++i) {\\n            if(i + (times[i] - 1) * 26 > k)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size())\\n            return false;\\n        if(s == t)\\n            return true;\\n        vector<int> times(26);\\n        int n = s.size();\\n        for(int i = 0; i < n; ++i) {\\n            int ti = (t[i] - s[i] + 26) % 26;\\n            ++times[ti];\\n        }\\n        \\n        for(int i = 1; i < 26; ++i) {\\n            if(i + (times[i] - 1) * 26 > k)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1189629,
                "title": "simple-c-solution-8-lines",
                "content": "Here we simply calculate the shift required for each character of ```s``` and and store it in an array of size 26. Then check if those many shift are possible or not within the given value of ```k```.\\n* ```ar[i] = x``` implies that there are x characters in ```string s``` that need a shift of i to match the charcters in ```string t```.\\n* Now it is given in the question that each shift can be used only once. \\n* So if two charcters need a shift of 1, only one of them will be allowed.\\n* The next charcter will get a shift of 1 + 26 which makes the efective shift to be 1. \\nEg: lets say ```s = \"aa\"``` and ```t = \"cc\"```\\nThen ```ar[2] = 2```\\nSo two characters need a net shift of 2. So the possible shifts are 2, 28, 54, .....\\nSince we need only two, so 2 and 28 are enough. Therefore our value of k should be atleast 28 .If not then return false immediately.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int ar[26] = {0};       \\n        for(int i = 0;i < s.length();i++){\\n            int shift = (t[i] - s[i] + 26) % 26;            \\n            ar[shift]++;\\n        }\\n        for(int i = 1;i <= 25;i++)\\n            if(i + (ar[i] - 1)*26 > k)\\n                return false;\\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```s```\n```k```\n```ar[i] = x```\n```string s```\n```string t```\n```s = \"aa\"```\n```t = \"cc\"```\n```ar[2] = 2```\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int ar[26] = {0};       \\n        for(int i = 0;i < s.length();i++){\\n            int shift = (t[i] - s[i] + 26) % 26;            \\n            ar[shift]++;\\n        }\\n        for(int i = 1;i <= 25;i++)\\n            if(i + (ar[i] - 1)*26 > k)\\n                return false;\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881255,
                "title": "python-3-3-lines-counter-w-example-t-m-93-19",
                "content": "Here\\'s the plan:\\n* We construct a `Counter` to keep track of the shifts.\\n\\n* We check whether `k` is sufficient to accomodate the shifts for each position of like difference. For example, if `c[2] = 3` (that is, three positions each have a difference of 2)  the third char is shifted `2+26+26 = 54`, so it must be that `k >= 54`.\\n* If so, we return `True`; if not `False`.\\n\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n        if len(s) != len(t): return False               # Example: s = \"aacdd\" , t = \"bbcdf\" , k = 30\\n\\n        c = Counter([(ord(t[i]) - ord(s[i])) % 26       # Counter([1,  1,  0,  0,  2]) = {1: 2, 0: 2, 2: 1} \\n                            for i in range(len(s))])    #          |   |   |   |   |\\n                                                        #         a:b a:b c:c d:d d:f \\n\\n        return all((c[i]-1)*26 + i <= k                 #  all( (1-1)*26 + 1 <= 30, (1-1)*26 + 1 <= 30, (2-1)*26 + 1 <= 30)\\n                            for i in c if i)            #  all(True,True,True)\\n                                                        #  return True \\n```\\n[https://leetcode.com/submissions/detail/855147141/](http://)\\n\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n        if len(s) != len(t): return False               # Example: s = \"aacdd\" , t = \"bbcdf\" , k = 30\\n\\n        c = Counter([(ord(t[i]) - ord(s[i])) % 26       # Counter([1,  1,  0,  0,  2]) = {1: 2, 0: 2, 2: 1} \\n                            for i in range(len(s))])    #          |   |   |   |   |\\n                                                        #         a:b a:b c:c d:d d:f \\n\\n        return all((c[i]-1)*26 + i <= k                 #  all( (1-1)*26 + 1 <= 30, (1-1)*26 + 1 <= 30, (2-1)*26 + 1 <= 30)\\n                            for i in c if i)            #  all(True,True,True)\\n                                                        #  return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657022,
                "title": "detailed-explanation-well-coded-92-faster",
                "content": "## IDEA :\\n* First we need to calculate the difference of the conversion. for example conversion from `a to b` will have difference of 1.\\n* Then we hold a dictiomary (hash map) diff to see how many times we want to convert each difference.\\n\\n* For example to go from `\"aa\" to \"bb\"` we want to go difference 1 for 2 times.\\n* This is possible only if we will have k of 27 or above, because to go from a to b we need 1, and each loop starts at 26 (alphabet count).\\n\\n****\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n\\t\\t\\tif len(s)!=len(t):\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tdic = defaultdict(int)\\n\\t\\t\\tfor a,b in zip(s,t):\\n\\t\\t\\t\\tif a!=b:\\n\\t\\t\\t\\t\\tif ord(b)>ord(a):\\n\\t\\t\\t\\t\\t\\tdiff = ord(b)-ord(a)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdiff = (26-ord(a)+ord(b))\\n\\n\\t\\t\\t\\t\\tn = dic[diff]*26 + diff\\n\\t\\t\\t\\t\\tif n>k:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tdic[diff]+=1\\n\\n\\t\\t\\treturn True\\n\\n### Explanation :\\n\\n**Dict Storing Difference as key and value as frequency of that shift require to convert all char with same difference to respective char in \\'t\\'.**\\nExample \\n\\'\\'\\'\\n\\n\\ts=abc t=bcd , we require 1 shift three times.So key=1 val=3.\\n\\n\\n**Now for a particular key, we require maximum `26*(val)+diff` number if we want to convert all char with same difference(key) to valid char in \\'t\\'.**\\nExample :\\n\\'\\'\\'\\n\\n\\ts = abc t =bcd we require number 1,27,53 to convert s to t.\\n\\n\\n\\t\\t\\t\\n**Thanks and Upvote if you got any help or like the Idea !!** \\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## IDEA :\\n* First we need to calculate the difference of the conversion. for example conversion from `a to b` will have difference of 1.\\n* Then we hold a dictiomary (hash map) diff to see how many times we want to convert each difference.\\n\\n* For example to go from `\"aa\" to \"bb\"` we want to go difference 1 for 2 times.\\n* This is possible only if we will have k of 27 or above, because to go from a to b we need 1, and each loop starts at 26 (alphabet count).\\n\\n****\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n\\t\\t\\tif len(s)!=len(t):\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tdic = defaultdict(int)\\n\\t\\t\\tfor a,b in zip(s,t):\\n\\t\\t\\t\\tif a!=b:\\n\\t\\t\\t\\t\\tif ord(b)>ord(a):\\n\\t\\t\\t\\t\\t\\tdiff = ord(b)-ord(a)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdiff = (26-ord(a)+ord(b))\\n\\n\\t\\t\\t\\t\\tn = dic[diff]*26 + diff\\n\\t\\t\\t\\t\\tif n>k:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tdic[diff]+=1\\n\\n\\t\\t\\treturn True\\n\\n### Explanation :\\n\\n**Dict Storing Difference as key and value as frequency of that shift require to convert all char with same difference to respective char in \\'t\\'.**\\nExample \\n\\'\\'\\'\\n\\n\\ts=abc t=bcd , we require 1 shift three times.So key=1 val=3.\\n\\n\\n**Now for a particular key, we require maximum `26*(val)+diff` number if we want to convert all char with same difference(key) to valid char in \\'t\\'.**\\nExample :\\n\\'\\'\\'\\n\\n\\ts = abc t =bcd we require number 1,27,53 to convert s to t.\\n\\n\\n\\t\\t\\t\\n**Thanks and Upvote if you got any help or like the Idea !!** \\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1268156,
                "title": "easy-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        map<int,int>mp;\\n        int n=s.length(),m=t.length();\\n        if(n!=m)\\n            return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            int diff=int(t[i])-int(s[i]);\\n            if(diff<0)\\n                diff=26-abs(diff);\\n            if(diff>0)\\n                mp[diff]+=1;\\n        }\\n        bool ans=true;\\n        for(auto i:mp)\\n        {\\n            if(k<26*(i.second-1)+i.first)\\n                ans=false;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        map<int,int>mp;\\n        int n=s.length(),m=t.length();\\n        if(n!=m)\\n            return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            int diff=int(t[i])-int(s[i]);\\n            if(diff<0)\\n                diff=26-abs(diff);\\n            if(diff>0)\\n                mp[diff]+=1;\\n        }\\n        bool ans=true;\\n        for(auto i:mp)\\n        {\\n            if(k<26*(i.second-1)+i.first)\\n                ans=false;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779987,
                "title": "java-hashmap-o-n",
                "content": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length())\\n            return false;\\n        Map<Integer,Integer> seen=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            int d=(t.charAt(i)-\\'a\\')-(s.charAt(i)-\\'a\\');\\n            if(d==0)\\n                continue;\\n            if(d<0)\\n                d+=26;\\n            if(d>k)\\n                return false;\\n            if(seen.containsKey(d)){\\n                int lastShift=seen.get(d);\\n                if(26+lastShift<=k)\\n                    seen.put(d,lastShift+26);\\n                else\\n                    return false;\\n            } else\\n                seen.put(d,d);\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length())\\n            return false;\\n        Map<Integer,Integer> seen=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            int d=(t.charAt(i)-\\'a\\')-(s.charAt(i)-\\'a\\');\\n            if(d==0)\\n                continue;\\n            if(d<0)\\n                d+=26;\\n            if(d>k)\\n                return false;\\n            if(seen.containsKey(d)){\\n                int lastShift=seen.get(d);\\n                if(26+lastShift<=k)\\n                    seen.put(d,lastShift+26);\\n                else\\n                    return false;\\n            } else\\n                seen.put(d,d);\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779911,
                "title": "simple-c-o-n-solution-no-hashmap-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\n        // Array to store the next usable difference \\n        long long int diffArr[27] = { 0 };\\n\\n        char sChar, tChar;\\n        int diff;\\n        for (int i=0; i<s.length(); i++) {\\n            sChar = s[i];\\n            tChar = t[i];\\n            if (sChar == tChar) {\\n                continue;\\n            }\\n            \\n            diff = (tChar - sChar);\\n            diff += ((diff < 0) ? 26 : 0); // If we go from \\'z\\' to \\'a\\', diff is negative, so we add 26 to make it positive (circular)\\n\\n            if (diff + diffArr[diff] > k) {\\n                return false;\\n            }\\n            \\n            // Increase the diff value by 26 if we happen to find it again with some other character\\n            diffArr[diff] += 26;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\n        // Array to store the next usable difference \\n        long long int diffArr[27] = { 0 };\\n\\n        char sChar, tChar;\\n        int diff;\\n        for (int i=0; i<s.length(); i++) {\\n            sChar = s[i];\\n            tChar = t[i];\\n            if (sChar == tChar) {\\n                continue;\\n            }\\n            \\n            diff = (tChar - sChar);\\n            diff += ((diff < 0) ? 26 : 0); // If we go from \\'z\\' to \\'a\\', diff is negative, so we add 26 to make it positive (circular)\\n\\n            if (diff + diffArr[diff] > k) {\\n                return false;\\n            }\\n            \\n            // Increase the diff value by 26 if we happen to find it again with some other character\\n            diffArr[diff] += 26;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286937,
                "title": "java-string-greedy-10ms-beats-90-t-c-o-n-s-c-o-n",
                "content": "\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        int len1 = s.length(), len2 = t.length();\\n        if(len1 != len2)\\n            return false;\\n        \\n        int[] next = new int[26];\\n        \\n        for(int i=0;i<26;i++)\\n            next[i] = i;\\n        \\n        for(int i = 0 ; i < len1 ; i++){\\n            \\n            int diff = t.charAt(i) - s.charAt(i);\\n            if(diff == 0)\\n                continue;\\n            \\n            if(diff < 0)\\n                diff += 26;\\n            \\n            int move = next[diff];\\n            next[diff] += 26;\\n            \\n            if(move > k)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        int len1 = s.length(), len2 = t.length();\\n        if(len1 != len2)\\n            return false;\\n        \\n        int[] next = new int[26];\\n        \\n        for(int i=0;i<26;i++)\\n            next[i] = i;\\n        \\n        for(int i = 0 ; i < len1 ; i++){\\n            \\n            int diff = t.charAt(i) - s.charAt(i);\\n            if(diff == 0)\\n                continue;\\n            \\n            if(diff < 0)\\n                diff += 26;\\n            \\n            int move = next[diff];\\n            next[diff] += 26;\\n            \\n            if(move > k)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 981234,
                "title": "python-3-beats-91-with-explanation",
                "content": "For example, we want to transform \"ad\" to \"be\".\\nApparently, we can shift \"a\" by 1 move, to \"b\", however, in order to shift \"d\" to \"e\", we can no longer shift \"d\" by 1 move since we have already done it before, so we have to find the next smallest number which residue is 1, which is 27. So once we shift \"a\" by 1 move, we can wait for 25 following steps with 0 move, then, we shift d by 27 moves to get \"e\"\\nTherefore it is pretty clear that we just need to sort the characters pairs in s and t, by the residue of ord different after mod 26.\\nSo the dictionary for our example is d={1:2}, which means the char pairs have 2 residue of 1. Then the smallest K should be 1+(2-1)* 26.\\n\\nDo not forget to pick the alphabitically largest character if multiple characters have same values.\\n\\n```\\ndef canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s)!=len(t):\\n            return False\\n        d=collections.defaultdict(int)\\n        for x,y in zip(s,t):\\n            d[(ord(y)-ord(x))%26]+=1\\n        ans=sorted(d.items(), key=lambda x: [-x[1],-x[0]])[0]        \\n        return True if ans[0]==0 else ans[0]+26*(ans[1]-1)<=k\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\ndef canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s)!=len(t):\\n            return False\\n        d=collections.defaultdict(int)\\n        for x,y in zip(s,t):\\n            d[(ord(y)-ord(x))%26]+=1\\n        ans=sorted(d.items(), key=lambda x: [-x[1],-x[0]])[0]        \\n        return True if ans[0]==0 else ans[0]+26*(ans[1]-1)<=k\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 895168,
                "title": "python-sol-explained-in-great-detail",
                "content": "\\tclass Solution(object):\\n\\t\\tdef canConvertString(self, s, t, k):\\n\\t\\t\\tif s==t:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif len(s)!=len(t):\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tshift_require_dict = collections.defaultdict(int) \\n\\t\\t\\t\\'\\'\\'Dict Storing Difference/shift as key and value as frequency \\n\\t\\t\\tof that shift require to convert all char with same shift/difference \\n\\t\\t\\tto respective char in \\'t\\'. Example s=abc t=bcd , we require 1 shift three times.So key=1 val=3\\'\\'\\'\\n\\t\\t\\tfor i,j in zip(s,t):\\n\\t\\t\\t\\tif i!=j:\\n\\t\\t\\t\\t\\tif j<i:\\n\\t\\t\\t\\t\\t\\ta = (122-ord(i)) + (ord(j)-96) # if char[s] > char[t], then we may go till z and again come char[t]\\n\\t\\t\\t\\t\\t\\tshift_require_dict[a] +=1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ta = ord(j)-ord(i)\\n\\t\\t\\t\\t\\t\\tshift_require_dict[a] += 1\\n\\n\\t\\'\\'\\'Now for a particular key, we require maximum\\n\\t26*(val-1)+key number if we want to convert all \\n\\tchar with same shift(key) to valid char in \\'t\\'.\\n\\tExample s = abc t =bcd we require number 1,27,53 to convert s to t.\\'\\'\\'\\n\\n\\t# So MAX_Val required will be max_freq with largest shift\\n\\t\\t\\tmax_f = shift_require_dict[max(shift_require_dict,key=shift_require_dict.get)]\\n\\t\\t\\tmax_diff =0\\n\\t\\t\\tfor key,val in shift_require_dict.items():\\n\\t\\t\\t\\tif val ==max_f:\\n\\t\\t\\t\\t\\tmax_diff = max(max_diff,key)\\n\\n\\t\\t\\tif (26*(max_f-1) + max_diff) <=k:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False",
                "solutionTags": [],
                "code": "\\tclass Solution(object):\\n\\t\\tdef canConvertString(self, s, t, k):\\n\\t\\t\\tif s==t:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif len(s)!=len(t):\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tshift_require_dict = collections.defaultdict(int) \\n\\t\\t\\t\\'\\'\\'Dict Storing Difference/shift as key and value as frequency \\n\\t\\t\\tof that shift require to convert all char with same shift/difference \\n\\t\\t\\tto respective char in \\'t\\'. Example s=abc t=bcd , we require 1 shift three times.So key=1 val=3\\'\\'\\'\\n\\t\\t\\tfor i,j in zip(s,t):\\n\\t\\t\\t\\tif i!=j:\\n\\t\\t\\t\\t\\tif j<i:\\n\\t\\t\\t\\t\\t\\ta = (122-ord(i)) + (ord(j)-96) # if char[s] > char[t], then we may go till z and again come char[t]\\n\\t\\t\\t\\t\\t\\tshift_require_dict[a] +=1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ta = ord(j)-ord(i)\\n\\t\\t\\t\\t\\t\\tshift_require_dict[a] += 1\\n\\n\\t\\'\\'\\'Now for a particular key, we require maximum\\n\\t26*(val-1)+key number if we want to convert all \\n\\tchar with same shift(key) to valid char in \\'t\\'.\\n\\tExample s = abc t =bcd we require number 1,27,53 to convert s to t.\\'\\'\\'\\n\\n\\t# So MAX_Val required will be max_freq with largest shift\\n\\t\\t\\tmax_f = shift_require_dict[max(shift_require_dict,key=shift_require_dict.get)]\\n\\t\\t\\tmax_diff =0\\n\\t\\t\\tfor key,val in shift_require_dict.items():\\n\\t\\t\\t\\tif val ==max_f:\\n\\t\\t\\t\\t\\tmax_diff = max(max_diff,key)\\n\\n\\t\\t\\tif (26*(max_f-1) + max_diff) <=k:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False",
                "codeTag": "Java"
            },
            {
                "id": 858863,
                "title": "python-breifly-explained-remember-the-recent-longest-shift-o-n",
                "content": "Each character at index j in both source and target string have some expected shifts. For example,\\n```\\ns[j] = \"a\"\\nt[j] = \"e\" \\n```\\nAlgorithm:\\n1.  Expected shifts are ```(ord(\"e\") - ord(\"a\"))%26```, since alphabets arranged in cycle. Here, ```shifts = 4```\\n\\n2.  Maintain a hashmap for used i number of shifts. Ask hashmap whether 4 shifts are available. If yes update the ```eyesUsed[4] = 4```\\n\\n3.  if any other pair of chars in s and t also asking for 4 shifts which are occupied, then previously saved hashmap[4] can lead us where to look next, which is  ```26 + eyesUsed[4]```  because next valid way to reach target char is to shift through all alphabets once.\\n\\n4.  Repeat **step 2** and **step3** untill vacant shifts found if number of shifts exceeded the K value then abort the loop and return False\\n\\n5.  After successfully shifting all the characters return True\\n\\n```\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n\\t\\tif len(s) != len(t): return False\\n\\n\\t\\t\\teyesUsed = dict()\\n\\t\\t\\tfor ch1,ch2 in zip(map(ord,s),map(ord,t)):\\n\\n\\t\\t\\t\\tif ch1 == ch2: continue\\n\\t\\t\\t\\tshift = (ch2 - ch1)%26\\n\\n\\t\\t\\t\\tinitShift = shift\\n\\t\\t\\t\\twhile 1 <= shift <= k:\\n\\n\\t\\t\\t\\t\\tif shift not in eyesUsed:\\n\\t\\t\\t\\t\\t\\teyesUsed[initShift] = shift\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\tshift = eyesUsed[initShift]+26\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True\\n        \\n```\\n\\n**Base cases:** \\n* ```If source s[i]  == target t[j] then skip shifting```\\n* ```if lengths of source != target then return False```\\n\\nUnderStood? Any Improvements?",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ns[j] = \"a\"\\nt[j] = \"e\" \\n```\n```(ord(\"e\") - ord(\"a\"))%26```\n```shifts = 4```\n```eyesUsed[4] = 4```\n```26 + eyesUsed[4]```\n```\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n\\t\\tif len(s) != len(t): return False\\n\\n\\t\\t\\teyesUsed = dict()\\n\\t\\t\\tfor ch1,ch2 in zip(map(ord,s),map(ord,t)):\\n\\n\\t\\t\\t\\tif ch1 == ch2: continue\\n\\t\\t\\t\\tshift = (ch2 - ch1)%26\\n\\n\\t\\t\\t\\tinitShift = shift\\n\\t\\t\\t\\twhile 1 <= shift <= k:\\n\\n\\t\\t\\t\\t\\tif shift not in eyesUsed:\\n\\t\\t\\t\\t\\t\\teyesUsed[initShift] = shift\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\tshift = eyesUsed[initShift]+26\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True\\n        \\n```\n```If source s[i]  == target t[j] then skip shifting```\n```if lengths of source != target then return False```",
                "codeTag": "Python3"
            },
            {
                "id": 836489,
                "title": "java-o-n-method",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] shiftCounts = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == t.charAt(i)) {\\n                continue;\\n            }\\n            int shift = getNumOfShifts(s.charAt(i), t.charAt(i));\\n            int val = shiftCounts[shift] * 26 + shift;\\n            if (val > k) {\\n                return false;\\n            }\\n            shiftCounts[shift]++;\\n        }\\n        return true;\\n    }\\n    \\n    private final int getNumOfShifts(char a, char b) {\\n        return (b - a + 26) % 26;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] shiftCounts = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == t.charAt(i)) {\\n                continue;\\n            }\\n            int shift = getNumOfShifts(s.charAt(i), t.charAt(i));\\n            int val = shiftCounts[shift] * 26 + shift;\\n            if (val > k) {\\n                return false;\\n            }\\n            shiftCounts[shift]++;\\n        }\\n        return true;\\n    }\\n    \\n    private final int getNumOfShifts(char a, char b) {\\n        return (b - a + 26) % 26;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781884,
                "title": "c-o-n-beat-100",
                "content": "Got TLE using set, so i use a int array to store the numbers of move. 100% time\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int used[26] = {0};\\n        int diff = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(t[i] - s[i] > 0) diff = t[i] - s[i];\\n            else if(t[i] - s[i] < 0) diff = 26 - s[i] + t[i];\\n            else continue;\\n            \\n            if( (used[diff]) * 26 + diff > k) return false;\\n            used[diff]++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int used[26] = {0};\\n        int diff = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(t[i] - s[i] > 0) diff = t[i] - s[i];\\n            else if(t[i] - s[i] < 0) diff = 26 - s[i] + t[i];\\n            else continue;\\n            \\n            if( (used[diff]) * 26 + diff > k) return false;\\n            used[diff]++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780437,
                "title": "python-o-n-solution-with-explanation",
                "content": "**Technique:**\\n\\n1. Create a `diffArr` (Difference Array) which will store the ascii difference between the characters in the string `t` & `s`. Since we can only increment & not reduce, for all the negative values(When we sustract `a` with `z`) we have to subtract it with 26 & store the difference. \\n2. Next step is to crate a set (`diffSet`) to keep track of the shifts which we have already used between `1-k`. \\n3. As we iterate through the `diffArr` we have to check if we already have the `ith` step in set, if not we\\'ll add it to the set since that is the first time we\\'re using it. And if it is already present - here\\'s where the real logic is. We have to keep incrementing the number of shifts by 26 as that would result in the same character. We have to increment it until we get the number of moves which have not been used until now (which is what the while loop within else statement is responsible for). \\n\\ni.e., difference 1 can take values 1, 27, 53, 79... & so on\\n\\nMeanwhile while moving itself, we can check if the number of shifts is going to exceed k or not, if yes return False\\n\\n**TLE Issue Code**\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        diffArr = []\\n        if s == t:\\n            return True\\n        n = len(s)\\n        n2 = len(t)\\n        if n != n2:\\n            return False\\n        for i in range(n):\\n            diff = ord(t[i])-ord(s[i])\\n            if diff < 0:\\n                diff = 26+diff\\n            diffArr.append(diff)\\n        diffSet = set()\\n        for i in diffArr:\\n            if i == 0:\\n                continue\\n            if i not in diffSet:\\n                diffSet.add(i)\\n            else:\\n                while i in diffSet:\\n                    if i > k:\\n                        return False\\n                    i += 26\\n                diffSet.add(i)\\n        return max(diffSet) <= k\\n```\\n\\n**Whats the problem with this approach?**\\n\\nSince we\\'re having a while loop which starts from i (which is less than 26) and loop until we find the next number of shifts for every value in `diffArr` we will end up in ***`TLE`***\\n\\n**How to solve this?**\\n\\nHere\\'s where memoization comes into picture. Instead of looping through by incrementing values by 26, we can store what is the value for the original `i` which will store the most recently used value for `i`\\n\\nFor eg., \\nif i = 1, we can have the number of shifts as 1,27,53,79... and so on.\\nInstead of calculating this from 1 upto... the limit k or next free value, mem[1] will store the most recently used value which will fit it. \\n\\nFor 1st iteration\\n```mem[1] = 1```\\n2nd\\n```mem[1] = 27```\\n3rd\\n```mem[1] = 53```\\n& so on\\n\\n**Working code with Single Loop**\\n\\nWe don\\'t have to store and then iterate the `diffArr`, we can perform the memoization & checks while iterating through the strings itself.\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        n = len(s)\\n        n2 = len(t)\\n        if n != n2:\\n            return False\\n        mem = {}\\n        for i in range(n):\\n            diff = ord(t[i])-ord(s[i])\\n            if diff == 0:\\n                continue\\n            if diff < 0:\\n                diff += 26\\n            if diff in mem:\\n                mem[diff] += 26\\n            else:\\n                mem[diff] = diff\\n            if mem[diff] > k:\\n                return False\\n        return True\\n```\\n\\nJust checking for the base conditions if both strings are same, we return `True`. And if the lengths don\\'t match, we return `False`",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        diffArr = []\\n        if s == t:\\n            return True\\n        n = len(s)\\n        n2 = len(t)\\n        if n != n2:\\n            return False\\n        for i in range(n):\\n            diff = ord(t[i])-ord(s[i])\\n            if diff < 0:\\n                diff = 26+diff\\n            diffArr.append(diff)\\n        diffSet = set()\\n        for i in diffArr:\\n            if i == 0:\\n                continue\\n            if i not in diffSet:\\n                diffSet.add(i)\\n            else:\\n                while i in diffSet:\\n                    if i > k:\\n                        return False\\n                    i += 26\\n                diffSet.add(i)\\n        return max(diffSet) <= k\\n```\n```mem[1] = 1```\n```mem[1] = 27```\n```mem[1] = 53```\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        n = len(s)\\n        n2 = len(t)\\n        if n != n2:\\n            return False\\n        mem = {}\\n        for i in range(n):\\n            diff = ord(t[i])-ord(s[i])\\n            if diff == 0:\\n                continue\\n            if diff < 0:\\n                diff += 26\\n            if diff in mem:\\n                mem[diff] += 26\\n            else:\\n                mem[diff] = diff\\n            if mem[diff] > k:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780066,
                "title": "java-6-lines-o-n-time-o-1-space",
                "content": "Just compute required swaps for each position modulo 26, and confirm that k is large enough to satisfy all required swappings.\\n\\n```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) return false;\\n        int[] counts = new int[26];\\n        for (int i = 0; i < s.length(); i++) counts[Math.floorMod(t.charAt(i) - s.charAt(i), 26)]++;\\n        for (int i = 1; i < 26; i++)\\n            if (counts[i] > 0 && i + (counts[i]-1)*26 > k) return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) return false;\\n        int[] counts = new int[26];\\n        for (int i = 0; i < s.length(); i++) counts[Math.floorMod(t.charAt(i) - s.charAt(i), 26)]++;\\n        for (int i = 1; i < 26; i++)\\n            if (counts[i] > 0 && i + (counts[i]-1)*26 > k) return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3039833,
                "title": "can-convert-string-in-k-moves",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, it checks if the length of two strings are not equal, it returns false\\nIt calculates the number of shift required for each character to convert the first string to the second one.\\nThen it iterates over the number of shift required and for each shift, it checks if the number of shift * 26 + the current shift greater than k, if so it returns false.\\nIf all the indexes can be shifted in k moves or less, it returns true.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n) where n is the length of the string.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n The space complexity is O(1) since we are using a fixed size array of size 26 to store the shift count.\\n# Code\\n```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        // Edge case: if the length of the two strings are not equal, return false\\n        if (s.length() != t.length()) return false;\\n        int n = s.length();\\n        int[] diff = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            diff[i] = (t.charAt(i) - s.charAt(i) + 26) % 26;\\n        }\\n        int[] count = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            if (diff[i] == 0) continue;\\n            if (count[diff[i]] * 26 + diff[i] > k) return false;\\n            count[diff[i]]++;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        // Edge case: if the length of the two strings are not equal, return false\\n        if (s.length() != t.length()) return false;\\n        int n = s.length();\\n        int[] diff = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            diff[i] = (t.charAt(i) - s.charAt(i) + 26) % 26;\\n        }\\n        int[] count = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            if (diff[i] == 0) continue;\\n            if (count[diff[i]] * 26 + diff[i] > k) return false;\\n            count[diff[i]]++;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963839,
                "title": "python3-solution-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canConvertString(self, s, t, k):\\n        if len(s) != len(t): return False\\n        dp = [-1] * 27\\n        for a, b in zip(s, t):\\n            n = ord(b) - ord(a)\\n            dp[n if n >= 0 else 26 + n] += 1\\n        return all([dp[i] <= (k - i) // 26 for i in range(1, 27)])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s, t, k):\\n        if len(s) != len(t): return False\\n        dp = [-1] * 27\\n        for a, b in zip(s, t):\\n            n = ord(b) - ord(a)\\n            dp[n if n >= 0 else 26 + n] += 1\\n        return all([dp[i] <= (k - i) // 26 for i in range(1, 27)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666958,
                "title": "c-easy-to-understand-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool canConvertString(string s, string t, int k) {\\n    if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool canConvertString(string s, string t, int k) {\\n    if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915299,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int round = k / 26;\\n        int remaining = k % 26;\\n        int[] record = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            if (i < remaining) {\\n                record[i] += 1;\\n            }\\n            record[i] += round;\\n        }\\n        for (int i = 0; i < s.length(); i++) {\\n            char c1 = s.charAt(i);\\n            char c2 = t.charAt(i);\\n            if (c1 == c2) continue;\\n            int index = (c2 - c1 + 26) % 26 - 1;\\n            if (record[index] > 0) {\\n                record[index] -= 1;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1409548,
                "title": "c-easy",
                "content": "```\\n\\n```public:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        vector<vector<int>>v(26);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int diff=t[i]-s[i];\\n            if(diff<0)\\n            {\\n                diff=diff+26;\\n            }\\n            if(diff!=0)\\n            {\\n                if(v[diff].size()==0)\\n                {\\n                    v[diff].push_back(diff);\\n                }\\n                else\\n                {\\n                    v[diff].push_back(v[diff].back()+26);\\n                    diff=v[diff].back();\\n                }\\n            }\\n            if(diff>k)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1315618,
                "title": "first-pass-with-len-s-second-pass-with-len-26-100-speed",
                "content": "Runtime: 260 ms, faster than 100.00% of Python3 online submissions for Can Convert String in K Moves.\\nMemory Usage: 15.7 MB, less than 16.67% of Python3 online submissions for Can Convert String in K Moves.\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        shifts = [0] * 26\\n        for a, b in zip(s, t):\\n            shifts[(ord(b) - ord(a)) % 26] += 1\\n        for j, n in enumerate(shifts):\\n            if j > 0 and n > 0 and j + (n - 1) * 26 > k:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        shifts = [0] * 26\\n        for a, b in zip(s, t):\\n            shifts[(ord(b) - ord(a)) % 26] += 1\\n        for j, n in enumerate(shifts):\\n            if j > 0 and n > 0 and j + (n - 1) * 26 > k:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092769,
                "title": "c-easy-solution",
                "content": "```\\nbool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())\\n            return false;\\n        map<int,int> mp;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(t[i]-s[i]<0)\\n                mp[t[i]-s[i]+26]++;\\n            else if(t[i]-s[i]>0)\\n                mp[t[i]-s[i]]++;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if((it->second-1)*26+it->first>k)\\n                return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())\\n            return false;\\n        map<int,int> mp;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(t[i]-s[i]<0)\\n                mp[t[i]-s[i]+26]++;\\n            else if(t[i]-s[i]>0)\\n                mp[t[i]-s[i]]++;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if((it->second-1)*26+it->first>k)\\n                return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1059413,
                "title": "java-faster-than-100-o-n-time-complexity",
                "content": "\\n\\nclass Solution {\\n#####  public boolean canConvertString(String s, String t, int k) {\\n        char[] sref=s.toCharArray();            //Converting string to char Array\\n        char[] tref=t.toCharArray();            //Converting string to char Array\\n         int len=sref.length;\\n        if(len!=tref.length) return false;     //Base case\\n        int[] count=new int[26];                //Maximum difference we can get is 26\\n\\t\\tfor(int i=0;i<len;i++){\\n            if(tref[i]==sref[i]) continue;\\n            int temp=tref[i]-sref[i];\\n            if(temp<0) temp=temp+26;\\n            count[temp]++;                                  // Increment the count\\n            temp=temp+(26*(count[temp]-1));                 //value which it needs\\n            if(temp>k) return false;                         //compare with the k value\\n        }\\n        return true;\\n       \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n#####  public boolean canConvertString(String s, String t, int k) {\\n        char[] sref=s.toCharArray();            //Converting string to char Array\\n        char[] tref=t.toCharArray();            //Converting string to char Array\\n         int len=sref.length;\\n        if(len!=tref.length) return false;     //Base case\\n        int[] count=new int[26];                //Maximum difference we can get is 26\\n\\t\\tfor(int i=0;i<len;i++){\\n            if(tref[i]==sref[i]) continue;\\n            int temp=tref[i]-sref[i];\\n            if(temp<0) temp=temp+26;\\n            count[temp]++;                                  // Increment the count\\n            temp=temp+(26*(count[temp]-1));                 //value which it needs\\n            if(temp>k) return false;                         //compare with the k value\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 988808,
                "title": "c-60-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(const string& s, const string& t, int k) {\\n        \\n        if(s.size()!=t.size()) return false;\\n        \\n        int shift=0;\\n        vector<int> v(26);\\n        for(int i=0; i<s.size(); ++i) {\\n            if(s[i]!=t[i]) {\\n                shift=s[i]<t[i]?t[i]-s[i]:t[i]-s[i]+26;\\n                shift+=26*v[shift]++;\\n                if(k-shift<0) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(const string& s, const string& t, int k) {\\n        \\n        if(s.size()!=t.size()) return false;\\n        \\n        int shift=0;\\n        vector<int> v(26);\\n        for(int i=0; i<s.size(); ++i) {\\n            if(s[i]!=t[i]) {\\n                shift=s[i]<t[i]?t[i]-s[i]:t[i]-s[i]+26;\\n                shift+=26*v[shift]++;\\n                if(k-shift<0) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888012,
                "title": "python3-o-n-solution-beats-99",
                "content": "```py\\nimport collections\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        # check lengths\\n        n1 = len(s)\\n        n2 = len(t)\\n        if n1 != n2:\\n            return False\\n        n = n1\\n        \\n        # find diffArray\\n        diffArray = [(ord(t[i])-ord(s[i]))%26 for i in range(n)]\\n       \\n        # frequency of difference\\n        cda = collections.Counter(diffArray)\\n        \\n        # delete 0\\n        del cda[0]\\n        \\n        minK = 0\\n        if len(cda) > 0 :\\n            key = max([(i[1], i[0])for i in cda.items()])\\n            minK = (key[0] - 1) *26 + key[1]\\n        \\n        return k >= minK\\n```",
                "solutionTags": [],
                "code": "```py\\nimport collections\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        # check lengths\\n        n1 = len(s)\\n        n2 = len(t)\\n        if n1 != n2:\\n            return False\\n        n = n1\\n        \\n        # find diffArray\\n        diffArray = [(ord(t[i])-ord(s[i]))%26 for i in range(n)]\\n       \\n        # frequency of difference\\n        cda = collections.Counter(diffArray)\\n        \\n        # delete 0\\n        del cda[0]\\n        \\n        minK = 0\\n        if len(cda) > 0 :\\n            key = max([(i[1], i[0])for i in cda.items()])\\n            minK = (key[0] - 1) *26 + key[1]\\n        \\n        return k >= minK\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887066,
                "title": "python3-o-n-solution-can-convert-string-in-k-moves",
                "content": "Find the largest character among those who have the highest frequency. The min steps required is the `(freq - 1) * 26 + ord(char)`.\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        distance = Counter((ord(b) - ord(a)) % 26 for a, b in zip(s, t) if a != b)\\n        maxf = [-1, -1]\\n        for c, f in distance.items():\\n            if f > maxf[1] or f == maxf[1] and c > maxf[0]:\\n                maxf[0] = c\\n                maxf[1] = f\\n        return not distance or ((maxf[1] - 1) * 26 + maxf[0]) <= k\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        distance = Counter((ord(b) - ord(a)) % 26 for a, b in zip(s, t) if a != b)\\n        maxf = [-1, -1]\\n        for c, f in distance.items():\\n            if f > maxf[1] or f == maxf[1] and c > maxf[0]:\\n                maxf[0] = c\\n                maxf[1] = f\\n        return not distance or ((maxf[1] - 1) * 26 + maxf[0]) <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881844,
                "title": "c-99-faster-simple-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        \\n        vector<int> changes(26, 0);\\n        for(int i=0;i<s.size();i++){\\n            if(t[i]!=s[i])\\n            changes[ (t[i]-s[i]+26)%26]++;\\n        }\\n        \\n        for(int i=1; i<changes.size(); i++){\\n            int diff = i + (26 * (changes[i]-1));\\n            if(diff > k) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        \\n        vector<int> changes(26, 0);\\n        for(int i=0;i<s.size();i++){\\n            if(t[i]!=s[i])\\n            changes[ (t[i]-s[i]+26)%26]++;\\n        }\\n        \\n        for(int i=1; i<changes.size(); i++){\\n            int diff = i + (26 * (changes[i]-1));\\n            if(diff > k) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822842,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length()) return false;\\n        vector<int> vi(27, 0);\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (t[i] > s[i]) vi[t[i] - s[i]]++;\\n            else vi[t[i] - s[i] + 26]++;\\n        }\\n        for (int i = 1; i < 26; ++i) {\\n            if (i + (vi[i] - 1) * 26 > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length()) return false;\\n        vector<int> vi(27, 0);\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (t[i] > s[i]) vi[t[i] - s[i]]++;\\n            else vi[t[i] - s[i] + 26]++;\\n        }\\n        for (int i = 1; i < 26; ++i) {\\n            if (i + (vi[i] - 1) * 26 > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 814681,
                "title": "very-eazy-and-clear-python-3-solution-o-n",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n\\t\\t# checking edge cases\\n        if len(s) != len(t):\\n            return False\\n        if s == t:\\n            return True\\n        \\n\\t\\t\\n        s = list(s)\\n        t = list(t)\\n        \\n        used = {} # creating dictionary or ditances which were used\\n        for i in range(len(s)):\\n            if s[i] != t[i]:  # if these letter are the same we don\\'t care about them\\n                diff = (ord(t[i]) - ord(s[i]))%26  \\n\\n                if diff > k:\\n                    return False\\n                \\n                if diff not in used:\\n                    used[diff] = 1    \\n                else:\\n                    if diff + 26*used[diff] <= k:  # we can wrap around adding 26 steps\\n                        used[diff] += 1\\n                    else:\\n                        return False   # if we don\\'t have what we need \\n        \\n        return True   # we went through strings and everything is OK\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n\\t\\t# checking edge cases\\n        if len(s) != len(t):\\n            return False\\n        if s == t:\\n            return True\\n        \\n\\t\\t\\n        s = list(s)\\n        t = list(t)\\n        \\n        used = {} # creating dictionary or ditances which were used\\n        for i in range(len(s)):\\n            if s[i] != t[i]:  # if these letter are the same we don\\'t care about them\\n                diff = (ord(t[i]) - ord(s[i]))%26  \\n\\n                if diff > k:\\n                    return False\\n                \\n                if diff not in used:\\n                    used[diff] = 1    \\n                else:\\n                    if diff + 26*used[diff] <= k:  # we can wrap around adding 26 steps\\n                        used[diff] += 1\\n                    else:\\n                        return False   # if we don\\'t have what we need \\n        \\n        return True   # we went through strings and everything is OK\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 800729,
                "title": "java-hashmap-solution",
                "content": "```\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0;i < s.length();i++){\\n            int d = getOp(s.charAt(i),t.charAt(i));\\n            if(d == 0) continue;\\n            int op = map.getOrDefault(d,0)*26 + d;\\n            if(op > k) return false;\\n            map.put(d,map.getOrDefault(d,0) + 1);\\n        }\\n        return true;\\n    }\\n    public int getOp(char in,char out){\\n        if(in <= out){\\n            return out - in;\\n        }else{\\n            return (\\'z\\' - in + (out - \\'a\\' + 1));\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0;i < s.length();i++){\\n            int d = getOp(s.charAt(i),t.charAt(i));\\n            if(d == 0) continue;\\n            int op = map.getOrDefault(d,0)*26 + d;\\n            if(op > k) return false;\\n            map.put(d,map.getOrDefault(d,0) + 1);\\n        }\\n        return true;\\n    }\\n    public int getOp(char in,char out){\\n        if(in <= out){\\n            return out - in;\\n        }else{\\n            return (\\'z\\' - in + (out - \\'a\\' + 1));\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 800282,
                "title": "c-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()) return false;\\n        unordered_map<int,int>mp;\\n        int left=k%26;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==t[i]) continue;\\n            int req;\\n            if(s[i]<t[i]){\\n                req=t[i]-s[i];\\n            }else{\\n                req=t[i]-\\'a\\'+(\\'z\\'-s[i])+1;\\n            }\\n            if(req>k) return false;\\n            mp[req]++;\\n            int max=k/26;\\n            if(req<=left) max++;\\n            if(mp[req]>max) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()) return false;\\n        unordered_map<int,int>mp;\\n        int left=k%26;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==t[i]) continue;\\n            int req;\\n            if(s[i]<t[i]){\\n                req=t[i]-s[i];\\n            }else{\\n                req=t[i]-\\'a\\'+(\\'z\\'-s[i])+1;\\n            }\\n            if(req>k) return false;\\n            mp[req]++;\\n            int max=k/26;\\n            if(req<=left) max++;\\n            if(mp[req]>max) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793074,
                "title": "simple-c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length())   return false;\\n        map<int, int> vmap;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] != t[i]) {\\n                int diff;\\n                if (t[i] > s[i]) diff = t[i] - s[i];\\n                else diff = t[i] - s[i] + 26;\\n                vmap[diff]++;\\n            }\\n        }\\n        if (vmap.empty())   return true;\\n        for (map<int, int> :: iterator it = vmap.begin(); it != vmap.end(); it++) {\\n            \\n            if (((it->second - 1) * 26) + it->first > k) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length())   return false;\\n        map<int, int> vmap;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] != t[i]) {\\n                int diff;\\n                if (t[i] > s[i]) diff = t[i] - s[i];\\n                else diff = t[i] - s[i] + 26;\\n                vmap[diff]++;\\n            }\\n        }\\n        if (vmap.empty())   return true;\\n        for (map<int, int> :: iterator it = vmap.begin(); it != vmap.end(); it++) {\\n            \\n            if (((it->second - 1) * 26) + it->first > k) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784683,
                "title": "python-3-explained",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \"\"\"\\n        This program determines whether string can be converted\\n        to string t within k moves.\\n\\n        :param s: string to be converted\\n        :type s: str\\n        :param t: target string\\n        :type t: str\\n        :param k: maximum number of moves allowed\\n        :type k: int\\n        :return: True if conversion possible within k moves,\\n                 else False\\n        :rtype: bool\\n        \"\"\"\\n\\n        \"\"\"\\n        Base Case:\\n        - If strings s and t are different lengths, return False.\\n        \"\"\"\\n        if len(s) != len(t):\\n            return False\\n\\n        \"\"\"\\n        Determine whether conversion from s to t is possible\\n        within k moves:\\n        - The shift map (shift_map) maps a shift count to the\\n          maximum number of moves needed to complete all moves\\n          with this shift count. If there are multiple moves\\n          with the same shift count, the first shift is executed\\n          at move \"shift count\". The second shift is executed 26\\n          moves, the third one 26 moves after the second, and so\\n          on.\\n        - If the maximum number of moves for a shift count exceeds\\n          k, return False.\\n        - If the analysis of strings s and t is completed without\\n          exceeding k moves, return True.\\n        \"\"\"\\n        shift_map = {}\\n        for j, s_chr in enumerate(s):\\n            if s_chr != t[j]:\\n                shift = ord(t[j]) - ord(s_chr)\\n                if shift < 0:\\n                    shift += 26\\n                if shift:\\n                    if shift in shift_map:\\n                        shift_map[shift] += 26\\n                    else:\\n                        shift_map[shift] = shift\\n                    if shift_map[shift] > k:\\n                        return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \"\"\"\\n        This program determines whether string can be converted\\n        to string t within k moves.\\n\\n        :param s: string to be converted\\n        :type s: str\\n        :param t: target string\\n        :type t: str\\n        :param k: maximum number of moves allowed\\n        :type k: int\\n        :return: True if conversion possible within k moves,\\n                 else False\\n        :rtype: bool\\n        \"\"\"\\n\\n        \"\"\"\\n        Base Case:\\n        - If strings s and t are different lengths, return False.\\n        \"\"\"\\n        if len(s) != len(t):\\n            return False\\n\\n        \"\"\"\\n        Determine whether conversion from s to t is possible\\n        within k moves:\\n        - The shift map (shift_map) maps a shift count to the\\n          maximum number of moves needed to complete all moves\\n          with this shift count. If there are multiple moves\\n          with the same shift count, the first shift is executed\\n          at move \"shift count\". The second shift is executed 26\\n          moves, the third one 26 moves after the second, and so\\n          on.\\n        - If the maximum number of moves for a shift count exceeds\\n          k, return False.\\n        - If the analysis of strings s and t is completed without\\n          exceeding k moves, return True.\\n        \"\"\"\\n        shift_map = {}\\n        for j, s_chr in enumerate(s):\\n            if s_chr != t[j]:\\n                shift = ord(t[j]) - ord(s_chr)\\n                if shift < 0:\\n                    shift += 26\\n                if shift:\\n                    if shift in shift_map:\\n                        shift_map[shift] += 26\\n                    else:\\n                        shift_map[shift] = shift\\n                    if shift_map[shift] > k:\\n                        return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782490,
                "title": "java-easy-solution-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        List<Integer> li=new ArrayList<>();\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=t.charAt(i)){\\n                int diff=t.charAt(i)-s.charAt(i);\\n                // System.out.println(t.charAt(i)+\" \"+diff+\" \"+s.charAt(i));\\n                if(diff<0){\\n                    diff=diff+26;\\n                }\\n                int a=diff;\\n                int v=0;\\n                if(li.contains(diff)){\\n                    v=map.get(a);\\n                    diff=v+26;\\n                }\\n                map.put(a,diff);\\n                if(k>=diff){\\n                \\n                    li.add(diff);\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 781657,
                "title": "java-simple-o-n-time-constant-space-solution",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int[] arr=new int[26];\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=get(s.charAt(i),t.charAt(i));\\n            if(a!=0)\\n            {\\n                arr[a]++;\\n                a=(arr[a]-1)*26+a;\\n            }\\n            if(a>k)return false;\\n        }\\n        return true;\\n    }\\n    public int get(char a,char b)\\n    {   if(a==b)return 0;\\n        if(b>a)return b-a;\\n        return b+26-a;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int[] arr=new int[26];\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=get(s.charAt(i),t.charAt(i));\\n            if(a!=0)\\n            {\\n                arr[a]++;\\n                a=(arr[a]-1)*26+a;\\n            }\\n            if(a>k)return false;\\n        }\\n        return true;\\n    }\\n    public int get(char a,char b)\\n    {   if(a==b)return 0;\\n        if(b>a)return b-a;\\n        return b+26-a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780785,
                "title": "easy-c-solution-using-hashmap-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())return false;\\n        unordered_map<long long int,long long int>mp;\\n        vector<long long int>ans;\\n        for(int i=0;i<t.size();i++)\\n        {\\n\\t\\t\\t\\t if(s[i]!=t[i])\\n\\t\\t\\t\\t {\\n\\t\\t\\t\\t  long long int req = s[i]<t[i] ? t[i]-s[i] : 26+t[i]-s[i];\\n\\t\\t\\t\\t  if(req>k)return false;\\n\\t\\t\\t\\t\\t\\t  if(mp.find(req)!=mp.end()) {\\n\\t\\t\\t\\t\\t\\t   mp[req]+=26;\\n\\t\\t\\t\\t\\t\\t   if(mp[req]>k)return false;\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t\\t  else{\\n\\t\\t\\t\\t\\t\\t\\t\\tmp[req]=req;\\n\\t\\t\\t\\t\\t\\t\\t   if(req>k)return false;\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())return false;\\n        unordered_map<long long int,long long int>mp;\\n        vector<long long int>ans;\\n        for(int i=0;i<t.size();i++)\\n        {\\n\\t\\t\\t\\t if(s[i]!=t[i])\\n\\t\\t\\t\\t {\\n\\t\\t\\t\\t  long long int req = s[i]<t[i] ? t[i]-s[i] : 26+t[i]-s[i];\\n\\t\\t\\t\\t  if(req>k)return false;\\n\\t\\t\\t\\t\\t\\t  if(mp.find(req)!=mp.end()) {\\n\\t\\t\\t\\t\\t\\t   mp[req]+=26;\\n\\t\\t\\t\\t\\t\\t   if(mp[req]>k)return false;\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t\\t  else{\\n\\t\\t\\t\\t\\t\\t\\t\\tmp[req]=req;\\n\\t\\t\\t\\t\\t\\t\\t   if(req>k)return false;\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780454,
                "title": "javascript-python3-c-add-del-needs",
                "content": "**Synopsis:**\\n\\nUse a hash table to track `needs`.  Return `true` if and only if there are no `needs`.  There are three use cases to consider when calculating `needs` by comparing the difference (ie. `k`) between each i-th character\\'s ordinal value in `s` and `t`:\\n\\n* **Case 1:** the difference is 0, then there\\'s no need to perform any rotation, since the characters are the same\\n* **Case 2:** the difference is a positive value `x`, this means that the character `s[i]` occurs *before* the character `t[i]` lexicographically in the english latin alphabet, and so we can safely add 26 onto `x` because when we mod by 26, we end up with the same value, ie `x == (x + 26) % 26`.  (Try plugging in some positive values for `x` if you don\\'t believe me.)  Since adding 26 then mod\\'ing by 26 is a no-op for case 2, one may wonder \"what\\'s the point?\"  The purpose of adding by 26 is for case 3, the \"wrap-around\" case.\\n* **Case 3:** the difference is a negative value, this means that the character `s[i]` occurs *after* the character `t[i]` lexicographically in the english latin alphabet, per the problem statement, when we rotate this character, it \"wraps-around\" upon reaching `z` back to `a`.  So the \"wrap-around\" length is taken into account by adding 26 onto the negative value.  The result is a positive value `y` which is less than 26, and so we can safely mod `y` by 26 because any value less than 26 mod by 26 is that same value, ie. if `0 < y < 26`, then `y == y % 26`\\n\\nIn general, we can think of the difference (ie. `k`) as buckets between 1..25 inclusive which track the count of each i-th character rotation needed to transform `s` to `t` per the rules of the problem statement.\\n\\n---\\n\\n**Screenshare:** https://www.youtube.com/watch?v=xuyvk8ycHFs\\n\\n---\\n\\n**Verbose Solutions:**\\n\\n*Javascript*\\n```\\nlet canConvertString = (s, t, K, need = {}, needs = 0) => {\\n    if (s.length != t.length)\\n        return false;\\n    // \\u2705 add needs\\n    for (let i = 0; i < s.length; ++i) {\\n        let diff = (t[i].charCodeAt(0) - s[i].charCodeAt(0) + 26) % 26;\\n        if (diff)\\n            need[diff] = need[diff] ? 1 + need[diff] : 1, ++needs;\\n    }\\n    // \\uD83D\\uDEAB del needs\\n    for (let i = 1; i <= K && needs; ++i) {\\n        let diff = i % 26;\\n        if (need[diff])\\n            --need[diff], --needs;\\n    }\\n    return !needs; // \\uD83C\\uDFAF no needs\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, K: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        need, needs = {}, 0\\n        # \\u2705 add needs \\n        for i in range(len(s)):\\n            diff = (ord(t[i]) - ord(s[i]) + 26) % 26\\n            if diff:\\n                if not diff in need:\\n                    need[diff] = 0\\n                need[diff] += 1\\n                needs += 1\\n        # \\uD83D\\uDEAB del needs\\n        for i in range(1, K + 1):\\n            if not needs:\\n                break\\n            diff = i % 26\\n            if diff in need and need[diff]:\\n                need[diff] -= 1\\n                needs -= 1\\n        return not needs # \\uD83C\\uDFAF no needs\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<int, int>;\\n    bool canConvertString(string s, string t, int K, Map need = {}, int needs = 0) {\\n        if (s.size() != t.size())\\n            return false;\\n        // \\u2705 add needs\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto diff = (t[i] - s[i] + 26) % 26;\\n            if (diff)\\n                ++need[diff], ++needs;\\n        }\\n        // \\uD83D\\uDEAB del needs\\n        for (auto i{ 1 }; i <= K && needs; ++i) {\\n            auto diff = i % 26;\\n            if (need[diff])\\n                --need[diff], --needs;\\n        }\\n        return !needs; // \\uD83C\\uDFAF no needs\\n    }\\n};\\n```\\n\\n---\\n\\n**Concise Solutions:** it is naive to continually iterate i to find needs to delete because we know we need to rotate each k-th need bucket by 26 (ie. the cardinality of the latin alphabet) for each bucket count greater than 1.  For example to transform `aa` to `bb`, we need 1 rotation for the first difference in this bucket, plus (1 * 26) rotations for the remaining differences in this bucket for a total of 27 rotations.  Similiarly to transform `aaa` to `bbb`, we need 1 rotation for the first difference in this bucket, plus (2 * 26) rotations for the remaining differences in this bucket for a total of 53 rotations, etc, etc...\\n\\n*Javascript*\\n```\\nlet canConvertString = (s, t, T, need = {}) => {\\n    if (s.length != t.length)\\n        return false;\\n    // \\u2705 add needs\\n    for (let i = 0; i < s.length; ++i) {\\n        let k = (t[i].charCodeAt(0) - s[i].charCodeAt(0) + 26) % 26;\\n        if (k)\\n            need[k] = need[k] ? 1 + need[k] : 1;\\n    }\\n    // check if T is \\uD83D\\uDEAB insufficient for the needs\\n    for (let [k, cnt] of Object.entries(need))\\n        if (T < Number(k) + (cnt - 1) * 26)\\n            return false;\\n    return true; // \\uD83C\\uDFAF T is sufficient for the needs\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, T: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        need = {}\\n        # \\u2705 add needs \\n        for i in range(len(s)):\\n            k = (ord(t[i]) - ord(s[i])) % 26\\n            if k:\\n                if not k in need:\\n                    need[k] = 0\\n                need[k] += 1\\n        # check if T is \\uD83D\\uDEAB insufficient for the needs\\n        for k, cnt in need.items():\\n            if T < k + (cnt - 1) * 26:\\n                return False\\n        return True # \\uD83C\\uDFAF T is sufficient for the needs\\n```\\n\\n*C++*\\n```\\npublic:\\n    using Map = unordered_map<int, int>;\\n    bool canConvertString(string s, string t, int T, Map need = {}) {\\n        if (s.size() != t.size())\\n            return false;\\n        // \\u2705 add needs\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto k = (t[i] - s[i] + 26) % 26;\\n            if (k)\\n                ++need[k];\\n        }\\n        // check if T is \\uD83D\\uDEAB insufficient for the needs\\n        for (auto [k, cnt]: need)\\n            if (T < k + (cnt - 1) * 26)\\n                return false;\\n        return true; // \\uD83C\\uDFAF T is sufficient for the needs\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nlet canConvertString = (s, t, K, need = {}, needs = 0) => {\\n    if (s.length != t.length)\\n        return false;\\n    // \\u2705 add needs\\n    for (let i = 0; i < s.length; ++i) {\\n        let diff = (t[i].charCodeAt(0) - s[i].charCodeAt(0) + 26) % 26;\\n        if (diff)\\n            need[diff] = need[diff] ? 1 + need[diff] : 1, ++needs;\\n    }\\n    // \\uD83D\\uDEAB del needs\\n    for (let i = 1; i <= K && needs; ++i) {\\n        let diff = i % 26;\\n        if (need[diff])\\n            --need[diff], --needs;\\n    }\\n    return !needs; // \\uD83C\\uDFAF no needs\\n};\\n```\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, K: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        need, needs = {}, 0\\n        # \\u2705 add needs \\n        for i in range(len(s)):\\n            diff = (ord(t[i]) - ord(s[i]) + 26) % 26\\n            if diff:\\n                if not diff in need:\\n                    need[diff] = 0\\n                need[diff] += 1\\n                needs += 1\\n        # \\uD83D\\uDEAB del needs\\n        for i in range(1, K + 1):\\n            if not needs:\\n                break\\n            diff = i % 26\\n            if diff in need and need[diff]:\\n                need[diff] -= 1\\n                needs -= 1\\n        return not needs # \\uD83C\\uDFAF no needs\\n```\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<int, int>;\\n    bool canConvertString(string s, string t, int K, Map need = {}, int needs = 0) {\\n        if (s.size() != t.size())\\n            return false;\\n        // \\u2705 add needs\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto diff = (t[i] - s[i] + 26) % 26;\\n            if (diff)\\n                ++need[diff], ++needs;\\n        }\\n        // \\uD83D\\uDEAB del needs\\n        for (auto i{ 1 }; i <= K && needs; ++i) {\\n            auto diff = i % 26;\\n            if (need[diff])\\n                --need[diff], --needs;\\n        }\\n        return !needs; // \\uD83C\\uDFAF no needs\\n    }\\n};\\n```\n```\\nlet canConvertString = (s, t, T, need = {}) => {\\n    if (s.length != t.length)\\n        return false;\\n    // \\u2705 add needs\\n    for (let i = 0; i < s.length; ++i) {\\n        let k = (t[i].charCodeAt(0) - s[i].charCodeAt(0) + 26) % 26;\\n        if (k)\\n            need[k] = need[k] ? 1 + need[k] : 1;\\n    }\\n    // check if T is \\uD83D\\uDEAB insufficient for the needs\\n    for (let [k, cnt] of Object.entries(need))\\n        if (T < Number(k) + (cnt - 1) * 26)\\n            return false;\\n    return true; // \\uD83C\\uDFAF T is sufficient for the needs\\n};\\n```\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, T: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        need = {}\\n        # \\u2705 add needs \\n        for i in range(len(s)):\\n            k = (ord(t[i]) - ord(s[i])) % 26\\n            if k:\\n                if not k in need:\\n                    need[k] = 0\\n                need[k] += 1\\n        # check if T is \\uD83D\\uDEAB insufficient for the needs\\n        for k, cnt in need.items():\\n            if T < k + (cnt - 1) * 26:\\n                return False\\n        return True # \\uD83C\\uDFAF T is sufficient for the needs\\n```\n```\\npublic:\\n    using Map = unordered_map<int, int>;\\n    bool canConvertString(string s, string t, int T, Map need = {}) {\\n        if (s.size() != t.size())\\n            return false;\\n        // \\u2705 add needs\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto k = (t[i] - s[i] + 26) % 26;\\n            if (k)\\n                ++need[k];\\n        }\\n        // check if T is \\uD83D\\uDEAB insufficient for the needs\\n        for (auto [k, cnt]: need)\\n            if (T < k + (cnt - 1) * 26)\\n                return false;\\n        return true; // \\uD83C\\uDFAF T is sufficient for the needs\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780288,
                "title": "c-o-n-solution-easy-to-understand",
                "content": "**\\nIt\\'s just iterate over the length of the strings....\\nfirst case : if length of both the strings are not same simply return false ;\\nSecond case : if both char are different take the differnce of the ASCII values of the char and if it less than 0 so you need to add the differnce(i.e is diff) to 26 + diff ....as we need to see clockwise rotation from a to z.\\nand the main part comes when it asks you about if differnce is repeated then what ? Then you just need to mantain a map or set something to keep frequency of the differnce how many times it is appearing ... and formula will be like diff = 26 * m[diff] + diff ..... see the code which will help you to understand more...and make a dry run which will help you more better\\n**\\n\\n*if liked my solution please upvote :D*\\n```\\nclass Solution {\\npublic:\\nbool canConvertString(string s, string t, int k)\\n{\\n\\tint n = s.length();\\n\\tint l = t.length();\\n\\n\\tif (n != l)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tmap<int, int> m;\\n\\t\\tint diff = 0;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tif (s[i] != t[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tdiff = t[i] - s[i];\\n\\t\\t\\t\\tif (diff < 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdiff = 26 + diff;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (diff <= k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (m.find(diff) == m.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tm.insert({diff, 1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint ans = 26 * m[diff] + diff;\\n\\t\\t\\t\\t\\tif (ans <= k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tm[diff]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\n\\t}\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nbool canConvertString(string s, string t, int k)\\n{\\n\\tint n = s.length();\\n\\tint l = t.length();\\n\\n\\tif (n != l)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tmap<int, int> m;\\n\\t\\tint diff = 0;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tif (s[i] != t[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tdiff = t[i] - s[i];\\n\\t\\t\\t\\tif (diff < 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdiff = 26 + diff;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (diff <= k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (m.find(diff) == m.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tm.insert({diff, 1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint ans = 26 * m[diff] + diff;\\n\\t\\t\\t\\t\\tif (ans <= k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tm[diff]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\n\\t}\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780084,
                "title": "c-o-n-time-o-1-space-explained",
                "content": "If length are not same return false.\\notherwise\\nThere are 3 possible cases for each chars at same index\\n1. if s[i] == t[i] then continue;\\n2. else find difference (if -ve add 26) which will be in range [0,25], for this we take 26 size array **step** to remember the which moves we have already taken, and update **step** for next possible move we can take.\\n**example:**\\ndiff = t[i]-s[i];\\nFor diff = 1, possible moves are 1, 27, 53 ...\\nFor diff = 2, possible moves are 2, 28, 54 ...\\nFor diff = 3, possible moves are 3, 29, 55 ... \\n.\\n.\\n.\\nFor diff = 25, possible moves are 25, 51, 77 ... \\n\\n3. Whenever we found the move we need for this is greater K return false. \\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()) return false;\\n        vector<int> step(27, 0);\\n        for(int i=1; i<27; ++i){\\n            step[i] = i;\\n        }\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            if(s[i] == t[i]) continue;\\n            \\n            int diff = t[i]-s[i];\\n            if(diff < 0) diff += 26;\\n            if(step[diff] <= k){\\n                step[diff] += 26;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()) return false;\\n        vector<int> step(27, 0);\\n        for(int i=1; i<27; ++i){\\n            step[i] = i;\\n        }\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            if(s[i] == t[i]) continue;\\n            \\n            int diff = t[i]-s[i];\\n            if(diff < 0) diff += 26;\\n            if(step[diff] <= k){\\n                step[diff] += 26;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780078,
                "title": "python-dictionary-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\t\\t\\tif len(s) != len(t):\\n\\t\\t\\t\\treturn False\\n\\t\\t\\td = {}\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif t[i] != s[i]:\\n\\t\\t\\t\\t\\tif t[i] > s[i]:\\n\\t\\t\\t\\t\\t\\tdiff = ord(t[i]) - ord(s[i])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdiff = ord(t[i]) + 26 - ord(s[i])\\n\\t\\t\\t\\t\\tif diff > k:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tif diff not in d:\\n\\t\\t\\t\\t\\t\\t\\td[diff] = diff\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tif d[diff] + 26 > k:\\n\\t\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\t\\td[diff] += 26\\n\\t\\t\\treturn True",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\t\\t\\tif len(s) != len(t):\\n\\t\\t\\t\\treturn False\\n\\t\\t\\td = {}",
                "codeTag": "Java"
            },
            {
                "id": 779965,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int[] hash = new int[26];\\n        Arrays.fill(hash,k / 26);\\n        int offset = k % 26;\\n        for(int i=0;i<=offset;++i) hash[i]++;\\n        for(int i=0;i<s.length();++i){\\n            if(s.charAt(i) != t.charAt(i)){\\n                int c1 = s.charAt(i) - \\'a\\' + 1;\\n                int c2 = t.charAt(i) - \\'a\\' + 1;\\n                int m = 0;\\n                if(c1 <= c2){\\n                    m = c2 - c1;\\n                }else{\\n                    m = 26 - c1 + c2;\\n                }\\n                \\n                if(hash[m]-- <= 0) return false;        \\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int[] hash = new int[26];\\n        Arrays.fill(hash,k / 26);\\n        int offset = k % 26;\\n        for(int i=0;i<=offset;++i) hash[i]++;\\n        for(int i=0;i<s.length();++i){\\n            if(s.charAt(i) != t.charAt(i)){\\n                int c1 = s.charAt(i) - \\'a\\' + 1;\\n                int c2 = t.charAt(i) - \\'a\\' + 1;\\n                int m = 0;\\n                if(c1 <= c2){\\n                    m = c2 - c1;\\n                }else{\\n                    m = 26 - c1 + c2;\\n                }\\n                \\n                if(hash[m]-- <= 0) return false;        \\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779961,
                "title": "c-dictionary",
                "content": "Runtime: 224 ms\\nMemory Usage: 40.2 MB\\n\\n```\\n\\n    public bool CanConvertString(string s, string t, int k) {\\n        if (s.Length != t.Length) { return false; }\\n        \\n        int alphaLength = \\'z\\'-\\'a\\'+1;\\n        \\n        Dictionary<int, int> distance = new Dictionary<int, int>();\\n        int moves;\\n        \\n        for(int i=0; i<s.Length; i++)\\n        {\\n            if (s[i] == t[i]) { continue; }\\n            \\n            if (s[i] < t[i]) \\n            {  \\n                moves = t[i] - s[i]; \\n            }\\n            else\\n            {\\n                moves = alphaLength - (s[i] - t[i]); \\n            }\\n           \\n            if (moves > k) { return false; }\\n            \\n            if (!distance.ContainsKey(moves)) { distance[moves] = 0; }\\n            distance[moves]++;\\n        }\\n        \\n        foreach(int key in distance.Keys)\\n        {\\n            if (distance[key] == 1) { continue; }\\n            if (key + ((distance[key]-1) * alphaLength) > k) { return false; }\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 224 ms\\nMemory Usage: 40.2 MB\\n\\n```\\n\\n    public bool CanConvertString(string s, string t, int k) {\\n        if (s.Length != t.Length) { return false; }\\n        \\n        int alphaLength = \\'z\\'-\\'a\\'+1;\\n        \\n        Dictionary<int, int> distance = new Dictionary<int, int>();\\n        int moves;\\n        \\n        for(int i=0; i<s.Length; i++)\\n        {\\n            if (s[i] == t[i]) { continue; }\\n            \\n            if (s[i] < t[i]) \\n            {  \\n                moves = t[i] - s[i]; \\n            }\\n            else\\n            {\\n                moves = alphaLength - (s[i] - t[i]); \\n            }\\n           \\n            if (moves > k) { return false; }\\n            \\n            if (!distance.ContainsKey(moves)) { distance[moves] = 0; }\\n            distance[moves]++;\\n        }\\n        \\n        foreach(int key in distance.Keys)\\n        {\\n            if (distance[key] == 1) { continue; }\\n            if (key + ((distance[key]-1) * alphaLength) > k) { return false; }\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4091920,
                "title": "simple-c-solution-o-n-time-and-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        vector<int> diff(26,0);\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]!=t[i]){\\n                int d = (t[i] - s[i] + 26)%26;\\n                int n1 = 26*diff[d] + d;\\n                if(n1<=k){\\n                    diff[d]++;\\n                }\\n                else return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        vector<int> diff(26,0);\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]!=t[i]){\\n                int d = (t[i] - s[i] + 26)%26;\\n                int n1 = 26*diff[d] + d;\\n                if(n1<=k){\\n                    diff[d]++;\\n                }\\n                else return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084270,
                "title": "simple-c-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n\\n        int n = s.size();\\n        map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=t[i]){\\n                int x = (int)(t[i])-(int)(s[i]);\\n                if(x<0) x+=26;\\n                int m=26*mp[x];\\n                if(x+m>k) return 0;\\n                else{\\n                    mp[x]++;\\n                }\\n            }\\n        }\\n\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n\\n        int n = s.size();\\n        map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=t[i]){\\n                int x = (int)(t[i])-(int)(s[i]);\\n                if(x<0) x+=26;\\n                int m=26*mp[x];\\n                if(x+m>k) return 0;\\n                else{\\n                    mp[x]++;\\n                }\\n            }\\n        }\\n\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010225,
                "title": "c-hash-table-string",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())\\n        return false;\\n        if(s==t)\\n        return true;\\n        if(k==0)\\n        return false;\\n        int n = s.size();\\n        vector<int> diff(n);\\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            diff[i] = (t[i]-s[i]+26)%26;\\n            if(m.find(diff[i])!=m.end() && diff[i]!=0)\\n            {\\n                m[diff[i]]+=26;\\n                diff[i] = m[diff[i]];\\n            }\\n            else\\n            m[diff[i]] = diff[i];\\n        }\\n        sort(diff.begin(),diff.end());\\n        int mov = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(diff[i]==0)\\n            continue;\\n            if(mov<diff[i] && diff[i]<=k)\\n            {\\n                mov = diff[i];\\n            }\\n            else if(diff[i]+26>mov && diff[i]+26<=k)\\n            {\\n                mov = diff[i]+26;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())\\n        return false;\\n        if(s==t)\\n        return true;\\n        if(k==0)\\n        return false;\\n        int n = s.size();\\n        vector<int> diff(n);\\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            diff[i] = (t[i]-s[i]+26)%26;\\n            if(m.find(diff[i])!=m.end() && diff[i]!=0)\\n            {\\n                m[diff[i]]+=26;\\n                diff[i] = m[diff[i]];\\n            }\\n            else\\n            m[diff[i]] = diff[i];\\n        }\\n        sort(diff.begin(),diff.end());\\n        int mov = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(diff[i]==0)\\n            continue;\\n            if(mov<diff[i] && diff[i]<=k)\\n            {\\n                mov = diff[i];\\n            }\\n            else if(diff[i]+26>mov && diff[i]+26<=k)\\n            {\\n                mov = diff[i]+26;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002892,
                "title": "java-modulo-and-clean-code",
                "content": "# Approach\\n1. The key is to count how many group of modulos you have for the given k.\\n    - EG: 27: [1,2,3...26,27]. All of these % 26 would result [1,2,...1]. Two elements (1 and 27) % 26 = 1. So modulo[1] = 2.\\n2. For given k calculate the groups of modulos\\n3. Traverse s and t and for each index, if the chars are disting, calculate their distance.\\n    - a -> c = 2 ; y -> b = 3. \\n4. For each such distinct pair, deduct 1 from their modulo groups. If the modulo groups goes below 0, it means you do not have enough numbers to cover their modulos. \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(26)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (k == 0) {\\n            return s.equals(t);\\n        } else if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] modulos = getModulos(k);\\n        return canConvert(s, t, modulos);\\n    }\\n\\n    private boolean canConvert(String s, String t, int[] modulos) {\\n        char first, second;\\n        int distance;\\n        for (int i = 0; i < s.length(); i++) {\\n            first = s.charAt(i);\\n            second = t.charAt(i);\\n            if (first != second) {\\n                distance = first < second ? second - first : (26 - first) + second;\\n                if (--modulos[distance] < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int[] getModulos(int k) {\\n        int[] modulos = new int[26];\\n        int div = k / 26;\\n        Arrays.fill(modulos, div);\\n        k = k % 26;\\n        while (k >= 0) {\\n            modulos[k--]++;\\n        }\\n        return modulos;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (k == 0) {\\n            return s.equals(t);\\n        } else if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] modulos = getModulos(k);\\n        return canConvert(s, t, modulos);\\n    }\\n\\n    private boolean canConvert(String s, String t, int[] modulos) {\\n        char first, second;\\n        int distance;\\n        for (int i = 0; i < s.length(); i++) {\\n            first = s.charAt(i);\\n            second = t.charAt(i);\\n            if (first != second) {\\n                distance = first < second ? second - first : (26 - first) + second;\\n                if (--modulos[distance] < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int[] getModulos(int k) {\\n        int[] modulos = new int[26];\\n        int div = k / 26;\\n        Arrays.fill(modulos, div);\\n        k = k % 26;\\n        while (k >= 0) {\\n            modulos[k--]++;\\n        }\\n        return modulos;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999274,
                "title": "c-8-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we simply calculate the shift required for each character of s and and store it in an array of size 26. Then check if those many shift are possible or not within the given value of k.\\n\\nar[i] = x implies that there are x characters in string s that need a shift of i to match the charcters in string t.\\nNow it is given in the question that each shift can be used only once.\\nSo if two charcters need a shift of 1, only one of them will be allowed.\\nThe next charcter will get a shift of 1 + 26 which makes the efective shift to be 1.\\nEg: lets say s = \"aa\" and t = \"cc\"\\nThen ar[2] = 2\\nSo two characters need a net shift of 2. So the possible shifts are 2, 28, 54, .....\\nSince we need only two, so 2 and 28 are enough. Therefore our value of k should be atleast 28 .If not then return false immediately\\n\\n# Complexity\\n- Time complexity:O(s.length)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int ar[26] = {0};       \\n        for(int i = 0;i < s.length();i++){\\n            int shift = (t[i] - s[i] + 26) % 26;            \\n            ar[shift]++;\\n        }\\n        for(int i = 1;i <= 25;i++)\\n            if(i + (ar[i] - 1)*26 > k)\\n                return false;\\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int ar[26] = {0};       \\n        for(int i = 0;i < s.length();i++){\\n            int shift = (t[i] - s[i] + 26) % 26;            \\n            ar[shift]++;\\n        }\\n        for(int i = 1;i <= 25;i++)\\n            if(i + (ar[i] - 1)*26 > k)\\n                return false;\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956395,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  bool canConvertString(string s, string t, int k) {\\n    if (s.length() != t.length())\\n      return false;\\n\\n    // E.g. s = \"aab\", t = \"bbc\", so shiftCount[1] = 3\\n    // For a -> b, need 1 move\\n    //     a -> b, need 1 + 26 moves\\n    //     b -> c, need 1 + 26 * 2 moves\\n    vector<int> shiftCount(26);\\n\\n    for (int i = 0; i < s.length(); ++i)\\n      ++shiftCount[(t[i] - s[i] + 26) % 26];\\n\\n    for (int shift = 1; shift < 26; ++shift)\\n      if (shift + 26 * (shiftCount[shift] - 1) > k)\\n        return false;\\n\\n    return true;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool canConvertString(string s, string t, int k) {\\n    if (s.length() != t.length())\\n      return false;\\n\\n    // E.g. s = \"aab\", t = \"bbc\", so shiftCount[1] = 3\\n    // For a -> b, need 1 move\\n    //     a -> b, need 1 + 26 moves\\n    //     b -> c, need 1 + 26 * 2 moves\\n    vector<int> shiftCount(26);\\n\\n    for (int i = 0; i < s.length(); ++i)\\n      ++shiftCount[(t[i] - s[i] + 26) % 26];\\n\\n    for (int shift = 1; shift < 26; ++shift)\\n      if (shift + 26 * (shiftCount[shift] - 1) > k)\\n        return false;\\n\\n    return true;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903100,
                "title": "easy-to-understand-javascript-solution-hash-table",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(26)$$\\n\\n# Code\\n```\\nvar canConvertString = function(s, t, k) {\\n    if (s.length !== t.length) return false;\\n    const convertCounts = Array(26).fill(0);\\n\\n    for (let index = 0; index < s.length; index++) {\\n        const diff = (t.charCodeAt(index) - s.charCodeAt(index) + 26) % 26;\\n        \\n        if (!diff) continue;\\n        if (diff + convertCounts[diff] * 26 > k) return false;\\n        convertCounts[diff] += 1;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConvertString = function(s, t, k) {\\n    if (s.length !== t.length) return false;\\n    const convertCounts = Array(26).fill(0);\\n\\n    for (let index = 0; index < s.length; index++) {\\n        const diff = (t.charCodeAt(index) - s.charCodeAt(index) + 26) % 26;\\n        \\n        if (!diff) continue;\\n        if (diff + convertCounts[diff] * 26 > k) return false;\\n        convertCounts[diff] += 1;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3842294,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size()!=t.size()) return false;\\n        int n=s.size();\\n        int div=k/26;\\n        vector<int>temp(26,div);\\n        int rem=k%26;\\n        for (int i=0;i<=rem;i++) temp[i]++;   \\n        for (int i=0;i<n;i++)\\n        {\\n            if (s[i]!=t[i])\\n            {\\n                int diff=(t[i]-s[i]+26)%26;\\n                if (temp[diff]==0) return false;\\n                temp[diff]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size()!=t.size()) return false;\\n        int n=s.size();\\n        int div=k/26;\\n        vector<int>temp(26,div);\\n        int rem=k%26;\\n        for (int i=0;i<=rem;i++) temp[i]++;   \\n        for (int i=0;i<n;i++)\\n        {\\n            if (s[i]!=t[i])\\n            {\\n                int diff=(t[i]-s[i]+26)%26;\\n                if (temp[diff]==0) return false;\\n                temp[diff]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725131,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        vector<int> diffs(26,0);\\n        for(int i=0;i<26;i++){\\n            diffs[i]=i;\\n        }\\n        int n = s.size();\\n        int m = t.size();\\n        if(m!=n) return false;\\n        for(int i=0;i<n;i++){\\n            int diff = ((int)t[i] - (int)s[i]);\\n            if(diff==0) continue;\\n            else if(diff<0) diff+=26;\\n            if(diffs[diff]>k) return false;\\n            diffs[diff]+=26;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        vector<int> diffs(26,0);\\n        for(int i=0;i<26;i++){\\n            diffs[i]=i;\\n        }\\n        int n = s.size();\\n        int m = t.size();\\n        if(m!=n) return false;\\n        for(int i=0;i<n;i++){\\n            int diff = ((int)t[i] - (int)s[i]);\\n            if(diff==0) continue;\\n            else if(diff<0) diff+=26;\\n            if(diffs[diff]>k) return false;\\n            diffs[diff]+=26;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663184,
                "title": "python-check-max-counter-of-diff-o-n",
                "content": "```\\n\"\"\"\\nHere we just count of same diff, and then\\ncheck if the max difference*26 larger than k.\\n\\nBecause of each new +1 of same diff increases\\nour move by 26.\\n\\nTC: O(N)\\nSC: O(1)\\n\"\"\"\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        count = Counter()\\n        for a, b in zip(s, t):\\n            if a != b:\\n                count[(ord(b) - ord(a)) % 26] += 1\\n            \\n        m = 0\\n        for d, v in count.items():\\n            m = max(m, d + (v - 1)*26)\\n            if m > k:\\n                return False\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nHere we just count of same diff, and then\\ncheck if the max difference*26 larger than k.\\n\\nBecause of each new +1 of same diff increases\\nour move by 26.\\n\\nTC: O(N)\\nSC: O(1)\\n\"\"\"\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        count = Counter()\\n        for a, b in zip(s, t):\\n            if a != b:\\n                count[(ord(b) - ord(a)) % 26] += 1\\n            \\n        m = 0\\n        for d, v in count.items():\\n            m = max(m, d + (v - 1)*26)\\n            if m > k:\\n                return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598436,
                "title": "small-c-solution-100-runtime-and-100-memory",
                "content": "# Code\\n```\\n#pragma GCC optimize (\"-O3\", \"-march=native\")\\nbool canConvertString(char *s, char *t, int k) {\\n    int needed_shifts[26] = {};\\n    for (; *s && *t; ++s, ++t) ++needed_shifts[(*t - *s + 26) % 26];\\n    if (*s || *t) return false;\\n    for (int i = 1; i < 26; ++i) {\\n        if (i + (needed_shifts[i] - 1) * 26 > k) return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#pragma GCC optimize (\"-O3\", \"-march=native\")\\nbool canConvertString(char *s, char *t, int k) {\\n    int needed_shifts[26] = {};\\n    for (; *s && *t; ++s, ++t) ++needed_shifts[(*t - *s + 26) % 26];\\n    if (*s || *t) return false;\\n    for (int i = 1; i < 26; ++i) {\\n        if (i + (needed_shifts[i] - 1) * 26 > k) return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3552972,
                "title": "beats-100-must-see-approach-t-c-o-n-and-o-26-or-constant-space",
                "content": "# Intuition\\nto make a freq array and then look for value of k\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- O(n) -->\\n\\n- Space complexity:  O(26) \\n<!-- O(26) or basically it is constant -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n       <!-- for fast I/O -->\\n        std::ios_base::sync_with_stdio(false);\\n        std::cout.tie(nullptr);\\n        std::cin.tie(nullptr);\\n\\n        int n = s.length(), m = t.length();\\n        <!-- edge case -->\\n        if(n!=m) return false;\\n        vector<int > mp(27,0);\\n        <!-- if we got diff as 1 (increase freq of 1 at this point)then if we get another 1 then we look for k=27 i.e diff(1)+mp[diff](1)  then we take action according to value of k--> \\n\\n        for(int i =0;i<n;i++){\\n            int diff= (t[i]-s[i]+26)%26;\\n            if(diff!=0){\\n                if(diff+mp[diff]*26<=k){\\n                    mp[diff]++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n       <!-- for fast I/O -->\\n        std::ios_base::sync_with_stdio(false);\\n        std::cout.tie(nullptr);\\n        std::cin.tie(nullptr);\\n\\n        int n = s.length(), m = t.length();\\n        <!-- edge case -->\\n        if(n!=m) return false;\\n        vector<int > mp(27,0);\\n        <!-- if we got diff as 1 (increase freq of 1 at this point)then if we get another 1 then we look for k=27 i.e diff(1)+mp[diff](1)  then we take action according to value of k--> \\n\\n        for(int i =0;i<n;i++){\\n            int diff= (t[i]-s[i]+26)%26;\\n            if(diff!=0){\\n                if(diff+mp[diff]*26<=k){\\n                    mp[diff]++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3549991,
                "title": "find-the-residue-of-modulo",
                "content": "# Approach\\nif two strings have different length, can\\'t convert s to t for all k.\\nFind the modulo number of shifts by i and its upper bound for i = 1,2,...,25, meaning that do nothing for the residue\\'s. \\n\\n# Complexity\\n- Time complexity: O(n), n:length of s\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n            \\n        k += 1\\n        L = [0] * 26\\n        T = [k // 26] * 26\\n        k %= 26\\n\\n        for i in range(len(s)):\\n            L[ord(t[i])-ord(s[i])] += 1\\n        \\n        for i in range(k):\\n            T[i] += 1\\n\\n        for i in range(1, 26):\\n            if L[i] > T[i]:\\n                return False\\n        \\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n            \\n        k += 1\\n        L = [0] * 26\\n        T = [k // 26] * 26\\n        k %= 26\\n\\n        for i in range(len(s)):\\n            L[ord(t[i])-ord(s[i])] += 1\\n        \\n        for i in range(k):\\n            T[i] += 1\\n\\n        for i in range(1, 26):\\n            if L[i] > T[i]:\\n                return False\\n        \\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534281,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n  pub fn can_convert_string(s: String, t: String, k: i32) -> bool {\\n    if s.len() != t.len() {\\n      return false\\n    }\\n    let s = s.chars().into_iter().map(|v| v as usize - \\'a\\' as usize).collect::<Vec<usize>>();\\n    let t = t.chars().into_iter().map(|v| v as usize - \\'a\\' as usize).collect::<Vec<usize>>();\\n    let n = s.len();\\n    let k = k as usize;\\n    let mut memo = (0..26).into_iter().collect::<Vec<usize>>();\\n\\n    for i in 0..n {\\n      if s[i] < t[i] {\\n        let ti = t[i] - s[i];\\n        if memo[ti] > k {\\n          return false\\n        }\\n        memo[ti] += 26;\\n      } else if s[i] > t[i] {\\n        let ti = 26 - s[i] + t[i];\\n        if memo[ti] > k {\\n          return false\\n        }\\n        memo[ti] += 26;\\n      }\\n    }\\n    true\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn can_convert_string(s: String, t: String, k: i32) -> bool {\\n    if s.len() != t.len() {\\n      return false\\n    }\\n    let s = s.chars().into_iter().map(|v| v as usize - \\'a\\' as usize).collect::<Vec<usize>>();\\n    let t = t.chars().into_iter().map(|v| v as usize - \\'a\\' as usize).collect::<Vec<usize>>();\\n    let n = s.len();\\n    let k = k as usize;\\n    let mut memo = (0..26).into_iter().collect::<Vec<usize>>();\\n\\n    for i in 0..n {\\n      if s[i] < t[i] {\\n        let ti = t[i] - s[i];\\n        if memo[ti] > k {\\n          return false\\n        }\\n        memo[ti] += 26;\\n      } else if s[i] > t[i] {\\n        let ti = 26 - s[i] + t[i];\\n        if memo[ti] > k {\\n          return false\\n        }\\n        memo[ti] += 26;\\n      }\\n    }\\n    true\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524005,
                "title": "simple-c-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n     int l = s.length();\\n     int qwe = t.length();\\n\\n     if(l!=qwe){\\n         return 0;\\n     }\\n\\n    vector<int> alpha(27);\\n    vector<int> match(27);\\n    match[0] = INT_MAX;\\n    int n = k/26;\\n    int r = k%26;\\n\\n\\n    for(int i = 0; i<=26; i++){\\n         alpha[i] = 0;\\n     } \\n\\n     for(int i = 0; i<l; i++){\\n         if(t[i] - s[i] >= 0){\\n             int k = t[i] - s[i];\\n             alpha[k]++;\\n         }\\n         else{\\n             int k = t[i] - s[i] + 26;\\n             alpha[k]++;\\n         }\\n     }\\n\\n     \\n\\n     \\n     for(int i = 1; i<=26; i++){\\n         if(r>0){\\n             match[i] = n+1;\\n             r--;\\n         }\\n         else{\\n             match[i] = n;\\n         }\\n     }\\n\\n     for(int i = 1; i<=26; i++){\\n         if(match[i] - alpha[i]<0){\\n             return false;\\n         }\\n     }\\n     return true;\\n     \\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n     int l = s.length();\\n     int qwe = t.length();\\n\\n     if(l!=qwe){\\n         return 0;\\n     }\\n\\n    vector<int> alpha(27);\\n    vector<int> match(27);\\n    match[0] = INT_MAX;\\n    int n = k/26;\\n    int r = k%26;\\n\\n\\n    for(int i = 0; i<=26; i++){\\n         alpha[i] = 0;\\n     } \\n\\n     for(int i = 0; i<l; i++){\\n         if(t[i] - s[i] >= 0){\\n             int k = t[i] - s[i];\\n             alpha[k]++;\\n         }\\n         else{\\n             int k = t[i] - s[i] + 26;\\n             alpha[k]++;\\n         }\\n     }\\n\\n     \\n\\n     \\n     for(int i = 1; i<=26; i++){\\n         if(r>0){\\n             match[i] = n+1;\\n             r--;\\n         }\\n         else{\\n             match[i] = n;\\n         }\\n     }\\n\\n     for(int i = 1; i<=26; i++){\\n         if(match[i] - alpha[i]<0){\\n             return false;\\n         }\\n     }\\n     return true;\\n     \\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438162,
                "title": "fast-and-simple-solution-with-explanation-c",
                "content": "# Intuition\\nWe can convert *s* to *t* only if for every position *i* (*0 <= i < s.size()*) where *s[i] != t[i]* we can find a unique number *1 <= n <= k* such that *s[i] + (n % 26)  == t[i]*. (26 is the number of characters in english alphabet).\\n\\n# Approach\\nFirst we check sizes of the two strings. When they differ, we return false immidiately. Next, we iterate over the strings and count only chars that do differ. When difference is negative, we add 26 to it.\\n\\nIn the last step, we iterate over the summery map and check every position, where difference greater than 0. For example, when we have a difference 2 in 3 positions, we have to use numbers 2, 28 and 54 to close gaps in all three positions (2, 2 + 1 x 26, 2 + 2 x 26). When the maximal number do not exceeds k, we return true, otherwise false. \\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\tconst int alphabet_size = 26;\\n\\npublic:\\n\\tbool canConvertString(string s, string t, int k) {\\n\\t\\tif (s.size() != t.size()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tvector<int> movesMap(127, 0);\\n\\t\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\t\\tint diff = t[i] - s[i];\\n\\t\\t\\tif (diff > 0) {\\n\\t\\t\\t\\tmovesMap[diff]++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (diff < 0) {\\n\\t\\t\\t\\tmovesMap[alphabet_size + diff]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (movesMap.empty()) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < movesMap.size(); i++) {\\n\\t\\t\\tif ((movesMap[i] > 0) && (i + (movesMap[i] - 1) * alphabet_size > k)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\tconst int alphabet_size = 26;\\n\\npublic:\\n\\tbool canConvertString(string s, string t, int k) {\\n\\t\\tif (s.size() != t.size()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tvector<int> movesMap(127, 0);\\n\\t\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\t\\tint diff = t[i] - s[i];\\n\\t\\t\\tif (diff > 0) {\\n\\t\\t\\t\\tmovesMap[diff]++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (diff < 0) {\\n\\t\\t\\t\\tmovesMap[alphabet_size + diff]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (movesMap.empty()) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < movesMap.size(); i++) {\\n\\t\\t\\tif ((movesMap[i] > 0) && (i + (movesMap[i] - 1) * alphabet_size > k)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314788,
                "title": "and-c",
                "content": "C solution:\\n```\\nbool canConvertString(char * s, char * t, int k){\\n    if(strlen(s) != strlen(t))\\n        return false ;\\n    int n = strlen(s) ;\\n    int* count = calloc(26, sizeof(int)) ;\\n    for(int i = 0; i < n; i++){\\n        int d = (t[i] - s[i] + 26) % 26 ;\\n        count[d]++ ;\\n    }\\n    bool ret = true ;\\n    for(int i = 1; i < 26; i++){\\n        if(count[i] > 0){\\n            int max = i + (count[i]-1)*26 ;\\n            if(max > k){\\n                ret = false ;\\n                break ;\\n            }\\n        }\\n    }\\n    free(count) ;\\n    return ret ;\\n}\\n```\\n\\nC++ solution \\uFF1A\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size())\\n            return false ;\\n        int n = s.size() ;\\n        vector<int>count(26) ;\\n        for(int i = 0; i < n; i++){\\n            int d = (t[i] - s[i] + 26) % 26 ;\\n            count[d]++ ;\\n        }\\n        for(int i = 1 ; i < 26; i++){\\n            if(count[i] > 0){\\n                int max = i + 26 *(count[i] -1) ;\\n                if(max > k)\\n                    return false ;\\n            }\\n        }\\n        return true ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(char * s, char * t, int k){\\n    if(strlen(s) != strlen(t))\\n        return false ;\\n    int n = strlen(s) ;\\n    int* count = calloc(26, sizeof(int)) ;\\n    for(int i = 0; i < n; i++){\\n        int d = (t[i] - s[i] + 26) % 26 ;\\n        count[d]++ ;\\n    }\\n    bool ret = true ;\\n    for(int i = 1; i < 26; i++){\\n        if(count[i] > 0){\\n            int max = i + (count[i]-1)*26 ;\\n            if(max > k){\\n                ret = false ;\\n                break ;\\n            }\\n        }\\n    }\\n    free(count) ;\\n    return ret ;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size())\\n            return false ;\\n        int n = s.size() ;\\n        vector<int>count(26) ;\\n        for(int i = 0; i < n; i++){\\n            int d = (t[i] - s[i] + 26) % 26 ;\\n            count[d]++ ;\\n        }\\n        for(int i = 1 ; i < 26; i++){\\n            if(count[i] > 0){\\n                int max = i + 26 *(count[i] -1) ;\\n                if(max > k)\\n                    return false ;\\n            }\\n        }\\n        return true ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283787,
                "title": "short-and-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int,int>mp;\\n        if(s.size()!=t.size()) return false;\\n        for(int i=0;i<s.size();i++){\\n           int x=(t[i]-s[i]+26)%26;\\n           if(x!=0){\\n               int v=mp[x];\\n               int ve=x+26*v;\\n               if(ve<=k){\\n                   mp[x]++;\\n               }\\n               else{\\n                   return false;\\n               }\\n           }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int,int>mp;\\n        if(s.size()!=t.size()) return false;\\n        for(int i=0;i<s.size();i++){\\n           int x=(t[i]-s[i]+26)%26;\\n           if(x!=0){\\n               int v=mp[x];\\n               int ve=x+26*v;\\n               if(ve<=k){\\n                   mp[x]++;\\n               }\\n               else{\\n                   return false;\\n               }\\n           }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270070,
                "title": "o-n-constant-space-solution-in-c",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(26) ~ constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n\\n        vector<int> tracker(26, 0);\\n        for(int i=0;i<s.length();i++){\\n            int diff;\\n            if(t[i]>s[i]){\\n                diff = (t[i]-\\'a\\')-(s[i]-\\'a\\');\\n            }\\n            else{\\n                diff = (\\'z\\'-s[i]) + (t[i]-\\'a\\') + 1;\\n            }\\n            if(diff==0 || diff==26){\\n                continue;\\n            }\\n            if(diff>k){\\n                return false;\\n            }\\n            if(tracker[diff]!=0){\\n                tracker[diff]+=26;\\n                if(tracker[diff]>k){\\n                    return false;\\n                }\\n            }\\n            else{\\n                tracker[diff] += diff;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n\\n        vector<int> tracker(26, 0);\\n        for(int i=0;i<s.length();i++){\\n            int diff;\\n            if(t[i]>s[i]){\\n                diff = (t[i]-\\'a\\')-(s[i]-\\'a\\');\\n            }\\n            else{\\n                diff = (\\'z\\'-s[i]) + (t[i]-\\'a\\') + 1;\\n            }\\n            if(diff==0 || diff==26){\\n                continue;\\n            }\\n            if(diff>k){\\n                return false;\\n            }\\n            if(tracker[diff]!=0){\\n                tracker[diff]+=26;\\n                if(tracker[diff]>k){\\n                    return false;\\n                }\\n            }\\n            else{\\n                tracker[diff] += diff;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269343,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        \\n        int[] count = new int[26];\\n        for(int i =0; i< s.length(); i++){\\n            int diff = (int)(t.charAt(i) - s.charAt(i));\\n            if(diff < 0 ) diff = diff + 26;\\n\\n            if(diff > 0 && diff + count[diff]*26 > k ) return false;\\n            count[diff]++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        \\n        int[] count = new int[26];\\n        for(int i =0; i< s.length(); i++){\\n            int diff = (int)(t.charAt(i) - s.charAt(i));\\n            if(diff < 0 ) diff = diff + 26;\\n\\n            if(diff > 0 && diff + count[diff]*26 > k ) return false;\\n            count[diff]++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266162,
                "title": "c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n       if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n       if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265958,
                "title": "c-o-n-o-1-frequency-array",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(length)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int sl = s.length(), tl = t.length();\\n        if(sl != tl) return false;\\n\\n        vector<int> m(27, k/26);\\n        for(int i = 1; i < 27; i++) {\\n            if(k%26 >= i) m[i]++;\\n        }\\n\\n        for(int i = 0; i < sl; i++) {\\n            if(s[i] == t[i]) continue;\\n            int diff = t[i]-s[i];\\n            if(diff < 0) diff += 26;\\n            if(diff > k || m[diff] <= 0) return false;\\n            m[diff]--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int sl = s.length(), tl = t.length();\\n        if(sl != tl) return false;\\n\\n        vector<int> m(27, k/26);\\n        for(int i = 1; i < 27; i++) {\\n            if(k%26 >= i) m[i]++;\\n        }\\n\\n        for(int i = 0; i < sl; i++) {\\n            if(s[i] == t[i]) continue;\\n            int diff = t[i]-s[i];\\n            if(diff < 0) diff += 26;\\n            if(diff > k || m[diff] <= 0) return false;\\n            m[diff]--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262977,
                "title": "simple-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince for every move we can go for i steps forward, we need to track for steps..\\nAlso every j will be unique as we are traversing the string..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain a map where we store the i values along with the no of times we used it.\\nIt we would like to convert a to c , we need to look for 2nd move, suppose for another j again we get a to c, then we can\\'t use 2nd move but we can use 2+26 the move. again if we get same conversion use 2+26*2... so on..\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)  as map keys are from 1 to 26 only..\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for map.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        map<int,int> mp;\\n        for(int j=0;j<s.length();i++){\\n            char c1 = s[j];\\n            char c2 = t[j];\\n            int val = t[j]-s[j];\\n            if(val!=0){\\n                if(val<0){\\n                    val+=26;\\n                }\\n                //cout<<\"Val is \"<<val+mp[val]*26<<\"for converting \"<<s[i]<<\" to \"<<t[i]<<endl;\\n                if(val+mp[val]*26<=k){\\n                    mp[val]++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        map<int,int> mp;\\n        for(int j=0;j<s.length();i++){\\n            char c1 = s[j];\\n            char c2 = t[j];\\n            int val = t[j]-s[j];\\n            if(val!=0){\\n                if(val<0){\\n                    val+=26;\\n                }\\n                //cout<<\"Val is \"<<val+mp[val]*26<<\"for converting \"<<s[i]<<\" to \"<<t[i]<<endl;\\n                if(val+mp[val]*26<=k){\\n                    mp[val]++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3262137,
                "title": "258-ms",
                "content": "```ruby\\ndef can_convert_string s, t, k\\n    return false if s.size != t.size\\n    s, t = *[s, t].map!(&:bytes)\\n    h = (0...s.size).map do\\n        x, y = s[_1], t[_1]\\n        y + (y < x ? 26 : 0) - x \\n    end .tally\\n    h.delete 0\\n    h.empty? || begin\\n        x, y = *h.max_by { [_2, _1] }\\n        (y - 1) * 26 + x <= k\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef can_convert_string s, t, k\\n    return false if s.size != t.size\\n    s, t = *[s, t].map!(&:bytes)\\n    h = (0...s.size).map do\\n        x, y = s[_1], t[_1]\\n        y + (y < x ? 26 : 0) - x \\n    end .tally\\n    h.delete 0\\n    h.empty? || begin\\n        x, y = *h.max_by { [_2, _1] }\\n        (y - 1) * 26 + x <= k\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3223328,
                "title": "java-using-modulo-operation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        int[] arr=new int[27];\\n        int div=k/26,rem=k%26;\\n        for (int i=1;i<arr.length;i++){\\n            arr[i]=div;\\n        }\\n        for (int i=1;i<=rem;i++){\\n            arr[i]++;\\n        }\\n        for (int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=t.charAt(i)){\\n                int val=(t.charAt(i)-s.charAt(i)+26)%26;\\n                if(arr[val]>0){\\n                    arr[val]--;\\n                }else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n     public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        int[] arr=new int[27];\\n        int div=k/26,rem=k%26;\\n        for (int i=1;i<arr.length;i++){\\n            arr[i]=div;\\n        }\\n        for (int i=1;i<=rem;i++){\\n            arr[i]++;\\n        }\\n        for (int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=t.charAt(i)){\\n                int val=(t.charAt(i)-s.charAt(i)+26)%26;\\n                if(arr[val]>0){\\n                    arr[val]--;\\n                }else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169455,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    // calculates distance between char a and b through shifting right\\n    int dist(char a, char b){\\n        int moves = 0;\\n        while (a != b){\\n            ++moves;\\n            if (a == \\'z\\') a = \\'a\\';\\n            else ++a;\\n        }\\n        return moves;\\n    }\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) return false;\\n        unordered_map<int,int> m;\\n        int remainder = k % 26;\\n        for (int i = 1; i <= 26; ++i){\\n            m[i] += k / 26;\\n            if (remainder-- > 0) m[i] += 1;\\n        }\\n        for (int i = 0; i < s.size(); ++i){\\n            if (s[i] != t[i]){\\n                int d = dist(s[i], t[i]);\\n                if (--m[d] == -1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // calculates distance between char a and b through shifting right\\n    int dist(char a, char b){\\n        int moves = 0;\\n        while (a != b){\\n            ++moves;\\n            if (a == \\'z\\') a = \\'a\\';\\n            else ++a;\\n        }\\n        return moves;\\n    }\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) return false;\\n        unordered_map<int,int> m;\\n        int remainder = k % 26;\\n        for (int i = 1; i <= 26; ++i){\\n            m[i] += k / 26;\\n            if (remainder-- > 0) m[i] += 1;\\n        }\\n        for (int i = 0; i < s.size(); ++i){\\n            if (s[i] != t[i]){\\n                int d = dist(s[i], t[i]);\\n                if (--m[d] == -1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167267,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn can_convert_string(s: String, t: String, k: i32) -> bool {\\n        use std::collections::HashMap;\\n        if s.len() != t.len() {\\n            return false;\\n        }\\n        let diffs = s.bytes().zip(t.bytes()).map(|(x, y)| (y as i32 - x as i32 + 26) % 26);\\n        let diffs = diffs.into_iter().filter(|&x| x != 0);\\n        let mut map: HashMap<i32, i32> = HashMap::new();\\n        for diff in diffs {\\n            let multiplier = *map.entry(diff).or_insert(0);\\n            if diff + (26 * multiplier) > k {\\n                return false;\\n            }\\n            *map.entry(diff).or_insert(0) += 1;\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn can_convert_string(s: String, t: String, k: i32) -> bool {\\n        use std::collections::HashMap;\\n        if s.len() != t.len() {\\n            return false;\\n        }\\n        let diffs = s.bytes().zip(t.bytes()).map(|(x, y)| (y as i32 - x as i32 + 26) % 26);\\n        let diffs = diffs.into_iter().filter(|&x| x != 0);\\n        let mut map: HashMap<i32, i32> = HashMap::new();\\n        for diff in diffs {\\n            let multiplier = *map.entry(diff).or_insert(0);\\n            if diff + (26 * multiplier) > k {\\n                return false;\\n            }\\n            *map.entry(diff).or_insert(0) += 1;\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3164248,
                "title": "c-o-n-easy-solution-intuitive",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length())\\n            return 0;\\n        vector<int> vacant(26, 0);\\n        for(int i=0;i<26;i++)\\n            vacant[i] = i;\\n        int x, p;\\n        for(int i=0;i<s.length();i++){\\n            if(t[i] - \\'a\\'- (s[i] - \\'a\\') != 0)\\n            {\\n             x = t[i] - \\'a\\'- (s[i] - \\'a\\');\\n            if(x < 0)\\n                x += 26;\\n             p = vacant[x%26];\\n            vacant[x%26] += 26;\\n            if(p > k)\\n                return 0;         \\n            s[i] = t[i];\\n            }\\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length())\\n            return 0;\\n        vector<int> vacant(26, 0);\\n        for(int i=0;i<26;i++)\\n            vacant[i] = i;\\n        int x, p;\\n        for(int i=0;i<s.length();i++){\\n            if(t[i] - \\'a\\'- (s[i] - \\'a\\') != 0)\\n            {\\n             x = t[i] - \\'a\\'- (s[i] - \\'a\\');\\n            if(x < 0)\\n                x += 26;\\n             p = vacant[x%26];\\n            vacant[x%26] += 26;\\n            if(p > k)\\n                return 0;         \\n            s[i] = t[i];\\n            }\\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035460,
                "title": "hashing-o-n",
                "content": "used hashmap to store previous min value of difference of two alphabets in both s and t respectively \\nfirst i was using hashset which was not effeceint because that checks everytime if the number is present or not \\n\\nso i used hashmap and everything solved \\n\\n```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()) return false ; \\n        HashMap<Long,Long> hm = new HashMap<>();\\n        for(int i = 0 ; i < s.length() ; i++){\\n            Long a = (long)(t.charAt(i)-\\'a\\')-(long)(s.charAt(i)-\\'a\\');\\n            if(a>0) {\\n                if(hm.containsKey(a)){\\n                    if((hm.get(a)+26)>k) return false ; \\n                    else hm.put(a,hm.get(a)+26);\\n                }\\n                else {\\n                    if(a>k) return false ; \\n                    hm.put(a,a);\\n                }\\n            }\\n            else if(a<0){\\n                a += 26 ; \\n                if(hm.containsKey(a)){\\n                    if((hm.get(a)+26) > k) return false ; \\n                    else hm.put(a,hm.get(a)+26);\\n                }\\n                else {\\n                    if(a>k) return false ; \\n                    hm.put(a,a);\\n                }\\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()) return false ; \\n        HashMap<Long,Long> hm = new HashMap<>();\\n        for(int i = 0 ; i < s.length() ; i++){\\n            Long a = (long)(t.charAt(i)-\\'a\\')-(long)(s.charAt(i)-\\'a\\');\\n            if(a>0) {\\n                if(hm.containsKey(a)){\\n                    if((hm.get(a)+26)>k) return false ; \\n                    else hm.put(a,hm.get(a)+26);\\n                }\\n                else {\\n                    if(a>k) return false ; \\n                    hm.put(a,a);\\n                }\\n            }\\n            else if(a<0){\\n                a += 26 ; \\n                if(hm.containsKey(a)){\\n                    if((hm.get(a)+26) > k) return false ; \\n                    else hm.put(a,hm.get(a)+26);\\n                }\\n                else {\\n                    if(a>k) return false ; \\n                    hm.put(a,a);\\n                }\\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928266,
                "title": "c-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()) return false;\\n        int cnt[26]{}, round = k/26, remainer = k%26;\\n        for(int i = 0; i < s.size(); i++) cnt[(t[i]-s[i]+26)%26]++;\\n        for(int i = 1; i <= 25; i++) if(round + (i <= remainer ? 1 : 0) < cnt[i]) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()) return false;\\n        int cnt[26]{}, round = k/26, remainer = k%26;\\n        for(int i = 0; i < s.size(); i++) cnt[(t[i]-s[i]+26)%26]++;\\n        for(int i = 1; i <= 25; i++) if(round + (i <= remainer ? 1 : 0) < cnt[i]) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927948,
                "title": "c-simple-solution-worst-question",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        int end= s.size()-1, start = 0;\\n        map<int,int> mp;\\n        while(start<=end){\\n            int diff = (t[start]-s[start]+26)%26; //for negative difference\\n            if(diff!=0){\\n                int mul = mp[diff];\\n                long long val = diff+ (26*mul);\\n                if(val<=k) mp[diff]++; \\n                else return false;\\n            }\\n            start++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        int end= s.size()-1, start = 0;\\n        map<int,int> mp;\\n        while(start<=end){\\n            int diff = (t[start]-s[start]+26)%26; //for negative difference\\n            if(diff!=0){\\n                int mul = mp[diff];\\n                long long val = diff+ (26*mul);\\n                if(val<=k) mp[diff]++; \\n                else return false;\\n            }\\n            start++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842168,
                "title": "python-hashmap-faster-than-100",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:    \\n        m, n = len(s), len(t)\\n        if m != n: return False\\n        cnt1 = Counter((ord(t[i]) - ord(s[i])) % 26 for i in range(m))\\n        del(cnt1[0])\\n        q, r = divmod(k, 26)\\n        cnt2 = Counter({i: q for i in range(1, 26)}) + Counter({i: 1 for i in range(1, r + 1)})\\n        return cnt1 <= cnt2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:    \\n        m, n = len(s), len(t)\\n        if m != n: return False\\n        cnt1 = Counter((ord(t[i]) - ord(s[i])) % 26 for i in range(m))\\n        del(cnt1[0])\\n        q, r = divmod(k, 26)\\n        cnt2 = Counter({i: q for i in range(1, 26)}) + Counter({i: 1 for i in range(1, r + 1)})\\n        return cnt1 <= cnt2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683473,
                "title": "c-count-o-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$ -> `n` is the length os string `s`.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool canConvertString(const string& s, const string& t, int k) {\\n        const int n = size(s);\\n        if (n != size(t))\\n            return false;\\n        array<int, 26> count{};\\n        for (int i = 0; i < n; ++i)\\n            if (int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n                shift && shift + count[shift]++ * 26 > k)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool canConvertString(const string& s, const string& t, int k) {\\n        const int n = size(s);\\n        if (n != size(t))\\n            return false;\\n        array<int, 26> count{};\\n        for (int i = 0; i < n; ++i)\\n            if (int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n                shift && shift + count[shift]++ * 26 > k)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628773,
                "title": "c-o-n-simple",
                "content": "I found that many solutions check the possibility at the end of every round of the loop, but I do it later instead.\\nI wonder which one would be faster.\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()){\\n            return false;\\n        }\\n        const int n = s.size();\\n        const int M = 26;\\n        int count[M];\\n        memset(count, 0, sizeof(count));\\n        for(int i = 0; i < n; ++i){\\n            count[t[i] - s[i] + (t[i] < s[i] ? M : 0)]++;\\n        }\\n        for(int i = 1; i < M; ++i){\\n            if((count[i] - 1) * M + i > k){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()){\\n            return false;\\n        }\\n        const int n = s.size();\\n        const int M = 26;\\n        int count[M];\\n        memset(count, 0, sizeof(count));\\n        for(int i = 0; i < n; ++i){\\n            count[t[i] - s[i] + (t[i] < s[i] ? M : 0)]++;\\n        }\\n        for(int i = 1; i < M; ++i){\\n            if((count[i] - 1) * M + i > k){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593356,
                "title": "can-convert-string-in-k-moves",
                "content": "bool canConvertString(string s, string t, int k) {\\n          if(s.size()!=t.size())\\n        {\\n            return false;\\n        }\\n        unordered_map<int,int>mp;\\n       for(int i=0;i<s.size();i++)\\n      {\\n           if(s[i]==t[i])\\n           {\\n               continue;\\n           }\\n           if(t[i]-s[i]>k)\\n           {\\n               return false;\\n           }\\n           if(t[i]-s[i]<0){\\n           if(t[i]-s[i]+26>k)\\n           {\\n               return false;\\n           }\\n           }\\n           if(t[i]-s[i]>0)\\n           mp[t[i]-s[i]]++;\\n           if(t[i]-s[i]<0)\\n           mp[t[i]-s[i]+26]++;\\n           \\n    \\n       }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(t[i]-s[i]>0)\\n            {\\n                if(mp[t[i]-s[i]]>1)\\n                {\\n                    if(26*(mp[t[i]-s[i]]-1)+t[i]-s[i]>k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n                \\n            }\\n            if(t[i]-s[i]<0)\\n            {\\n                 if(mp[t[i]-s[i]+26]>1)\\n                {\\n                    if(26+26*(mp[t[i]-s[i]+26]-1)+t[i]-s[i]>k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;",
                "solutionTags": [],
                "code": "bool canConvertString(string s, string t, int k) {\\n          if(s.size()!=t.size())\\n        {\\n            return false;\\n        }\\n        unordered_map<int,int>mp;\\n       for(int i=0;i<s.size();i++)\\n      {\\n           if(s[i]==t[i])\\n           {\\n               continue;\\n           }\\n           if(t[i]-s[i]>k)\\n           {\\n               return false;\\n           }\\n           if(t[i]-s[i]<0){\\n           if(t[i]-s[i]+26>k)\\n           {\\n               return false;\\n           }\\n           }\\n           if(t[i]-s[i]>0)\\n           mp[t[i]-s[i]]++;\\n           if(t[i]-s[i]<0)\\n           mp[t[i]-s[i]+26]++;\\n           \\n    \\n       }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(t[i]-s[i]>0)\\n            {\\n                if(mp[t[i]-s[i]]>1)\\n                {\\n                    if(26*(mp[t[i]-s[i]]-1)+t[i]-s[i]>k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n                \\n            }\\n            if(t[i]-s[i]<0)\\n            {\\n                 if(mp[t[i]-s[i]+26]>1)\\n                {\\n                    if(26+26*(mp[t[i]-s[i]+26]-1)+t[i]-s[i]>k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;",
                "codeTag": "Unknown"
            },
            {
                "id": 2542449,
                "title": "java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int len1 = s.length();\\n        int len2 = t.length();\\n        if (len1 != len2) {\\n            return false;\\n        }\\n        if (s.equals(t)) {\\n            return true;\\n        }\\n        int[] freq = new int[26];\\n        int multiple = k / 26;\\n        for (int i = 0; i < 26; i++) {\\n            freq[i] = multiple;\\n        }\\n        int rem = k % 26;\\n        for (int i = 1; i <= rem; i++) {\\n            freq[i]++;\\n        }\\n        int movesRemaining = k;\\n        for (int i = 0; i < len1; i++) {\\n            char ch1 = s.charAt(i);\\n            char ch2 = t.charAt(i);\\n            if (ch1 == ch2) {\\n                movesRemaining--;\\n                continue;\\n            }\\n            int diff = (ch2 - ch1 + 26) % 26;\\n            if (freq[diff] > 0) {\\n                freq[diff]--;\\n                movesRemaining--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return movesRemaining >= 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int len1 = s.length();\\n        int len2 = t.length();\\n        if (len1 != len2) {\\n            return false;\\n        }\\n        if (s.equals(t)) {\\n            return true;\\n        }\\n        int[] freq = new int[26];\\n        int multiple = k / 26;\\n        for (int i = 0; i < 26; i++) {\\n            freq[i] = multiple;\\n        }\\n        int rem = k % 26;\\n        for (int i = 1; i <= rem; i++) {\\n            freq[i]++;\\n        }\\n        int movesRemaining = k;\\n        for (int i = 0; i < len1; i++) {\\n            char ch1 = s.charAt(i);\\n            char ch2 = t.charAt(i);\\n            if (ch1 == ch2) {\\n                movesRemaining--;\\n                continue;\\n            }\\n            int diff = (ch2 - ch1 + 26) % 26;\\n            if (freq[diff] > 0) {\\n                freq[diff]--;\\n                movesRemaining--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return movesRemaining >= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467091,
                "title": "an-easy-o-26-space-solution-learn-new-tricks",
                "content": "class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int ns=s.length(), nt=t.length();\\n        \\n        if(ns!=nt) \\n            return false;\\n        \\n        unordered_map<int,int> un;\\n        int num = k/26, rem=k%26;\\n        \\n        for(int i=1;i<=26;i++) {\\n            un[i]+=num;\\n            if(rem>=i)\\n                un[i]++;\\n        }\\n        \\n        for(int i=0;i<ns;i++) {\\n            int diff = 0;\\n            if(s[i] > t[i]) {\\n                diff = 26+(t[i]-s[i]);\\n            }\\n            else if(s[i] < t[i]) {\\n                diff = t[i]-s[i];\\n            }\\n            if(diff!=0) {\\n                if(un[diff]>0) un[diff]--;\\n                else return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int ns=s.length(), nt=t.length();\\n        \\n        if(ns!=nt) \\n            return false;\\n        \\n        unordered_map<int,int> un;\\n        int num = k/26, rem=k%26;\\n        \\n        for(int i=1;i<=26;i++) {\\n            un[i]+=num;\\n            if(rem>=i)\\n                un[i]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2464132,
                "title": "crisp-n-clear-o-n-javascript-runtime-100-00-meaningful-vars",
                "content": "Runtime: 85 ms, faster than 100.00% of JavaScript online submissions for Can Convert String in K Moves.\\nMemory Usage: 47.5 MB, less than 57.14% of JavaScript online submissions for Can Convert String in K Moves.\\n\\n```\\nvar canConvertString = function (str = \\'\\', target = \\'\\', k) {\\n  if (str.length !== target.length) {\\n    return false;\\n  }\\n  const config = {};\\n  for (let index = 0; index < str.length; index++) {\\n    const diff = target.charCodeAt(index) - str.charCodeAt(index);\\n\\n    if (diff === 0) {\\n      continue;\\n    }\\n    if (diff > k) {\\n      return false;\\n    }\\n    if (diff < 0) {\\n      const temp = 26 + diff;\\n      if (temp > k) {\\n        return false;\\n      }\\n      if (!config[temp]) {\\n        config[temp] = 0;\\n      }\\n      config[temp] += 1;\\n    } else {\\n      if (!config[diff]) {\\n        config[diff] = 0;\\n      }\\n      config[diff] += 1;\\n    }\\n  }\\n  for (const key in config) {\\n    if (config[key] > 1) {\\n      const temp = (config[key] - 1) * 26 + Number(key);\\n      if (k < temp) {\\n        return false;\\n      }\\n    }\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConvertString = function (str = \\'\\', target = \\'\\', k) {\\n  if (str.length !== target.length) {\\n    return false;\\n  }\\n  const config = {};\\n  for (let index = 0; index < str.length; index++) {\\n    const diff = target.charCodeAt(index) - str.charCodeAt(index);\\n\\n    if (diff === 0) {\\n      continue;\\n    }\\n    if (diff > k) {\\n      return false;\\n    }\\n    if (diff < 0) {\\n      const temp = 26 + diff;\\n      if (temp > k) {\\n        return false;\\n      }\\n      if (!config[temp]) {\\n        config[temp] = 0;\\n      }\\n      config[temp] += 1;\\n    } else {\\n      if (!config[diff]) {\\n        config[diff] = 0;\\n      }\\n      config[diff] += 1;\\n    }\\n  }\\n  for (const key in config) {\\n    if (config[key] > 1) {\\n      const temp = (config[key] - 1) * 26 + Number(key);\\n      if (k < temp) {\\n        return false;\\n      }\\n    }\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431379,
                "title": "c-o-n-time-o-26-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())  return false;\\n        \\n        vector<int> moves( 27, k/26);\\n        for( int i=1; i<=k%26; i++)\\n            moves[i]+=1;\\n        \\n        for( int i=0; i<s.size(); i++){\\n            int d=(26+t[i]-s[i])%26;\\n            if(d==0)    continue;\\n            if(moves[d]==0)\\n                return false;\\n            else\\n                moves[d]-=1;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())  return false;\\n        \\n        vector<int> moves( 27, k/26);\\n        for( int i=1; i<=k%26; i++)\\n            moves[i]+=1;\\n        \\n        for( int i=0; i<s.size(); i++){\\n            int d=(26+t[i]-s[i])%26;\\n            if(d==0)    continue;\\n            if(moves[d]==0)\\n                return false;\\n            else\\n                moves[d]-=1;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430909,
                "title": "c-modulo-arithmetics",
                "content": "We compute how many times me can and we should use `(t[i] - k[i])` shift:\\n\\n```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        if (s.Length != t.Length)\\n            return false;\\n        \\n        int[] moves = Enumerable\\n            .Range(0, 26)\\n            .Select(i => k / 26 + (i <= k % 26 ? 1 : 0))\\n            .ToArray();\\n        \\n        moves[0] = int.MaxValue;\\n        \\n        for (int i = s.Length - 1; i >= 0; --i) \\n            if (--moves[(t[i] - s[i] + 26) % 26] < 0)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        if (s.Length != t.Length)\\n            return false;\\n        \\n        int[] moves = Enumerable\\n            .Range(0, 26)\\n            .Select(i => k / 26 + (i <= k % 26 ? 1 : 0))\\n            .ToArray();\\n        \\n        moves[0] = int.MaxValue;\\n        \\n        for (int i = s.Length - 1; i >= 0; --i) \\n            if (--moves[(t[i] - s[i] + 26) % 26] < 0)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400825,
                "title": "c-easy-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string tr, int k) {\\n        int n=s.size();\\n        if(n!=tr.size())\\n            return 0;\\n        vector<int> t(26);\\n        for(int i=0;i<26;i++)\\n            t[i]=k/26;\\n        for(int i=k%26;i>=1;i--)\\n            t[i]++;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(tr[i]==s[i])continue;\\n            int a=(tr[i]>s[i]?tr[i]-s[i]:26-s[i]+tr[i]);\\n            if(!t[a])return 0;\\n            t[a]--;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string tr, int k) {\\n        int n=s.size();\\n        if(n!=tr.size())\\n            return 0;\\n        vector<int> t(26);\\n        for(int i=0;i<26;i++)\\n            t[i]=k/26;\\n        for(int i=k%26;i>=1;i--)\\n            t[i]++;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(tr[i]==s[i])continue;\\n            int a=(tr[i]>s[i]?tr[i]-s[i]:26-s[i]+tr[i]);\\n            if(!t[a])return 0;\\n            t[a]--;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2343164,
                "title": "c",
                "content": "```\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) return false;\\n        \\n        int ans = 0;\\n        vector<int> bucket(26);\\n        for (int i = 0; i < s.size(); ++ i){\\n            if (s[i] == t[i]) continue;\\n            int temp = (-s[i] + t[i]) > 0 ? (-s[i] + t[i]) : (-s[i] + t[i]) + 26;\\n            ans = max(ans, (bucket[temp]) * 26 + temp);\\n            bucket[temp] ++;\\n        }\\n        \\n        return ans <= k;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) return false;\\n        \\n        int ans = 0;\\n        vector<int> bucket(26);\\n        for (int i = 0; i < s.size(); ++ i){\\n            if (s[i] == t[i]) continue;\\n            int temp = (-s[i] + t[i]) > 0 ? (-s[i] + t[i]) : (-s[i] + t[i]) + 26;\\n            ans = max(ans, (bucket[temp]) * 26 + temp);\\n            bucket[temp] ++;\\n        }\\n        \\n        return ans <= k;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2341667,
                "title": "intuitive-do-as-hints-say-corner-cases",
                "content": "```\\nclass Solution {\\n    \\n    int dis(char s, char t) {\\n        return (t - s + 26) % 26;\\n    }\\n    \\n    vector<int> get_dis(const string& s, const string& t) {\\n        int len = s.size();\\n        vector<int> res(26);\\n        for (int i = 0; i < len; ++i) {\\n            res[dis(s[i], t[i])]++;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if (s.size() != t.size()) return false;\\n        \\n        auto distances = get_dis(s, t);\\n        for (int i = 1; i < distances.size(); ++i) {\\n            if (i + (distances[i] - 1) * 26 > k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int dis(char s, char t) {\\n        return (t - s + 26) % 26;\\n    }\\n    \\n    vector<int> get_dis(const string& s, const string& t) {\\n        int len = s.size();\\n        vector<int> res(26);\\n        for (int i = 0; i < len; ++i) {\\n            res[dis(s[i], t[i])]++;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if (s.size() != t.size()) return false;\\n        \\n        auto distances = get_dis(s, t);\\n        for (int i = 1; i < distances.size(); ++i) {\\n            if (i + (distances[i] - 1) * 26 > k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331947,
                "title": "c-98-optimised-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        int n=s.size();\\n        vector<int>v(26);\\n        int diff;\\n        for(int i=0;i<n;i++)\\n        {\\n            // cout<<t[i]-s[i]\\n            if(s[i]!=t[i])\\n            {\\n                diff=t[i]-s[i];\\n                // cout<<\"i , diff : \"<<i<<\" \"<<diff<<endl;\\n                if(diff>0)\\n                {\\n                    v[diff]=v[diff]+1;\\n                }\\n                else \\n                {\\n                    v[26+diff]=v[26+diff]+1;\\n                }\\n            }\\n        }\\n        // for(int i=0;i<26;i++) cout<<i<<\" \"<<v[i]<<endl;\\n        int maxi=-1;\\n        for(int i=1;i<=25;i++)\\n        {\\n            if(v[i]>0)\\n            {\\n                // cout<<\"v[i] : \"<<v[i]<<endl;\\n                int step=((v[i]-1)*26)+i;\\n                // cout<<\"step : \"<<step<<endl;\\n                maxi=max(maxi,step);\\n            }\\n        }\\n        if(maxi<=k) return true;\\n        else return false;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        int n=s.size();\\n        vector<int>v(26);\\n        int diff;\\n        for(int i=0;i<n;i++)\\n        {\\n            // cout<<t[i]-s[i]\\n            if(s[i]!=t[i])\\n            {\\n                diff=t[i]-s[i];\\n                // cout<<\"i , diff : \"<<i<<\" \"<<diff<<endl;\\n                if(diff>0)\\n                {\\n                    v[diff]=v[diff]+1;\\n                }",
                "codeTag": "C++"
            },
            {
                "id": 2302803,
                "title": "c-solution-with-explanation",
                "content": "```\\n/*\\n\\n    actually here, the k value represents the maximum difference we can use\\n    to go from a to b - we can start from a and reach b in one step \\n                      - we can start from a, complete a full circle, and come back to a, then take 1 step to reach b (1 + 26 steps)\\n                      - we can start from a, complete 2 full circles, and come back to a, then take 1 step to reach b (1 + 2*26 steps)\\n                      - if we take m circles then, we will take 1 + m*26 steps\\n                      \\n   notice that to transform s[i] to t[i], the number of circles, we will have to take is the number of occurrences of the difference \\n   (t[i] - s[i] + 26) % 26 [this is actually the circular difference between s[i] and t[i] (angular displacement*r)] \\n   like if we want to convert x to a, then the shortest path in ciruclar fashion will be (a - x + 26) % 26 = (-23 + 26) % 26 = 3\\n   \\n   \\n   for example \\n   a a b\\n   b b b\\n   \\n   for converting the first a to b, we used 1 step\\n   now for converting the second a to b, we will have to use the next available option : that is [1 + 1*26] = 27\\n   so at each point, check if diff + cnt[diff]*26 <= k, if it is you can change it to t[i] else not\\n                      \\n\\n*/\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n            \\n        if(s.length() != t.length()) return false;\\n        \\n        int cnt[26]{0};\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == t[i]) continue;\\n            int diff = (t[i] - s[i] + 26) % 26;\\n            if(diff + cnt[diff]*26 > k) return false;\\n            cnt[diff]++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\n    actually here, the k value represents the maximum difference we can use\\n    to go from a to b - we can start from a and reach b in one step \\n                      - we can start from a, complete a full circle, and come back to a, then take 1 step to reach b (1 + 26 steps)\\n                      - we can start from a, complete 2 full circles, and come back to a, then take 1 step to reach b (1 + 2*26 steps)\\n                      - if we take m circles then, we will take 1 + m*26 steps\\n                      \\n   notice that to transform s[i] to t[i], the number of circles, we will have to take is the number of occurrences of the difference \\n   (t[i] - s[i] + 26) % 26 [this is actually the circular difference between s[i] and t[i] (angular displacement*r)] \\n   like if we want to convert x to a, then the shortest path in ciruclar fashion will be (a - x + 26) % 26 = (-23 + 26) % 26 = 3\\n   \\n   \\n   for example \\n   a a b\\n   b b b\\n   \\n   for converting the first a to b, we used 1 step\\n   now for converting the second a to b, we will have to use the next available option : that is [1 + 1*26] = 27\\n   so at each point, check if diff + cnt[diff]*26 <= k, if it is you can change it to t[i] else not\\n                      \\n\\n*/\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n            \\n        if(s.length() != t.length()) return false;\\n        \\n        int cnt[26]{0};\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == t[i]) continue;\\n            int diff = (t[i] - s[i] + 26) % 26;\\n            if(diff + cnt[diff]*26 > k) return false;\\n            cnt[diff]++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268872,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int val=0;\\n        if(s.size()!=t.size())return false;\\n        unordered_map<int,int>m;//it contains the number of times diff appeared\\n        for(int i=0;i<s.size();i++){\\n            int diff=t[i]-s[i];\\n            if(diff==0)continue;\\n            if(diff<0)diff+=26;\\n            if(m[diff]*26+diff>k)return false;\\n            m[diff]++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int val=0;\\n        if(s.size()!=t.size())return false;\\n        unordered_map<int,int>m;//it contains the number of times diff appeared\\n        for(int i=0;i<s.size();i++){\\n            int diff=t[i]-s[i];\\n            if(diff==0)continue;\\n            if(diff<0)diff+=26;\\n            if(m[diff]*26+diff>k)return false;\\n            m[diff]++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260349,
                "title": "easy-to-understand-o-n-c",
                "content": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        \\n        if(s.Length!=t.Length) return false;\\n        var map = new int[27];\\n        \\n        var whole = k/26;\\n        var partial = k%26;\\n        \\n        //Fill values with available replaces\\n        // a => b can happen with 1 or 27 so we can count 27 as 1\\n        for(int i=1; i<=26; i++)\\n        {\\n            map[i] = whole;\\n            if(i<=partial) map[i]++;\\n        }\\n        \\n        for(int i=0; i<s.Length; i++)\\n        {\\n            //(t[i] - s[i]) =>  a->z. => 26-1 => 25\\n            //(t[i] - s[i] + 26) => z -> a  => 1 - 26 + 26 => 1\\n            var diff = (t[i] - s[i]) >= 0 ? (t[i] - s[i]) : (t[i] - s[i] + 26);\\n            \\n            //If difference is 0 then we don\\'t need to do anything\\n            if(diff== 0) continue;\\n            \\n            //If we don\\'t have any replace available\\n            if(map[diff] <= 0) return false;\\n            map[diff]--;\\n            \\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        \\n        if(s.Length!=t.Length) return false;\\n        var map = new int[27];\\n        \\n        var whole = k/26;\\n        var partial = k%26;\\n        \\n        //Fill values with available replaces\\n        // a => b can happen with 1 or 27 so we can count 27 as 1\\n        for(int i=1; i<=26; i++)\\n        {\\n            map[i] = whole;\\n            if(i<=partial) map[i]++;\\n        }\\n        \\n        for(int i=0; i<s.Length; i++)\\n        {\\n            //(t[i] - s[i]) =>  a->z. => 26-1 => 25\\n            //(t[i] - s[i] + 26) => z -> a  => 1 - 26 + 26 => 1\\n            var diff = (t[i] - s[i]) >= 0 ? (t[i] - s[i]) : (t[i] - s[i] + 26);\\n            \\n            //If difference is 0 then we don\\'t need to do anything\\n            if(diff== 0) continue;\\n            \\n            //If we don\\'t have any replace available\\n            if(map[diff] <= 0) return false;\\n            map[diff]--;\\n            \\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238035,
                "title": "can-convert-string-in-k-moves",
                "content": "### \\tC++ \\n\\t\\n\\tbool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()){\\n            return false;\\n        }\\n        \\n        int n = s.length();\\n    \\n        int arr[26]={};\\n        \\n        for(int i = 0;i<n;i++){\\n            int diff = t[i]-s[i] + (t[i]>=s[i] ? 0 : 26);\\n            if(diff==0) {\\n                continue;\\n            }    \\n            if(arr[diff]*26 + diff >k){\\n                return false;\\n            }\\n            ++arr[diff];\\n        }\\n        return true;\\n        \\n    }",
                "solutionTags": [
                    "String"
                ],
                "code": "### \\tC++ \\n\\t\\n\\tbool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()){\\n            return false;\\n        }\\n        \\n        int n = s.length();\\n    \\n        int arr[26]={};\\n        \\n        for(int i = 0;i<n;i++){\\n            int diff = t[i]-s[i] + (t[i]>=s[i] ? 0 : 26);\\n            if(diff==0) {\\n                continue;\\n            }    \\n            if(arr[diff]*26 + diff >k){\\n                return false;\\n            }\\n            ++arr[diff];\\n        }\\n        return true;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2222696,
                "title": "c-compare-moves-needed-to-available-moves",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        \\n        vector<int> diffCount(26,0);\\n        for(int i=0;i<s.size();++i) diffCount[(t[i]-s[i]+26)%26]++;\\n        \\n        int repeat = k/26, remain = k%26;\\n        vector<int> diffCountAvailable(26,repeat);\\n        for(int i=1;i<=remain;++i) diffCountAvailable[i]++;\\n        \\n        for(int i=1;i<diffCount.size();++i) \\n            if(diffCount[i]>diffCountAvailable[i]) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        \\n        vector<int> diffCount(26,0);\\n        for(int i=0;i<s.size();++i) diffCount[(t[i]-s[i]+26)%26]++;\\n        \\n        int repeat = k/26, remain = k%26;\\n        vector<int> diffCountAvailable(26,repeat);\\n        for(int i=1;i<=remain;++i) diffCountAvailable[i]++;\\n        \\n        for(int i=1;i<diffCount.size();++i) \\n            if(diffCount[i]>diffCountAvailable[i]) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155709,
                "title": "python-3-simple-o-n-o-1-solution",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        cycles, extra = divmod(k, 26)\\n        shifts = [cycles + (shift <= extra) for shift in range(26)]\\n\\n        for cs, ct in zip(s, t):\\n            shift = (ord(ct) - ord(cs)) % 26\\n            if shift == 0:\\n                continue\\n            if not shifts[shift]:\\n                return False\\n            shifts[shift] -= 1\\n        \\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        cycles, extra = divmod(k, 26)\\n        shifts = [cycles + (shift <= extra) for shift in range(26)]\\n\\n        for cs, ct in zip(s, t):\\n            shift = (ord(ct) - ord(cs)) % 26\\n            if shift == 0:\\n                continue\\n            if not shifts[shift]:\\n                return False\\n            shifts[shift] -= 1\\n        \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2131454,
                "title": "interesting-trick-for-an-interesting-question",
                "content": "```cpp\\nif (s.size() != t.size())\\n\\treturn false;\\n\\n// count the quota of every possible shift 1 ~ 25 given by k wrapping around 26.\\nint q = k / 26;\\nint r = k % 26;\\n\\nvector<int> quota(26, q);\\n\\nfor (int i = 0; i <= r; ++i)\\n\\t++ quota[i];\\n\\n// compare each char\\nfor (int i = 0; i < s.size(); ++i)\\n{\\n\\t// find the difference\\n\\tint d = (t[i] - s[i] + 26) % 26;\\n\\t\\n\\t// skip when d == 0\\n\\t// if run out of quota of any d, sad, can not convert.\\n\\tif (d && -- quota[d] < 0)\\n\\t\\treturn false;\\n}\\n\\nreturn true;\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nif (s.size() != t.size())\\n\\treturn false;\\n\\n// count the quota of every possible shift 1 ~ 25 given by k wrapping around 26.\\nint q = k / 26;\\nint r = k % 26;\\n\\nvector<int> quota(26, q);\\n\\nfor (int i = 0; i <= r; ++i)\\n\\t++ quota[i];\\n\\n// compare each char\\nfor (int i = 0; i < s.size(); ++i)\\n{\\n\\t// find the difference\\n\\tint d = (t[i] - s[i] + 26) % 26;\\n\\t\\n\\t// skip when d == 0\\n\\t// if run out of quota of any d, sad, can not convert.\\n\\tif (d && -- quota[d] < 0)\\n\\t\\treturn false;\\n}\\n\\nreturn true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2106259,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @param {number} k\\n * @return {boolean}\\n */\\n var canConvertString = function(s, t, k) {\\n    let res = true;\\n    if(s.length === t.length){\\n        let tmp = [];\\n        let countMap = new Map();\\n        for(let i=0; i<s.length; i++){\\n            let n1 = s[i].charCodeAt();\\n            let n2 = t[i].charCodeAt();\\n            let r = n2 - n1;\\n            if(r < 0){\\n                r += 26;\\n            }\\n            // exclude special case 0\\n            if(r > 0){\\n                // Considering repeated letters, the unrepeated move should change to r + 26*n (n>=0)\\n                // use hash table to count the same letter\\n                if(!countMap.has(r)){\\n\\t\\t\\t\\t    // first time to move\\n                    countMap.set(r, 1);\\n                    tmp.push(r);\\n                }else{\\n\\t\\t\\t\\t    // n time to move, n means the count of the same letter\\n                    let c = countMap.get(r);\\n                    tmp.push(r + c * 26);\\n\\t\\t\\t\\t\\t// update count\\n                    countMap.set(r, c+1);\\n                }\\n            }\\n        }\\n        // check all possible move in range\\n        for(let i=0; i<tmp.length; i++){\\n            let t = tmp[i];\\n            if(t > k){\\n                res = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        res = false;\\n    }\\n    \\n    return res;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @param {number} k\\n * @return {boolean}\\n */\\n var canConvertString = function(s, t, k) {\\n    let res = true;\\n    if(s.length === t.length){\\n        let tmp = [];\\n        let countMap = new Map();\\n        for(let i=0; i<s.length; i++){\\n            let n1 = s[i].charCodeAt();\\n            let n2 = t[i].charCodeAt();\\n            let r = n2 - n1;\\n            if(r < 0){\\n                r += 26;\\n            }\\n            // exclude special case 0\\n            if(r > 0){\\n                // Considering repeated letters, the unrepeated move should change to r + 26*n (n>=0)\\n                // use hash table to count the same letter\\n                if(!countMap.has(r)){\\n\\t\\t\\t\\t    // first time to move\\n                    countMap.set(r, 1);\\n                    tmp.push(r);\\n                }else{\\n\\t\\t\\t\\t    // n time to move, n means the count of the same letter\\n                    let c = countMap.get(r);\\n                    tmp.push(r + c * 26);\\n\\t\\t\\t\\t\\t// update count\\n                    countMap.set(r, c+1);\\n                }\\n            }\\n        }\\n        // check all possible move in range\\n        for(let i=0; i<tmp.length; i++){\\n            let t = tmp[i];\\n            if(t > k){\\n                res = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        res = false;\\n    }\\n    \\n    return res;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2103358,
                "title": "check-is-the-shift-possible-within-k-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n        vector<int> vec(26, 0); // distance between characters is in  [0,25]\\n        for(int i=0; i<s.size(); i++){\\n            int d= (int)t[i]- (int)s[i]; // distance between ith characters in strings  s, t\\n            if(d<0){\\n                d+=26; // as  d cannot be negative\\n            }\\n            if(d!=0){\\n                if(vec[d]*26+d<=k){ // d+ 26*n is the move required where n can be 0, 1, 2...\\n\\t\\t\\t\\t//we keep track of n for given \\'d\\' in vec[d] when ever this vec[d]*26+d<=k  condition fails we \\n\\t\\t\\t\\t//output false as we cannot find a move that can shift our character our character by d!\\n                    vec[d]++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n        vector<int> vec(26, 0); // distance between characters is in  [0,25]\\n        for(int i=0; i<s.size(); i++){\\n            int d= (int)t[i]- (int)s[i]; // distance between ith characters in strings  s, t\\n            if(d<0){\\n                d+=26; // as  d cannot be negative\\n            }\\n            if(d!=0){\\n                if(vec[d]*26+d<=k){ // d+ 26*n is the move required where n can be 0, 1, 2...\\n\\t\\t\\t\\t//we keep track of n for given \\'d\\' in vec[d] when ever this vec[d]*26+d<=k  condition fails we \\n\\t\\t\\t\\t//output false as we cannot find a move that can shift our character our character by d!\\n                    vec[d]++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081314,
                "title": "javascript-step-check-176ms",
                "content": "```\\nconst ord = (c) => c.charCodeAt();\\nconst counter = (a_or_s) => { let m = new Map(); for (const x of a_or_s) m.set(x, m.get(x) + 1 || 1); return m; };\\n\\nconst canConvertString = (s, t, k) => {\\n    if (s.length != t.length) return false;\\n    let n = s.length, step = Array(n).fill(0);\\n    for (let i = 0; i < n; i++) { // calculate each step move\\n        if (s[i] <= t[i]) {\\n            step[i] = ord(t[i]) - ord(s[i]);\\n        } else {\\n            step[i] = 122 - ord(s[i]) + 1 + ord(t[i]) - 97;  // s[i] -> \\'z\\' -> \\'a\\' -> t[i]\\n        }\\n    }\\n    let m = counter(step);\\n    for (const [x, occ] of m) {\\n        if (x == 0) continue;\\n        if (x > k) return false; // over k cannot move\\n        let can = parseInt((k - x) / 26) + 1; // possible all different moves  x + 26 * (1, 2, 3 ......)\\n        if (occ > can) return false; // under k, but can doesn\\'t enough for occurrence\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst ord = (c) => c.charCodeAt();\\nconst counter = (a_or_s) => { let m = new Map(); for (const x of a_or_s) m.set(x, m.get(x) + 1 || 1); return m; };\\n\\nconst canConvertString = (s, t, k) => {\\n    if (s.length != t.length) return false;\\n    let n = s.length, step = Array(n).fill(0);\\n    for (let i = 0; i < n; i++) { // calculate each step move\\n        if (s[i] <= t[i]) {\\n            step[i] = ord(t[i]) - ord(s[i]);\\n        } else {\\n            step[i] = 122 - ord(s[i]) + 1 + ord(t[i]) - 97;  // s[i] -> \\'z\\' -> \\'a\\' -> t[i]\\n        }\\n    }\\n    let m = counter(step);\\n    for (const [x, occ] of m) {\\n        if (x == 0) continue;\\n        if (x > k) return false; // over k cannot move\\n        let can = parseInt((k - x) / 26) + 1; // possible all different moves  x + 26 * (1, 2, 3 ......)\\n        if (occ > can) return false; // under k, but can doesn\\'t enough for occurrence\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2069898,
                "title": "simple-python-solution-space-o-1-time-o-n",
                "content": "**Steps:**\\n1. Check if the length for strings are equal. If not, then return False.\\n2. Store the counts of difference from s[i] to t[i].\\n3. Multiply the count by 26 and add the difference if s[i] != t[i]. This is done because for the first occurence of the difference, we need to add it. And for extra occurences of the difference, we need to add 26 to it each time so that i(mentioned in the question) would be unique for each occurrence.\\n4. If the above value is more than k then return False.\\n5. If the whole string gets parsed, return True.\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n        #If length of strings are different return False\\n        if len(s) != len(t):\\n            return False\\n        \\n        check = [0]*26  #List which stores counts of t[i] - s[i]\\n        \\n        #Storing counts of t[i] - s[i] for 0 <= i < len(s)\\n        for i in range(len(s)):\\n            if s[i] != t[i]:\\n                temp = ( ord(t[i]) - ord(s[i]) ) % 26\\n                big = temp + 26*check[temp]\\n                check[temp] += 1\\n                if big > k:\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n        #If length of strings are different return False\\n        if len(s) != len(t):\\n            return False\\n        \\n        check = [0]*26  #List which stores counts of t[i] - s[i]\\n        \\n        #Storing counts of t[i] - s[i] for 0 <= i < len(s)\\n        for i in range(len(s)):\\n            if s[i] != t[i]:\\n                temp = ( ord(t[i]) - ord(s[i]) ) % 26\\n                big = temp + 26*check[temp]\\n                check[temp] += 1\\n                if big > k:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069204,
                "title": "easy-o-n-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        HashMap<Integer, Integer> mp=new HashMap();\\n        if(s.length()!=t.length())return false;\\n        for(int i=0;i<s.length();i++){\\n            int temp = 0;\\n            if((int)(s.charAt(i))<(int)(t.charAt(i))){\\n                temp = (int)(t.charAt(i))-(int)(s.charAt(i));\\n                if(!mp.containsKey(temp))mp.put(temp,1);\\n                else mp.put(temp,mp.get(temp)+1);\\n            }\\n            else if((int)(s.charAt(i))>(int)(t.charAt(i))){\\n                temp = 26 - s.charAt(i) + t.charAt(i);\\n                if(!mp.containsKey(temp))mp.put(temp, 1);\\n                else mp.put(temp,mp.get(temp)+1);\\n            }\\n            else continue;\\n        }\\n        for(int i:mp.keySet()){\\n            int fre = mp.get(i);\\n            int temp = i + (fre-1)*26;\\n            if(temp>k)return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        HashMap<Integer, Integer> mp=new HashMap();\\n        if(s.length()!=t.length())return false;\\n        for(int i=0;i<s.length();i++){\\n            int temp = 0;\\n            if((int)(s.charAt(i))<(int)(t.charAt(i))){\\n                temp = (int)(t.charAt(i))-(int)(s.charAt(i));\\n                if(!mp.containsKey(temp))mp.put(temp,1);\\n                else mp.put(temp,mp.get(temp)+1);\\n            }\\n            else if((int)(s.charAt(i))>(int)(t.charAt(i))){\\n                temp = 26 - s.charAt(i) + t.charAt(i);\\n                if(!mp.containsKey(temp))mp.put(temp, 1);\\n                else mp.put(temp,mp.get(temp)+1);\\n            }\\n            else continue;\\n        }\\n        for(int i:mp.keySet()){\\n            int fre = mp.get(i);\\n            int temp = i + (fre-1)*26;\\n            if(temp>k)return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037161,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if(s.length()!=t.length()) return false;\\n        \\n        vector<pair<int,int>> v(27, {0,0});\\n        \\n        long long maxK = -1;\\n        for(int i=0; i<s.length(); i++) {\\n            long long diff;\\n            if(s[i] == t[i]) {\\n                continue;\\n            } else if(s[i] < t[i]) {\\n                diff = t[i] - s[i];\\n            } else {\\n                diff = 26 - (s[i] - t[i]);\\n            }\\n            \\n            if(v[diff].first == 0) {\\n                v[diff].first = 1;\\n                maxK = max(maxK, diff);\\n            } else {\\n                v[diff].second += 1;\\n                diff = 26*v[diff].second + diff;\\n                maxK = max(maxK, diff);\\n            }\\n        }\\n        return (maxK>k)?false:true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if(s.length()!=t.length()) return false;\\n        \\n        vector<pair<int,int>> v(27, {0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2008682,
                "title": "declarative-ruby-one-liner-beats-100-100",
                "content": "```\\n# @param {String} s\\n# @param {String} t\\n# @param {Integer} k\\n# @return {Boolean}\\ndef can_convert_string(s, t, k)\\n  s.size == t.size && t.bytes.zip(s.bytes).map { (_1 - _2) % 26 }.tally.all? { _1 == 0 || _2 <= (k - _1) / 26 + 1 }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {String} s\\n# @param {String} t\\n# @param {Integer} k\\n# @return {Boolean}\\ndef can_convert_string(s, t, k)\\n  s.size == t.size && t.bytes.zip(s.bytes).map { (_1 - _2) % 26 }.tally.all? { _1 == 0 || _2 <= (k - _1) / 26 + 1 }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1925423,
                "title": "c-very-fast-and-memory-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()) return false;\\n        int n = s.length();\\n        vector<int> v(26);\\n        for(int i=0;i<n;i++){\\n            if(s[i]<=t[i]) v[t[i]-s[i]]++;\\n            else{\\n                int d1 = \\'z\\' - s[i];\\n                int d2 = t[i] -\\'a\\' + 1;\\n                v[d1+d2]++;\\n            }\\n        }\\n        for(int i=1;i<26;i++){\\n            if(v[i]){\\n                int q = k/26;\\n                int r = k%26;\\n                if(r>=i) q += 1;\\n                if(v[i]>q) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()) return false;\\n        int n = s.length();\\n        vector<int> v(26);\\n        for(int i=0;i<n;i++){\\n            if(s[i]<=t[i]) v[t[i]-s[i]]++;\\n            else{\\n                int d1 = \\'z\\' - s[i];\\n                int d2 = t[i] -\\'a\\' + 1;\\n                v[d1+d2]++;\\n            }\\n        }\\n        for(int i=1;i<26;i++){\\n            if(v[i]){\\n                int q = k/26;\\n                int r = k%26;\\n                if(r>=i) q += 1;\\n                if(v[i]>q) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892437,
                "title": "python3-o-n-simple-to-understand",
                "content": "* just get an array of the shift values and if the shift value has been seen \\'n\\' times, the largest move we need is:\\n\\t* shift value + \\'n\\' * 26\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s)!=len(t): return False\\n        arr=[ord(b)-ord(a) if b>a else 26-(ord(a)-ord(b)) for a,b in zip(s,t) if a!=b]\\n        dct=collections.Counter()\\n        for el in arr:\\n            if el+dct[el]*26>k: return False\\n            dct[el]+=1\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s)!=len(t): return False\\n        arr=[ord(b)-ord(a) if b>a else 26-(ord(a)-ord(b)) for a,b in zip(s,t) if a!=b]\\n        dct=collections.Counter()\\n        for el in arr:\\n            if el+dct[el]*26>k: return False\\n            dct[el]+=1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889772,
                "title": "hashmap",
                "content": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) return false;\\n        \\n        var map = new HashMap<Integer, Integer>();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (t.charAt(i) == s.charAt(i)) continue;\\n            else if (t.charAt(i) - s.charAt(i) > 0) {\\n                var c = t.charAt(i) - s.charAt(i);\\n                map.put(c, map.getOrDefault(c, 0) + 1);\\n            } else {\\n                var c = 26 - s.charAt(i) + t.charAt(i);\\n                map.put(c, map.getOrDefault(c, 0) + 1);\\n            }\\n        }\\n        \\n        var used = new HashSet<Integer>();\\n        for (var it : map.entrySet()) {\\n            var next = it.getKey();\\n            \\n            for (int i = it.getValue(); i > 0; i--) {\\n                while(used.contains(next)) next += 26;\\n                \\n                if (next > k) return false;\\n                else used.add(next);\\n            }   \\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) return false;\\n        \\n        var map = new HashMap<Integer, Integer>();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (t.charAt(i) == s.charAt(i)) continue;\\n            else if (t.charAt(i) - s.charAt(i) > 0) {\\n                var c = t.charAt(i) - s.charAt(i);\\n                map.put(c, map.getOrDefault(c, 0) + 1);\\n            } else {\\n                var c = 26 - s.charAt(i) + t.charAt(i);\\n                map.put(c, map.getOrDefault(c, 0) + 1);\\n            }\\n        }\\n        \\n        var used = new HashSet<Integer>();\\n        for (var it : map.entrySet()) {\\n            var next = it.getKey();\\n            \\n            for (int i = it.getValue(); i > 0; i--) {\\n                while(used.contains(next)) next += 26;\\n                \\n                if (next > k) return false;\\n                else used.add(next);\\n            }   \\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1870337,
                "title": "c-freq",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) {\\n            return false;\\n        }\\n        \\n        int shifts[26] = {0};\\n        for (int i = 1; i < 26; ++i) {\\n            shifts[i] = k / 26 + (i <= (k % 26));\\n        }\\n        \\n        for (int i = 0; i < s.size(); ++i) {\\n\\t\\t    auto idx = t[i] - s[i] + (s[i] < t[i] ? 0 : 26);\\n            if (s[i] != t[i] && --shifts[idx] < 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) {\\n            return false;\\n        }\\n        \\n        int shifts[26] = {0};\\n        for (int i = 1; i < 26; ++i) {\\n            shifts[i] = k / 26 + (i <= (k % 26));\\n        }\\n        \\n        for (int i = 0; i < s.size(); ++i) {\\n\\t\\t    auto idx = t[i] - s[i] + (s[i] < t[i] ? 0 : 26);\\n            if (s[i] != t[i] && --shifts[idx] < 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774010,
                "title": "java-sharing-code",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        if(s.length()!=t.length())\\n            return false;\\n        int[] arr = new int [26];\\n        int mini = k/26;\\n        int limit = k%26;\\n        for(int i=0;i<26;i++){\\n            arr[i]=mini;\\n            if(limit>=i)\\n                arr[i]++;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int cnt = ((t.charAt(i)-s.charAt(i))+26)%26;\\n            if(cnt==0)\\n                continue;\\n            arr[cnt]--;\\n            if(arr[cnt]<0)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        if(s.length()!=t.length())\\n            return false;\\n        int[] arr = new int [26];\\n        int mini = k/26;\\n        int limit = k%26;\\n        for(int i=0;i<26;i++){\\n            arr[i]=mini;\\n            if(limit>=i)\\n                arr[i]++;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int cnt = ((t.charAt(i)-s.charAt(i))+26)%26;\\n            if(cnt==0)\\n                continue;\\n            arr[cnt]--;\\n            if(arr[cnt]<0)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711905,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n     int size=s.size(),n=t.size();\\n        if(size!=n)\\n            return false;\\n        unordered_map<int,int>cnt;\\n        for(int i=0;i<size;i++){\\n            int dist=t[i]-s[i];\\n            dist+=(dist<0)?26:0;\\n            if(dist==0)\\n                continue;\\n            cnt[dist]++;\\n        }\\n        for(auto & p:cnt){\\n           int maxi=26*(p.second-1)+p.first; \\n            if(maxi>k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n     int size=s.size(),n=t.size();\\n        if(size!=n)\\n            return false;\\n        unordered_map<int,int>cnt;\\n        for(int i=0;i<size;i++){\\n            int dist=t[i]-s[i];\\n            dist+=(dist<0)?26:0;\\n            if(dist==0)\\n                continue;\\n            cnt[dist]++;\\n        }\\n        for(auto & p:cnt){\\n           int maxi=26*(p.second-1)+p.first; \\n            if(maxi>k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707045,
                "title": "easy-explained-solution-using-map",
                "content": "1. If length( s ) and length( t ) are not equal, then it\\'ll never be possible to convert, because we are not allowed to add or remove character from the strings. Hence ans = false.\\n\\nWe want to store remainder, as well as frequency into the map.\\nEx.1. For \\'a\\' to \\'z\\' conversion, \\'z\\' - \\'a\\' = 25, Added with 26 and take mod 26, rem = (25+26)%26 = 25.\\nEx.2. For \\'z\\' to \\'a\\' conversion, \\'a\\' - \\'z\\' = -25, added 26 and take mod 26, rem = (-25+26)%26 = 1.\\nSo 26 is added to avoid negative remainder, as we are only allowed to move forword.\\n\\n2. Ex.3. For s = \\'aaab\\' to t = \\'bbbb\\' conversion, we want three \\'a\\' to \\'b\\' conversion.\\nSo, rem = (\\'b\\'-\\'a\\'+26)%26 = 1, frequency = 3.\\nfor s[0] = \\'a\\' to t[0] = \\'b\\', we need 1st move, we use 1st move,\\nfor s[1] = \\'a\\' to t[1] = \\'b\\', we need 1st move too, we use (1+(26\\\\*1) ) = 27th move,\\nfor s[2] = \\'a\\' to t[2] = \\'b\\', we need 1st move too, we use (1+(26\\\\*2) ) = 53rd move,\\nHence, if for a particular remainder frequency = \\'x\\', we\\'re gonna check, if \\'(x-1)\\\\*26 + rem\\' belongs to the range [0, k] or not.\\nSo, we directly check for 53 <= k, if not, then ans = false.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int, int> mp;\\n        int n = s.size(), i, rem, freq;\\n        if( t.size() != n )return false;\\n        for( i = 0; i < n; i++ ){\\n            if( s[i] == t[i] )continue;\\n            rem = ( t[i] - s[i] + 26)%26;\\n            mp[rem]++;\\n        }\\n        for( auto& x : mp ){\\n            rem = x.first;\\n            freq = x.second;\\n            if( ( freq-1 )*26 + rem > k )return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\nFeel free to comment and upvote ;)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int, int> mp;\\n        int n = s.size(), i, rem, freq;\\n        if( t.size() != n )return false;\\n        for( i = 0; i < n; i++ ){\\n            if( s[i] == t[i] )continue;\\n            rem = ( t[i] - s[i] + 26)%26;\\n            mp[rem]++;\\n        }\\n        for( auto& x : mp ){\\n            rem = x.first;\\n            freq = x.second;\\n            if( ( freq-1 )*26 + rem > k )return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701407,
                "title": "easy-map-set-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int, int>hash;\\n        unordered_set<int>umap;\\n        if(s.length() != t.length()){\\n            return false;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == t[i]){\\n                continue;\\n            }\\n            int a = ((t[i]-\\'a\\')-(s[i]-\\'a\\') + 26)%26;\\n            hash[a]++;\\n        }\\n       \\n        for(auto x : hash){\\n            int move = (k/26);\\n            if(k%26 and x.first<=k%26){\\n                move++;\\n            }\\n            cout << move << endl;\\n            if(move < x.second or umap.count(x.first)){\\n                return false;\\n            }\\n            umap.insert(x.first);\\n        }\\n        return true;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int, int>hash;\\n        unordered_set<int>umap;\\n        if(s.length() != t.length()){\\n            return false;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == t[i]){\\n                continue;\\n            }\\n            int a = ((t[i]-\\'a\\')-(s[i]-\\'a\\') + 26)%26;\\n            hash[a]++;\\n        }\\n       \\n        for(auto x : hash){\\n            int move = (k/26);\\n            if(k%26 and x.first<=k%26){\\n                move++;\\n            }\\n            cout << move << endl;\\n            if(move < x.second or umap.count(x.first)){\\n                return false;\\n            }\\n            umap.insert(x.first);\\n        }\\n        return true;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1668896,
                "title": "c-linq-one-liner-o-n-time",
                "content": "```\\npublic class Solution \\n{\\n    public bool CanConvertString(string s, string t, int k) \\n        => s.Length == t.Length && \\n           s.Zip(t, (c1, c2) => (26 + c2 - c1) % 26)\\n            .GroupBy(x => x)\\n            .All(g => g.Key == 0 || (g.Count() - 1) * 26 + g.Key <= k);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public bool CanConvertString(string s, string t, int k) \\n        => s.Length == t.Length && \\n           s.Zip(t, (c1, c2) => (26 + c2 - c1) % 26)\\n            .GroupBy(x => x)\\n            .All(g => g.Key == 0 || (g.Count() - 1) * 26 + g.Key <= k);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667151,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        HashMap<Integer,Character> set=new HashMap<>();\\n        int n=s.length();\\n        int m=t.length();\\n        if(m!=n)\\n            return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            char x=s.charAt(i);\\n            char y=t.charAt(i);\\n            int key=(y-x);\\n            if(key<0)\\n            {\\n                key=key+26;\\n            }\\n            else if(key==0)\\n                continue;\\n            if(key>k)\\n                return false;\\n            else if(set.containsKey(key))\\n            {\\n                while(set.containsKey(key))\\n                {\\n                    key=getNum(key);\\n                    if(key>k)\\n                        return false;\\n                }\\n                set.put(key,x);\\n            }\\n            else if(!set.containsKey(key))\\n            {\\n                set.put(key,x);\\n            }\\n            \\n            \\n        }\\n        return true;\\n        \\n        \\n    }\\n    public int getNum(int m)\\n    {\\n        return (26+m);\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        HashMap<Integer,Character> set=new HashMap<>();\\n        int n=s.length();\\n        int m=t.length();\\n        if(m!=n)\\n            return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            char x=s.charAt(i);\\n            char y=t.charAt(i);\\n            int key=(y-x);\\n            if(key<0)\\n            {\\n                key=key+26;\\n            }\\n            else if(key==0)\\n                continue;\\n            if(key>k)\\n                return false;\\n            else if(set.containsKey(key))\\n            {\\n                while(set.containsKey(key))\\n                {\\n                    key=getNum(key);\\n                    if(key>k)\\n                        return false;\\n                }\\n                set.put(key,x);\\n            }\\n            else if(!set.containsKey(key))\\n            {\\n                set.put(key,x);\\n            }\\n            \\n            \\n        }\\n        return true;\\n        \\n        \\n    }\\n    public int getNum(int m)\\n    {\\n        return (26+m);\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666195,
                "title": "golang-o-n-count-group-by-shift-move",
                "content": "```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s) != len(t) {\\n        return false\\n    }\\n    \\n    count := make([]int, 26)\\n    for i := range s {\\n        var d byte\\n        if s[i] <= t[i] {\\n            d = t[i] - s[i]\\n        } else {\\n            d = t[i] + 26 - s[i]\\n        }\\n        \\n        if int(d) > k {\\n            return false\\n        }\\n        \\n        count[d]++\\n    }\\n    \\n    for i := 1; i < 26; i++ {\\n        if count[i] > 0 {\\n            if max := i + int(count[i] - 1) * 26; max > k {\\n                return false\\n            }\\n        }\\n    } \\n    \\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s) != len(t) {\\n        return false\\n    }\\n    \\n    count := make([]int, 26)\\n    for i := range s {\\n        var d byte\\n        if s[i] <= t[i] {\\n            d = t[i] - s[i]\\n        } else {\\n            d = t[i] + 26 - s[i]\\n        }\\n        \\n        if int(d) > k {\\n            return false\\n        }\\n        \\n        count[d]++\\n    }\\n    \\n    for i := 1; i < 26; i++ {\\n        if count[i] > 0 {\\n            if max := i + int(count[i] - 1) * 26; max > k {\\n                return false\\n            }\\n        }\\n    } \\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1660061,
                "title": "count-req-and-available-operations",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n        \\n        vector<int> req(26,0);\\n        for(int i=0;i<s.size();i++){\\n            req[(t[i]-s[i]+26)%26]++;\\n        }\\n        vector<int> avail(26,(k+1)/26);\\n        int temp=k%26;\\n        \\n        for(int j=1;j<=temp;j++) avail[j]++;\\n        \\n        for(int i=1;i<26;i++){\\n            if(req[i]>avail[i]) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n        \\n        vector<int> req(26,0);\\n        for(int i=0;i<s.size();i++){\\n            req[(t[i]-s[i]+26)%26]++;\\n        }\\n        vector<int> avail(26,(k+1)/26);\\n        int temp=k%26;\\n        \\n        for(int j=1;j<=temp;j++) avail[j]++;\\n        \\n        for(int i=1;i<26;i++){\\n            if(req[i]>avail[i]) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654414,
                "title": "golang",
                "content": "some examples to calc char offset:\\n\\ns[i] -> t[i]\\n\\n\\'a\\' -> \\'c\\' = 2 - 0 = 2 moves\\n\\n\\'c\\' -> \\'a\\' = 0 + 26 - 2 = 24 moves\\n\\n\\n\\n\\'a\\' -> \\'z\\' = 25 - 0 = 25 moves\\n\\n\\'z\\' -> \\'a\\' = 0 + 26 - 25 = 1 move\\n\\n```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s) != len(t) {\\n        return false\\n    }\\n    \\n    cache := make([]int, 26) // how many ops needed\\n    for i := range s {\\n        if s[i] != t[i] {  // needs shifting\\n            opsNeeded := int(t[i] + 26 - s[i]) % 26\\n            turn := opsNeeded + 26 * cache[opsNeeded]\\n            cache[opsNeeded]++\\n            \\n            if turn > k {\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s) != len(t) {\\n        return false\\n    }\\n    \\n    cache := make([]int, 26) // how many ops needed\\n    for i := range s {\\n        if s[i] != t[i] {  // needs shifting\\n            opsNeeded := int(t[i] + 26 - s[i]) % 26\\n            turn := opsNeeded + 26 * cache[opsNeeded]\\n            cache[opsNeeded]++\\n            \\n            if turn > k {\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1605985,
                "title": "c-52ms-99-45-simple-easy-small-time-on-space-o1-operators-only-and",
                "content": "Runtime: 52 ms, faster than 99.45% of C++ online submissions for Can Convert String in K Moves.\\nMemory Usage: 17.7 MB, less than 77.35% of C++ online submissions for Can Convert String in K Moves.\\n\\n```\\nclass Solution {\\npublic:\\n  bool canConvertString(string s, string t, int k) {\\n    if(s.size() != t.size()) return false;\\n    int table[26];\\n    for(int i = 0; i != 26; i++) table[i] = i - 26;\\n    \\n    for(int i = 0; i != s.size(); i++)\\n      if(int def = t[i] - s[i])\\n        if((table[def > 0 ? def : def += 26] += 26) > k) return false;      \\n    \\n    return true;      \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool canConvertString(string s, string t, int k) {\\n    if(s.size() != t.size()) return false;\\n    int table[26];\\n    for(int i = 0; i != 26; i++) table[i] = i - 26;\\n    \\n    for(int i = 0; i != s.size(); i++)\\n      if(int def = t[i] - s[i])\\n        if((table[def > 0 ? def : def += 26] += 26) > k) return false;      \\n    \\n    return true;      \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588760,
                "title": "clearly-explained-python3-faster-than-91",
                "content": "```\\n#Faster than 91% of submissions\\n\\ndef rightmost_argmax(l):\\n    #Return the index and element of the largest element in l that\\'s furthest to the right\\n    i,e=max(enumerate(l),key=lambda x:x[::-1])\\n    return i,e\\n\\ndef min_k(s,t):\\n    \\n    #Assert s and t are two lower-case alphabetical strings of the same length\\n    assert len(s)==len(t) and isinstance(s,str) and isinstance(t,str)\\n    assert s.isalpha() and t.isalpha()\\n    assert s==s.lower() and t==t.lower()\\n\\n    #If s and t are the same string, we don\\'t need any shifts\\n    if s==t:\\n        return 0\\n    \\n    #The rest of this code assumes we need at least one shift\\n    \\n    #Calculate required shifts between letters (d=deltas)\\n    d=[(ord(y)-ord(x))%26 for x,y in zip(s,t)]\\n    \\n    #All elements in d should be integers between 0 and 25 because of the modulo\\n    assert max(d)<=25\\n    \\n    #Calculate a histogram of the elements in d\\n    h=[0]*26 \\n    for x in d:\\n        h[x]+=1\\n        \\n    #Ignore the times we didn\\'t need to change anything\\n    h[0]=0\\n    \\n    #At least one element needs to be changed, because we know if we\\'ve reached this line s!=t\\n    assert not all(x==0 for x in d)\\n    \\n    #This is the main solution here: Whatever shift we need more than once needs to wrap around the 26 letters that many times (the 26*(e-1)), then shift a little more (the +i term)\\n    i,e=rightmost_argmax(h)\\n    return 26*(e-1)+i\\n\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        try:\\n            return k>=min_k(s,t)\\n        except AssertionError:\\n            return False\\n        ```",
                "solutionTags": [],
                "code": "```\\n#Faster than 91% of submissions\\n\\ndef rightmost_argmax(l):\\n    #Return the index and element of the largest element in l that\\'s furthest to the right\\n    i,e=max(enumerate(l),key=lambda x:x[::-1])\\n    return i,e\\n\\ndef min_k(s,t):\\n    \\n    #Assert s and t are two lower-case alphabetical strings of the same length\\n    assert len(s)==len(t) and isinstance(s,str) and isinstance(t,str)\\n    assert s.isalpha() and t.isalpha()\\n    assert s==s.lower() and t==t.lower()\\n\\n    #If s and t are the same string, we don\\'t need any shifts\\n    if s==t:\\n        return 0\\n    \\n    #The rest of this code assumes we need at least one shift\\n    \\n    #Calculate required shifts between letters (d=deltas)\\n    d=[(ord(y)-ord(x))%26 for x,y in zip(s,t)]\\n    \\n    #All elements in d should be integers between 0 and 25 because of the modulo\\n    assert max(d)<=25\\n    \\n    #Calculate a histogram of the elements in d\\n    h=[0]*26 \\n    for x in d:\\n        h[x]+=1\\n        \\n    #Ignore the times we didn\\'t need to change anything\\n    h[0]=0\\n    \\n    #At least one element needs to be changed, because we know if we\\'ve reached this line s!=t\\n    assert not all(x==0 for x in d)\\n    \\n    #This is the main solution here: Whatever shift we need more than once needs to wrap around the 26 letters that many times (the 26*(e-1)), then shift a little more (the +i term)\\n    i,e=rightmost_argmax(h)\\n    return 26*(e-1)+i\\n\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        try:\\n            return k>=min_k(s,t)\\n        except AssertionError:\\n            return False\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 1574043,
                "title": "10-line-of-code-simple-o-n-solution-and-o-1-space-solution-easy-and-cake-walk",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s==t) return true;\\n        if(s.size()!=t.size() or k==0) return false;\\n        vector<int>vec;\\n        int mp[26]; memset(mp,0,sizeof(mp));\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int diff = t[i]-s[i];\\n            if(diff<0) diff+=26;\\n            \\n            if(diff>0)\\n            {\\n                vec.push_back(mp[diff]*26 + diff);\\n                mp[diff]++;\\n            }\\n        }\\n        \\n        \\n        return (*max_element(vec.begin(),vec.end())<=k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s==t) return true;\\n        if(s.size()!=t.size() or k==0) return false;\\n        vector<int>vec;\\n        int mp[26]; memset(mp,0,sizeof(mp));\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int diff = t[i]-s[i];\\n            if(diff<0) diff+=26;\\n            \\n            if(diff>0)\\n            {\\n                vec.push_back(mp[diff]*26 + diff);\\n                mp[diff]++;\\n            }\\n        }\\n        \\n        \\n        return (*max_element(vec.begin(),vec.end())<=k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528283,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int n = s.size(), nn = t.size();\\n        if(n != nn) {\\n            return false;\\n        }\\n        unordered_map<int,int> m;\\n        for(int i=0; i<n; i++) {\\n            if(s[i] == t[i]) {\\n                continue;\\n            }\\n            int a = t[i] - \\'a\\';\\n            int b = s[i] - \\'a\\';\\n            int k;\\n            if(a > b) {\\n                k = a-b;\\n            } else {\\n                k = 26 - (b-a);\\n            }\\n            m[k]++;\\n        }\\n        for(auto x: m) {\\n            int a = x.first;\\n            int b = x.second;\\n            while(b--) {\\n                if(a > k) {\\n                    return false;\\n                }\\n                a += 26;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int n = s.size(), nn = t.size();\\n        if(n != nn) {\\n            return false;\\n        }\\n        unordered_map<int,int> m;\\n        for(int i=0; i<n; i++) {\\n            if(s[i] == t[i]) {\\n                continue;\\n            }\\n            int a = t[i] - \\'a\\';\\n            int b = s[i] - \\'a\\';\\n            int k;\\n            if(a > b) {\\n                k = a-b;\\n            } else {\\n                k = 26 - (b-a);\\n            }\\n            m[k]++;\\n        }\\n        for(auto x: m) {\\n            int a = x.first;\\n            int b = x.second;\\n            while(b--) {\\n                if(a > k) {\\n                    return false;\\n                }\\n                a += 26;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527738,
                "title": "java-14ms-t-c-o-n-s-c-o-26-easy",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int len1 = s.length(), len2 = t.length();\\n        \\n        if(len1 != len2)\\n            return false;\\n        \\n        if(s.equals(t))\\n            return true;\\n        \\n        int[] Freq = new int[26];\\n        \\n        int multiple = k / 26;\\n        for(int i = 0; i < 26; i++) {\\n            Freq[i] = multiple;\\n        }\\n        \\n        int rem = k % 26;\\n        for(int i = 1; i <= rem; i++)\\n            Freq[i]++;\\n        \\n        int movesRemaining = k;\\n        \\n        for(int i = 0; i < len1; i++) {\\n            char ch1 = s.charAt(i);\\n            char ch2 = t.charAt(i);\\n            \\n            if(ch1 == ch2) {\\n                movesRemaining--;\\n                continue;\\n            }\\n            \\n            int diff = (ch2 - ch1 + 26) % 26;\\n            \\n            if(Freq[diff] > 0) {\\n                Freq[diff]--;\\n                movesRemaining--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return movesRemaining >= 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int len1 = s.length(), len2 = t.length();\\n        \\n        if(len1 != len2)\\n            return false;\\n        \\n        if(s.equals(t))\\n            return true;\\n        \\n        int[] Freq = new int[26];\\n        \\n        int multiple = k / 26;\\n        for(int i = 0; i < 26; i++) {\\n            Freq[i] = multiple;\\n        }\\n        \\n        int rem = k % 26;\\n        for(int i = 1; i <= rem; i++)\\n            Freq[i]++;\\n        \\n        int movesRemaining = k;\\n        \\n        for(int i = 0; i < len1; i++) {\\n            char ch1 = s.charAt(i);\\n            char ch2 = t.charAt(i);\\n            \\n            if(ch1 == ch2) {\\n                movesRemaining--;\\n                continue;\\n            }\\n            \\n            int diff = (ch2 - ch1 + 26) % 26;\\n            \\n            if(Freq[diff] > 0) {\\n                Freq[diff]--;\\n                movesRemaining--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return movesRemaining >= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446966,
                "title": "go-o-n-time-o-1-space-1-pass",
                "content": "```go\\nfunc canConvertString(s string, t string, k int) bool {\\n\\tif len(s) != len(t) {\\n\\t\\treturn false\\n\\t}\\n\\n\\tvar shifts [26]int // how many times we need to shift n steps?\\n\\n\\tfor i, c := range s {\\n\\t\\tx := int(c - \\'a\\')\\n\\t\\ty := int(t[i] - \\'a\\')\\n\\n\\t\\tif x != y {\\n\\t\\t\\tstep := (y - x + 26) % 26\\n\\t\\t\\tshifts[step]++\\n\\t\\t\\tif step + (shifts[step]-1)*26 >k {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc canConvertString(s string, t string, k int) bool {\\n\\tif len(s) != len(t) {\\n\\t\\treturn false\\n\\t}\\n\\n\\tvar shifts [26]int // how many times we need to shift n steps?\\n\\n\\tfor i, c := range s {\\n\\t\\tx := int(c - \\'a\\')\\n\\t\\ty := int(t[i] - \\'a\\')\\n\\n\\t\\tif x != y {\\n\\t\\t\\tstep := (y - x + 26) % 26\\n\\t\\t\\tshifts[step]++\\n\\t\\t\\tif step + (shifts[step]-1)*26 >k {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428497,
                "title": "easy-c-map-solution",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int n=s.length();\\n        if(s.length()!=t.length())\\n            return false;\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=t[i])\\n            {\\n                int z=t[i]-s[i];\\n                if(z<0)\\n                    z+=26;\\n                mp[z]++;\\n            }\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.first>k)\\n                return false;\\n            if(it.second>1)\\n            {\\n                mp[it.first+26]+=it.second-1;\\n            }\\n        }\\n        return true;\\n    }\\n};``\\nUpvote if you like :)",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1423160,
                "title": "python-3-using-hashmap",
                "content": "```\\ndef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\tls, lt = len(s), len(t)\\n\\tif ls!=lt:\\n\\t\\treturn False\\n\\n\\tdone = {}\\n\\n\\tfor i in range(0, ls):\\n\\t\\tif s[i]==t[i]:\\n\\t\\t\\tcontinue\\n\\t\\tif s[i]<t[i]:\\n\\t\\t\\tmove = ord(t[i])-ord(s[i])\\n\\t\\telse:\\n\\t\\t\\tmove = 26-(ord(s[i])-96)+(ord(t[i])-96)\\n\\n\\t\\tif move in done:\\n\\t\\t\\tdone[move]+=1\\n\\t\\t\\tmove+=(done[move]-1)*26\\n\\t\\telse:\\n\\t\\t\\tdone[move] = 1\\n\\n\\t\\tif move>k:\\n\\t\\t\\treturn False\\n\\treturn True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\tls, lt = len(s), len(t)\\n\\tif ls!=lt:\\n\\t\\treturn False\\n\\n\\tdone = {}\\n\\n\\tfor i in range(0, ls):\\n\\t\\tif s[i]==t[i]:\\n\\t\\t\\tcontinue\\n\\t\\tif s[i]<t[i]:\\n\\t\\t\\tmove = ord(t[i])-ord(s[i])\\n\\t\\telse:\\n\\t\\t\\tmove = 26-(ord(s[i])-96)+(ord(t[i])-96)\\n\\n\\t\\tif move in done:\\n\\t\\t\\tdone[move]+=1\\n\\t\\t\\tmove+=(done[move]-1)*26\\n\\t\\telse:\\n\\t\\t\\tdone[move] = 1\\n\\n\\t\\tif move>k:\\n\\t\\t\\treturn False\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1366245,
                "title": "c-easy-multiplier-tracker",
                "content": "```\\npublic bool CanConvertString(string s, string t, int k) {\\n\\t//TAKING care of base case\\n\\n\\tif(s.Length != t.Length) return false;\\n\\t //Keep track of counter of multiplier\\n\\tint [] mul = new int[26];\\n\\n\\tfor(int i = 0 ; i < s.Length ; i++)\\n\\t{\\n\\t\\t//here we wre finding the shift\\n\\t\\tint shift = t[i] - s[i] + (s[i] > t[i] ? 26 :0);\\n\\n\\t\\t//now check the moves should not greater then k\\n\\n\\t\\tif(shift !=0 && shift + mul[shift] *26 >k)\\n\\t\\t\\treturn false;\\n\\n\\t\\tmul[shift]++;\\n\\t}\\n\\n\\treturn true;\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic bool CanConvertString(string s, string t, int k) {\\n\\t//TAKING care of base case\\n\\n\\tif(s.Length != t.Length) return false;\\n\\t //Keep track of counter of multiplier\\n\\tint [] mul = new int[26];\\n\\n\\tfor(int i = 0 ; i < s.Length ; i++)\\n\\t{\\n\\t\\t//here we wre finding the shift\\n\\t\\tint shift = t[i] - s[i] + (s[i] > t[i] ? 26 :0);\\n\\n\\t\\t//now check the moves should not greater then k\\n\\n\\t\\tif(shift !=0 && shift + mul[shift] *26 >k)\\n\\t\\t\\treturn false;\\n\\n\\t\\tmul[shift]++;\\n\\t}\\n\\n\\treturn true;\\n}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1312263,
                "title": "c-solution-o-n-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int,int> m;\\n        if(s.length()!=t.length())\\n            return(false);\\n        int q=k/26,o=k%26;\\n        for(int l=0;l<=25;l++)\\n        {\\n            if(l<=o)\\n                m[l]++;\\n            m[l]+=q;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int p=t[i]-s[i];\\n            if(p<0)\\n            {\\n                p=(\\'z\\'-s[i])+1+(t[i]-\\'a\\');\\n            }\\n            if(p>0)\\n            {\\n                if(m[p]==0)\\n                {\\n                    return(false);\\n                }\\n                m[p]--;\\n            }\\n        }\\n        return(true);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int,int> m;\\n        if(s.length()!=t.length())\\n            return(false);\\n        int q=k/26,o=k%26;\\n        for(int l=0;l<=25;l++)\\n        {\\n            if(l<=o)\\n                m[l]++;\\n            m[l]+=q;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int p=t[i]-s[i];\\n            if(p<0)\\n            {\\n                p=(\\'z\\'-s[i])+1+(t[i]-\\'a\\');\\n            }\\n            if(p>0)\\n            {\\n                if(m[p]==0)\\n                {\\n                    return(false);\\n                }\\n                m[p]--;\\n            }\\n        }\\n        return(true);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309687,
                "title": "go-solution",
                "content": "//credits: https://leetcode.com/problems/can-convert-string-in-k-moves/discuss/1268156/Easy-C%2B%2B-solution-using-Map\\n```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s)!=len(t) {\\n        return false\\n    }\\n    val:=0\\n    m:=make(map[int]int)\\n    for i, _ := range s {\\n        val = int(t[i])-int(s[i])\\n        if val < 0  {\\n            val = 26-abs(val)\\n        }  \\n        if val >0 {\\n            m[val]+=1\\n        }  \\n    }\\n    for key, v := range m {\\n        if k<(26*(v-1)+key) {\\n            return false\\n        }\\n    }\\n    return true\\n}\\nfunc abs(n int) int {\\n    if n<0 {\\n        return -n\\n    }\\n    return n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s)!=len(t) {\\n        return false\\n    }\\n    val:=0\\n    m:=make(map[int]int)\\n    for i, _ := range s {\\n        val = int(t[i])-int(s[i])\\n        if val < 0  {\\n            val = 26-abs(val)\\n        }  \\n        if val >0 {\\n            m[val]+=1\\n        }  \\n    }\\n    for key, v := range m {\\n        if k<(26*(v-1)+key) {\\n            return false\\n        }\\n    }\\n    return true\\n}\\nfunc abs(n int) int {\\n    if n<0 {\\n        return -n\\n    }\\n    return n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1256317,
                "title": "c-100-100",
                "content": "```\\nbool canConvertString(char * s, char * t, int k){\\n    int seen[26]={-26, -26, -26, -26, -26, -26, -26, -26, -26,\\n                  -26, -26, -26, -26, -26, -26, -26, -26, -26,\\n                  -26, -26, -26, -26, -26, -26, -26, -26};\\n    while (*s != 0 && *t != 0) {\\n        int d;\\n        if ((d = *t++ - *s++)==0) {\\n            continue;\\n        } else if (d < 0) {\\n            d += 26;\\n        }\\n        if ((d += seen[d] += 26) > k) {\\n            return false;\\n        }\\n    }\\n    return (*t == 0 && *s == 0);\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(char * s, char * t, int k){\\n    int seen[26]={-26, -26, -26, -26, -26, -26, -26, -26, -26,\\n                  -26, -26, -26, -26, -26, -26, -26, -26, -26,\\n                  -26, -26, -26, -26, -26, -26, -26, -26};\\n    while (*s != 0 && *t != 0) {\\n        int d;\\n        if ((d = *t++ - *s++)==0) {\\n            continue;\\n        } else if (d < 0) {\\n            d += 26;\\n        }\\n        if ((d += seen[d] += 26) > k) {\\n            return false;\\n        }\\n    }\\n    return (*t == 0 && *s == 0);\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1256309,
                "title": "python-highly-optimized",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        seen = [-26] * 26\\n        for sc, tc in zip(s, t):\\n            d = ord(tc) - ord(sc)\\n            if d == 0:\\n                continue\\n            elif d < 0:\\n                d += 26\\n            seen[d] += 26\\n            d += seen[d]\\n            if d > k:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        seen = [-26] * 26\\n        for sc, tc in zip(s, t):\\n            d = ord(tc) - ord(sc)\\n            if d == 0:\\n                continue\\n            elif d < 0:\\n                d += 26\\n            seen[d] += 26\\n            d += seen[d]\\n            if d > k:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253830,
                "title": "easy-c-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s==t) return true;\\n        if(s.size()!=t.size()) return false;\\n        vector<int>diff(26,0);\\n        //cout<<(int)\\'z\\' - (int)\\'source\\' + (int)\\'tar\\' - (int)\\'a\\' + 1<<endl;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==t[i]){\\n                continue;\\n            }\\n            if(t[i] > s[i]){\\n                int id = t[i] - s[i];\\n                diff[id]++;\\n            }\\n            else{\\n                int d =( (int)\\'z\\' - (int)s[i] + (int)t[i] - (int)\\'a\\' + 1);\\n                diff[d]++;\\n            }\\n        }\\n        for(int i = 1;i<26;i++){\\n            int tar = i + (26 * (diff[i] - 1));\\n            if(tar > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s==t) return true;\\n        if(s.size()!=t.size()) return false;\\n        vector<int>diff(26,0);\\n        //cout<<(int)\\'z\\' - (int)\\'source\\' + (int)\\'tar\\' - (int)\\'a\\' + 1<<endl;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==t[i]){\\n                continue;\\n            }\\n            if(t[i] > s[i]){\\n                int id = t[i] - s[i];\\n                diff[id]++;\\n            }\\n            else{\\n                int d =( (int)\\'z\\' - (int)s[i] + (int)t[i] - (int)\\'a\\' + 1);\\n                diff[d]++;\\n            }\\n        }\\n        for(int i = 1;i<26;i++){\\n            int tar = i + (26 * (diff[i] - 1));\\n            if(tar > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1248115,
                "title": "js-easy-to-follow-time-o-n-space-o-1",
                "content": "```\\nvar canConvertString = function(s, t, k) {\\n    let numMoves = 0;\\n    let shiftCountMap = {};\\n    let leastNumMoves = 0;\\n    let getMoves = function(from, to) {\\n      let result = to.charCodeAt(0) - from.charCodeAt(0);\\n      return result < 0 ? 26 + result : result;\\n    }\\n\\n    if(s.length !== t.length) {\\n      return false;\\n    }\\n\\n    for(let i = 0; i < s.length; i++) {\\n      numMoves = getMoves(s.charAt(i), t.charAt(i));\\n      shiftCountMap[numMoves] = !!shiftCountMap[numMoves] ? shiftCountMap[numMoves] + 1 : 1;\\n      let temp = (26 * (shiftCountMap[numMoves] - 1)) + numMoves;\\n      if(leastNumMoves < temp && numMoves !== 0){\\n        leastNumMoves = temp;\\n      }\\n    }\\n    return k >= leastNumMoves;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConvertString = function(s, t, k) {\\n    let numMoves = 0;\\n    let shiftCountMap = {};\\n    let leastNumMoves = 0;\\n    let getMoves = function(from, to) {\\n      let result = to.charCodeAt(0) - from.charCodeAt(0);\\n      return result < 0 ? 26 + result : result;\\n    }\\n\\n    if(s.length !== t.length) {\\n      return false;\\n    }\\n\\n    for(let i = 0; i < s.length; i++) {\\n      numMoves = getMoves(s.charAt(i), t.charAt(i));\\n      shiftCountMap[numMoves] = !!shiftCountMap[numMoves] ? shiftCountMap[numMoves] + 1 : 1;\\n      let temp = (26 * (shiftCountMap[numMoves] - 1)) + numMoves;\\n      if(leastNumMoves < temp && numMoves !== 0){\\n        leastNumMoves = temp;\\n      }\\n    }\\n    return k >= leastNumMoves;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240148,
                "title": "c-count",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) \\n    {\\n        if(s.size()!=t.size())\\n            return false;\\n        vector<int>m(26,0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int diff=t[i]-s[i];\\n            if(diff==0)\\n                continue;\\n            if(diff<0)\\n                diff+=26;\\n            m[diff]++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(m[i]==0)\\n                continue;\\n            int req=(26*(m[i]-1))+i;\\n            if(req>k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) \\n    {\\n        if(s.size()!=t.size())\\n            return false;\\n        vector<int>m(26,0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int diff=t[i]-s[i];\\n            if(diff==0)\\n                continue;\\n            if(diff<0)\\n                diff+=26;\\n            m[diff]++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(m[i]==0)\\n                continue;\\n            int req=(26*(m[i]-1))+i;\\n            if(req>k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234636,
                "title": "swift-solution",
                "content": "Obviously if `s.count != t.count`, then the answer is `false`. Let\\'s add that check at the beginning.\\n\\nIt makes sense to perform shifts in the range from 1 to 25. We can perform each shift `k / 26 + (k % 26 >= shift ? 1 : 0)` times. Let\\'s fill the `shifts` array with the number of available shifts.\\n\\nConsider all indexes `i` in range `0 <= i < s.count` where `s[i] != t[i]` and calculate the `shift` to get `t[i]` from `s[i]`. If `shifts[shift] == 0` then the answer is `false`, else decrement `shifts[shift]` by 1.\\n```\\nclass Solution {\\n    func s2i(_ s: String) -> [Int] {\\n        return s.map({ Int($0.asciiValue ?? 97) - 97 })\\n    }\\n    func canConvertString(_ s: String, _ t: String, _ k: Int) -> Bool {\\n        guard s.count == t.count else { return false }\\n        let alphabet = 26, s = s2i(s), t = s2i(t), n = s.count\\n        var shifts = [Int](repeating: k / alphabet, count: alphabet)\\n        for i in stride(from: 1, through: k % alphabet, by: 1) {\\n            shifts[i] += 1\\n        }\\n        for i in 0..<n where s[i] != t[i] {\\n            let shift = t[i] - s[i] + (t[i] > s[i] ? 0 : alphabet)\\n            shifts[shift] -= 1\\n            if shifts[shift] < 0 {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func s2i(_ s: String) -> [Int] {\\n        return s.map({ Int($0.asciiValue ?? 97) - 97 })\\n    }\\n    func canConvertString(_ s: String, _ t: String, _ k: Int) -> Bool {\\n        guard s.count == t.count else { return false }\\n        let alphabet = 26, s = s2i(s), t = s2i(t), n = s.count\\n        var shifts = [Int](repeating: k / alphabet, count: alphabet)\\n        for i in stride(from: 1, through: k % alphabet, by: 1) {\\n            shifts[i] += 1\\n        }\\n        for i in 0..<n where s[i] != t[i] {\\n            let shift = t[i] - s[i] + (t[i] > s[i] ? 0 : alphabet)\\n            shifts[shift] -= 1\\n            if shifts[shift] < 0 {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226937,
                "title": "python-o-n-with-constant-memory-storage",
                "content": "```Python\\n\"Medium 1540. Can Convert String in K Moves\"\\n# https://leetcode.com/problems/can-convert-string-in-k-moves/\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \"Method 0 47.34%, self done, should be constant memory and time.\"\\n        # Posted to https://leetcode.com/problems/can-convert-string-in-k-moves/discuss/1226937/python-O(n)-with-constant-memory-storage.\\n        if len(s) != len(t): return False\\n        calDiff = lambda l, r: (ord(r) - ord(l)) % 26\\n        gaps = [calDiff(l, r) for l, r in zip(s, t)]\\n        base, remainder = k // 26, k%26\\n        choices = [base for _ in range(26)]\\n        for i in range(remainder + 1):\\n            choices[i] += 1\\n        for gap in gaps:\\n            if gap == 0: continue\\n            choices[gap] -= 1\\n            if choices[gap] == -1: return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```Python\\n\"Medium 1540. Can Convert String in K Moves\"\\n# https://leetcode.com/problems/can-convert-string-in-k-moves/\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \"Method 0 47.34%, self done, should be constant memory and time.\"\\n        # Posted to https://leetcode.com/problems/can-convert-string-in-k-moves/discuss/1226937/python-O(n)-with-constant-memory-storage.\\n        if len(s) != len(t): return False\\n        calDiff = lambda l, r: (ord(r) - ord(l)) % 26\\n        gaps = [calDiff(l, r) for l, r in zip(s, t)]\\n        base, remainder = k // 26, k%26\\n        choices = [base for _ in range(26)]\\n        for i in range(remainder + 1):\\n            choices[i] += 1\\n        for gap in gaps:\\n            if gap == 0: continue\\n            choices[gap] -= 1\\n            if choices[gap] == -1: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223574,
                "title": "map",
                "content": "bool canConvertString(string s, string t, int k) {\\n        \\n        \\n        int n=t.length();\\n        int count=0,i=0;\\n        unordered_map<int,int> m;\\n        \\n      while(i<n && count <=k){\\n            \\n          if(s[i]!=t[i]){\\n            \\n                count=t[i]-s[i];\\n                if(count<0)\\n                    count+=26;\\n        \\n                if(m.find(count)!=m.end()){ \\n                   m[count]++;\\n                   count+=(m[count]-1)*26;\\n                }\\n                m[count]++;\\n               if(count<=k)       \\n                 s[i]=t[i];\\n          }\\n            \\n            i++;\\n        }\\n      \\n    return s==t;       \\n     }\\n        };",
                "solutionTags": [],
                "code": "bool canConvertString(string s, string t, int k) {\\n        \\n        \\n        int n=t.length();\\n        int count=0,i=0;\\n        unordered_map<int,int> m;\\n        \\n      while(i<n && count <=k){\\n            \\n          if(s[i]!=t[i]){\\n            \\n                count=t[i]-s[i];\\n                if(count<0)\\n                    count+=26;\\n        \\n                if(m.find(count)!=m.end()){ \\n                   m[count]++;\\n                   count+=(m[count]-1)*26;\\n                }\\n                m[count]++;\\n               if(count<=k)       \\n                 s[i]=t[i];\\n          }\\n            \\n            i++;\\n        }\\n      \\n    return s==t;       \\n     }\\n        };",
                "codeTag": "Unknown"
            },
            {
                "id": 1214680,
                "title": "simple-to-understand-java-soln",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        int mp[] = new int[100001];\\n        if(s.length() != t.length())\\n            return false;\\n        \\n        int n = s.length();\\n        \\n        for(int i=0;i<n;i++) {\\n            \\n            int diff = t.charAt(i) - s.charAt(i);\\n            \\n            if(diff == 0)\\n                continue;\\n            if(diff > 0) {                      \\n                int z = mp[diff] * 26 + diff;\\n                if(z > k)\\n                    return false;                \\n                mp[diff]++;                \\n            }\\n            else {               \\n                int z =  mp[diff + 26] * 26 + diff + 26;\\n                if(z > k)\\n                    return false;                \\n                mp[diff + 26]++;               \\n            }           \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        int mp[] = new int[100001];\\n        if(s.length() != t.length())\\n            return false;\\n        \\n        int n = s.length();\\n        \\n        for(int i=0;i<n;i++) {\\n            \\n            int diff = t.charAt(i) - s.charAt(i);\\n            \\n            if(diff == 0)\\n                continue;\\n            if(diff > 0) {                      \\n                int z = mp[diff] * 26 + diff;\\n                if(z > k)\\n                    return false;                \\n                mp[diff]++;                \\n            }\\n            else {               \\n                int z =  mp[diff + 26] * 26 + diff + 26;\\n                if(z > k)\\n                    return false;                \\n                mp[diff + 26]++;               \\n            }           \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185999,
                "title": "c-histogram-beats-100-of-submissions",
                "content": "## The Problem\\n\\nWhen we have to shift a letter by i spaces, we want to record that shift in some container. At some point we want to check that this shift is less or equal to k.\\n\\nOur problem is in checking if there is an existing shift of the same distance. Each time there is a letter attempting the same distance of shift, we need one of those letters to be shifted by an additional 26 spaces. The second time we find this occurance we need to shift by 2x26, and so on.\\n\\nThe insight is that we can store a count of the number of letters that shift by the same amount, then we can calculate the number of additional shifts that the final letter needs to be shifted to abide by the unique i restriction in the question.\\n\\n## The Solution\\n\\nWe can create a histogram of distances by using an array of integers initialized at zero. We then iterate over both strings, find the character distance, and then increase the histogram value at that distance location as long as the distance is not zero. \\n\\n### Histogram Checks\\n\\nThe check against K can be performed either in-loop or on its own after the main while-loop. The code below shows the in-loop solution. \\n\\nThe in-loop method allows us to quit early if we find that a histogram value is violating our K requirement. However, the in-loop solutions adds a constant-time overhead for every operation. \\n\\nChecking the histogram values after the main while-loop requires far fewer (25) checks, but we have to compare entire strings and cannot exit early.\\n\\nI have found similar performance (24ms and 28ms) submitting both solutions. This seems to be similar within the variance that leetcode has for submissions.\\n\\n### Perform fewer K checks\\n\\nWe do not need to check against K for every single item we place into the histogram. We can keep track of the max number of duplicate distances in the histogram (largest value in the histogram), and only check against K if we just increased a histogram value to an equal or greater value.\\n\\nThe reason we can avoid these checks is that if the histogram value we just placed is smaller than the max previously seen histogram value, then we cannot have just placed a value greater than K, otherwise we would have exited when we had seen that max previously seen histogram value.\\n\\n### io tricks\\n\\nLeetcode appears to include the io time in the submission benchmarking time. In C++ we can reduce that overhead by including the two lines at the top of the code. The first line removes the synchronization between C and C++ standard streams, and the second line unties cin from cout. \\n\\nThese lines reduce the runtime by about half. I\\'m not sure I like that io tricks can decrease runtime more than my other optimizations, but this is the world that we live in.\\n\\n\\n\\n```\\n    bool canConvertString(string s, string t, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        if (s.size() != t.size())\\n        {\\n            return false;\\n        }\\n        auto it_s = s.begin();\\n        auto it_t = t.begin();\\n        int histogram[25] = {};\\n        int current_max_steps = 0;\\n        int ch_diff, max_steps;\\n        while(it_s != s.end()){\\n             ch_diff = (*it_t - *it_s + 26) % 26;\\n            if(ch_diff != 0){\\n                histogram[ch_diff-1] ++;\\n                if (current_max_steps <= histogram[ch_diff-1])\\n                {\\n                    current_max_steps = histogram[ch_diff-1];\\n                    max_steps = ch_diff + 26 * (histogram[ch_diff-1] - 1);\\n                    if (max_steps > k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n            it_s++; it_t++;\\n        }\\n        return true;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    bool canConvertString(string s, string t, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        if (s.size() != t.size())\\n        {\\n            return false;\\n        }\\n        auto it_s = s.begin();\\n        auto it_t = t.begin();\\n        int histogram[25] = {};\\n        int current_max_steps = 0;\\n        int ch_diff, max_steps;\\n        while(it_s != s.end()){\\n             ch_diff = (*it_t - *it_s + 26) % 26;\\n            if(ch_diff != 0){\\n                histogram[ch_diff-1] ++;\\n                if (current_max_steps <= histogram[ch_diff-1])\\n                {\\n                    current_max_steps = histogram[ch_diff-1];\\n                    max_steps = ch_diff + 26 * (histogram[ch_diff-1] - 1);\\n                    if (max_steps > k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n            it_s++; it_t++;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1171843,
                "title": "easy-c-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())return false;\\n        unordered_map<int,int> vis;\\n        priority_queue<long long> que;\\n        for(int i=0;i<s.length();i++){\\n            int shft=t[i]-s[i];\\n            if(shft==0)continue;\\n            shft=shft<0?shft+26:shft;\\n            long long x=shft+26*vis[shft]; //is same rotn is there we have to move it to next cycle\\n            vis[shft]++;\\n            que.push(x);\\n        }\\n        if(!que.empty()&&que.top()>k)return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())return false;\\n        unordered_map<int,int> vis;\\n        priority_queue<long long> que;\\n        for(int i=0;i<s.length();i++){\\n            int shft=t[i]-s[i];\\n            if(shft==0)continue;\\n            shft=shft<0?shft+26:shft;\\n            long long x=shft+26*vis[shft]; //is same rotn is there we have to move it to next cycle\\n            vis[shft]++;\\n            que.push(x);\\n        }\\n        if(!que.empty()&&que.top()>k)return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169219,
                "title": "detailed-o-n-time-o-1-space-solution",
                "content": "\\t// time complexity : O(n), space complexity : O(1)\\n\\t/*\\n\\t\\tapproach :\\n\\t\\t--> find the least amount of shift we need to do, to convert s[i] to t[i].\\n\\t\\t--> if that was done, then add 26 to it(As a shift amount can not be done more than once).\\n\\t\\t--> If that was also done add 26*2 to the least shift amount and so on.\\n\\t\\t--> Well the question is how to know the # of time we need to add 26.\\n\\t\\t--> For this we create a map of size 26. Cuz least shift can be upto 25, when \\'a\\' -> \\'z\\'.\\n\\t\\t--> map[i] = j means we added 26 upto j times for a shift by i.\\n\\t\\t--> But how to ensure that a particular value of shifting is not used more than once.\\n\\t\\t--> This is beacuse a * 26 + i != b * 26 + j for any value of a and b and i!=j and 1<=i,j<=25.\\n\\t*/\\n\\tclass Solution {\\n\\t\\tpublic boolean canConvertString(String s, String t, int k) {\\n\\t\\t\\tif(s.length()!=t.length())return false;\\n\\t\\t\\tint[] map = new int[26];\\n\\t\\t\\tfor(var i=0;i<s.length();i++){\\n\\t\\t\\t\\tchar c1 = s.charAt(i);\\n\\t\\t\\t\\tchar c2 = t.charAt(i);\\n\\t\\t\\t\\tif(c1==c2)continue;\\n\\t\\t\\t\\tint shifts  = 0;\\n\\t\\t\\t\\tif(c2>c1) shifts = c2-c1;\\n\\t\\t\\t\\telse shifts = \\'z\\'- c1 + 1 + c2-\\'a\\';\\n\\t\\t\\t\\tint totalShifts = 26*map[shifts] + shifts;\\n\\t\\t\\t\\tmap[shifts]++;\\n\\t\\t\\t\\tif(totalShifts>k)return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean canConvertString(String s, String t, int k) {\\n\\t\\t\\tif(s.length()!=t.length())return false;\\n\\t\\t\\tint[] map = new int[26];\\n\\t\\t\\tfor(var i=0;i<s.length();i++){\\n\\t\\t\\t\\tchar c1 = s.charAt(i);\\n\\t\\t\\t\\tchar c2 = t.charAt(i);\\n\\t\\t\\t\\tif(c1==c2)continue;\\n\\t\\t\\t\\tint shifts  = 0;\\n\\t\\t\\t\\tif(c2>c1) shifts = c2-c1;\\n\\t\\t\\t\\telse shifts = \\'z\\'- c1 + 1 + c2-\\'a\\';\\n\\t\\t\\t\\tint totalShifts = 26*map[shifts] + shifts;\\n\\t\\t\\t\\tmap[shifts]++;\\n\\t\\t\\t\\tif(totalShifts>k)return false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1167215,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) \\n    {\\n        if (s.length() != t.length()) return false;\\n        \\n        int diff[26];\\n        for (int i = 0; i<26; i++) diff[i] = i;\\n        for (int i = 0; i<s.length(); i++)\\n        {\\n            if (s[i] == t[i]) continue;\\n            int j = t[i]-s[i];\\n            if (j<0) j+= 26;\\n            if (diff[j] > k)\\n                return false;\\n            \\n            diff[j] += 26;\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) \\n    {\\n        if (s.length() != t.length()) return false;\\n        \\n        int diff[26];\\n        for (int i = 0; i<26; i++) diff[i] = i;\\n        for (int i = 0; i<s.length(); i++)\\n        {\\n            if (s[i] == t[i]) continue;\\n            int j = t[i]-s[i];\\n            if (j<0) j+= 26;\\n            if (diff[j] > k)\\n                return false;\\n            \\n            diff[j] += 26;\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159917,
                "title": "java-hashmap-o-n",
                "content": "```\\n\\tpublic boolean canConvertString(String s, String t, int k){\\n        if(s.length()!=t.length()) return false;\\n        Map<Integer,Integer> map= new HashMap<>();\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==t.charAt(i)) continue;\\n            int moves= 0;\\n            if(t.charAt(i)>s.charAt(i)) moves= t.charAt(i)-s.charAt(i);\\n            else{\\n                moves= \\'z\\'-s.charAt(i)+t.charAt(i)-\\'a\\'+1;\\n            }\\n            if(map.containsKey(moves)){\\n                int less26= moves;\\n                moves= map.get(moves)+26;\\n                map.replace(less26,moves);\\n            }else{\\n                map.put(moves,moves);\\n            } \\n            if(moves>k) return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic boolean canConvertString(String s, String t, int k){\\n        if(s.length()!=t.length()) return false;\\n        Map<Integer,Integer> map= new HashMap<>();\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==t.charAt(i)) continue;\\n            int moves= 0;\\n            if(t.charAt(i)>s.charAt(i)) moves= t.charAt(i)-s.charAt(i);\\n            else{\\n                moves= \\'z\\'-s.charAt(i)+t.charAt(i)-\\'a\\'+1;\\n            }\\n            if(map.containsKey(moves)){\\n                int less26= moves;\\n                moves= map.get(moves)+26;\\n                map.replace(less26,moves);\\n            }else{\\n                map.put(moves,moves);\\n            } \\n            if(moves>k) return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1145426,
                "title": "python3-explanation-runtime-and-space-analysis-o-n-time-o-1-space",
                "content": "**Explanation**\\nThe idea is to use a hashtable for the required shifts to transform one letter into another. It provides the next free number of shifts which is the initial number of shifts plus a multiple of `26`. Every time we access such a free number of shifts, we check if it is greater than `k`. If it is, `false` will be returned. In any other case, the next free number of shifts will be the current one plus `26`.\\n\\nExample: To transform `a` into `b` we need `1` shift. The next free number of shifts for this initial number of shifts will be `27`. If we now are asked to transform `b` into `c`, for instance, the required shifts will be `27` and the next free number of shifts `27 + 26 = 53` and so on.\\n________________________\\n**Definitions**\\n`n`: Size of `s` and `t` if `s = t`.\\n________________________\\n**Runtime Complexity**\\n`O(n)`\\n_______________________\\n**Space Complexity**\\n`O(1)`\\n_______________________\\n**Python Implementation**\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        shifts_to_next_shift = list(range(26))\\n        \\n        for i in range(len(s)):\\n            if s[i] != t[i]:\\n                shifts = ord(t[i]) - ord(s[i]) if s[i] < t[i] else ord(\"z\") - ord(s[i]) + 1 + ord(t[i]) - ord(\"a\")\\n                \\n                if shifts_to_next_shift[shifts] > k:\\n                    return False\\n                \\n                shifts_to_next_shift[shifts] += 26\\n                \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        shifts_to_next_shift = list(range(26))\\n        \\n        for i in range(len(s)):\\n            if s[i] != t[i]:\\n                shifts = ord(t[i]) - ord(s[i]) if s[i] < t[i] else ord(\"z\") - ord(s[i]) + 1 + ord(t[i]) - ord(\"a\")\\n                \\n                if shifts_to_next_shift[shifts] > k:\\n                    return False\\n                \\n                shifts_to_next_shift[shifts] += 26\\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143035,
                "title": "c-solution-beats-80-o-n-time-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())\\n        {\\n            return false;\\n        }\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==t[i])\\n            {\\n                continue;\\n            }\\n            int diff=t[i]-s[i];\\n            if(t[i]<s[i])\\n            {\\n                diff+=26;\\n            }\\n            mp[diff]++;\\n        }\\n        unordered_map<int,int>::iterator itr;\\n        for(itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            int vg=itr->first;\\n            int yu=itr->second;\\n            int ans= vg + (26*(yu-1));\\n            if(ans>k)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())\\n        {\\n            return false;\\n        }\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==t[i])\\n            {\\n                continue;\\n            }\\n            int diff=t[i]-s[i];\\n            if(t[i]<s[i])\\n            {\\n                diff+=26;\\n            }\\n            mp[diff]++;\\n        }\\n        unordered_map<int,int>::iterator itr;\\n        for(itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            int vg=itr->first;\\n            int yu=itr->second;\\n            int ans= vg + (26*(yu-1));\\n            if(ans>k)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107285,
                "title": "c-solution-using-dictionary",
                "content": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        if(s.Length != t.Length) return false;\\n        int times = k/26;\\n        k %= 26;\\n        Dictionary<int, int> dict = new Dictionary<int, int>();\\n        for(int i=0; i<s.Length; i++)\\n        {\\n            if(s[i] == t[i]) continue;\\n            int shift = s[i]-t[i]>0? 26-s[i]+t[i] : t[i]-s[i];\\n            if(dict.ContainsKey(shift))\\n            {\\n                dict[shift]++;\\n            }\\n            else\\n            {\\n                dict.Add(shift, 1);\\n            }\\n            \\n            if(dict[shift] > times)\\n            {\\n                if(shift > k || dict[shift] - times > 1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        if(s.Length != t.Length) return false;\\n        int times = k/26;\\n        k %= 26;\\n        Dictionary<int, int> dict = new Dictionary<int, int>();\\n        for(int i=0; i<s.Length; i++)\\n        {\\n            if(s[i] == t[i]) continue;\\n            int shift = s[i]-t[i]>0? 26-s[i]+t[i] : t[i]-s[i];\\n            if(dict.ContainsKey(shift))\\n            {\\n                dict[shift]++;\\n            }\\n            else\\n            {\\n                dict.Add(shift, 1);\\n            }\\n            \\n            if(dict[shift] > times)\\n            {\\n                if(shift > k || dict[shift] - times > 1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102036,
                "title": "c-o-n-solution-maintain-counts-of-number-of-ways-to-make-1-25-steps",
                "content": "```\\nbool canConvertString(string s, string t, int k) {\\n\\tif (s.size() != t.size()) return false;\\n\\n\\t// Maintain a count of the number of times we can make\\n\\t// X number of shifts. X ranges from 1-25.\\n\\tint count[26] = {};\\n\\tfor (int i = 1; i < 26; i++) {\\n\\t\\tcount[i] = (k+26-i)/26;\\n\\t}\\n\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tif (s[i] == t[i]) continue;\\n\\n\\t\\tint shift = (t[i] + 26 - s[i]) % 26;\\n\\t\\t// If we have already used up all possible ways to\\n\\t\\t// make \\'shift\\' number of steps, string can\\'t be\\n\\t\\t// converted.\\n\\t\\tif (count[shift]-- == 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(string s, string t, int k) {\\n\\tif (s.size() != t.size()) return false;\\n\\n\\t// Maintain a count of the number of times we can make\\n\\t// X number of shifts. X ranges from 1-25.\\n\\tint count[26] = {};\\n\\tfor (int i = 1; i < 26; i++) {\\n\\t\\tcount[i] = (k+26-i)/26;\\n\\t}\\n\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tif (s[i] == t[i]) continue;\\n\\n\\t\\tint shift = (t[i] + 26 - s[i]) % 26;\\n\\t\\t// If we have already used up all possible ways to\\n\\t\\t// make \\'shift\\' number of steps, string can\\'t be\\n\\t\\t// converted.\\n\\t\\tif (count[shift]-- == 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570107,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 1824479,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 1570421,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 1574182,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 2044343,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 2007883,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Insertions to Balance a Parentheses String",
        "question_content": "<p>Given a parentheses string <code>s</code> containing only the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>. A parentheses string is <strong>balanced</strong> if:</p>\n\n<ul>\n\t<li>Any left parenthesis <code>&#39;(&#39;</code> must have a corresponding two consecutive right parenthesis <code>&#39;))&#39;</code>.</li>\n\t<li>Left parenthesis <code>&#39;(&#39;</code> must go before the corresponding two consecutive right parenthesis <code>&#39;))&#39;</code>.</li>\n</ul>\n\n<p>In other words, we treat <code>&#39;(&#39;</code> as an opening parenthesis and <code>&#39;))&#39;</code> as a closing parenthesis.</p>\n\n<ul>\n\t<li>For example, <code>&quot;())&quot;</code>, <code>&quot;())(())))&quot;</code> and <code>&quot;(())())))&quot;</code> are balanced, <code>&quot;)()&quot;</code>, <code>&quot;()))&quot;</code> and <code>&quot;(()))&quot;</code> are not balanced.</li>\n</ul>\n\n<p>You can insert the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code> at any position of the string to balance it if needed.</p>\n\n<p>Return <em>the minimum number of insertions</em> needed to make <code>s</code> balanced.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(()))&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The second &#39;(&#39; has two matching &#39;))&#39;, but the first &#39;(&#39; has only &#39;)&#39; matching. We need to add one more &#39;)&#39; at the end of the string to be &quot;(())))&quot; which is balanced.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;())&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The string is already balanced.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;))())(&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Add &#39;(&#39; to match the first &#39;))&#39;, Add &#39;))&#39; to match the last &#39;(&#39;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code> only.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 780199,
                "title": "java-c-python-straight-forward-one-pass",
                "content": "# **Intuition**\\nSimilar to [921. Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/discuss/181132/C++JavaPython-Straight-Forward-One-Pass).\\nJust need to pay attention:\\nleft parenthesis \\'(\\' must have a corresponding two **consecutive** right parenthesis \\'))\\'.\\n<br>\\n\\n# **Explanation**\\n`res` represents the number of left/right parentheses already added.\\n`right` represents the number of right parentheses needed.\\n\\n**1) case `)`**\\nIf we meet a right parentheses , `right--`.\\nIf `right < 0`, we need to add a left parentheses before it.\\nThen we update `right += 2` and `res++`\\nThis part is easy and normal.\\n\\n**2) case `(`**\\nIf we meet a left parentheses,\\nwe check if we have odd number `\\')\\'` before.\\nIf we `right`, we have odd `\\')\\'` before,\\nbut we want right parentheses in paires.\\nSo add one `\\')\\'` here, then update `right--; res++;`.\\nNote that this part is not necessary if two **consecutive** right parenthesis not required.\\n\\nBecause we have `)`, we update `right += 2`.\\n<br>\\n\\n# **Dry run**\\nAll by @himanshusingh11:\\n\\n**Example 1: Consider ((()(,n= 5 ,i=0,1...4**\\ni=0, we have ( it means we need two right parenthesis (they are in pair) so.. right+=2 => res =0, right =2\\ni=1, again we have ( it means we need two right parenthesis (they are in pair) so.. right+=2 => res =0, right =4\\ni=2, again we have ( it means we need two right parenthesis (they are in pair) so.. right+=2 => res =0, right =6\\ni=3, we have ) we subtract one from right. so.. right-- => res =0, right =5\\ni=4, we have ( but here right is odd so we need to make it even with right-- and increment res++ => res =1, right =4. Also, as we have got a left parenthesis then we need two right parenthesis (they are in pair) so.. right+=2 => res =1, right =6\\n\\nfinally ans is res + right => 1 +6 == 7\\n\\n**Example 2: ((()**\\nSimilarly, we can see when we have right<0 then we increment res by one & add 2 to right as they should be in pairs..\\n<br>\\n\\n# **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int minInsertions(String s) {\\n        int res = 0, right = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'(\\') {\\n                if (right % 2 > 0) {\\n                    right--;\\n                    res++;\\n                }\\n                right += 2;\\n            } else {\\n                right--;\\n                if (right < 0) {\\n                    right += 2;\\n                    res++;\\n                }\\n            }\\n        }\\n        return right + res;\\n    }\\n```\\n**C++:**\\n```cpp\\n    int minInsertions(string s) {\\n        int res = 0, right = 0;\\n        for (char &c: s) {\\n            if (c == \\'(\\') {\\n                if (right % 2 > 0) {\\n                    right--;\\n                    res++;\\n                }\\n                right += 2;\\n            } else {\\n                right--;\\n                if (right < 0) {\\n                    right += 2;\\n                    res++;\\n                }\\n            }\\n        }\\n        return right + res;\\n    }\\n```\\n**Python:**\\n```py\\n    def minInsertions(self, s):\\n        res = right = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                if right % 2:\\n                    right -= 1\\n                    res += 1\\n                right += 2\\n            if c == \\')\\':\\n                right -= 1\\n                if right < 0:\\n                    right += 2\\n                    res += 1\\n        return right + res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minInsertions(String s) {\\n        int res = 0, right = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'(\\') {\\n                if (right % 2 > 0) {\\n                    right--;\\n                    res++;\\n                }\\n                right += 2;\\n            } else {\\n                right--;\\n                if (right < 0) {\\n                    right += 2;\\n                    res++;\\n                }\\n            }\\n        }\\n        return right + res;\\n    }\\n```\n```cpp\\n    int minInsertions(string s) {\\n        int res = 0, right = 0;\\n        for (char &c: s) {\\n            if (c == \\'(\\') {\\n                if (right % 2 > 0) {\\n                    right--;\\n                    res++;\\n                }\\n                right += 2;\\n            } else {\\n                right--;\\n                if (right < 0) {\\n                    right += 2;\\n                    res++;\\n                }\\n            }\\n        }\\n        return right + res;\\n    }\\n```\n```py\\n    def minInsertions(self, s):\\n        res = right = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                if right % 2:\\n                    right -= 1\\n                    res += 1\\n                right += 2\\n            if c == \\')\\':\\n                right -= 1\\n                if right < 0:\\n                    right += 2\\n                    res += 1\\n        return right + res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 779928,
                "title": "simple-o-n-stack-solution-with-detailed-explanation",
                "content": "**Brief Idea**: Maintain a stack. Every time we see a ```(``` we need to have 2 ```)``` to balance. So we would push 2 to the stack. Then when we see ```)``` we would check the top of the stack. If the top is 2, that means this is the first ```)``` that will match the previous ```(```. So we would change the top to 1. In case the top of stack had 1 it means we are seeing the second ```)``` for some ```(``` and so we just pop this 1 from the stack. \\n\\n**Details of transition**:\\n1. When we see ```(```:\\n* And the stack is empty or has a 2 at the top: we just push another 2.\\n * And the stack had 1 at the top: This means we have just seen ```()``` and now we are seeing ```(```. In this case, we need to first provide a ```)``` to the previous ```(``` and then we can process the current ```(```. So increment the answer, pop the 1 (which was for last ```(```) and push a 2 (for current ```(```).\\n2. When we see ```)```:\\n * And the stack is empty: We have encountered a lone ```)```. We would need to add ```(``` to the sequence to balance, which would match one of its ```)``` with the current ```)```. So we increment the answer.  Moreover, it would also need another ```)``` to match. So we push 1 to the top. This is like saying we have seen ```()``` (of which ```(``` was inserted by us).\\n* And the stack had 1 at the top: This the second ```)``` for some ```(```. We just pop from the stack.\\n* And the stack had 2 at the top: This the first ```)``` for some ```(```. We just pop 2 from the stack and push 1.\\nAt the end of going through the string we just add up all the numbers in stack, which represents the number of ```)``` we need to balance.\\n\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int ans = 0;\\n        stack<int> t;\\n        for (char c : s) {\\n            if (c == \\'(\\') {\\n                if (t.empty() || t.top() == 2) t.push(2);\\n                else {\\n                    t.pop();\\n                    t.push(2);\\n                    ans++;\\n                }\\n            }\\n            else {\\n                if (t.empty()) {\\n                    t.push(1); ans++;\\n                } else if (t.top() == 1) {\\n                    t.pop();\\n                } else if (t.top() == 2) {\\n                    t.pop(); t.push(1);\\n                }\\n            }\\n        }\\n        while (!t.empty()) {\\n            ans += t.top();\\n            t.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```(```\n```)```\n```)```\n```)```\n```(```\n```)```\n```(```\n```(```\n```()```\n```(```\n```)```\n```(```\n```(```\n```(```\n```(```\n```)```\n```)```\n```(```\n```)```\n```)```\n```)```\n```()```\n```(```\n```)```\n```(```\n```)```\n```(```\n```)```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int ans = 0;\\n        stack<int> t;\\n        for (char c : s) {\\n            if (c == \\'(\\') {\\n                if (t.empty() || t.top() == 2) t.push(2);\\n                else {\\n                    t.pop();\\n                    t.push(2);\\n                    ans++;\\n                }\\n            }\\n            else {\\n                if (t.empty()) {\\n                    t.push(1); ans++;\\n                } else if (t.top() == 1) {\\n                    t.pop();\\n                } else if (t.top() == 2) {\\n                    t.pop(); t.push(1);\\n                }\\n            }\\n        }\\n        while (!t.empty()) {\\n            ans += t.top();\\n            t.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780221,
                "title": "python-simple-and-fast-time-o-n-space-o-1",
                "content": "# \\uD83D\\uDCA1 Idea\\n\\n* Record the number of \\'(\\' in an open bracket count int. \\n* If there is a \\'))\\' or a \\') \\'then open bracket count -= 1\\n* If there is a \\'))\\' or a \\') and open bracket count = 0 an \\'(\\' must be inserted\\n* If there is a single \\')\\' another \\')\\' must be inserted\\n* At the end of the program and if open bracket count >0 then an \\'))\\' must be added for each unmatched \\'(\\'\\n\\n---\\n\\n# \\uD83D\\uDCD1Overview\\n* Solution 1: Time O(n), Space O(n) - String Replace <code style=\"background-color: Green; color: white;\">Easy</code>\\n* Solution 2: Time O(n), Space O(1) - Case by Case <code style=\"background-color: OrangeRed; color: white;\">Medium</code>\\n\\n\\n---\\n\\n\\n# \\uD83C\\uDFAFSolution 1: Simple String Replace <code style=\"background-color: Green; color: white;\">Easy</code>\\n\\n\\n## Tricks\\n\\n* Go through string replacing \\'))\\' with \\'}\\'\\n* This allows for easy differentiation between \\')\\'  \\'))\\' when iterating through the input string\\n* This makes checking the above conditions a breeze \\n\\n## Examples\\n**Example 1:**\\n```\\nInput: s = \"(()))\"\\nUsing \\'{\\' trick\\nInput: s = \"((})\"\\n\\nVery easy to see the problem running through the string one character at a time\\nCase 1: Starting \\'(\\' has only one \\')\\'       --> add 1\\nOutput:                                             1\\n```\\n\\n**Example 2:**\\n```\\nInput: s = \"))())(\"\\nUsing \\'{\\' trick\\nInput: s = \"}(}(\"\\n\\nCase 2: Starting \\'}\\' with no matching \\'(\\'  --> add 1\\nCase 3: Ending \\'(\\' with no maching \\'}\\'     --> add 2\\nOutput:                                            3\\n```\\n\\n**Example 3:**\\n```\\nInput: s = \")))))))\"\\nUsing \\'{\\' trick\\nInput: s= \"}}} )\"\\n\\nCase 2:  \\'}\\' with no matching \\'(\\'                             --> add 1 x (3 times) \\nCase 3:  \\')\\' with no matching \\'(\\' or trailing \\')\\'             --> add 2\\n\\nOutput:                                                               5\\n\\n* Case 2 happens 3 times since there are three \"}}}\"\\n* Case 3: we automatically know there is not trailing a \\')\\' becuase if there were the character would be a \\'}\\' instead\\n```\\n\\nExamples 1-3 cover all the cases of mismatching brackets there are! You should be ready to try coding a solution :) \\n\\n## Code\\n\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        s = s.replace(\\'))\\', \\'}\\')\\n        missing_brackets = 0\\n        required_closed = 0\\n\\n        for c in s:\\n\\n            # Open Bracket Condition\\n            if c == \\'(\\':\\n                required_closed += 2\\n              \\n            # Closed Bracket Condition  \\n            else:\\n\\t\\t\\t\\n                # Case: \\')\\' \\n                # Requires additional \\')\\' \\n                if c == \\')\\': \\n                    missing_brackets += 1\\n\\n                # Case: Matching ( for ) or ))\\n                if required_closed:\\n                    required_closed -= 2\\n\\n\\n                # Case: Unmatched ) or ))\\n                # Need to insert ( to balance string\\n                else:\\n                    missing_brackets += 1\\n\\n        return missing_brackets + required_closed\\n```\\n\\n---\\n\\n# \\uD83C\\uDFAF Solution 2: Case by Case <code style=\"background-color: OrangeRed; color: white;\">Medium</code>\\n\\n## Implementation\\n\\n* Implement a boolean that can track \\'))\\' in O(1) space\\n* Update logic from Solution 1 \\n\\n## Code \\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        # Missing \\')\\' to make valid pair\\n        missing_closed = 0 \\n\\n        # Required \\'(\\' to make valid pair\\n        required_open = 0\\n\\n        # Required \\')\\' to make valid pair\\n        required_closed = 0\\n\\n        # Track \\'))\\' cases \\n        prev_closed = 0\\n\\n\\n        for c in s:\\n\\n            # Open Bracket Condition\\n            if c == \\'(\\':\\n\\n                # Failed to make valid pair \\n                #\\')\\' Brackets are considered missing and cannot be made valid by subsequent brackets\\n                # Case: () (\\n                if required_closed % 2 == 1: \\n                    missing_closed += 1  \\n                    required_closed -= 1\\n\\n                required_closed += 2\\n                prev_closed = False\\n                \\n            # Closed Bracket Condition \\n            else:\\n\\n                # Match ( with )\\n                if required_closed:\\n                    required_closed -= 1\\n\\n                # Unmatched ))\\n                elif prev_closed:\\n                    required_closed -= 1\\n\\n                # Unmatched )\\n                else:\\n                    required_open += 1\\n                    required_closed += 1\\n\\n                # Bool to track \\'))\\' \\n                prev_closed = not prev_closed\\n\\n        return required_open + required_closed + missing_closed\\n```\\n\\nLike if this helped!\\nCheers,\\nArgent \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nInput: s = \"(()))\"\\nUsing \\'{\\' trick\\nInput: s = \"((})\"\\n\\nVery easy to see the problem running through the string one character at a time\\nCase 1: Starting \\'(\\' has only one \\')\\'       --> add 1\\nOutput:                                             1\\n```\n```\\nInput: s = \"))())(\"\\nUsing \\'{\\' trick\\nInput: s = \"}(}(\"\\n\\nCase 2: Starting \\'}\\' with no matching \\'(\\'  --> add 1\\nCase 3: Ending \\'(\\' with no maching \\'}\\'     --> add 2\\nOutput:                                            3\\n```\n```\\nInput: s = \")))))))\"\\nUsing \\'{\\' trick\\nInput: s= \"}}} )\"\\n\\nCase 2:  \\'}\\' with no matching \\'(\\'                             --> add 1 x (3 times) \\nCase 3:  \\')\\' with no matching \\'(\\' or trailing \\')\\'             --> add 2\\n\\nOutput:                                                               5\\n\\n* Case 2 happens 3 times since there are three \"}}}\"\\n* Case 3: we automatically know there is not trailing a \\')\\' becuase if there were the character would be a \\'}\\' instead\\n```\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        s = s.replace(\\'))\\', \\'}\\')\\n        missing_brackets = 0\\n        required_closed = 0\\n\\n        for c in s:\\n\\n            # Open Bracket Condition\\n            if c == \\'(\\':\\n                required_closed += 2\\n              \\n            # Closed Bracket Condition  \\n            else:\\n\\t\\t\\t\\n                # Case: \\')\\' \\n                # Requires additional \\')\\' \\n                if c == \\')\\': \\n                    missing_brackets += 1\\n\\n                # Case: Matching ( for ) or ))\\n                if required_closed:\\n                    required_closed -= 2\\n\\n\\n                # Case: Unmatched ) or ))\\n                # Need to insert ( to balance string\\n                else:\\n                    missing_brackets += 1\\n\\n        return missing_brackets + required_closed\\n```\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        # Missing \\')\\' to make valid pair\\n        missing_closed = 0 \\n\\n        # Required \\'(\\' to make valid pair\\n        required_open = 0\\n\\n        # Required \\')\\' to make valid pair\\n        required_closed = 0\\n\\n        # Track \\'))\\' cases \\n        prev_closed = 0\\n\\n\\n        for c in s:\\n\\n            # Open Bracket Condition\\n            if c == \\'(\\':\\n\\n                # Failed to make valid pair \\n                #\\')\\' Brackets are considered missing and cannot be made valid by subsequent brackets\\n                # Case: () (\\n                if required_closed % 2 == 1: \\n                    missing_closed += 1  \\n                    required_closed -= 1\\n\\n                required_closed += 2\\n                prev_closed = False\\n                \\n            # Closed Bracket Condition \\n            else:\\n\\n                # Match ( with )\\n                if required_closed:\\n                    required_closed -= 1\\n\\n                # Unmatched ))\\n                elif prev_closed:\\n                    required_closed -= 1\\n\\n                # Unmatched )\\n                else:\\n                    required_open += 1\\n                    required_closed += 1\\n\\n                # Bool to track \\'))\\' \\n                prev_closed = not prev_closed\\n\\n        return required_open + required_closed + missing_closed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394902,
                "title": "c-with-without-stack-clear-detailed-step-by-step-explanation",
                "content": "\\n#### **Intution:**\\nThis problem is similar to [921. Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/).  Note that here, for every open parantheses, there must be 2 consecutive close parantheses. \\n\\nSeeing any question involving parenthesis balancing, it becomes quite intutive to use stacks. \\nHowever, for problems involving only a single type of parenthesis (open, curly or square), we can generally (but not always) solve them without stack in the same time complexity.But as an advantage, this could solve the problem in constant space.\\n\\nIn this post, I am adding two approaches - one using stack and another without stack.\\nThe codes are well commented for your better understanding.\\n\\n##### 1. Using stack:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack <char> st;\\n        \\n        // open & close denote number of open and close brackets needed respectively\\n        int open = 0, close = 0;\\n        \\n        for(int i = 0; i<s.length(); i++){\\n            // Push all open brackets\\n            if(s[i]==\\'(\\') st.push(s[i]);\\n            \\n            // For close brackets\\n            else if(s[i]==\\')\\') {\\n                // if consecutive close brackets appear, remove one open bracket from stack which would balance the two close brackets.  \\n\\t\\t\\t\\t// If however stack is empty, an open bracket is needed. \\n                if(  i<s.length()-1 && s[i+1]==\\')\\'){\\n                    if(!st.empty()) st.pop();\\n                    else open++;\\n                    i++; //Remember to increment the ith pointer!!\\n                }\\n                \\n                // if the next element is not a closing bracket- 2 cases: stack is empty or not\\n                else{\\n                    // for an empty stack ->    \\')\\' bracket needs an \\'(\\' and a \\')\\' to make \\'( ) )\\' \\n                    if(st.empty()){\\n                        open++;\\n                        close++; \\n                    }\\n                    \\n                    //for a filled stack ->     \\')\\' bracket and atleast 1 \\'(\\' in stack would need 1 \\')\\' to make \\'( )) \\' \\n                    else{\\n                        close++;\\n                        st.pop();\\n                    }\\n                }\\n            }\\n        }\\n        \\n        /* After traversing the complete string, the minimum brackets needed include:\\n        1. st.size() indicates the \\'(\\' which never had the required number of \\')\\' found in the string.\\n        2. close indicates number of close bracketes needed\\n        3. open indicates number of open brackets needed. Note that these are the need of \\'(\\' brackets encountered when stack was empty. \\n        */\\n        int total = st.size() * 2 + close + open;\\n        return total; \\n\\t\\t}\\n};\\n```\\n\\n**Complexity Analysis:** Time Complexity - O(n) , since the entire string of length n is traversed once, and for each character we perform the operations in constant time. \\nSpace Complexity - O(n) becuase of stack\\n\\n\\n##### 2. Without  using stack : \\n\\n```\\nclass Solution {\\npublic:\\n\\n    int minInsertions(string s) {\\n        //Let open be the number of open brackets in the stack which did not get equivalent close brackets to balance.\\n        // openneeded be the number of ( needed (Found when stack was empty)\\n        // closeneeded be the number of ) needed \\n        int open = 0; \\n        int openneeded = 0;\\n        int closeneeded = 0;\\n        \\n        for(int i = 0; i<s.size(); i++){\\n            \\n            //For open brackets\\n            if(s[i]==\\'(\\')\\n                open++;\\n            \\n            //For close brackets\\n            else if(s[i]==\\')\\') {\\n                \\n                //If next char is also a \\')\\' , check if an open bracket was encountered before and has not yet been balanced or not. If yes, decrement the number of open brackets. \\n                if(  i<s.length()-1 && s[i+1]==\\')\\'){\\n                    if(open==0) openneeded++;\\n                    else open--;\\n                    i++;\\n                }\\n                // If next char is a (\\n                else{\\n                    if(open==0){\\n                        openneeded++;\\n                        closeneeded++;\\n                    }\\n                    else {\\n                        open--;\\n                        closeneeded++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int total = 2*open + openneeded + closeneeded;\\n        return total; \\n\\t\\t}\\n};\\n```\\n\\n**Complexity Analysis:** Time Complexity - O(n) , since the entire string of length n is traversed once, and for each character we perform the operations in constant time. \\nSpace Complexity - O(1) constant space \\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack <char> st;\\n        \\n        // open & close denote number of open and close brackets needed respectively\\n        int open = 0, close = 0;\\n        \\n        for(int i = 0; i<s.length(); i++){\\n            // Push all open brackets\\n            if(s[i]==\\'(\\') st.push(s[i]);\\n            \\n            // For close brackets\\n            else if(s[i]==\\')\\') {\\n                // if consecutive close brackets appear, remove one open bracket from stack which would balance the two close brackets.  \\n\\t\\t\\t\\t// If however stack is empty, an open bracket is needed. \\n                if(  i<s.length()-1 && s[i+1]==\\')\\'){\\n                    if(!st.empty()) st.pop();\\n                    else open++;\\n                    i++; //Remember to increment the ith pointer!!\\n                }\\n                \\n                // if the next element is not a closing bracket- 2 cases: stack is empty or not\\n                else{\\n                    // for an empty stack ->    \\')\\' bracket needs an \\'(\\' and a \\')\\' to make \\'( ) )\\' \\n                    if(st.empty()){\\n                        open++;\\n                        close++; \\n                    }\\n                    \\n                    //for a filled stack ->     \\')\\' bracket and atleast 1 \\'(\\' in stack would need 1 \\')\\' to make \\'( )) \\' \\n                    else{\\n                        close++;\\n                        st.pop();\\n                    }\\n                }\\n            }\\n        }\\n        \\n        /* After traversing the complete string, the minimum brackets needed include:\\n        1. st.size() indicates the \\'(\\' which never had the required number of \\')\\' found in the string.\\n        2. close indicates number of close bracketes needed\\n        3. open indicates number of open brackets needed. Note that these are the need of \\'(\\' brackets encountered when stack was empty. \\n        */\\n        int total = st.size() * 2 + close + open;\\n        return total; \\n\\t\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int minInsertions(string s) {\\n        //Let open be the number of open brackets in the stack which did not get equivalent close brackets to balance.\\n        // openneeded be the number of ( needed (Found when stack was empty)\\n        // closeneeded be the number of ) needed \\n        int open = 0; \\n        int openneeded = 0;\\n        int closeneeded = 0;\\n        \\n        for(int i = 0; i<s.size(); i++){\\n            \\n            //For open brackets\\n            if(s[i]==\\'(\\')\\n                open++;\\n            \\n            //For close brackets\\n            else if(s[i]==\\')\\') {\\n                \\n                //If next char is also a \\')\\' , check if an open bracket was encountered before and has not yet been balanced or not. If yes, decrement the number of open brackets. \\n                if(  i<s.length()-1 && s[i+1]==\\')\\'){\\n                    if(open==0) openneeded++;\\n                    else open--;\\n                    i++;\\n                }\\n                // If next char is a (\\n                else{\\n                    if(open==0){\\n                        openneeded++;\\n                        closeneeded++;\\n                    }\\n                    else {\\n                        open--;\\n                        closeneeded++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int total = 2*open + openneeded + closeneeded;\\n        return total; \\n\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780366,
                "title": "c-o-n-proper-explaination-without-stack",
                "content": "We keep 2 variables, **ans** ``A counter for manual addition brackets`` and **req** ``Number of closing brackets that we need`` .\\nWe start iterating over the string elements one by one. Now:-\\n**1. We get an open bracket**\\nIn this, we have 2 things to understand\\n* For every open bracket, we need 2 closed brackets.\\n ``req += 2``\\n* Now if I have an odd number of closed brackets, this means that we have one ``)`` for one of the ``(``, and now we have another open bracket. As the question says ``Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))``, so we need to give a ``)`` to the existing open bracket, and then process the new one.\\n``ans++   => We added a new closed bracket\\nreq--   =>  the existing lonely ) is paired and not needed now`` \\n\\n**2. We encounter a closed bracket**\\nIn this, we again have two things to understand: \\n* If we encounter a lone warrior, basically a ``) when req = 0``, this means we can manually add a ``(`` and then say that we encountered ``()``.\\n``ans++    => We added a new open bracket``\\n``req++    => Another closed bracket is required as we have ()``\\n* Otherwise, we directly reduce the number of required closed brackets.\\n ``req--``\\n \\n Code: - (C++ O(n))\\n \\n ```\\n class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int manual_add = 0;\\n        int req_close = 0;\\n        \\n        for (int i=0;i<s.length();i++) {\\n            // we see an opening bracket\\n            if (s[i] == \\'(\\') {\\n                // increment closed req by 2\\n                req_close += 2;\\n                if (req_close%2 != 0) {\\n                    // if total is odd, we do the steps as explained above.\\n                    manual_add++;\\n                    req_close--;\\n                }\\n            } else {\\n                // we see a closing bracket\\n                \\n                if (req_close == 0) {\\n                    // lone warrior \\\\*o*/\\n                    manual_add++;\\n                    req_close++;\\n                } else  {\\n                    req_close--;\\n                }\\n            }\\n        }\\n        return manual_add + req_close;\\n    }\\n};\\n ```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int manual_add = 0;\\n        int req_close = 0;\\n        \\n        for (int i=0;i<s.length();i++) {\\n            // we see an opening bracket\\n            if (s[i] == \\'(\\') {\\n                // increment closed req by 2\\n                req_close += 2;\\n                if (req_close%2 != 0) {\\n                    // if total is odd, we do the steps as explained above.\\n                    manual_add++;\\n                    req_close--;\\n                }\\n            } else {\\n                // we see a closing bracket\\n                \\n                if (req_close == 0) {\\n                    // lone warrior \\\\*o*/\\n                    manual_add++;\\n                    req_close++;\\n                } else  {\\n                    req_close--;\\n                }\\n            }\\n        }\\n        return manual_add + req_close;\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 780029,
                "title": "java-solusion-count-the-left-and-right-parenthese",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        \\n        int ans=0;       \\n        int cnt=0;\\n        for(char ch:s.toCharArray()){     \\n            if(ch==\\'(\\') {\\n                cnt+=2;  \\n                if(cnt%2!=0){\\n                    ans++;\\n                    cnt--;\\n                }\\n            }\\n            else{       \\n                cnt-=1;\\n                if(cnt<0){\\n                    ans++;\\n                    cnt+=2;\\n                } \\n            }           \\n        }\\n\\n        return ans+cnt;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        \\n        int ans=0;       \\n        int cnt=0;\\n        for(char ch:s.toCharArray()){     \\n            if(ch==\\'(\\') {\\n                cnt+=2;  \\n                if(cnt%2!=0){\\n                    ans++;\\n                    cnt--;\\n                }\\n            }\\n            else{       \\n                cnt-=1;\\n                if(cnt<0){\\n                    ans++;\\n                    cnt+=2;\\n                } \\n            }           \\n        }\\n\\n        return ans+cnt;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780409,
                "title": "python-simple-solution-with-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        ## RC ##\\n        ## APPROACH : STACK ##\\n        ## LOGIC ##\\n        ## 1. Only 3 conditions, open brace -> push to stack\\n        ## 2. 2 close braces -> pop from stack, if you donot have enough open braces before increment count(indicates one open required)\\n        ## 3. Only 1 close brace found --> count + 1, to make it 2 close braces, if stack then just pop, if stack is empty then increment count by 2 (one for close brace, one for open brace)\\n        ## 4. If stack is still left with open braces, we require close braces = twice of that open braces in stack\\n        \\n        ## You can even optimize it, without using stack, just counting the left braces.\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        \\n        s += \"$\"  # appending dummy character at the end, to make things simpler\\n        left_braces, count, i = 0, 0, 0\\n        while( i < len(s)-1 ):\\n            if s[i] == \"(\":\\n                left_braces, i = left_braces + 1, i + 1\\n            elif s[i] == \")\" and s[i+1] == \")\":\\n                if left_braces:\\n                    left_braces -= 1\\n                else:\\n                    count += 1                  # one open brace required\\n                i += 2\\n            elif s[i] == \")\" and s[i+1] != \")\":\\n                if left_braces:\\n                    count += 1                  # one close brace required\\n                    left_braces -= 1\\n                else:\\n                    count += 2                  # one open and one close brace required\\n                i += 1\\n        return count + (left_braces * 2)        # close braces required at the end for all the remaining left braces\\n```\\nPlease upvote if you liked my solution.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        ## RC ##\\n        ## APPROACH : STACK ##\\n        ## LOGIC ##\\n        ## 1. Only 3 conditions, open brace -> push to stack\\n        ## 2. 2 close braces -> pop from stack, if you donot have enough open braces before increment count(indicates one open required)\\n        ## 3. Only 1 close brace found --> count + 1, to make it 2 close braces, if stack then just pop, if stack is empty then increment count by 2 (one for close brace, one for open brace)\\n        ## 4. If stack is still left with open braces, we require close braces = twice of that open braces in stack\\n        \\n        ## You can even optimize it, without using stack, just counting the left braces.\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        \\n        s += \"$\"  # appending dummy character at the end, to make things simpler\\n        left_braces, count, i = 0, 0, 0\\n        while( i < len(s)-1 ):\\n            if s[i] == \"(\":\\n                left_braces, i = left_braces + 1, i + 1\\n            elif s[i] == \")\" and s[i+1] == \")\":\\n                if left_braces:\\n                    left_braces -= 1\\n                else:\\n                    count += 1                  # one open brace required\\n                i += 2\\n            elif s[i] == \")\" and s[i+1] != \")\":\\n                if left_braces:\\n                    count += 1                  # one close brace required\\n                    left_braces -= 1\\n                else:\\n                    count += 2                  # one open and one close brace required\\n                i += 1\\n        return count + (left_braces * 2)        # close braces required at the end for all the remaining left braces\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780291,
                "title": "java-linear-loop-and-o-1-space",
                "content": "```\\n    public int minInsertions(String s) {\\n        int st = 0, l = s.length(), res = 0;\\n        for (int i = 0; i < l; i++) {\\n            if (s.charAt(i) == \\'(\\') st++;  // found a \\'(\\', push\\n            else {\\n                if (st == 0) {\\n                    res++;  // need insert a \\'(\\';\\n                    st++;\\n                }\\n                if (i + 1 < l && s.charAt(i + 1) == \\')\\') i++; //next loop start from i + 2;\\n                else res++;   // need insert a \\')\\'\\n                st--;  // found a match, pop;\\n            }\\n        }\\n        return res + st * 2;   // every unmatched \\'(\\', need two \\')\\';\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minInsertions(String s) {\\n        int st = 0, l = s.length(), res = 0;\\n        for (int i = 0; i < l; i++) {\\n            if (s.charAt(i) == \\'(\\') st++;  // found a \\'(\\', push\\n            else {\\n                if (st == 0) {\\n                    res++;  // need insert a \\'(\\';\\n                    st++;\\n                }\\n                if (i + 1 < l && s.charAt(i + 1) == \\')\\') i++; //next loop start from i + 2;\\n                else res++;   // need insert a \\')\\'\\n                st--;  // found a match, pop;\\n            }\\n        }\\n        return res + st * 2;   // every unmatched \\'(\\', need two \\')\\';\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779917,
                "title": "c-o-n-o-1-track-left-and-right",
                "content": "```cpp\\nint minInsertions(string s) {\\n    int l = 0, r = 0, res = 0;\\n    for (auto ch : s) {\\n        if (ch == \\'(\\') {\\n            if (r != 0) {\\n                res += l > 0 ? 1 : 2;\\n                l = max(0, l - 1);\\n                r = 0;\\n            }\\n            ++l;\\n        } else if (++r == 2) {\\n            r = 0;\\n            if (l > 0)\\n                --l;\\n            else\\n                ++res;\\n        }\\n    }\\n    if (l > 0)\\n        return res + 2 * l - r;\\n    return res + (r == 1 ? 2 : 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minInsertions(string s) {\\n    int l = 0, r = 0, res = 0;\\n    for (auto ch : s) {\\n        if (ch == \\'(\\') {\\n            if (r != 0) {\\n                res += l > 0 ? 1 : 2;\\n                l = max(0, l - 1);\\n                r = 0;\\n            }\\n            ++l;\\n        } else if (++r == 2) {\\n            r = 0;\\n            if (l > 0)\\n                --l;\\n            else\\n                ++res;\\n        }\\n    }\\n    if (l > 0)\\n        return res + 2 * l - r;\\n    return res + (r == 1 ? 2 : 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779986,
                "title": "java-stack-solution-easy-to-understand",
                "content": "Idea:\\n\\n1. if the character is closing `)` \\n\\t* stack is not empty\\n\\t\\t if last character in stack is also `)` then just pop two characters from stack `())`\\n\\t\\t else add character in stack\\n\\t* to make balance we need to insert `(` before so increment count and add `(` in stack along with `)`\\n2. if the character is closing `(` \\n\\t* stack is not empty\\n\\t\\tif stack peek is also `(` just add into stakc\\n\\t\\telse count++ and pop from stack \\n\\t*  add into stack\\n\\t\\n3. loop until stack is not empty and check \\n\\t* if peek character `(` count += 2 and pop from stack once\\n\\t* else for `)` count++ and pop from stack twice\\n\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int count = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\')\\') {\\n                if (!stack.isEmpty()) {\\n                    if (stack.peek() == \\')\\') {\\n                        stack.pop();\\n                        stack.pop();\\n                    } else {\\n                        stack.add(c);\\n                    }\\n                } else {\\n                    count++;\\n                    stack.add(\\'(\\');\\n                    stack.add(c);\\n                }\\n            } else {\\n                if (!stack.isEmpty()) {\\n                    if (stack.peek() == \\'(\\') {\\n                        stack.add(c);\\n                    } else {\\n                        count++;\\n                        stack.pop();\\n                    }\\n                } else {\\n                    stack.add(c);\\n                }\\n            }\\n        }\\n\\n        while (!stack.isEmpty()) {\\n            if (stack.peek() == \\'(\\') {\\n                count += 2;\\n                stack.pop();\\n            } else {\\n                count++;\\n                stack.pop();\\n                stack.pop();\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int count = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\')\\') {\\n                if (!stack.isEmpty()) {\\n                    if (stack.peek() == \\')\\') {\\n                        stack.pop();\\n                        stack.pop();\\n                    } else {\\n                        stack.add(c);\\n                    }\\n                } else {\\n                    count++;\\n                    stack.add(\\'(\\');\\n                    stack.add(c);\\n                }\\n            } else {\\n                if (!stack.isEmpty()) {\\n                    if (stack.peek() == \\'(\\') {\\n                        stack.add(c);\\n                    } else {\\n                        count++;\\n                        stack.pop();\\n                    }\\n                } else {\\n                    stack.add(c);\\n                }\\n            }\\n        }\\n\\n        while (!stack.isEmpty()) {\\n            if (stack.peek() == \\'(\\') {\\n                count += 2;\\n                stack.pop();\\n            } else {\\n                count++;\\n                stack.pop();\\n                stack.pop();\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779956,
                "title": "java-solution-without-using-stack-just-with-counter",
                "content": "The idea is to save down the count of left parenthesis, then match it with double \\')\\'.\\nIf case of single \\')\\' or end of String happened, we did special handling as shown below.\\n\\n```\\npublic int minInsertions(String s) {\\n        int res = 0, left = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') { // when (\\n                left++;\\n            } else if (i == s.length() - 1 || s.charAt(i + 1) == \\'(\\') { // when single )\\n                if (left > 0) {\\n                    res++;\\n                    left--;\\n                } else {\\n                    res += 2;\\n                }\\n            } else { // when double )\\n                if (left > 0) left--;\\n                else res++;\\n                i++; // advance pointer since we have process double ) in a time\\n            }\\n        }\\n        res += left * 2;\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minInsertions(String s) {\\n        int res = 0, left = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') { // when (\\n                left++;\\n            } else if (i == s.length() - 1 || s.charAt(i + 1) == \\'(\\') { // when single )\\n                if (left > 0) {\\n                    res++;\\n                    left--;\\n                } else {\\n                    res += 2;\\n                }\\n            } else { // when double )\\n                if (left > 0) left--;\\n                else res++;\\n                i++; // advance pointer since we have process double ) in a time\\n            }\\n        }\\n        res += left * 2;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779974,
                "title": "c-solution-using-stack-and-conditions",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> v;\\n        int ans = 0;\\n        for(int i = 0;i < s.size();i++){\\n            if(s[i] == \\'(\\') v.push(s[i]);\\n            else{\\n                if(s[i] == \\')\\' && i < s.size() && s[i + 1] == \\')\\') {\\n                    if(!v.empty())\\n                        v.pop();\\n                    else ans++;\\n                    i++;       // because we considered i+1 in this case\\n                }\\n                else if(s[i] == \\')\\' && i < s.size() && s[i + 1] != \\')\\'){\\n                    if(!v.empty()){\\n                        v.pop();\\n                        ans++;\\n                    }\\n                    else ans += 2;\\n                }\\n            }\\n        }\\n        if(v.empty()) return ans;\\n        return v.size()*2 + ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> v;\\n        int ans = 0;\\n        for(int i = 0;i < s.size();i++){\\n            if(s[i] == \\'(\\') v.push(s[i]);\\n            else{\\n                if(s[i] == \\')\\' && i < s.size() && s[i + 1] == \\')\\') {\\n                    if(!v.empty())\\n                        v.pop();\\n                    else ans++;\\n                    i++;       // because we considered i+1 in this case\\n                }\\n                else if(s[i] == \\')\\' && i < s.size() && s[i + 1] != \\')\\'){\\n                    if(!v.empty()){\\n                        v.pop();\\n                        ans++;\\n                    }\\n                    else ans += 2;\\n                }\\n            }\\n        }\\n        if(v.empty()) return ans;\\n        return v.size()*2 + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780161,
                "title": "simple-java-solution-using-stack",
                "content": "Also viewable on [Github here](https://github.com/fishercoder1534/Leetcode/blob/master/src/main/java/com/fishercoder/solutions/_1541.java).\\n```\\n public int minInsertions(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int insertionsNeeded = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                if (stack.isEmpty()) {\\n                    stack.add(c);\\n                } else {\\n                    if (stack.peek() == \\')\\') {\\n                        //in this case, we need to add one more \\')\\' to get two consecutive right paren, then we could pop the one \\')\\' and one \\'(\\' off the stack\\n                        insertionsNeeded++;\\n                        stack.pop();\\n                        stack.pop();\\n                        stack.add(c);\\n                    } else {\\n                        stack.add(c);\\n                    }\\n                }\\n            } else if (c == \\')\\') {\\n                if (stack.isEmpty()) {\\n                    //in this case, we need to add one \\'(\\' before we add this \\')\\' onto this stack\\n                    insertionsNeeded++;\\n                    stack.add(\\'(\\');\\n                    stack.add(c);\\n                } else {\\n                    if (stack.peek() == \\')\\') {\\n                        //in this case, we could pop the one \\')\\' and one \\'(\\' off the stack\\n                        stack.pop();\\n                        stack.pop();\\n                    } else {\\n                        stack.add(c);\\n                    }\\n                }\\n            }\\n        }\\n        if (stack.isEmpty()) {\\n            return insertionsNeeded;\\n        } else {\\n            while (!stack.isEmpty()) {\\n                char pop = stack.pop();\\n                if (pop == \\'(\\') {\\n                    insertionsNeeded += 2;\\n                } else {\\n                    insertionsNeeded++;\\n                    stack.pop();\\n                }\\n            }\\n            return insertionsNeeded;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int minInsertions(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int insertionsNeeded = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                if (stack.isEmpty()) {\\n                    stack.add(c);\\n                } else {\\n                    if (stack.peek() == \\')\\') {\\n                        //in this case, we need to add one more \\')\\' to get two consecutive right paren, then we could pop the one \\')\\' and one \\'(\\' off the stack\\n                        insertionsNeeded++;\\n                        stack.pop();\\n                        stack.pop();\\n                        stack.add(c);\\n                    } else {\\n                        stack.add(c);\\n                    }\\n                }\\n            } else if (c == \\')\\') {\\n                if (stack.isEmpty()) {\\n                    //in this case, we need to add one \\'(\\' before we add this \\')\\' onto this stack\\n                    insertionsNeeded++;\\n                    stack.add(\\'(\\');\\n                    stack.add(c);\\n                } else {\\n                    if (stack.peek() == \\')\\') {\\n                        //in this case, we could pop the one \\')\\' and one \\'(\\' off the stack\\n                        stack.pop();\\n                        stack.pop();\\n                    } else {\\n                        stack.add(c);\\n                    }\\n                }\\n            }\\n        }\\n        if (stack.isEmpty()) {\\n            return insertionsNeeded;\\n        } else {\\n            while (!stack.isEmpty()) {\\n                char pop = stack.pop();\\n                if (pop == \\'(\\') {\\n                    insertionsNeeded += 2;\\n                } else {\\n                    insertionsNeeded++;\\n                    stack.pop();\\n                }\\n            }\\n            return insertionsNeeded;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 797128,
                "title": "c-o-n-step-by-step-from-space-o-n-to-o-1",
                "content": "1. Naive Implementation [Time O(n) Space O(n)]\\n```\\n    int minInsertions(string t) {\\n        int ans=0;\\n        stack<char> s;\\n        int n = t.length();\\n        for(int i=0;i<n;i++){\\n            char c = t[i];\\n            if(c==\\'(\\')\\n                s.push(\\'(\\');\\n            else{\\n                if(s.empty()){\\n                    if(i+1<n && t[i+1]==\\')\\')\\n                        ans++,i++;\\n                    else\\n                        ans+=2;\\n                }\\n                else{\\n\\t\\t\\t\\t\\ts.pop();\\n                    if(i+1<n && t[i+1]==\\')\\') i++;\\n                    else ans++;\\t\\t\\t\\t\\t\\n                }\\n            }\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n```\\n2. Concise Implementation [Time O(n) Space O(n)]\\n```\\n    int minInsertions(string t) {\\n        int ans=0;\\n        stack<char> s;\\n        int n = t.length();\\n        for(int i=0;i<n;i++){\\n            char c = t[i];\\n            if(c==\\'(\\')\\n                s.push(\\'(\\');\\n            else{\\n                if(i+1<n && t[i+1]==\\')\\') i++;\\n                else ans++;\\n                \\n                if(s.empty()) ans++;\\n                else s.pop();\\n            }\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n```\\n3. Final Code  [Time O(n) Space O(1)]\\n```\\n    int minInsertions(string t) {\\n        \\n        int top=0,ans=0;\\n        int n = t.length();\\n        for(int i=0;i<n;i++){\\n            char c = t[i];\\n            if(c==\\'(\\')\\n                top++;\\n            else{\\n                if(i+1<n && t[i+1]==\\')\\') i++;\\n                else ans++;\\n                \\n                if(top==0) ans++;\\n                else top--;\\n            }\\n        }\\n\\n        return ans+2*top;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    int minInsertions(string t) {\\n        int ans=0;\\n        stack<char> s;\\n        int n = t.length();\\n        for(int i=0;i<n;i++){\\n            char c = t[i];\\n            if(c==\\'(\\')\\n                s.push(\\'(\\');\\n            else{\\n                if(s.empty()){\\n                    if(i+1<n && t[i+1]==\\')\\')\\n                        ans++,i++;\\n                    else\\n                        ans+=2;\\n                }\\n                else{\\n\\t\\t\\t\\t\\ts.pop();\\n                    if(i+1<n && t[i+1]==\\')\\') i++;\\n                    else ans++;\\t\\t\\t\\t\\t\\n                }\\n            }\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n```\n```\\n    int minInsertions(string t) {\\n        int ans=0;\\n        stack<char> s;\\n        int n = t.length();\\n        for(int i=0;i<n;i++){\\n            char c = t[i];\\n            if(c==\\'(\\')\\n                s.push(\\'(\\');\\n            else{\\n                if(i+1<n && t[i+1]==\\')\\') i++;\\n                else ans++;\\n                \\n                if(s.empty()) ans++;\\n                else s.pop();\\n            }\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n```\n```\\n    int minInsertions(string t) {\\n        \\n        int top=0,ans=0;\\n        int n = t.length();\\n        for(int i=0;i<n;i++){\\n            char c = t[i];\\n            if(c==\\'(\\')\\n                top++;\\n            else{\\n                if(i+1<n && t[i+1]==\\')\\') i++;\\n                else ans++;\\n                \\n                if(top==0) ans++;\\n                else top--;\\n            }\\n        }\\n\\n        return ans+2*top;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779978,
                "title": "simple-solution-in-o-n-intuitive-beats-100-python-explanation",
                "content": "1- First we replace all double closed brackets with a single squared closed bracket as that is what they behave like.\\n2- Then we find all alone closed brackets. Since they are useless alone we add one more closed bracket to all of them and again replace them with a single squared closed bracket.\\n3- Then do simple balancing\\n\\n```Python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        ret=0\\n        s = s.replace(\\'))\\', \\']\\')\\n        ret+=s.count(\\')\\')\\n        s = s.replace(\\')\\', \\']\\')\\n        bal = 0\\n        for i,v in enumerate(s):\\n            if v == \\'(\\':\\n                bal+=1\\n            elif v==\\']\\':\\n                bal-=1\\n            if bal==-1:\\n                ret+=1\\n                bal+=1\\n        return ret + 2*bal\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        ret=0\\n        s = s.replace(\\'))\\', \\']\\')\\n        ret+=s.count(\\')\\')\\n        s = s.replace(\\')\\', \\']\\')\\n        bal = 0\\n        for i,v in enumerate(s):\\n            if v == \\'(\\':\\n                bal+=1\\n            elif v==\\']\\':\\n                bal-=1\\n            if bal==-1:\\n                ret+=1\\n                bal+=1\\n        return ret + 2*bal\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 779885,
                "title": "stack-like-operation-but-don-t-need-a-stack",
                "content": "```\\nint minInsertions(string s) {\\n        int res = 0; //operations we added\\n        int n = s.size();\\n        int left = 0; //how many \\'(\\'\\n        \\n        for(int i = 0; i < n; ++i) {\\n            if(s[i] == \\'(\\') {\\n                ++left;\\n            } else {\\n                if(left == 0) {\\n                    ++res; //add \\'(\\'\\n                    ++left; //we actually manually added a \\'(\\'\\n                }\\n                \\n                //if we happen to have \"))\", we simply pop a \\'(\\'\\n                if(i < n-1 && s[i+1] == \\')\\') {\\n                    ++i;\\n                    --left;\\n                \\n                } else {\\n                    //otherwise, we add a \\')\\' and pop a \\'(\\'\\n                    --left;\\n                    ++res; //add \\')\\'\\'\\n                }\\n            }\\n        }\\n        return res + 2*left;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minInsertions(string s) {\\n        int res = 0; //operations we added\\n        int n = s.size();\\n        int left = 0; //how many \\'(\\'\\n        \\n        for(int i = 0; i < n; ++i) {\\n            if(s[i] == \\'(\\') {\\n                ++left;\\n            } else {\\n                if(left == 0) {\\n                    ++res; //add \\'(\\'\\n                    ++left; //we actually manually added a \\'(\\'\\n                }\\n                \\n                //if we happen to have \"))\", we simply pop a \\'(\\'\\n                if(i < n-1 && s[i+1] == \\')\\') {\\n                    ++i;\\n                    --left;\\n                \\n                } else {\\n                    //otherwise, we add a \\')\\' and pop a \\'(\\'\\n                    --left;\\n                    ++res; //add \\')\\'\\'\\n                }\\n            }\\n        }\\n        return res + 2*left;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1214894,
                "title": "java-constant-space-solution-one-pass",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int open=0;\\n        int ans=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                if(i+1<s.length() && s.charAt(i+1)==\\')\\'){\\n                    i++;\\n                    if(open>0){\\n                        open--;\\n                    }\\n                    else{\\n                        ans++;\\n                    }\\n                }\\n                else{\\n                    if(open>0){\\n                        open--;\\n                        ans++;\\n                    }\\n                    else{\\n                        ans+=2;\\n                    }\\n                }\\n            }\\n        }\\n        ans+=2*open;\\n        return ans;\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int open=0;\\n        int ans=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                if(i+1<s.length() && s.charAt(i+1)==\\')\\'){\\n                    i++;\\n                    if(open>0){\\n                        open--;\\n                    }\\n                    else{\\n                        ans++;\\n                    }\\n                }\\n                else{\\n                    if(open>0){\\n                        open--;\\n                        ans++;\\n                    }\\n                    else{\\n                        ans+=2;\\n                    }\\n                }\\n            }\\n        }\\n        ans+=2*open;\\n        return ans;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574980,
                "title": "java-solution-o-1-space-explained-in-comments",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int countBraces = 0;\\n        int ans = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                countBraces += 1;\\n            }\\n            else{\\n                //Case 1-> Whenever a closing bracket is encountered, one case can be it is followed by another closing bracket and preceeded/not preceeded by an opening bracket(handled in this following if block)\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    if(countBraces > 0){\\n                        countBraces--; // It\\'s balanced only.. Just decrement the opening bracket\\n                    }\\n                    else{\\n                        //This is the case for --> \"))\" It means we need to add 1 opening bracket --> \"(\"\\n                        ans += 1;\\n                    }\\n                    i++;\\n                }\\n                else{\\n                    //Case 2 -> Whenever a closing bracket is encountered, another case can be it is not followed by another closing bracket and preceeded/not preceeded by an opening bracket(handled in this following if block)\\n                    if(countBraces > 0){\\n                        countBraces--;\\n                        ans += 1;//Add the last closing bracket to balance\\n                    }\\n                    else{\\n                        \\n                        ans += 2;//Add the last closing bracket and first opening bracket(eg.test case-> \")\")\\n                    }\\n                }\\n                //Finally we should return the 2times the number of countBraces(opening brackets remaining in excess)\\n            }\\n        }\\n        return ans+countBraces*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int countBraces = 0;\\n        int ans = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                countBraces += 1;\\n            }\\n            else{\\n                //Case 1-> Whenever a closing bracket is encountered, one case can be it is followed by another closing bracket and preceeded/not preceeded by an opening bracket(handled in this following if block)\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    if(countBraces > 0){\\n                        countBraces--; // It\\'s balanced only.. Just decrement the opening bracket\\n                    }\\n                    else{\\n                        //This is the case for --> \"))\" It means we need to add 1 opening bracket --> \"(\"\\n                        ans += 1;\\n                    }\\n                    i++;\\n                }\\n                else{\\n                    //Case 2 -> Whenever a closing bracket is encountered, another case can be it is not followed by another closing bracket and preceeded/not preceeded by an opening bracket(handled in this following if block)\\n                    if(countBraces > 0){\\n                        countBraces--;\\n                        ans += 1;//Add the last closing bracket to balance\\n                    }\\n                    else{\\n                        \\n                        ans += 2;//Add the last closing bracket and first opening bracket(eg.test case-> \")\")\\n                    }\\n                }\\n                //Finally we should return the 2times the number of countBraces(opening brackets remaining in excess)\\n            }\\n        }\\n        return ans+countBraces*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488865,
                "title": "simple-soln-using-stack",
                "content": "```\\n  int minInsertions(string s) {\\n        int n=s.size();\\n        stack<char>stk;\\n        int minInsert=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                stk.push(s[i]);\\n            }\\n            else \\n            {\\n                if( s[i] == \\')\\' && i < n && s[i + 1] == \\')\\')\\n                {\\n                    if(!stk.empty())\\n                    {\\n                       stk.pop();\\n                    }\\n                    else\\n                    {\\n                        minInsert++;\\n                    }\\n                    \\n                    i++;\\n                }\\n                \\n                else if(s[i] == \\')\\' && i < n && s[i + 1] != \\')\\' ) {\\n                    if(!stk.empty()){\\n                        stk.pop();\\n                        minInsert++;\\n                    }\\n                    else minInsert += 2;\\n                \\n            }\\n        }\\n        \\n    }\\n         \\n        if(stk.empty())\\n        {return minInsert;}\\n        else\\n        {return minInsert+2*stk.size();}\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n  int minInsertions(string s) {\\n        int n=s.size();\\n        stack<char>stk;\\n        int minInsert=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                stk.push(s[i]);\\n            }\\n            else \\n            {\\n                if( s[i] == \\')\\' && i < n && s[i + 1] == \\')\\')\\n                {\\n                    if(!stk.empty())\\n                    {\\n                       stk.pop();\\n                    }\\n                    else\\n                    {\\n                        minInsert++;\\n                    }\\n                    \\n                    i++;\\n                }\\n                \\n                else if(s[i] == \\')\\' && i < n && s[i + 1] != \\')\\' ) {\\n                    if(!stk.empty()){\\n                        stk.pop();\\n                        minInsert++;\\n                    }\\n                    else minInsert += 2;\\n                \\n            }\\n        }\\n        \\n    }\\n         \\n        if(stk.empty())\\n        {return minInsert;}\\n        else\\n        {return minInsert+2*stk.size();}\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1778621,
                "title": "c-100-faster-solution-o-n",
                "content": "****Please upvote me :)****\\n```\\nint minInsertions(string s) {\\n\\n        int add = 0, bal = 0;\\n        for (const auto& c: s) {\\n            if (c == \\'(\\') {\\n                if (bal % 2 > 0) {\\n                    ++add;  // add \\')\\' to make sure consecutive \\')\\'\\n                    --bal;\\n                }\\n                bal += 2;\\n            } else {\\n                --bal;\\n                if (bal < 0) {\\n                    ++add;  // add \\'(\\'\\n                    bal += 2;\\n                }\\n            }\\n        }\\n        return add + bal;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minInsertions(string s) {\\n\\n        int add = 0, bal = 0;\\n        for (const auto& c: s) {\\n            if (c == \\'(\\') {\\n                if (bal % 2 > 0) {\\n                    ++add;  // add \\')\\' to make sure consecutive \\')\\'\\n                    --bal;\\n                }\\n                bal += 2;\\n            } else {\\n                --bal;\\n                if (bal < 0) {\\n                    ++add;  // add \\'(\\'\\n                    bal += 2;\\n                }\\n            }\\n        }\\n        return add + bal;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1391464,
                "title": "clear-explanation-c-one-pass-greedy",
                "content": "**Intution :**\\n\\nFor such kind of balancing parenthesis first thing should strike is Greedy along with Stack to balance. \\nLets see how to solve these kind of problems.\\n\\n* Idea is simple, at every index in string we need to keep the balance of opening and closing brackets i.e.\\n\\t\\n\\tcount of \\'(\\' >= count of \\')\\'  -> for all index i from 0 to n\\n\\t\\n* And to track balance at *every index i* we have two conditions : \\n\\t\\n\\t1. if element at current index i is \\'(\\' \\n\\t\\t-> do balance + 2 , since for two \\') )\\' we have one \\'(\\' \\n\\t\\t\\n\\t2. else if element is \\')\\', then do [balance - 2]\\n\\t\\t -> if next is also \\')\\' then increment i as we got two consecutive \\'))\\'\\n\\t\\t -> else we need to insert one \\')\\' next to this. So increment number of insertions counter.\\n\\n* Also, if at any point this inequality fails i.e. \\n\\t* balance become negative or \\n\\n\\t\\t*\\t\\tcount of \\'(\\' < count of \\')\\'\\n\\t\\n\\t* We need to balance that by inserting (actually increamenting count) counter bracket .\\n\\t\\n\\t\\t\\tif balance < 0, we have two cases either balance = -1 or -2\\n\\t\\t\\t\\n\\t\\t\\t\\t-> When balance = -1, this means we have only \\'(\\'\\n\\t\\t\\t\\t\\tand we need to insert one \\'(\\' and one \\')\\'.\\n\\t\\t\\t\\t\\tSo incease the counter of number of insertions by 2.\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t-> When balance = -2, this means we have two consecutive \\')\\' i.e \\') ) \\'\\n\\t\\t\\t\\t\\t and we just need single \\'(\\' to balance it.\\n\\t\\t\\t\\t\\t Thus increase counter only by 1. \\n\\t\\t\\t\\t\\t \\n\\t\\t\\t\\tIn the end, we also need to reset balance to 0 as we have \\'( ) )\\' -> valid string\\n\\n* Now, there may be some case when balance > 0. This means we have some extra \\'(\\' which do not have their counter parts. \\n* So, we have to insert those many \\')\\' to make balance=0. Thus, increament remaining to counter.\\n\\t\\n\\t\\n# Code : \\t\\n \\t\\n```\\nint minInsertions(string s) {\\n        \\n\\tint n = s.size();\\n\\tint cntInsertions = 0, balance = 0;\\n\\n\\tfor(int i=0; i<n; )\\n\\t{\\n\\tif(s[i] == \\'(\\') balance += 2;\\n\\telse if(s[i] == \\')\\')\\n\\t{\\n\\t\\tbalance -= 2;\\n\\t\\tif(i+1<n && s[i+1] == \\')\\')\\n\\t\\t{\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\telse \\n\\t\\t{\\n\\t\\t\\tcntInsertions++;\\n\\t\\t}\\n\\t}\\n\\tif(balance < 0)\\n\\t{\\n\\t\\tif(balance == -2) cntInsertions++;\\n\\t\\telse cntInsertions += 2;\\n\\t\\tbalance = 0;\\n\\t}\\n\\ti++;\\n\\n\\t// cout << balance << \" \" << cntInsertions << endl;\\n\\t}\\n\\tcntInsertions += balance;\\n\\treturn cntInsertions;\\n}\\n```\\n\\n**Time : O(N) Single pass**\\n**Space : O(1)**\\n\\nAlso do try similar problems for better grip over such problems. \\n\\n**Hope this explanation was crystal clear, and in case of any query let me know.... :)**\\n***If you understood do upvote post !!!***",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint minInsertions(string s) {\\n        \\n\\tint n = s.size();\\n\\tint cntInsertions = 0, balance = 0;\\n\\n\\tfor(int i=0; i<n; )\\n\\t{\\n\\tif(s[i] == \\'(\\') balance += 2;\\n\\telse if(s[i] == \\')\\')\\n\\t{\\n\\t\\tbalance -= 2;\\n\\t\\tif(i+1<n && s[i+1] == \\')\\')\\n\\t\\t{\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\telse \\n\\t\\t{\\n\\t\\t\\tcntInsertions++;\\n\\t\\t}\\n\\t}\\n\\tif(balance < 0)\\n\\t{\\n\\t\\tif(balance == -2) cntInsertions++;\\n\\t\\telse cntInsertions += 2;\\n\\t\\tbalance = 0;\\n\\t}\\n\\ti++;\\n\\n\\t// cout << balance << \" \" << cntInsertions << endl;\\n\\t}\\n\\tcntInsertions += balance;\\n\\treturn cntInsertions;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1146014,
                "title": "single-pass-without-extra-space",
                "content": "class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        \\n        int count=0,open=0,n=s.size();\\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'(\\') open+=1;\\n            else if(s[i]==\\')\\' && i+1<n && s[i+1]==\\')\\'){\\n                \\n                if(open==0) count+=1;\\n                else open--;\\n                i++;\\n           }\\n            \\n         else if(s[i]==\\')\\' && i+1<n && s[i+1]!=\\')\\'){\\n             \\n             if(open==0) count+=2;\\n             else {\\n                 count+=1;\\n                 open--;\\n             }\\n        }\\n       \\n        else if(s[i]==\\')\\' && i+1==n){\\n            if(open==0) count+=2;\\n            else{\\n                open--;\\n                count+=1;\\n            }\\n         }\\n            \\n        }\\n        \\n        count+=(open*2);\\n        return count;\\n            \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        \\n        int count=0,open=0,n=s.size();\\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'(\\') open+=1;\\n            else if(s[i]==\\')\\' && i+1<n && s[i+1]==\\')\\'){\\n                \\n                if(open==0) count+=1;\\n                else open--;\\n                i++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2666960,
                "title": "c-80-faster-than-all-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int minInsertions(string s) {\\n        if(s.size() == 0) return 0;\\n        int stack = 0;\\n        int invalidRight = 0;\\n        \\n        for(int i =0;i<s.size();i++){\\n            char ch = s[i];\\n            \\n            if(ch == \\'(\\') stack++;\\n            else {\\n                if(i+1 == s.size() || s[i+1]!= \\')\\') invalidRight++;\\n                else {i++;} \\n                \\n                if(stack == 0) invalidRight++;\\n                else stack--;\\n            }\\n        }\\n        return invalidRight + 2*stack;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int minInsertions(string s) {\\n        if(s.size() == 0) return 0;\\n        int stack = 0;\\n        int invalidRight = 0;\\n        \\n        for(int i =0;i<s.size();i++){\\n            char ch = s[i];\\n            \\n            if(ch == \\'(\\') stack++;\\n            else {\\n                if(i+1 == s.size() || s[i+1]!= \\')\\') invalidRight++;\\n                else {i++;} \\n                \\n                if(stack == 0) invalidRight++;\\n                else stack--;\\n            }\\n        }\\n        return invalidRight + 2*stack;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034943,
                "title": "java-o-n-time-and-o-1-space-with-explanation",
                "content": "According to the description, we can have:\\n1. for any `(`, there must have a corresponding `))` in the remaining string\\n2. for any `)`, there must have a corresponding `(` in the previous string and a successive `)` \\n\\nWe can summarize that there are totally 4 cases for a given string:\\n1. `(` and `))`, which is a vaild case\\n2. `(` and `)`, which means we must add a `)`\\n3. only `)`, which meast we must add a `)` and a `(`\\n4. only `))`, which means we must add a `(`\\n5. only `(`, which means we mustt add a `))`\\n\\nwe only care about whether we can make every `(` has a corresonding `))`, no matter what sequence it is, then we can use greedy algorithm.\\n\\n**Algorithm**\\n\\n    public int minInsertions(String s) {\\n\\t    // record the \\'(\\' number we meet so far\\n        int left = 0;\\n        int res = 0;\\n        int right = 0;\\n        while (right < s.length()) {\\n            char curr = s.charAt(right);\\n            if (curr == \\'(\\') {\\n                left++;\\n            } else {\\n                if (right + 1 == s.length() || s.charAt(right + 1) != \\')\\') {\\n\\t\\t\\t\\t    // get only one \\')\\', which means we must insert another \\')\\', so add 1 to result\\n                    res++;\\n                } else {\\n\\t\\t\\t\\t    // get \\'))\\', no need to insert, move pointer to the next\\n                    right++;\\n                }\\n\\t\\t\\t\\t// after above operation, we get \\'))\\', then we need to check \\'(\\'\\n                if (left == 0) {\\n\\t\\t\\t\\t    // no \\'(\\' for \\'))\\', which means we must insert a \\'(\\', add 1 to the result\\n                    res++;\\n                } else {\\n\\t\\t\\t\\t    // we meet a valid \\'())\\', delete a \\'(\\' from the \\'(\\' number\\n                    left--;\\n                }\\n            }\\n            right++;\\n        }\\n\\t\\t// if still remain \\'(\\', insert \\'))\\' for each \\'(\\'\\n        return res + left * 2;\\n    }",
                "solutionTags": [],
                "code": "According to the description, we can have:\\n1. for any `(`, there must have a corresponding `))` in the remaining string\\n2. for any `)`, there must have a corresponding `(` in the previous string and a successive `)` \\n\\nWe can summarize that there are totally 4 cases for a given string:\\n1. `(` and `))`, which is a vaild case\\n2. `(` and `)`, which means we must add a `)`\\n3. only `)`, which meast we must add a `)` and a `(`\\n4. only `))`, which means we must add a `(`\\n5. only `(`, which means we mustt add a `))`\\n\\nwe only care about whether we can make every `(` has a corresonding `))`, no matter what sequence it is, then we can use greedy algorithm.\\n\\n**Algorithm**\\n\\n    public int minInsertions(String s) {\\n\\t    // record the \\'(\\' number we meet so far\\n        int left = 0;\\n        int res = 0;\\n        int right = 0;\\n        while (right < s.length()) {\\n            char curr = s.charAt(right);\\n            if (curr == \\'(\\') {\\n                left++;\\n            } else {\\n                if (right + 1 == s.length() || s.charAt(right + 1) != \\')\\') {\\n\\t\\t\\t\\t    // get only one \\')\\', which means we must insert another \\')\\', so add 1 to result\\n                    res++;\\n                } else {\\n\\t\\t\\t\\t    // get \\'))\\', no need to insert, move pointer to the next\\n                    right++;\\n                }\\n\\t\\t\\t\\t// after above operation, we get \\'))\\', then we need to check \\'(\\'\\n                if (left == 0) {\\n\\t\\t\\t\\t    // no \\'(\\' for \\'))\\', which means we must insert a \\'(\\', add 1 to the result\\n                    res++;\\n                } else {\\n\\t\\t\\t\\t    // we meet a valid \\'())\\', delete a \\'(\\' from the \\'(\\' number\\n                    left--;\\n                }\\n            }\\n            right++;\\n        }\\n\\t\\t// if still remain \\'(\\', insert \\'))\\' for each \\'(\\'\\n        return res + left * 2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2028472,
                "title": "javascript-o-1-space",
                "content": "``` \\nvar minInsertions = function(s) {\\n    let rightNeeded = 0;\\n    let leftNeeded = 0;\\n    for (const char of s) {\\n        if (char === \"(\") {\\n            if (rightNeeded % 2 === 0) {\\n                rightNeeded += 2;  \\n            } else {                \\n                rightNeeded++;\\n                leftNeeded++;\\n            }\\n        } else {\\n            rightNeeded--;\\n            if (rightNeeded === -1 ){\\n                leftNeeded++;\\n                rightNeeded = 1;\\n            }\\n        }\\n    }\\n    return leftNeeded + rightNeeded;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\nvar minInsertions = function(s) {\\n    let rightNeeded = 0;\\n    let leftNeeded = 0;\\n    for (const char of s) {\\n        if (char === \"(\") {\\n            if (rightNeeded % 2 === 0) {\\n                rightNeeded += 2;  \\n            } else {                \\n                rightNeeded++;\\n                leftNeeded++;\\n            }\\n        } else {\\n            rightNeeded--;\\n            if (rightNeeded === -1 ){\\n                leftNeeded++;\\n                rightNeeded = 1;\\n            }\\n        }\\n    }\\n    return leftNeeded + rightNeeded;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1736069,
                "title": "java-one-pass-o-1-space-with-explanation",
                "content": "```\\n// Define balance such that \\'(\\' increments it by 2, and \\')\\' decrements it by 1. 0 balance is expected at the end.\\n// if \\'(\\' comes, make sure balance is not an odd number, because then one opening parenthesis has only been partially closed. If balance is odd, we need to add ), and modify balance accordingly.\\n// if balance going negative, we have extra closing parenthesis. Add \\'(\\' and inc by bal by 2. \\n// At the end, if balance>0, we need to add extra \\')\\' to make balance=0.\\n```\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int count = 0; // tracks the extra additions we have made\\n        int balance = 0;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\'){\\n\\t\\t\\t\\n\\t\\t\\t    // if \\'(\\' comes, make sure balance is not an odd number, \\n\\t\\t\\t\\t// because then one opening parenthesis has only been partially closed. \\n\\t\\t\\t\\tif(balance%2==1){\\n                    count ++;    // we need to add )\\n                    balance--;    // modify balance accordingly.\\n                }\\n\\t\\t\\t\\t// Since we added a \\'(\\'\\n                balance+=2;\\n            }else if(c == \\')\\'){\\n                balance --;\\n            }\\n            \\n\\t\\t\\t// if balance going negative, we have extra closing parenthesis. Add \\'(\\' and inc by bal by 2. \\n            if(balance<0){\\n                count++;\\n                balance+=2;\\n            }\\n        }\\n        \\n\\t\\t// At the end, if balance>0, we need to add extra \\')\\' to make balance=0.\\n        return count + balance;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Define balance such that \\'(\\' increments it by 2, and \\')\\' decrements it by 1. 0 balance is expected at the end.\\n// if \\'(\\' comes, make sure balance is not an odd number, because then one opening parenthesis has only been partially closed. If balance is odd, we need to add ), and modify balance accordingly.\\n// if balance going negative, we have extra closing parenthesis. Add \\'(\\' and inc by bal by 2. \\n// At the end, if balance>0, we need to add extra \\')\\' to make balance=0.\\n```\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int count = 0; // tracks the extra additions we have made\\n        int balance = 0;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\'){\\n\\t\\t\\t\\n\\t\\t\\t    // if \\'(\\' comes, make sure balance is not an odd number, \\n\\t\\t\\t\\t// because then one opening parenthesis has only been partially closed. \\n\\t\\t\\t\\tif(balance%2==1){\\n                    count ++;    // we need to add )\\n                    balance--;    // modify balance accordingly.\\n                }\\n\\t\\t\\t\\t// Since we added a \\'(\\'\\n                balance+=2;\\n            }else if(c == \\')\\'){\\n                balance --;\\n            }\\n            \\n\\t\\t\\t// if balance going negative, we have extra closing parenthesis. Add \\'(\\' and inc by bal by 2. \\n            if(balance<0){\\n                count++;\\n                balance+=2;\\n            }\\n        }\\n        \\n\\t\\t// At the end, if balance>0, we need to add extra \\')\\' to make balance=0.\\n        return count + balance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730396,
                "title": "python-simplest-one-pass",
                "content": "O(N) time complexity, O(1) space complexity\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        leftbrackets = insertions = 0\\n        i, n = 0, len(s)\\n\\n        while i < n:\\n            if s[i] == \\'(\\':\\n                leftbrackets += 1\\n            elif s[i] == \\')\\':\\n                if i == n-1 or s[i+1] != \\')\\': insertions += 1\\n                else: i += 1\\n                    \\n                if not leftbrackets: insertions += 1\\n                else: leftbrackets -= 1\\n                    \\n            i += 1\\n        \\n        return leftbrackets * 2 + insertions",
                "solutionTags": [
                    "Python"
                ],
                "code": "O(N) time complexity, O(1) space complexity\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        leftbrackets = insertions = 0\\n        i, n = 0, len(s)\\n\\n        while i < n:\\n            if s[i] == \\'(\\':\\n                leftbrackets += 1\\n            elif s[i] == \\')\\':\\n                if i == n-1 or s[i+1] != \\')\\': insertions += 1\\n                else: i += 1\\n                    \\n                if not leftbrackets: insertions += 1\\n                else: leftbrackets -= 1\\n                    \\n            i += 1\\n        \\n        return leftbrackets * 2 + insertions",
                "codeTag": "Java"
            },
            {
                "id": 1650461,
                "title": "c-left-to-right-right-to-left-most-intuitive-amateur-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        \\n        int minInsert = 0; // final answer \\n        \\n        vector<char> ss; // is the equivalent string wherein \\'))\\' is denoted by a single \\')\\'\\n        \\n        \\n       //1. Find the number of inserts to make consecutive \\'))\\'---\\n        for(int i=0;i<n;i++){\\n            ss.push_back(s[i]);\\n            \\n            if(s[i] == \\')\\'){\\n                if(i == n-1 || s[i+1] != \\')\\')\\n                    minInsert++;\\n                else\\n                    i++;\\n            }\\n        }\\n        //---------------------------------------------------------\\n        \\n        \\n        //2. Now, just usual minimum inserts to balance where \\'ss\\' is the new string we will use\\n        n = ss.size();\\n        \\n        \\n        //2.1: left-to-right -> to balance unpaired \\')\\' \\n        int balance = 0;\\n        for(int i=0;i<n;i++){\\n            balance += (ss[i]==\\'(\\') - (ss[i]==\\')\\');\\n            if(balance == -1){\\n                minInsert+=1; // we need 1 extra \\'(\\' to balance one unpaired \\')\\' {wherein \\')\\' == \\'))\\' as per problem}\\n                balance= 0;\\n            }\\n        }\\n        \\n        \\n        //2.2: right-to-left -> to balance unpaired \\'(\\'\\n        balance = 0;\\n        for(int i=n-1;i>=0;i--){\\n            balance += (ss[i]==\\')\\') - (ss[i]==\\'(\\');\\n            if(balance == -1){\\n                minInsert+=2; // NOTE: we need \\'))\\' to balance one unpaired \\'(\\', hence +=2\\n                balance = 0;\\n            }\\n        }\\n        \\n        \\n        return minInsert; \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        \\n        int minInsert = 0; // final answer \\n        \\n        vector<char> ss; // is the equivalent string wherein \\'))\\' is denoted by a single \\')\\'\\n        \\n        \\n       //1. Find the number of inserts to make consecutive \\'))\\'---\\n        for(int i=0;i<n;i++){\\n            ss.push_back(s[i]);\\n            \\n            if(s[i] == \\')\\'){\\n                if(i == n-1 || s[i+1] != \\')\\')\\n                    minInsert++;\\n                else\\n                    i++;\\n            }\\n        }\\n        //---------------------------------------------------------\\n        \\n        \\n        //2. Now, just usual minimum inserts to balance where \\'ss\\' is the new string we will use\\n        n = ss.size();\\n        \\n        \\n        //2.1: left-to-right -> to balance unpaired \\')\\' \\n        int balance = 0;\\n        for(int i=0;i<n;i++){\\n            balance += (ss[i]==\\'(\\') - (ss[i]==\\')\\');\\n            if(balance == -1){\\n                minInsert+=1; // we need 1 extra \\'(\\' to balance one unpaired \\')\\' {wherein \\')\\' == \\'))\\' as per problem}\\n                balance= 0;\\n            }\\n        }\\n        \\n        \\n        //2.2: right-to-left -> to balance unpaired \\'(\\'\\n        balance = 0;\\n        for(int i=n-1;i>=0;i--){\\n            balance += (ss[i]==\\')\\') - (ss[i]==\\'(\\');\\n            if(balance == -1){\\n                minInsert+=2; // NOTE: we need \\'))\\' to balance one unpaired \\'(\\', hence +=2\\n                balance = 0;\\n            }\\n        }\\n        \\n        \\n        return minInsert; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779952,
                "title": "python-using-stack-o-n-100-time",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        stack = []\\n        cur_closed = 0\\n        modifications_needed = 0\\n        \\n        for char in s:\\n            if char == \\'(\\':\\n                if cur_closed == 1:\\n                    modifications_needed += 1\\n                    cur_closed = 0\\n                    stack.pop()\\n                    \\n                stack.append(\\'(\\')\\n            \\n            else:\\n                if not stack:\\n                    stack.append(\\'(\\')\\n                    modifications_needed += 1\\n                    cur_closed += 1\\n                    \\n                elif cur_closed == 1:\\n                    cur_closed = 0\\n                    stack.pop()\\n                else:\\n                    cur_closed += 1\\n                    \\n        if stack:\\n            modifications_needed += (len(stack) * 2) - cur_closed\\n            \\n        return modifications_needed\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        stack = []\\n        cur_closed = 0\\n        modifications_needed = 0\\n        \\n        for char in s:\\n            if char == \\'(\\':\\n                if cur_closed == 1:\\n                    modifications_needed += 1\\n                    cur_closed = 0\\n                    stack.pop()\\n                    \\n                stack.append(\\'(\\')\\n            \\n            else:\\n                if not stack:\\n                    stack.append(\\'(\\')\\n                    modifications_needed += 1\\n                    cur_closed += 1\\n                    \\n                elif cur_closed == 1:\\n                    cur_closed = 0\\n                    stack.pop()\\n                else:\\n                    cur_closed += 1\\n                    \\n        if stack:\\n            modifications_needed += (len(stack) * 2) - cur_closed\\n            \\n        return modifications_needed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779910,
                "title": "c-easy-to-understand-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0, n = s.length();\\n        stack<char> st;\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == \\'(\\') st.push(s[i]);\\n            else {\\n                // If we have both )) in the string, increment i and if we have a single ) increase count\\n                if (i + 1 < n && s[i] == s[i + 1]) i++;\\n                else count++;\\n                \\n                // If we have ( for corresponding )), pop otherwise increase the count.\\n                if (!st.empty()) st.pop();\\n                else count++;\\n            }\\n        }\\n        \\n        return count + st.size() * 2;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0, n = s.length();\\n        stack<char> st;\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == \\'(\\') st.push(s[i]);\\n            else {\\n                // If we have both )) in the string, increment i and if we have a single ) increase count\\n                if (i + 1 < n && s[i] == s[i + 1]) i++;\\n                else count++;\\n                \\n                // If we have ( for corresponding )), pop otherwise increase the count.\\n                if (!st.empty()) st.pop();\\n                else count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2424596,
                "title": "c-stack-t-o-n-s-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/6d646c38-5b86-4ab9-ae05-e4a82476d06c_1660481979.6475577.png)\\n\\n**n==s.size()\\nT->O(n) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minInsertions(string s) {\\n\\t\\t\\tstack<char>st;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'(\\') st.push(\\'(\\');\\n\\t\\t\\t\\telse if(s[i]==\\')\\' && s[i+1]==\\')\\'){\\n\\t\\t\\t\\t\\tif(st.empty())count++;\\n\\t\\t\\t\\t\\telse st.pop();\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(!st.empty()){\\n\\t\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse count+=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(!st.empty()) count+=2*st.size();\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minInsertions(string s) {\\n\\t\\t\\tstack<char>st;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'(\\') st.push(\\'(\\');\\n\\t\\t\\t\\telse if(s[i]==\\')\\' && s[i+1]==\\')\\'){\\n\\t\\t\\t\\t\\tif(st.empty())count++;\\n\\t\\t\\t\\t\\telse st.pop();\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2090219,
                "title": "python",
                "content": "\\n    def minInsertions(self, s):\\n        total1, total2 = 0, 0\\n        \\n        s = s.replace(\"))\",\"]\")\\n        total1 += s.count(\")\")\\n        s = s.replace(\")\",\"]\")\\n        \\n        for i, v in enumerate(s):\\n            if v == \"(\":\\n                total2 += 1\\n            elif v == \"]\":\\n                total2 -= 1\\n            \\n            if total2 == -1:\\n                total1 += 1\\n                total2 += 1\\n                \\n        return total1 + 2*total2",
                "solutionTags": [],
                "code": "\\n    def minInsertions(self, s):\\n        total1, total2 = 0, 0\\n        \\n        s = s.replace(\"))\",\"]\")\\n        total1 += s.count(\")\")\\n        s = s.replace(\")\",\"]\")\\n        \\n        for i, v in enumerate(s):\\n            if v == \"(\":\\n                total2 += 1\\n            elif v == \"]\":\\n                total2 -= 1\\n            \\n            if total2 == -1:\\n                total1 += 1\\n                total2 += 1\\n                \\n        return total1 + 2*total2",
                "codeTag": "Python3"
            },
            {
                "id": 1429325,
                "title": "c-stack",
                "content": "```\\n```\\n\\n```\\n```public:\\n    int minInsertions(string s) {\\n        long long int t,count=0;\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(s[i]);\\n            }\\n            else if(st.size()==0)\\n            {\\n                if(i<s.length()-1&&s[i+1]==\\')\\')\\n                {\\n                    i++;\\n                    count++;\\n                }\\n                else\\n                {\\n                    count=count+2;\\n                }\\n            }\\n            else\\n            {\\n                if(i<s.length()-1&&s[i+1]==\\')\\')\\n                {\\n                  i++;   \\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return count+(st.size()*2);\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1225658,
                "title": "python-92",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        count = 0\\n        o = 0\\n        s = s.replace(\\'))\\',\\']\\')\\n        for c in s:\\n            if c == \\'(\\':\\n                o+=1\\n            else:\\n                if c == \\')\\':\\n                    count+=1\\n                if o==0:\\n                    count+=1\\n                else:\\n                    o-=1\\n                    \\n        return count+(2*o)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        count = 0\\n        o = 0\\n        s = s.replace(\\'))\\',\\']\\')\\n        for c in s:\\n            if c == \\'(\\':\\n                o+=1\\n            else:\\n                if c == \\')\\':\\n                    count+=1\\n                if o==0:\\n                    count+=1\\n                else:\\n                    o-=1\\n                    \\n        return count+(2*o)",
                "codeTag": "Java"
            },
            {
                "id": 1223865,
                "title": "c-fully-commented",
                "content": "**please upvote it this helps :)**\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int len=s.length();\\n        int res=0;\\n        int i=0;\\n        int open=0;\\n        //open stores the number of opening brackets\\n        while(i<len){\\n            if(s[i]==\\'(\\')\\n            {\\n                //increment number of opening brackets\\n                open++;\\n                i++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                //check if next char is also a \\')\\'\\n                if(i+1<len && s[i+1]==\\')\\')\\n                {\\n                    if(open>0){\\n                        //decrement open as we use it for two \\')\\'\\n                        open--;\\n                    }\\n                    else{\\n                        //no opening bracket for two closing \\')\\'\\n                        res+=1;\\n                    }\\n                    i+=2;\\n                }\\n                else{\\n                    //found single  \\')\\'\\n                    if(open>0)\\n                    {\\n                        //we have one \\'(\\' and need only one \\')\\'\\n                        open--;\\n                        res+=1;\\n                    }\\n                    else{\\n                    //need one \\'(\\' and one closing \\')\\'\\n                        res+=2;\\n                    }\\n                i++;\\n                }\\n            }\\n        }\\n        if(open>0)\\n            res+=(2*open);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int len=s.length();\\n        int res=0;\\n        int i=0;\\n        int open=0;\\n        //open stores the number of opening brackets\\n        while(i<len){\\n            if(s[i]==\\'(\\')\\n            {\\n                //increment number of opening brackets\\n                open++;\\n                i++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                //check if next char is also a \\')\\'\\n                if(i+1<len && s[i+1]==\\')\\')\\n                {\\n                    if(open>0){\\n                        //decrement open as we use it for two \\')\\'\\n                        open--;\\n                    }\\n                    else{\\n                        //no opening bracket for two closing \\')\\'\\n                        res+=1;\\n                    }\\n                    i+=2;\\n                }\\n                else{\\n                    //found single  \\')\\'\\n                    if(open>0)\\n                    {\\n                        //we have one \\'(\\' and need only one \\')\\'\\n                        open--;\\n                        res+=1;\\n                    }\\n                    else{\\n                    //need one \\'(\\' and one closing \\')\\'\\n                        res+=2;\\n                    }\\n                i++;\\n                }\\n            }\\n        }\\n        if(open>0)\\n            res+=(2*open);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208565,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stk=new Stack<Character>();\\n        int bal=0;\\n        for(int i=0;i<s.length();)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            {\\n                stk.push(s.charAt(i));\\n                i++;\\n            }\\n            else \\n            {\\n                //if incase stack is empty,check next character\\n                if(stk.empty())\\n                {\\n                    //if next character is ),then you need to add one ( for balancing,so bal++\\n                    if(i+1<s.length() && s.charAt(i+1)==\\')\\')\\n                    {\\n                        bal++;\\n                        i+=2;\\n                    }\\n                    //if next character is not ),then you need to add one ( and one ) for balancing,so bal+=2\\n                    else\\n                    {\\n                        bal+=2;\\n                        i++;\\n                    }\\n                }\\n                //if stack is not empty,the it means,it contains a (,so check next character\\n                else\\n                {\\n                    //if next character is also ) the it is already balanced\\n                    if(i+1<s.length() && s.charAt(i+1)==\\')\\')\\n                    {\\n                        i+=2;\\n                    }\\n                    //else one ) should be added so bal++\\n                    else\\n                    {\\n                        bal++;\\n                        i++;\\n                    }\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        //if the string contains all character as ),then for each ( bal+=2\\n        while(!stk.empty())\\n        {\\n            stk.pop();\\n            bal+=2;\\n        }\\n        return bal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stk=new Stack<Character>();\\n        int bal=0;\\n        for(int i=0;i<s.length();)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            {\\n                stk.push(s.charAt(i));\\n                i++;\\n            }\\n            else \\n            {\\n                //if incase stack is empty,check next character\\n                if(stk.empty())\\n                {\\n                    //if next character is ),then you need to add one ( for balancing,so bal++\\n                    if(i+1<s.length() && s.charAt(i+1)==\\')\\')\\n                    {\\n                        bal++;\\n                        i+=2;\\n                    }\\n                    //if next character is not ),then you need to add one ( and one ) for balancing,so bal+=2\\n                    else\\n                    {\\n                        bal+=2;\\n                        i++;\\n                    }\\n                }\\n                //if stack is not empty,the it means,it contains a (,so check next character\\n                else\\n                {\\n                    //if next character is also ) the it is already balanced\\n                    if(i+1<s.length() && s.charAt(i+1)==\\')\\')\\n                    {\\n                        i+=2;\\n                    }\\n                    //else one ) should be added so bal++\\n                    else\\n                    {\\n                        bal++;\\n                        i++;\\n                    }\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        //if the string contains all character as ),then for each ( bal+=2\\n        while(!stk.empty())\\n        {\\n            stk.pop();\\n            bal+=2;\\n        }\\n        return bal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155606,
                "title": "java-stack-o-n",
                "content": "class Solution {\\n    public int minInsertions(String s) {\\n\\t\\n        int count=0;\\n        Stack<Character> stk=new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char c=s.charAt(i);\\n            if(c==\\')\\')\\n            {\\n                 // If there is no two consicutive \\')\\' , we need to insert it too , so count++\\n                \\n                if(i==s.length()-1 || s.charAt(i+1)!=\\')\\')\\n                    count++;\\n                \\n                // if there is consicutive \\')\\'...so we will move i to next \\')\\' as it has been counted.\\n                else            \\n                    i++;\\n                \\n             //if any \\')\\'encountered...so surely there will be \\'(\\'       ..so we will pop it\\n                 if(stk.size()>0)\\n                     stk.pop();\\n                \\n                // As if \\')\\' arrives then its counter which is \\'(\\' should be in stack..if it is not then we need to insert it ..so count++;\\n                 else\\n                     count++;\\n            }\\n            else\\n                stk.push(c);\\n        }\\n        \\n        while(stk.size()>0)\\n        {\\n            stk.pop();\\n            count+=2;\\n        }\\n     return count;   \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minInsertions(String s) {\\n\\t\\n        int count=0;\\n        Stack<Character> stk=new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char c=s.charAt(i);\\n            if(c==\\')\\')\\n            {\\n                 // If there is no two consicutive \\')\\' , we need to insert it too , so count++\\n                \\n                if(i==s.length()-1 || s.charAt(i+1)!=\\')\\')\\n                    count++;\\n                \\n                // if there is consicutive \\')\\'...so we will move i to next \\')\\' as it has been counted.\\n                else            \\n                    i++;\\n                \\n             //if any \\')\\'encountered...so surely there will be \\'(\\'       ..so we will pop it\\n                 if(stk.size()>0)\\n                     stk.pop();\\n                \\n                // As if \\')\\' arrives then its counter which is \\'(\\' should be in stack..if it is not then we need to insert it ..so count++;\\n                 else\\n                     count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1018761,
                "title": "o-n-solution-in-python-with-and-without-stack",
                "content": "* `O(n)` space with stack\\n```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\'\\'\\'\\n        O(n) solution with stack\\n        \\'\\'\\'\\n        N = len(s)\\n        \\n        # traverse the string\\n        toadd = 0\\n        stack = []\\n        i = 0\\n        while i<N:\\n            if s[i]==\\'(\\':\\n                stack.append(s[i])\\n                i += 1\\n            else:\\n                if s[i:i+2]==\\'))\\':\\n                    if len(stack)>0:\\n                        stack.pop()\\n                    else:\\n                        toadd += 1\\n                    i += 2\\n                else:\\n                    if len(stack)>0:\\n                        stack.pop()\\n                        toadd += 1\\n                    else:\\n                        toadd += 2\\n                    i += 1\\n        # check the length of stack\\n        if len(stack)>0:\\n            toadd += len(stack)*2\\n        \\n        return toadd\\n```\\n\\n* `O(1)` space without stack\\n```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\'\\'\\'\\n        O(n) solution without stack\\n        \\'\\'\\'\\n        N = len(s)\\n        # traverse the string\\n        lcounter = 0\\n        toadd = 0\\n        \\n        i = 0\\n        while i<N:\\n            if s[i]==\\'(\\':\\n                lcounter += 1\\n                i += 1\\n            else:\\n                if s[i:i+2]==\\'))\\':\\n                    if lcounter>0:\\n                        lcounter -= 1\\n                        i += 2\\n                    else:\\n                        toadd += 1\\n                        i += 2\\n                else:\\n                    if lcounter>0:\\n                        toadd += 1\\n                        lcounter -= 1\\n                        i += 1\\n                    else:\\n                        toadd += 2\\n                        i += 1\\n        return toadd + lcounter*2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\'\\'\\'\\n        O(n) solution with stack\\n        \\'\\'\\'\\n        N = len(s)\\n        \\n        # traverse the string\\n        toadd = 0\\n        stack = []\\n        i = 0\\n        while i<N:\\n            if s[i]==\\'(\\':\\n                stack.append(s[i])\\n                i += 1\\n            else:\\n                if s[i:i+2]==\\'))\\':\\n                    if len(stack)>0:\\n                        stack.pop()\\n                    else:\\n                        toadd += 1\\n                    i += 2\\n                else:\\n                    if len(stack)>0:\\n                        stack.pop()\\n                        toadd += 1\\n                    else:\\n                        toadd += 2\\n                    i += 1\\n        # check the length of stack\\n        if len(stack)>0:\\n            toadd += len(stack)*2\\n        \\n        return toadd\\n```\n```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\'\\'\\'\\n        O(n) solution without stack\\n        \\'\\'\\'\\n        N = len(s)\\n        # traverse the string\\n        lcounter = 0\\n        toadd = 0\\n        \\n        i = 0\\n        while i<N:\\n            if s[i]==\\'(\\':\\n                lcounter += 1\\n                i += 1\\n            else:\\n                if s[i:i+2]==\\'))\\':\\n                    if lcounter>0:\\n                        lcounter -= 1\\n                        i += 2\\n                    else:\\n                        toadd += 1\\n                        i += 2\\n                else:\\n                    if lcounter>0:\\n                        toadd += 1\\n                        lcounter -= 1\\n                        i += 1\\n                    else:\\n                        toadd += 2\\n                        i += 1\\n        return toadd + lcounter*2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899734,
                "title": "c-easy-to-understand-o-n-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char>st;\\n        int cnt = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            char ch = s[i];\\n            if(ch == \\'(\\'){\\n                st.push(ch);\\n            }else{\\n                if(i+1 < s.size() && s[i+1] == \\')\\'){\\n                    i++;\\n                    if(st.size() == 0){\\n                        cnt++;\\n                    }else{\\n                        st.pop();\\n                    }\\n                }else{\\n                    if(st.size() == 0){\\n                        cnt+=2;\\n                    }else{\\n                        st.pop();\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        cnt += st.size()*2;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char>st;\\n        int cnt = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            char ch = s[i];\\n            if(ch == \\'(\\'){\\n                st.push(ch);\\n            }else{\\n                if(i+1 < s.size() && s[i+1] == \\')\\'){\\n                    i++;\\n                    if(st.size() == 0){\\n                        cnt++;\\n                    }else{\\n                        st.pop();\\n                    }\\n                }else{\\n                    if(st.size() == 0){\\n                        cnt+=2;\\n                    }else{\\n                        st.pop();\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        cnt += st.size()*2;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829421,
                "title": "simplest-solution-one-pass-o-n-time-o-1-space-with-only-1-variable",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n     \\n        int ans=0;\\n        int o=0;  // open brackets not matched till now  \\n            for(int i=0;i<s.size();i++){\\n                if(s[i]==\\'(\\') o++;             // add open bracketa to not matched count\\n                else if(s[i]==\\')\\'){\\n                    if(i+1==s.size() || s[i+1]!=\\')\\')  // look if only 1 closeing bracket encountered, we need 1 more closing bracket\\n                        ans++;\\n                    else i++;  // skip the next closing bracket\\n                    if(o>0) o--;      // their are availbale open brackets\\n                    else ans++;   // open bracket required to be inserted\\n                }\\n            }\\n        return ans+ o*2; //o*2 is the final no of open brackets remaining which needs twice closing braces.\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n     \\n        int ans=0;\\n        int o=0;  // open brackets not matched till now  \\n            for(int i=0;i<s.size();i++){\\n                if(s[i]==\\'(\\') o++;             // add open bracketa to not matched count\\n                else if(s[i]==\\')\\'){\\n                    if(i+1==s.size() || s[i+1]!=\\')\\')  // look if only 1 closeing bracket encountered, we need 1 more closing bracket\\n                        ans++;\\n                    else i++;  // skip the next closing bracket\\n                    if(o>0) o--;      // their are availbale open brackets\\n                    else ans++;   // open bracket required to be inserted\\n                }\\n            }\\n        return ans+ o*2; //o*2 is the final no of open brackets remaining which needs twice closing braces.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805133,
                "title": "simple-o-n-c-solution-without-stack-w-comments",
                "content": "I previously used stack and enum to represent the current stack status and it turned out to be a disaster because there are too many cases that have to take into consider.\\nI then saw the solution from @mohitbhateja and realized that the cases can be classified (and simplied) to only a few cases. Refer to the code and comments below.\\n\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int left_count = 0;\\n        int insertions = 0;\\n        // ) is completely different from ))\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') left_count++;\\n            else {                                      // s[i] == \\')\\'\\n                if (left_count == 0) insertions++;      // need a \\'(\\' for this \\')\\'\\n                else left_count--;                      // consume a \\'(\\' for a \\')\\'\\n                if (i == s.size()-1 || s[i+1] == \\'(\\')\\n                    insertions++;                       // need another contiguous \\')\\'\\n                else i++;                               // made a )), we already checked if \\'(\\' exists before\\n            }\\n        }\\n        return insertions + left_count * 2;             // every \\'(\\' not matched needs two \\')\\' \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int left_count = 0;\\n        int insertions = 0;\\n        // ) is completely different from ))\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') left_count++;\\n            else {                                      // s[i] == \\')\\'\\n                if (left_count == 0) insertions++;      // need a \\'(\\' for this \\')\\'\\n                else left_count--;                      // consume a \\'(\\' for a \\')\\'\\n                if (i == s.size()-1 || s[i+1] == \\'(\\')\\n                    insertions++;                       // need another contiguous \\')\\'\\n                else i++;                               // made a )), we already checked if \\'(\\' exists before\\n            }\\n        }\\n        return insertions + left_count * 2;             // every \\'(\\' not matched needs two \\')\\' \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802715,
                "title": "simple-c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int ans=0;\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(s[i]);\\n            }\\n            else{\\n                if(st.empty()) ans++;\\n                if(i+1>=s.length()) ans++;\\n                if(i+1<s.length() && s[i+1] == \\'(\\') ans++;\\n                else if(i+1<s.length() && s[i+1] == \\')\\') i++;\\n                if(!st.empty())\\n                st.pop();\\n            }\\n        }\\n        return ans += st.size()*2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int ans=0;\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(s[i]);\\n            }\\n            else{\\n                if(st.empty()) ans++;\\n                if(i+1>=s.length()) ans++;\\n                if(i+1<s.length() && s[i+1] == \\'(\\') ans++;\\n                else if(i+1<s.length() && s[i+1] == \\')\\') i++;\\n                if(!st.empty())\\n                st.pop();\\n            }\\n        }\\n        return ans += st.size()*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781543,
                "title": "c-100-faster-fully-explained",
                "content": "What we have done is:  we will use three numbers:(-1,0,1)\\n1. 1 number states that \"))\" substring is present.\\n2. 0 number states that only \")\" substring is present and we need one more \\')\\'.  \\n3. -1 number states that \"(\" is present.\\n4. Last we will have a variable \"count\" wich will store no of insertions.\\n*  If we encounter -1 \"(\", we will push it to the stack.\\n*  If we encounter 0 \")\", this means we need to insert \")\" so we will count++. But we will check if stack is empty, this means we need  to insert \"(\" also and we will again count++ and pop.\\n*  If we encounter 1\"))\", this means pop from the stack [or remove \"(\"].\\n\\nFor eg [\" ( )) ( )\"]:- In this our array will be [-1,1,-1,0].\\narray[0]:First we will push -1 to stack.\\narray[1]:Then we will pop.\\narray[2]:Then we will push -1 to stack.\\narray[3]:Then we will count++ and pop.\\nAnswer is 1.\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        if(s.size()<3)\\n            return 3-s.size();\\n        vector<int> v;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                v.push_back(-1);\\n            else\\n            {\\n                if(i!=s.size()-1)\\n                {if(s[i+1]==\\')\\')\\n                    v.push_back(1),i++;\\n                else\\n                    v.push_back(0);}\\n                else v.push_back(0);\\n                    \\n            }\\n        }\\n        for(auto num:v) cout<<num<<\" \";\\n        int count=0;\\n        stack<int> S;\\n        for(auto num:v)\\n        {\\n            if(num==-1)\\n                S.push(num);\\n            else if(num==0)\\n            {\\n                 if(S.empty())\\n                     count+=2;\\n                else\\n                    count++,S.pop();\\n            } else{\\n                     if(S.empty())\\n                         count++;\\n                      else S.pop();\\n            }   \\n        }\\n        if(!S.empty())\\n            count+=S.size()*2;\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        if(s.size()<3)\\n            return 3-s.size();\\n        vector<int> v;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                v.push_back(-1);\\n            else\\n            {\\n                if(i!=s.size()-1)\\n                {if(s[i+1]==\\')\\')\\n                    v.push_back(1),i++;\\n                else\\n                    v.push_back(0);}",
                "codeTag": "Java"
            },
            {
                "id": 780024,
                "title": "help-needed-confusing-testcase",
                "content": "Can anyone please explain why ```4``` is expected output for this input\\n\\n```\"(()))(()))()())))\"```\\n\\nShouldn\\'t it be just ```1``` ?",
                "solutionTags": [],
                "code": "```4```\n```\"(()))(()))()())))\"```\n```1```",
                "codeTag": "Unknown"
            },
            {
                "id": 779966,
                "title": "java-stack-solution-o-n-one-pass-solution-with-explanation-and-comments",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character>stk=new Stack<>();\\n        int cnt=0;\\n        char c;\\n        for(int i=0;i<s.length();i++){\\n            c=s.charAt(i);\\n            if(c==\\'(\\') // if we get one \\'(\\' we simply insert it into the stack.\\n                stk.push(c);\\n            else{\\n                // if we get a \\')\\',\\n                if(i<s.length()-1&&s.charAt(i+1)==\\')\\'){ // we check if the next(if present) character is also a \\')\\'. \\n                    \\n                    // if stack is empty then one \\'(\\' will be required for the found \\'))\\', else we just matched a \\'(\\' with \\'))\\'.\\n                    if(stk.empty()) \\n                        cnt++;\\n                    else    \\n                        stk.pop();\\n                    \\n                    i++; // since we accessed the next element as well.\\n                }\\n                else{\\n                    // if the next element is not present or the next element is not a \\')\\', then we obviously need a \\')\\'. \\n                    // Then if stack is empty, one \\'(\\' will be required to balance \\'))\\', else we got a \\'(\\' for \\'))\\'.                    \\n                    if(stk.empty()) \\n                        cnt+=2; \\n                    else{\\n                        stk.pop();\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        cnt+=stk.size()*2; // for each remaining \\'(\\', we require two \\'))\\'.\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character>stk=new Stack<>();\\n        int cnt=0;\\n        char c;\\n        for(int i=0;i<s.length();i++){\\n            c=s.charAt(i);\\n            if(c==\\'(\\') // if we get one \\'(\\' we simply insert it into the stack.\\n                stk.push(c);\\n            else{\\n                // if we get a \\')\\',\\n                if(i<s.length()-1&&s.charAt(i+1)==\\')\\'){ // we check if the next(if present) character is also a \\')\\'. \\n                    \\n                    // if stack is empty then one \\'(\\' will be required for the found \\'))\\', else we just matched a \\'(\\' with \\'))\\'.\\n                    if(stk.empty()) \\n                        cnt++;\\n                    else    \\n                        stk.pop();\\n                    \\n                    i++; // since we accessed the next element as well.\\n                }\\n                else{\\n                    // if the next element is not present or the next element is not a \\')\\', then we obviously need a \\')\\'. \\n                    // Then if stack is empty, one \\'(\\' will be required to balance \\'))\\', else we got a \\'(\\' for \\'))\\'.                    \\n                    if(stk.empty()) \\n                        cnt+=2; \\n                    else{\\n                        stk.pop();\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        cnt+=stk.size()*2; // for each remaining \\'(\\', we require two \\'))\\'.\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779954,
                "title": "c-o-n-o-1-intuitive-if-else",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        int c = 0; // ans\\n        int op = 0; // Open Parantheses\\n        for(int i=0;i<n;i++){\\n            char ch = s[i];\\n            if(ch == \\'(\\'){\\n                op++;\\n            }\\n            else{\\n                if(i+1<n && s[i+1]==\\')\\'){\\n                    i++; // two times \\')\\' present for one \\'(\\' move forward\\n                }\\n                else{\\n                    c++; // only one \\')\\' , so insert one more \\')\\'\\n                }\\n                if(op==0){\\n                    c++; // if no corresponding opening para then add one by insertion\\n                }\\n                else op--; // else \\'(\\' has corresponding two \\')\\'\\n            }\\n        }\\n        if(op>0) c+= op*2; // for all \\'(\\' left insert corresponding \\'))\\'\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        int c = 0; // ans\\n        int op = 0; // Open Parantheses\\n        for(int i=0;i<n;i++){\\n            char ch = s[i];\\n            if(ch == \\'(\\'){\\n                op++;\\n            }\\n            else{\\n                if(i+1<n && s[i+1]==\\')\\'){\\n                    i++; // two times \\')\\' present for one \\'(\\' move forward\\n                }\\n                else{\\n                    c++; // only one \\')\\' , so insert one more \\')\\'\\n                }\\n                if(op==0){\\n                    c++; // if no corresponding opening para then add one by insertion\\n                }\\n                else op--; // else \\'(\\' has corresponding two \\')\\'\\n            }\\n        }\\n        if(op>0) c+= op*2; // for all \\'(\\' left insert corresponding \\'))\\'\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321179,
                "title": "java-stack-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf **left bracket we need twice on right**, if **right bracket present we need just half on left**.\\nRefer Commnets, Dry Run for better understanding !! \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n// -Keep adding left barckets\\n            if(s.charAt(i)==\\'(\\'){\\n                stack.push(s.charAt(i));\\n            }else{\\n                if(i+1<s.length()&& s.charAt(i+1)==\\')\\'){\\n                    // -Skip it as two consecutives are present\\n                    i++;\\n                }else count++;\\n                \\n                if(!stack.isEmpty()){\\n                    stack.pop();\\n                }else count++ ;\\n            }\\n        }\\n        count+=2*stack.size();\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n// -Keep adding left barckets\\n            if(s.charAt(i)==\\'(\\'){\\n                stack.push(s.charAt(i));\\n            }else{\\n                if(i+1<s.length()&& s.charAt(i+1)==\\')\\'){\\n                    // -Skip it as two consecutives are present\\n                    i++;\\n                }else count++;\\n                \\n                if(!stack.isEmpty()){\\n                    stack.pop();\\n                }else count++ ;\\n            }\\n        }\\n        count+=2*stack.size();\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295720,
                "title": "java-100-easy-to-understand",
                "content": "\\n\\n# Approach\\nUse stack to store the number of insertions, not the string itself.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        int ans =0;\\n        for(int i =0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\')\\n            {\\n                if(stack.isEmpty() || stack.peek() == 2)\\n                stack.push(2);\\n                else{\\n                    stack.pop();\\n                    stack.push(2);\\n                    ans++;\\n                }\\n            }\\n            else if(ch == \\')\\')\\n            {\\n                if(stack.isEmpty())\\n                {\\n                    stack.push(1);\\n                    ans++;\\n                }\\n                else if (stack.peek()==1)\\n                stack.pop();\\n                else if (stack.peek()==2)\\n                {\\n                    stack.pop();\\n                    stack.push(1);\\n                }\\n            }\\n           \\n        }\\n        while(!stack.isEmpty())\\n        {\\n            ans = ans + stack.peek();\\n            stack.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        int ans =0;\\n        for(int i =0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\')\\n            {\\n                if(stack.isEmpty() || stack.peek() == 2)\\n                stack.push(2);\\n                else{\\n                    stack.pop();\\n                    stack.push(2);\\n                    ans++;\\n                }\\n            }\\n            else if(ch == \\')\\')\\n            {\\n                if(stack.isEmpty())\\n                {\\n                    stack.push(1);\\n                    ans++;\\n                }\\n                else if (stack.peek()==1)\\n                stack.pop();\\n                else if (stack.peek()==2)\\n                {\\n                    stack.pop();\\n                    stack.push(1);\\n                }\\n            }\\n           \\n        }\\n        while(!stack.isEmpty())\\n        {\\n            ans = ans + stack.peek();\\n            stack.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047629,
                "title": "kotlin-stack",
                "content": "# Code\\n```\\nclass Solution {\\n    fun minInsertions(s: String): Int {\\n        var q = ArrayDeque<Char>()\\n        var i = 0\\n        var res = 0\\n        while (true) {\\n            if (i >= s.length) break\\n            var c = s[i]\\n            \\n            if (c == \\')\\') {\\n                if (q.size > 0) q.pop() else res++\\n                if (i < s.length - 1 && s[i + 1] == \\')\\') {\\n                    i += 2\\n                } else {\\n                    res++\\n                    i++\\n                }\\n            } else {\\n                q.push(c)\\n                i++\\n            }\\n        }\\n        if (q.size != 0) res += 2 * q.size\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    fun minInsertions(s: String): Int {\\n        var q = ArrayDeque<Char>()\\n        var i = 0\\n        var res = 0\\n        while (true) {\\n            if (i >= s.length) break\\n            var c = s[i]\\n            \\n            if (c == \\')\\') {\\n                if (q.size > 0) q.pop() else res++\\n                if (i < s.length - 1 && s[i + 1] == \\')\\') {\\n                    i += 2\\n                } else {\\n                    res++\\n                    i++\\n                }\\n            } else {\\n                q.push(c)\\n                i++\\n            }\\n        }\\n        if (q.size != 0) res += 2 * q.size\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686697,
                "title": "python-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhile seeing parentheses problem, using stack is my intuition.\\nres: record the number of times making insertion\\nidx: pointer on s\\nstk: store left parenthese\\n\\nIn this case, if we meet \\'(\\', just append left parenthese into stack.\\nIf we meet one \\')\\', there is three cases:\\n1. nothing in stack. So we need to insert one left parenthese into stack, in order to match right parenthese. So res += 1\\n2. \\'(\\' in stack, also, the next char in s is also a \\')\\'. Thus, now we have a valid right parenthese. We just need to update the index pointer, and pop the topmost left paren from stack\\n3. \\'(\\' in stack, also, the next char in s is not a \\')\\'. So we need to add one more \\')\\' to construct a valid right parenthese. After adding right paren, now we can pop left paren from stack\\n\\nwhy res += len(stk) * 2?\\nAfter traversing s completely, if there are remaining left parentheses, it means there are left parenthese having no matching right parenthese. So we have to add len(stk) * 2 to res.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        stk = list()\\n        res = 0\\n        idx = 0\\n        while (idx < len(s)):\\n            c = s[idx]\\n            if (c == \\'(\\'):\\n                stk.append(c)\\n            else: # \\u5982\\u679C\\u662Fright paren\\n                # Fill in left parenthesis\\n                if (not stk): # \\u5982\\u679C\\u6CA1\\u6709left paren\\u5728stack\\n                    res += 1 \\n                    stk.append(\\'(\\')\\n                \\n                # Paired right parenthesis.\\n                if (idx < len(s) - 1 and s[idx + 1] == \\')\\'):\\n                    idx += 1\\n                    stk.pop()\\n                \\n                # Unpaired right parenthesis.\\n                else:\\n                    res += 1\\n                    stk.pop()\\n            \\n            idx += 1\\n        \\n        # Calculate unpaired left parenthesis.\\n        res += len(stk) * 2\\n        return res\\n        \\n        # # res \\u8BB0\\u5F55\\u63D2\\u5165\\u6B21\\u6570\\n        # # need \\u53D8\\u91CF\\u8BB0\\u5F55\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u91CF\\n        # need, res = 0, 0\\n\\n        # for i in range(len(s)):\\n        #     if s[i] == \\'(\\':\\n        #         need += 2\\n        #         # \\u5F53\\u9047\\u5230\\u5DE6\\u62EC\\u53F7\\u65F6\\uFF0C\\u82E5\\u5BF9\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u91CF\\u4E3A\\u5947\\u6570\\uFF0C\\u9700\\u8981\\u63D2\\u5165 1 \\u4E2A\\u53F3\\u62EC\\u53F7\\u3002\\n        #         # \\u56E0\\u4E3A\\u4E00\\u4E2A\\u5DE6\\u62EC\\u53F7\\u9700\\u8981\\u4E24\\u4E2A\\u53F3\\u62EC\\u53F7\\u561B\\uFF0C\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u5FC5\\u987B\\u662F\\u5076\\u6570\\n        #         if need %2 == 1:\\n        #             # \\u63D2\\u5165\\u4E00\\u4E2A\\u53F3\\u62EC\\u53F7\\n        #             res += 1\\n        #             # \\u5BF9\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u51CF\\u4E00\\n        #             need -= 1\\n\\n        #     elif s[i] == \\')\\':\\n        #         need -= 1\\n        #         # \\u8BF4\\u660E\\u53F3\\u62EC\\u53F7\\u592A\\u591A\\u4E86\\n        #         if need == -1:\\n        #             # \\u9700\\u8981\\u63D2\\u5165\\u4E00\\u4E2A\\u5DE6\\u62EC\\u53F7\\n        #             res += 1\\n        #             # \\u540C\\u65F6\\uFF0C\\u5BF9\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u53D8\\u4E3A 1\\n        #             # -1 -> 1 # \\u76F8\\u5F53\\u4E8E\\u662Fadd 2 to need\\n        #             need = 1\\n        # return need + res\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        stk = list()\\n        res = 0\\n        idx = 0\\n        while (idx < len(s)):\\n            c = s[idx]\\n            if (c == \\'(\\'):\\n                stk.append(c)\\n            else: # \\u5982\\u679C\\u662Fright paren\\n                # Fill in left parenthesis\\n                if (not stk): # \\u5982\\u679C\\u6CA1\\u6709left paren\\u5728stack\\n                    res += 1 \\n                    stk.append(\\'(\\')\\n                \\n                # Paired right parenthesis.\\n                if (idx < len(s) - 1 and s[idx + 1] == \\')\\'):\\n                    idx += 1\\n                    stk.pop()\\n                \\n                # Unpaired right parenthesis.\\n                else:\\n                    res += 1\\n                    stk.pop()\\n            \\n            idx += 1\\n        \\n        # Calculate unpaired left parenthesis.\\n        res += len(stk) * 2\\n        return res\\n        \\n        # # res \\u8BB0\\u5F55\\u63D2\\u5165\\u6B21\\u6570\\n        # # need \\u53D8\\u91CF\\u8BB0\\u5F55\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u91CF\\n        # need, res = 0, 0\\n\\n        # for i in range(len(s)):\\n        #     if s[i] == \\'(\\':\\n        #         need += 2\\n        #         # \\u5F53\\u9047\\u5230\\u5DE6\\u62EC\\u53F7\\u65F6\\uFF0C\\u82E5\\u5BF9\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u91CF\\u4E3A\\u5947\\u6570\\uFF0C\\u9700\\u8981\\u63D2\\u5165 1 \\u4E2A\\u53F3\\u62EC\\u53F7\\u3002\\n        #         # \\u56E0\\u4E3A\\u4E00\\u4E2A\\u5DE6\\u62EC\\u53F7\\u9700\\u8981\\u4E24\\u4E2A\\u53F3\\u62EC\\u53F7\\u561B\\uFF0C\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u5FC5\\u987B\\u662F\\u5076\\u6570\\n        #         if need %2 == 1:\\n        #             # \\u63D2\\u5165\\u4E00\\u4E2A\\u53F3\\u62EC\\u53F7\\n        #             res += 1\\n        #             # \\u5BF9\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u51CF\\u4E00\\n        #             need -= 1\\n\\n        #     elif s[i] == \\')\\':\\n        #         need -= 1\\n        #         # \\u8BF4\\u660E\\u53F3\\u62EC\\u53F7\\u592A\\u591A\\u4E86\\n        #         if need == -1:\\n        #             # \\u9700\\u8981\\u63D2\\u5165\\u4E00\\u4E2A\\u5DE6\\u62EC\\u53F7\\n        #             res += 1\\n        #             # \\u540C\\u65F6\\uFF0C\\u5BF9\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u53D8\\u4E3A 1\\n        #             # -1 -> 1 # \\u76F8\\u5F53\\u4E8E\\u662Fadd 2 to need\\n        #             need = 1\\n        # return need + res\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303596,
                "title": "c-easy-to-understand-stack-single-pass-o-n",
                "content": "class Solution {\\npublic:\\n\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        int ans=0;\\n        stack<char>st;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'(\\')\\n                st.push(s[i]);\\n            else{\\n                 if(st.size()>0){\\n                     if(i+1<n && ( s[i] == \\')\\' && s[i+1] == \\')\\' ) ){\\n                     st.pop();\\n                     i++;   \\n                     }\\n                     else{\\n                         st.pop();\\n                         ans++;\\n                     }\\n                     \\n                 }\\n                 else if(i+1<n && ( s[i] == \\')\\' && s[i+1] == \\')\\' ))\\n                 {\\n                     ans++;\\n                     i++;\\n                 }\\n                 else\\n                 {\\n                   ans+=2;    \\n                 }\\n            }\\n        }\\n        while(st.size()){\\n            st.pop();\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        int ans=0;\\n        stack<char>st;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'(\\')\\n                st.push(s[i]);\\n            else{\\n                 if(st.size()>0){\\n                     if(i+1<n && ( s[i] == \\')\\' && s[i+1] == \\')\\' ) ){\\n                     st.pop();\\n                     i++;   \\n                     }",
                "codeTag": "Java"
            },
            {
                "id": 2255977,
                "title": "c-o-n-one-pass-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s1) {\\n        stack<char> s; \\n        int ans = 0; \\n        for(int x = 0; x<s1.length(); x++){\\n            if(s1[x]==\\'(\\')\\n                s.push(s1[x]);\\n            else{\\n                if(x+1<s1.length()){\\n                    if(s1[x+1]==\\')\\')\\n                        x++;\\n                    else{\\n                      ans++;  \\n                    }\\n                }\\n                else\\n                    ans++;\\n                if(!s.empty())\\n                    s.pop();\\n                else\\n                    ans++;\\n            }     \\n        }\\n        return ans + s.size()*2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s1) {\\n        stack<char> s; \\n        int ans = 0; \\n        for(int x = 0; x<s1.length(); x++){\\n            if(s1[x]==\\'(\\')\\n                s.push(s1[x]);\\n            else{\\n                if(x+1<s1.length()){\\n                    if(s1[x+1]==\\')\\')\\n                        x++;\\n                    else{\\n                      ans++;  \\n                    }\\n                }\\n                else\\n                    ans++;\\n                if(!s.empty())\\n                    s.pop();\\n                else\\n                    ans++;\\n            }     \\n        }\\n        return ans + s.size()*2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218237,
                "title": "simplest-java-solution-2-pass",
                "content": "```\\n/**\\nNot the fastest but arguably simplest. Replacing )) with ] reduces this problem to a simpler balancing problem\\n**/\\n\\nclass Solution {\\n    public int minInsertions(String s) {\\n        s = s.replace(\"))\", \"]\");\\n        System.out.print(s);\\n        int count = 0, leftCount =0;\\n        for (int i = 0; i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\') leftCount++;\\n            else{\\n                if (leftCount > 0) {\\n                    leftCount--;\\n                    count += ch == \\']\\' ? 0 : 1;\\n                }\\n                else count += ch == \\']\\' ? 1 : 2;\\n            }\\n        }\\n        return count+leftCount*2;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minInsertions(String s) {\\n        s = s.replace(\"))\", \"]\");\\n        System.out.print(s);\\n        int count = 0, leftCount =0;\\n        for (int i = 0; i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\') leftCount++;\\n            else{\\n                if (leftCount > 0) {\\n                    leftCount--;\\n                    count += ch == \\']\\' ? 0 : 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2215666,
                "title": "python-solution-with-explantions",
                "content": "\\'\\'\\'\\n\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        #res: # of extra insertion to balance \\n        # need: # of needed right parenthesis\\n        \\n        res, need  = 0,0\\n        \\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                need += 2\\n                \\n                # (( ))) need = 4 -3 = 1\\n                \\n                if need % 2 == 1:\\n                    \\n                    # need another ) insertion to balance \\n                    res += 1 \\n                    \\n                    # need for ) decrease by 1 \\n                    need -= 1 \\n            if s[i] == \\')\\':\\n                \\n                need -= 1\\n                if need == -1:\\n                    res +=1 \\n                    need = 1\\n\\n        return res + need \\n\\'\\'\\'\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\n\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        #res: # of extra insertion to balance \\n        # need: # of needed right parenthesis\\n        \\n        res, need  = 0,0\\n        \\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                need += 2\\n                \\n                # (( ))) need = 4 -3 = 1\\n                \\n                if need % 2 == 1:\\n                    \\n                    # need another ) insertion to balance \\n                    res += 1 \\n                    \\n                    # need for ) decrease by 1 \\n                    need -= 1 \\n            if s[i] == \\')\\':\\n                \\n                need -= 1\\n                if need == -1:\\n                    res +=1 \\n                    need = 1\\n\\n        return res + need \\n\\'\\'\\'\\n",
                "codeTag": "Java"
            },
            {
                "id": 2084857,
                "title": "c-easy-to-understand-simple-code-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int x=0,n=s.length();\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                v.push_back(1);\\n            }\\n            else if(i<n-1&&s[i]==\\')\\'&&s[i+1]==\\')\\')\\n            {\\n                v.push_back(2);\\n                i++;\\n            }\\n            else\\n            {\\n                v.push_back(2);\\n                x++;\\n            }\\n        }\\n        stack<int> st;\\n        n=v.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!st.empty()&&st.top()==1&&v[i]==2)\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                st.push(v[i]);\\n            }\\n        }\\n        int count=0;\\n        n=st.size();\\n        while(!st.empty())\\n        {\\n            if(st.top()==1)\\n            count++;\\n            st.pop();\\n        }\\n        return x+2*count+(n-count);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int x=0,n=s.length();\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                v.push_back(1);\\n            }\\n            else if(i<n-1&&s[i]==\\')\\'&&s[i+1]==\\')\\')\\n            {\\n                v.push_back(2);\\n                i++;\\n            }\\n            else\\n            {\\n                v.push_back(2);\\n                x++;\\n            }\\n        }\\n        stack<int> st;\\n        n=v.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!st.empty()&&st.top()==1&&v[i]==2)\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                st.push(v[i]);\\n            }\\n        }\\n        int count=0;\\n        n=st.size();\\n        while(!st.empty())\\n        {\\n            if(st.top()==1)\\n            count++;\\n            st.pop();\\n        }\\n        return x+2*count+(n-count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848462,
                "title": "simplest-solution-easiest-to-understand",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        \\n        char[] ar= s.toCharArray();\\n        Stack<Character> stack= new Stack<>();\\n        int insertions=0;\\n        \\n        for(int i=0;i<ar.length;i++)\\n        {\\n            char ch= ar[i];\\n            \\n            if(ch==\\'(\\')\\n            {\\n                if(stack.isEmpty())\\n                    stack.push(ch);\\n                else if(stack.peek()==\\'(\\')\\n                    stack.push(ch);\\n                else if(stack.peek()==\\')\\')\\n                {\\n                    insertions++;\\n                    stack.pop();\\n                    stack.pop();\\n                    stack.push(ch);\\n                }\\n            }\\n            else\\n            {\\n                if(stack.isEmpty())\\n                {\\n                    insertions++;\\n                    stack.push(\\'(\\');\\n                    stack.push(ch);\\n                }\\n                else if(stack.peek()==\\'(\\')\\n                    stack.push(ch);\\n                else if(stack.peek()==\\')\\')\\n                {\\n                    stack.pop();\\n                    stack.pop();\\n                }\\n            }\\n        }\\n        \\n        while(!stack.isEmpty())\\n        {\\n            if(stack.pop()==\\'(\\')\\n                insertions = insertions+2;\\n            else\\n            {\\n                insertions++;\\n                stack.pop();\\n            }\\n        }\\n        \\n        return insertions;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        \\n        char[] ar= s.toCharArray();\\n        Stack<Character> stack= new Stack<>();\\n        int insertions=0;\\n        \\n        for(int i=0;i<ar.length;i++)\\n        {\\n            char ch= ar[i];\\n            \\n            if(ch==\\'(\\')\\n            {\\n                if(stack.isEmpty())\\n                    stack.push(ch);\\n                else if(stack.peek()==\\'(\\')\\n                    stack.push(ch);\\n                else if(stack.peek()==\\')\\')\\n                {\\n                    insertions++;\\n                    stack.pop();\\n                    stack.pop();\\n                    stack.push(ch);\\n                }\\n            }\\n            else\\n            {\\n                if(stack.isEmpty())\\n                {\\n                    insertions++;\\n                    stack.push(\\'(\\');\\n                    stack.push(ch);\\n                }\\n                else if(stack.peek()==\\'(\\')\\n                    stack.push(ch);\\n                else if(stack.peek()==\\')\\')\\n                {\\n                    stack.pop();\\n                    stack.pop();\\n                }\\n            }\\n        }\\n        \\n        while(!stack.isEmpty())\\n        {\\n            if(stack.pop()==\\'(\\')\\n                insertions = insertions+2;\\n            else\\n            {\\n                insertions++;\\n                stack.pop();\\n            }\\n        }\\n        \\n        return insertions;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772757,
                "title": "c-stack-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        int count = 0;\\n        stack<char>S;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!S.empty())\\n            {\\n                if(s[i] == \\'(\\')\\n                    S.push(\\'(\\');\\n                else\\n                {\\n                    if(i < n - 1 and s[i + 1] == \\')\\')\\n                    {\\n                        S.pop();\\n                        i++;\\n                    }\\n                    else\\n                    {\\n                        S.pop();\\n                        count++;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                 if(s[i] == \\'(\\')\\n                    S.push(\\'(\\');\\n                 else\\n                 {\\n                     count++;\\n                    if( !(i < n - 1 and s[i + 1] == \\')\\') )\\n                    {\\n                        count++;\\n                    }\\n                    else\\n                        i++;\\n                 }\\n            }\\n        }\\n        if(!S.empty())\\n            count += (S.size() * 2);\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        int count = 0;\\n        stack<char>S;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!S.empty())\\n            {\\n                if(s[i] == \\'(\\')\\n                    S.push(\\'(\\');\\n                else\\n                {\\n                    if(i < n - 1 and s[i + 1] == \\')\\')\\n                    {\\n                        S.pop();\\n                        i++;\\n                    }\\n                    else\\n                    {\\n                        S.pop();\\n                        count++;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                 if(s[i] == \\'(\\')\\n                    S.push(\\'(\\');\\n                 else\\n                 {\\n                     count++;\\n                    if( !(i < n - 1 and s[i + 1] == \\')\\') )\\n                    {\\n                        count++;\\n                    }\\n                    else\\n                        i++;\\n                 }\\n            }\\n        }\\n        if(!S.empty())\\n            count += (S.size() * 2);\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694649,
                "title": "c-using-stack-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        \\n        stack<char>st;\\n        int ans=0;\\n        \\n        for(char c: s){\\n            if(c==\\'(\\'){\\n                if(st.empty())\\n                    st.push(\\'(\\');\\n                else if(st.top()==\\'(\\')\\n                    st.push(\\'(\\');\\n                else if(st.top()==\\')\\'){\\n                    st.pop();\\n                    st.pop();\\n                    ans++;\\n                    st.push(\\'(\\');\\n                }\\n            }\\n            \\n            if(c==\\')\\'){\\n                if(st.empty()){\\n                    st.push(\\'(\\');\\n                    st.push(c);\\n                    ans++;\\n                }\\n                \\n                else if(st.top()==\\')\\'){\\n                    st.pop();\\n                    st.pop();\\n                }\\n                \\n                else if(st.top()==\\'(\\')\\n                    st.push(c);\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            if(st.top()==\\'(\\'){\\n                ans+=2;\\n                st.pop();\\n            }\\n                \\n            else if(st.top()==\\')\\'){\\n                ans++;\\n                st.pop();\\n                st.pop();\\n            }\\n                \\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        \\n        stack<char>st;\\n        int ans=0;\\n        \\n        for(char c: s){\\n            if(c==\\'(\\'){\\n                if(st.empty())\\n                    st.push(\\'(\\');\\n                else if(st.top()==\\'(\\')\\n                    st.push(\\'(\\');\\n                else if(st.top()==\\')\\'){\\n                    st.pop();\\n                    st.pop();\\n                    ans++;\\n                    st.push(\\'(\\');\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1687981,
                "title": "java-o-1-space-solution",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n=s.length();\\n        int ans=0,open=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            char c=s.charAt(i);\\n            if(c==\\'(\\')\\n            {\\n                ++open;\\n            }\\n            else\\n            {\\n                if(i+1<n&&s.charAt(i+1)==\\')\\')\\n                {\\n                    if(open==0)\\n                    {\\n                        ++ans;\\n                    }\\n                    else\\n                    {\\n                        --open;\\n                    }\\n                    ++i;\\n                }\\n                else\\n                {\\n                    if(open==0)\\n                    {\\n                        ans+=2;\\n                    }\\n                    else\\n                    {\\n                        ++ans;\\n                        --open;\\n                    }\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        return ans+2*open;\\n        \\n        \\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minInsertions(String s) {\\n        int n=s.length();\\n        int ans=0,open=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            char c=s.charAt(i);\\n            if(c==\\'(\\')\\n            {\\n                ++open;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1621255,
                "title": "c-easy-to-understand-stack-solution",
                "content": "# class Solution {\\n# public:\\n    int minInsertions(string s) {\\n        int n=s.size(),ans=0;\\n        stack<char> st;\\n        for(int i=0; i<n;){\\n            cout<<i<<endl;\\n            if(s[i]==\\'(\\'){\\n                st.push(s[i]); i++;\\n            }\\n            else{\\n                if(i+1<n){\\n                    if(s[i+1]==\\')\\'){\\n                        if(st.size()>0){st.pop(); i+=2;}\\n                        else{ans++; i+=2;}\\n                    }\\n                    else{\\n                        if(st.size()>0){\\n                            st.pop(); ans++; i++;\\n                        }\\n                        else{\\n                            ans+=2; i++;\\n                        }\\n                    }\\n                }\\n                else{\\n                    if(st.size()>0){\\n                        st.pop(); ans++;\\n                        break;\\n                    }\\n                    else{\\n                        ans+=2; break;\\n                    }\\n                }\\n            }\\n        }\\n        if(st.size()>0){\\n            ans+=st.size()*2;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n# public:\\n    int minInsertions(string s) {\\n        int n=s.size(),ans=0;\\n        stack<char> st;\\n        for(int i=0; i<n;){\\n            cout<<i<<endl;\\n            if(s[i]==\\'(\\'){\\n                st.push(s[i]); i++;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 1597083,
                "title": "java-count-parenthesis-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int ans = 0;\\n        int cnt = 0;\\n        for(char c: s.toCharArray())\\n        {\\n            if(c==\\'(\\')\\n            {\\n                cnt+=2;\\n                if(cnt%2==1)\\n                {\\n                    ans++;\\n                    cnt--;\\n                }\\n            }\\n            else\\n            {\\n                cnt--;\\n                if(cnt < 0)\\n                {\\n                    cnt+=2;\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans + cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int ans = 0;\\n        int cnt = 0;\\n        for(char c: s.toCharArray())\\n        {\\n            if(c==\\'(\\')\\n            {\\n                cnt+=2;\\n                if(cnt%2==1)\\n                {\\n                    ans++;\\n                    cnt--;\\n                }\\n            }\\n            else\\n            {\\n                cnt--;\\n                if(cnt < 0)\\n                {\\n                    cnt+=2;\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans + cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582020,
                "title": "python-o-n-time-o-n-space-solution-stack",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        strlen=len(s)\\n        i=0\\n        answer=0\\n        stack=[]\\n        \\n        while i<strlen:\\n            \\n            if s[i]==\\'(\\':stack.append(\\'(\\')\\n                \\n            else:\\n                if i+1<strlen and s[i+1]==\\')\\':\\n                    if len(stack)>0:stack.pop()\\n                    # going to need an opening brace\\n                    else:answer+=1\\n                    i+=1\\n                else:\\n                    answer+=1 # going to need a closing brace\\n                    if len(stack)>0:stack.pop()\\n                    # going to need an opening brace\\n                    else: answer+=1\\n            i+=1\\n                    \\n                \\n        while len(stack)>0:\\n            answer+=2\\n            stack.pop(-1)\\n            \\n        return answer\\n                \\n                \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        strlen=len(s)\\n        i=0\\n        answer=0\\n        stack=[]\\n        \\n        while i<strlen:\\n            \\n            if s[i]==\\'(\\':stack.append(\\'(\\')\\n                \\n            else:\\n                if i+1<strlen and s[i+1]==\\')\\':\\n                    if len(stack)>0:stack.pop()\\n                    # going to need an opening brace\\n                    else:answer+=1\\n                    i+=1\\n                else:\\n                    answer+=1 # going to need a closing brace\\n                    if len(stack)>0:stack.pop()\\n                    # going to need an opening brace\\n                    else: answer+=1\\n            i+=1\\n                    \\n                \\n        while len(stack)>0:\\n            answer+=2\\n            stack.pop(-1)\\n            \\n        return answer\\n                \\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 1552910,
                "title": "c-28ms-98-3-line-math",
                "content": "Runtime: 28 ms, faster than 97.91% of C++ online submissions for Minimum Insertions to Balance a Parentheses String.\\nMemory Usage: 12.3 MB, less than 93.09% of C++ online submissions for Minimum Insertions to Balance a Parentheses String.\\n```\\nclass Solution {\\npublic:\\n  int minInsertions(string s) {\\n    int n = 0, answer = 0;\\n    for(auto &ch: s) ch == \\'(\\' ? (n&1 ? n++, answer++ : n += 2) : (n == 0 ? n++, answer++ : n--); \\n    return answer + n;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int minInsertions(string s) {\\n    int n = 0, answer = 0;\\n    for(auto &ch: s) ch == \\'(\\' ? (n&1 ? n++, answer++ : n += 2) : (n == 0 ? n++, answer++ : n--); \\n    return answer + n;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543379,
                "title": "o-n-time-and-o-1-space-solution-10-line-of-code-simple-cake-walk-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int open=0,close=0;\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\') open++;\\n            else if(s[i]==\\')\\')\\n            {\\n                if(i+1<s.size() and s[i+1]==\\')\\')\\n                {\\n                    if(open>0) open--;  // it become cancel with each other.\\n                    else\\n                        ans++;  // for one open bracket\\n                    i++;\\n                }\\n                else\\n                {\\n                    // Example -> (  ) , if open is there then need only for one close bracket\\n                    if(open>0)\\n                    {\\n                        open--;\\n                        ans++;\\n                    }\\n                    else\\n                        ans+=2;  //Example -> ), it means need 1 for open & 1 for close bracket.\\n                }\\n            }\\n            \\n        }\\n        \\n        ans+=open*2; // it means at the if some ((( left then we need 2 close for each open\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int open=0,close=0;\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\') open++;\\n            else if(s[i]==\\')\\')\\n            {\\n                if(i+1<s.size() and s[i+1]==\\')\\')\\n                {\\n                    if(open>0) open--;  // it become cancel with each other.\\n                    else\\n                        ans++;  // for one open bracket\\n                    i++;\\n                }\\n                else\\n                {\\n                    // Example -> (  ) , if open is there then need only for one close bracket\\n                    if(open>0)\\n                    {\\n                        open--;\\n                        ans++;\\n                    }\\n                    else\\n                        ans+=2;  //Example -> ), it means need 1 for open & 1 for close bracket.\\n                }\\n            }\\n            \\n        }\\n        \\n        ans+=open*2; // it means at the if some ((( left then we need 2 close for each open\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535577,
                "title": "python-beat-100-time-complexity-with-comments-o-n-tc-and-o-1-sc",
                "content": "```class Solution:\\n    ### similar to https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/\\n    def minInsertions(self, s: str) -> int:\\n        bal=0\\n        ans=0\\n        s = s.replace(\"))\",\"}\")\\n        for c in s:\\n            if c ==\"(\":\\n                bal+=1\\n            elif c == \"}\":\\n                if bal == 0: ans+=1\\n                else:   bal-=1\\n            else: #####c == \\')\\'\\n                if bal == 0: ##it should be ()) wesaw 1 close we need 1 open and another close\\n                    ans+=2\\n                else:  #####() \\n                    bal-=1\\n                    ans+=1   ##()) we saw () so we need one close so ans+=1 and we saw one open so bal-=1\\n        return ans+bal*2",
                "solutionTags": [],
                "code": "class Solution:\\n    ### similar to https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/\\n    def minInsertions(self, s: str) -> int:\\n        bal=0\\n        ans=0\\n        s = s.replace(\"))\",\"}",
                "codeTag": "Java"
            },
            {
                "id": 1531211,
                "title": "c-simple-one-pass-solution-explained-using-comments-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int i = 0; // Index to iterate the string\\n        int counter = 0; // Count the number of open brackets for which we are to find corresponding closing brackets\\n        int ans = 0; // Number of insertions made till end of string\\n        \\n        while (i < s.size()) { // Iterate over the string\\n            if (s[i] == \\'(\\') { // If there is an open bracket, we increase the counter and move forward by 1\\n                counter++;\\n                i++;\\n            } else if (s[i] == \\')\\') {\\n\\t\\t\\t\\t// If it is a closing bracket, there are two possibilities:\\n\\t\\t\\t\\t// 1. It is followed by another closing bracket\\n\\t\\t\\t\\t// 2. It is followed by another open bracket.\\n                if (i + 1 < s.size()) {\\n\\t\\t\\t\\t\\t// Check if we are not crossing string length\\n                    if (s[i + 1] != \\')\\') {\\n\\t\\t\\t\\t\\t// Case 2: If there is no closing bracket, then we insert 1 closing bracket for completion,\\n\\t\\t\\t\\t\\t// increase answer by 1 and move\\n                        ans++;\\n                        i++;\\n                    } else {\\n\\t\\t\\t\\t\\t\\t// Case 1: If there is a closing bracket, then we jump 2 indexes and repeat\\n                        i += 2;\\n                    }\\n                    // In either case, we complete a closing double brackets,\\n\\t\\t\\t\\t\\t// so we decrease counter by 1 as we have completed it.\\n\\t\\t\\t\\t\\tcounter--; \\n                } else {\\n\\t\\t\\t\\t\\t// If i was the last index, we don\\'t have anything following it,\\n\\t\\t\\t\\t\\t// so we need to add another closing bracket to make a pair,\\n\\t\\t\\t\\t\\t// decrease counter by 1 and increase ans by 1\\n                    counter--;\\n                    ans++;\\n                    i++;\\n                }\\n            }\\n            \\n            if (counter == -1) {\\n\\t\\t\\t\\t// If at any point, the counter equals -1, this means that closing brackets are more than opening brackets,\\n\\t\\t\\t\\t// so we increase counter by 1 ie, it becomes equal to 0 and\\n\\t\\t\\t\\t// increase ans by 1 because we add an opening bracket for the lonely closing brackets.\\n                ans++;\\n                counter = 0;\\n            }\\n        }\\n        // Why we add 2 * counter to final ans?\\n\\t\\t// There can be a case where we have more opening brackets than closing brackets.\\n\\t\\t// We would need to add 2 closing brackets for every opening bracket.\\n\\t\\t// So we add 2 * counter to the ans.\\n        return ans + 2 * counter;\\n    }\\n};\\n// fin.\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int i = 0; // Index to iterate the string\\n        int counter = 0; // Count the number of open brackets for which we are to find corresponding closing brackets\\n        int ans = 0; // Number of insertions made till end of string\\n        \\n        while (i < s.size()) { // Iterate over the string\\n            if (s[i] == \\'(\\') { // If there is an open bracket, we increase the counter and move forward by 1\\n                counter++;\\n                i++;\\n            } else if (s[i] == \\')\\') {\\n\\t\\t\\t\\t// If it is a closing bracket, there are two possibilities:\\n\\t\\t\\t\\t// 1. It is followed by another closing bracket\\n\\t\\t\\t\\t// 2. It is followed by another open bracket.\\n                if (i + 1 < s.size()) {\\n\\t\\t\\t\\t\\t// Check if we are not crossing string length\\n                    if (s[i + 1] != \\')\\') {\\n\\t\\t\\t\\t\\t// Case 2: If there is no closing bracket, then we insert 1 closing bracket for completion,\\n\\t\\t\\t\\t\\t// increase answer by 1 and move\\n                        ans++;\\n                        i++;\\n                    } else {\\n\\t\\t\\t\\t\\t\\t// Case 1: If there is a closing bracket, then we jump 2 indexes and repeat\\n                        i += 2;\\n                    }\\n                    // In either case, we complete a closing double brackets,\\n\\t\\t\\t\\t\\t// so we decrease counter by 1 as we have completed it.\\n\\t\\t\\t\\t\\tcounter--; \\n                } else {\\n\\t\\t\\t\\t\\t// If i was the last index, we don\\'t have anything following it,\\n\\t\\t\\t\\t\\t// so we need to add another closing bracket to make a pair,\\n\\t\\t\\t\\t\\t// decrease counter by 1 and increase ans by 1\\n                    counter--;\\n                    ans++;\\n                    i++;\\n                }\\n            }\\n            \\n            if (counter == -1) {\\n\\t\\t\\t\\t// If at any point, the counter equals -1, this means that closing brackets are more than opening brackets,\\n\\t\\t\\t\\t// so we increase counter by 1 ie, it becomes equal to 0 and\\n\\t\\t\\t\\t// increase ans by 1 because we add an opening bracket for the lonely closing brackets.\\n                ans++;\\n                counter = 0;\\n            }\\n        }\\n        // Why we add 2 * counter to final ans?\\n\\t\\t// There can be a case where we have more opening brackets than closing brackets.\\n\\t\\t// We would need to add 2 closing brackets for every opening bracket.\\n\\t\\t// So we add 2 * counter to the ans.\\n        return ans + 2 * counter;\\n    }\\n};\\n// fin.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523232,
                "title": "python-straight-forward-one-pass-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        # Keep track of how many closing brackets we need as we iterate through s.\\n        # These are the invalid states where we need to insert brackets:\\n        # 1. Odd number of closing brackets required. Requires inserting 1 more close bracket.\\n        # 2. Negative number of closing brackets required (i.e excess closing brackets). Requires inserting 1 more close bracket if odd. Insert (closing brackets required // 2) opening brackets\\n        # Handle excess close required brackets at the end of s as well.\\n        \\n        closeRequired = 0\\n        count = 0\\n        a  = 0\\n        \\n        while a < len(s):\\n            if s[a] == \"(\":\\n                closeRequired += 2\\n                a += 1\\n            else:\\n                while a < len(s) and s[a] == \\')\\':\\n                    closeRequired -= 1\\n                    a += 1\\n                                    \\n                # 1. Positive closeRequired\\n                # Even closeRequired -> do nothing\\n                # Odd closeRequired -> insert 1 more close bracket, subtract 2 closeRequired -> insert = 1\\n                \\n                # 2. Negative closeRequired \\n                # Even closeRequired -> Add closeRequired // 2 open brackets -> closeRequired = 0\\n                # Odd closeRequired -> Add 1 extra closeRequired and insert [closeRequired //2] open brackets -> closeRequired = 0\\n                \\n                if closeRequired > 0:\\n                    if closeRequired % 2 == 0:\\n                        continue\\n                    closeRequired -= 1\\n                    count += 1\\n                else:\\n                    if abs(closeRequired) % 2 == 1:\\n                        closeRequired -= 1\\n                        count += 1\\n                        \\n                    count += abs(closeRequired) // 2\\n                    closeRequired = 0\\n        \\n        return count + closeRequired\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        # Keep track of how many closing brackets we need as we iterate through s.\\n        # These are the invalid states where we need to insert brackets:\\n        # 1. Odd number of closing brackets required. Requires inserting 1 more close bracket.\\n        # 2. Negative number of closing brackets required (i.e excess closing brackets). Requires inserting 1 more close bracket if odd. Insert (closing brackets required // 2) opening brackets\\n        # Handle excess close required brackets at the end of s as well.\\n        \\n        closeRequired = 0\\n        count = 0\\n        a  = 0\\n        \\n        while a < len(s):\\n            if s[a] == \"(\":\\n                closeRequired += 2\\n                a += 1\\n            else:\\n                while a < len(s) and s[a] == \\')\\':\\n                    closeRequired -= 1\\n                    a += 1\\n                                    \\n                # 1. Positive closeRequired\\n                # Even closeRequired -> do nothing\\n                # Odd closeRequired -> insert 1 more close bracket, subtract 2 closeRequired -> insert = 1\\n                \\n                # 2. Negative closeRequired \\n                # Even closeRequired -> Add closeRequired // 2 open brackets -> closeRequired = 0\\n                # Odd closeRequired -> Add 1 extra closeRequired and insert [closeRequired //2] open brackets -> closeRequired = 0\\n                \\n                if closeRequired > 0:\\n                    if closeRequired % 2 == 0:\\n                        continue\\n                    closeRequired -= 1\\n                    count += 1\\n                else:\\n                    if abs(closeRequired) % 2 == 1:\\n                        closeRequired -= 1\\n                        count += 1\\n                        \\n                    count += abs(closeRequired) // 2\\n                    closeRequired = 0\\n        \\n        return count + closeRequired\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434641,
                "title": "c-easiest-time-o-n-space-o-1",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int res = 0, open = 0, n = s.size(), i = 0; \\n        \\n        while(i<n){\\n            if(s[i] == \\'(\\') open ++, i++; \\n            else if(open>0){\\n                if(i == n-1|| s[i+1] != \\')\\') res ++, open --, i++; \\n                else open --, i+=2;\\n            }\\n            else {\\n                open ++, res++; \\n            }\\n        };\\n        res += 2*open; \\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int res = 0, open = 0, n = s.size(), i = 0; \\n        \\n        while(i<n){\\n            if(s[i] == \\'(\\') open ++, i++; \\n            else if(open>0){\\n                if(i == n-1|| s[i+1] != \\')\\') res ++, open --, i++; \\n                else open --, i+=2;\\n            }\\n            else {\\n                open ++, res++; \\n            }\\n        };\\n        res += 2*open; \\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433841,
                "title": "python-min-insertions-to-balance-weird-string",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        # https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/discuss/779928/Simple-O(n)-stack-solution-with-detailed-explanation\\n\\n        stack = []\\n        pair = 0\\n        for c in s:\\n            if c == \"(\": \\n                if stack and stack[-1] == 1: pair += stack.pop()\\n                stack.append(2)\\n                \\n            if c == \")\":\\n                if not stack: \\n                    stack.append(1)\\n                    pair += 1\\n                elif stack[-1] == 1: stack.pop()\\n                elif stack[-1] == 2: stack[-1] -= 1\\n\\n        \\n        return pair + sum(stack)\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        # https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/discuss/779928/Simple-O(n)-stack-solution-with-detailed-explanation\\n\\n        stack = []\\n        pair = 0\\n        for c in s:\\n            if c == \"(\": \\n                if stack and stack[-1] == 1: pair += stack.pop()\\n                stack.append(2)\\n                \\n            if c == \")\":\\n                if not stack: \\n                    stack.append(1)\\n                    pair += 1\\n                elif stack[-1] == 1: stack.pop()\\n                elif stack[-1] == 2: stack[-1] -= 1\\n\\n        \\n        return pair + sum(stack)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384784,
                "title": "c-solution-fully-explained-o-n-solution-one-pass",
                "content": "https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/\\nIf u havent solve above given problem yet, i really recommend u solve that problem first.\\n\\nThe only difference between above given problem and this problem is, in above problem a \"()\" this is valid parentheses string and this \"())\" this is valid parentheses string, here 2 consecutive \"))\" closing bracket needed for one \"(\" opening bracket.\\n\\nwe will use same approach like valid parentheses,\\nwe will push \"(\" opening bracket in stack and whenever we find \")\" closing bracket in string\\nnow we will have 4 cases\\n\\n1. cases (when string is valid, like \"())\" )\\n2. when string is like(\"))\"): mean no opening bracket\\n3. when we have string like this(\"()\") no consecutive closing bracket\\n4. when we have only one \")\" no opening no consecutive closing.\\n\\n````\\nclass Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        int l=s.length();\\n        stack<char> st;\\n        int count=0;int flag=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(\\'(\\');\\n            }\\n            else\\n            {\\n                if(i==l-1)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n                \\n                if(!st.empty() and i+1<l and s[i+1]==\\')\\')\\n                {\\n                    i++; st.pop();\\n                }\\n                else if(st.empty() and i+1<l and s[i+1]==\\')\\')\\n                {\\n                    count++;\\n                    i++;\\n                }\\n                else if(!st.empty() and i+1<l and s[i+1]!=\\')\\')\\n                {\\n                    count++;\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    count+=2;\\n                }\\n            }\\n        }\\n        \\n        if(flag==1)\\n        {\\n            if(!st.empty())\\n            {\\n                st.pop();\\n                count++;\\n            }\\n            else\\n            {\\n                count+=2;\\n            }\\n        }\\n        \\n        count+=st.size()*2;\\n        \\n        return count;\\n    }\\n};\\n\\n````\\n\\nif u have any query regarding coding above approach just ask me in comments.",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        int l=s.length();\\n        stack<char> st;\\n        int count=0;int flag=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(\\'(\\');\\n            }\\n            else\\n            {\\n                if(i==l-1)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n                \\n                if(!st.empty() and i+1<l and s[i+1]==\\')\\')\\n                {\\n                    i++; st.pop();\\n                }\\n                else if(st.empty() and i+1<l and s[i+1]==\\')\\')\\n                {\\n                    count++;\\n                    i++;\\n                }\\n                else if(!st.empty() and i+1<l and s[i+1]!=\\')\\')\\n                {\\n                    count++;\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    count+=2;\\n                }\\n            }\\n        }\\n        \\n        if(flag==1)\\n        {\\n            if(!st.empty())\\n            {\\n                st.pop();\\n                count++;\\n            }\\n            else\\n            {\\n                count+=2;\\n            }\\n        }\\n        \\n        count+=st.size()*2;\\n        \\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341051,
                "title": "easy-to-understand-java-solution",
                "content": "Solve this problem first before going through my code : https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/\\n\\nNow the code should be easy to understand , if you have any doubts do comment down below and I will try to help you out \\n\\n```\\n// intuition is same as leetcode 921 , so solve that first \\n// and then this solution should be a cakewalk to understand \\n\\n// TC : O(n) where n is the length of s\\n// SC : O(1)\\n\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int openCount = 0; // count of \\'(\\'\\n        int closeCount = 0; // count of \\')\\'\\n        for(int i =0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                openCount++;\\n            }else{\\n                if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){ // case : \"())\"\\n                    if(openCount>0) openCount--; // balance opening and \\n                    // closing if possible\\n                    else closeCount++; // if not possible\\n                    // then increment closeCount\\n                    // example : \"))\"\\n                    i++; // increment i because (i+1)th character\\n\\t\\t\\t\\t\\t// has been dealt with\\n                }else{ // case : \")\" or case : \"()(\"\\n                    if(openCount>0){ // consider case :\"()(\" , \\n                        // here you basically balance \"()\" part\\n                        // by adding \\')\\' at the end\\n                        // now part becomes \"())\"\\n                        // so this is balanced \\n                        // so decrement openCount\\n                       \\n                        openCount--;\\n                        closeCount++;\\n                    }else closeCount+=2; // consider case : \")\"\\n                    // you need to add one opening bracket and \\n                    // one closing bracket to balance the expression\\n                    // so the expression becomes \"())\" which is balanced\\n                    // now you added two brackets , so increment\\n                    // closeCount by 2 \\n                }\\n            }\\n        }\\n        // since 1 opening bracket requires 2 closing \\n        // brackets to balance , and closing brackets only \\n        // require one opening bracket to balance \\n        // so we return 2*openCount + closeCount\\n        return 2*openCount+closeCount;\\n    }\\n}\\n```\\n\\nYou can also solve this using stack , how ? solve leetcode 921 using stack and submit it  , and then try to solve this problem by making changes to the code you submitted for leetcode 921 , but since that takes linear space I did not code it up \\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// intuition is same as leetcode 921 , so solve that first \\n// and then this solution should be a cakewalk to understand \\n\\n// TC : O(n) where n is the length of s\\n// SC : O(1)\\n\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int openCount = 0; // count of \\'(\\'\\n        int closeCount = 0; // count of \\')\\'\\n        for(int i =0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                openCount++;\\n            }else{\\n                if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){ // case : \"())\"\\n                    if(openCount>0) openCount--; // balance opening and \\n                    // closing if possible\\n                    else closeCount++; // if not possible\\n                    // then increment closeCount\\n                    // example : \"))\"\\n                    i++; // increment i because (i+1)th character\\n\\t\\t\\t\\t\\t// has been dealt with\\n                }else{ // case : \")\" or case : \"()(\"\\n                    if(openCount>0){ // consider case :\"()(\" , \\n                        // here you basically balance \"()\" part\\n                        // by adding \\')\\' at the end\\n                        // now part becomes \"())\"\\n                        // so this is balanced \\n                        // so decrement openCount\\n                       \\n                        openCount--;\\n                        closeCount++;\\n                    }else closeCount+=2; // consider case : \")\"\\n                    // you need to add one opening bracket and \\n                    // one closing bracket to balance the expression\\n                    // so the expression becomes \"())\" which is balanced\\n                    // now you added two brackets , so increment\\n                    // closeCount by 2 \\n                }\\n            }\\n        }\\n        // since 1 opening bracket requires 2 closing \\n        // brackets to balance , and closing brackets only \\n        // require one opening bracket to balance \\n        // so we return 2*openCount + closeCount\\n        return 2*openCount+closeCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295068,
                "title": "stack-solution-one-pass",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int count = 0;\\n        Deque<Character> stack = new ArrayDeque<>();\\n        \\n        char[] arr = s.toCharArray();\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == \\'(\\') {\\n                stack.offerFirst(arr[i]);\\n            } else if (arr[i] == \\')\\') {\\n                if (i < arr.length - 1 && arr[i + 1] == \\')\\') {\\n                    if (stack.isEmpty()) {\\n                        count += 1;\\n                    } else {\\n                        stack.pollFirst();\\n                    }\\n                    i += 1;\\n                } else {\\n                    if (stack.isEmpty()) {\\n                        count += 2;\\n                    } else {\\n                        count += 1;\\n                        stack.pollFirst();\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count + stack.size() * 2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int count = 0;\\n        Deque<Character> stack = new ArrayDeque<>();\\n        \\n        char[] arr = s.toCharArray();\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == \\'(\\') {\\n                stack.offerFirst(arr[i]);\\n            } else if (arr[i] == \\')\\') {\\n                if (i < arr.length - 1 && arr[i + 1] == \\')\\') {\\n                    if (stack.isEmpty()) {\\n                        count += 1;\\n                    } else {\\n                        stack.pollFirst();\\n                    }\\n                    i += 1;\\n                } else {\\n                    if (stack.isEmpty()) {\\n                        count += 2;\\n                    } else {\\n                        count += 1;\\n                        stack.pollFirst();\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count + stack.size() * 2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238392,
                "title": "one-pass-using-stack-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    Solution() \\n    { \\n        ios_base::sync_with_stdio(0);\\n        cin.tie(NULL); \\n    }\\n    \\n    int minInsertions(string s) \\n    {\\n        int ct = 0 , bt=0;\\n        vector<char> st;\\n        for(int i=0;i<s.length() ; i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push_back(s[i]);\\n            else if(st.size()>0)\\n               {\\n                   if(i+1 < s.length())\\n                       {\\n                           if(s[i+1]==\\')\\')\\n                             { st.pop_back(); i++; }\\n                           else\\n                                { ct++; st.pop_back(); }  \\n                       }\\n                   else\\n                       { ct++; st.pop_back(); }           \\n               } \\n            else\\n            {\\n                if((i+1 < s.length()))\\n                    if(s[i+1]==\\')\\') { bt++; i++; }\\n                    else bt+=2;\\n                else\\n                    bt+=2;\\n            }     \\n        }\\n        int res = 2*st.size();\\n        res += ct + bt;\\n     return res;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution() \\n    { \\n        ios_base::sync_with_stdio(0);\\n        cin.tie(NULL); \\n    }\\n    \\n    int minInsertions(string s) \\n    {\\n        int ct = 0 , bt=0;\\n        vector<char> st;\\n        for(int i=0;i<s.length() ; i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push_back(s[i]);\\n            else if(st.size()>0)\\n               {\\n                   if(i+1 < s.length())\\n                       {\\n                           if(s[i+1]==\\')\\')\\n                             { st.pop_back(); i++; }\\n                           else\\n                                { ct++; st.pop_back(); }  \\n                       }\\n                   else\\n                       { ct++; st.pop_back(); }           \\n               } \\n            else\\n            {\\n                if((i+1 < s.length()))\\n                    if(s[i+1]==\\')\\') { bt++; i++; }\\n                    else bt+=2;\\n                else\\n                    bt+=2;\\n            }     \\n        }\\n        int res = 2*st.size();\\n        res += ct + bt;\\n     return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222152,
                "title": "python-solution",
                "content": "```python\\nresult = l = r = 0\\nfor c in s:\\n\\tif c == \"(\":\\n\\t\\tif r == 1:\\n\\t\\t\\tresult += 1\\n\\t\\t\\tif l > 0:\\n\\t\\t\\t\\tl -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tresult += 1\\n\\t\\t\\tr = 0\\n\\t\\tl += 1\\n\\telse:\\n\\t\\tr += 1\\n\\t\\tif r == 2:\\n\\t\\t\\tif l > 0:\\n\\t\\t\\t\\tl -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tresult += 1\\n\\t\\t\\tr = 0\\nif l < r:\\n\\treturn result + 2\\nelse:\\n\\treturn result + 2 * l - r\\n```",
                "solutionTags": [],
                "code": "```python\\nresult = l = r = 0\\nfor c in s:\\n\\tif c == \"(\":\\n\\t\\tif r == 1:\\n\\t\\t\\tresult += 1\\n\\t\\t\\tif l > 0:\\n\\t\\t\\t\\tl -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tresult += 1\\n\\t\\t\\tr = 0\\n\\t\\tl += 1\\n\\telse:\\n\\t\\tr += 1\\n\\t\\tif r == 2:\\n\\t\\t\\tif l > 0:\\n\\t\\t\\t\\tl -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tresult += 1\\n\\t\\t\\tr = 0\\nif l < r:\\n\\treturn result + 2\\nelse:\\n\\treturn result + 2 * l - r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1200203,
                "title": "python-replace-and-count",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        l,r,h =0,0,0\\n        cnt=0\\n        t = s.replace(\\'))\\',\\'#\\')\\n        for i in range(len(t)):\\n            if t[i]==\\'(\\':\\n                l+=1\\n            elif  t[i]==\\')\\':\\n                if l>0:\\n                    l-=1\\n                    cnt+=1\\n                else:\\n                    r+=1\\n            else:\\n                if l>0:\\n                    l-=1\\n                else:\\n                    h+=1\\n        cnt+= l*2 + r*2 + h\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        l,r,h =0,0,0\\n        cnt=0\\n        t = s.replace(\\'))\\',\\'#\\')\\n        for i in range(len(t)):\\n            if t[i]==\\'(\\':\\n                l+=1\\n            elif  t[i]==\\')\\':\\n                if l>0:\\n                    l-=1\\n                    cnt+=1\\n                else:\\n                    r+=1\\n            else:\\n                if l>0:\\n                    l-=1\\n                else:\\n                    h+=1\\n        cnt+= l*2 + r*2 + h\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151300,
                "title": "no-extra-space",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        s=s.replace(\"))\",\"|\");st=0;c=0\\n        for i in range(len(s)):\\n            if s[i]==\"|\":\\n                if st>0:st-=1\\n                else:c+=1\\n                if st>0:st-=1\\n            elif s[i]==\")\":\\n                c+=1\\n                if st>0:st-=1\\n                else:c+=1\\n                if st>0:st-=1\\n            elif s[i]==\"(\":\\n                st+=1\\n                st+=1\\n        return st+c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        s=s.replace(\"))\",\"|\");st=0;c=0\\n        for i in range(len(s)):\\n            if s[i]==\"|\":\\n                if st>0:st-=1\\n                else:c+=1\\n                if st>0:st-=1\\n            elif s[i]==\")\":\\n                c+=1\\n                if st>0:st-=1\\n                else:c+=1\\n                if st>0:st-=1\\n            elif s[i]==\"(\":\\n                st+=1\\n                st+=1\\n        return st+c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138473,
                "title": "c-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int open=0,insert=0;\\n        int i=0,n=s.length();\\n        \\n        while(i<n) {\\n            if(s[i]==\\'(\\') \\n                open++;\\n            else {\\n                if(i+1<n && s[i+1]==\\')\\')    //there are 2 consecutive \\')\\'\\n                    i++;                    //so skip checking for the 2nd \\'\\')\\'\\n                else \\n                    insert++;\\n                if(open == 0)   //if any close bracket does not have a corresponding open bracket. \\n                    insert++;\\n                else \\n                    open--;     //there is atleast one \\')\\' for an \\'(\\' then we need not add anymore \\'(\\'. Note in case there is only \\')\\', for the second \\')\\' insert in incremented in the previous else block.\\n            }\\n            i++;\\n        }\\n        if(open>0) \\n            insert += 2*open;  //these open do not have any matching \\')\\'\\n        return insert;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int open=0,insert=0;\\n        int i=0,n=s.length();\\n        \\n        while(i<n) {\\n            if(s[i]==\\'(\\') \\n                open++;\\n            else {\\n                if(i+1<n && s[i+1]==\\')\\')    //there are 2 consecutive \\')\\'\\n                    i++;                    //so skip checking for the 2nd \\'\\')\\'\\n                else \\n                    insert++;\\n                if(open == 0)   //if any close bracket does not have a corresponding open bracket. \\n                    insert++;\\n                else \\n                    open--;     //there is atleast one \\')\\' for an \\'(\\' then we need not add anymore \\'(\\'. Note in case there is only \\')\\', for the second \\')\\' insert in incremented in the previous else block.\\n            }\\n            i++;\\n        }\\n        if(open>0) \\n            insert += 2*open;  //these open do not have any matching \\')\\'\\n        return insert;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134665,
                "title": "c-concise-o-n-solution-using-stacks",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        s.push_back(\\'.\\'); //Adding a dummy char at the end to ease the task in loops.\\n        stack<char> st;\\n        int cnt=0;\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            // if(!st.empty())\\n                // cout<<st.top()<<endl;\\n            \\n            if(s[i]==\\'(\\')\\n                st.push(s[i]);\\n            \\n            else if(s[i]==\\')\\' && s[i+1]==\\')\\')\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n                else\\n                    cnt+=1;\\n                i++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                if(!st.empty())\\n                {\\n                    st.pop();\\n                    cnt++;\\n                }\\n                else\\n                    cnt+=2;\\n            }\\n        }\\n        //Now if the stack is not empty means \\'(\\' are present so we need to add more \\'))\\'\\n        if(!st.empty())\\n            cnt+=st.size()*2;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        s.push_back(\\'.\\'); //Adding a dummy char at the end to ease the task in loops.\\n        stack<char> st;\\n        int cnt=0;\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            // if(!st.empty())\\n                // cout<<st.top()<<endl;\\n            \\n            if(s[i]==\\'(\\')\\n                st.push(s[i]);\\n            \\n            else if(s[i]==\\')\\' && s[i+1]==\\')\\')\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n                else\\n                    cnt+=1;\\n                i++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                if(!st.empty())\\n                {\\n                    st.pop();\\n                    cnt++;\\n                }\\n                else\\n                    cnt+=2;\\n            }\\n        }\\n        //Now if the stack is not empty means \\'(\\' are present so we need to add more \\'))\\'\\n        if(!st.empty())\\n            cnt+=st.size()*2;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1113079,
                "title": "python-replacement-trick",
                "content": "```html5\\n<b>Time complexity: O(n)</b> &becaus; replacement and the for-loop both require visiting all n characters in s\\n<b>Space complexity: O(n)</b> &becaus; strings are immutable, the replacement operation creates a new string at a new memory address\\n```\\n\\n**Approach:**\\n\\nReplacing all `\\'))\\'` with `\\']\\'` pairs up all of the closed brackets into groups of 2.\\nReplacing all `\\'(\\'` with `\\'[\\'` does nothing, but it makes it easier to visualize which brackets pairs are complete.\\n\\nIterate over each character in `s` and talley the \\ntotal open / closed parentheses where `\\'[\\' = +2` and `\\']\\' = -2`.\\n\\nWhile iterating over `s` we need to make sure the count never drops below zero.\\nThis would indicate the string is unbalanced.\\n\\nThere are a few possible scenarios:\\n1. For `\\'[\\'` just add 2 to the count, no changes necessary.\\n2. For `\\']\\'` subtract 2 from the count.\\nIf `count < 2` then we must add 1 `[` to keep the string balanced. (`res += 1 ; count += 2`)\\n3. For `\\')\\'` then there are two possibilities.\\nIf `count >= 2` then we have extra `\\'[\\'` and just need to add one `\\')\\'` to keep the string balanced. (`res += 1 ; count -= 2`)\\nOtherwise we need to add one `\\'[\\'` and one `\\')\\'` (`res += 2 ; count += 0`).\\n\\nAfter iterating over `s` if `count` is `0` then the string is balanced.  \\nHowever, in cases like examples 3 and 4, where `count` &ne; `0` then `count` `\\')\\'` must be added to balance the string.\\n\\nThis brings the total insertions up to `res + count` where `res` parentheses were inserted during the traversal\\nand `count` parenetheses were inserted at the end to balance the string.\\n\\n<hr>\\n\\n**Example Replacements:**\\n\\n| Example | Before | After | res | count | answer |\\n|:---:|:---:|:---:|:---:|:---:|:---:|\\n| 1 |(())) |  [[])|1 |  0 | 1|\\n| 2 |()) |  []|0 |  0 | 0|\\n| 3 |))())( |  ][][|1 |  2 | 3|\\n| 4 |(((((( |  [[[[[[|0 |  12 | 12|\\n| 5 |))))))) |  ]]])|5 |  0 | 5|\\n\\n```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        s = s.replace(\\'))\\', \\']\\')\\n        s = s.replace(\\'(\\', \\'[\\')\\n        count = res = 0\\n        \\n        for char in s:\\n            # Scenario 1\\n            if char == \\'[\\':\\n                count += 2\\n                \\n            # Scenario 2\\n            elif char == \\']\\':\\n                if count < 2:\\n                    count += 2\\n                    res += 1\\n                count -= 2\\n            \\n            # Scenario 3\\n            else:\\n                if count >= 2:\\n                    res += 1\\n                else:\\n                    res += 2\\n                    count += 2\\n                count -= 2\\n        \\n        return res + count\\n```",
                "solutionTags": [],
                "code": "```html5\\n<b>Time complexity: O(n)</b> &becaus; replacement and the for-loop both require visiting all n characters in s\\n<b>Space complexity: O(n)</b> &becaus; strings are immutable, the replacement operation creates a new string at a new memory address\\n```\n```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        s = s.replace(\\'))\\', \\']\\')\\n        s = s.replace(\\'(\\', \\'[\\')\\n        count = res = 0\\n        \\n        for char in s:\\n            # Scenario 1\\n            if char == \\'[\\':\\n                count += 2\\n                \\n            # Scenario 2\\n            elif char == \\']\\':\\n                if count < 2:\\n                    count += 2\\n                    res += 1\\n                count -= 2\\n            \\n            # Scenario 3\\n            else:\\n                if count >= 2:\\n                    res += 1\\n                else:\\n                    res += 2\\n                    count += 2\\n                count -= 2\\n        \\n        return res + count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107138,
                "title": "simple-and-short-solution-without-using-stacks-time-o-n-and-space-o-1-faster-than-90",
                "content": "JAVA CODE IS:\\n# \\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n       int open=0;\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\')\\n                open++;\\n            else\\n                if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){ i++;\\n                    if(open>0)   open--;\\n                    else  count++;\\n                }\\n                else{  count++;\\n                    if(open>0)   open--;\\n                    else   count++;\\n                }\\n        }\\n        return count+open*2;\\n    }\\n}\\n```\\nTIME : O(n)\\nSPACE : O(1) NO EXTRA SPACE USED\\n***PLEASE,UPVOTE IF THIS IS HELPFUL ***\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n       int open=0;\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\')\\n                open++;\\n            else\\n                if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){ i++;\\n                    if(open>0)   open--;\\n                    else  count++;\\n                }\\n                else{  count++;\\n                    if(open>0)   open--;\\n                    else   count++;\\n                }\\n        }\\n        return count+open*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080384,
                "title": "c-one-pass-runtime-86-memory-92",
                "content": "```\\nint minInsertions(string s) {\\n\\tint res = 0;\\n\\tint nopen = 0; // unmatched opens\\n\\n\\tfor (int i = 0; i < s.size(); i++){\\n\\t\\tif (s[i] == \\'(\\') {\\n\\t\\t\\tnopen++;\\n\\t\\t} else {\\n\\t\\t\\t// If there is unmatched open use it.\\n\\t\\t\\t// Otherwise, insert an open parenthesis.\\n\\t\\t\\tif (nopen > 0) {\\n\\t\\t\\t\\tnopen--;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If we don\\'t have 2 closing parenthesis, insert \\n\\t\\t\\t// one closing parenthesis.\\n\\t\\t\\tif (i+1 < s.size() && s[i+1] == \\')\\') {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// Every unmatched open will require 2 closing parenthesis\\n\\tres += nopen*2;\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minInsertions(string s) {\\n\\tint res = 0;\\n\\tint nopen = 0; // unmatched opens\\n\\n\\tfor (int i = 0; i < s.size(); i++){\\n\\t\\tif (s[i] == \\'(\\') {\\n\\t\\t\\tnopen++;\\n\\t\\t} else {\\n\\t\\t\\t// If there is unmatched open use it.\\n\\t\\t\\t// Otherwise, insert an open parenthesis.\\n\\t\\t\\tif (nopen > 0) {\\n\\t\\t\\t\\tnopen--;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If we don\\'t have 2 closing parenthesis, insert \\n\\t\\t\\t// one closing parenthesis.\\n\\t\\t\\tif (i+1 < s.size() && s[i+1] == \\')\\') {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// Every unmatched open will require 2 closing parenthesis\\n\\tres += nopen*2;\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1055510,
                "title": "c-one-pass-count-simple-solution-with-explanation",
                "content": "* when s[i] == \\')\\' && (s[i+1] == \\'(\\' or i == s.size()-1), we need to insert one \\')\\'; Otherwise, there are two consecutive \\')\\', and we skip the next one: i++\\n* when every time we face two \\')\\', subtract one \\'(\\' and check if it is < 0. If yes, we need to insert one \\'(\\' and reset left to 0.\\n* after one time pass. res += left\\\\*2 to make sure if there are not enough \\')\\'.\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int res = 0, left = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == \\'(\\') {\\n                ++left;\\n            } else {\\n                if (i < s.size()-1 && s[i+1] == \\')\\') {\\n                    ++i;\\n                } else {\\n                    ++res;\\n                }\\n                if (--left < 0) {\\n                    ++res;\\n                    left = 0;\\n                }\\n            }\\n        }\\n        return res + left*2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int res = 0, left = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == \\'(\\') {\\n                ++left;\\n            } else {\\n                if (i < s.size()-1 && s[i+1] == \\')\\') {\\n                    ++i;\\n                } else {\\n                    ++res;\\n                }\\n                if (--left < 0) {\\n                    ++res;\\n                    left = 0;\\n                }\\n            }\\n        }\\n        return res + left*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976074,
                "title": "c-easy-to-understand-ask-doubts-in-the-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0, n = s.size();\\n        stack<char> d;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'(\\'){\\n                d.push(s[i]);\\n            }\\n            else{\\n                if(i+1 >= n || s[i+1] != \\')\\' ){\\n                    count++;\\n                }\\n                else{\\n                    i++;\\n                }\\n                if(d.size() == 0){\\n                    count++;\\n                }\\n                else{\\n                    d.pop();\\n                }\\n            }\\n        }\\n        return count + 2 * d.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0, n = s.size();\\n        stack<char> d;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'(\\'){\\n                d.push(s[i]);\\n            }\\n            else{\\n                if(i+1 >= n || s[i+1] != \\')\\' ){\\n                    count++;\\n                }\\n                else{\\n                    i++;\\n                }\\n                if(d.size() == 0){\\n                    count++;\\n                }\\n                else{\\n                    d.pop();\\n                }\\n            }\\n        }\\n        return count + 2 * d.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938626,
                "title": "java-one-pass-with-code-comments",
                "content": "```\\npublic int minInsertions(String s) {\\n        //count the number of ( paranthesis without closed.\\n        int count = 0, minInsertions=0;\\n        char[] arr = s.toCharArray();\\n        \\n        //iterate through array, ensure at each point all given either increase count or add paranthesis.\\n        for(int i=0; i<arr.length; i++) {\\n            \\n            if(arr[i]==\\'(\\') count++;\\n            else {\\n                //if current count is positive reduce count otherwise incur one insertion for open.\\n                if(count>0) count--;\\n                else minInsertions++;\\n                \\n                //handling the last element\\n                char next = (i==arr.length-1)? \\'X\\': arr[i+1]; \\n                \\n                //if the next element is not closed, incur another insertion like ()(. Else omit the next element to avoid recalculation\\n                if(next!=\\')\\')  minInsertions++;\\n                else i++;\\n            }\\n        }\\n        \\n        //Add missing end paranthesis.\\n        minInsertions += count*2;\\n        return minInsertions;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minInsertions(String s) {\\n        //count the number of ( paranthesis without closed.\\n        int count = 0, minInsertions=0;\\n        char[] arr = s.toCharArray();\\n        \\n        //iterate through array, ensure at each point all given either increase count or add paranthesis.\\n        for(int i=0; i<arr.length; i++) {\\n            \\n            if(arr[i]==\\'(\\') count++;\\n            else {\\n                //if current count is positive reduce count otherwise incur one insertion for open.\\n                if(count>0) count--;\\n                else minInsertions++;\\n                \\n                //handling the last element\\n                char next = (i==arr.length-1)? \\'X\\': arr[i+1]; \\n                \\n                //if the next element is not closed, incur another insertion like ()(. Else omit the next element to avoid recalculation\\n                if(next!=\\')\\')  minInsertions++;\\n                else i++;\\n            }\\n        }\\n        \\n        //Add missing end paranthesis.\\n        minInsertions += count*2;\\n        return minInsertions;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936597,
                "title": "one-pass-solution-with-o-1-space",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int count = 0, ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i) == \\'(\\') count++;\\n            else{\\n                if(i+1 < n && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                    if(count > 0) count--;\\n                    else ans++;\\n                }\\n                else{\\n                    if(count > 0){\\n                        count--;\\n                        ans++;\\n                    }\\n                    else ans+=2;\\n                }\\n            }\\n        }\\n        ans+=(count*2);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int count = 0, ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i) == \\'(\\') count++;\\n            else{\\n                if(i+1 < n && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                    if(count > 0) count--;\\n                    else ans++;\\n                }\\n                else{\\n                    if(count > 0){\\n                        count--;\\n                        ans++;\\n                    }\\n                    else ans+=2;\\n                }\\n            }\\n        }\\n        ans+=(count*2);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923816,
                "title": "python-use-count-to-simulate-stack",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        res = 0\\n        cnt = 0  #  num of \\'(\\'\\n        for c in s:\\n            if c == \\'(\\':\\n                cnt += 2\\n                if cnt&1:      # only a previous single \\')\\' can cause cnt to be odd\\n                    cnt -= 1\\n                    res += 1\\n            elif c == \\')\\':\\n                if cnt == 0:\\n                    cnt += 1\\n                    res += 1\\n                else:\\n                    cnt -= 1\\n\\n        return res + cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        res = 0\\n        cnt = 0  #  num of \\'(\\'\\n        for c in s:\\n            if c == \\'(\\':\\n                cnt += 2\\n                if cnt&1:      # only a previous single \\')\\' can cause cnt to be odd\\n                    cnt -= 1\\n                    res += 1\\n            elif c == \\')\\':\\n                if cnt == 0:\\n                    cnt += 1\\n                    res += 1\\n                else:\\n                    cnt -= 1\\n\\n        return res + cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917613,
                "title": "c-intuitive-solution-with-explanation",
                "content": "```\\n// Explanation:\\n// view \\'(\\' as push one element in the stack\\n// view \"))\" as pop one elment in the stack\\n// after a sequence of action, if the stack size is empty -> it is balanced\\n\\n// Implmentation:\\n// simply use a interger to represent size of stack, don\\'t really need to use a stack object\\n// how to make it balanced:\\n// if we need pop, but stack is empty -> add a \\'(\\'\\n// if we encounter a single \\')\\' -> add another \\')\\' to complete pop command\\n// if the stack is not empty in the end -> just add stack_size * \"))\" to pop out all elements\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int size = s.size();\\n        int answer = 0;\\n        int stackSize = 0;\\n        for(int i=0; i<size; i++){\\n        \\tif(s[i] == \\'(\\'){\\n        \\t\\tstackSize++; // push one element in the stack\\n        \\t}else{\\n        \\t\\t// check if pop command complete\\n        \\t\\tif(i+1<size && s[i+1] == \\')\\'){\\n        \\t\\t\\ti += 1;\\n        \\t\\t}else{ // not a complete pop command, add a \\')\\'\\n        \\t\\t\\tanswer+=1;\\n        \\t\\t}\\n        \\t\\t// update stackSize\\n        \\t\\tif(stackSize == 0){\\n        \\t\\t\\tanswer+=1;\\n        \\t\\t}else{\\n        \\t\\t\\tstackSize--;\\n        \\t\\t}\\n        \\t}\\n        }\\n        answer += stackSize*2; // if not empty, pop out all elements\\n        return answer;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Explanation:\\n// view \\'(\\' as push one element in the stack\\n// view \"))\" as pop one elment in the stack\\n// after a sequence of action, if the stack size is empty -> it is balanced\\n\\n// Implmentation:\\n// simply use a interger to represent size of stack, don\\'t really need to use a stack object\\n// how to make it balanced:\\n// if we need pop, but stack is empty -> add a \\'(\\'\\n// if we encounter a single \\')\\' -> add another \\')\\' to complete pop command\\n// if the stack is not empty in the end -> just add stack_size * \"))\" to pop out all elements\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int size = s.size();\\n        int answer = 0;\\n        int stackSize = 0;\\n        for(int i=0; i<size; i++){\\n        \\tif(s[i] == \\'(\\'){\\n        \\t\\tstackSize++; // push one element in the stack\\n        \\t}else{\\n        \\t\\t// check if pop command complete\\n        \\t\\tif(i+1<size && s[i+1] == \\')\\'){\\n        \\t\\t\\ti += 1;\\n        \\t\\t}else{ // not a complete pop command, add a \\')\\'\\n        \\t\\t\\tanswer+=1;\\n        \\t\\t}\\n        \\t\\t// update stackSize\\n        \\t\\tif(stackSize == 0){\\n        \\t\\t\\tanswer+=1;\\n        \\t\\t}else{\\n        \\t\\t\\tstackSize--;\\n        \\t\\t}\\n        \\t}\\n        }\\n        answer += stackSize*2; // if not empty, pop out all elements\\n        return answer;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885922,
                "title": "python-counting-solution",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        res, need = 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                need += 2\\n                if need % 2 == 1:\\n                    res += 1\\n                    need -= 1\\n\\n            if s[i] == \\')\\':\\n                need -= 1\\n                if need == -1:\\n                    res += 1\\n                    need = 1\\n\\n        return res + need\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        res, need = 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                need += 2\\n                if need % 2 == 1:\\n                    res += 1\\n                    need -= 1\\n\\n            if s[i] == \\')\\':\\n                need -= 1\\n                if need == -1:\\n                    res += 1\\n                    need = 1\\n\\n        return res + need\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879669,
                "title": "cpp-o-n-tc-and-o-1-sc-faster-than-99-97-solution",
                "content": "```class Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        int n=s.length();\\n        int ans=0;\\n        int i=0;\\n        int op=0,cl=0;;\\n        while(i < n)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                op++;\\n                i++;\\n            }\\n            else\\n            {\\n                cl=0;\\n                while(i < n&&s[i]==\\')\\')\\n                {\\n                    cl++;\\n                    i++;\\n                }\\n                if(cl%2!=0)\\n                {\\n                    cl++;\\n                    ans++;\\n                }\\n                if((cl/2)>op)\\n                {\\n                    ans+=(cl/2-op);\\n                    op=cl=0;\\n                }\\n                else\\n                {\\n                    op-=(cl/2);\\n                    cl=0;\\n                }\\n            }\\n        }\\n        if(cl%2!=0)\\n        {\\n            cl++;\\n            ans++;\\n        }\\n        if((cl/2)>op)\\n        {\\n            ans+=(cl/2-op);\\n        }\\n        else\\n        {\\n            op-=(cl/2);\\n            ans+=(2*op);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```class Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        int n=s.length();\\n        int ans=0;\\n        int i=0;\\n        int op=0,cl=0;;\\n        while(i < n)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                op++;\\n                i++;\\n            }\\n            else\\n            {\\n                cl=0;\\n                while(i < n&&s[i]==\\')\\')\\n                {\\n                    cl++;\\n                    i++;\\n                }\\n                if(cl%2!=0)\\n                {\\n                    cl++;\\n                    ans++;\\n                }\\n                if((cl/2)>op)\\n                {\\n                    ans+=(cl/2-op);\\n                    op=cl=0;\\n                }\\n                else\\n                {\\n                    op-=(cl/2);\\n                    cl=0;\\n                }\\n            }\\n        }\\n        if(cl%2!=0)\\n        {\\n            cl++;\\n            ans++;\\n        }\\n        if((cl/2)>op)\\n        {\\n            ans+=(cl/2-op);\\n        }\\n        else\\n        {\\n            op-=(cl/2);\\n            ans+=(2*op);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870862,
                "title": "c-just-do-what-is-asked",
                "content": "```\\n int minInsertions(string s) {\\n        int i=0;\\n        stack<char> st; \\n        int count = 0;\\n        while(i < s.length()){\\n            if(s[i] == \\'(\\'){\\n                st.push(\\'(\\');\\n                i++;\\n            }\\n            else{\\n                if(s[i] == \\')\\' && i+1 < s.length() && s[i+1] == \\')\\' && !st.empty()){\\n                    st.pop();\\n                    i+=2;\\n                }\\n                else if(s[i] == \\')\\' && i+1 < s.length() && s[i+1] == \\')\\' && st.empty()){\\n                    i+=2;\\n                    count++;\\n                }\\n                else if(s[i] == \\')\\' && i+1 < s.length() && s[i+1]!= \\')\\' && !st.empty()){\\n                    count++;\\n                    i++;\\n                    st.pop();\\n                }\\n                else if(s[i] == \\')\\' && i+1 < s.length() && s[i+1]!= \\')\\' && st.empty()){\\n                    count+=2;\\n                    i++;\\n                }\\n                else if(s[i] == \\')\\' && i+1 == s.length() && !st.empty()){\\n                    count++;\\n                    i++;\\n                    st.pop();\\n                }\\n                else if(s[i] == \\')\\' && i+1 == s.length() && st.empty()){\\n                    count+=2;\\n                    i++;\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            count+=2;\\n            st.pop();\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int minInsertions(string s) {\\n        int i=0;\\n        stack<char> st; \\n        int count = 0;\\n        while(i < s.length()){\\n            if(s[i] == \\'(\\'){\\n                st.push(\\'(\\');\\n                i++;\\n            }\\n            else{\\n                if(s[i] == \\')\\' && i+1 < s.length() && s[i+1] == \\')\\' && !st.empty()){\\n                    st.pop();\\n                    i+=2;\\n                }\\n                else if(s[i] == \\')\\' && i+1 < s.length() && s[i+1] == \\')\\' && st.empty()){\\n                    i+=2;\\n                    count++;\\n                }\\n                else if(s[i] == \\')\\' && i+1 < s.length() && s[i+1]!= \\')\\' && !st.empty()){\\n                    count++;\\n                    i++;\\n                    st.pop();\\n                }\\n                else if(s[i] == \\')\\' && i+1 < s.length() && s[i+1]!= \\')\\' && st.empty()){\\n                    count+=2;\\n                    i++;\\n                }\\n                else if(s[i] == \\')\\' && i+1 == s.length() && !st.empty()){\\n                    count++;\\n                    i++;\\n                    st.pop();\\n                }\\n                else if(s[i] == \\')\\' && i+1 == s.length() && st.empty()){\\n                    count+=2;\\n                    i++;\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            count+=2;\\n            st.pop();\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 847974,
                "title": "my-java-solutions-with-my-thought-process",
                "content": "```\\n/* My though process:\\nSince for most of the paranthesis matching problem, we make use of stack, so here also a stack is used inorder to store some string.\\n\\nFirst of all I simply check whether the string given is empty, if empty then we dont have any insertions to perform, so just return 0.\\nNow I traverse through the string given, when I see a ( then I just push its corresponding )) on to the stack.\\nIf we dont encounter a (, then it means we have ) paranthesis, so we need to take care of certain things\\n-> We check whether we are not having another ) at the last, so if we dont have one, we have to insert one, so increment our count + 1\\n-> else we just increment our iterating variable\\n-> Another case to consider is that, whether we are not have a ( as the first character, so this can be checked by just checking whether our stack is empty or not, if its empty means we have not seen any (, so incrment our count + 1\\n-> Else we pop from the stack and outside the condition, we increment the iterarting variable.\\n\\nNow there is a tricky with the result we have to return. We just didn\\'t return our result, rather we need to take the double of the size of stack because for a single ( we require, 2 ) so we have to multiply by 2 for this mathching.\\nSo we have to return count + size(stack) * 2\\n*/\\nclass Solution {\\n    public int minInsertions(String s) {\\n        if (s.length() == 0)\\n            return 0;\\n        int count = 0;\\n        Stack<String> stack = new Stack<>();\\n        int i = 0;\\n        while (i < s.length()) {\\n            if (s.charAt(i) == \\'(\\') {\\n                stack.push(\"))\");\\n                i ++;\\n            }\\n            else {\\n                if (i == s.length()-1 || s.charAt(i+1) != \\')\\') {// not another ) \\n                    count += 1;\\n                }\\n                else {\\n                    i += 1;\\n                }\\n                if (stack.isEmpty()) \\n                    count += 1;\\n                else\\n                    stack.pop();\\n                i += 1;\\n            }\\n        }\\n        return count + stack.size() * 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n/* My though process:\\nSince for most of the paranthesis matching problem, we make use of stack, so here also a stack is used inorder to store some string.\\n\\nFirst of all I simply check whether the string given is empty, if empty then we dont have any insertions to perform, so just return 0.\\nNow I traverse through the string given, when I see a ( then I just push its corresponding )) on to the stack.\\nIf we dont encounter a (, then it means we have ) paranthesis, so we need to take care of certain things\\n-> We check whether we are not having another ) at the last, so if we dont have one, we have to insert one, so increment our count + 1\\n-> else we just increment our iterating variable\\n-> Another case to consider is that, whether we are not have a ( as the first character, so this can be checked by just checking whether our stack is empty or not, if its empty means we have not seen any (, so incrment our count + 1\\n-> Else we pop from the stack and outside the condition, we increment the iterarting variable.\\n\\nNow there is a tricky with the result we have to return. We just didn\\'t return our result, rather we need to take the double of the size of stack because for a single ( we require, 2 ) so we have to multiply by 2 for this mathching.\\nSo we have to return count + size(stack) * 2\\n*/\\nclass Solution {\\n    public int minInsertions(String s) {\\n        if (s.length() == 0)\\n            return 0;\\n        int count = 0;\\n        Stack<String> stack = new Stack<>();\\n        int i = 0;\\n        while (i < s.length()) {\\n            if (s.charAt(i) == \\'(\\') {\\n                stack.push(\"))\");\\n                i ++;\\n            }\\n            else {\\n                if (i == s.length()-1 || s.charAt(i+1) != \\')\\') {// not another ) \\n                    count += 1;\\n                }\\n                else {\\n                    i += 1;\\n                }\\n                if (stack.isEmpty()) \\n                    count += 1;\\n                else\\n                    stack.pop();\\n                i += 1;\\n            }\\n        }\\n        return count + stack.size() * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832536,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        miss = rm = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                if rm % 2:\\n                    rm -= 1\\n                    miss += 1\\n                rm += 2\\n            else:\\n                rm -= 1\\n                if rm < 0:\\n                    rm = 1\\n                    miss += 1\\n        return miss + rm\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        miss = rm = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                if rm % 2:\\n                    rm -= 1\\n                    miss += 1\\n                rm += 2\\n            else:\\n                rm -= 1\\n                if rm < 0:\\n                    rm = 1\\n                    miss += 1\\n        return miss + rm\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 793890,
                "title": "python-o-n-time-o-1-space-with-concise-explanation",
                "content": "At first I figured we could do this with a stack. Then I realized, we don\\'t actually need a stack because the value we push in the stack doesn\\'t matter.. all we really care about is if there are any ( remaining when I see a ). So a counter will suffice.\\n\\nbasically keep a counter of open parenthesis. If i see a ), then i check if i have any ( left. If i dont, i know i need at least one insertion. Then check if there is another ) after the current ). If there isn\\'t, that also will cost another insertion. Then at the end if there are any remaining ( that i never found a corresponding ) for, i know each of those require 2 insertions, so multiply the remaining ( count by 2.\\n\\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        open_cnt = 0\\n        insert = 0\\n        \\n        i = 0\\n        while i < len(s):\\n            char = s[i]\\n            \\n            if char == \\'(\\':\\n                open_cnt += 1\\n                i += 1\\n            else:\\n                if open_cnt > 0:\\n                    open_cnt -= 1\\n                else:\\n                    insert += 1\\n                    \\n                if i + 1 < len(s) and s[i + 1] == \\')\\':\\n                    i += 2\\n                else:\\n                    insert += 1\\n                    i += 1\\n                        \\n        return insert + 2*open_cnt",
                "solutionTags": [],
                "code": "At first I figured we could do this with a stack. Then I realized, we don\\'t actually need a stack because the value we push in the stack doesn\\'t matter.. all we really care about is if there are any ( remaining when I see a ). So a counter will suffice.\\n\\nbasically keep a counter of open parenthesis. If i see a ), then i check if i have any ( left. If i dont, i know i need at least one insertion. Then check if there is another ) after the current ). If there isn\\'t, that also will cost another insertion. Then at the end if there are any remaining ( that i never found a corresponding ) for, i know each of those require 2 insertions, so multiply the remaining ( count by 2.\\n\\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        open_cnt = 0\\n        insert = 0\\n        \\n        i = 0\\n        while i < len(s):\\n            char = s[i]\\n            \\n            if char == \\'(\\':\\n                open_cnt += 1\\n                i += 1\\n            else:\\n                if open_cnt > 0:\\n                    open_cnt -= 1\\n                else:\\n                    insert += 1\\n                    \\n                if i + 1 < len(s) and s[i + 1] == \\')\\':\\n                    i += 2\\n                else:\\n                    insert += 1\\n                    i += 1\\n                        \\n        return insert + 2*open_cnt",
                "codeTag": "Java"
            },
            {
                "id": 789594,
                "title": "golang-simple-solution",
                "content": "```go\\nfunc minInsertions(s string) int {\\n\\tcounter := 0\\n\\tinsertion := 0\\n\\tfor _, r := range s {\\n\\t\\tif r == \\'(\\' {\\n\\t\\t\\tif counter % 2 == 1 {\\n\\t\\t\\t\\t// insert a \\')\\'\\n\\t\\t\\t\\tinsertion++\\n\\t\\t\\t\\tcounter--\\n\\t\\t\\t}\\n\\t\\t\\tcounter += 2\\n\\t\\t} else {\\n\\t\\t\\tif counter > 0 {\\n\\t\\t\\t\\tcounter--\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// insert a \\'(\\'\\n\\t\\t\\t\\tinsertion++\\n\\t\\t\\t\\tcounter = 1\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn insertion + counter\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minInsertions(s string) int {\\n\\tcounter := 0\\n\\tinsertion := 0\\n\\tfor _, r := range s {\\n\\t\\tif r == \\'(\\' {\\n\\t\\t\\tif counter % 2 == 1 {\\n\\t\\t\\t\\t// insert a \\')\\'\\n\\t\\t\\t\\tinsertion++\\n\\t\\t\\t\\tcounter--\\n\\t\\t\\t}\\n\\t\\t\\tcounter += 2\\n\\t\\t} else {\\n\\t\\t\\tif counter > 0 {\\n\\t\\t\\t\\tcounter--\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// insert a \\'(\\'\\n\\t\\t\\t\\tinsertion++\\n\\t\\t\\t\\tcounter = 1\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn insertion + counter\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 789453,
                "title": "c-simple-o-n-solution",
                "content": "Here we are maintaining a stack of `\\')\\'`. But for that the size of stack is enough. We start from the end of the string.\\nIf we encounter a `\\'(\\'`, then we must subtract 2 from the stack. If less than 2 `\\')\\'` are available in the stack then we add the number of `\\')\\'` required to make it balanced i.e. `2 - (stack size)`.\\nIf we encounter a `\\')\\'`, then we check if we have 2 consecutive `\\')\\'`. If yes, then we add 2 to the stack else we add 1 more to the result and 2 to the stack.\\nIn returning the result we have,\\n`res` = computed answer\\n`stack/2` = In case we have a residue of `\\')\\'` left over in stack, so we add 1 for every 2 in the result.\\n** `stack%2?2:0` = In case we have an odd number of residue, then we add 2 to the result, 1 `\\'(\\'` and 1 `\\')\\'`.\\nThis last condition is not required because we are adding `\\')\\'` into the stack in sets of 2. So we wont have any odd number of parenthesis in the stack.\\n```\\nint minInsertions(string s) {\\n        int res = 0, stack = 0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\'){\\n                if(stack<2)\\n                    res += 2-stack;\\n                stack = max(stack-2,0);\\n            }\\n            else{\\n                if(i>0 && s[i-1]==\\')\\'){\\n                    stack += 2;\\n                    i--;\\n                }\\n                else{\\n                    res += 1;\\n                    stack += 2;\\n                }\\n            }\\n        }\\n        return res + (stack/2); // + (stack%2?2:0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minInsertions(string s) {\\n        int res = 0, stack = 0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\'){\\n                if(stack<2)\\n                    res += 2-stack;\\n                stack = max(stack-2,0);\\n            }\\n            else{\\n                if(i>0 && s[i-1]==\\')\\'){\\n                    stack += 2;\\n                    i--;\\n                }\\n                else{\\n                    res += 1;\\n                    stack += 2;\\n                }\\n            }\\n        }\\n        return res + (stack/2); // + (stack%2?2:0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 785031,
                "title": "python-3-explained-using-stack",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \"\"\"\\n        This program determines the minimum number of parentheses\\n        that need to be added to s to balance the sequence of\\n        open and close parentheses.\\n\\n        :param s: input string of open and close parentheses\\n        :type s: str\\n        :return: minimum number of parentheses needed to balance\\n                 the parentheses in s\\n        :rtype: int\\n        \"\"\"\\n        len_s = len(s)\\n        added_count = 0\\n        stack_count = 0\\n        k = 0\\n        while k < len_s:\\n            chr = s[k]\\n            k += 1\\n            if chr == \\'(\\':\\n                \"\"\"\\n                Place \\'(\\' on stack\\n                \"\"\"\\n                stack_count += 1\\n            elif chr == \\')\\':\\n                \"\"\"\\n                Have one \\')\\', need second one\\n                \"\"\"\\n                if k == len_s or s[k] == \\'(\\':\\n                    \"\"\"\\n                    End of string or \\'(\\' - add second \\')\\'\\n                    \"\"\"\\n                    added_count += 1\\n                else:\\n                    \"\"\"\\n                    Got second \\')\\' from string\\n                    \"\"\"\\n                    k += 1\\n                \"\"\"\\n                Remove matching \\'(\\' from stack or add one to\\n                remove if stack empty.\\n                \"\"\"\\n                if stack_count:\\n                    stack_count -= 1\\n                else:\\n                    added_count += 1\\n        \"\"\"\\n        After string processed, add \\'))\\' for each \\'(\\' remaining\\n        in the stack.\\n        \"\"\"\\n        added_count += 2 * stack_count\\n        return added_count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \"\"\"\\n        This program determines the minimum number of parentheses\\n        that need to be added to s to balance the sequence of\\n        open and close parentheses.\\n\\n        :param s: input string of open and close parentheses\\n        :type s: str\\n        :return: minimum number of parentheses needed to balance\\n                 the parentheses in s\\n        :rtype: int\\n        \"\"\"\\n        len_s = len(s)\\n        added_count = 0\\n        stack_count = 0\\n        k = 0\\n        while k < len_s:\\n            chr = s[k]\\n            k += 1\\n            if chr == \\'(\\':\\n                \"\"\"\\n                Place \\'(\\' on stack\\n                \"\"\"\\n                stack_count += 1\\n            elif chr == \\')\\':\\n                \"\"\"\\n                Have one \\')\\', need second one\\n                \"\"\"\\n                if k == len_s or s[k] == \\'(\\':\\n                    \"\"\"\\n                    End of string or \\'(\\' - add second \\')\\'\\n                    \"\"\"\\n                    added_count += 1\\n                else:\\n                    \"\"\"\\n                    Got second \\')\\' from string\\n                    \"\"\"\\n                    k += 1\\n                \"\"\"\\n                Remove matching \\'(\\' from stack or add one to\\n                remove if stack empty.\\n                \"\"\"\\n                if stack_count:\\n                    stack_count -= 1\\n                else:\\n                    added_count += 1\\n        \"\"\"\\n        After string processed, add \\'))\\' for each \\'(\\' remaining\\n        in the stack.\\n        \"\"\"\\n        added_count += 2 * stack_count\\n        return added_count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784566,
                "title": "javascript-extremely-simple-4-line-solution-w-explanation",
                "content": "First, we initialize a counter for the open parentheses and our answer variable.\\n\\nIterating through the string, if we find a \\'(\\', increment the counter.\\n\\nIf it\\'s not a \\'(\\', then it must be a \\')\\'. If we have a stored \\'(\\', then \\'use\\' it and decrement the counter, otherwise we\\'d need to insert a \\'(\\' here, so increment the answer. Also, if the next character is a \\')\\', then jump ahead one step by incrementing the interval, or else we\\'ll need to insert a \\')\\' here, so again increment the answer.\\n\\nFinally, any remaining stored \\'(\\'s left at the end will need to be closed off with two \\')\\'s each.\\n\\n```\\nvar minInsertions = function(s, open=0, ans=0) {\\n    for (let i = 0; i < s.length; i++)\\n        if (s[i] === \\'(\\') open++\\n        else open > 0 ? open-- : ans++, s[i+1] === \\')\\' ? i++ : ans++\\n    return ans + open * 2\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minInsertions = function(s, open=0, ans=0) {\\n    for (let i = 0; i < s.length; i++)\\n        if (s[i] === \\'(\\') open++\\n        else open > 0 ? open-- : ans++, s[i+1] === \\')\\' ? i++ : ans++\\n    return ans + open * 2\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780287,
                "title": "o-n-solution-in-c-using-a-temporary-string",
                "content": "#### Converting a hard question into something simpler\\n\\nIf I had a simple string that required one \\'(\\' and \\')\\', the it would have been easier right? \\nSo, why not convert to a simpler one. Start with creating a new temporary string where we have single \\')\\' for every opening \\'(\\'. But do remember, while converting to simpler one, count number of missing \\')\\', where we were supposed to have \\'))\\'.\\n```\\n\\t\\tstring temp = \"\";\\n        int cnt = 0;\\n        for(int i = 0;i<n;i++){\\n            if(s[i] == \\'(\\') temp += \\'(\\';\\n            else{\\n                if(i + 1 < n){\\n                    if(s[i+1] == \\')\\') i++;\\n                    else cnt++;\\n                }\\n                else{ cnt++;}       // handling case with string ending with single \\')\\'\\n                temp+= \\')\\';\\n            }\\n        }\\n\\t\\t\\n```\\n\\nNow since this problem has been converted into a simpler problem, it can be done easily.\\nFor this  problem we need to calculate difference of \\'(\\' and \\')\\'. If anytime this difference becomes less than 0, add a \\'(\\'. And, if diff is positive, we must add a \\')\\'. \\nAnd while adding diff to total count, add twice of diff as in the original question we were supposed to add \\'))\\' for every \\'(\\'.\\n\\n\\n```\\n\\tint diff = 0, ans = 0;\\n    for (int i = 0; i < tempp.length(); ++i) { \\n  \\n        if(temp[i] == \\'(\\') diff++; \\n        else diff--; \\n  \\n        if (diff == -1) { \\n            ans++; diff++; \\n\\t\\t}\\n    } \\n  \\n    int total =  diff*2 + ans + cnt; \\n\\t\\n```\\n\\nTime Complexity : O(N)\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\n\\t\\tstring temp = \"\";\\n        int cnt = 0;\\n        for(int i = 0;i<n;i++){\\n            if(s[i] == \\'(\\') temp += \\'(\\';\\n            else{\\n                if(i + 1 < n){\\n                    if(s[i+1] == \\')\\') i++;\\n                    else cnt++;\\n                }\\n                else{ cnt++;}       // handling case with string ending with single \\')\\'\\n                temp+= \\')\\';\\n            }\\n        }\\n\\t\\t\\n```\n```\\n\\tint diff = 0, ans = 0;\\n    for (int i = 0; i < tempp.length(); ++i) { \\n  \\n        if(temp[i] == \\'(\\') diff++; \\n        else diff--; \\n  \\n        if (diff == -1) { \\n            ans++; diff++; \\n\\t\\t}\\n    } \\n  \\n    int total =  diff*2 + ans + cnt; \\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780195,
                "title": "easy-understanding-c-python-stack-solution",
                "content": "We can use stack to imitate left parenthesis.\\nWhenever we met a left parenthesis, place it into stack.\\nOtherwise, fill in left parenthesis, and pop out stack as needed.\\n\\nC++ version:\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> stk;\\n        int res = 0;\\n        for (int idx = 0; idx < s.length(); ++idx) {\\n            char c = s[idx];\\n            if (c == \\'(\\') {\\n                stk.push(c);\\n            } else if (c == \\')\\') {\\n                // Fill in missing left parenthesis.\\n                if (stk.empty()) {\\n                    ++res;\\n                    stk.push(\\'(\\');\\n                }\\n                \\n                // Paired right parenthesis.\\n                if (idx < s.length() - 1 && s[idx + 1] == \\')\\') {\\n                    ++idx;\\n                    stk.pop();\\n                }\\n                \\n                // Unpaired right parenthesis.\\n                else if (idx == s.length() - 1 || (idx < s.length() - 1 && s[idx + 1] != \\')\\')) {\\n                    ++res;\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        \\n        res += 2 * stk.size();\\n        return res;\\n    }\\n};\\n```\\n\\nPython version:\\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stk = list()\\n        res = 0\\n        idx = 0\\n        while (idx < len(s)):\\n            c = s[idx]\\n            if (c == \\'(\\'):\\n                stk.append(c)\\n            else:\\n                # Fill in left parenthesis\\n                if (not stk):\\n                    res += 1\\n                    stk.append(\\'(\\')\\n                \\n                # Paired right parenthesis.\\n                if (idx < len(s) - 1 and s[idx + 1] == \\')\\'):\\n                    idx += 1\\n                    stk.pop()\\n                \\n                # Unpaired right parenthesis.\\n                else:\\n                    res += 1\\n                    stk.pop()\\n            \\n            idx += 1\\n        \\n        # Calculate unpaired left parenthesis.\\n        res += len(stk) * 2\\n        return res\\n```\\n\\nAfter you\\'ve understood this method, we could easily replace stack with left counter.\\nC++:\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int left = 0;\\n        int res = 0;\\n        for (int idx = 0; idx < s.length(); ++idx) {\\n            char c = s[idx];\\n            if (c == \\'(\\') {\\n                ++left;\\n            } else if (c == \\')\\') {\\n                // Fill in missing left parenthesis.\\n                if (left == 0) {\\n                    ++res;\\n                    ++left;\\n                }\\n                \\n                // Paired right parenthesis.\\n                if (idx < s.length() - 1 && s[idx + 1] == \\')\\') {\\n                    ++idx;\\n                    --left;\\n                }\\n                \\n                // Unpaired right parenthesis.\\n                else if (idx == s.length() - 1 || (idx < s.length() - 1 && s[idx + 1] != \\')\\')) {\\n                    ++res;\\n                    --left;\\n                }\\n            }\\n        }\\n        \\n        res += 2 * left;\\n        return res;\\n    }\\n};\\n```\\n\\npython:\\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stk = list()\\n        res = 0\\n        idx = 0\\n        while (idx < len(s)):\\n            c = s[idx]\\n            if (c == \\'(\\'):\\n                stk.append(c)\\n            else:\\n                # Fill in left parenthesis\\n                if (not stk):\\n                    res += 1\\n                    stk.append(\\'(\\')\\n                \\n                # Paired right parenthesis.\\n                if (idx < len(s) - 1 and s[idx + 1] == \\')\\'):\\n                    idx += 1\\n                    stk.pop()\\n                \\n                # Unpaired right parenthesis.\\n                else:\\n                    res += 1\\n                    stk.pop()\\n            \\n            idx += 1\\n        \\n        # Calculate unpaired left parenthesis.\\n        res += len(stk) * 2\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> stk;\\n        int res = 0;\\n        for (int idx = 0; idx < s.length(); ++idx) {\\n            char c = s[idx];\\n            if (c == \\'(\\') {\\n                stk.push(c);\\n            } else if (c == \\')\\') {\\n                // Fill in missing left parenthesis.\\n                if (stk.empty()) {\\n                    ++res;\\n                    stk.push(\\'(\\');\\n                }\\n                \\n                // Paired right parenthesis.\\n                if (idx < s.length() - 1 && s[idx + 1] == \\')\\') {\\n                    ++idx;\\n                    stk.pop();\\n                }\\n                \\n                // Unpaired right parenthesis.\\n                else if (idx == s.length() - 1 || (idx < s.length() - 1 && s[idx + 1] != \\')\\')) {\\n                    ++res;\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        \\n        res += 2 * stk.size();\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stk = list()\\n        res = 0\\n        idx = 0\\n        while (idx < len(s)):\\n            c = s[idx]\\n            if (c == \\'(\\'):\\n                stk.append(c)\\n            else:\\n                # Fill in left parenthesis\\n                if (not stk):\\n                    res += 1\\n                    stk.append(\\'(\\')\\n                \\n                # Paired right parenthesis.\\n                if (idx < len(s) - 1 and s[idx + 1] == \\')\\'):\\n                    idx += 1\\n                    stk.pop()\\n                \\n                # Unpaired right parenthesis.\\n                else:\\n                    res += 1\\n                    stk.pop()\\n            \\n            idx += 1\\n        \\n        # Calculate unpaired left parenthesis.\\n        res += len(stk) * 2\\n        return res\\n```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int left = 0;\\n        int res = 0;\\n        for (int idx = 0; idx < s.length(); ++idx) {\\n            char c = s[idx];\\n            if (c == \\'(\\') {\\n                ++left;\\n            } else if (c == \\')\\') {\\n                // Fill in missing left parenthesis.\\n                if (left == 0) {\\n                    ++res;\\n                    ++left;\\n                }\\n                \\n                // Paired right parenthesis.\\n                if (idx < s.length() - 1 && s[idx + 1] == \\')\\') {\\n                    ++idx;\\n                    --left;\\n                }\\n                \\n                // Unpaired right parenthesis.\\n                else if (idx == s.length() - 1 || (idx < s.length() - 1 && s[idx + 1] != \\')\\')) {\\n                    ++res;\\n                    --left;\\n                }\\n            }\\n        }\\n        \\n        res += 2 * left;\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stk = list()\\n        res = 0\\n        idx = 0\\n        while (idx < len(s)):\\n            c = s[idx]\\n            if (c == \\'(\\'):\\n                stk.append(c)\\n            else:\\n                # Fill in left parenthesis\\n                if (not stk):\\n                    res += 1\\n                    stk.append(\\'(\\')\\n                \\n                # Paired right parenthesis.\\n                if (idx < len(s) - 1 and s[idx + 1] == \\')\\'):\\n                    idx += 1\\n                    stk.pop()\\n                \\n                # Unpaired right parenthesis.\\n                else:\\n                    res += 1\\n                    stk.pop()\\n            \\n            idx += 1\\n        \\n        # Calculate unpaired left parenthesis.\\n        res += len(stk) * 2\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779962,
                "title": "c-only-count-left-parentheses-o-n-o-1-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minInsertions(string s) {\\n\\t\\t\\tint left=0;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\n\\t\\t\\t\\t\\tif(left>0 && i<s.size()-1 && s[i+1]==\\')\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\tleft--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(left>0  && ((i<s.size()-1 && s[i+1]!=\\')\\') || i==s.size()-1))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t\\tleft--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(left==0 && i<s.size()-1 && s[i+1]==\\')\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telse if(left==0 && ((i<s.size()-1 && s[i+1]!=\\')\\') || i==s.size()-1 ))\\n\\t\\t\\t\\t\\t{\\n\\n\\t\\t\\t\\t\\t\\tans+=2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tans+=left*2;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minInsertions(string s) {\\n\\t\\t\\tint left=0;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 779934,
                "title": "python-using-stack",
                "content": "As we need two clossing brackets for one opening bracket we pop a oppening bracket from the stack when we have two clossing bracket adjecent to each other, and rest is very similar to simple valid parenthesis problem.\\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stack=[]\\n        number=0\\n        ans=0\\n        i=0\\n        while(i<len(s)):\\n            if s[i]==\"(\":\\n                stack.append(s[i])\\n                i+=1\\n            else:\\n                if i==len(s)-1 or s[i+1]==\"(\":\\n                    ans+=1\\n                    if len(stack)!=0:\\n                        stack.pop()\\n                    else:\\n                        ans+=1\\n                    i+=1\\n                else:\\n                    if len(stack)!=0:\\n                        stack.pop()\\n                    else:\\n                        ans+=1\\n                    i+=2\\n        \\n        ans+=len(stack)*2\\n        return ans\\n",
                "solutionTags": [],
                "code": "As we need two clossing brackets for one opening bracket we pop a oppening bracket from the stack when we have two clossing bracket adjecent to each other, and rest is very similar to simple valid parenthesis problem.\\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stack=[]\\n        number=0\\n        ans=0\\n        i=0\\n        while(i<len(s)):\\n            if s[i]==\"(\":\\n                stack.append(s[i])\\n                i+=1\\n            else:\\n                if i==len(s)-1 or s[i+1]==\"(\":\\n                    ans+=1\\n                    if len(stack)!=0:\\n                        stack.pop()\\n                    else:\\n                        ans+=1\\n                    i+=1\\n                else:\\n                    if len(stack)!=0:\\n                        stack.pop()\\n                    else:\\n                        ans+=1\\n                    i+=2\\n        \\n        ans+=len(stack)*2\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 779897,
                "title": "java-using-stack",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        Stack<Character> stack = new Stack<>();\\n        int count = 0, curr = 0;\\n        for(int i = 0; i < n; i++) {\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\') {\\n                if(curr == 1) {\\n                    count++;\\n                    if(stack.size() > 0) stack.pop();\\n                    else count++;\\n                    curr = 0;\\n                }\\n                stack.push(ch);\\n            } else {\\n                if(curr == 0) {\\n                    if(stack.size() == 0) {\\n                        stack.push(\\'(\\');\\n                        count++;\\n                    }\\n                    curr = 1;\\n                } else {\\n                    if(stack.size() == 0) count++;\\n                    else stack.pop();\\n                    curr = 0;\\n                }\\n            }\\n        }\\n        while(stack.size() > 0) {\\n            if(curr == 1) {\\n                curr = 0;\\n                count++;\\n            } else count += 2;\\n            stack.pop();\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        Stack<Character> stack = new Stack<>();\\n        int count = 0, curr = 0;\\n        for(int i = 0; i < n; i++) {\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\') {\\n                if(curr == 1) {\\n                    count++;\\n                    if(stack.size() > 0) stack.pop();\\n                    else count++;\\n                    curr = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4084421,
                "title": "java-intuitive-easy-constant-space-complexity-missing-test-case-description-explanation",
                "content": "# Missing Data\\nthe opening bracket can only be balanced by pair of consecutive closing brackets. \\nFor example in the following case: \\n(()))(()))()())))\\nSee the following screenshot how the brackets are balanced with each other. Same color opening brackets will be balanced with first occurence of same color closing bracket towards it right.\\n \\n![bracketsBalanced.png](https://assets.leetcode.com/users/images/ce86266a-410c-4a01-872b-d3ebce631140_1695553126.7488647.png)\\n\\n\\nThe answer should be 4\\nExplanation: \\nThe first red brackets need 1 closing bracket to balance. \\nSimilarly the next Green Brackets need one 1 closing bracket\\nBlue Brackets need 1 closing bracket \\nBrown Brackets need 1 opening bracket\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep count of opening bracket encountered so far, \\nIf the current bracket is an closing bracket, balance it with one of the opening bracket, if there is any otherwise, we just have to insert one opening bracket. \\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int open, close, index ;\\n        open = close  = index = 0;\\n        while ( index < s.length()){\\n            char ch = s.charAt(index++);\\n            if ( ch == \\'(\\'){\\n                open++;\\n            }\\n            else{\\n                // this is an closing bracket.\\n                if ( index >= s.length() || s.charAt(index) != \\')\\'){\\n                    close ++;\\n                }\\n                else{\\n                    index++;\\n                }\\n                if ( open > 0){\\n                    open--;\\n                }\\n                else{\\n                    close++;\\n                }\\n\\n            }\\n        }\\n        return close + open*2;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int open, close, index ;\\n        open = close  = index = 0;\\n        while ( index < s.length()){\\n            char ch = s.charAt(index++);\\n            if ( ch == \\'(\\'){\\n                open++;\\n            }\\n            else{\\n                // this is an closing bracket.\\n                if ( index >= s.length() || s.charAt(index) != \\')\\'){\\n                    close ++;\\n                }\\n                else{\\n                    index++;\\n                }\\n                if ( open > 0){\\n                    open--;\\n                }\\n                else{\\n                    close++;\\n                }\\n\\n            }\\n        }\\n        return close + open*2;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057125,
                "title": "java-solution",
                "content": "S# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        //count is for counting the number of right parenthese\\n        int count=0;\\n        int result=0;\\n        for (char x:s.toCharArray()) {\\n            if (x == \\'(\\') {\\n                count+=2;\\n                if(count%2!=0){\\n                    result++;\\n                    count--;\\n                }\\n            }\\n            else{\\n                //we have encountered right paranthese\\n                count-=1;\\n                if(count<0){\\n                    count+=2;\\n                    result++;\\n                }\\n            }\\n        }\\n        return result+count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        //count is for counting the number of right parenthese\\n        int count=0;\\n        int result=0;\\n        for (char x:s.toCharArray()) {\\n            if (x == \\'(\\') {\\n                count+=2;\\n                if(count%2!=0){\\n                    result++;\\n                    count--;\\n                }\\n            }\\n            else{\\n                //we have encountered right paranthese\\n                count-=1;\\n                if(count<0){\\n                    count+=2;\\n                    result++;\\n                }\\n            }\\n        }\\n        return result+count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054767,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        \\n        int lcount = 0;\\n        int res = 0;\\n        int n = s.length();\\n        for(int i = 0; i < n; i++) {\\n            \\n            if(s.charAt(i) == \\'(\\') {\\n                lcount++;\\n            }\\n            if(s.charAt(i) == \\')\\') {\\n                \\n                if(i < n-1 && s.charAt(i+1) == \\')\\') {\\n                    i++;\\n                    \\n                    if(lcount > 0) {\\n                        lcount--;\\n                    } else {\\n                        res++;\\n                    }\\n                } else {\\n                    if(lcount > 0) {\\n                        lcount--;\\n                        res++;\\n                    } else {\\n                        res += 2;\\n                    }\\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        \\n        res += lcount*2;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        \\n        int lcount = 0;\\n        int res = 0;\\n        int n = s.length();\\n        for(int i = 0; i < n; i++) {\\n            \\n            if(s.charAt(i) == \\'(\\') {\\n                lcount++;\\n            }\\n            if(s.charAt(i) == \\')\\') {\\n                \\n                if(i < n-1 && s.charAt(i+1) == \\')\\') {\\n                    i++;\\n                    \\n                    if(lcount > 0) {\\n                        lcount--;\\n                    } else {\\n                        res++;\\n                    }\\n                } else {\\n                    if(lcount > 0) {\\n                        lcount--;\\n                        res++;\\n                    } else {\\n                        res += 2;\\n                    }\\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        \\n        res += lcount*2;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038546,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\nBasically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\t\\tint countBrackets = 0;\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tif (s.charAt(i) == \\'(\\') {\\n\\t\\t\\t\\tstack.push(s.charAt(i));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (i + 1 < s.length() && s.charAt(i + 1) == \\')\\') {\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcountBrackets++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tif (!stack.isEmpty()) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcountBrackets++;\\n\\t\\t\\t}\\n        }\\n\\t\\t}\\n\\t\\tcountBrackets += 2 * stack.size();\\n\\t\\treturn countBrackets;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\t\\tint countBrackets = 0;\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tif (s.charAt(i) == \\'(\\') {\\n\\t\\t\\t\\tstack.push(s.charAt(i));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (i + 1 < s.length() && s.charAt(i + 1) == \\')\\') {\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcountBrackets++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tif (!stack.isEmpty()) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcountBrackets++;\\n\\t\\t\\t}\\n        }\\n\\t\\t}\\n\\t\\tcountBrackets += 2 * stack.size();\\n\\t\\treturn countBrackets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034396,
                "title": "go-greedy-100-less-memory-simple",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc minInsertions(s string) int {\\n\\n\\tc_needed := 0\\n\\to_needed := 0\\n\\n\\tfor _, v := range s {\\n\\t\\tif string(v) == \"(\" {\\n\\t\\t\\tc_needed += 2\\n\\n\\t\\t\\tif c_needed%2 == 1 {\\n\\t\\t\\t\\tc_needed--\\n\\t\\t\\t\\to_needed++\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tc_needed -= 1\\n\\n\\t\\t\\tif c_needed == -1 {\\n\\t\\t\\t\\tc_needed = 1\\n\\t\\t\\t\\to_needed++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn c_needed + o_needed\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nfunc minInsertions(s string) int {\\n\\n\\tc_needed := 0\\n\\to_needed := 0\\n\\n\\tfor _, v := range s {\\n\\t\\tif string(v) == \"(\" {\\n\\t\\t\\tc_needed += 2\\n\\n\\t\\t\\tif c_needed%2 == 1 {\\n\\t\\t\\t\\tc_needed--\\n\\t\\t\\t\\to_needed++\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tc_needed -= 1\\n\\n\\t\\t\\tif c_needed == -1 {\\n\\t\\t\\t\\tc_needed = 1\\n\\t\\t\\t\\to_needed++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn c_needed + o_needed\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957611,
                "title": "c-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minInsertions(string s) {\\n    int neededRight = 0;   // Increment by 2 for each \\'(\\'.\\n    int missingLeft = 0;   // Increment by 1 for each missing \\'(\\'.\\n    int missingRight = 0;  // Increment by 1 for each missing \\')\\'.\\n\\n    for (const char c : s)\\n      if (c == \\'(\\') {\\n        if (neededRight % 2 == 1) {\\n          // E.g. \"()(...\"\\n          ++missingRight;\\n          --neededRight;\\n        }\\n        neededRight += 2;\\n      } else if (--neededRight < 0) {  // c == \\')\\'\\n        // E.g. \"()))...\"\\n        ++missingLeft;\\n        neededRight += 2;\\n      }\\n\\n    return neededRight + missingLeft + missingRight;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minInsertions(string s) {\\n    int neededRight = 0;   // Increment by 2 for each \\'(\\'.\\n    int missingLeft = 0;   // Increment by 1 for each missing \\'(\\'.\\n    int missingRight = 0;  // Increment by 1 for each missing \\')\\'.\\n\\n    for (const char c : s)\\n      if (c == \\'(\\') {\\n        if (neededRight % 2 == 1) {\\n          // E.g. \"()(...\"\\n          ++missingRight;\\n          --neededRight;\\n        }\\n        neededRight += 2;\\n      } else if (--neededRight < 0) {  // c == \\')\\'\\n        // E.g. \"()))...\"\\n        ++missingLeft;\\n        neededRight += 2;\\n      }\\n\\n    return neededRight + missingLeft + missingRight;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956017,
                "title": "100-useful-minimum-number-of-swaps-to-make-the-string-balanced",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minInsertions = function(s) {\\n    \\n   let left = 0;\\n   let right = 0;\\n   for(i=0; i<s.length;i++) {\\n       if (s[i]===\"(\") {\\n           right += 2;\\n            if(right % 2 === 1) {\\n                left++;\\n                right--;\\n            }\\n       } \\n       if (s[i]===\")\") {\\n           right--;\\n            if (right ===-1) {\\n                left++;\\n                right = 1;\\n            \\n           }\\n       }\\n   } \\n return left+right;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minInsertions = function(s) {\\n    \\n   let left = 0;\\n   let right = 0;\\n   for(i=0; i<s.length;i++) {\\n       if (s[i]===\"(\") {\\n           right += 2;\\n            if(right % 2 === 1) {\\n                left++;\\n                right--;\\n            }\\n       } \\n       if (s[i]===\")\") {\\n           right--;\\n            if (right ===-1) {\\n                left++;\\n                right = 1;\\n            \\n           }\\n       }\\n   } \\n return left+right;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3929808,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nvar minInsertions = function(s) {\\n    let left = result = 0;\\n\\n    for (let index = 0; index < s.length; index++) {\\n        if (s[index] === \\'(\\') left += 1;\\n        else if (s[index + 1] === \\')\\') {\\n            left > 0 ? left -= 1 : result += 1;\\n            index += 1;\\n        } else {\\n            if (left > 0) {\\n                left -= 1;\\n                result += 1;\\n            } else {\\n                result += 2;\\n            }\\n        }\\n    }\\n    return result += left * 2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minInsertions = function(s) {\\n    let left = result = 0;\\n\\n    for (let index = 0; index < s.length; index++) {\\n        if (s[index] === \\'(\\') left += 1;\\n        else if (s[index + 1] === \\')\\') {\\n            left > 0 ? left -= 1 : result += 1;\\n            index += 1;\\n        } else {\\n            if (left > 0) {\\n                left -= 1;\\n                result += 1;\\n            } else {\\n                result += 2;\\n            }\\n        }\\n    }\\n    return result += left * 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915268,
                "title": "python-o-n-time-and-o-1-space-beats-100",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        insertion = 0\\n        left = 0 # track imbalanced opens\\n        right = False # track if there is a single closing bracket\\n        for v in s:\\n            if v == \\'(\\':\\n                # we\\'ve closed a single bracket, so either have () or just ), inserting 1 or 2 respectively\\n                if right:\\n                    right = False\\n                    if left:\\n                        insertion += 1\\n                        left -= 1\\n                    else:\\n                        insertion += 2\\n                left += 1\\n            else:\\n                # flip whether we have a single trailing ) and evaluate insertions needed if we have a new ))\\n                if not right:\\n                    right = True\\n                else:\\n                    right = False\\n                    if left:\\n                        left -= 1\\n                    else:\\n                        insertion += 1\\n                        \\n        if left:\\n            return insertion + 2  * left - right\\n        \\n        if right:\\n            return insertion + 2\\n                        \\n        return insertion\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        insertion = 0\\n        left = 0 # track imbalanced opens\\n        right = False # track if there is a single closing bracket\\n        for v in s:\\n            if v == \\'(\\':\\n                # we\\'ve closed a single bracket, so either have () or just ), inserting 1 or 2 respectively\\n                if right:\\n                    right = False\\n                    if left:\\n                        insertion += 1\\n                        left -= 1\\n                    else:\\n                        insertion += 2\\n                left += 1\\n            else:\\n                # flip whether we have a single trailing ) and evaluate insertions needed if we have a new ))\\n                if not right:\\n                    right = True\\n                else:\\n                    right = False\\n                    if left:\\n                        left -= 1\\n                    else:\\n                        insertion += 1\\n                        \\n        if left:\\n            return insertion + 2  * left - right\\n        \\n        if right:\\n            return insertion + 2\\n                        \\n        return insertion\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914863,
                "title": "java-no-stack-used-easy-to-follow",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public int minInsertions(String s) {\\n    int n = s.length();\\n    int count = 0;\\n    int ans = 0;\\n    \\n    for (int i = 0; i < n; i++) {\\n        if (s.charAt(i) == \\'(\\') {\\n            count++;\\n        } else {\\n            if (i + 1 < n && s.charAt(i + 1) == \\')\\') {\\n                i++;\\n                if (count > 0) {\\n                    count--;\\n                } else {\\n                    ans++;\\n                }\\n            } else {\\n                if (count > 0) {\\n                    count--;\\n                    ans++;\\n                } else {\\n                    ans += 2;\\n                }\\n            }\\n        }\\n    }\\n    \\n    ans = ans + (count * 2);\\n    return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int minInsertions(String s) {\\n    int n = s.length();\\n    int count = 0;\\n    int ans = 0;\\n    \\n    for (int i = 0; i < n; i++) {\\n        if (s.charAt(i) == \\'(\\') {\\n            count++;\\n        } else {\\n            if (i + 1 < n && s.charAt(i + 1) == \\')\\') {\\n                i++;\\n                if (count > 0) {\\n                    count--;\\n                } else {\\n                    ans++;\\n                }\\n            } else {\\n                if (count > 0) {\\n                    count--;\\n                    ans++;\\n                } else {\\n                    ans += 2;\\n                }\\n            }\\n        }\\n    }\\n    \\n    ans = ans + (count * 2);\\n    return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914813,
                "title": "c-no-stack-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        // n equal to the size of the array\\n        int n = s.length();\\n        // 2 variables count & ans\\n        int count = 0;\\n        int ans = 0;\\n        // Traverse the array\\n        for (int i = 0; i < n; i++) {\\n            // if we found \\'(\\' in array we\\'ll increase the count\\n            if (s[i] == \\'(\\') {\\n                count++;\\n            } else { // s[i] == \\')\\'\\n                // check if the next is also \\')\\'\\n                if (i + 1 < n && s[i + 1] == \\')\\') {\\n                    // move i ahead\\n                    i++;\\n                    // if there\\'s \\'(\\' present i.e count > 0 : ( ))\\n                    if (count > 0) {\\n                        count--;\\n                    } else {\\n                        // \\'(\\' is not present we\\'ll add 1 to the ans\\n                        ans++;\\n                    }\\n                } else { // This tells us that there\\'s a \" ) ( \" closing & opening\\n                    if (count > 0) {\\n                        // check if there\\'s is a opening or not i.e ( )(\\n                        count--;\\n                        ans++;\\n                    } else {\\n                        // there\\'s is not opening i.e )(\\n                        ans += 2;\\n                    }\\n                }\\n            }\\n        }\\n        // why we;re doing x2 because for every ( we need )) to balance\\n        ans = ans + (count * 2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        // n equal to the size of the array\\n        int n = s.length();\\n        // 2 variables count & ans\\n        int count = 0;\\n        int ans = 0;\\n        // Traverse the array\\n        for (int i = 0; i < n; i++) {\\n            // if we found \\'(\\' in array we\\'ll increase the count\\n            if (s[i] == \\'(\\') {\\n                count++;\\n            } else { // s[i] == \\')\\'\\n                // check if the next is also \\')\\'\\n                if (i + 1 < n && s[i + 1] == \\')\\') {\\n                    // move i ahead\\n                    i++;\\n                    // if there\\'s \\'(\\' present i.e count > 0 : ( ))\\n                    if (count > 0) {\\n                        count--;\\n                    } else {\\n                        // \\'(\\' is not present we\\'ll add 1 to the ans\\n                        ans++;\\n                    }\\n                } else { // This tells us that there\\'s a \" ) ( \" closing & opening\\n                    if (count > 0) {\\n                        // check if there\\'s is a opening or not i.e ( )(\\n                        count--;\\n                        ans++;\\n                    } else {\\n                        // there\\'s is not opening i.e )(\\n                        ans += 2;\\n                    }\\n                }\\n            }\\n        }\\n        // why we;re doing x2 because for every ( we need )) to balance\\n        ans = ans + (count * 2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908008,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve the problem using only Stack.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n     public int minInsertions(String s) { Stack<Character> stack = new Stack<>();\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\')\\'){\\n                if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){\\n                    i++;\\n                    if(!stack.isEmpty()){\\n                        stack.pop();\\n                    }else{\\n                        ans++;\\n                    }\\n                    }else{\\n                    if(!stack.isEmpty()){\\n                        stack.pop();\\n                        ans++;\\n                    }else{// it means that the first element is ) and then the elements ar ()())\\n                        ans+=2;\\n                    }\\n                }\\n                }else{\\n                stack.push(s.charAt(i));\\n            }\\n            }\\n        return ans+=(2*stack.size());\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int minInsertions(String s) { Stack<Character> stack = new Stack<>();\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\')\\'){\\n                if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){\\n                    i++;\\n                    if(!stack.isEmpty()){\\n                        stack.pop();\\n                    }else{\\n                        ans++;\\n                    }\\n                    }else{\\n                    if(!stack.isEmpty()){\\n                        stack.pop();\\n                        ans++;\\n                    }else{// it means that the first element is ) and then the elements ar ()())\\n                        ans+=2;\\n                    }\\n                }\\n                }else{\\n                stack.push(s.charAt(i));\\n            }\\n            }\\n        return ans+=(2*stack.size());\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906554,
                "title": "c-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string modified = \"\";\\n        int count = 0;\\n        int n = s.length();\\n        int i = 0;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                modified.push_back(\\'(\\');\\n                i++;\\n            }\\n            else\\n            {\\n                if(i+1<n && s[i+1]==\\')\\')\\n                {\\n                    modified.push_back(\\')\\');\\n                    i = i+2;\\n                }\\n                else\\n                {\\n                    modified.push_back(\\')\\');\\n                    count++;\\n                    i = i+1;\\n                }\\n            }\\n        }\\n        priority_queue<int> st;\\n        for(int j=0;j<modified.length();j++)\\n        {\\n            if(modified[j]==\\'(\\')\\n            {\\n                st.push(j);\\n            }\\n            else\\n            {\\n               if(!st.empty())\\n               {\\n                   st.pop();\\n               }\\n               else\\n               {\\n                   count++;\\n               }\\n            }\\n        }\\n\\n        if(st.size()>0)\\n        count+=2*st.size();\\n\\n        return  count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string modified = \"\";\\n        int count = 0;\\n        int n = s.length();\\n        int i = 0;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                modified.push_back(\\'(\\');\\n                i++;\\n            }\\n            else\\n            {\\n                if(i+1<n && s[i+1]==\\')\\')\\n                {\\n                    modified.push_back(\\')\\');\\n                    i = i+2;\\n                }\\n                else\\n                {\\n                    modified.push_back(\\')\\');\\n                    count++;\\n                    i = i+1;\\n                }\\n            }\\n        }\\n        priority_queue<int> st;\\n        for(int j=0;j<modified.length();j++)\\n        {\\n            if(modified[j]==\\'(\\')\\n            {\\n                st.push(j);\\n            }\\n            else\\n            {\\n               if(!st.empty())\\n               {\\n                   st.pop();\\n               }\\n               else\\n               {\\n                   count++;\\n               }\\n            }\\n        }\\n\\n        if(st.size()>0)\\n        count+=2*st.size();\\n\\n        return  count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880202,
                "title": "simple-stack-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) \\n    {\\n       Stack<Character> ss=new Stack<>();\\n       int co=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           char c=s.charAt(i);\\n           if(c==\\'(\\')\\n           {\\n             ss.push(c);\\n           }\\n           else\\n           {\\n             if(ss.size() > 0 && ss.peek() == \\'(\\')\\n             {\\n                 if(i < s.length()-1 && s.charAt(i+1) == \\')\\')\\n                {\\n                  i++;\\n                  ss.pop();\\n                }\\n                else\\n                {\\n                  co++;\\n                  ss.pop();\\n                }\\n             }\\n             else\\n             {\\n                if(i < s.length()-1 && s.charAt(i+1) == \\')\\')\\n                {\\n                  co++;\\n                  i++;\\n                }\\n                else\\n                {\\n                  co+=2;\\n                }\\n             }\\n           }\\n       }\\n       return co+(ss.size()*2); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) \\n    {\\n       Stack<Character> ss=new Stack<>();\\n       int co=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           char c=s.charAt(i);\\n           if(c==\\'(\\')\\n           {\\n             ss.push(c);\\n           }\\n           else\\n           {\\n             if(ss.size() > 0 && ss.peek() == \\'(\\')\\n             {\\n                 if(i < s.length()-1 && s.charAt(i+1) == \\')\\')\\n                {\\n                  i++;\\n                  ss.pop();\\n                }\\n                else\\n                {\\n                  co++;\\n                  ss.pop();\\n                }\\n             }\\n             else\\n             {\\n                if(i < s.length()-1 && s.charAt(i+1) == \\')\\')\\n                {\\n                  co++;\\n                  i++;\\n                }\\n                else\\n                {\\n                  co+=2;\\n                }\\n             }\\n           }\\n       }\\n       return co+(ss.size()*2); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863528,
                "title": "java-solution-using-stacks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n\\n        Stack<Character> st = new Stack<>();\\n        int n = s.length();\\n\\n        int ans = 0;\\n        int k = 0;\\n\\n        for(int i=0; i<n-1; i++){\\n            char ch = s.charAt(i);\\n            if(ch==\\'(\\') st.push(ch);\\n            else{\\n                char x = s.charAt(i+1);\\n                if(x==\\')\\'){\\n                    if(st.size()==0) ans++;\\n                        else st.pop();\\n                        i++;\\n                        if(i==n-1) k=1;\\n                    }else{\\n                        if(st.size()==0) ans+=2;\\n                    else{\\n                        ans++;\\n                        st.pop();\\n                    }\\n                }\\n            }\\n        }\\n\\n        int a = st.size();\\n        char x = s.charAt(n-1);\\n\\n        if(k==0){\\n            if(x==\\'(\\') ans=ans+2;\\n        else{\\n            if(a!=0){\\n                ans++;\\n                a--;\\n            }else{\\n                ans+=2;\\n            }\\n        }\\n        }\\n        \\n        ans=ans+2*a;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n\\n        Stack<Character> st = new Stack<>();\\n        int n = s.length();\\n\\n        int ans = 0;\\n        int k = 0;\\n\\n        for(int i=0; i<n-1; i++){\\n            char ch = s.charAt(i);\\n            if(ch==\\'(\\') st.push(ch);\\n            else{\\n                char x = s.charAt(i+1);\\n                if(x==\\')\\'){\\n                    if(st.size()==0) ans++;\\n                        else st.pop();\\n                        i++;\\n                        if(i==n-1) k=1;\\n                    }else{\\n                        if(st.size()==0) ans+=2;\\n                    else{\\n                        ans++;\\n                        st.pop();\\n                    }\\n                }\\n            }\\n        }\\n\\n        int a = st.size();\\n        char x = s.charAt(n-1);\\n\\n        if(k==0){\\n            if(x==\\'(\\') ans=ans+2;\\n        else{\\n            if(a!=0){\\n                ans++;\\n                a--;\\n            }else{\\n                ans+=2;\\n            }\\n        }\\n        }\\n        \\n        ans=ans+2*a;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853124,
                "title": "python-beats-98-one-pass-stack",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        closingPCount = 0\\n        stack = deque()\\n        insertions = 0\\n        for c in s:\\n            if c == \"(\":\\n                if closingPCount == 1:\\n                    insertions += 1\\n                    closingPCount = 0\\n                    if stack:\\n                        stack.pop()\\n                    else:\\n                        insertions += 1\\n                stack.append(c)\\n            else:\\n                if closingPCount == 0:\\n                    closingPCount += 1\\n                else:\\n                    if stack:\\n                        stack.pop()\\n                    else:\\n                        insertions += 1\\n                    closingPCount = 0\\n        \\n        if closingPCount == 1:\\n            insertions += 1\\n            if stack:\\n                stack.pop()\\n            else:\\n                insertions += 1\\n        \\n        return insertions + len(stack)*2\\n                    \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        closingPCount = 0\\n        stack = deque()\\n        insertions = 0\\n        for c in s:\\n            if c == \"(\":\\n                if closingPCount == 1:\\n                    insertions += 1\\n                    closingPCount = 0\\n                    if stack:\\n                        stack.pop()\\n                    else:\\n                        insertions += 1\\n                stack.append(c)\\n            else:\\n                if closingPCount == 0:\\n                    closingPCount += 1\\n                else:\\n                    if stack:\\n                        stack.pop()\\n                    else:\\n                        insertions += 1\\n                    closingPCount = 0\\n        \\n        if closingPCount == 1:\\n            insertions += 1\\n            if stack:\\n                stack.pop()\\n            else:\\n                insertions += 1\\n        \\n        return insertions + len(stack)*2\\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 3805390,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:      \\n        s = s.replace(\\'))\\', \\'}\\')\\n        missing_brackets = 0\\n        required_closed = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                required_closed += 2 \\n            else: \\n                if c == \\')\\': \\n                    missing_brackets += 1\\n                if required_closed:\\n                    required_closed -= 2\\n                else:\\n                    missing_brackets += 1\\n        return missing_brackets + required_closed\\n\\n\\n        # o=0\\n        # c=0\\n        # for i in s:\\n        #     if(i==\"(\"):\\n        #         o+=1\\n        #     else:\\n        #         if(o):\\n        #             o-=1\\n        #         else:\\n        #             c+=1\\n        # return(o+c)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:      \\n        s = s.replace(\\'))\\', \\'}\\')\\n        missing_brackets = 0\\n        required_closed = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                required_closed += 2 \\n            else: \\n                if c == \\')\\': \\n                    missing_brackets += 1\\n                if required_closed:\\n                    required_closed -= 2\\n                else:\\n                    missing_brackets += 1\\n        return missing_brackets + required_closed\\n\\n\\n        # o=0\\n        # c=0\\n        # for i in s:\\n        #     if(i==\"(\"):\\n        #         o+=1\\n        #     else:\\n        #         if(o):\\n        #             o-=1\\n        #         else:\\n        #             c+=1\\n        # return(o+c)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769398,
                "title": "dart-solution",
                "content": "# Intuition\\n\\n1. Consecutive `)` must be even count.\\n2. When it\\'s imbalanced, add `(`.\\n3. If there are outstanding `(`, add `))` at the end.\\n\\n# Code\\n```\\nclass StrCount {\\n  final String letter;\\n  final int count;\\n  const StrCount(this.letter, this.count);\\n}\\nclass Solution {\\n  int minInsertions(String s) {\\n    List<StrCount> counts = [];\\n    for (int i = 0; i < s.length; i++) {\\n      final begin = i;\\n      while (i + 1 < s.length && s[i + 1] == s[begin]) i++;\\n      counts.add(StrCount(s[begin], i + 1 - begin));\\n    }\\n    var sum = 0;\\n    var res = 0;\\n    for (final sc in counts) {\\n      if (sc.letter == \\'(\\') {\\n        sum += sc.count;\\n      } else {\\n        if (sc.count % 2 == 1)\\n          res++;\\n        final closers = (sc.count + 1) ~/ 2;\\n        sum -= closers;\\n        if (sum < 0) {\\n          res -= sum;\\n          sum = 0;\\n        }\\n      }\\n    }\\n    if (sum > 0) res += 2 * sum;\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass StrCount {\\n  final String letter;\\n  final int count;\\n  const StrCount(this.letter, this.count);\\n}\\nclass Solution {\\n  int minInsertions(String s) {\\n    List<StrCount> counts = [];\\n    for (int i = 0; i < s.length; i++) {\\n      final begin = i;\\n      while (i + 1 < s.length && s[i + 1] == s[begin]) i++;\\n      counts.add(StrCount(s[begin], i + 1 - begin));\\n    }\\n    var sum = 0;\\n    var res = 0;\\n    for (final sc in counts) {\\n      if (sc.letter == \\'(\\') {\\n        sum += sc.count;\\n      } else {\\n        if (sc.count % 2 == 1)\\n          res++;\\n        final closers = (sc.count + 1) ~/ 2;\\n        sum -= closers;\\n        if (sum < 0) {\\n          res -= sum;\\n          sum = 0;\\n        }\\n      }\\n    }\\n    if (sum > 0) res += 2 * sum;\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756296,
                "title": "easy-python3-solution-with-an-explanation",
                "content": "\\n# Approach\\nHere is an approach to understand how the code works:\\n\\n1. Iterate through the characters of the string using a while loop until i reaches the end of the string.\\n\\n2. If openBrackets is greater than 0 and ch is equal to \\')\\', it means there are open parentheses that need to be closed.\\n\\n    - If the next character s[i+1] is also \\')\\', it means there is a pair of closing parentheses. In this case, decrease minimumInsertions by 2 to account for the pair and increment i by 2 to skip the next character.\\n    - Otherwise, there is a single closing parenthesis. Increment i by 1 and decrease minimumInsertions by 1 to account for the single closing parenthesis.\\n    - Decrement openBrackets by 1 since a closing parenthesis has been balanced.\\n3. If ch is equal to \\')\\', but the above condition is not met, it means there is an unbalanced closing parenthesis.\\n\\n    - If the next character s[i+1] is also \\')\\', it means there is a pair of closing parentheses. In this case, increment minimumInsertions by 1 to account for adding an opening parenthesis, and increment i by 2 to skip the next character.\\n    - Otherwise, there is a single closing parenthesis. Increment minimumInsertions by 2 to account for adding an opening and closing parenthesis, and increment i by 1.\\n4. If ch is equal to \\'(\\', it means there is an opening parenthesis that needs to be closed.\\n\\n    - Increment openBrackets by 1 to keep track of the open parentheses.\\n    - Increment minimumInsertions by 2 to account for adding a closing parenthesis.\\n    - Increment i by 1.\\n5. After the loop ends, return the value of minimumInsertions, which represents the minimum number of insertions required to balance the parentheses in the string.\\n\\nThis approach ensures that the parentheses are balanced by inserting the minimum number of additional parentheses. The algorithm scans the string from left to right and maintains a count of open parentheses encountered. It adjusts the count and the number of insertions based on the encountered characters.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        openBrackets = 0\\n        minimumInsertions = 0\\n        i = 0\\n        n = len(s)\\n\\n        while i < n:\\n            ch = s[i]\\n\\n            if openBrackets > 0 and ch == \\')\\': \\n                if i + 1 < n and s[i + 1] == \\')\\':                    \\n                    minimumInsertions -= 2\\n                    i += 2\\n                else:\\n                    i += 1\\n                    minimumInsertions -= 1\\n                openBrackets -= 1\\n            elif ch == \\')\\':\\n                if i + 1 < n and s[i + 1] == \\')\\':\\n                    minimumInsertions += 1\\n                    i += 2\\n                else:\\n                    minimumInsertions += 2\\n                    i += 1\\n            elif ch == \\'(\\':\\n                openBrackets += 1\\n                minimumInsertions += 2\\n                i += 1\\n\\n        return minimumInsertions\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        openBrackets = 0\\n        minimumInsertions = 0\\n        i = 0\\n        n = len(s)\\n\\n        while i < n:\\n            ch = s[i]\\n\\n            if openBrackets > 0 and ch == \\')\\': \\n                if i + 1 < n and s[i + 1] == \\')\\':                    \\n                    minimumInsertions -= 2\\n                    i += 2\\n                else:\\n                    i += 1\\n                    minimumInsertions -= 1\\n                openBrackets -= 1\\n            elif ch == \\')\\':\\n                if i + 1 < n and s[i + 1] == \\')\\':\\n                    minimumInsertions += 1\\n                    i += 2\\n                else:\\n                    minimumInsertions += 2\\n                    i += 1\\n            elif ch == \\'(\\':\\n                openBrackets += 1\\n                minimumInsertions += 2\\n                i += 1\\n\\n        return minimumInsertions\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659026,
                "title": "python3-following-the-hints",
                "content": "# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        ans = 0\\n        st = []\\n        leftCnt = 0\\n        i = 0\\n        while i < len(s):\\n            if s[i]==\\'(\\':\\n                leftCnt += 1\\n            else:\\n                if i+1 < len(s) and s[i+1]==\\')\\':\\n                    if leftCnt > 0:\\n                        leftCnt -= 1\\n                    else:\\n                        ans += 1\\n                    i += 2\\n                    continue\\n                else:\\n                    ans += 1\\n                    if leftCnt > 0:\\n                        leftCnt -= 1\\n                    else:\\n                        ans += 1\\n            i += 1\\n\\n        ans += leftCnt*2\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        ans = 0\\n        st = []\\n        leftCnt = 0\\n        i = 0\\n        while i < len(s):\\n            if s[i]==\\'(\\':\\n                leftCnt += 1\\n            else:\\n                if i+1 < len(s) and s[i+1]==\\')\\':\\n                    if leftCnt > 0:\\n                        leftCnt -= 1\\n                    else:\\n                        ans += 1\\n                    i += 2\\n                    continue\\n                else:\\n                    ans += 1\\n                    if leftCnt > 0:\\n                        leftCnt -= 1\\n                    else:\\n                        ans += 1\\n            i += 1\\n\\n        ans += leftCnt*2\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614434,
                "title": "easy-c-with-or-without-stack-beats-100",
                "content": "\\n1.  Using stack\\n```\\nclass Solution {\\npublic:\\n    \\n    int minInsertions(string s) \\n    {\\n        stack<char>st;\\n        int cnt=0, n=s.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            char c=s[i];\\n            if(c==\\'(\\')\\n                st.push(c);\\n            else\\n            {\\n                if(i==n-1 || s[i+1]!=\\')\\') cnt++;\\n                else i++;\\n                \\n                if(st.empty() || st.top()!=\\'(\\') cnt++;\\n                else st.pop();\\n            }\\n        }\\n        \\n        return cnt+ 2*st.size();\\n    }\\n};\\n\\n```\\n2. No stack , keep count of unbalanced open brackets \\n```\\nclass Solution {\\npublic:\\n    \\n    int minInsertions(string s) \\n    {\\n        int open=0;\\n        int cnt=0, n=s.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            char c=s[i];\\n            if(c==\\'(\\')\\n                open++;\\n            else\\n            {\\n                if(i==n-1 || s[i+1]!=\\')\\') cnt++;\\n                else i++;\\n                \\n                if(open==0) cnt++;\\n                else open--;\\n            }\\n        }\\n        \\n        return cnt+ 2*open;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minInsertions(string s) \\n    {\\n        stack<char>st;\\n        int cnt=0, n=s.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            char c=s[i];\\n            if(c==\\'(\\')\\n                st.push(c);\\n            else\\n            {\\n                if(i==n-1 || s[i+1]!=\\')\\') cnt++;\\n                else i++;\\n                \\n                if(st.empty() || st.top()!=\\'(\\') cnt++;\\n                else st.pop();\\n            }\\n        }\\n        \\n        return cnt+ 2*st.size();\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int minInsertions(string s) \\n    {\\n        int open=0;\\n        int cnt=0, n=s.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            char c=s[i];\\n            if(c==\\'(\\')\\n                open++;\\n            else\\n            {\\n                if(i==n-1 || s[i+1]!=\\')\\') cnt++;\\n                else i++;\\n                \\n                if(open==0) cnt++;\\n                else open--;\\n            }\\n        }\\n        \\n        return cnt+ 2*open;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608373,
                "title": "1541-my-java-solution-with-comments",
                "content": "This is an extension quesion of LeetCode 921\\n\\n# Code\\n```java\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int needP = 0, putP = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char p = s.charAt(i);\\n            if (p == \\'(\\') {\\n                // if we see a left p\\n                // expect 2 right p in the future string\\n                needP += 2;\\n                if (needP %2 == 1) {\\n                // needP must be even, because for a left p, it must come with 2 consecutive right p\\n                // so we should PUT a right P in this case\\n                // since we put a right p, we need one less right p\\n                    needP--;\\n                    putP++;\\n                }\\n            } else {\\n                // p == \\')\\', consume needRight if we still have it >0\\n                if(needP > 0) {\\n                    needP--;\\n                } else {\\n                // needP==0, but we see a right p here,\\n                // so we need a pair of ()\\n                // we firstly PUT a left p, and we expect a right p in the future\\n                // the key idea shows again, we always expect a right p will appear in the future char\\n                // that\\'s why for right p, we make it in needP variable, while for left p, we make it in putP variable\\n                    putP++;\\n                    needP = 1;\\n                }\\n\\n            }\\n        }\\n        return needP+putP;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int needP = 0, putP = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char p = s.charAt(i);\\n            if (p == \\'(\\') {\\n                // if we see a left p\\n                // expect 2 right p in the future string\\n                needP += 2;\\n                if (needP %2 == 1) {\\n                // needP must be even, because for a left p, it must come with 2 consecutive right p\\n                // so we should PUT a right P in this case\\n                // since we put a right p, we need one less right p\\n                    needP--;\\n                    putP++;\\n                }\\n            } else {\\n                // p == \\')\\', consume needRight if we still have it >0\\n                if(needP > 0) {\\n                    needP--;\\n                } else {\\n                // needP==0, but we see a right p here,\\n                // so we need a pair of ()\\n                // we firstly PUT a left p, and we expect a right p in the future\\n                // the key idea shows again, we always expect a right p will appear in the future char\\n                // that\\'s why for right p, we make it in needP variable, while for left p, we make it in putP variable\\n                    putP++;\\n                    needP = 1;\\n                }\\n\\n            }\\n        }\\n        return needP+putP;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590920,
                "title": "c-easy-approach-simple-if-else-conditions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int c=0;\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\') st.push(s[i]);\\n            else if(s[i]==\\')\\' && s[i+1]==\\')\\' && !st.empty())\\n            {\\n                st.pop();\\n                i++;\\n            }\\n            else if(s[i]==\\')\\' && s[i+1]==\\')\\' && st.empty())\\n            {\\n                c+=1;\\n                i++;\\n            }\\n            else if(s[i]==\\')\\' && (s[i+1]==\\'(\\' || i==s.size()-1))\\n            {\\n                if(st.empty()) c+=2;\\n                else\\n                {\\n                    st.pop();\\n                    c+=1;\\n                }\\n            }\\n        }\\n        if(!st.empty()) c+=2*st.size();\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int c=0;\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\') st.push(s[i]);\\n            else if(s[i]==\\')\\' && s[i+1]==\\')\\' && !st.empty())\\n            {\\n                st.pop();\\n                i++;\\n            }\\n            else if(s[i]==\\')\\' && s[i+1]==\\')\\' && st.empty())\\n            {\\n                c+=1;\\n                i++;\\n            }\\n            else if(s[i]==\\')\\' && (s[i+1]==\\'(\\' || i==s.size()-1))\\n            {\\n                if(st.empty()) c+=2;\\n                else\\n                {\\n                    st.pop();\\n                    c+=1;\\n                }\\n            }\\n        }\\n        if(!st.empty()) c+=2*st.size();\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568091,
                "title": "easy-stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npush \"(\" unitl \"))\" found, then pop. if not able to pop according to rule increase the count.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<int> st;\\n        int count = 0;\\n        for(int i = 0; i < s.length();){\\n            if(s[i] == \\'(\\'){\\n                st.push(s[i]);\\n                i++;\\n            }\\n            else{\\n                if(st.empty()){\\n                    if(i+1 < s.length() && s[i+1]==\\')\\')\\n                        {\\n                            count = count+1;\\n                            i = i+2;\\n                        }\\n                        else{\\n                            count = count+2;\\n                            i += 1;\\n                        }\\n                }\\n                else{\\n                    if(i+1 < s.length() && s[i+1] == \\')\\')\\n                        {\\n                            st.pop();\\n                            i += 2;\\n                        }\\n                    else{\\n                        st.pop();\\n                        count+=1;\\n                        i++;\\n                    }\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            count+=2;\\n            st.pop();\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<int> st;\\n        int count = 0;\\n        for(int i = 0; i < s.length();){\\n            if(s[i] == \\'(\\'){\\n                st.push(s[i]);\\n                i++;\\n            }\\n            else{\\n                if(st.empty()){\\n                    if(i+1 < s.length() && s[i+1]==\\')\\')\\n                        {\\n                            count = count+1;\\n                            i = i+2;\\n                        }\\n                        else{\\n                            count = count+2;\\n                            i += 1;\\n                        }\\n                }\\n                else{\\n                    if(i+1 < s.length() && s[i+1] == \\')\\')\\n                        {\\n                            st.pop();\\n                            i += 2;\\n                        }\\n                    else{\\n                        st.pop();\\n                        count+=1;\\n                        i++;\\n                    }\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            count+=2;\\n            st.pop();\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554070,
                "title": "simple-implementation-without-stack-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinInsertions(string s) {\\n        int openCount = 0;\\n        int minInsertion = 0;\\n        int n = s.Length;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'(\\'){\\n                ++openCount;\\n                continue;\\n            }\\n\\n            if(openCount == 0)\\n                ++minInsertion;\\n            else\\n                --openCount;\\n\\n            if(i == n-1){\\n                ++minInsertion;\\n            }\\n            else{\\n                if(s[i+1] != \\')\\')\\n                    ++minInsertion;\\n                else\\n                    ++i;\\n            }  \\n        }\\n\\n        return minInsertion + (2 * openCount);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinInsertions(string s) {\\n        int openCount = 0;\\n        int minInsertion = 0;\\n        int n = s.Length;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'(\\'){\\n                ++openCount;\\n                continue;\\n            }\\n\\n            if(openCount == 0)\\n                ++minInsertion;\\n            else\\n                --openCount;\\n\\n            if(i == n-1){\\n                ++minInsertion;\\n            }\\n            else{\\n                if(s[i+1] != \\')\\')\\n                    ++minInsertion;\\n                else\\n                    ++i;\\n            }  \\n        }\\n\\n        return minInsertion + (2 * openCount);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538705,
                "title": "easy-to-understand-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        res, need = 0,0\\n        for i in s:\\n            if i==\\'(\\':\\n                need+=2\\n                if need%2==1:\\n                    res+=1\\n                    need-=1\\n            if i == \\')\\':\\n                need-=1\\n                if need==-1:\\n                    res+=1\\n                    need=1\\n\\n        return res+need\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        res, need = 0,0\\n        for i in s:\\n            if i==\\'(\\':\\n                need+=2\\n                if need%2==1:\\n                    res+=1\\n                    need-=1\\n            if i == \\')\\':\\n                need-=1\\n                if need==-1:\\n                    res+=1\\n                    need=1\\n\\n        return res+need\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527872,
                "title": "java-simple-solution-greedy-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        int pCount = 0;\\n        for(int i=0;i<n;i++) {\\n            if(s.charAt(i) == \\'(\\')\\n                pCount++;\\n            else {\\n                if(pCount > 0) {\\n                    pCount--;\\n                    if(i+1<n && s.charAt(i+1) == \\')\\')\\n                        i++;\\n                    else\\n                        ans++;\\n                }\\n                else {\\n                    ans++;\\n                    if(i+1>=n || s.charAt(i+1) != \\')\\')\\n                        ans++;\\n                    else\\n                        i++;\\n                }\\n            }\\n        }\\n        \\n        if(pCount > 0)\\n            ans += 2*pCount;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        int pCount = 0;\\n        for(int i=0;i<n;i++) {\\n            if(s.charAt(i) == \\'(\\')\\n                pCount++;\\n            else {\\n                if(pCount > 0) {\\n                    pCount--;\\n                    if(i+1<n && s.charAt(i+1) == \\')\\')\\n                        i++;\\n                    else\\n                        ans++;\\n                }\\n                else {\\n                    ans++;\\n                    if(i+1>=n || s.charAt(i+1) != \\')\\')\\n                        ans++;\\n                    else\\n                        i++;\\n                }\\n            }\\n        }\\n        \\n        if(pCount > 0)\\n            ans += 2*pCount;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502132,
                "title": "one-pass-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n    Stack<Character>st=new Stack<>();\\n    int count=0;\\n    for(int i=0;i<s.length();){\\n    if(s.charAt(i)==\\')\\'&&st.isEmpty()){\\n        if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){\\n            count+=1;\\n            i+=2;\\n        }\\n        else{\\n            count+=2;\\n            i+=1;\\n        }\\n    }\\n    else if(s.charAt(i)==\\'(\\'){\\n        st.add(s.charAt(i));\\n        i++;\\n    }\\n    else{\\n    if(i+1>=s.length()||s.charAt(i+1)!=\\')\\'){\\n            count+=1;\\n            if(i+1<s.length())i+=1;\\n            else \\n            {\\n            st.pop();\\n            break;\\n            }\\n    }\\n    else{\\n        i+=2;\\n    }\\n    st.pop();\\n    }\\n    \\n    }\\n\\n    count=count+(st.size()*2);\\n\\n    return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n    Stack<Character>st=new Stack<>();\\n    int count=0;\\n    for(int i=0;i<s.length();){\\n    if(s.charAt(i)==\\')\\'&&st.isEmpty()){\\n        if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){\\n            count+=1;\\n            i+=2;\\n        }\\n        else{\\n            count+=2;\\n            i+=1;\\n        }\\n    }\\n    else if(s.charAt(i)==\\'(\\'){\\n        st.add(s.charAt(i));\\n        i++;\\n    }\\n    else{\\n    if(i+1>=s.length()||s.charAt(i+1)!=\\')\\'){\\n            count+=1;\\n            if(i+1<s.length())i+=1;\\n            else \\n            {\\n            st.pop();\\n            break;\\n            }\\n    }\\n    else{\\n        i+=2;\\n    }\\n    st.pop();\\n    }\\n    \\n    }\\n\\n    count=count+(st.size()*2);\\n\\n    return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496694,
                "title": "without-stack-c-solution-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int a = 0;\\n        int ans = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                a++;\\n            }\\n            else{\\n                if(a>0 && s[i]==\\')\\' && s[i+1]==\\')\\'){\\n                    a--;\\n                    i++;\\n                }\\n                else if(a>0 && s[i+1]!=\\')\\'){\\n                    ans++;\\n                    a--;\\n                }\\n                else if(a==0 && s[i+1]==\\')\\'){\\n                    i++;\\n                    ans++;\\n                }\\n                else{\\n                    ans+=2;\\n                }\\n            }\\n        }\\n        return 2*a + ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int a = 0;\\n        int ans = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                a++;\\n            }\\n            else{\\n                if(a>0 && s[i]==\\')\\' && s[i+1]==\\')\\'){\\n                    a--;\\n                    i++;\\n                }\\n                else if(a>0 && s[i+1]!=\\')\\'){\\n                    ans++;\\n                    a--;\\n                }\\n                else if(a==0 && s[i+1]==\\')\\'){\\n                    i++;\\n                    ans++;\\n                }\\n                else{\\n                    ans+=2;\\n                }\\n            }\\n        }\\n        return 2*a + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483963,
                "title": "no-need-of-stack-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n\\n      int count=0;\\n\\tint ans=0;\\n\\t\\n\\t\\n\\tfor(int i=0; i< s.length(); i++) {\\n\\t\\t\\t\\n\\t\\tif(s.charAt(i)== \\'(\\') {  // if any opening brace is found, push it in the stack\\n\\t\\t\\tcount++; }\\n\\t\\t\\n\\t\\telse {\\n\\t\\t\\tif(i+1<s.length() && s.charAt(i+1) ==\\')\\') {\\n\\t\\t\\t\\tif(count>0) {\\n\\t\\t\\t\\t\\tcount--;}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tans++;}\\n\\t                i++;}\\n\\t\\t\\t\\n\\t\\t\\telse {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(count>0) {\\n\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\tans++; }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tans+=2;}    }}}\\n\\t\\t\\t\\n\\t\\n\\treturn ans+ count*2;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n\\n      int count=0;\\n\\tint ans=0;\\n\\t\\n\\t\\n\\tfor(int i=0; i< s.length(); i++) {\\n\\t\\t\\t\\n\\t\\tif(s.charAt(i)== \\'(\\') {  // if any opening brace is found, push it in the stack\\n\\t\\t\\tcount++; }\\n\\t\\t\\n\\t\\telse {\\n\\t\\t\\tif(i+1<s.length() && s.charAt(i+1) ==\\')\\') {\\n\\t\\t\\t\\tif(count>0) {\\n\\t\\t\\t\\t\\tcount--;}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tans++;}\\n\\t                i++;}\\n\\t\\t\\t\\n\\t\\t\\telse {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(count>0) {\\n\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\tans++; }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tans+=2;}    }}}\\n\\t\\t\\t\\n\\t\\n\\treturn ans+ count*2;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447656,
                "title": "c-stack-easy-o-n-o-n",
                "content": "# Intuition - Idea is every \\')\\' should be enclosed by \\'(\\' and \\')\\'\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach - \\n    1. Use a stack to store every \\'(\\'\\n    2. On \\')\\', initially consider no \\'(\\' and \\')\\' enclosing it, hence ops = 2, if there is \\'(\\' on top of stack, ops = 1 and also if there is \\')\\' after current char, ops = 0.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> st;\\n        int ans = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'(\\') {\\n                st.push(s[i]);\\n            } else {\\n                // initially consider no \\'(\\' and \\')\\' enclosing a \\')\\', ops = 2\\n                int currInc = 2;\\n                if(i+1 < s.size() && s[i+1] == \\')\\') {\\n                    currInc--;\\n                    i++;\\n                }\\n                if(st.size() > 0 && st.top() == \\'(\\') {\\n                    st.pop(); currInc--;\\n                }\\n                ans += currInc;\\n            }\\n        }\\n\\n        return ans + 2 * st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> st;\\n        int ans = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'(\\') {\\n                st.push(s[i]);\\n            } else {\\n                // initially consider no \\'(\\' and \\')\\' enclosing a \\')\\', ops = 2\\n                int currInc = 2;\\n                if(i+1 < s.size() && s[i+1] == \\')\\') {\\n                    currInc--;\\n                    i++;\\n                }\\n                if(st.size() > 0 && st.top() == \\'(\\') {\\n                    st.pop(); currInc--;\\n                }\\n                ans += currInc;\\n            }\\n        }\\n\\n        return ans + 2 * st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422363,
                "title": "java-3-approaches",
                "content": "# Intuition\\nFirst I thought tocode like this but somewhere I was getting lost in handling \\')\\'.\\n\\n```class Solution {\\n    public int minInsertions(String s) {\\n        String s1 = s.replace(\"))\", \"}\");\\n        System.out.println(s1);\\n        \\n        Stack<Character> stk = new Stack<>();\\n\\n        for(int i=0; i<s1.length(); i++){\\n            if(s1.charAt(i) == \\'}\\'){\\n                if(!stk.empty() && stk.peek() ==\\'(\\'){\\n                    stk.pop();\\n                }else{\\n                    stk.push(s1.charAt(i));\\n                }\\n            }else{\\n                stk.push(s1.charAt(i));\\n            }\\n        }\\n        System.out.println(stk);\\n        int count =0;\\n        while(!stk.empty()){\\n            System.out.println(stk.peek());\\n            if(stk.peek() == \\'(\\'){\\n                count += 2;\\n                stk.pop();\\n                System.out.println(count);\\n            }else if(stk.peek() == \\'}\\'){\\n                count +=1;\\n                stk.pop();\\n                System.out.println(count);\\n            }else{\\n                count --;\\n            }\\n            stk.pop();\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Approach\\n( -> ))\\na single opening bracket requires two closing brackets\\n\\n# Complexity\\n- Time complexity:O(n)\\n \\n# Code\\n\\n- <h5>Least efficient (using stack):</h5>\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int count =0;\\n        Stack<Character> stack = new Stack<>();\\n        for(int i =0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\')\\'){\\n                if(!stack.empty() && stack.peek() == \\'(\\'){\\n                    stack.pop();\\n                }else{\\n                    count ++;\\n                }\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                }else{\\n                    count ++;\\n                }\\n            }else{\\n                stack.push(ch);\\n            }\\n        }\\n        //System.out.print(stack);\\n        return count + stack.size()*2;        \\n    }\\n}\\n```\\n\\n- <h5>Better (using string):</h5>\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int right =0;\\n        int left =0;\\n        for(int i =0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\')\\'){\\n                if(left ==0){\\n                    right++;\\n                }else{\\n                    left--;\\n                }\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                }else{\\n                    right++;\\n                }\\n            }else{\\n                left++;\\n            }\\n        }\\n        return right + left*2;        \\n    }\\n}\\n```\\n\\n- <h5>Better (1ms difference by just exchanging if and else condition):</h5>\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int right =0;\\n        int left =0;\\n        for(int i =0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                left++;\\n            }else{\\n                if(left ==0){\\n                    right++;\\n                }else{\\n                    left--;\\n                }\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                }else{\\n                    right++;\\n                }\\n            }\\n        }\\n            \\n        return right + left*2;        \\n    }\\n}\\n```\\n\\n- <h5>Best (Using char array):</h5>\\n\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int right =0;\\n        int left =0;\\n        char[] ch = s.toCharArray();\\n        for(int i =0; i<s.length(); i++){\\n            if(ch[i] == \\'(\\'){\\n                left++;\\n            }else{\\n                if(left ==0){\\n                    right++;\\n                }else{\\n                    left--;\\n                }\\n                if(i+1<s.length() && ch[i+1] == \\')\\'){\\n                    i++;\\n                }else{\\n                    right++;\\n                }\\n            }\\n        }\\n            \\n        return right + left*2;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "String",
                    "Stack"
                ],
                "code": "```class Solution {\\n    public int minInsertions(String s) {\\n        String s1 = s.replace(\"))\", \"}\");\\n        System.out.println(s1);\\n        \\n        Stack<Character> stk = new Stack<>();\\n\\n        for(int i=0; i<s1.length(); i++){\\n            if(s1.charAt(i) == \\'}\\'){\\n                if(!stk.empty() && stk.peek() ==\\'(\\'){\\n                    stk.pop();\\n                }else{\\n                    stk.push(s1.charAt(i));\\n                }\\n            }else{\\n                stk.push(s1.charAt(i));\\n            }\\n        }\\n        System.out.println(stk);\\n        int count =0;\\n        while(!stk.empty()){\\n            System.out.println(stk.peek());\\n            if(stk.peek() == \\'(\\'){\\n                count += 2;\\n                stk.pop();\\n                System.out.println(count);\\n            }else if(stk.peek() == \\'}\\'){\\n                count +=1;\\n                stk.pop();\\n                System.out.println(count);\\n            }else{\\n                count --;\\n            }\\n            stk.pop();\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int count =0;\\n        Stack<Character> stack = new Stack<>();\\n        for(int i =0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\')\\'){\\n                if(!stack.empty() && stack.peek() == \\'(\\'){\\n                    stack.pop();\\n                }else{\\n                    count ++;\\n                }\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                }else{\\n                    count ++;\\n                }\\n            }else{\\n                stack.push(ch);\\n            }\\n        }\\n        //System.out.print(stack);\\n        return count + stack.size()*2;        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int right =0;\\n        int left =0;\\n        for(int i =0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\')\\'){\\n                if(left ==0){\\n                    right++;\\n                }else{\\n                    left--;\\n                }\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                }else{\\n                    right++;\\n                }\\n            }else{\\n                left++;\\n            }\\n        }\\n        return right + left*2;        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int right =0;\\n        int left =0;\\n        for(int i =0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                left++;\\n            }else{\\n                if(left ==0){\\n                    right++;\\n                }else{\\n                    left--;\\n                }\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                }else{\\n                    right++;\\n                }\\n            }\\n        }\\n            \\n        return right + left*2;        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int right =0;\\n        int left =0;\\n        char[] ch = s.toCharArray();\\n        for(int i =0; i<s.length(); i++){\\n            if(ch[i] == \\'(\\'){\\n                left++;\\n            }else{\\n                if(left ==0){\\n                    right++;\\n                }else{\\n                    left--;\\n                }\\n                if(i+1<s.length() && ch[i+1] == \\')\\'){\\n                    i++;\\n                }else{\\n                    right++;\\n                }\\n            }\\n        }\\n            \\n        return right + left*2;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385628,
                "title": "stack-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minInsertions(string s) \\n    {\\n        int i=0, n=s.size();\\n        stack<char> st;\\n        int ans=0;\\n        while(i<n)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                if(i+1>=n || s[i+1]!=\\')\\') ans++;\\n                else i++;\\n                if(!st.empty() && st.top()==\\'(\\') st.pop();\\n                else ans++;\\n            }\\n            else st.push(s[i]);\\n            i++;\\n        }\\n        while(!st.empty())\\n        {\\n            if(st.top()==\\'(\\') ans+=2;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minInsertions(string s) \\n    {\\n        int i=0, n=s.size();\\n        stack<char> st;\\n        int ans=0;\\n        while(i<n)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                if(i+1>=n || s[i+1]!=\\')\\') ans++;\\n                else i++;\\n                if(!st.empty() && st.top()==\\'(\\') st.pop();\\n                else ans++;\\n            }\\n            else st.push(s[i]);\\n            i++;\\n        }\\n        while(!st.empty())\\n        {\\n            if(st.top()==\\'(\\') ans+=2;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380979,
                "title": "c-use-int-as-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int curStack = 0, ans = 0;\\n        for (int i = 0; i < s.size(); ++i)\\n            if (s[i] == \\'(\\') ++curStack;\\n            else {\\n                if (i == s.size() - 1 || s[i + 1] != \\')\\') ++ans;\\n                else ++i;\\n                if (--curStack == -1)\\n                    ++ans, curStack = 0;\\n            }\\n        return ans + curStack * 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int curStack = 0, ans = 0;\\n        for (int i = 0; i < s.size(); ++i)\\n            if (s[i] == \\'(\\') ++curStack;\\n            else {\\n                if (i == s.size() - 1 || s[i + 1] != \\')\\') ++ans;\\n                else ++i;\\n                if (--curStack == -1)\\n                    ++ans, curStack = 0;\\n            }\\n        return ans + curStack * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356684,
                "title": "ok",
                "content": "**time: `O(N)`; space: `O(1)`**\\n```\\nint minInsertions(string s) \\n{\\n\\tint out{}, n{};\\n\\tfor(int i{}; i<size(s); ++i)\\n\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\t++n;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ti+1==size(s) or s[i+1]!=\\')\\' ? ++out : ++i;\\n\\t\\t\\tn ? --n : ++out;\\n\\t\\t}\\n\\treturn out+2*n;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minInsertions(string s) \\n{\\n\\tint out{}, n{};\\n\\tfor(int i{}; i<size(s); ++i)\\n\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\t++n;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ti+1==size(s) or s[i+1]!=\\')\\' ? ++out : ++i;\\n\\t\\t\\tn ? --n : ++out;\\n\\t\\t}\\n\\treturn out+2*n;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3356058,
                "title": "i-ruby",
                "content": "```ruby\\ndef min_insertions s\\n    o, c = 0, 0\\n    s.gsub /\\\\(+|\\\\)+/ do\\n        z = _1.size\\n        _1[?(] ? o += z : begin\\n            c += 1 if z.odd?\\n            o -= z.succ / 2\\n            c, o = c - o, 0 if o < 0\\n        end\\n    end\\n    o * 2 + c\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef min_insertions s\\n    o, c = 0, 0\\n    s.gsub /\\\\(+|\\\\)+/ do\\n        z = _1.size\\n        _1[?(] ? o += z : begin\\n            c += 1 if z.odd?\\n            o -= z.succ / 2\\n            c, o = c - o, 0 if o < 0\\n        end\\n    end\\n    o * 2 + c\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3313348,
                "title": "java-simple-solution-beginners-friendly",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int invalidCount = 0, stack = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\'){\\n                stack++;\\n            }\\n            else{\\n                if(i+1 == s.length() || s.charAt(i + 1) != \\')\\'){\\n                    invalidCount++;\\n                }\\n                else{\\n                    i++;\\n                }\\n                if(stack == 0){\\n                    invalidCount++;\\n                }\\n                else{\\n                    stack--;\\n                }\\n            }\\n        }\\n        return invalidCount + 2 * stack;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int invalidCount = 0, stack = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\'){\\n                stack++;\\n            }\\n            else{\\n                if(i+1 == s.length() || s.charAt(i + 1) != \\')\\'){\\n                    invalidCount++;\\n                }\\n                else{\\n                    i++;\\n                }\\n                if(stack == 0){\\n                    invalidCount++;\\n                }\\n                else{\\n                    stack--;\\n                }\\n            }\\n        }\\n        return invalidCount + 2 * stack;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295878,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n         int c=0;\\n         int cp=0;\\n         for(int i=0;i<s.length();++i)\\n         {\\n             if(s[i]==\\'(\\')\\n             {\\n                 ++c;\\n             }\\n             else\\n             {\\n                 if(i+1<s.length())\\n                 {\\n                     if(s[i+1]==\\')\\')\\n                     {\\n                         if(c>0)\\n                         {\\n                             --c;\\n                             ++i;\\n                         }\\n                         else\\n                         {\\n                             cp+=1;\\n                             ++i;\\n                         }\\n                     }\\n                     else\\n                     {\\n                         if(c>0)\\n                         {\\n                             --c;\\n                              cp+=1;\\n                         }\\n                         else\\n                         {\\n                             cp+=2;\\n                         }\\n                     }\\n                 }\\n                 else\\n                 {\\n                     if(c>0)\\n                     {\\n                         cp+=1;\\n                         --c;\\n                     }\\n                     else\\n                     {\\n                         cp+=2;\\n                     }\\n                 }\\n             }\\n         }\\n        while(c>0)\\n        {\\n            cp+=2;\\n            --c;\\n        }\\n        return cp;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n         int c=0;\\n         int cp=0;\\n         for(int i=0;i<s.length();++i)\\n         {\\n             if(s[i]==\\'(\\')\\n             {\\n                 ++c;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 3289051,
                "title": "python-one-pass-solution-time-o-n-and-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        count = 0\\n        insertion_count = 0\\n\\n        for ch in s:\\n            if(ch == \"(\" and count % 2 == 0):\\n                count += 2\\n            elif((ch == \"(\" and count % 2 == 1) or (ch == \")\" and count == 0)):\\n                count += 1\\n                insertion_count += 1\\n            else:\\n                count -= 1\\n\\n        return insertion_count + count           \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        count = 0\\n        insertion_count = 0\\n\\n        for ch in s:\\n            if(ch == \"(\" and count % 2 == 0):\\n                count += 2\\n            elif((ch == \"(\" and count % 2 == 1) or (ch == \")\" and count == 0)):\\n                count += 1\\n                insertion_count += 1\\n            else:\\n                count -= 1\\n\\n        return insertion_count + count           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288675,
                "title": "single-pass-with-o-1-space",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n      int ans = 0;\\n      int ctn = 0;\\n      for (char ch: s.toCharArray()) {\\n        if (ch == \\'(\\' && ctn % 2 == 0) ctn += 2;\\n        else if ((ch == \\'(\\' && ctn % 2 == 1) || (ch == \\')\\' && ctn == 0)) {\\n          ctn++;\\n          ans++;\\n        }\\n        else ctn--;\\n      }\\n      return ans + ctn;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n      int ans = 0;\\n      int ctn = 0;\\n      for (char ch: s.toCharArray()) {\\n        if (ch == \\'(\\' && ctn % 2 == 0) ctn += 2;\\n        else if ((ch == \\'(\\' && ctn % 2 == 1) || (ch == \\')\\' && ctn == 0)) {\\n          ctn++;\\n          ans++;\\n        }\\n        else ctn--;\\n      }\\n      return ans + ctn;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288583,
                "title": "o-n-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        stack = deque()\\n        insertion_count = 0\\n\\n        for ch in s:\\n            if(ch == \"(\"):\\n                if(stack and stack[-1] != \"(\"):\\n                    insertion_count += 1\\n                    stack.pop()\\n                    stack.pop()\\n                stack.append(ch)\\n            else:\\n                if(not stack):\\n                    insertion_count += 1\\n                    stack.append(\"(\")\\n                    stack.append(ch)\\n                else:\\n                    if(stack[-1] == \"(\"):\\n                        stack.append(ch)\\n                    else:\\n                        stack.pop()\\n                        stack.pop()\\n\\n        while(stack):\\n            if(stack[-1] == \"(\"):\\n                insertion_count += 2\\n                stack.pop()\\n            else:\\n                insertion_count += 1\\n                stack.pop()\\n                stack.pop()\\n\\n        return insertion_count\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        stack = deque()\\n        insertion_count = 0\\n\\n        for ch in s:\\n            if(ch == \"(\"):\\n                if(stack and stack[-1] != \"(\"):\\n                    insertion_count += 1\\n                    stack.pop()\\n                    stack.pop()\\n                stack.append(ch)\\n            else:\\n                if(not stack):\\n                    insertion_count += 1\\n                    stack.append(\"(\")\\n                    stack.append(ch)\\n                else:\\n                    if(stack[-1] == \"(\"):\\n                        stack.append(ch)\\n                    else:\\n                        stack.pop()\\n                        stack.pop()\\n\\n        while(stack):\\n            if(stack[-1] == \"(\"):\\n                insertion_count += 2\\n                stack.pop()\\n            else:\\n                insertion_count += 1\\n                stack.pop()\\n                stack.pop()\\n\\n        return insertion_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214154,
                "title": "c",
                "content": "```\\nint minInsertions(char * s){\\n    int n = strlen(s) ;\\n    int left = 0 ;\\n    int ret = 0 ;\\n    for(int i = 0; i < n; i++){\\n        if(s[i] == \\'(\\'){\\n            left++ ;\\n        }\\n        else{\\n            if((i+1) < n && s[i+1] == \\')\\'){\\n                if(left == 0)\\n                    ret++ ;\\n                else\\n                    left-- ;\\n                i++ ;\\n            }\\n            else{\\n                if(left == 0)\\n                    ret += 2 ;\\n                else{\\n                    ret++ ;\\n                    left-- ;\\n                }\\n            }            \\n        }\\n    }\\n \\n    ret += left*2 ;\\n    \\n    return ret ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minInsertions(char * s){\\n    int n = strlen(s) ;\\n    int left = 0 ;\\n    int ret = 0 ;\\n    for(int i = 0; i < n; i++){\\n        if(s[i] == \\'(\\'){\\n            left++ ;\\n        }\\n        else{\\n            if((i+1) < n && s[i+1] == \\')\\'){\\n                if(left == 0)\\n                    ret++ ;\\n                else\\n                    left-- ;\\n                i++ ;\\n            }\\n            else{\\n                if(left == 0)\\n                    ret += 2 ;\\n                else{\\n                    ret++ ;\\n                    left-- ;\\n                }\\n            }            \\n        }\\n    }\\n \\n    ret += left*2 ;\\n    \\n    return ret ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3212415,
                "title": "easy-simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.length();\\n        int l=0;\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                l++;\\n                continue;\\n            }\\n            if(i<n-1 && s[i]==\\')\\' && s[i+1]==\\')\\')\\n            {\\n                if(l>0)\\n                l--;\\n                else\\n                cnt++;\\n                i++;\\n                continue;\\n            }\\n            else\\n            {\\n                if(l>0)\\n                {\\n                    cnt++;\\n                    l--;\\n                }\\n                else\\n                cnt+=2;\\n            }\\n        }\\n        return cnt+(2*l);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.length();\\n        int l=0;\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                l++;\\n                continue;\\n            }\\n            if(i<n-1 && s[i]==\\')\\' && s[i+1]==\\')\\')\\n            {\\n                if(l>0)\\n                l--;\\n                else\\n                cnt++;\\n                i++;\\n                continue;\\n            }\\n            else\\n            {\\n                if(l>0)\\n                {\\n                    cnt++;\\n                    l--;\\n                }\\n                else\\n                cnt+=2;\\n            }\\n        }\\n        return cnt+(2*l);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3212043,
                "title": "easy-to-understand-solution-in-java-using-greedy-approach-with-stack",
                "content": "\\n# Approach\\ndeclare two variables res(extra characters added) and stack(to keep track of open paranteses)\\nif we encounter a ( just add it to the stack.\\nif you encounter a )\\n\\n\\nthen check the character after that there are three cases possible.\\n1. )  -two cases possible\\n    1.  empty stack first add a opening bracket  \\n    2. filled stack just reduce the stack by 1\\n2. (  -two cases possible\\n    1. empty stack add opening first then closing \\n    2. add only closing and increase the stack by one\\n3. string get out of bounds- two cases possible similar to one just add extra )\\n    1.  empty stack first add a opening bracket  \\n    2. filled stack just reduce the stack by 1\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int res=0;\\n        int stack=0;\\n        int n =s.length();\\n        int i=0;\\n        while(i<n)\\n        {    char c = s.charAt(i);\\n\\n            if(c==\\'(\\')\\n            {\\n                stack++;\\n                i++;\\n            }\\n            else\\n            {\\n                if(i<n-1 && s.charAt(i+1)==\\')\\')\\n                {\\n                    if(stack>0)\\n                    {\\n                        stack--;\\n                    }\\n                    else\\n                    {\\n                        // since no opening present add one \\n                        res++;\\n                        stack++;\\n                        // since the second digit is \\')\\' hence we will consume one opening bracket\\n                        stack--;\\n                    }\\n                }\\n                else if(i<n-1 && s.charAt(i+1)==\\'(\\')\\n                {\\n                    if(stack>0)\\n                    {\\n\\n                        res++;\\n                        stack--;\\n                        // adding \\'(\\' to stack\\n                        stack++;\\n                    }\\n                    else\\n                    {\\n                        // since no opening present add one \\n                        res++;\\n                        res++;\\n                        stack++;\\n                        stack--;\\n                        stack++;\\n                        \\n                    }\\n                \\n                }\\n                else \\n                {\\n                    if(stack>0)\\n                    {\\n                        res++;\\n                        stack--;\\n                    }\\n                    else\\n                    {\\n                        // since no opening present add one \\n                        res++;\\n                        stack++;\\n                        // since the second digit is \\')\\' hence we will consume one opening bracket\\n                        // since no second character is present adding one more \\')\\'\\n                        res++;\\n                        stack--;\\n                    }\\n                }\\n                i=i+2;\\n               \\n            }\\n           \\n        }\\n         return 2*stack+res;\\n    }\\n}\\n```\\n\\nSimilar Question:\\n \\nhttps://leetcode.com/problems/minimum-add-to-make-parentheses-valid/solutions/3207628/easy-to-understand-solution-in-java-using-stacks-and-greedy-approach/?orderBy=hot",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int res=0;\\n        int stack=0;\\n        int n =s.length();\\n        int i=0;\\n        while(i<n)\\n        {    char c = s.charAt(i);\\n\\n            if(c==\\'(\\')\\n            {\\n                stack++;\\n                i++;\\n            }\\n            else\\n            {\\n                if(i<n-1 && s.charAt(i+1)==\\')\\')\\n                {\\n                    if(stack>0)\\n                    {\\n                        stack--;\\n                    }\\n                    else\\n                    {\\n                        // since no opening present add one \\n                        res++;\\n                        stack++;\\n                        // since the second digit is \\')\\' hence we will consume one opening bracket\\n                        stack--;\\n                    }\\n                }\\n                else if(i<n-1 && s.charAt(i+1)==\\'(\\')\\n                {\\n                    if(stack>0)\\n                    {\\n\\n                        res++;\\n                        stack--;\\n                        // adding \\'(\\' to stack\\n                        stack++;\\n                    }\\n                    else\\n                    {\\n                        // since no opening present add one \\n                        res++;\\n                        res++;\\n                        stack++;\\n                        stack--;\\n                        stack++;\\n                        \\n                    }\\n                \\n                }\\n                else \\n                {\\n                    if(stack>0)\\n                    {\\n                        res++;\\n                        stack--;\\n                    }\\n                    else\\n                    {\\n                        // since no opening present add one \\n                        res++;\\n                        stack++;\\n                        // since the second digit is \\')\\' hence we will consume one opening bracket\\n                        // since no second character is present adding one more \\')\\'\\n                        res++;\\n                        stack--;\\n                    }\\n                }\\n                i=i+2;\\n               \\n            }\\n           \\n        }\\n         return 2*stack+res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168450,
                "title": "stack-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//stack : )(\\n    int minInsertions(string s) {\\n        stack<char>st;\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n         if(s[i]==\\'(\\')\\n         {\\n             if(st.empty())\\n             {\\n                 st.push(s[i]);\\n             }\\n             else{\\n                 if(st.top()==\\'(\\')\\n                 {\\n                     st.push(s[i]);\\n                 }\\n                 else{\\n                    count++;\\n                    st.pop();\\n                    st.pop();\\n                    st.push(s[i]);\\n                 }\\n             }\\n         }\\n         else{\\n             if(st.empty())\\n             {  \\n                 count++;\\n                 st.push(\\'(\\');\\n                 st.push(s[i]);\\n             }\\n             else\\n             {\\n                 if(st.top()==\\'(\\'){\\n               st.push(s[i]);\\n                 }\\n                 else{\\n                   st.pop();\\n                   st.pop();\\n                 }\\n             }\\n         }\\n        }\\n\\n        if(st.empty())return count;\\n        else {\\n            while(!st.empty()){\\n                char temp=st.top();\\n                st.pop();\\n                if(temp==\\'(\\')\\n                {\\n                    count=count+2;\\n                  \\n                }\\n                else{\\n                    count++;\\n                    st.pop();\\n                }\\n            }\\n            return count;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//stack : )(\\n    int minInsertions(string s) {\\n        stack<char>st;\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n         if(s[i]==\\'(\\')\\n         {\\n             if(st.empty())\\n             {\\n                 st.push(s[i]);\\n             }\\n             else{\\n                 if(st.top()==\\'(\\')\\n                 {\\n                     st.push(s[i]);\\n                 }\\n                 else{\\n                    count++;\\n                    st.pop();\\n                    st.pop();\\n                    st.push(s[i]);\\n                 }\\n             }\\n         }\\n         else{\\n             if(st.empty())\\n             {  \\n                 count++;\\n                 st.push(\\'(\\');\\n                 st.push(s[i]);\\n             }\\n             else\\n             {\\n                 if(st.top()==\\'(\\'){\\n               st.push(s[i]);\\n                 }\\n                 else{\\n                   st.pop();\\n                   st.pop();\\n                 }\\n             }\\n         }\\n        }\\n\\n        if(st.empty())return count;\\n        else {\\n            while(!st.empty()){\\n                char temp=st.top();\\n                st.pop();\\n                if(temp==\\'(\\')\\n                {\\n                    count=count+2;\\n                  \\n                }\\n                else{\\n                    count++;\\n                    st.pop();\\n                }\\n            }\\n            return count;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167287,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_insertions(s: String) -> i32 {\\n        let (mut res, mut right) = (0, 0);\\n        let s = s.as_bytes();\\n        for &c in s.iter() {\\n            if c == b\\'(\\' {\\n                if right % 2 > 0 {\\n                    right -= 1;\\n                    res += 1;\\n                }\\n                right += 2;\\n            } else {\\n                right -= 1;\\n                if right < 0 {\\n                    right += 2;\\n                    res += 1;\\n                }\\n            }\\n        }\\n        right + res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_insertions(s: String) -> i32 {\\n        let (mut res, mut right) = (0, 0);\\n        let s = s.as_bytes();\\n        for &c in s.iter() {\\n            if c == b\\'(\\' {\\n                if right % 2 > 0 {\\n                    right -= 1;\\n                    res += 1;\\n                }\\n                right += 2;\\n            } else {\\n                right -= 1;\\n                if right < 0 {\\n                    right += 2;\\n                    res += 1;\\n                }\\n            }\\n        }\\n        right + res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3164406,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        s1=s+\"1\"\\n        i=0\\n        l=[]\\n        count=0\\n        while(i<len(s1)):\\n            if(s1[i]==\\'(\\'):\\n                l.append(s[i])\\n            else:\\n                if(s1[i]==\")\" and s1[i+1]==\")\"):\\n                    if(len(l)!=0):\\n                        l.pop()\\n                    else:\\n                        count+=1\\n                    i+=1\\n                elif(s1[i]==\\')\\' and s1[i+1]!=\")\"):\\n                    if(len(l)!=0):\\n                        l.pop()\\n                        count+=1\\n                    else:\\n                        count+=2\\n            i+=1\\n        if(len(l)!=0):\\n            count+=2*len(l)\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        s1=s+\"1\"\\n        i=0\\n        l=[]\\n        count=0\\n        while(i<len(s1)):\\n            if(s1[i]==\\'(\\'):\\n                l.append(s[i])\\n            else:\\n                if(s1[i]==\")\" and s1[i+1]==\")\"):\\n                    if(len(l)!=0):\\n                        l.pop()\\n                    else:\\n                        count+=1\\n                    i+=1\\n                elif(s1[i]==\\')\\' and s1[i+1]!=\")\"):\\n                    if(len(l)!=0):\\n                        l.pop()\\n                        count+=1\\n                    else:\\n                        count+=2\\n            i+=1\\n        if(len(l)!=0):\\n            count+=2*len(l)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161626,
                "title": "o-n-c-solution-without-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar to question 921\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWalk through every parantheses in input string and use two variable **insertion** and **right_need** to record the status of parantheses need.\\n- **Insertion** record the number of insertion activities needed before current char\\n- **right_need** record the number of right parantheses need\\n***\\n\\n## Cases\\n1. If current char is \\'(\\'\\n    * We need two more right parantheses: \\n        * right_need +=2\\n    * If current right_need is odd, the pattern is invalid. Thus, we need to insert one \\')\\' \\n        * insertion++, right_need--\\n2. If current char is \\')\\'\\n    * The right paranthesis we need would minus one \\n    * If the right_need is -1, it means there is a extra right paranthesis. To match the pattern \\'())\\', we insert one left paranthesis and need one more right paranthesis.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int insertion=0;\\n        int right_need=0;\\n        for(char c: s){\\n            if(c==\\'(\\'){\\n                right_need+=2;\\n                if(right_need%2==1){\\n                    insertion++;\\n                    right_need--;\\n                }\\n            }\\n            else if(c==\\')\\'){\\n                right_need--;\\n                if(right_need==-1){\\n                    right_need=1;\\n                    insertion++;\\n                }\\n\\n            }\\n        }\\n        return insertion+right_need;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int insertion=0;\\n        int right_need=0;\\n        for(char c: s){\\n            if(c==\\'(\\'){\\n                right_need+=2;\\n                if(right_need%2==1){\\n                    insertion++;\\n                    right_need--;\\n                }\\n            }\\n            else if(c==\\')\\'){\\n                right_need--;\\n                if(right_need==-1){\\n                    right_need=1;\\n                    insertion++;\\n                }\\n\\n            }\\n        }\\n        return insertion+right_need;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564804,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1570807,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1576499,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1574183,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1568412,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1870978,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2055662,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2025105,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1783148,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1662228,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1564804,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1570807,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1576499,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1574183,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1568412,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1870978,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2055662,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2025105,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1783148,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1662228,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Longest Awesome Substring",
        "question_content": "<p>You are given a string <code>s</code>. An <strong>awesome</strong> substring is a non-empty substring of <code>s</code> such that we can make any number of swaps in order to make it a palindrome.</p>\n\n<p>Return <em>the length of the maximum length <strong>awesome substring</strong> of</em> <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;3242415&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> &quot;24241&quot; is the longest awesome substring, we can form the palindrome &quot;24142&quot; with some swaps.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;12345678&quot;\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;213123&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> &quot;213123&quot; is the longest awesome substring, we can form the palindrome &quot;231132&quot; with some swaps.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists only of digits.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 779893,
                "title": "c-java-python3-with-picture-similar-to-1371",
                "content": "#### Intuition\\nThis is similar to [1371. Find the Longest Substring Containing Vowels in Even Counts](https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/534135/C%2B%2BJava-with-picture).\\n\\nWe can form a palindrome if the count of each included number (expcept maybe one) is even, and this is the property of an awesome string.\\n\\nA bit in our `mask` is `0` if the count for the corresponding number is even, and `1` if it\\'s odd.  As we go through the string, we track odd/even counts in our mask. If we see the same `mask` again, the subarray between first poistion (exclusive) and the current position (inclusive) with the same `mask` has all numbers with the even count. \\n\\nWe will use the `dp` array to track the smallest (first) position of each `mask`. We can get the size of the substring by substracting it from the current poisition. \\n\\n> Note that position for zero mask is `-1`, as we need to include the very first character.\\n\\nNow, the difference from #1371 is that a palindrome can have up to one number with the odd count. Therefore, we need to also check all masks that are different from the current one by one bit. In other words, if two masks are different by one bit, that means that there is one odd count in the substring.\\n\\n![image](https://assets.leetcode.com/users/images/4fb7c48e-699d-4303-ade3-52300e87abf6_1596907985.4008424.png)\\n\\n**C++**\\n```cpp\\nint longestAwesome(string s) {\\n    vector<int> dp(1024, s.size());\\n    int res = 0, mask = 0;\\n    dp[0] = -1;\\n    for (auto i = 0; i < s.size(); ++i) {\\n        mask ^= 1 << (s[i] - \\'0\\');\\n        res = max(res, i - dp[mask]);\\n        for (auto j = 0; j <= 9; ++j)\\n            res = max(res, i - dp[mask ^ (1 << j)]);\\n        dp[mask] = min(dp[mask], i);\\n    }\\n    return res;\\n}\\n```\\n**Java**\\n```java\\npublic int longestAwesome(String s) {\\n    int dp[] = new int[1024];\\n    Arrays.fill(dp, s.length());\\n    int res = 0, mask = 0;\\n    dp[0] = -1;\\n    for (int i = 0; i < s.length(); ++i) {\\n        mask ^= 1 << (s.charAt(i) - \\'0\\');\\n        res = Math.max(res, i - dp[mask]);\\n        for (int j = 0; j <= 9; ++j)\\n            res = Math.max(res, i - dp[mask ^ (1 << j)]);\\n        dp[mask] = Math.min(dp[mask], i);\\n    }\\n    return res;\\n}\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        mask, res = 0, 0\\n        dp = [-1] + [len(s)] * 1023\\n        for i in range(len(s)):\\n            mask ^= 1 << (ord(s[i]) - 48)\\n            for j in range(11):\\n                check_mask = 1023 & (mask ^ (1 << j))\\n                res = max(res, i - dp[check_mask])\\n            dp[mask] = min(dp[mask], i)\\n        return res\\n```\\n\\n#### Complexity Analysis\\n- Time: O(nk), where k is the number of unique characters we track. We go through the string once, and do k checks for each character.\\n- Memory: O(2^ k), where k is the number of unique characters to track.",
                "solutionTags": [],
                "code": "```cpp\\nint longestAwesome(string s) {\\n    vector<int> dp(1024, s.size());\\n    int res = 0, mask = 0;\\n    dp[0] = -1;\\n    for (auto i = 0; i < s.size(); ++i) {\\n        mask ^= 1 << (s[i] - \\'0\\');\\n        res = max(res, i - dp[mask]);\\n        for (auto j = 0; j <= 9; ++j)\\n            res = max(res, i - dp[mask ^ (1 << j)]);\\n        dp[mask] = min(dp[mask], i);\\n    }\\n    return res;\\n}\\n```\n```java\\npublic int longestAwesome(String s) {\\n    int dp[] = new int[1024];\\n    Arrays.fill(dp, s.length());\\n    int res = 0, mask = 0;\\n    dp[0] = -1;\\n    for (int i = 0; i < s.length(); ++i) {\\n        mask ^= 1 << (s.charAt(i) - \\'0\\');\\n        res = Math.max(res, i - dp[mask]);\\n        for (int j = 0; j <= 9; ++j)\\n            res = Math.max(res, i - dp[mask ^ (1 << j)]);\\n        dp[mask] = Math.min(dp[mask], i);\\n    }\\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        mask, res = 0, 0\\n        dp = [-1] + [len(s)] * 1023\\n        for i in range(len(s)):\\n            mask ^= 1 << (ord(s[i]) - 48)\\n            for j in range(11):\\n                check_mask = 1023 & (mask ^ (1 << j))\\n                res = max(res, i - dp[check_mask])\\n            dp[mask] = min(dp[mask], i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785213,
                "title": "example-input-3242415-explanation-with-bitmask",
                "content": "**Definition of Awesomeness**\\nString S is a palindrome if S equals to its reversed version: \"1112111\"\\nAny string is awesome if we can reorder its characters to make it a palindrome: \\n\"24241\" can be reordered to \"24142\".\\n\\n**Properties of Awesome string**\\nThere are 2 cases that a string can be reordered to be a palindrome:\\n**Case 1**. All of its characters have even occurrences: \\n\\t\\t\"2424\" -> there are two \\'2\\'s and two \\'4\\'s.\\n**Case 2**. All of its characters have even occurrences except one: \\n\\t\\t\"24241\" -> there are two \\'2\\'s, two \\'4\\'s and one \\'1\\'\\n\\t\\t\\n**Brute force solution**\\nThe most straighforward solution would be keeping track of all counters while looping through characters. Once we are at position i, we go back and subtract all our previous counters from our current counter to check if any of them is awesome. However, its time complexity is O(10*N^2): 10 digits * N chars * N comparisons which is not desirable\\n\\n**BitMask solution**\\nWe don\\'t have to keep track of counters, we are only interested in odd counts in a substring. We can use one bit to say if some digit has even or odd count at any point.\\nLet 0 represent \"even\" and 1 represent \"odd\". \\nFor example, for an input of \"233\":\\n1. i = 0, char = \\'2\\', xor 2nd bit from right:\\n\\tmask = \"100\"\\n2. i = 1, char = \\'3\\', xor 3rd bit from right:\\n\\tmask = \"1100\"\\n3. i = 2, char = \\'3\\', xor 3rd bit from right:\\n\\tmask = \"0100\"\\n\\t\\nThe last mask is \"0100\" which says it has only one number with odd count, so, the input can be rearranged to make it a palindrome: \"233\" => \"323\".\\n\\nEven simpler, if the input is \"22\", we set and unset 2nd bit, then the remaining mask would be \"000\", which says we have numbers with all having even counts.\\n\\nNow, let\\'s analyze the example input \"3242415\" from problem definition.\\n1. i = 0, char = \\'3\\', xor 3rd bit from right:\\n\\n\\t\\tmask = \\'0000001000\\'\\n2. i = 1, char = \\'2\\', xor 2nd bit from right:\\n\\t\\n\\t\\tmask = \\'0000001100\\'\\n3. i = 2, char = \\'4\\', xor 4th bit from right:\\n    \\n\\t\\tmask = \\'0000011100\\'\\n4. i = 3, char = \\'2\\', xor 2nd bit from right:\\n\\t\\n\\t\\tmask = \\'0000011000\\'\\n5. i = 4, char = \\'4\\', xor 4th bit from right:\\n\\t\\n\\t\\tmask = \\'0000001000\\'\\n6. i = 5, char = \\'1\\', xor 1st bit from right:\\n\\t\\n\\t\\tmask = \\'0000001010\\'\\n7. i = 6, char = \\'5\\', xor 5th bit from right:\\n\\t\\n\\t\\tmask = \\'0000101010\\'\\n\\t\\nThe problem asks to find the longest awesome substring, it can be anywhere between i and j such that i <= j <= lenth of input. For this, on every step above, we need to memoize the current mask and check if we have seen similar mask before.\\nUpdate the answer if:\\n\\t\\ta. We have seen similar mask before.\\n\\t\\tb. We have seen a mask such that it differs from the current mask by one bit being different.\\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        n = len(s)\\n        ans, mask = 0, 0\\n        \\n        memo = [n] * 1024\\n        memo[0] = -1\\n        \\n        for i in range(n):\\n            mask ^= 1 << int(s[i])\\n\\t\\t\\t\\n\\t\\t\\t# Case 1. Check if we have seen similar mask\\n            ans = max(ans, i - memo[mask])\\n            \\n\\t\\t\\t# Case 2. Check for masks that differ by one bit\\n            for j in range(10):\\n                test_mask = mask ^ (1 << j)\\n                ans = max(ans, i - memo[test_mask])\\n                \\n\\t\\t\\t# save the earliest position\\n            memo[mask] = min(memo[mask], i)    \\n        \\n        return ans\\n```\\nThere are number of questions arise from the above solution:\\n**Question 1. Why 1024?**\\nSince the input only contains 10 digits (\"0123456789\"), we can only see 2^10 or 1024 variations of bit masks: 0000000000, 0000000001, .... , 1111111110, 1111111111\\n**Question 2. What is 1 << int(s[i])**\\nIt shifts 1 by s[i] times, for ex: 1 << 3 gives us \\'1000\\'.\\nAnd it updates the current mask: 0000 ^ 1000 = 1000 or 1110 ^ 1000 = 0110 \\nIf you didn\\'t get it, please, read bit operations in depth.\\n**Question 3. What is the test mask**\\nThe test mask in above solution alters one of the bits of the current mask to check for Case 2.\\n**Question 4. Why do we check for similar masks?**\\nThat means between the similar mask and the current mask, we have seen such digits that xored themselves along the way and disappeared from the mask. Only if the number of digits is even, they can disappear from the current mask: for ex: \"223\", the current mask evolution is: \"100\" -> \"000\" -> \"1000\". \\n**Question 5. Why do we check for masks that differ by one bit?**\\nSince it is allowed to have one number with odd count, we can check for masks that differ by one bit from the current mask.\\n\\nI think, you got this, let me know if you have any other questions.\\n",
                "solutionTags": [
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        n = len(s)\\n        ans, mask = 0, 0\\n        \\n        memo = [n] * 1024\\n        memo[0] = -1\\n        \\n        for i in range(n):\\n            mask ^= 1 << int(s[i])\\n\\t\\t\\t\\n\\t\\t\\t# Case 1. Check if we have seen similar mask\\n            ans = max(ans, i - memo[mask])\\n            \\n\\t\\t\\t# Case 2. Check for masks that differ by one bit\\n            for j in range(10):\\n                test_mask = mask ^ (1 << j)\\n                ans = max(ans, i - memo[test_mask])\\n                \\n\\t\\t\\t# save the earliest position\\n            memo[mask] = min(memo[mask], i)    \\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779919,
                "title": "java-c-python-prefix-bitmask",
                "content": "## **Intuition**\\nSimilar to [1371. Find the Longest Substring Containing Vowels in Even Counts](https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/531840/JavaC++Python-One-Pass).\\n<br>\\n\\n## **Explanation**\\nWe have 10 + 1 types of palindromes.\\nUse any number as the middle character, or don\\'t have a middle character.\\n<br>\\n\\n## **Complexity**\\nTime `O(10N)`\\nSpace `O(1024)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int longestAwesome(String s) {\\n        int res = 0, cur = 0, n = s.length(), seen[] = new int[1024];\\n        Arrays.fill(seen, n);\\n        seen[0] = -1;\\n        for (int i = 0; i < n; ++i) {\\n            cur ^= 1 << (s.charAt(i) - \\'0\\');\\n            for (int a = 0; a < 10; ++a)\\n                res = Math.max(res, i - seen[cur ^ (1 << a)]);\\n            res = Math.max(res, i - seen[cur]);\\n            seen[cur] = Math.min(seen[cur], i);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int longestAwesome(string s) {\\n        int res = 0, cur = 0, n = s.size();\\n        vector<int> seen(1024, n);\\n        seen[0] = -1;\\n        for (int i = 0; i < n; ++i) {\\n            cur ^= 1 << (s[i] - \\'0\\');\\n            for (int a = 0; a < 10; ++a)\\n                res = max(res, i - seen[cur ^ (1 << a)]);\\n            res = max(res, i - seen[cur]);\\n            seen[cur] = min(seen[cur], i);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def longestAwesome(self, s):\\n        res, cur, n = 0, 0, len(s)\\n        seen = [-1] + [n] * 1024\\n        for i, c in enumerate(s):\\n            cur ^= 1 << int(c)\\n            for a in xrange(10):\\n                res = max(res, i - seen[cur ^ (1 << a)])\\n            res = max(res, i - seen[cur])\\n            seen[cur] = min(seen[cur], i)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int longestAwesome(String s) {\\n        int res = 0, cur = 0, n = s.length(), seen[] = new int[1024];\\n        Arrays.fill(seen, n);\\n        seen[0] = -1;\\n        for (int i = 0; i < n; ++i) {\\n            cur ^= 1 << (s.charAt(i) - \\'0\\');\\n            for (int a = 0; a < 10; ++a)\\n                res = Math.max(res, i - seen[cur ^ (1 << a)]);\\n            res = Math.max(res, i - seen[cur]);\\n            seen[cur] = Math.min(seen[cur], i);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int longestAwesome(string s) {\\n        int res = 0, cur = 0, n = s.size();\\n        vector<int> seen(1024, n);\\n        seen[0] = -1;\\n        for (int i = 0; i < n; ++i) {\\n            cur ^= 1 << (s[i] - \\'0\\');\\n            for (int a = 0; a < 10; ++a)\\n                res = max(res, i - seen[cur ^ (1 << a)]);\\n            res = max(res, i - seen[cur]);\\n            seen[cur] = min(seen[cur], i);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def longestAwesome(self, s):\\n        res, cur, n = 0, 0, len(s)\\n        seen = [-1] + [n] * 1024\\n        for i, c in enumerate(s):\\n            cur ^= 1 << int(c)\\n            for a in xrange(10):\\n                res = max(res, i - seen[cur ^ (1 << a)])\\n            res = max(res, i - seen[cur])\\n            seen[cur] = min(seen[cur], i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 779888,
                "title": "detailed-explanation-case-wise-solution",
                "content": ">Observation 1: \\n>We need to find a substring that contains:\\n>\\n>1. Even occurrences of 0, 1, 2, 3 ... 9.\\n>OR\\n>2. Odd occurrences of one of 0, 1, 2, 3 ... 9. And even occurrences of all other digits.\\n\\nNow, let\\'s enumerate occurrences of each digit for this string \"011233444555569\". And for even occurrences of a digit represent it as set bit in our state.\\n\\n\"\": will have following occurrences: (0, 0, 0, 0, 0, 0, 0, 0, 0, 0) => (1111111111)base2\\n\"0\": will have following occurrences: (1, 0, 0, 0, 0, 0, 0, 0, 0, 0) => (1111111110)base2\\n\"01\": will have following occurrences: (1, 1, 0, 0, 0, 0, 0, 0, 0, 0) => (1111111100)base2\\n\"011\": will have following occurrences: (1, 2, 0, 0, 0, 0, 0, 0, 0, 0) => (1111111110)base2\\n\"0112\": will have following occurrences: (1, 2, 1, 0, 0, 0, 0, 0, 0, 0) => (1111111010)base2\\n\\nMaintaining state in the form of bits will help us find index which will give us a substring that satisfy case1 or case2. Let\\'s see how:\\n\\nFor observation 1 case 1: For this case we only need to check when did we encountered the same set bits earlier.\\n\\nBecause to get even occurences of a digit that has even occurrences we must\\'ve had even occurrences earlier. And to get even occurrences of a digit that has odd occurrences we must\\'ve had odd occurrences of same digit earlier. \\n\\nWhy?\\n\\n>Observation 2: \\n>even - even = even\\n>odd - odd = even\\n\\nFor observation 1 case 2: Keep even occurrences of each digit and use odd occurrence of one of the digit and see if there is a longer substring.\\n\\n**Case wise, light bit-wise operation, easy to understand solution:**\\n\\n```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<Integer, Integer> pos = new HashMap<>();   // `state` => index of first occurence of this `state`\\n        int[] occurrences = new int[10];\\n\\n        // Minimum answer will always be 1\\n        int ans = 1;\\n\\n        // All digits have even number of occurences in the beginning.\\n        pos.put(1023, -1);\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            occurrences[s.charAt(i) - \\'0\\']++;\\n\\n            int currentState = 0;\\n            for (int j = 0; j < 10; ++j) {\\n                if (occurrences[j] % 2 == 0) {\\n                    currentState |= (1 << j);\\n                }\\n            }\\n            // Case 1: All even\\n            ans = Math.max(ans, i - pos.getOrDefault(currentState, i));\\n\\n            // Case 2: All even, except one odd\\n            for (int digitWithOddOccurrences = 0; digitWithOddOccurrences < 10; ++digitWithOddOccurrences) {\\n                int state = 0;\\n                for (int j = 0; j < 10; ++j) {\\n                    if (j != digitWithOddOccurrences) {\\n                        if (occurrences[j] % 2 == 0) {\\n                            state |= (1 << j);\\n                        }\\n                    } else {\\n                        if (occurrences[j] % 2 == 1) {\\n                            state |= (1 << j);\\n                        }\\n                    }\\n                }\\n\\n                ans = Math.max(ans, i - pos.getOrDefault(state, i));\\n            }\\n            if (!pos.containsKey(currentState)) {\\n                pos.put(currentState, i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n**Refactored solution:**\\n\\n```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<Integer, Integer> pos = new HashMap<>();   // `state` => index of first occurence of this `state`\\n        int[] occurrences = new int[10];\\n\\n        // Minimum answer will always be 1\\n        int ans = 1;\\n        \\n        // All digits have even number of occurences in the beginning.\\n        int currentState = 1023;\\n\\n        pos.put(currentState, -1);\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            currentState ^= (1 << (s.charAt(i) - \\'0\\'));\\n            \\n            // Case 1: All even\\n            ans = Math.max(ans, i - pos.getOrDefault(currentState, i));\\n\\n            // Case 2: All even, except one odd\\n            for (int digitWithOddOccurrences = 0; digitWithOddOccurrences < 10; ++digitWithOddOccurrences) {\\n                ans = Math.max(ans, i - pos.getOrDefault(currentState ^ (1 << digitWithOddOccurrences), i));\\n            }\\n            if (!pos.containsKey(currentState)) {\\n                pos.put(currentState, i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<Integer, Integer> pos = new HashMap<>();   // `state` => index of first occurence of this `state`\\n        int[] occurrences = new int[10];\\n\\n        // Minimum answer will always be 1\\n        int ans = 1;\\n\\n        // All digits have even number of occurences in the beginning.\\n        pos.put(1023, -1);\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            occurrences[s.charAt(i) - \\'0\\']++;\\n\\n            int currentState = 0;\\n            for (int j = 0; j < 10; ++j) {\\n                if (occurrences[j] % 2 == 0) {\\n                    currentState |= (1 << j);\\n                }\\n            }\\n            // Case 1: All even\\n            ans = Math.max(ans, i - pos.getOrDefault(currentState, i));\\n\\n            // Case 2: All even, except one odd\\n            for (int digitWithOddOccurrences = 0; digitWithOddOccurrences < 10; ++digitWithOddOccurrences) {\\n                int state = 0;\\n                for (int j = 0; j < 10; ++j) {\\n                    if (j != digitWithOddOccurrences) {\\n                        if (occurrences[j] % 2 == 0) {\\n                            state |= (1 << j);\\n                        }\\n                    } else {\\n                        if (occurrences[j] % 2 == 1) {\\n                            state |= (1 << j);\\n                        }\\n                    }\\n                }\\n\\n                ans = Math.max(ans, i - pos.getOrDefault(state, i));\\n            }\\n            if (!pos.containsKey(currentState)) {\\n                pos.put(currentState, i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<Integer, Integer> pos = new HashMap<>();   // `state` => index of first occurence of this `state`\\n        int[] occurrences = new int[10];\\n\\n        // Minimum answer will always be 1\\n        int ans = 1;\\n        \\n        // All digits have even number of occurences in the beginning.\\n        int currentState = 1023;\\n\\n        pos.put(currentState, -1);\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            currentState ^= (1 << (s.charAt(i) - \\'0\\'));\\n            \\n            // Case 1: All even\\n            ans = Math.max(ans, i - pos.getOrDefault(currentState, i));\\n\\n            // Case 2: All even, except one odd\\n            for (int digitWithOddOccurrences = 0; digitWithOddOccurrences < 10; ++digitWithOddOccurrences) {\\n                ans = Math.max(ans, i - pos.getOrDefault(currentState ^ (1 << digitWithOddOccurrences), i));\\n            }\\n            if (!pos.containsKey(currentState)) {\\n                pos.put(currentState, i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217420,
                "title": "c-solution-bit-manipulation-and-hashmaps-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/99e88436-7a7e-4309-97ac-55108293a6ac_1656577255.5991323.jpeg)\\n![image](https://assets.leetcode.com/users/images/82940c6e-3c42-4eca-b3d2-444ba0663d11_1656577267.6991522.jpeg)\\n![image](https://assets.leetcode.com/users/images/4adff6e6-77b6-4987-9b99-0ebcb0c144c7_1656577286.23025.jpeg)\\n![image](https://assets.leetcode.com/users/images/153f279b-d4f8-4b3c-bfc9-02b3e48c7c98_1656577299.7385113.jpeg)\\n![image](https://assets.leetcode.com/users/images/f49ec115-14a4-41ec-958f-29b9adbf1ab3_1656577324.9608977.jpeg)\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<int,int>maskTable;\\n        maskTable[0]=-1;\\n        int ans=0;\\n        int mask=0;\\n        for(int i=0;i<s.size();i++){\\n            int digit=s[i]-\\'0\\';\\n            mask^=(1<<digit);\\n            if(!maskTable.count(mask)){\\n                maskTable[mask]=i;\\n            } else {\\n                //case III\\n                ans=max(ans,i-maskTable[mask]);\\n            }\\n            //caseI and case II\\n            if(mask==0 or (mask&(mask-1))==0){\\n                ans=max(ans,i+1);\\n            }\\n            //case IV\\n            for(int pos=0;pos<=10;pos++){\\n                int nwmask=mask^(1<<pos);\\n                if(maskTable.count(nwmask)){\\n                    ans=max(ans,i-maskTable[nwmask]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<int,int>maskTable;\\n        maskTable[0]=-1;\\n        int ans=0;\\n        int mask=0;\\n        for(int i=0;i<s.size();i++){\\n            int digit=s[i]-\\'0\\';\\n            mask^=(1<<digit);\\n            if(!maskTable.count(mask)){\\n                maskTable[mask]=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 779944,
                "title": "easy-bitmask-with-explanation-o-n",
                "content": "We store the first occurance of counts in a mask\\nfor all even we do\\n`mask[i]` = set `digit\\'th` bit if `count[digit]` in `1..i` is odd\\n\\n`ans = i \\u2013 start[mask]`\\nfor only one odd (digit = `b`)\\nwe find `new mask`\\n`new_mask = mask ^ (1<<b)`\\n`ans = i \\u2013 start[new_mask]`\\n\\nps we only do this when we have seen atleast one occourance of the mask\\n\\ncode:\\n```\\n    int longestAwesome(string s) {\\n\\n        int n = s.length();\\n        int ans = 1;\\n        int mask = 0;\\n        vector<int> pos(2000, -1);\\n        pos[0] = 0;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            int d = s[i-1] - \\'0\\';\\n            mask ^= 1<<d;\\n            if (pos[mask] == -1)\\n                pos[mask] = i;\\n\\t\\t\\t\\t\\n\\t\\t\\t // for no odd digit in subarray\\n            ans = max(ans, i - pos[mask]);\\n\\t\\t\\t// for only one odd digit in subarray\\n            for (int b = 0; b < 10; b++)\\n            {\\n\\t\\t\\t\\t// only odd bit is b\\n                int new_mask = mask^(1<<b);\\n                if (pos[new_mask] != -1)\\n                {\\n                    ans = max(ans, i - pos[new_mask]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\n    int longestAwesome(string s) {\\n\\n        int n = s.length();\\n        int ans = 1;\\n        int mask = 0;\\n        vector<int> pos(2000, -1);\\n        pos[0] = 0;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            int d = s[i-1] - \\'0\\';\\n            mask ^= 1<<d;\\n            if (pos[mask] == -1)\\n                pos[mask] = i;\\n\\t\\t\\t\\t\\n\\t\\t\\t // for no odd digit in subarray\\n            ans = max(ans, i - pos[mask]);\\n\\t\\t\\t// for only one odd digit in subarray\\n            for (int b = 0; b < 10; b++)\\n            {\\n\\t\\t\\t\\t// only odd bit is b\\n                int new_mask = mask^(1<<b);\\n                if (pos[new_mask] != -1)\\n                {\\n                    ans = max(ans, i - pos[new_mask]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1234697,
                "title": "explained-simple-efficient",
                "content": "A substring will be an awesome substring:-\\n* \\xA0 \\xA0 If the frequency of each digit/character is even in the substring\\n\\xA0 \\xA0 Or\\n* \\xA0 \\xA0 If only one of the digit/character is having odd count of frequency and rest of the ohters are having even frequency\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 Here the possible character in the string are \\'0\\' to \\'9\\', so we can use a bitmap of length 10 where each position will have either 0 or 1\\n\\xA0 \\xA0 If frequecy of digit \\'0\\' is even, then the first bit will be set as 0, or 1 otherwise\\n\\xA0 \\xA0 If the frequency of digit \\'1\\' is even, then the second digit in bitmap will be 0, or 1 otherwise\\n\\xA0 \\xA0 Same goese for digits 2,3,4....9 and 3rd,4th,5th....10th digit\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 Now we will try to find substrings which are having even number of frequency for each digit or atmost 1 digit with odd frequency.\\n\\xA0 \\xA0 For this we will use (digit-1)th bit in a bitmap\\n\\xA0 \\xA0 When we process each digit, we will toggle the (digit-1)th position bit in bitmap.\\xA0Toggeling this so it becomes 0 for even frequencies, and 1 for odd frequencies. \\n\\xA0 \\xA0 Each time we will set the new bitmap in hashmap where bitmap will be key and the current index will be the value. \\n\\tBefore pushing this in hash, we will check if the same bitmap is already there in hasmap. If yes, then we know there has been a substring which has added even number of frequency for each digit, That\\'s why the overall impact is nothing and we got the same bitmap again. That substring started from the last_index+1(We got last_index from hashmap) and ending on the current index.\\n\\tThe hashmap approach is similar to this, Refer to \"Approach 4: Using Hashmap\" here https://leetcode.com/problems/subarray-sum-equals-k/solution/\\n\\xA0 \\xA0 The above thing covers all the substrings with even frequency of each digit\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 Now to cover substring with odd frequency for 1 digit, we will follow below step\\n\\xA0 \\xA0 There are 10 positions in the bitmap\\n\\xA0 \\xA0 We will toggle the bit on 1st position and check if the toggled bitmap is there in hashmap, if yes then there is an awesome subtring starting after the value of hashmap till this index. It is becuase the substring in between these 2 indexes has added odd frequency only for 1 digit,\\xA0rest of the other digits were added in even freqeuncy. That\\'s why the current bitmap differs by 1 bit only.\\n\\xA0 \\xA0 We will repeat the above step 10 times, each time we will toggle a new digit and check for the match.\\n\\xA0 \\xA0 \\n\\tWhenever we find an awesome substring, we will check for the maximum length.\\n\\n```\\n\\tvar longestAwesome = function(s) {\\n    let bitmap=0,hash={},digit,ans=0,d=1,toggledBitmap;\\n    hash[0]=-1;\\n    for(let i=0;i<s.length;i++){\\n        digit = parseInt(s[i]);\\n        bitmap^= 1<<digit;//Toggle digit bit in total bitmap. So if bit for digit 3 is already set then it will make it zero, otherwise it will set it to 1\\n\\t\\t\\n        if(hash[bitmap]!==undefined){//Here we are checking if the same bitmap has already been there\\n            ans = Math.max(ans,i-hash[bitmap]);\\n        }else{//***We are niw overriding the last key,value pair by the current one, this is to maximize the length whenever a match is found for any index on the right side. \\n            hash[bitmap] = i;\\n        }\\n        for(let j=0;j<10;j++){//Here we are checking for bit with a difference of 1 bit. This is to cover the substrings having odd frequency for 1 digit. \\n             d = 1<<j;\\n            toggledBitmap = bitmap^d;\\n            if(hash[toggledBitmap]!==undefined){\\n                ans = Math.max(ans,i-hash[toggledBitmap]);\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\tvar longestAwesome = function(s) {\\n    let bitmap=0,hash={},digit,ans=0,d=1,toggledBitmap;\\n    hash[0]=-1;\\n    for(let i=0;i<s.length;i++){\\n        digit = parseInt(s[i]);\\n        bitmap^= 1<<digit;//Toggle digit bit in total bitmap. So if bit for digit 3 is already set then it will make it zero, otherwise it will set it to 1\\n\\t\\t\\n        if(hash[bitmap]!==undefined){//Here we are checking if the same bitmap has already been there\\n            ans = Math.max(ans,i-hash[bitmap]);\\n        }else{//***We are niw overriding the last key,value pair by the current one, this is to maximize the length whenever a match is found for any index on the right side. \\n            hash[bitmap] = i;\\n        }\\n        for(let j=0;j<10;j++){//Here we are checking for bit with a difference of 1 bit. This is to cover the substrings having odd frequency for 1 digit. \\n             d = 1<<j;\\n            toggledBitmap = bitmap^d;\\n            if(hash[toggledBitmap]!==undefined){\\n                ans = Math.max(ans,i-hash[toggledBitmap]);\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779909,
                "title": "python-bit-mask",
                "content": "Since the string only contains digits, we can use 10 bits to represent the status of a substring, bit 1 indicates there is an odd number of digits, bit 0 indicates there is an even number of digits. So for an awesome substring, its status has to be zero (all the digits occur even number of times), or only one bit is 1 (there\\'s only one digit occurs odd times)\\n\\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        left_most_masks = {0:-1}\\n        valid_masks = {1 << i for i in range(10)} | {0}\\n        ans = 0\\n        curr_mask = 0\\n        for i, x in enumerate(map(int, s)):\\n            curr_mask ^= 1 << x\\n            for valid_mask in valid_masks:\\n                left_mask = valid_mask ^ curr_mask\\n                if left_mask in left_most_masks:\\n                    ans = max(ans, i - left_most_masks[left_mask])\\n            if curr_mask not in left_most_masks:\\n                left_most_masks[curr_mask] = i\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        left_most_masks = {0:-1}\\n        valid_masks = {1 << i for i in range(10)} | {0}\\n        ans = 0\\n        curr_mask = 0\\n        for i, x in enumerate(map(int, s)):\\n            curr_mask ^= 1 << x\\n            for valid_mask in valid_masks:\\n                left_mask = valid_mask ^ curr_mask\\n                if left_mask in left_most_masks:\\n                    ans = max(ans, i - left_most_masks[left_mask])\\n            if curr_mask not in left_most_masks:\\n                left_most_masks[curr_mask] = i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780639,
                "title": "python-blazingly-fast-208-ms-99-runtime-while-short-and-simple",
                "content": "Two simple ideas that take advantage of long test scenarios:\\n\\n1. In the first loop, create dictionaries dictF(orward) and dictB(ackward) that contain first and last occurances of cumulative XOR for bitwise coding of digits - the coding is explained very well in other solutions in the discussion. [E.g., see this great post from votrubac.](https://leetcode.com/problems/find-longest-awesome-substring/discuss/779893/C%2B%2BJavaPython3-with-picture-(similar-to-1371))\\n2. In the return statement, browse dictF and dictB for the largest distance between the indices. \\n\\nTime saving: finding max at every step is no longer needed. Instead, we need to populate additional dictionary.\\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        \\n        digits=[512 >> move for move in range(11)]\\n        xor, dictF, dictB=0, {0:-1}, {0:-1}\\n        \\n        for i in range(len(s)):\\n            xor=xor ^ (1 << int(s[i]))\\n            if xor not in dictF:\\n                dictF[xor]=i\\n            dictB[xor]=i\\n\\n        return max([(ind-dictF[val ^ digit]) \\\\\\n                            for val, ind in dictB.items() \\\\\\n                            for digit in digits \\\\\\n                            if digit ^ val in dictF])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        \\n        digits=[512 >> move for move in range(11)]\\n        xor, dictF, dictB=0, {0:-1}, {0:-1}\\n        \\n        for i in range(len(s)):\\n            xor=xor ^ (1 << int(s[i]))\\n            if xor not in dictF:\\n                dictF[xor]=i\\n            dictB[xor]=i\\n\\n        return max([(ind-dictF[val ^ digit]) \\\\\\n                            for val, ind in dictB.items() \\\\\\n                            for digit in digits \\\\\\n                            if digit ^ val in dictF])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1565770,
                "title": "java-solution-problem-for-input-9498331-93139-ans-should-be-5-but-leet-code-show-3",
                "content": "class Solution {\\n    public int longestAwesome(String string) {\\n\\t\\tList<Integer> list1 = new ArrayList<>();\\n\\t\\tList<Integer> list2 = new ArrayList<>();\\n\\t\\tMap<Character, Integer> map = new HashMap<Character, Integer>();\\n\\t\\tfor(int i=0; i<string.length();i++) {\\n\\t\\t\\tif(map.containsKey(string.charAt(i))) {\\n\\t\\t\\t\\tmap.put(string.charAt(i), map.get(string.charAt(i))+1);\\n\\t\\t\\t}\\n\\t\\t\\tmap.putIfAbsent(string.charAt(i), 1);\\n\\t\\t}\\n\\n\\t\\tfor(Character c1 : map.keySet()) {\\n\\t\\t\\tint value = map.get(c1);\\n\\t\\t\\tif(value > 1) {\\n\\t\\t\\t\\tif(value % 2 == 0 ) {\\n\\t\\t\\t\\t\\tlist1.add(value);\\n\\t\\t\\t\\t}else {\\n\\t\\t\\t\\t\\tlist1.add(value-1);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tlist2.add(map.get(c1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(list1.size() == 0)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif(list2.size() == 0) \\n\\t\\t\\treturn list1.stream().mapToInt(Integer::intValue).sum();\\n\\n\\t\\treturn list1.stream().mapToInt(Integer::intValue).sum()+1;\\n    }\\t\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int longestAwesome(String string) {\\n\\t\\tList<Integer> list1 = new ArrayList<>();\\n\\t\\tList<Integer> list2 = new ArrayList<>();\\n\\t\\tMap<Character, Integer> map = new HashMap<Character, Integer>();\\n\\t\\tfor(int i=0; i<string.length();i++) {\\n\\t\\t\\tif(map.containsKey(string.charAt(i))) {\\n\\t\\t\\t\\tmap.put(string.charAt(i), map.get(string.charAt(i))+1);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3525043,
                "title": "c-bitmask-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[100005];\\n    int longestAwesome(string s) {\\n        \\n        dp[0]=dp[0]+1<<(s[0]-\\'0\\');\\n        \\n        for(int i=1;i<s.size();i++)\\n        {\\n            int temp=(dp[i-1]>>(s[i]-\\'0\\'))%2;\\n            int x=1<<(s[i]-\\'0\\');\\n            if(temp) dp[i]=dp[i-1]-x;\\n            else dp[i]=dp[i-1]+x;\\n        }\\n        int ans=1;\\n        map<int,int> m;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int x=dp[i];\\n            int l=dp[i]&(dp[i]-1);\\n\\n            // Case: 1 if no masked no. is present \\n            if(m[dp[i]]==0)m[dp[i]]=i+1;\\n            // Case:2 if same masked no. is present in the map\\n            else ans=max(ans,i+1-m[dp[i]]+1);\\n            // Case:3/4 if the value of mask no. is 0 i.e, all the numbers get balanced or the value is the mask no. just has one setbit i.e, only one no. has odd parity before the current index.\\n            if(dp[i]==0||(dp[i]&(dp[i]-1))==0) {ans=i+1;}\\n            // Case: 5 if same masked no. is present in the map if we will remove any one setbit from the current mask no. i.e, an odd parity no. is present in between the two ends of the no.\\n            for(int pos=0;pos<=10;pos++){\\n                int nwmask=dp[i]^(1<<pos);\\n                if(m.count(nwmask)){\\n                    ans=max(ans,i+1-m[nwmask]);\\n                }\\n            }\\n        }\\n            \\n        cout<<endl;\\n         return ans;\\n    }\\n};\\n\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[100005];\\n    int longestAwesome(string s) {\\n        \\n        dp[0]=dp[0]+1<<(s[0]-\\'0\\');\\n        \\n        for(int i=1;i<s.size();i++)\\n        {\\n            int temp=(dp[i-1]>>(s[i]-\\'0\\'))%2;\\n            int x=1<<(s[i]-\\'0\\');\\n            if(temp) dp[i]=dp[i-1]-x;\\n            else dp[i]=dp[i-1]+x;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1161457,
                "title": "simple-explanation-of-the-idea-using-bitmasking",
                "content": "If the subtring S[j....i] is making a palindrome then the XOR of this substring will be either 0(in case of even length palindrome) or only one of the 10 bit will be set(in case of odd length palindrome)\\n\\n1.In case of even length palindromic S[j.....i] is a palindromic substring then XOR(S[0....j-1]) and XOR(S[0....i]) should be the same  since XOR(S[j...i]) is zero.\\nSo we can use dp to get the last location we found the same XOR.\\n2.Similarly for odd length palindrome we can try setting each of the 10 bits and see if we got the same xor earlier.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s)\\n    {\\n        int n=s.length();\\n        vector<int> last(1025,n);//To store the last position of xor\\n        \\n        last[0]=-1;\\n        \\n        int ans=0,cur=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            cur^= 1<<(s[i]-\\'0\\');\\n            ans=max(ans,i-last[cur]);//suppose the last time curr mask was occured at jth position\\n                    //then xor of j.....i should be 0\\n            \\n            for(int j=0;j<10;j++)\\n            {\\n                ans=max(ans,i-last[cur ^ (1<<j)]);//if the palindrome is of odd length\\n            }\\n            last[cur]=min(last[cur],i);//The last location for which i found this mask\\n        }\\n             \\n        return ans;\\n    }\\n};\\n\\n```\\nPlease **Upvote** if you found this helpful.Any **Suggestions** are welcome",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s)\\n    {\\n        int n=s.length();\\n        vector<int> last(1025,n);//To store the last position of xor\\n        \\n        last[0]=-1;\\n        \\n        int ans=0,cur=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            cur^= 1<<(s[i]-\\'0\\');\\n            ans=max(ans,i-last[cur]);//suppose the last time curr mask was occured at jth position\\n                    //then xor of j.....i should be 0\\n            \\n            for(int j=0;j<10;j++)\\n            {\\n                ans=max(ans,i-last[cur ^ (1<<j)]);//if the palindrome is of odd length\\n            }\\n            last[cur]=min(last[cur],i);//The last location for which i found this mask\\n        }\\n             \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102430,
                "title": "java-hashmap-bits-xor-explaination",
                "content": "We use Xor operation to add/include elements. We check in the hashmap if at some previous index \\'n\\' we found the same Xor as current Xor. If yes then it mean all elements from index \\'n\\' to current index have even frequencies since their Xor is zero. but we can have atmost one digit with odd frequency. So for that we will use a for loop and check in th map for currXor Xored with any one digit. this is done to check odd length palindrome. Algorithm is similar to finding max Length subarray with sum equal to k OR 0.\\n```\\n\\tpublic int longestAwesome(String s) {\\n        Map<Integer,Integer> bitXor= new HashMap<>();\\n        bitXor.put(0,-1);\\n        int currXor= 0, maxLength= 0;\\n        for(int i=0; i<s.length(); i++){\\n            currXor^= (1<<(s.charAt(i)-\\'0\\'));\\n            if(bitXor.containsKey(currXor)) maxLength= Math.max(maxLength,i-bitXor.get(currXor));\\n            for(int j=0; j<=9; j++){\\n                int oddLength= currXor^(1<<j);\\n                if(bitXor.containsKey(oddLength)){\\n                    maxLength= Math.max(maxLength,i-bitXor.get(oddLength));\\n                }\\n            }\\n            bitXor.putIfAbsent(currXor,i);\\n        }\\n        return maxLength;\\n    }\\n",
                "solutionTags": [],
                "code": "We use Xor operation to add/include elements. We check in the hashmap if at some previous index \\'n\\' we found the same Xor as current Xor. If yes then it mean all elements from index \\'n\\' to current index have even frequencies since their Xor is zero. but we can have atmost one digit with odd frequency. So for that we will use a for loop and check in th map for currXor Xored with any one digit. this is done to check odd length palindrome. Algorithm is similar to finding max Length subarray with sum equal to k OR 0.\\n```\\n\\tpublic int longestAwesome(String s) {\\n        Map<Integer,Integer> bitXor= new HashMap<>();\\n        bitXor.put(0,-1);\\n        int currXor= 0, maxLength= 0;\\n        for(int i=0; i<s.length(); i++){\\n            currXor^= (1<<(s.charAt(i)-\\'0\\'));\\n            if(bitXor.containsKey(currXor)) maxLength= Math.max(maxLength,i-bitXor.get(currXor));\\n            for(int j=0; j<=9; j++){\\n                int oddLength= currXor^(1<<j);\\n                if(bitXor.containsKey(oddLength)){\\n                    maxLength= Math.max(maxLength,i-bitXor.get(oddLength));\\n                }\\n            }\\n            bitXor.putIfAbsent(currXor,i);\\n        }\\n        return maxLength;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 789284,
                "title": "python-o-n-solution-with-explanation",
                "content": "A substring is palindrome if all the numbers occurs even number of times or only one number occurs odd number of times.\\n\\nLet \\'n\\' represent the integer corresponding to the bit vector whether count of the digit k is even or odd.\\n\\n\\'0010100010\\' is the bit vector indicating that counts of digits 1, 5 and 7 are odd and the rest are even.\\n\\nAt each index i, update n by toggling the s[i]-th bit because if count of s[i] increments by 1 the bit toggles.\\nKeep a map from n to the last i.\\n\\nIf all the digits in the palindrome i to j occurs even number of times then n(i) = n(j+1). Thus check if n(i) has been seen earlier.\\n\\nTo check if any one digit occurs in odd number of times, for each digit j toggle the j-th bit in n(i) (call it m(i)) and check if we have seen m(i) earlier.\\n\\n```\\nclass Solution(object):\\n    def longestAwesome(self, s):\\n        n = 0\\n        pos_map = {0:len(s)}\\n        \\n        max_len = 1\\n        \\n        for i in range(len(s)-1, -1, -1):\\n            n = n ^ (1 << int(s[i]))\\n            \\n            if n in pos_map:\\n                max_len = max(max_len, pos_map[n]-i)\\n                \\n            for j in range(10):\\n                m = n ^ (1 << j)\\n                if m in pos_map:\\n                    max_len = max(max_len, pos_map[m]-i)\\n                    \\n            if n not in pos_map:\\n                pos_map[n] = i\\n        \\n        return max_len",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def longestAwesome(self, s):\\n        n = 0\\n        pos_map = {0:len(s)}",
                "codeTag": "Java"
            },
            {
                "id": 780420,
                "title": "javascript-bitwise-mask-prefix-xor-comments-explanation",
                "content": "First off, let\\'s deal with the palindromes. Any possible number of switches is allowed so I only have to deal with the frequency of the characters inside the string. Any string will be palindrome if every frequency is even, except maybe one. \\n\\nSo essentially, there are only 11 possible states Im interested in\\n1000000000,010000000,....,000000001,000000000\\n which mean that The only odd frequency seen so far is of the number i\\n  0<=i<=9\\n Prefix Xor part: \\nWell Every time i come across any new state, I save it as a key with the value being the index I first met that accumulative xor. Then, any time in the future, i come across the same state that means that inbetween value\\n\\n```\\nvar longestAwesome = function(s) {\\n    // freq starts with 0:0 because 9 0s is also a state and if I come across a \\n    // 0 down the road, that means that the whole array up to index i is of the required type\\n    let firstIndex={0:0}, result=-1, curr=0\\n    for (let i = 0; i < s.length; i++) {\\n       curr^= 1<<s[i]\\n       // Check if you have seen curr^0=curr before, \\n\\t   // because that would make the inbetween elements\\' xor = 000000000\\n       if(firstIndex[curr]!==undefined)\\n            result=Math.max(result,i-firstIndex[curr]+1)\\n       // Check all the other xors, because that would make \\n\\t   // the inbetween elements of the required type (100000000,010000000,......,000000001)\\n       for (let j = 0; j <10; j++) {\\n            let ele=1<<j\\n            if(firstIndex[curr^ele]!==undefined)\\n                //i-firstIndex[curr^ele] because on freq I saved\\n\\t\\t\\t\\t//the smallest index where I last met curr^ele\\n                result=Math.max(result,i-firstIndex[curr^ele]+1)\\n       }\\n       if(firstIndex[curr]===undefined)\\n\\t\\t   firstIndex[curr]=i+1// +1 cos 0th place is for my 0 state\\n    }\\n \\n    return result\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nvar longestAwesome = function(s) {\\n    // freq starts with 0:0 because 9 0s is also a state and if I come across a \\n    // 0 down the road, that means that the whole array up to index i is of the required type\\n    let firstIndex={0:0}, result=-1, curr=0\\n    for (let i = 0; i < s.length; i++) {\\n       curr^= 1<<s[i]\\n       // Check if you have seen curr^0=curr before, \\n\\t   // because that would make the inbetween elements\\' xor = 000000000\\n       if(firstIndex[curr]!==undefined)\\n            result=Math.max(result,i-firstIndex[curr]+1)\\n       // Check all the other xors, because that would make \\n\\t   // the inbetween elements of the required type (100000000,010000000,......,000000001)\\n       for (let j = 0; j <10; j++) {\\n            let ele=1<<j\\n            if(firstIndex[curr^ele]!==undefined)\\n                //i-firstIndex[curr^ele] because on freq I saved\\n\\t\\t\\t\\t//the smallest index where I last met curr^ele\\n                result=Math.max(result,i-firstIndex[curr^ele]+1)\\n       }\\n       if(firstIndex[curr]===undefined)\\n\\t\\t   firstIndex[curr]=i+1// +1 cos 0th place is for my 0 state\\n    }\\n \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3414556,
                "title": "intuitive-bit-mask-solution-with-comments",
                "content": "# Intuition\\nWant to use a bitmask to subsitute a dictionary because our alphabet is a fixed length (the numebr of digits \"0-9\" = 10 digits). Similar to Prefix Sum + Hashmap Medium problems, but with a bitmask spin to get lower time and space complexity. \\n\\n# Approach\\nRead in-text comments\\n\\n# Complexity\\n- Time complexity:\\nO(N) for the outer for loop and O(10) for inner for loop = O(10 * N) = O(N)\\n\\n- Space complexity:\\nO(1), because of bitmask\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        int ans = 0;\\n        // Mask = 0b0000000000 -> There are 10 zeroes because we have 10 possible vals 0-9 as our alphabet\\n        // 0th place is 1 if we have odd number of 0s and 0 if we have even number of 0s\\n        // 1th place is 1 ... \\n        int mask = 0;\\n\\n        HashMap<Integer, Integer> map = new HashMap();\\n        map.put(0, -1);\\n\\n        for (int idx = 0; idx < s.length(); idx++) {\\n            // lets say s.charAt(idx) == 3. We shift 0b1 by 3 so that we get 0b1000\\n            // lets say mask = 0b1000 -> the xOr will evaluate to 0b000\\n            // This means we had an odd number of 3s now we have an even number of all values\\n            mask ^= 1 << (s.charAt(idx) - \\'0\\');\\n\\n\\n            // If we see matching masks then that means the number of odd characters \\n            // and those corresponding characters that are odd are the same\\n            // Substracting one substring from another we get a new susbtring with no odd freq characters\\n            if (map.containsKey(mask)) {\\n                ans = Math.max(ans, idx - map.get(mask));\\n            } else {\\n                map.put(mask, idx);\\n            }\\n\\n            // Palindrome can also have 1 character with an odd freq (in the middle)\\n            for (int shift = 0; shift < 10; shift++) {\\n                // Consider all masks that differ by mask in 1 place\\n                int oddMask = mask ^ (1 << shift);\\n\\n                if (map.containsKey(oddMask)) {\\n                    ans = Math.max(ans, idx - map.get(oddMask));\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        int ans = 0;\\n        // Mask = 0b0000000000 -> There are 10 zeroes because we have 10 possible vals 0-9 as our alphabet\\n        // 0th place is 1 if we have odd number of 0s and 0 if we have even number of 0s\\n        // 1th place is 1 ... \\n        int mask = 0;\\n\\n        HashMap<Integer, Integer> map = new HashMap();\\n        map.put(0, -1);\\n\\n        for (int idx = 0; idx < s.length(); idx++) {\\n            // lets say s.charAt(idx) == 3. We shift 0b1 by 3 so that we get 0b1000\\n            // lets say mask = 0b1000 -> the xOr will evaluate to 0b000\\n            // This means we had an odd number of 3s now we have an even number of all values\\n            mask ^= 1 << (s.charAt(idx) - \\'0\\');\\n\\n\\n            // If we see matching masks then that means the number of odd characters \\n            // and those corresponding characters that are odd are the same\\n            // Substracting one substring from another we get a new susbtring with no odd freq characters\\n            if (map.containsKey(mask)) {\\n                ans = Math.max(ans, idx - map.get(mask));\\n            } else {\\n                map.put(mask, idx);\\n            }\\n\\n            // Palindrome can also have 1 character with an odd freq (in the middle)\\n            for (int shift = 0; shift < 10; shift++) {\\n                // Consider all masks that differ by mask in 1 place\\n                int oddMask = mask ^ (1 << shift);\\n\\n                if (map.containsKey(oddMask)) {\\n                    ans = Math.max(ans, idx - map.get(oddMask));\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287021,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        // 3 2 4 2 4 1 5\\n        unordered_map<int,int>mp;\\n        int ans=1;\\n        int num=0;\\n        mp[0]=-1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            num=num^(1<<(s[i]-\\'0\\'));\\n            // case 1\\n            if(mp.find(num)!=mp.end())\\n            {\\n                ans=max(ans,i-mp[num]);\\n            }\\n            // checking for palindrome\\n            for(int j=0;j<=9;j++)\\n            {\\n                int mask=num^(1<<j);\\n                if(mp.find(mask)!=mp.end())\\n                {\\n                    ans=max(ans,i-mp[mask]);\\n                }\\n            }\\n            if(mp.find(num)==mp.end())\\n            {\\n                mp[num]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        // 3 2 4 2 4 1 5\\n        unordered_map<int,int>mp;\\n        int ans=1;\\n        int num=0;\\n        mp[0]=-1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            num=num^(1<<(s[i]-\\'0\\'));\\n            // case 1\\n            if(mp.find(num)!=mp.end())\\n            {\\n                ans=max(ans,i-mp[num]);\\n            }\\n            // checking for palindrome\\n            for(int j=0;j<=9;j++)\\n            {\\n                int mask=num^(1<<j);\\n                if(mp.find(mask)!=mp.end())\\n                {\\n                    ans=max(ans,i-mp[mask]);\\n                }\\n            }\\n            if(mp.find(num)==mp.end())\\n            {\\n                mp[num]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802585,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int longestAwesome(string s) {\\n    vector<int> dp(1024, s.size());\\n    int res = 0, mask = 0;\\n    dp[0] = -1;\\n    for (auto i = 0; i < s.size(); ++i) {\\n        mask ^= 1 << (s[i] - \\'0\\');\\n        res = max(res, i - dp[mask]);\\n        for (auto j = 0; j <= 9; ++j)\\n            res = max(res, i - dp[mask ^ (1 << j)]);\\n        dp[mask] = min(dp[mask], i);\\n    }\\n    return res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int longestAwesome(string s) {\\n    vector<int> dp(1024, s.size());\\n    int res = 0, mask = 0;\\n    dp[0] = -1;\\n    for (auto i = 0; i < s.size(); ++i) {\\n        mask ^= 1 << (s[i] - \\'0\\');\\n        res = max(res, i - dp[mask]);\\n        for (auto j = 0; j <= 9; ++j)\\n            res = max(res, i - dp[mask ^ (1 << j)]);\\n        dp[mask] = min(dp[mask], i);\\n    }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259262,
                "title": "python3-prefix-xor-o-n-solution",
                "content": "Time Complexity: O(n) ->  O(512n) in worst case?\\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        # li = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\\n        li = [2**i for i in range(10)]\\n        # checker = {0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512}\\n        checker = set(li)\\n        checker.add(0)\\n        # di: k = prefix xor, v = the first idx I got a new prefix_xor_value.\\n        di = collections.OrderedDict({0: -1})\\n        maxLength = prefix_xor = 0\\n        \\n        for i in range(len(s)):\\n            prefix_xor ^= li[int(s[i])]\\n            # Found a new prefix_xor_value\\n            if prefix_xor not in di:\\n                di[prefix_xor] = i\\n            \\n            # XOR operation with previous prefix_xor_value\\n            for key in di.keys():\\n                if i - di[key] <= maxLength:\\n                    break\\n\\t\\t\\t\\t# s[di[key] : i] is Awesome Substring\\n                if key ^ prefix_xor in checker:\\n                    maxLength = i - di[key]\\n        return maxLength\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        # li = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\\n        li = [2**i for i in range(10)]\\n        # checker = {0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512}\\n        checker = set(li)\\n        checker.add(0)\\n        # di: k = prefix xor, v = the first idx I got a new prefix_xor_value.\\n        di = collections.OrderedDict({0: -1})\\n        maxLength = prefix_xor = 0\\n        \\n        for i in range(len(s)):\\n            prefix_xor ^= li[int(s[i])]\\n            # Found a new prefix_xor_value\\n            if prefix_xor not in di:\\n                di[prefix_xor] = i\\n            \\n            # XOR operation with previous prefix_xor_value\\n            for key in di.keys():\\n                if i - di[key] <= maxLength:\\n                    break\\n\\t\\t\\t\\t# s[di[key] : i] is Awesome Substring\\n                if key ^ prefix_xor in checker:\\n                    maxLength = i - di[key]\\n        return maxLength\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875354,
                "title": "c-easy-understanding-explained-with-comments-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    // Similar to :-\\n    // https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/\\n\\t// To understand logic behind using xor here , see:\\n\\t// https://leetcode.com/submissions/detail/665490340/\\n\\t//\\n    int longestAwesome(string s) {\\n        int parity = 0000000000 ; // 9-8-7..1-0\\n        unordered_map <int,int> m ;\\n        m[0] = 0; // empty case\\n        int ans = 0;\\n        for ( int i = 0;i<s.length();i++){\\n            int x = s[i]-\\'0\\';\\n            parity ^= (1<<x);\\n            if(m.find(parity)!=m.end()){ // for 0 case\\n                    ans=max(ans,i+1-m[parity]);\\n                    m[parity]=min(m[parity],i+1);\\n            }\\n            for ( int j=0 ; j<=9;j++)\\n                if(m.find(parity^(1<<j))!=m.end())\\n                    ans=max(ans,i+1-m[parity^(1<<j)]);\\n            if(m.find(parity)==m.end())\\n                m[parity]=i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Similar to :-\\n    // https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/\\n\\t// To understand logic behind using xor here , see:\\n\\t// https://leetcode.com/submissions/detail/665490340/\\n\\t//\\n    int longestAwesome(string s) {\\n        int parity = 0000000000 ; // 9-8-7..1-0\\n        unordered_map <int,int> m ;\\n        m[0] = 0; // empty case\\n        int ans = 0;\\n        for ( int i = 0;i<s.length();i++){\\n            int x = s[i]-\\'0\\';\\n            parity ^= (1<<x);\\n            if(m.find(parity)!=m.end()){ // for 0 case\\n                    ans=max(ans,i+1-m[parity]);\\n                    m[parity]=min(m[parity],i+1);\\n            }\\n            for ( int j=0 ; j<=9;j++)\\n                if(m.find(parity^(1<<j))!=m.end())\\n                    ans=max(ans,i+1-m[parity^(1<<j)]);\\n            if(m.find(parity)==m.end())\\n                m[parity]=i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751201,
                "title": "c-clean-and-simple-with-important-comments",
                "content": "we just need to find the longest substring wth atmax 1 character occuring odd number of times\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.length();\\n        unordered_map<int,int>M;\\n        M[0] = -1;\\n        int mask = 0;\\n        int max_len = 0;\\n        for(int i = 0;i < n; i++)\\n        {\\n            mask ^= (1 << (s[i] - \\'0\\'));\\n            if(M.find(mask) == M.end())\\n                M[mask] = i;\\n            else//all the character are of even occurances\\n            {\\n                max_len = max(max_len, i - M[mask]);\\n                \\n            }\\n\\t\\t\\t//at max 1 occurance of a character is fine \\n            for(int j = 0; j <= 9; j++)\\n            {\\n                if(M.find(mask ^ (1 << j)) != M.end())\\n                    max_len = max(max_len, i - M[mask ^ (1 << j)]);\\n            }\\n        }\\n        return max_len;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.length();\\n        unordered_map<int,int>M;\\n        M[0] = -1;\\n        int mask = 0;\\n        int max_len = 0;\\n        for(int i = 0;i < n; i++)\\n        {\\n            mask ^= (1 << (s[i] - \\'0\\'));\\n            if(M.find(mask) == M.end())\\n                M[mask] = i;\\n            else//all the character are of even occurances\\n            {\\n                max_len = max(max_len, i - M[mask]);\\n                \\n            }\\n\\t\\t\\t//at max 1 occurance of a character is fine \\n            for(int j = 0; j <= 9; j++)\\n            {\\n                if(M.find(mask ^ (1 << j)) != M.end())\\n                    max_len = max(max_len, i - M[mask ^ (1 << j)]);\\n            }\\n        }\\n        return max_len;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744050,
                "title": "python-bit-mask",
                "content": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n\\t    #keeps track of last index where this state was seen\\n        last_seen={}\\n        ans=0\\n        mask=0\\n        last_seen[mask]=-1\\n        for i,c in enumerate(s):\\n            c=int(c)\\n            mask ^= (1<<c)\\n            if mask in last_seen:\\n                ans=max(ans,i-last_seen[mask])\\n            else:\\n                last_seen[mask]=i\\n\\t\\t\\t#checking for one odd char in palindrome\\n            for x in range(10):\\n                new_mask=mask ^ (1<<x)\\n                if new_mask in last_seen:\\n                    ans=max(ans,i-last_seen[new_mask])\\n        return ans\\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n\\t    #keeps track of last index where this state was seen\\n        last_seen={}\\n        ans=0\\n        mask=0\\n        last_seen[mask]=-1\\n        for i,c in enumerate(s):\\n            c=int(c)\\n            mask ^= (1<<c)\\n            if mask in last_seen:\\n                ans=max(ans,i-last_seen[mask])\\n            else:\\n                last_seen[mask]=i\\n\\t\\t\\t#checking for one odd char in palindrome\\n            for x in range(10):\\n                new_mask=mask ^ (1<<x)\\n                if new_mask in last_seen:\\n                    ans=max(ans,i-last_seen[new_mask])\\n        return ans\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 855538,
                "title": "java-o-n-solution-shortest",
                "content": "I have implemented BitMasking with HashMap since ther is only 10 possible characters.\\n```\\npublic int longestAwesome(String s) {\\n        \\n        \\n        int l=s.length(),x=0,res=0;\\n        HashMap<Integer,Integer> h=new HashMap<>();\\n        h.put(0,-1);\\n        for(int i=0;i<l;i++)\\n        {\\n            x=x^(1<<(s.charAt(i)-\\'0\\'));\\n            if(h.containsKey(x))\\n            res=Math.max(res,i-h.get(x));\\n            else\\n            h.put(x,i);\\n            \\n            for(int j=0;j<10;j++)\\n            {\\n                if(h.containsKey(x^(1<<j)))\\n                res = Math.max(res,i-h.get(x^(1<<j)));\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```\\n\\nIncase, of any explanation is required for the above solution, let me know.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\npublic int longestAwesome(String s) {\\n        \\n        \\n        int l=s.length(),x=0,res=0;\\n        HashMap<Integer,Integer> h=new HashMap<>();\\n        h.put(0,-1);\\n        for(int i=0;i<l;i++)\\n        {\\n            x=x^(1<<(s.charAt(i)-\\'0\\'));\\n            if(h.containsKey(x))\\n            res=Math.max(res,i-h.get(x));\\n            else\\n            h.put(x,i);\\n            \\n            for(int j=0;j<10;j++)\\n            {\\n                if(h.containsKey(x^(1<<j)))\\n                res = Math.max(res,i-h.get(x^(1<<j)));\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 806334,
                "title": "python-traverse-from-longest",
                "content": "```\\n# I am assuming they mean contiguous substrings\\n\\nfrom collections import Counter\\n\\ndef palindromable(s):\\n    # to be palindromable there needs to be an even number of all chars except one odd is acceptable\\n    counts = Counter(s)\\n    num_odds = 0\\n    for char, ct in counts.items():\\n        if ct % 2 != 0:\\n            num_odds += 1\\n            if num_odds > 1:\\n                return False\\n    return True\\n\\ndef findlength(s: str) -> int:\\n\\t# traverse from longest contiguous substrings\\n\\tnum_chars = len(s)\\n\\tfor num_dropped in range(num_chars):\\n\\t\\tfor left_idx in range(num_dropped + 1):\\n\\t\\t\\tright_idx = num_chars - (num_dropped - left_idx)\\n\\t\\t\\tsub_s = s[left_idx: right_idx]\\n\\t\\t\\tif palindromable(sub_s):\\n\\t\\t\\t\\toutput = num_chars - num_dropped\\n\\t\\t\\t\\treturn output\\n\\t```",
                "solutionTags": [],
                "code": "```\\n# I am assuming they mean contiguous substrings\\n\\nfrom collections import Counter\\n\\ndef palindromable(s):\\n    # to be palindromable there needs to be an even number of all chars except one odd is acceptable\\n    counts = Counter(s)\\n    num_odds = 0\\n    for char, ct in counts.items():\\n        if ct % 2 != 0:\\n            num_odds += 1\\n            if num_odds > 1:\\n                return False\\n    return True\\n\\ndef findlength(s: str) -> int:\\n\\t# traverse from longest contiguous substrings\\n\\tnum_chars = len(s)\\n\\tfor num_dropped in range(num_chars):\\n\\t\\tfor left_idx in range(num_dropped + 1):\\n\\t\\t\\tright_idx = num_chars - (num_dropped - left_idx)\\n\\t\\t\\tsub_s = s[left_idx: right_idx]\\n\\t\\t\\tif palindromable(sub_s):\\n\\t\\t\\t\\toutput = num_chars - num_dropped\\n\\t\\t\\t\\treturn output\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 801683,
                "title": "c-unordered-map-bitmask",
                "content": "```\\n        vector<int> pbit = {0};\\n        for(int i=0; i<10; i++) pbit.push_back(1<<i);\\n        unordered_map<int, int> bitmap; //bit, index\\n        bitmap[0] = -1;\\n        int res = 0, bits = 0;\\n        for(int i=0; i<s.size(); i++){\\n            bits ^= (1<<(s[i]-\\'0\\'));\\n            for(auto x:pbit){\\n                auto it = bitmap.find(bits ^ x);\\n                if(it != bitmap.end()){\\n                    res = max(res, i - it->second);\\n                }\\n            }\\n            if(!bitmap.count(bits)) bitmap[bits] = i;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n        vector<int> pbit = {0};\\n        for(int i=0; i<10; i++) pbit.push_back(1<<i);\\n        unordered_map<int, int> bitmap; //bit, index\\n        bitmap[0] = -1;\\n        int res = 0, bits = 0;\\n        for(int i=0; i<s.size(); i++){\\n            bits ^= (1<<(s[i]-\\'0\\'));\\n            for(auto x:pbit){\\n                auto it = bitmap.find(bits ^ x);\\n                if(it != bitmap.end()){\\n                    res = max(res, i - it->second);\\n                }\\n            }\\n            if(!bitmap.count(bits)) bitmap[bits] = i;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 784632,
                "title": "python3-prefix-xor",
                "content": "Toggle bit to indicate if a number has appeared even/odd number of times. \\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        ans = prefix = 0\\n        seen = {0: -1}\\n        for i, c in enumerate(s):\\n            prefix ^= 1 << int(c) #toggle bit \\n            ans = max(ans, i - seen.get(prefix, inf))\\n            for k in range(10): \\n                x = prefix ^ (1 << k) #toggle kth bit \\n                ans = max(ans, i - seen.get(x, inf))\\n            seen.setdefault(prefix, i)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        ans = prefix = 0\\n        seen = {0: -1}\\n        for i, c in enumerate(s):\\n            prefix ^= 1 << int(c) #toggle bit \\n            ans = max(ans, i - seen.get(prefix, inf))\\n            for k in range(10): \\n                x = prefix ^ (1 << k) #toggle kth bit \\n                ans = max(ans, i - seen.get(x, inf))\\n            seen.setdefault(prefix, i)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 780127,
                "title": "easy-bitmasking-o-n-solution-c",
                "content": "Solved using Bitmasking!\\nSimple O(n)\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n=s.size(),ans=0;\\n        vector<int> mask(1<<10,-1);\\n        vector<int>count(10);\\n        mask[0]=-1;\\n        for(int i=0;i<n;i++){\\n            count[s[i]-\\'0\\']++;\\n            int temp=0;\\n            for(int j=0;j<10;j++){\\n                if(count[j]&1)temp|=(1<<j);\\n            }\\n            int req=0,chk=0;\\n            for(int j=0;j<10;j++){\\n                if((temp)&(1<<j))req|=(1<<j),chk++;\\n            }\\n            if(chk<=1){\\n                ans=max(ans,i+1);\\n            }\\n            else{\\n                if(mask[req]!=-1)ans=max(ans,i-mask[req]+1);//all zero\\n                for(int j=0;j<10;j++){\\n                    //jth bit is one and else zero\\n                    int Z=0;\\n                    if(temp&(1<<j)){\\n                        Z=req^(1<<j);\\n                    }else{\\n                        Z=req|(1<<j); \\n                    }\\n                    if(mask[Z]!=-1)ans=max(ans,i-mask[Z]);\\n                }                \\n            }\\n            if(mask[temp]==-1)\\n                mask[temp]=i;\\n            // cout<<i<<\" \"<<ans<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n=s.size(),ans=0;\\n        vector<int> mask(1<<10,-1);\\n        vector<int>count(10);\\n        mask[0]=-1;\\n        for(int i=0;i<n;i++){\\n            count[s[i]-\\'0\\']++;\\n            int temp=0;\\n            for(int j=0;j<10;j++){\\n                if(count[j]&1)temp|=(1<<j);\\n            }\\n            int req=0,chk=0;\\n            for(int j=0;j<10;j++){\\n                if((temp)&(1<<j))req|=(1<<j),chk++;\\n            }\\n            if(chk<=1){\\n                ans=max(ans,i+1);\\n            }\\n            else{\\n                if(mask[req]!=-1)ans=max(ans,i-mask[req]+1);//all zero\\n                for(int j=0;j<10;j++){\\n                    //jth bit is one and else zero\\n                    int Z=0;\\n                    if(temp&(1<<j)){\\n                        Z=req^(1<<j);\\n                    }else{\\n                        Z=req|(1<<j); \\n                    }\\n                    if(mask[Z]!=-1)ans=max(ans,i-mask[Z]);\\n                }                \\n            }\\n            if(mask[temp]==-1)\\n                mask[temp]=i;\\n            // cout<<i<<\" \"<<ans<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 779922,
                "title": "java-prefix-bitmask-o-10-n",
                "content": "Similar idea to https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/\\n\\nBut additionally at each step we check for complements that add to power of two. Power of two since a palindrome can contain at most 1 odd number of characters.\\n\\n```\\n    public int longestAwesome(String s) {\\n        final Map<Integer, Integer> idx = new HashMap<>(Collections.singletonMap(0, -1));\\n        int res = 0, mask = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            mask ^= 1 << (s.charAt(i) - \\'0\\');\\n            idx.putIfAbsent(mask, i);\\n            res = Math.max(res, i - idx.getOrDefault(mask, i));\\n            for (int value = 1; value <= (1 << 10); value <<= 1) {\\n                final int complement = value ^ mask;\\n                res = Math.max(res, i - idx.getOrDefault(complement, i));\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int longestAwesome(String s) {\\n        final Map<Integer, Integer> idx = new HashMap<>(Collections.singletonMap(0, -1));\\n        int res = 0, mask = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            mask ^= 1 << (s.charAt(i) - \\'0\\');\\n            idx.putIfAbsent(mask, i);\\n            res = Math.max(res, i - idx.getOrDefault(mask, i));\\n            for (int value = 1; value <= (1 << 10); value <<= 1) {\\n                final int complement = value ^ mask;\\n                res = Math.max(res, i - idx.getOrDefault(complement, i));\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779898,
                "title": "c-o-11n-bitmask",
                "content": "[a, b] is an awesome substring if at most one letter appears odd number of times in [a, b].\\n\\nlet dp[i] = parity of each letter in [0, i] by setting j-th bit to 1 if \\'j\\' appears odd number of times in [0, i], otherwise 0.\\n\\ns[a, b] is an awesome substring if dp[a] ^ dp[b] == 0 or (1 << k) for some k\\n\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        vector<int> dp(1 << 10, -1);\\n        int x = 0;\\n        for(int i = 0; i < n; ++i) {\\n            x ^= 1 << (s[i] - \\'0\\');\\n            dp[x] = i;\\n        }\\n        int ans = 1;\\n        x = 0;\\n        for(int i = 0; i < n; ++i) {\\n            ans = max(ans, dp[x] - i + 1);\\n            for(int j = 0; j < 10; ++j) {\\n                ans = max(ans, dp[x ^ (1 << j)] - i + 1);\\n            }\\n            x ^= 1 << (s[i] - \\'0\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        vector<int> dp(1 << 10, -1);\\n        int x = 0;\\n        for(int i = 0; i < n; ++i) {\\n            x ^= 1 << (s[i] - \\'0\\');\\n            dp[x] = i;\\n        }\\n        int ans = 1;\\n        x = 0;\\n        for(int i = 0; i < n; ++i) {\\n            ans = max(ans, dp[x] - i + 1);\\n            for(int j = 0; j < 10; ++j) {\\n                ans = max(ans, dp[x ^ (1 << j)] - i + 1);\\n            }\\n            x ^= 1 << (s[i] - \\'0\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975112,
                "title": "c-hash-table-bitmasking",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        unordered_map<int,int> m;\\n        int mask = 0;\\n        m[mask] = -1;\\n        int ans = INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            mask^=(1<<(s[i]-\\'0\\'));\\n            if(m.find(mask)!=m.end())\\n            {\\n                ans = max(ans,i-m[mask]);\\n            }\\n            for(int j=0;j<=9;j++)\\n            {\\n                int tmp = mask^(1<<j);\\n                if(m.find(tmp)!=m.end())\\n                ans = max(ans,i-m[tmp]);\\n            }\\n            if(m.find(mask)==m.end())\\n            m[mask] = i;\\n        }\\n        if(ans==INT_MIN)\\n        return 1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        unordered_map<int,int> m;\\n        int mask = 0;\\n        m[mask] = -1;\\n        int ans = INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            mask^=(1<<(s[i]-\\'0\\'));\\n            if(m.find(mask)!=m.end())\\n            {\\n                ans = max(ans,i-m[mask]);\\n            }\\n            for(int j=0;j<=9;j++)\\n            {\\n                int tmp = mask^(1<<j);\\n                if(m.find(tmp)!=m.end())\\n                ans = max(ans,i-m[tmp]);\\n            }\\n            if(m.find(mask)==m.end())\\n            m[mask] = i;\\n        }\\n        if(ans==INT_MIN)\\n        return 1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903963,
                "title": "bitmask",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n\\n     unordered_map<int,int>mp;\\n        mp[0]=-1;\\n      \\n         int mask=0; \\n          int ans=1;\\n          \\n          for(int i=0;i<s.size();i++){\\n            mask=mask ^( 1<<(s[i]-\\'0\\')); \\n            if(mp.find(mask)!=mp.end()) ans=max(ans,i-mp[mask]);\\n            else mp[mask]=i;\\n        \\n            for(int k=0;k<=9;k++){\\n                  int num=mask^(1<<k);\\n                if(mp.find(num)!=mp.end()) ans=max(i-mp[num],ans);\\n            }\\n     \\n        \\n          }\\n          return  ans;\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n\\n     unordered_map<int,int>mp;\\n        mp[0]=-1;\\n      \\n         int mask=0; \\n          int ans=1;\\n          \\n          for(int i=0;i<s.size();i++){\\n            mask=mask ^( 1<<(s[i]-\\'0\\')); \\n            if(mp.find(mask)!=mp.end()) ans=max(ans,i-mp[mask]);\\n            else mp[mask]=i;\\n        \\n            for(int k=0;k<=9;k++){\\n                  int num=mask^(1<<k);\\n                if(mp.find(num)!=mp.end()) ans=max(i-mp[num],ans);\\n            }\\n     \\n        \\n          }\\n          return  ans;\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858394,
                "title": "bit-masking-and-prefix-sum-c",
                "content": "# Intuition\\nWe know a string can only become a palindrome in 2 cases :-\\n1. If all the distinct elements occurs even no. of times.\\n2. If all the distinct elements except one occurs even no. of times.\\n\\nWe have to find the longest substring that satistfies any one of the above condition.\\n\\n# Approach\\nWe will check for each index if the string ending at it can become palindrome (i.e satisifies above condtion).\\nIf it doesn\\'t then we will check if removing a substring from its behind helps it become palindrome.\\n\\nSince the elements present are all digits `(0 - 9)`, we will create bitmask for each index and store them in a prefix array.\\nEach index in the bitmask represents corresponding digit.\\n\\n`0` bit represents that digit at that index have occured even no. of times, `1` represents odd no. of times.\\n\\nAfter forming the prefix array, we will traverse the string along with maintaining a hashmap to store previously seen bitmask.\\n\\nfor each index i, \\n**if** \\nmask == 0 (means all no.s occur even no. of times) \\nor mask contains only one 1 i.e it\\'s a power of 2 (means all no.s except 1 occurs even no. of times),\\nthen we will calculate length of string\\n\\n**else** \\nwe will check if there exists a mask before, xoring with which we get 0\\n\\ncurMask ^ toBeFindMask = 0\\ntoBeFindMask = 0 ^ curMask\\ntoBeFindMask = curMask\\n\\nor we will check if there exists a mask before, xoring with which we get a no. which contains only one 1.\\n\\ncurMask ^ toBeFindMask = $$2^x$$  (0 <= x <= 9)\\ntoBeFindMask = $$2^x$$ ^ curMask\\n\\nand update max length string found.\\n\\nStore the bit mask only if it is not seen already, that way we can get the farthest index from current index when we search for it, thereby getting maximum length \\n\\n\\n# Complexity\\n- Time complexity: $$O(10*n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        vector<int> prefix(n+1);\\n        for(int i=0; i<n; i++){\\n            int bit = s[i] - \\'0\\';\\n            prefix[i+1] = prefix[i] ^ (1 << bit);\\n        }\\n\\n        unordered_map<int,int> mp;\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            int mask = prefix[i+1];\\n            \\n            // mask == 0 means all numbers present even times\\n            // mask with all 0 except 1 means all numbers present even times except one\\n            if(mask == 0 || !(mask & (mask-1))){\\n                ans = max(ans, i+1);\\n            }\\n            else{\\n                // check if a mask exist with which if we take XOR we\\'ll get a 0\\n                // that means check if same mask exist previously\\n                if(mp.count(mask)){\\n                    ans = max(ans, i-mp[mask]);\\n                }\\n                // check if a mask exist with which if we take XOR we\\'ll get a number which have only one 1\\n                for(int j=0; j<10; j++){\\n                    int submask = (1 << j);\\n                    int f = mask ^ submask;\\n                    \\n                    if(mp.count(f)){\\n                        ans = max(ans, i - mp[f]);\\n                    }\\n                }\\n            }\\n            if(!mp.count(mask)){\\n                mp[mask] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        vector<int> prefix(n+1);\\n        for(int i=0; i<n; i++){\\n            int bit = s[i] - \\'0\\';\\n            prefix[i+1] = prefix[i] ^ (1 << bit);\\n        }\\n\\n        unordered_map<int,int> mp;\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            int mask = prefix[i+1];\\n            \\n            // mask == 0 means all numbers present even times\\n            // mask with all 0 except 1 means all numbers present even times except one\\n            if(mask == 0 || !(mask & (mask-1))){\\n                ans = max(ans, i+1);\\n            }\\n            else{\\n                // check if a mask exist with which if we take XOR we\\'ll get a 0\\n                // that means check if same mask exist previously\\n                if(mp.count(mask)){\\n                    ans = max(ans, i-mp[mask]);\\n                }\\n                // check if a mask exist with which if we take XOR we\\'ll get a number which have only one 1\\n                for(int j=0; j<10; j++){\\n                    int submask = (1 << j);\\n                    int f = mask ^ submask;\\n                    \\n                    if(mp.count(f)){\\n                        ans = max(ans, i - mp[f]);\\n                    }\\n                }\\n            }\\n            if(!mp.count(mask)){\\n                mp[mask] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825043,
                "title": "python-simple-bit-manipulation",
                "content": "```\\n\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        d,mask,ans={},0,0\\n        d[0]=-1\\n        for i in range(len(s)):\\n            num=ord(s[i])-ord(\\'0\\')\\n            mask=mask^(1<<num)\\n            if mask in d:\\n                ans=max(ans,i-d[mask])\\n            else:\\n                d[mask]=i\\n            for j in range(0,10):\\n                temp=mask^(1<<j)\\n                if temp in d:\\n                    ans=max(ans,i-d[temp])\\n        return ans \\n                    \\n```\\nPlease upvote",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "```\\n\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        d,mask,ans={},0,0\\n        d[0]=-1\\n        for i in range(len(s)):\\n            num=ord(s[i])-ord(\\'0\\')\\n            mask=mask^(1<<num)\\n            if mask in d:\\n                ans=max(ans,i-d[mask])\\n            else:\\n                d[mask]=i\\n            for j in range(0,10):\\n                temp=mask^(1<<j)\\n                if temp in d:\\n                    ans=max(ans,i-d[temp])\\n        return ans \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811807,
                "title": "bitmask-cpp-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n=s.size();\\n\\n        int mask=0;\\n        unordered_map<int,int>mp;\\n        mp[0]=-1;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {   \\n            mask = mask^(1<<(s[i]-\\'0\\'));           \\n\\n            for(int j=0;j<10;j++)\\n            {\\n                int new_mask = mask^(1<<j);\\n\\n                if(mp.find(new_mask)!=mp.end())\\n                ans=max(ans,i-mp[new_mask]);\\n            }\\n            if(mp.find(mask)==mp.end())\\n            mp[mask] = i;\\n            else \\n            ans = max(ans,i-mp[mask]);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n=s.size();\\n\\n        int mask=0;\\n        unordered_map<int,int>mp;\\n        mp[0]=-1;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {   \\n            mask = mask^(1<<(s[i]-\\'0\\'));           \\n\\n            for(int j=0;j<10;j++)\\n            {\\n                int new_mask = mask^(1<<j);\\n\\n                if(mp.find(new_mask)!=mp.end())\\n                ans=max(ans,i-mp[new_mask]);\\n            }\\n            if(mp.find(mask)==mp.end())\\n            mp[mask] = i;\\n            else \\n            ans = max(ans,i-mp[mask]);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798274,
                "title": "providing-a-link-pattern-can-anyone-do-this-question-with-same-pattern",
                "content": "https://leetcode.com/problems/minimum-window-substring/solutions/26808/Here-is-a-10-line-template-that-can-solve-most-\\'substring\\'-problems/\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3797684,
                "title": "bitmask-prefix-xor-explaination",
                "content": "if looked carefully, this question reduces to the problem which is a slight variation of the problem\\nhttps://leetcode.com/problems/number-of-wonderful-substrings/\\n\\nif we want to make a substing palindrome, it either could have even length or odd length, for even length palindrome, we need all the constituting characters to occur even number of times, \\nand to have a palindrome of odd length, we need all the other characters to occur even number of times except that one character at the middle which will occur once. \\n\\nSo, at last the problem reduces to finding the length of longest substring that has at most 1 character that occurs odd number of times.\\n\\nhere is the solution, we will be storing the first index of every prefix xor.\\n\\nclass Solution {\\npublic:\\n\\n    int longestAwesome(string s) {\\n\\t\\n        // i think the question reduces to finding the longest substring having at at most one character that occurs odd number of times\\n        \\n        int mask=0;\\n        unordered_map<int,int> m;\\n        \\n        m[0]=-1; // prefix xor and its index\\n        int ans=INT_MIN;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            mask^= (1<<(s[i]-\\'0\\'));\\n            \\n            if(m.count(mask^0))\\n                ans= max(ans,i-m[mask^0]);\\n            \\n            for(int k=0;k<32;k++)\\n            {\\n                int copy= mask;\\n                \\n                copy^=(1<<k);\\n                \\n                if(m.count(copy))\\n                    ans= max(ans,i-m[copy]);\\n            }\\n            if(m.count(mask)==0)\\n                m[mask]=i;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int longestAwesome(string s) {\\n\\t\\n        // i think the question reduces to finding the longest substring having at at most one character that occurs odd number of times\\n        \\n        int mask=0;\\n        unordered_map<int,int> m;\\n        \\n        m[0]=-1; // prefix xor and its index\\n        int ans=INT_MIN;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            mask^= (1<<(s[i]-\\'0\\'));\\n            \\n            if(m.count(mask^0))\\n                ans= max(ans,i-m[mask^0]);\\n            \\n            for(int k=0;k<32;k++)\\n            {\\n                int copy= mask;\\n                \\n                copy^=(1<<k);\\n                \\n                if(m.count(copy))\\n                    ans= max(ans,i-m[copy]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3704191,
                "title": "100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        n = len(s)\\n        dp = [n + 1] * (1 << 10)\\n        dp[0] = -1\\n        res, mask = 0, 0\\n        for i in range(n):\\n            mask ^= 1 << int(s[i])\\n            res = max(res, i - dp[mask])\\n            for j in range(10):\\n                res = max(res, i - dp[mask ^ (1 << j)])\\n            dp[mask] = min(dp[mask], i)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        n = len(s)\\n        dp = [n + 1] * (1 << 10)\\n        dp[0] = -1\\n        res, mask = 0, 0\\n        for i in range(n):\\n            mask ^= 1 << int(s[i])\\n            res = max(res, i - dp[mask])\\n            for j in range(10):\\n                res = max(res, i - dp[mask ^ (1 << j)])\\n            dp[mask] = min(dp[mask], i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700531,
                "title": "c-bitmask-and-prefix-sum-and-hashmaps",
                "content": "\\n# Code\\n```\\nclass Solution {\\n//find string having even parity for each character + \\n//string having at most one odd parity\\n\\n//find longest length of such string so we store smallest index for mask in dp[mask];\\n\\npublic:\\n    int longestAwesome(string s) {\\n        int res = 0, mask = 0;\\n        int n = s.length();\\n        //dp[i] = min index for the prefix having parity corrosponding to i(mask);\\n        vector<int> dp(1024, 200000);\\n        dp[0] = -1;\\n        for(int i=0;i<n; i++){\\n            mask = mask ^ (1<<(s[i]-\\'0\\'));\\n            //check for the mask containig even no. of items;\\n            res = max(res, i-dp[mask]);\\n            //cehck for the mask containing all  even no. of items except one;\\n            for(int j=0; j<=9; j++){\\n                int newmask = mask^(1<<j);\\n                res = max(res, i-dp[newmask]);\\n            }\\n            dp[mask] = min(dp[mask], i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n//find string having even parity for each character + \\n//string having at most one odd parity\\n\\n//find longest length of such string so we store smallest index for mask in dp[mask];\\n\\npublic:\\n    int longestAwesome(string s) {\\n        int res = 0, mask = 0;\\n        int n = s.length();\\n        //dp[i] = min index for the prefix having parity corrosponding to i(mask);\\n        vector<int> dp(1024, 200000);\\n        dp[0] = -1;\\n        for(int i=0;i<n; i++){\\n            mask = mask ^ (1<<(s[i]-\\'0\\'));\\n            //check for the mask containig even no. of items;\\n            res = max(res, i-dp[mask]);\\n            //cehck for the mask containing all  even no. of items except one;\\n            for(int j=0; j<=9; j++){\\n                int newmask = mask^(1<<j);\\n                res = max(res, i-dp[newmask]);\\n            }\\n            dp[mask] = min(dp[mask], i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375935,
                "title": "swift-bit-mask-and-dictionary",
                "content": "# Intuition\\nwe use a mask to track the number of each digit we have seen. For example, if we have seen an even number of digit 7, we would set 0 in the 7th bit position in the mask, otherwise we set it to 1.\\nWe also use a dictionary to track the first position we have seen this mask.\\nThen we use bit manipulation to test if there exist a subarray that has only one single digit, or no single digit.\\n\\n# Code\\n```\\nclass Solution {\\n    func longestAwesome(_ s: String) -> Int {\\n        let s = Array(s)\\n        var visited = [Int: Int]()\\n        visited[0] = -1\\n        var mask = 0\\n        var res = 0\\n        for i in 0..<s.count {\\n            let c = s[i]\\n            let bit = c.asciiValue! - Character(\"0\").asciiValue!\\n            mask ^= 1 << bit\\n            for (old_mask, index) in visited {\\n                var diff = mask ^ old_mask\\n                if diff == 0 || ((diff & (diff - 1)) == 0) {\\n                    res = max(i - index, res)\\n                }\\n            }\\n            if visited[mask] == nil {\\n                visited[mask] = i\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestAwesome(_ s: String) -> Int {\\n        let s = Array(s)\\n        var visited = [Int: Int]()\\n        visited[0] = -1\\n        var mask = 0\\n        var res = 0\\n        for i in 0..<s.count {\\n            let c = s[i]\\n            let bit = c.asciiValue! - Character(\"0\").asciiValue!\\n            mask ^= 1 << bit\\n            for (old_mask, index) in visited {\\n                var diff = mask ^ old_mask\\n                if diff == 0 || ((diff & (diff - 1)) == 0) {\\n                    res = max(i - index, res)\\n                }\\n            }\\n            if visited[mask] == nil {\\n                visited[mask] = i\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319065,
                "title": "c-solution-explained-why-need-for-bitmanipulation-or-hashmap-easy-peasy",
                "content": "# Intuition\\nis we have observed a state of mask before it has occured now,then an even length palindrome has occured since all the characters which occured have count as even, or if some other mask has occured before which has 1 bit different than the current mask,this means a odd length palindrome has occured,as they have only one character having odd count and all others even count.Also if the mask has become zero or only one bit is sent in the mask means that from the indx=0 to the current index either even length or odd length palindrome has occured respectively.\\n\\nWe need to make a check on the above three conditions also if a mask has not occured yet we will store its value int he hashtable with value as current index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        //using a count of digits occuring is bad in this case ,because it will not tell us that which occuring digits don\\'t match.\\n        //masking will help us to store a state that has occured previously.\\n        //thus using masking we can solve the question easily.\\n\\n        int mask=0;\\n        int ans = 1;\\n        unordered_map<int,int> mp;\\n        mp[0] = -1;\\n        for(int i=0;i<s.size();i++){\\n            int digit = s[i]-\\'0\\';\\n            int p = 1<<digit;\\n            mask^=p;\\n            if(!mp.count(mask)){\\n                mp[mask] = i;\\n            }else{\\n                ans = max(ans,i-mp[mask]);\\n            }\\n\\n            if(mask&(mask-1)==0){\\n                ans = max(ans,i+1);\\n            }\\n\\n            for(int j=0;j<10;j++){\\n                int nmask = mask^(1<<j);\\n                if(mp.count(nmask)){\\n                    ans = max(ans,i-mp[nmask]);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        //using a count of digits occuring is bad in this case ,because it will not tell us that which occuring digits don\\'t match.\\n        //masking will help us to store a state that has occured previously.\\n        //thus using masking we can solve the question easily.\\n\\n        int mask=0;\\n        int ans = 1;\\n        unordered_map<int,int> mp;\\n        mp[0] = -1;\\n        for(int i=0;i<s.size();i++){\\n            int digit = s[i]-\\'0\\';\\n            int p = 1<<digit;\\n            mask^=p;\\n            if(!mp.count(mask)){\\n                mp[mask] = i;\\n            }else{\\n                ans = max(ans,i-mp[mask]);\\n            }\\n\\n            if(mask&(mask-1)==0){\\n                ans = max(ans,i+1);\\n            }\\n\\n            for(int j=0;j<10;j++){\\n                int nmask = mask^(1<<j);\\n                if(mp.count(nmask)){\\n                    ans = max(ans,i-mp[nmask]);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217020,
                "title": "bitmask-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<int,int>mp;  //mask->index\\n        int mask=0,ans=0;\\n        //string of is if length 0\\n        mp[0]=-1;\\n        for(int i=0;i<s.size();i++){\\n            mask^=(1<<(s[i]-\\'0\\'));\\n           \\n           //if mask already exist\\n           if(mp.count(mask)){\\n               //if mask is present then calculate the maximum\\n               ans=max(ans,i-mp[mask]);\\n           }else{\\n               mp[mask]=i;   //if msk does not exist then store its index\\n           }\\n\\n           //for odd length the mask can differ by at most one bit\\n           for(int j=0;j<10;j++){\\n               if(mp.count(mask^(1<<j))){\\n                   ans=max(ans,i-mp[mask^(1<<j)]);\\n               }\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<int,int>mp;  //mask->index\\n        int mask=0,ans=0;\\n        //string of is if length 0\\n        mp[0]=-1;\\n        for(int i=0;i<s.size();i++){\\n            mask^=(1<<(s[i]-\\'0\\'));\\n           \\n           //if mask already exist\\n           if(mp.count(mask)){\\n               //if mask is present then calculate the maximum\\n               ans=max(ans,i-mp[mask]);\\n           }else{\\n               mp[mask]=i;   //if msk does not exist then store its index\\n           }\\n\\n           //for odd length the mask can differ by at most one bit\\n           for(int j=0;j<10;j++){\\n               if(mp.count(mask^(1<<j))){\\n                   ans=max(ans,i-mp[mask^(1<<j)]);\\n               }\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171125,
                "title": "hashmap-prefix-bitmask-clean-code-with-explanation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        // hashmap to store the index of the first\\n        // occurrence of a bitmask\\n        unordered_map<int,int> ind;\\n\\n        // the empty substring has no digits\\n        // hence its bitmask will be 0\\n        ind[0] = -1;\\n\\n        // A bitmask for keeping track of the occurrences of the digits.\\n        // In order for a substring to be awesome, the digits have to occur even number of times and atmost 1\\n        // digit can occur odd number of times. Whenever we see a digit in the substring, we toggle the bit\\n        // corresponding to that digit in the bitmask, hence after we go through the entire substring\\n        // If the ith bit is 1, then it means that the digit i occurs odd number of times (1, 3, 5, ....)\\n        // If the ith bit is 0, then it means that the digit i occurs even number of times (0, 2, 4, ....).\\n        // Therefore, for a substring to be awesome, the count of set bits in the bitmask has to be 0 or 1.\\n        int mask = 0;\\n\\n        // the length of the longest awesome substring\\n        int maxlen = 0;\\n\\n        // go through all the digits in the string\\n        for(int i=0; i<s.size(); i++) {\\n            // toggle the bit corresponding to the digit\\n            mask ^= (1<<(s[i]-\\'0\\'));\\n\\n            // if we have seen this bitmask before, then it means that there\\n            // is a substring with all even occurrences of digits.\\n            if(ind.count(mask)) {\\n                // find the length of the substring\\n                maxlen = max(maxlen, i - ind[mask]);\\n            }\\n            // if we haven\\'t seen this bitmask before\\n            else {\\n                // note the index of the first occurrence of the bitmask\\n                ind[mask] = i;\\n            }\\n\\n            // check for bitmasks that differ from the current bitmask by 1 bit.\\n            for(int j=0; j<10; j++) {\\n                if(ind.count(mask ^ (1<<j))) {\\n                    // awesome substring with 1 odd occurrence of a digit\\n                    maxlen = max(maxlen, i - ind[mask ^ (1<<j)]);\\n                }\\n            }\\n        }\\n\\n        return maxlen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        // hashmap to store the index of the first\\n        // occurrence of a bitmask\\n        unordered_map<int,int> ind;\\n\\n        // the empty substring has no digits\\n        // hence its bitmask will be 0\\n        ind[0] = -1;\\n\\n        // A bitmask for keeping track of the occurrences of the digits.\\n        // In order for a substring to be awesome, the digits have to occur even number of times and atmost 1\\n        // digit can occur odd number of times. Whenever we see a digit in the substring, we toggle the bit\\n        // corresponding to that digit in the bitmask, hence after we go through the entire substring\\n        // If the ith bit is 1, then it means that the digit i occurs odd number of times (1, 3, 5, ....)\\n        // If the ith bit is 0, then it means that the digit i occurs even number of times (0, 2, 4, ....).\\n        // Therefore, for a substring to be awesome, the count of set bits in the bitmask has to be 0 or 1.\\n        int mask = 0;\\n\\n        // the length of the longest awesome substring\\n        int maxlen = 0;\\n\\n        // go through all the digits in the string\\n        for(int i=0; i<s.size(); i++) {\\n            // toggle the bit corresponding to the digit\\n            mask ^= (1<<(s[i]-\\'0\\'));\\n\\n            // if we have seen this bitmask before, then it means that there\\n            // is a substring with all even occurrences of digits.\\n            if(ind.count(mask)) {\\n                // find the length of the substring\\n                maxlen = max(maxlen, i - ind[mask]);\\n            }\\n            // if we haven\\'t seen this bitmask before\\n            else {\\n                // note the index of the first occurrence of the bitmask\\n                ind[mask] = i;\\n            }\\n\\n            // check for bitmasks that differ from the current bitmask by 1 bit.\\n            for(int j=0; j<10; j++) {\\n                if(ind.count(mask ^ (1<<j))) {\\n                    // awesome substring with 1 odd occurrence of a digit\\n                    maxlen = max(maxlen, i - ind[mask ^ (1<<j)]);\\n                }\\n            }\\n        }\\n\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167295,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn longest_awesome(s: String) -> i32 {\\n        use std::collections::HashMap;\\n        let mut map: HashMap<i32, i32> = HashMap::new();\\n        let mut mask = 0;\\n        let mut ans = 0;\\n        map.insert(0, -1);\\n        for (i, c) in s.bytes().enumerate() {\\n            mask ^= 1 << (c - b\\'0\\');\\n            if let Some(&j) = map.get(&mask) {\\n                ans = ans.max(i as i32 - j);\\n            }\\n            for k in 0..10 {\\n                let mask2 = mask ^ (1 << k);\\n                if let Some(&j) = map.get(&mask2) {\\n                    ans = ans.max(i as i32 - j);\\n                }\\n            }\\n            map.entry(mask).or_insert(i as i32);\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_awesome(s: String) -> i32 {\\n        use std::collections::HashMap;\\n        let mut map: HashMap<i32, i32> = HashMap::new();\\n        let mut mask = 0;\\n        let mut ans = 0;\\n        map.insert(0, -1);\\n        for (i, c) in s.bytes().enumerate() {\\n            mask ^= 1 << (c - b\\'0\\');\\n            if let Some(&j) = map.get(&mask) {\\n                ans = ans.max(i as i32 - j);\\n            }\\n            for k in 0..10 {\\n                let mask2 = mask ^ (1 << k);\\n                if let Some(&j) = map.get(&mask2) {\\n                    ans = ans.max(i as i32 - j);\\n                }\\n            }\\n            map.entry(mask).or_insert(i as i32);\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3143256,
                "title": "simple-java-presum-bitmask-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(2^9)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        int n = s.length();\\n        int[] preSum = new int[1 << 9 + 1];\\n        Arrays.fill(preSum, n);\\n        preSum[0] = -1;\\n        int res = 0;\\n        int mask = 0;\\n        for (int i = 0; i < n; i++) {\\n            char c = s.charAt(i);\\n            mask ^= 1 << (c - \\'0\\');\\n            res = Math.max(res, i - preSum[mask]);\\n            for (int j = 0; j < 10; j++) {\\n                res = Math.max(res, i - preSum[mask ^ (1 << j)]);\\n            }\\n            if (preSum[mask] == n) preSum[mask] = i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        int n = s.length();\\n        int[] preSum = new int[1 << 9 + 1];\\n        Arrays.fill(preSum, n);\\n        preSum[0] = -1;\\n        int res = 0;\\n        int mask = 0;\\n        for (int i = 0; i < n; i++) {\\n            char c = s.charAt(i);\\n            mask ^= 1 << (c - \\'0\\');\\n            res = Math.max(res, i - preSum[mask]);\\n            for (int j = 0; j < 10; j++) {\\n                res = Math.max(res, i - preSum[mask ^ (1 << j)]);\\n            }\\n            if (preSum[mask] == n) preSum[mask] = i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115576,
                "title": "python-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem, we are looking for the longest substring that is an awesome string. An awesome string is a string that has an even number of each digit from 0-9. To solve this problem, we can use dynamic programming to keep track of the longest substring that is an awesome string at each index of the input string.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use dynamic programming to solve this problem. We can create an array, `dp`, of length 10 to keep track of the longest substring that is an awesome string at each index of the string. We can also keep track of the current mask of the substring, which is a bitmask that stores the count of each digit in the current substring. To calculate the longest awesome substring at each index, we can iterate through the string and update the mask and the `dp` array accordingly. At each index, we can check if the current substring is an awesome string. If it is, we can update the `dp` array and the longest substring length. \\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        n = len(s)\\n        dp = [n + 1] * (1 << 10)\\n        dp[0] = -1\\n        res, mask = 0, 0\\n        for i in range(n):\\n            mask ^= 1 << int(s[i])\\n            res = max(res, i - dp[mask])\\n            for j in range(10):\\n                res = max(res, i - dp[mask ^ (1 << j)])\\n            dp[mask] = min(dp[mask], i)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        n = len(s)\\n        dp = [n + 1] * (1 << 10)\\n        dp[0] = -1\\n        res, mask = 0, 0\\n        for i in range(n):\\n            mask ^= 1 << int(s[i])\\n            res = max(res, i - dp[mask])\\n            for j in range(10):\\n                res = max(res, i - dp[mask ^ (1 << j)])\\n            dp[mask] = min(dp[mask], i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115571,
                "title": "c-solution-masking-technique-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFrom the problem statement, it is clear that we have to find the longest substring in the given string which has even number of occurrences for each digit from 0 to 9. To accomplish this, we can use a bit masking technique to track the occurrence of each digit in the current substring. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can use a bit masking technique to track the occurrence of each digit in the current substring. We use a bit mask of length 10 with each bit representing the occurrence of a digit in the current substring. Initially, all the bits in the mask are set to 0. We traverse through the string and everytime we encounter a digit we toggle the corresponding bit in the mask. We also maintain an array pos of length 1024 which stores the index of the last occurence of each mask. We also maintain a variable mask which stores the current bit mask. \\n\\nWe use the variable res to store the length of the longest awesome substring. For every index, we update the res variable by taking the maximum of the current index minus the last index corresponding to the current mask and current index minus the last index corresponding to the current mask with all its bits toggled. \\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int res = 0, n = s.size();\\n        vector<int> pos(1 << 10, n); // pos array of length 1024 to store the last index of each mask\\n        pos[0] = -1; // initially setting the last index corresponding to 0 mask to -1\\n        int mask = 0;\\n        for (int i = 0; i < n; ++i) {\\n            mask ^= 1 << (s[i] - \\'0\\'); // toggling the bit corresponding to the current digit\\n            res = max(res, i - pos[mask]); // updating the res variable with the current index minus the last index corresponding to the current mask\\n            for (int j = 0; j < 10; ++j) \\n                res = max(res, i - pos[mask ^ (1 << j)]); // updating the res variable with the current index minus the last index corresponding to the current mask with all its bits toggled\\n            pos[mask] = min(pos[mask], i); // updating the last index corresponding to the current mask\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int res = 0, n = s.size();\\n        vector<int> pos(1 << 10, n); // pos array of length 1024 to store the last index of each mask\\n        pos[0] = -1; // initially setting the last index corresponding to 0 mask to -1\\n        int mask = 0;\\n        for (int i = 0; i < n; ++i) {\\n            mask ^= 1 << (s[i] - \\'0\\'); // toggling the bit corresponding to the current digit\\n            res = max(res, i - pos[mask]); // updating the res variable with the current index minus the last index corresponding to the current mask\\n            for (int j = 0; j < 10; ++j) \\n                res = max(res, i - pos[mask ^ (1 << j)]); // updating the res variable with the current index minus the last index corresponding to the current mask with all its bits toggled\\n            pos[mask] = min(pos[mask], i); // updating the last index corresponding to the current mask\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929056,
                "title": "c-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size(), res = 0, seen[1024]{[0]=-1,[1 ... 1023]=n};\\n        for(int i = 0, cur = 0; i < n; i++) {\\n            cur ^= (1 << (s[i]-\\'0\\'));\\n            for(int j = 0; j < 10; j++) res = max(res, i-seen[cur^(1 << j)]);\\n            res = max(res, i-seen[cur]);\\n            seen[cur] = min(i, seen[cur]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size(), res = 0, seen[1024]{[0]=-1,[1 ... 1023]=n};\\n        for(int i = 0, cur = 0; i < n; i++) {\\n            cur ^= (1 << (s[i]-\\'0\\'));\\n            for(int j = 0; j < 10; j++) res = max(res, i-seen[cur^(1 << j)]);\\n            res = max(res, i-seen[cur]);\\n            seen[cur] = min(i, seen[cur]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913431,
                "title": "prabal-kumar-pandey",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(10 * n)\\n\\n- Space complexity:\\nO(1024)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        static const int ALPHABET_SIZE = 10;\\n        int result = 0, mask = 0;\\n        vector<int> lookup(1 << ALPHABET_SIZE, s.length());\\n        lookup[0] = -1;\\n        for (int i = 0; i < s.length(); ++i) {\\n            mask ^= 1 << (s[i] - \\'0\\');\\n            if (lookup[mask] == s.length()) {\\n                lookup[mask] = i;\\n            }\\n            result = max(result, i - lookup[mask]);  // no middle\\n            for (int d = 0; d < ALPHABET_SIZE; ++d) {\\n                result = max(result, i - lookup[mask  ^ (1 << d)]); // as middle\\n            }\\n            lookup[mask] = min(lookup[mask], i);\\n        }      \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        static const int ALPHABET_SIZE = 10;\\n        int result = 0, mask = 0;\\n        vector<int> lookup(1 << ALPHABET_SIZE, s.length());\\n        lookup[0] = -1;\\n        for (int i = 0; i < s.length(); ++i) {\\n            mask ^= 1 << (s[i] - \\'0\\');\\n            if (lookup[mask] == s.length()) {\\n                lookup[mask] = i;\\n            }\\n            result = max(result, i - lookup[mask]);  // no middle\\n            for (int d = 0; d < ALPHABET_SIZE; ++d) {\\n                result = max(result, i - lookup[mask  ^ (1 << d)]); // as middle\\n            }\\n            lookup[mask] = min(lookup[mask], i);\\n        }      \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776195,
                "title": "use-bitmask-of-10-letters-as-states",
                "content": "# Approach\\nSince there\\'s only 10 possible letters/numbers, we can remember the state for each position, where the state can be defined as if the frequency of one number is even or odd.\\n\\nAt any position, we can check if there\\'s a previous position, who share the same state (same even/oddness for each number), if there is, we can use that position to form a palindrome, since excluding it will give us even number of each kind of letters.\\n```\\n[...a...] b\\n\\ndiff(a,b) = {x: 0, y: 1}\\n            {x: 0}\\n\\n 0 1 2 3 4 5 6\\n e o e o e o e  -- original state\\n e o e o e o e  -- if the same state existed before, we can for a palindrome with no center (even palindrome)\\n o o e o e o e  -- toggle one letter, try forming an odd palindrome with a center letter\\n ^\\n e e e o e o e  -- toggle one letter, try forming an odd palindrome with a center letter\\n   ^\\n```\\n\\n# Complexity\\nSince we only have 10 letters (0-9), b = 10.\\n\\n- Time complexity: O(b*n)\\n\\n- Space complexity: O(2^(b+1))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        vector<int> D(1<<11,-2), F(10, 0);\\n        D[0] = -1;\\n        int res = 1;\\n        auto make_mask = [&]() {\\n            int mask = 0;\\n            for (int j = 0, b = 1; j <= 9; ++j, b<<=1) {\\n                if (F[j]&1) mask += b;\\n            }\\n            return mask;\\n        };\\n\\n        for (int i = 0; i < s.size(); ++i) {\\n            ++F[s[i]-\\'0\\'];\\n            int mask = make_mask();\\n            for (int b = 1, j = 0; j <= 9; ++j, b <<= 1) {\\n                if (F[j] <= 0) continue;\\n                mask ^= b;\\n                if (D[mask] >= -1) res = max(res, i-D[mask]);\\n                mask ^= b;\\n            }\\n            if (D[mask] >= -1) res = max(res, i-D[mask]);\\n            else D[mask] = i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n[...a...] b\\n\\ndiff(a,b) = {x: 0, y: 1}\\n            {x: 0}\\n\\n 0 1 2 3 4 5 6\\n e o e o e o e  -- original state\\n e o e o e o e  -- if the same state existed before, we can for a palindrome with no center (even palindrome)\\n o o e o e o e  -- toggle one letter, try forming an odd palindrome with a center letter\\n ^\\n e e e o e o e  -- toggle one letter, try forming an odd palindrome with a center letter\\n   ^\\n```\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        vector<int> D(1<<11,-2), F(10, 0);\\n        D[0] = -1;\\n        int res = 1;\\n        auto make_mask = [&]() {\\n            int mask = 0;\\n            for (int j = 0, b = 1; j <= 9; ++j, b<<=1) {\\n                if (F[j]&1) mask += b;\\n            }\\n            return mask;\\n        };\\n\\n        for (int i = 0; i < s.size(); ++i) {\\n            ++F[s[i]-\\'0\\'];\\n            int mask = make_mask();\\n            for (int b = 1, j = 0; j <= 9; ++j, b <<= 1) {\\n                if (F[j] <= 0) continue;\\n                mask ^= b;\\n                if (D[mask] >= -1) res = max(res, i-D[mask]);\\n                mask ^= b;\\n            }\\n            if (D[mask] >= -1) res = max(res, i-D[mask]);\\n            else D[mask] = i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755418,
                "title": "simple-clean-bitmask-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n    unordered_map<int,int>mp;\\n    int result=0;\\n    for (int i=0;i<10;i++)\\n    {\\n        mp[i]=(1<<i);\\n    }\\n        \\n// set bit denotes current element has occured odd number of times\\n// when we are at i , we calculate length of longest substring ending at index i which can be made as a palindrome\\n        \\n    unordered_map<int,int> maskedindex;\\n    int mask=0;\\n    maskedindex[0]=-1;\\n    for (int i=0;i<s.size();i++)\\n    {\\n        mask=mask^(mp[s[i]-\\'0\\']);\\n        for (int j=0;j<10;j++)\\n        {\\n            \\n            mask=mask^(mp[j]);\\n           if (maskedindex.find(mask)!=maskedindex.end())\\n           {\\n            result=max(result,i-maskedindex[mask]);\\n           }\\n         mask=mask^(mp[j]);   \\n        }\\n        \\n        if (maskedindex.find(mask)==maskedindex.end())\\n            maskedindex[mask]=i;\\n        else\\n        {\\n            result=max(result,i-maskedindex[mask]);\\n        }\\n  \\n        \\n    }\\n        \\n        return result;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n    unordered_map<int,int>mp;\\n    int result=0;\\n    for (int i=0;i<10;i++)\\n    {\\n        mp[i]=(1<<i);\\n    }\\n        \\n// set bit denotes current element has occured odd number of times\\n// when we are at i , we calculate length of longest substring ending at index i which can be made as a palindrome\\n        \\n    unordered_map<int,int> maskedindex;\\n    int mask=0;\\n    maskedindex[0]=-1;\\n    for (int i=0;i<s.size();i++)\\n    {\\n        mask=mask^(mp[s[i]-\\'0\\']);\\n        for (int j=0;j<10;j++)\\n        {\\n            \\n            mask=mask^(mp[j]);\\n           if (maskedindex.find(mask)!=maskedindex.end())\\n           {\\n            result=max(result,i-maskedindex[mask]);\\n           }\\n         mask=mask^(mp[j]);   \\n        }\\n        \\n        if (maskedindex.find(mask)==maskedindex.end())\\n            maskedindex[mask]=i;\\n        else\\n        {\\n            result=max(result,i-maskedindex[mask]);\\n        }\\n  \\n        \\n    }\\n        \\n        return result;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737239,
                "title": "java-efficient-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    \\n    public int longestAwesome(String s) {\\n        \\n        // We only need to care about if a digit appears odd or even number of times.\\n        // Since the total number of digits is 10, the number of possible states is\\n        // (1<<10) == 1024\\n        int[] idxFirstAppearance = new int[1<<10]; // index where a state first appears\\n        Arrays.fill(idxFirstAppearance, Integer.MIN_VALUE);\\n        idxFirstAppearance[0] = -1;\\n        \\n        int mask = 0; // initial state\\n        int ans = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            \\n            int idx = s.charAt(i) - \\'0\\';\\n            \\n            // Case 1: all digits appear even number of times\\n            mask ^= (1 << idx); // update state\\n            \\n            if (idxFirstAppearance[mask] == Integer.MIN_VALUE)\\n                idxFirstAppearance[mask] = i;\\n            else\\n                ans = Math.max(ans, i-idxFirstAppearance[mask]);\\n            \\n            // Case 2: all digits but one appear even number of times\\n            for (int j=0; j<10; j++) {\\n                \\n                int temp = mask ^ (1 << j);\\n                \\n                ans = Math.max(ans, i-idxFirstAppearance[temp]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int longestAwesome(String s) {\\n        \\n        // We only need to care about if a digit appears odd or even number of times.\\n        // Since the total number of digits is 10, the number of possible states is\\n        // (1<<10) == 1024\\n        int[] idxFirstAppearance = new int[1<<10]; // index where a state first appears\\n        Arrays.fill(idxFirstAppearance, Integer.MIN_VALUE);\\n        idxFirstAppearance[0] = -1;\\n        \\n        int mask = 0; // initial state\\n        int ans = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            \\n            int idx = s.charAt(i) - \\'0\\';\\n            \\n            // Case 1: all digits appear even number of times\\n            mask ^= (1 << idx); // update state\\n            \\n            if (idxFirstAppearance[mask] == Integer.MIN_VALUE)\\n                idxFirstAppearance[mask] = i;\\n            else\\n                ans = Math.max(ans, i-idxFirstAppearance[mask]);\\n            \\n            // Case 2: all digits but one appear even number of times\\n            for (int j=0; j<10; j++) {\\n                \\n                int temp = mask ^ (1 << j);\\n                \\n                ans = Math.max(ans, i-idxFirstAppearance[temp]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650665,
                "title": "where-i-went-wrong-using-a-dictionary-and-python3-when-i-found-93139-from-9498331",
                "content": "I thought I had a clever solution to this as I don\\'t really know how to use bitmasks, so I basically used a dictionary instead to store the occurences of each character, and then since there can be unlimited swaps, I created a new string based on each value that is greater than 2 in my dictionary. \\n\\nFor the awesome string, I built it using the half + single + half reflected and then counted the length. \\n\\nWhy should this testcase be 3 as the longest instead of 5? \\n\\nWrong Answer\\nDetails\\nInput\\n\"9498331\"\\nstdout\\n93439\\n\\nOutput\\n5\\nExpected\\n3\\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        number_of_ch = {}\\n        \\n        #Read the string character by character into a dict\\n        #Key is the ch, value is the # of char found in the string. \\n        for ch in s:\\n            if number_of_ch.get(ch) is not None:\\n                number_of_ch.update({ch:number_of_ch[ch] + 1})\\n            else: \\n                number_of_ch[ch] = 1\\n                    \\n        #Create palindrome from the values in the dict. \\n        #When the value in the dict is >= 2 then we can add that value to beginning and end of the awesome string, and then reduce the value of the char by 2.\\n        single_used = False\\n        single_ch = \\'\\'\\n        awesome_half = \\'\\'\\n\\n        for ch in number_of_ch.keys():\\n            if number_of_ch.get(ch) >= 2:\\n                multi = (int(number_of_ch.get(ch) / 2))\\n                awesome_half = awesome_half + multi * str(ch)\\n                number_of_ch.update({ch:number_of_ch[ch] % 2})\\n            elif single_used == False and number_of_ch.get(ch) == 1:\\n                single_ch = ch\\n                number_of_ch.update({ch:number_of_ch[ch] - 1})\\n                single_used = True\\n        awesome = awesome_half + single_ch + awesome_half[::-1]\\n        \\n        print(awesome)\\n        return len(awesome)\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        number_of_ch = {}\\n        \\n        #Read the string character by character into a dict\\n        #Key is the ch, value is the # of char found in the string. \\n        for ch in s:\\n            if number_of_ch.get(ch) is not None:\\n                number_of_ch.update({ch:number_of_ch[ch] + 1})\\n            else: \\n                number_of_ch[ch] = 1\\n                    \\n        #Create palindrome from the values in the dict. \\n        #When the value in the dict is >= 2 then we can add that value to beginning and end of the awesome string, and then reduce the value of the char by 2.\\n        single_used = False\\n        single_ch = \\'\\'\\n        awesome_half = \\'\\'\\n\\n        for ch in number_of_ch.keys():\\n            if number_of_ch.get(ch) >= 2:\\n                multi = (int(number_of_ch.get(ch) / 2))\\n                awesome_half = awesome_half + multi * str(ch)\\n                number_of_ch.update({ch:number_of_ch[ch] % 2})\\n            elif single_used == False and number_of_ch.get(ch) == 1:\\n                single_ch = ch\\n                number_of_ch.update({ch:number_of_ch[ch] - 1})\\n                single_used = True\\n        awesome = awesome_half + single_ch + awesome_half[::-1]\\n        \\n        print(awesome)\\n        return len(awesome)\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2627565,
                "title": "easy-short-clean-efficient-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    int longestAwesome(const string&s) {\\n        ll n=s.size(), bm=0, ans=1;\\n        vi(ll)ump(1024, n);\\n        ump[0]=-1;\\n        for(ll i=0;i<n;++i){\\n            bm^=1<<(s[i]-\\'0\\');\\n            ans=max(ans, i-ump[bm]);\\n            for(ll j=0;j<10;++j){\\n                ans=max(ans, i-ump[bm^(1<<j)]);\\n            }\\n            ump[bm]=min(ump[bm], i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    int longestAwesome(const string&s) {\\n        ll n=s.size(), bm=0, ans=1;\\n        vi(ll)ump(1024, n);\\n        ump[0]=-1;\\n        for(ll i=0;i<n;++i){\\n            bm^=1<<(s[i]-\\'0\\');\\n            ans=max(ans, i-ump[bm]);\\n            for(ll j=0;j<10;++j){\\n                ans=max(ans, i-ump[bm^(1<<j)]);\\n            }\\n            ump[bm]=min(ump[bm], i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569852,
                "title": "c-bitmask-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<int, int>where;\\n        int cur=0;\\n        where[cur] = -1;\\n        int n=s.size();\\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            int dig = s[i]-\\'0\\';\\n            cur^=(1<<dig); //flip \\'dig\\' bit\\n            \\n            if(where.find(cur)!=where.end())\\n                ans = max(ans, i-where[cur]); //all even characters\\n            \\n            for(int bit = 0; bit<10; bit++){\\n                int better = cur^(1<<bit); //allowing the \\'bit\\' bit to be odd in the substring\\n                if(where.find(better)!=where.end())\\n                    ans = max(ans, i-where[better]); //one odd, others even\\n            }\\n            \\n            if(where.find(cur)==where.end())\\n                where[cur]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<int, int>where;\\n        int cur=0;\\n        where[cur] = -1;\\n        int n=s.size();\\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            int dig = s[i]-\\'0\\';\\n            cur^=(1<<dig); //flip \\'dig\\' bit\\n            \\n            if(where.find(cur)!=where.end())\\n                ans = max(ans, i-where[cur]); //all even characters\\n            \\n            for(int bit = 0; bit<10; bit++){\\n                int better = cur^(1<<bit); //allowing the \\'bit\\' bit to be odd in the substring\\n                if(where.find(better)!=where.end())\\n                    ans = max(ans, i-where[better]); //one odd, others even\\n            }\\n            \\n            if(where.find(cur)==where.end())\\n                where[cur]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483621,
                "title": "without-bitmasking-c",
                "content": "cnt(j) --> number of occurences of j, till ith index.\\ncur_state --> string to represent the current state.\\n\\ncur_state(j) ->0 ==> j appears an even number of times till ith index.\\ncur_state(j) ->1 ==> j appears an odd number of times till ith index.\\n\\nLet cur_state for any arbitary index i = \"0100000000\"\\nThis means that 1 has appeared an odd number of times, till ith index and all other digits appeared \\n0 number of times.\\n\\nSince we want to find longest substring, for which the substring could be rearranged to a palindrome .\\nThis is possible in 2 cases\\ncase 1: if all the distinct characters in the substring appears an even number of time\\ncase 2: if all the distinct characters in the substring appears an even number of time, except for one character.\\n\\nany state that we encouter is stored in a hash map against the index where that state occured, if the same state  or a state such that only one index is altered occurs later in the traversal ==> the substring between them including the cur index and not including the prev index is a valid answer.\\nJust find the maximum length among all such valid answers.\\n\\n``\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        \\n        unordered_map<string, int>mp; // (state, earliest index where this state was seen).\\n        int n = s.size();\\n        \\n        mp[\"0000000000\"] = -1; \\n        \\n        int ans = 0;\\n        \\n        int cnt[10] = {};\\n        \\n        for(int i = 0; i<n; i++){\\n            \\n            cnt[s[i]-\\'0\\']++; // incrementing the count of cur_character.\\n            \\n            string cur_state = \"\"; // stores the cur_state.\\n            \\n            for(int j = 0; j<10; j++){\\n                \\n                if(cnt[j] % 2 ==0){\\n                    \\n                    cur_state+=\\'0\\';\\n                }\\n                else{\\n                    cur_state+=\\'1\\';\\n                }\\n            }\\n            \\n            // Case 1 : if same to same state was there earlier ==> all chars even substring ==> yes a palindrome.\\n            \\n            if(mp.find(cur_state) != mp.end()){\\n                ans = max(ans, i - mp[cur_state]);\\n                \\n                \\n            }\\n            \\n            else{\\n                mp[cur_state]  = i;\\n            }\\n            \\n          \\n           \\n            \\n            // Case 2 : if only one change..\\n            \\n            for(int j = 0; j<10; j++){\\n                \\n                \\n                // changing the state for the time being..\\n                \\n                if(cur_state[j]==\\'0\\'){\\n                    cur_state[j] = \\'1\\';\\n                }\\n                else{\\n                    cur_state[j] = \\'0\\';\\n                }\\n                \\n                if(mp.find(cur_state) != mp.end()){\\n                    ans = max(ans, i - mp[cur_state]);\\n                }\\n                \\n                // changing it back to original state.\\n                \\n                 if(cur_state[j]==\\'0\\'){\\n                    cur_state[j] = \\'1\\';\\n                }\\n                \\n                else{\\n                    cur_state[j] = \\'0\\';\\n                }\\n                \\n                \\n                 \\n            }\\n            \\n           \\n            \\n            \\n        }\\n        \\n     \\n        return ans;\\n    }\\n};\\n``",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        \\n        unordered_map<string, int>mp; // (state, earliest index where this state was seen).\\n        int n = s.size();\\n        \\n        mp[\"0000000000\"] = -1; \\n        \\n        int ans = 0;\\n        \\n        int cnt[10] = {}",
                "codeTag": "Java"
            },
            {
                "id": 2413991,
                "title": "intresting-problem-c",
                "content": "```\\n  int longestAwesome(string A ) {\\n        \\n        int N = A.size();\\n        string t(10,0);\\n        unordered_map< string , int > M ;\\n        M[t] = -1 ;\\n        int res = 0 ;\\n        \\n        for( int i = 0 ; i < N ; i++ )\\n        {\\n            int v = A[i]-\\'0\\';\\n            t[v] ^= 1 ;\\n            \\n            // even count \\n            if( M.find(t) != M.end() )\\n                res = max( res , i-M[t]);\\n            // one odd count \\n            for( int j = 0 ; j < 10 ; j++ )\\n            {\\n                t[j] ^= 1;\\n                \\n                if( M.find(t) != M.end() )\\n                    res = max( res , i-M[t] );\\n                \\n                t[j] ^= 1;\\n            }\\n            \\n            if( M.find(t) == M.end() )\\n                M[t] = i ;\\n        }\\n        return res ;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int longestAwesome(string A ) {\\n        \\n        int N = A.size();\\n        string t(10,0);\\n        unordered_map< string , int > M ;\\n        M[t] = -1 ;\\n        int res = 0 ;\\n        \\n        for( int i = 0 ; i < N ; i++ )\\n        {\\n            int v = A[i]-\\'0\\';\\n            t[v] ^= 1 ;\\n            \\n            // even count \\n            if( M.find(t) != M.end() )\\n                res = max( res , i-M[t]);\\n            // one odd count \\n            for( int j = 0 ; j < 10 ; j++ )\\n            {\\n                t[j] ^= 1;\\n                \\n                if( M.find(t) != M.end() )\\n                    res = max( res , i-M[t] );\\n                \\n                t[j] ^= 1;\\n            }\\n            \\n            if( M.find(t) == M.end() )\\n                M[t] = i ;\\n        }\\n        return res ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2408929,
                "title": "c-bit-manipulation-bitmasking-string",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint longestAwesome(string s) {\\n\\n\\t\\t\\tunordered_map<int , int> mp;\\n\\t\\t\\tmp[0] = -1;\\n\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint len = 0;\\n\\t\\t\\tint curr = 0;\\n\\t\\t\\tfor(int i = 0 ; i < n ; i++){\\n\\n\\t\\t\\t\\tint mask = 1 << (s[i] - \\'0\\');\\n\\t\\t\\t\\tcurr ^= mask;\\n\\n\\t\\t\\t\\t/// case : 1\\n\\t\\t\\t\\t/// To check for all even position\\n\\t\\t\\t\\tif(mp.count(curr)){\\n\\t\\t\\t\\t   len = max(len , i - mp[curr]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t/// case : 2\\n\\t\\t\\t\\t/// To make exactly one odd position\\n\\t\\t\\t\\tfor(int j = 0 ; j <= 9 ; j++){\\n\\t\\t\\t\\t\\tmask = 1 << j;\\n\\t\\t\\t\\t\\tif(mp.count(curr ^ mask)){\\n\\t\\t\\t\\t\\t   len = max(len , i - mp[curr ^ mask]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(mp.count(curr) == 0){\\n\\t\\t\\t\\t   mp[curr] = i;   \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn len;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "String",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint longestAwesome(string s) {\\n\\n\\t\\t\\tunordered_map<int , int> mp;\\n\\t\\t\\tmp[0] = -1;\\n\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint len = 0;\\n\\t\\t\\tint curr = 0;\\n\\t\\t\\tfor(int i = 0 ; i < n ; i++){\\n\\n\\t\\t\\t\\tint mask = 1 << (s[i] - \\'0\\');\\n\\t\\t\\t\\tcurr ^= mask;\\n\\n\\t\\t\\t\\t/// case : 1\\n\\t\\t\\t\\t/// To check for all even position\\n\\t\\t\\t\\tif(mp.count(curr)){\\n\\t\\t\\t\\t   len = max(len , i - mp[curr]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2298662,
                "title": "java-bit-mask",
                "content": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<Integer,Integer>map=new HashMap<>();\\n        map.put(0,-1);\\n        \\n        int state=0;\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            int bit=(1<<(s.charAt(i)-\\'0\\'));\\n            state ^=bit; //if odd freq then it becomes even or if even becomes odd\\n            \\n            if(map.containsKey(state))\\n               ans=Math.max(ans,i-map.get(state));\\n            \\n                for(int odd=0;odd<=9;odd++){ //become odds one by one\\n                    int mask=(1<<odd);\\n                    \\n                    Integer j=map.get(state^mask);\\n                    \\n                    if(j!=null)\\n                        ans=Math.max(ans,i-j);\\n                }\\n            \\n            if(!map.containsKey(state))\\n                map.put(state,i);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<Integer,Integer>map=new HashMap<>();\\n        map.put(0,-1);\\n        \\n        int state=0;\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            int bit=(1<<(s.charAt(i)-\\'0\\'));\\n            state ^=bit; //if odd freq then it becomes even or if even becomes odd\\n            \\n            if(map.containsKey(state))\\n               ans=Math.max(ans,i-map.get(state));\\n            \\n                for(int odd=0;odd<=9;odd++){ //become odds one by one\\n                    int mask=(1<<odd);\\n                    \\n                    Integer j=map.get(state^mask);\\n                    \\n                    if(j!=null)\\n                        ans=Math.max(ans,i-j);\\n                }\\n            \\n            if(!map.containsKey(state))\\n                map.put(state,i);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277674,
                "title": "bit-masking-kind-of-not-really-using-bit-manipulation-just-the-concept",
                "content": "class Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        \\n        mask = [\"0\"]*10\\n        \\n        myhash = {}\\n        myhash[\"\".join(mask)] = -1\\n        ans = 1\\n        \\n        s2 = []\\n        for ch in s:\\n            s2.append(ch)\\n            \\n            \\n        for i,ch in enumerate(s2):\\n            \\n            ind = int(ch)\\n            \\n            if mask[ind] == \\'0\\':\\n                #occurs odd number of times\\n                mask[ind] = \\'1\\'\\n            else:\\n                #even number of times this has occured\\n                mask[ind] = \\'0\\'\\n            \\n            if \"\".join(mask) in myhash.keys():\\n                ans = max(i - myhash[\"\".join(mask)],ans)\\n                \\n            \\n            for ik in range(10):\\n                if mask[ik] == \\'0\\':\\n                    mask[ik] = \\'1\\'\\n                    if \"\".join(mask) in myhash.keys():\\n                        ans = max(i - myhash[\"\".join(mask)],ans)\\n                    mask[ik] = \\'0\\'\\n                    \\n                elif mask[ik] == \\'1\\':\\n                    mask[ik] = \\'0\\'\\n                    if \"\".join(mask) in myhash.keys():\\n                        ans = max(i - myhash[\"\".join(mask)],ans)\\n                    mask[ik] = \\'1\\'       \\n\\n            if \"\".join(mask) not in myhash.keys():\\n                myhash[\"\".join(mask)] = i\\n        \\n        \\n        return ans",
                "solutionTags": [],
                "code": "class Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        \\n        mask = [\"0\"]*10\\n        \\n        myhash = {}",
                "codeTag": "Java"
            },
            {
                "id": 2249440,
                "title": "hashmap-python-solution",
                "content": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        cur = res = 0\\n        d = defaultdict(lambda:float(\\'inf\\'), {0:-1})\\n        for i, ch in enumerate(s):\\n            cur ^= 1 << int(ch)\\n            res = max(res, i-d[cur])\\n            for j in range(10):\\n                res = max(res, i-d[cur^(1<<j)])\\n            d[cur] = min(d[cur], i)\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        cur = res = 0\\n        d = defaultdict(lambda:float(\\'inf\\'), {0:-1})\\n        for i, ch in enumerate(s):\\n            cur ^= 1 << int(ch)\\n            res = max(res, i-d[cur])\\n            for j in range(10):\\n                res = max(res, i-d[cur^(1<<j)])\\n            d[cur] = min(d[cur], i)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197275,
                "title": "easy-solution-java-t-o-n-s-o-2-10-with-array-and-s-o-n-with-hashmap",
                "content": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        //Pre-requisite: just dry-run 1-2 times atleast to grab the deep insight behind the working of this code then u can easly understand this question\\n        \\n        //time Optimized approach uses large array instead of  hashmap\\n        Integer[]map = new Integer[(1 << 10)];//(1 << 10) -> 10000000000\\n        // HashMap<Integer,Integer>map = new HashMap<>();//map(state, index);\\n        map[0] = -1;\\n        \\n        int state = 0;\\n        int ans = 0;\\n        \\n        for(int i = 0; i<s.length(); i++) {\\n            char ch = s.charAt(i);\\n            \\n            int mask = (1 << (ch - \\'0\\'));\\n            state ^= mask;\\n            \\n            if(map[state] != null) {\\n                int j = map[state];\\n                ans = Math.max(ans, i - j);\\n            }\\n            \\n            for(int b = 0; b<10; b++) {\\n                mask = (1 << b);//state^mask -> togling of \\'bth\\' bit in the state variable\\n                \\n                if(map[state ^ mask] != null) {\\n                    int j = map[state ^ mask];\\n                    \\n                    ans = Math.max(ans, i - j);\\n                }\\n            }\\n            \\n            if(map[state] == null) {\\n                map[state] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        //Pre-requisite: just dry-run 1-2 times atleast to grab the deep insight behind the working of this code then u can easly understand this question\\n        \\n        //time Optimized approach uses large array instead of  hashmap\\n        Integer[]map = new Integer[(1 << 10)];//(1 << 10) -> 10000000000\\n        // HashMap<Integer,Integer>map = new HashMap<>();//map(state, index);\\n        map[0] = -1;\\n        \\n        int state = 0;\\n        int ans = 0;\\n        \\n        for(int i = 0; i<s.length(); i++) {\\n            char ch = s.charAt(i);\\n            \\n            int mask = (1 << (ch - \\'0\\'));\\n            state ^= mask;\\n            \\n            if(map[state] != null) {\\n                int j = map[state];\\n                ans = Math.max(ans, i - j);\\n            }\\n            \\n            for(int b = 0; b<10; b++) {\\n                mask = (1 << b);//state^mask -> togling of \\'bth\\' bit in the state variable\\n                \\n                if(map[state ^ mask] != null) {\\n                    int j = map[state ^ mask];\\n                    \\n                    ans = Math.max(ans, i - j);\\n                }\\n            }\\n            \\n            if(map[state] == null) {\\n                map[state] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171375,
                "title": "debug-the-code",
                "content": "please can anyone tell me what\\'s wrong in the following code if i am not using dp then it\\'s right ans. but while using dp it;s showing wrong ans. can someone help me to figure out what is wrong in  the following algo..\\n\\n\\nLogic---\\n\\nI have used the map for frequency and checking if the count of numbers whose frequency is odd if odd==1 or 2 then the number can become pallindrome other wise not \\n\\n```\\nclass Solution {\\npublic:\\n    int odd = 0;\\n    vector<vector<int>> dp;\\n    int find(string &str,int start,int end,unordered_map<char,int> m){\\n        \\n        if(start > end) return 0;\\n        if(dp[start][end] != -1){ return dp[start][end];}\\n        if(odd == 1 || odd == 0){ cout<<start<<\" \"<<end<<endl;   return dp[start][end] = end-start+1;}\\n    \\n        // we are going to first half\\n        int res = 0;\\n        if(m[str[end]]%2) odd--;\\n        else odd++;\\n        m[str[end]]--;\\n        \\n        res = find(str,start,end-1,m);\\n        \\n        if(m[str[end]]%2) odd++;\\n        else odd--;\\n        m[str[end]]++;\\n        \\n        if(m[str[start]]%2) odd--;\\n        else odd++;\\n        m[str[start]]--;\\n        \\n        res=max(res,find(str,start+1,end,m));\\n        if(m[str[start]]%2) odd++;\\n        else odd--;\\n        m[str[start]]++;\\n        \\n        return dp[start][end] = res;\\n        \\n    }\\n    \\n    int longestAwesome(string str){\\n        \\n        dp.resize(str.length(),vector<int>(str.length(),-1));\\n        unordered_map<char,int> m;\\n        for(auto x:str) m[x]++;\\n        \\n        for(auto x:m) {if(x.second%2) odd++;}\\n        return find(str,0,str.length()-1,m);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int odd = 0;\\n    vector<vector<int>> dp;\\n    int find(string &str,int start,int end,unordered_map<char,int> m){\\n        \\n        if(start > end) return 0;\\n        if(dp[start][end] != -1){ return dp[start][end];}\\n        if(odd == 1 || odd == 0){ cout<<start<<\" \"<<end<<endl;   return dp[start][end] = end-start+1;}\\n    \\n        // we are going to first half\\n        int res = 0;\\n        if(m[str[end]]%2) odd--;\\n        else odd++;\\n        m[str[end]]--;\\n        \\n        res = find(str,start,end-1,m);\\n        \\n        if(m[str[end]]%2) odd++;\\n        else odd--;\\n        m[str[end]]++;\\n        \\n        if(m[str[start]]%2) odd--;\\n        else odd++;\\n        m[str[start]]--;\\n        \\n        res=max(res,find(str,start+1,end,m));\\n        if(m[str[start]]%2) odd++;\\n        else odd--;\\n        m[str[start]]++;\\n        \\n        return dp[start][end] = res;\\n        \\n    }\\n    \\n    int longestAwesome(string str){\\n        \\n        dp.resize(str.length(),vector<int>(str.length(),-1));\\n        unordered_map<char,int> m;\\n        for(auto x:str) m[x]++;\\n        \\n        for(auto x:m) {if(x.second%2) odd++;}\\n        return find(str,0,str.length()-1,m);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2145739,
                "title": "python-bitmask-clean-code",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        mask = 0\\n        index = defaultdict(lambda:float(\\'-inf\\'),{0:-1})\\n        res = 0\\n        for i,c in enumerate(s):\\n            mask ^= (1<<(ord(c)-ord(\\'0\\')))\\n            if index[mask] == float(\\'-inf\\'):\\n                index[mask] = i\\n            res = max(res, i-index[mask])\\n\\t\\t\\t#when the palindrome has one odd numbers of digits\\n            for j in range(10):\\n                tmp_mask = mask^(1<<j)\\n                res = max(res, i-index[tmp_mask] if index[tmp_mask] != float(\\'-inf\\') else 0)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "class Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        mask = 0\\n        index = defaultdict(lambda:float(\\'-inf\\'),{0:-1}",
                "codeTag": "Java"
            },
            {
                "id": 2113464,
                "title": "c-easy-to-understand-simple-bitmasking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n=s.size();\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        int state=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int mask=(1<<(s[i]-\\'0\\'));\\n            state=(state^mask);\\n            if(mp.find(state)!=mp.end())\\n            {\\n                int j=mp[state];\\n                ans=max(ans,i-j);\\n            }\\n            for(int k=0;k<=9;k++)\\n            {\\n                int mask=(1<<k);\\n                int state2=state^mask;\\n                if(mp.find(state2)!=mp.end())\\n                {\\n                    int j=mp[state2];\\n                    ans=max(ans,i-j);\\n                }\\n            }\\n            if(mp.find(state)==mp.end())\\n            mp[state]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n=s.size();\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        int state=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int mask=(1<<(s[i]-\\'0\\'));\\n            state=(state^mask);\\n            if(mp.find(state)!=mp.end())\\n            {\\n                int j=mp[state];\\n                ans=max(ans,i-j);\\n            }\\n            for(int k=0;k<=9;k++)\\n            {\\n                int mask=(1<<k);\\n                int state2=state^mask;\\n                if(mp.find(state2)!=mp.end())\\n                {\\n                    int j=mp[state2];\\n                    ans=max(ans,i-j);\\n                }\\n            }\\n            if(mp.find(state)==mp.end())\\n            mp[state]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098100,
                "title": "python-prefix-bitmask-fastest-99",
                "content": "I have givien solution below, with comments on each line to see what that line is doing.\\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        res = cur = 0\\n        seen = {0:-1}\\n        \\n        # as there is only 10 digits, define dict \\n        digits = {\\'0\\':1,\\'1\\':2,\\'2\\':4,\\'3\\':8,\\'4\\':16,\\'5\\':32,\\'6\\':64,\\'7\\':128,\\'8\\':256,\\'9\\':1024}\\n        \\n        for i,c in enumerate(s):\\n            cur ^= digits.get(c)\\n            \\n            # See if mask alredy in seen, if not then set it\\n            if cur not in seen:\\n                seen[cur] = i\\n            else:\\n                # else calulate length and save max in res\\n                res = max(res, i - seen[cur])\\n            \\n            # by fliping each digit, see if there prefix palindrome string\\n            for j in digits.values():\\n                newmask = cur ^ j\\n                \\n                if newmask in seen:\\n                    res = max(res,i-seen[newmask])\\n\\n        return res\\n```\\n\\n##### With this I suggest you also solve below very similar problem,\\n[1915. Number of Wonderful Substrings](https://leetcode.com/problems/number-of-wonderful-substrings/)\\n\\nIf you find this helpful, please do **upVote^**. \\nFor any help or suggestion, comment below.",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        res = cur = 0\\n        seen = {0:-1}\\n        \\n        # as there is only 10 digits, define dict \\n        digits = {\\'0\\':1,\\'1\\':2,\\'2\\':4,\\'3\\':8,\\'4\\':16,\\'5\\':32,\\'6\\':64,\\'7\\':128,\\'8\\':256,\\'9\\':1024}\\n        \\n        for i,c in enumerate(s):\\n            cur ^= digits.get(c)\\n            \\n            # See if mask alredy in seen, if not then set it\\n            if cur not in seen:\\n                seen[cur] = i\\n            else:\\n                # else calulate length and save max in res\\n                res = max(res, i - seen[cur])\\n            \\n            # by fliping each digit, see if there prefix palindrome string\\n            for j in digits.values():\\n                newmask = cur ^ j\\n                \\n                if newmask in seen:\\n                    res = max(res,i-seen[newmask])\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045971,
                "title": "c-bit-manipulation-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string str) {\\n        // mask, index\\n        map<int, int> inx;\\n        inx[0] = -1;\\n        \\n        int mask = 0, ans = 1;\\n        for(int i = 0; i < str.length(); i++) {\\n            mask ^= (1 << (str[i]-\\'0\\'));\\n            \\n            // all are even\\n            if(inx.count(mask))\\n                ans = max(ans, i - inx[mask]);\\n            \\n            // one is odd and others are even\\n            for(int j = 0; j < 10; j++) {\\n                int tmp_mask = mask ^ (1<<j);\\n                if(inx.count(tmp_mask))\\n                    ans = max(ans, i - inx[tmp_mask]);\\n            }\\n            \\n            // add to map\\n            if(inx.count(mask) == 0)\\n                inx[mask] = i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string str) {\\n        // mask, index\\n        map<int, int> inx;\\n        inx[0] = -1;\\n        \\n        int mask = 0, ans = 1;\\n        for(int i = 0; i < str.length(); i++) {\\n            mask ^= (1 << (str[i]-\\'0\\'));\\n            \\n            // all are even\\n            if(inx.count(mask))\\n                ans = max(ans, i - inx[mask]);\\n            \\n            // one is odd and others are even\\n            for(int j = 0; j < 10; j++) {\\n                int tmp_mask = mask ^ (1<<j);\\n                if(inx.count(tmp_mask))\\n                    ans = max(ans, i - inx[tmp_mask]);\\n            }\\n            \\n            // add to map\\n            if(inx.count(mask) == 0)\\n                inx[mask] = i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947695,
                "title": "c-study-java-code-first-c-code-engineering-skills",
                "content": "April 14, 2022\\n**Introduction**\\nEngineering skills are hard to train through leetcode algorithm practice. What I like to work on is to have more submissions. One of ideas is to study discuss posts and write C# code based on Java code shared by votrubac. \\n\\n**Engineering skills | Analytical skills**\\nI have some issues, maybe because I applied over-engineering analysis on this hard level algorithm. So I like to copy the analysis in the following, and then learn from expert instead. \\n\\n**votrubac\\'s analysis | My translation is next**\\nWe can form a palindrome if the count of each included number (expcept maybe one) is even, and this is the property of an awesome string.\\n\\nA bit in our mask is 0 if the count for the corresponding number is even, and 1 if it\\'s odd. As we go through the string, we track odd/even counts in our mask. If we see the same mask again, the subarray between first poistion (exclusive) and the current position (inclusive) with the same mask has all numbers with the even count.\\n\\nWe will use the dp array to track the smallest (first) position of each mask. We can get the size of the substring by substracting it from the current poisition.\\n\\nNote that position for zero mask is -1, as we need to include the very first character.\\n\\nNow, the difference from 1371 is that a palindrome can have up to one number with the odd count. Therefore, we need to also check all masks that are different from the current one by one bit. In other words, if two masks are different by one bit, that means that there is one odd count in the substring.\\n\\n**My translation**\\n1. Palindrome substring - even length - count of each digit is even\\n2. Palindrome substring - odd length - one digit count is odd, all others are even\\n3. 0 and 1 are used to represent even or odd. Iterate the given string char by char, record odd/even count in a mask variable - each digit from 0 to 9 is one bit, one integer can have 10 bits to cover all digits\\'s count. \\n4. Design: define an integer array called dp[1024], explain 1024 = 2^10 to cover all 10 digits\\'s count;\\n5. Initialization - position for zero mask is -1, since the first character should be included. \\n6. Go back to review my practice 1371. Check all masks that are diffrent from the current one by one bit. In other words, if two masks are different by one bit, that means that there is one odd count in the substring. <- why one odd count, not at least one? \\n\\n**Leetcode algorithm practice | Meta onsite in May 2022**\\nI need to figure out how to prepare algorithm interview. One of ideas is to learn ideas from other discuss post, and then quickly understand the analysis and write C# code. \\n\\n**C# catchup | Enumerable.Range(start, count)**\\nI run into exception, so that I made change on C# code\\n```\\ndp = Enumerable.Range(0, 1024).Select(i => length).ToArray();\\n```\\nI thought that start and end two indexes, actually it is start and count two variables. \\n```\\npublic static System.Collections.Generic.IEnumerable<int> Range (int start, int count);\\n```\\n\\nThe following C# code passes online judge. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1542_longest_substring\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var max = LongestAwesome(\"9498331\");\\n            Debug.Assert(max == 3);\\n        }\\n\\n        /// <summary>\\n        /// study code:\\n        /// https://leetcode.com/problems/find-longest-awesome-substring/discuss/779893/C%2B%2BJavaPython3-with-picture-(similar-to-1371)\\n        /// Learn to convert Java code to C# code\\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <returns></returns>\\n        public static int LongestAwesome(string s)\\n        {\\n            // design: 2^0, ..., 2^9, so 2^10 = 1024, minimum upper bound\\n            var dp = new int[1024];\\n\\n            var length = s.Length;\\n            //Arrays.fill(dp, s.length()); - Google Java Arrays.fill C# analog -> \\n            dp = Enumerable.Range(0, 1024).Select(i => length).ToArray();\\n\\n            int result = 0;  // default value is zero\\n            var mask = 0;\\n            dp[0] = -1;\\n\\n            for (int i = 0; i < length; ++i)\\n            {\\n                mask ^= 1 << (s[i] - \\'0\\');\\n                result = Math.Max(result, i - dp[mask]);\\n\\n                for (int digit = 0; digit <= 9; ++digit)\\n                {\\n                    result = Math.Max(result, i - dp[mask ^ (1 << digit)]);\\n                }\\n\\n                dp[mask] = Math.Min(dp[mask], i);\\n            }\\n\\n            return result;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndp = Enumerable.Range(0, 1024).Select(i => length).ToArray();\\n```\n```\\npublic static System.Collections.Generic.IEnumerable<int> Range (int start, int count);\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1542_longest_substring\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var max = LongestAwesome(\"9498331\");\\n            Debug.Assert(max == 3);\\n        }\\n\\n        /// <summary>\\n        /// study code:\\n        /// https://leetcode.com/problems/find-longest-awesome-substring/discuss/779893/C%2B%2BJavaPython3-with-picture-(similar-to-1371)\\n        /// Learn to convert Java code to C# code\\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <returns></returns>\\n        public static int LongestAwesome(string s)\\n        {\\n            // design: 2^0, ..., 2^9, so 2^10 = 1024, minimum upper bound\\n            var dp = new int[1024];\\n\\n            var length = s.Length;\\n            //Arrays.fill(dp, s.length()); - Google Java Arrays.fill C# analog -> \\n            dp = Enumerable.Range(0, 1024).Select(i => length).ToArray();\\n\\n            int result = 0;  // default value is zero\\n            var mask = 0;\\n            dp[0] = -1;\\n\\n            for (int i = 0; i < length; ++i)\\n            {\\n                mask ^= 1 << (s[i] - \\'0\\');\\n                result = Math.Max(result, i - dp[mask]);\\n\\n                for (int digit = 0; digit <= 9; ++digit)\\n                {\\n                    result = Math.Max(result, i - dp[mask ^ (1 << digit)]);\\n                }\\n\\n                dp[mask] = Math.Min(dp[mask], i);\\n            }\\n\\n            return result;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947500,
                "title": "c-bit-manipulation-hashmap",
                "content": "April 14, 2022\\n**Introduction**\\nI like to share my working C# solution using bit manipulation and hashmap solution. Compared to the idea using an integer array int[1024] to do the work, it takes extra steps to check if key exists or not. \\n\\n\\nThe following C# code passes online judge. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1542_test_one_case\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var result = LongestAwesome(\"3242415\");\\n        }\\n\\n        public static int LongestAwesome(string s)\\n        {\\n            if (s == null || s.Length == 0)\\n            {\\n                return 0;\\n            }\\n\\n            var map = new Dictionary<int, int>();\\n\\n            map.Add(0, -1); //\\n\\n            var length = s.Length;\\n            var bitsForDigits = 0;\\n            var maxLength = 0;\\n\\n            // 0 ^ 0 = 0\\n            // 0 ^ 1 = 1\\n            // 1 ^ 1 = 1  // xor - determine odd or even in each bit\\n            for (int i = 0; i < length; i++)\\n            {\\n                var digit = s[i] - \\'0\\';\\n                bitsForDigits ^= 1 << digit;\\n\\n                if (!map.ContainsKey(bitsForDigits))\\n                {\\n                    map.Add(bitsForDigits, i);\\n                }\\n                else\\n                {\\n                    maxLength = Math.Max(maxLength, i - map[bitsForDigits]);\\n                }\\n\\n                // search odd matching \\n                // brute force all digits with 1 - at most 10 cases\\n                for (int shift = 0; shift <= 9; shift++)\\n                {\\n                    var key = bitsForDigits ^ (1 << shift);  // remove one digit      \\n                      \\n                    if (map.ContainsKey(key))\\n                    {\\n                        maxLength = Math.Max(maxLength, i - map[key]);\\n                    }  \\n                }\\n            }\\n\\n            return maxLength;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1542_test_one_case\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var result = LongestAwesome(\"3242415\");\\n        }\\n\\n        public static int LongestAwesome(string s)\\n        {\\n            if (s == null || s.Length == 0)\\n            {\\n                return 0;\\n            }\\n\\n            var map = new Dictionary<int, int>();\\n\\n            map.Add(0, -1); //\\n\\n            var length = s.Length;\\n            var bitsForDigits = 0;\\n            var maxLength = 0;\\n\\n            // 0 ^ 0 = 0\\n            // 0 ^ 1 = 1\\n            // 1 ^ 1 = 1  // xor - determine odd or even in each bit\\n            for (int i = 0; i < length; i++)\\n            {\\n                var digit = s[i] - \\'0\\';\\n                bitsForDigits ^= 1 << digit;\\n\\n                if (!map.ContainsKey(bitsForDigits))\\n                {\\n                    map.Add(bitsForDigits, i);\\n                }\\n                else\\n                {\\n                    maxLength = Math.Max(maxLength, i - map[bitsForDigits]);\\n                }\\n\\n                // search odd matching \\n                // brute force all digits with 1 - at most 10 cases\\n                for (int shift = 0; shift <= 9; shift++)\\n                {\\n                    var key = bitsForDigits ^ (1 << shift);  // remove one digit      \\n                      \\n                    if (map.ContainsKey(key))\\n                    {\\n                        maxLength = Math.Max(maxLength, i - map[key]);\\n                    }  \\n                }\\n            }\\n\\n            return maxLength;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940881,
                "title": "c-last-position-bit-manipulation-study-code",
                "content": "April 12, 2022\\n**Introduction**\\nThere is only one C# solution in discuss, and I chose to study it and wrote my own C# code. \\n\\n**Bit manipulation**\\nFrom each integer n from 0 to 9, 2^n can be ranged from 1 to 512. So it is working solution to define masks array using those 10 numbers. \\n\\n**Case study: 76263**\\nGiven an integer 76263, longest substring 626 can be swapped into a palindrome. \\n\\nSubstring starting from index = 0, \"7\" can be mapped to prefixes[0] = 2^7 = 128. How to find a longest substring starting from index = 1 which can be swapped to a palindrome substring. \\n\\nOne of search is to find lastPosition defined as int[1024], here key is 128, lastPosition[128], if it is not defined or found, the default value of integer array is 0. Since maximum substring default value is 1, it is not a problem using default value 0 of lastPosition. \\n\\nAnother of search is to go through all possible masks - 1st to 9th bit, masks array index position from 0 to 9, XOR two values, one is prefixes[0] = 2&6 = 128, and look for last position of the mask value. If it is not found, then lastPosition array\\'s lookup is 0, and then \\n```\\nlastPosition[prefixes[i] ^ mask] - i + 1\\n```\\nThe above expression returns negative value, which does not matter since it will not be bigger than default value 1 of variable answer - maximum length of substring. \\n\\nSo \"7\", with all possible one extra digit, look for lastPosition with same odd and even count of string \"70\",\"71\",\"72\",\"73\",\"74\",\"75\",\"76\",\"77\",\"78\",\"79\". \\n\\n**First tip | Use array for 10 bits = 1111111111 in binary form = 2^9 + 2^8 + ...+ 2^0 < 2^10 = 1024 | Compare to use HashMap** \\nIt is hard level algorithm. Most of important is to design a working solution. Using array compared to HashMap on this algorithm definitely makes it easy to write a working solution. \\n\\n**Last position vs first position | Luck or smartness | I do not know**\\nI chose to first position, but I came cross a bug and I could not fix it. My design and the algorithm failed one test case: 9498331. [Here](https://leetcode.com/problems/find-longest-awesome-substring/discuss/1940771/C-or-First-position-or-Bit-manipulation-or-Failed%3A-%229498331%22-or-Lessons-learned) is my C# practice with failed test case. \\n\\nI learned to write using last position by studying discuss section C# code. I do not know how to advance myself in such short time to prepare for May Meta onsite. \\n\\n\\nThe following code passes online judge. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1542_study_code\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {   \\n            var max = LongestAwesome(\"9498331\");\\n            Debug.Assert(max == 3);\\n\\n            var max2 = LongestAwesome(\"30003\");\\n            Debug.Assert(max2 == 5);\\n\\n            // 76263 - 30003\\n            var max3 = LongestAwesome(\"76263\");\\n            Debug.Assert(max3 == 3);\\n        }\\n\\n        /// <summary>\\n        /// study code:\\n        /// https://leetcode.com/problems/find-longest-awesome-substring/discuss/952409/C-Bit-Manipulation\\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <returns></returns>\\n        public static int LongestAwesome(string s)\\n        {            \\n            var masks = new int[] { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 };\\n\\n            var length = s.Length;\\n            // calculate prefixes\\n            var prefixes = new int[length + 1];\\n\\n            for (var i = 1; i <= length; i++)\\n            {\\n                // XOR - 1 or 0, even or odd count\\n                prefixes[i] = prefixes[i - 1] ^ masks[s[i - 1] - \\'0\\'];\\n            }\\n\\n            // calculate last indexes of prefixes\\n            // 1024 - what for? 2^10 = 1024, 0 - 9, 2^0 = 1, ..., 2^9 = 512 \\n            var lastPosition = new int[1024];\\n\\n            for (var i = 0; i < s.Length; i++)\\n            {\\n                lastPosition[prefixes[i + 1]] = i;\\n            }\\n\\n            var answer = 1;\\n            // check max length between last index (+ any variations(10)) and current index\\n            // I failed in my practice since I chose to work on previous position - this makes buggy code\\n            for (var i = 0; i < length; i++)\\n            {\\n                answer = Math.Max(answer, lastPosition[prefixes[i]] - i + 1);\\n\\n                foreach (var mask in masks)\\n                {\\n                    answer = Math.Max(answer, lastPosition[prefixes[i] ^ mask] - i + 1);\\n                }\\n            }\\n\\n            return answer;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlastPosition[prefixes[i] ^ mask] - i + 1\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1542_study_code\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {   \\n            var max = LongestAwesome(\"9498331\");\\n            Debug.Assert(max == 3);\\n\\n            var max2 = LongestAwesome(\"30003\");\\n            Debug.Assert(max2 == 5);\\n\\n            // 76263 - 30003\\n            var max3 = LongestAwesome(\"76263\");\\n            Debug.Assert(max3 == 3);\\n        }\\n\\n        /// <summary>\\n        /// study code:\\n        /// https://leetcode.com/problems/find-longest-awesome-substring/discuss/952409/C-Bit-Manipulation\\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <returns></returns>\\n        public static int LongestAwesome(string s)\\n        {            \\n            var masks = new int[] { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 };\\n\\n            var length = s.Length;\\n            // calculate prefixes\\n            var prefixes = new int[length + 1];\\n\\n            for (var i = 1; i <= length; i++)\\n            {\\n                // XOR - 1 or 0, even or odd count\\n                prefixes[i] = prefixes[i - 1] ^ masks[s[i - 1] - \\'0\\'];\\n            }\\n\\n            // calculate last indexes of prefixes\\n            // 1024 - what for? 2^10 = 1024, 0 - 9, 2^0 = 1, ..., 2^9 = 512 \\n            var lastPosition = new int[1024];\\n\\n            for (var i = 0; i < s.Length; i++)\\n            {\\n                lastPosition[prefixes[i + 1]] = i;\\n            }\\n\\n            var answer = 1;\\n            // check max length between last index (+ any variations(10)) and current index\\n            // I failed in my practice since I chose to work on previous position - this makes buggy code\\n            for (var i = 0; i < length; i++)\\n            {\\n                answer = Math.Max(answer, lastPosition[prefixes[i]] - i + 1);\\n\\n                foreach (var mask in masks)\\n                {\\n                    answer = Math.Max(answer, lastPosition[prefixes[i] ^ mask] - i + 1);\\n                }\\n            }\\n\\n            return answer;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940771,
                "title": "c-first-position-bit-manipulation-failed-9498331-lessons-learned",
                "content": "April 12, 2022\\n**Introduction**\\nIt is a hard level algorithm. I chose to work on it, since I just did solve a similar bit manipulation algorithm 1371. Find the Longest Substring Containing Vowels in Even Counts based on discuss post by votrubac. I chose to work on first position of bit manipulation, and I came cross this failed test case \"9498331\". I could not solve the issue, and I just could not believe that how others solve the problem but no warning on this first position idea and its bugg issue. \\n\\n**Brute force solution | O(N^2)**\\nIt takes O(N^2) to find all substrings, and then it can be calculated to maximum substring to be swapped to a palindrome. \\n\\n**Optimal solution | Hashmap to record count of digits**\\nIt is easy to come out the design to use 10 bits to represent 0 to 9 10 digits, even or odd count using 0 or 1 to represent. \\n\\n**Case study | \"9498331\" | Should return 3, not 4**\\n\\nThe following code failed test case: 78 / 153 test cases passed.\\nInput:\\n\"9498331\"\\nOutput: 4\\nShould be: 3\\n\\n**Lesson learned:**\\nAnalysis:\\n949833 \\n94 - remove 9, so, 4 maps to a number 1<< 4 = 2^4 = 16. \\n949833 - remove 8, 94933 maps to a number 1 << 4 = 2^4 = 16\\nfirst position with 16\\'s index = 1, and the current positon with 16\\'s index = 5, so the answer is 4, but \"9833\" can not be a palindrome by the option to remove one char. \\n\\nThere are more than two issues in my design using those 10 bits mask to map 0 to 9 10 digits. It took me hours to figure out what is wrong, and how to address the issues. \\n\\n**Faulty design | Save substring with all possible one extra digit into HashMap**\\nI just gave it a quick try without strictly proof that it should work. I even save extra key into HashMap to pad at the end one more digit - any digit from 0 to 9. \\n\\nI chose to use first position, and then handle extra digit case. It is not easy to figure out so many things in such a short time. Just be patient. Learn from those failed submissions and those failed test cases, and I think that the failures should be best teacher for me. To prepare for Mata onsite in May 2022, I should try 10 hard level algorithms, and learn from all those mistakes in practice. [Here](https://leetcode.com/discuss/interview-question/1914695/30-days-to-meta-onsite-4th-facebook-onsite-system-design-daily-update-day-5) is my discuss post related to Meta onsite 30 day preparation. \\n\\nI should work on last position instead. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1542_find_longest_awesome_substring\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            //var maximumLength = LongestAwesome(\"3242415\");\\n            //Debug.Assert(maximumLength == 5);\\n\\n            var max = LongestAwesome(\"9498331\");\\n            Debug.Assert(max == 3);\\n        }\\n\\n        /// <summary>\\n        /// April 8, 2022\\n        /// Brute force solution O(N^2) \\n        /// find all substrings and then check if it is an awesome substring\\n        /// Optimal solution should be O(N), go through the array once, and then \\n        /// record all digits count in terms of even or odd, using one integer 10 bits \\n        /// to contain all 10 bits - left to right, 0 - 9\\n        /// \\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <returns></returns>\\n        public static int LongestAwesome(string s)\\n        {\\n            if (s == null || s.Length == 0)\\n            {\\n                return 0;\\n            }\\n            \\n            var map = new Dictionary<int, int>();            \\n\\n            map.Add(0, -1); //\\n\\n            var length = s.Length;\\n            var bitsForDigits = 0;\\n            var maxLength = 0;\\n\\n            // 0 ^ 0 = 0\\n            // 0 ^ 1 = 1\\n            // 1 ^ 1 = 1  // xor - determine odd or even in each bit\\n            for (int i = 0; i < length; i++)\\n            {\\n                var digit = s[i] - \\'0\\';\\n                bitsForDigits ^= 1 << digit;\\n\\n                if (!map.ContainsKey(bitsForDigits))\\n                {\\n                    map.Add(bitsForDigits, i);\\n                }\\n                else\\n                {\\n                     maxLength = Math.Max(maxLength, i - map[bitsForDigits]);\\n                }\\n                  \\n                // search odd matching \\n                // brute force all digits with 1 - at most 10 cases\\n                for (int shift = 0; shift <= 9; shift++)\\n                {\\n                    // mask one bit\\n                    if ((bitsForDigits & (1 << shift)) == 0)\\n                    {\\n                        continue;\\n                    }\\n\\n                    var key = bitsForDigits ^ (1 << shift);  // remove one digit\\n\\n                    if (!map.ContainsKey(key))\\n                    {\\n                        map.Add(key, i);\\n                    }\\n                    else\\n                    {\\n                        // 949833, remove 4, 99833, but 8\\'s count is odd \\n                        //if (key == 0)  // make sure that all digits have even count\\n                        {\\n                            maxLength = Math.Max(maxLength, i - map[key]);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return maxLength;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1542_find_longest_awesome_substring\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            //var maximumLength = LongestAwesome(\"3242415\");\\n            //Debug.Assert(maximumLength == 5);\\n\\n            var max = LongestAwesome(\"9498331\");\\n            Debug.Assert(max == 3);\\n        }\\n\\n        /// <summary>\\n        /// April 8, 2022\\n        /// Brute force solution O(N^2) \\n        /// find all substrings and then check if it is an awesome substring\\n        /// Optimal solution should be O(N), go through the array once, and then \\n        /// record all digits count in terms of even or odd, using one integer 10 bits \\n        /// to contain all 10 bits - left to right, 0 - 9\\n        /// \\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <returns></returns>\\n        public static int LongestAwesome(string s)\\n        {\\n            if (s == null || s.Length == 0)\\n            {\\n                return 0;\\n            }\\n            \\n            var map = new Dictionary<int, int>();            \\n\\n            map.Add(0, -1); //\\n\\n            var length = s.Length;\\n            var bitsForDigits = 0;\\n            var maxLength = 0;\\n\\n            // 0 ^ 0 = 0\\n            // 0 ^ 1 = 1\\n            // 1 ^ 1 = 1  // xor - determine odd or even in each bit\\n            for (int i = 0; i < length; i++)\\n            {\\n                var digit = s[i] - \\'0\\';\\n                bitsForDigits ^= 1 << digit;\\n\\n                if (!map.ContainsKey(bitsForDigits))\\n                {\\n                    map.Add(bitsForDigits, i);\\n                }\\n                else\\n                {\\n                     maxLength = Math.Max(maxLength, i - map[bitsForDigits]);\\n                }\\n                  \\n                // search odd matching \\n                // brute force all digits with 1 - at most 10 cases\\n                for (int shift = 0; shift <= 9; shift++)\\n                {\\n                    // mask one bit\\n                    if ((bitsForDigits & (1 << shift)) == 0)\\n                    {\\n                        continue;\\n                    }\\n\\n                    var key = bitsForDigits ^ (1 << shift);  // remove one digit\\n\\n                    if (!map.ContainsKey(key))\\n                    {\\n                        map.Add(key, i);\\n                    }\\n                    else\\n                    {\\n                        // 949833, remove 4, 99833, but 8\\'s count is odd \\n                        //if (key == 0)  // make sure that all digits have even count\\n                        {\\n                            maxLength = Math.Max(maxLength, i - map[key]);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return maxLength;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897753,
                "title": "c-bitmask-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<int,int> map;\\n        int mask = 0, maxL = 0;\\n        map[mask] = -1;\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            int ch = s[i]-\\'0\\';\\n            mask^= (1<<ch);\\n            \\n            if(map.find(mask) != map.end()){\\n                maxL = max(maxL, i-map[mask]);\\n            }\\n            \\n            for(int x=0; x<=9; ++x){\\n                int newMask = mask^(1<<x);\\n                if(map.find(newMask) != map.end()){\\n                    maxL = max(maxL, i-map[newMask]);\\n                }\\n            }\\n            \\n            if(map.find(mask) == map.end()){\\n                map[mask] = i;\\n            }\\n        }\\n        return maxL;\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<int,int> map;\\n        int mask = 0, maxL = 0;\\n        map[mask] = -1;\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            int ch = s[i]-\\'0\\';\\n            mask^= (1<<ch);\\n            \\n            if(map.find(mask) != map.end()){\\n                maxL = max(maxL, i-map[mask]);\\n            }\\n            \\n            for(int x=0; x<=9; ++x){\\n                int newMask = mask^(1<<x);\\n                if(map.find(newMask) != map.end()){\\n                    maxL = max(maxL, i-map[newMask]);\\n                }\\n            }\\n            \\n            if(map.find(mask) == map.end()){\\n                map[mask] = i;\\n            }\\n        }\\n        return maxL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848904,
                "title": "help-please-tell-why-is-this-solution-worng",
                "content": "class Solution {\\n    public int longestAwesome(String s) {\\n        int st[] = new int[10];\\n        int ans=0;\\n        for(int i =0;i<s.length();i++){\\n            st[s.charAt(i)-\\'0\\']++;\\n        }\\n        int i=0;\\n        for(;i<10;i++){\\n           if(st[i]!=0) {if(st[i]%2==1){\\n                ans+=st[i];\\n                break;\\n            }\\n            else{\\n                ans+=st[i];\\n            }}\\n        }\\n        ++i;\\n        for(;i<10;i++){\\n            if(st[i]!=0) {\\n            if(st[i]%2==1){\\n                ans+=st[i]-1;\\n            }\\n            else{\\n                ans+=st[i];\\n            }}\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int longestAwesome(String s) {\\n        int st[] = new int[10];\\n        int ans=0;\\n        for(int i =0;i<s.length();i++){\\n            st[s.charAt(i)-\\'0\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1770659,
                "title": "pls-help-needed-why-this-can-t-be-solved-by-using-concept-of-leetcode-395",
                "content": "![image](https://assets.leetcode.com/users/images/c3eae3b2-6aa1-4f7d-868f-ccbec53a192f_1644845764.5541365.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/c3eae3b2-6aa1-4f7d-868f-ccbec53a192f_1644845764.5541365.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1745933,
                "title": "golang-bitmask-subarray-caching",
                "content": "same idea as: https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/\\n\\nthis idea is also prevalent in: \\nhttps://leetcode.com/problems/contiguous-array/\\nhttps://leetcode.com/problems/subarray-sum-equals-k/\\nhttps://leetcode.com/problems/continuous-subarray-sum/\\n\\n```\\nfunc longestAwesome(s string) int {\\n    cache := make(map[int]int)\\n    cache[0] = -1 // at idx -1, all digits\\' count is also 0\\n    mask := 0\\n    res := 0\\n    for i, c := range s {\\n        mask = mask ^ (1 << int(c - \\'0\\'))  // toggle the nth bit\\n        \\n        // check for all cases where we allow 1 of the digits to be odd count\\n        for j := 0; j<=9; j++ {\\n            oddMask := mask ^ (1 << j)\\n            if prevEnd, exist := cache[oddMask]; exist {\\n                res = max(res, i - prevEnd)\\n            }\\n        }\\n        \\n        if prevEnd, exist := cache[mask]; exist {  // check for all even case\\n            res = max(res, i - prevEnd)\\n        } else {\\n            cache[mask] = i\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n/*\\n    bitmasking -> 10 bits to represent 10 digits\\' parity\\n    \\n    possible legal combinations:\\n    0 -> all even counts\\n    only one 1 -> all even counts except for 1 odd count\\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nfunc longestAwesome(s string) int {\\n    cache := make(map[int]int)\\n    cache[0] = -1 // at idx -1, all digits\\' count is also 0\\n    mask := 0\\n    res := 0\\n    for i, c := range s {\\n        mask = mask ^ (1 << int(c - \\'0\\'))  // toggle the nth bit\\n        \\n        // check for all cases where we allow 1 of the digits to be odd count\\n        for j := 0; j<=9; j++ {\\n            oddMask := mask ^ (1 << j)\\n            if prevEnd, exist := cache[oddMask]; exist {\\n                res = max(res, i - prevEnd)\\n            }\\n        }\\n        \\n        if prevEnd, exist := cache[mask]; exist {  // check for all even case\\n            res = max(res, i - prevEnd)\\n        } else {\\n            cache[mask] = i\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n/*\\n    bitmasking -> 10 bits to represent 10 digits\\' parity\\n    \\n    possible legal combinations:\\n    0 -> all even counts\\n    only one 1 -> all even counts except for 1 odd count\\n\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1700546,
                "title": "java-using-string-instead-of-bitmask",
                "content": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n    HashMap<String, Integer> map = new HashMap<>();\\n    int[] arr = new int[10];\\n    int best = 1;\\n    map.put(\"0000000000\", -1);\\n    for (int i = 0; i < s.length(); i++) {\\n      int num = Character.getNumericValue(s.charAt(i));\\n      arr[num]++;\\n      arr[num] %= 2;\\n      StringBuffer str = new StringBuffer(\"0000000000\");\\n      for (int j = 0; j < arr.length; j++) {\\n        if (arr[j] == 1) {\\n          str.setCharAt(j, \\'1\\');\\n        }\\n      }\\n      boolean add = false;\\n      if (map.containsKey(str.toString())) {\\n        int prevIdx = map.get(str.toString());\\n        best = Math.max(best, i - prevIdx);\\n      } else {\\n\\n        add = true;\\n      }\\n      for (int j = 0; j < arr.length; j++) {\\n        if (str.charAt(j) == \\'0\\') {\\n          str.setCharAt(j, \\'1\\');\\n          if (map.containsKey(str.toString())) {\\n            best = Math.max(best, i - map.get(str.toString()));\\n          }\\n          str.setCharAt(j, \\'0\\');\\n        } else {\\n          str.setCharAt(j, \\'0\\');\\n          if (map.containsKey(str.toString())) {\\n            best = Math.max(best, i - map.get(str.toString()));\\n          }\\n          str.setCharAt(j, \\'1\\');\\n        }\\n\\n      }\\n      if (add) {\\n        map.put(str.toString(), i);\\n      }\\n    }\\n    return best;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n    HashMap<String, Integer> map = new HashMap<>();\\n    int[] arr = new int[10];\\n    int best = 1;\\n    map.put(\"0000000000\", -1);\\n    for (int i = 0; i < s.length(); i++) {\\n      int num = Character.getNumericValue(s.charAt(i));\\n      arr[num]++;\\n      arr[num] %= 2;\\n      StringBuffer str = new StringBuffer(\"0000000000\");\\n      for (int j = 0; j < arr.length; j++) {\\n        if (arr[j] == 1) {\\n          str.setCharAt(j, \\'1\\');\\n        }\\n      }\\n      boolean add = false;\\n      if (map.containsKey(str.toString())) {\\n        int prevIdx = map.get(str.toString());\\n        best = Math.max(best, i - prevIdx);\\n      } else {\\n\\n        add = true;\\n      }\\n      for (int j = 0; j < arr.length; j++) {\\n        if (str.charAt(j) == \\'0\\') {\\n          str.setCharAt(j, \\'1\\');\\n          if (map.containsKey(str.toString())) {\\n            best = Math.max(best, i - map.get(str.toString()));\\n          }\\n          str.setCharAt(j, \\'0\\');\\n        } else {\\n          str.setCharAt(j, \\'0\\');\\n          if (map.containsKey(str.toString())) {\\n            best = Math.max(best, i - map.get(str.toString()));\\n          }\\n          str.setCharAt(j, \\'1\\');\\n        }\\n\\n      }\\n      if (add) {\\n        map.put(str.toString(), i);\\n      }\\n    }\\n    return best;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386885,
                "title": "c-hash-bitmask",
                "content": "The key idea is to use a hashmap to store the previous config of the string so that when we have more than one odd element in the substring we can look for a similar event in past \\n```\\nmap<long long,int>M;\\n        //M[0]=-1;\\n        vector<int>fre(10,0);\\n        int n=s.size();\\n        int mx=0;\\n        for(int i=0;i<n;i++){\\n            fre[s[i]-\\'0\\']=(fre[s[i]-\\'0\\']+1)%2;\\n            long long te=0;\\n           for(int j=0;j<10;j++){\\n                if(fre[j])\\n                    te+=pow(2,j);}\\n            if(te==0||ceil(log2(te)*1.0)==floor(log2(te)*1.0))\\n               mx=max(mx,i+1);\\n            if(M.count(te)==0)\\n                M[te]=i;\\n            mx=max(mx,i-M[te]);\\n            for(int j=0;j<10;j++){\\n                long long el=pow(2,j);\\n                long long va=el^te;\\n                if(M.count(va))\\n                    mx=max(mx,i-M[va]);\\n            }\\n        }\\n        return mx;\\n```",
                "solutionTags": [],
                "code": "```\\nmap<long long,int>M;\\n        //M[0]=-1;\\n        vector<int>fre(10,0);\\n        int n=s.size();\\n        int mx=0;\\n        for(int i=0;i<n;i++){\\n            fre[s[i]-\\'0\\']=(fre[s[i]-\\'0\\']+1)%2;\\n            long long te=0;\\n           for(int j=0;j<10;j++){\\n                if(fre[j])\\n                    te+=pow(2,j);}\\n            if(te==0||ceil(log2(te)*1.0)==floor(log2(te)*1.0))\\n               mx=max(mx,i+1);\\n            if(M.count(te)==0)\\n                M[te]=i;\\n            mx=max(mx,i-M[te]);\\n            for(int j=0;j<10;j++){\\n                long long el=pow(2,j);\\n                long long va=el^te;\\n                if(M.count(va))\\n                    mx=max(mx,i-M[va]);\\n            }\\n        }\\n        return mx;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1375991,
                "title": "java-bit-mask",
                "content": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n       int[] firstIndex = new int[1028];\\n        Arrays.fill(firstIndex,-2);\\n        firstIndex[0] = -1;\\n        int mask = 0;\\n        int len = 0;\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            mask^=(1<<(ch-\\'0\\'));\\n            if(firstIndex[mask]!=-2){\\n                len = Math.max(len,i-firstIndex[mask]);\\n            }\\n            else{\\n                firstIndex[mask] = i;\\n            }\\n            for(int n=0;n<10;n++){\\n                if(firstIndex[mask^(1<<n)]!=-2){\\n                    len = Math.max(len,i-firstIndex[mask^(1<<n)]);\\n                }\\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n       int[] firstIndex = new int[1028];\\n        Arrays.fill(firstIndex,-2);\\n        firstIndex[0] = -1;\\n        int mask = 0;\\n        int len = 0;\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            mask^=(1<<(ch-\\'0\\'));\\n            if(firstIndex[mask]!=-2){\\n                len = Math.max(len,i-firstIndex[mask]);\\n            }\\n            else{\\n                firstIndex[mask] = i;\\n            }\\n            for(int n=0;n<10;n++){\\n                if(firstIndex[mask^(1<<n)]!=-2){\\n                    len = Math.max(len,i-firstIndex[mask^(1<<n)]);\\n                }\\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361572,
                "title": "c-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        vector<int> pos((1<<10),-1);\\n        \\n        int curr=0,ans=1;\\n        pos[0]=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            char ch=s[i];\\n            \\n            curr^=(1<<(ch-\\'0\\'));\\n            \\n            if(pos[curr]!=-1)\\n            {\\n                ans=max(ans,i-pos[curr]+1);\\n            }\\n            \\n            for(int d=0;d<10;d++)\\n            {\\n                int req=curr^(1<<d);\\n                if(pos[req]==-1) continue;\\n                ans=max(ans,i-pos[req]+1);\\n            }\\n            if(pos[curr]==-1) pos[curr]=i+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        vector<int> pos((1<<10),-1);\\n        \\n        int curr=0,ans=1;\\n        pos[0]=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            char ch=s[i];\\n            \\n            curr^=(1<<(ch-\\'0\\'));\\n            \\n            if(pos[curr]!=-1)\\n            {\\n                ans=max(ans,i-pos[curr]+1);\\n            }\\n            \\n            for(int d=0;d<10;d++)\\n            {\\n                int req=curr^(1<<d);\\n                if(pos[req]==-1) continue;\\n                ans=max(ans,i-pos[req]+1);\\n            }\\n            if(pos[curr]==-1) pos[curr]=i+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308059,
                "title": "scala-solution-bit-mask",
                "content": "```\\n\\tdef longestAwesome(s: String): Int = {\\n        var bits = 0\\n        var res = 1\\n        val bitMap = scala.collection.mutable.Map[Int,Int]()//mask -> index\\n        bitMap(bits) = -1//As we need to consider the first element as well, so start index = -1 to get substring length\\n        \\n        s.zipWithIndex.foreach{case(c,i) =>\\n            bits = flipBit(bits,c.asDigit)\\n            \\n            //If exact same bit mask occured at an earlier index, we update result\\n            if(bitMap.contains(bits)){\\n                res = res.max(i-bitMap(bits))\\n            }\\n            //If bitMask with only 1 bit difference occured earlier (palindrome with odd length), we again update result\\n            for(n<- 0 to 9){\\n                val testBits =  flipBit(bits,n)\\n                if(bitMap.contains(testBits)){\\n                    res = res.max(i-bitMap(testBits))\\n                }\\n            }\\n            //We need to save the earlier position to maintain the longest path in b/w and not update the mask index everytime\\n            if(!bitMap.contains(bits)){\\n                bitMap(bits) = i\\n            }\\n        }\\n        res\\n    }\\n    \\n    def flipBit(n:Int,i:Int):Int = {\\n        var p = 1<<i\\n        n^p\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\n\\tdef longestAwesome(s: String): Int = {\\n        var bits = 0\\n        var res = 1\\n        val bitMap = scala.collection.mutable.Map[Int,Int]()//mask -> index\\n        bitMap(bits) = -1//As we need to consider the first element as well, so start index = -1 to get substring length\\n        \\n        s.zipWithIndex.foreach{case(c,i) =>\\n            bits = flipBit(bits,c.asDigit)\\n            \\n            //If exact same bit mask occured at an earlier index, we update result\\n            if(bitMap.contains(bits)){\\n                res = res.max(i-bitMap(bits))\\n            }\\n            //If bitMask with only 1 bit difference occured earlier (palindrome with odd length), we again update result\\n            for(n<- 0 to 9){\\n                val testBits =  flipBit(bits,n)\\n                if(bitMap.contains(testBits)){\\n                    res = res.max(i-bitMap(testBits))\\n                }\\n            }\\n            //We need to save the earlier position to maintain the longest path in b/w and not update the mask index everytime\\n            if(!bitMap.contains(bits)){\\n                bitMap(bits) = i\\n            }\\n        }\\n        res\\n    }\\n    \\n    def flipBit(n:Int,i:Int):Int = {\\n        var p = 1<<i\\n        n^p\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1305025,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        int[] dp=new int[1024];\\n        Arrays.fill(dp,-5);\\n        dp[0]=-1;\\n        int mask=0;\\n        int res=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            mask= mask ^ (1<<(s.charAt(i)-\\'0\\'));\\n            if(dp[mask]!=-5)\\n            {\\n                res=Math.max(res,i-dp[mask]);\\n            }\\n            for(int j=0;j<=9;j++)\\n            {\\n                if(dp[mask ^ (1<<j)]!=-5)\\n                    res=Math.max(res,i-dp[mask ^ (1<<j)]);\\n            }\\n            if(dp[mask]==-5)\\n               dp[mask]=i;\\n        }\\n       return res; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        int[] dp=new int[1024];\\n        Arrays.fill(dp,-5);\\n        dp[0]=-1;\\n        int mask=0;\\n        int res=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            mask= mask ^ (1<<(s.charAt(i)-\\'0\\'));\\n            if(dp[mask]!=-5)\\n            {\\n                res=Math.max(res,i-dp[mask]);\\n            }\\n            for(int j=0;j<=9;j++)\\n            {\\n                if(dp[mask ^ (1<<j)]!=-5)\\n                    res=Math.max(res,i-dp[mask ^ (1<<j)]);\\n            }\\n            if(dp[mask]==-5)\\n               dp[mask]=i;\\n        }\\n       return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262186,
                "title": "doubt-over-a-test-case",
                "content": "Why test input ```\"9498331\"``` has len 3 not 5? Since we have 2-9, 2-3, 1-1, 1-4, 1-8, can\\'t we form ```39193``` or ```39493``` or ```39893```? Or am I missing soemething here?",
                "solutionTags": [],
                "code": "```\"9498331\"```\n```39193```\n```39493```\n```39893```",
                "codeTag": "Unknown"
            },
            {
                "id": 1171351,
                "title": "simple-go",
                "content": "```\\nfunc longestAwesome(s string) int {\\n    n := 0\\n    m := map[int]int {0: -1}\\n    maxLen := 1\\n    \\n    for i:=0;i<len(s);i++ {\\n        n = n ^ (1 << (s[i]-\\'0\\'))\\n        \\n        if val, ok := m[n]; ok {\\n            maxLen = max(maxLen, i-val)\\n        }\\n        \\n        for j:=0;j<10;j++ {\\n            n_ := n ^ (1 << j)\\n            if val, ok := m[n_]; ok {\\n                maxLen = max(maxLen, i-val)\\n            }\\n        }\\n        \\n        if _, ok := m[n]; !ok {\\n            m[n] = i\\n        }\\n    }\\n    return maxLen\\n    \\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc longestAwesome(s string) int {\\n    n := 0\\n    m := map[int]int {0: -1}\\n    maxLen := 1\\n    \\n    for i:=0;i<len(s);i++ {\\n        n = n ^ (1 << (s[i]-\\'0\\'))\\n        \\n        if val, ok := m[n]; ok {\\n            maxLen = max(maxLen, i-val)\\n        }\\n        \\n        for j:=0;j<10;j++ {\\n            n_ := n ^ (1 << j)\\n            if val, ok := m[n_]; ok {\\n                maxLen = max(maxLen, i-val)\\n            }\\n        }\\n        \\n        if _, ok := m[n]; !ok {\\n            m[n] = i\\n        }\\n    }\\n    return maxLen\\n    \\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1161312,
                "title": "code-review-needed",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPowerofTwo(int x){\\n        return x&&(!(x&(x-1)));\\n    }\\n    int longestAwesome(string s) {\\n        int n=s.length();\\n        int ans=0;\\n        for(int i=0;i<n;++i){\\n            int mask=0;\\n            for(int j=i;j<n;++j){\\n                mask^=(1<<(s[j]-\\'0\\'));\\n                if(mask==0 || isPowerofTwo(mask)){\\n                    ans=max(ans,j-i+1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nWhen I am submitting this code it is showing TLE.But when i am running this code with the same input it is working fine.Though the complexity is O(n^2) but still it should work with this input atleast.\\nLast executed input:\"3242415\"\\nI don\\'t know wrong with this code.Can someone help me upon this.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerofTwo(int x){\\n        return x&&(!(x&(x-1)));\\n    }\\n    int longestAwesome(string s) {\\n        int n=s.length();\\n        int ans=0;\\n        for(int i=0;i<n;++i){\\n            int mask=0;\\n            for(int j=i;j<n;++j){\\n                mask^=(1<<(s[j]-\\'0\\'));\\n                if(mask==0 || isPowerofTwo(mask)){\\n                    ans=max(ans,j-i+1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103737,
                "title": "c-bit",
                "content": "It would be better to represent the \"key\" using integer. The idea behind is the same.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        string key(10, \\'0\\');\\n        unordered_map<string, vector<int>> mp;\\n        mp[key].push_back(-1);\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            int a = s[i] - \\'0\\';\\n            if(key[a] == \\'0\\') key[a] = \\'1\\';\\n            else key[a] = \\'0\\';\\n            mp[key].push_back(i);\\n        }\\n        \\n        int ans = 1;\\n        for(auto &[k, v] : mp) {\\n            if(v.size() > 1) ans = max(ans, v.back() - v[0]);\\n            \\n            string cp = k;\\n            for(int j=0; j<10; ++j) {\\n                string cp = k;\\n                if(k[j] == \\'1\\') cp[j] = \\'0\\';\\n                else cp[j] = \\'1\\';\\n                \\n                if(mp.count(cp)) {\\n                    auto v2 = mp[cp];\\n                    ans = max(ans, v.back() - v2[0]);\\n                    ans = max(ans, v2.back() - v[0]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        string key(10, \\'0\\');\\n        unordered_map<string, vector<int>> mp;\\n        mp[key].push_back(-1);\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            int a = s[i] - \\'0\\';\\n            if(key[a] == \\'0\\') key[a] = \\'1\\';\\n            else key[a] = \\'0\\';\\n            mp[key].push_back(i);\\n        }\\n        \\n        int ans = 1;\\n        for(auto &[k, v] : mp) {\\n            if(v.size() > 1) ans = max(ans, v.back() - v[0]);\\n            \\n            string cp = k;\\n            for(int j=0; j<10; ++j) {\\n                string cp = k;\\n                if(k[j] == \\'1\\') cp[j] = \\'0\\';\\n                else cp[j] = \\'1\\';\\n                \\n                if(mp.count(cp)) {\\n                    auto v2 = mp[cp];\\n                    ans = max(ans, v.back() - v2[0]);\\n                    ans = max(ans, v2.back() - v[0]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048240,
                "title": "invalid-test-case-expected-output-9498331",
                "content": "\"9498331\" -> \"4998331\" -> \"4938931\" -> \"4938391\" , gives 93839 a palindrome and hence 5 and not 3",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 997366,
                "title": "clean-java-using-xor",
                "content": "XOR works simply as a half adder here, if there is odd numbers of certain digit, the corresponding bit will be a \"1\" and vice versa. For palindrome, we at most allow one such digit. \\n```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        int prev = 0, res = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            int val = s.charAt(i) - \\'0\\';\\n            prev ^= (1 << val);\\n            for (int j = 0; j <= 9; j++) {\\n                if (map.containsKey(prev ^ (1 << j))) {\\n                    res = Math.max(res, i - map.get(prev ^ (1 << j)));\\n                }\\n            }\\n            if (map.containsKey(prev)) {\\n                res = Math.max(res, i - map.get(prev));\\n            }\\n            map.putIfAbsent(prev, i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        int prev = 0, res = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            int val = s.charAt(i) - \\'0\\';\\n            prev ^= (1 << val);\\n            for (int j = 0; j <= 9; j++) {\\n                if (map.containsKey(prev ^ (1 << j))) {\\n                    res = Math.max(res, i - map.get(prev ^ (1 << j)));\\n                }\\n            }\\n            if (map.containsKey(prev)) {\\n                res = Math.max(res, i - map.get(prev));\\n            }\\n            map.putIfAbsent(prev, i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966292,
                "title": "p23-5",
                "content": "https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/\\nSame bit trick for even and odd making\\nBit trick of even and odd\\nIf count is even at say 5\\nthen put 5th bit 0\\nsimilalry if count of 0 is odd put 0th bit as\\nKeep the ruuning bm\\nUse map\\nFor making palindrome either one of digits count is odd or all are even\\nNow for making count of say 7 to be odd\\nif 7th bit is 0, then we have to subtract odd number from it\\nso make 7th bit as 1\\nSimilarly if 7th bit is 1(means count is odd till now) to make count odd, subtract eve from it so make 7th bit as \\n",
                "solutionTags": [],
                "code": "https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/\\nSame bit trick for even and odd making\\nBit trick of even and odd\\nIf count is even at say 5\\nthen put 5th bit 0\\nsimilalry if count of 0 is odd put 0th bit as\\nKeep the ruuning bm\\nUse map\\nFor making palindrome either one of digits count is odd or all are even\\nNow for making count of say 7 to be odd\\nif 7th bit is 0, then we have to subtract odd number from it\\nso make 7th bit as 1\\nSimilarly if 7th bit is 1(means count is odd till now) to make count odd, subtract eve from it so make 7th bit as \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 952409,
                "title": "c-bit-manipulation",
                "content": "```\\npublic class Solution\\n{\\n  public int LongestAwesome(string s)\\n  {\\n    var ans = 1;\\n    var masks = new int[] { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 };\\n\\n    // calculate prefixes\\n    var pre = new int[s.Length + 1];\\n    for (var i = 1; i <= s.Length; i++)\\n      pre[i] = pre[i - 1] ^ masks[s[i - 1] - \\'0\\'];\\n    \\n    // calculate last indexes of prefixes\\n    var lastpos = new int[1024];\\n    for (var i = 0; i < s.Length; i++)\\n      lastpos[pre[i + 1]] = i;\\n\\n    // check max length between last index (+ any variations(10)) and current index\\n    for (var i = 0; i < s.Length; i++)\\n    {\\n      ans = Math.Max(ans, lastpos[pre[i]] - i + 1);\\n\\n      foreach (var mask in masks)\\n        ans = Math.Max(ans, lastpos[pre[i] ^ mask] - i + 1);\\n    }\\n    \\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution\\n{\\n  public int LongestAwesome(string s)\\n  {\\n    var ans = 1;\\n    var masks = new int[] { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 };\\n\\n    // calculate prefixes\\n    var pre = new int[s.Length + 1];\\n    for (var i = 1; i <= s.Length; i++)\\n      pre[i] = pre[i - 1] ^ masks[s[i - 1] - \\'0\\'];\\n    \\n    // calculate last indexes of prefixes\\n    var lastpos = new int[1024];\\n    for (var i = 0; i < s.Length; i++)\\n      lastpos[pre[i + 1]] = i;\\n\\n    // check max length between last index (+ any variations(10)) and current index\\n    for (var i = 0; i < s.Length; i++)\\n    {\\n      ans = Math.Max(ans, lastpos[pre[i]] - i + 1);\\n\\n      foreach (var mask in masks)\\n        ans = Math.Max(ans, lastpos[pre[i] ^ mask] - i + 1);\\n    }\\n    \\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938617,
                "title": "java-solution-hashmap-and-bitmask",
                "content": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        int n = s.length();\\n        int[] idx = new int[(int)Math.pow(2, 10)]; // mask can be 2 ^ 10 at most\\n        // initial state\\n        Arrays.fill(idx, Integer.MAX_VALUE);\\n        idx[0] = -1; \\n        int mask = 0;\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            mask ^= 1 << (s.charAt(i) - \\'0\\');\\n            // check the all even case of palindrome\\n            ans = Math.max(ans, i - idx[mask]);\\n            // check the all even but one single case of palindrome\\n            for (int j = 0; j < 10; j++) {\\n                ans = Math.max(ans, i - idx[mask ^ (1 << j)]);\\n            }\\n            // update the min index ever seen\\n            idx[mask] = Math.min(idx[mask], i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        int n = s.length();\\n        int[] idx = new int[(int)Math.pow(2, 10)]; // mask can be 2 ^ 10 at most\\n        // initial state\\n        Arrays.fill(idx, Integer.MAX_VALUE);\\n        idx[0] = -1; \\n        int mask = 0;\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            mask ^= 1 << (s.charAt(i) - \\'0\\');\\n            // check the all even case of palindrome\\n            ans = Math.max(ans, i - idx[mask]);\\n            // check the all even but one single case of palindrome\\n            for (int j = 0; j < 10; j++) {\\n                ans = Math.max(ans, i - idx[mask ^ (1 << j)]);\\n            }\\n            // update the min index ever seen\\n            idx[mask] = Math.min(idx[mask], i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938368,
                "title": "c-98-85-time-o-len-s-and-96-space-o-1-short-code",
                "content": "```\\n#define F(x,y) for(int x = 0 ; x < y ; x++)\\n\\nconst int d_size = 1<<10;\\n\\nclass Solution {\\npublic:\\n    int digit[d_size];\\n    int longestAwesome(string s) {\\n        F(i,d_size) digit[i] = -2;\\n        digit[0] = -1;\\n        int temp = 0, ans = 0;\\n        for(int i = 0 ; s[i] ; i++){\\n            temp ^= (1<<(s[i] - \\'0\\'));\\n            if (digit[temp] == -2) digit[temp] = i;\\n            ans = max(ans, i - digit[temp]);\\n            F(j,10) if (digit[temp^(1<<j)] != -2) ans = max(ans, i - digit[temp^(1<<j)]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define F(x,y) for(int x = 0 ; x < y ; x++)\\n\\nconst int d_size = 1<<10;\\n\\nclass Solution {\\npublic:\\n    int digit[d_size];\\n    int longestAwesome(string s) {\\n        F(i,d_size) digit[i] = -2;\\n        digit[0] = -1;\\n        int temp = 0, ans = 0;\\n        for(int i = 0 ; s[i] ; i++){\\n            temp ^= (1<<(s[i] - \\'0\\'));\\n            if (digit[temp] == -2) digit[temp] = i;\\n            ans = max(ans, i - digit[temp]);\\n            F(j,10) if (digit[temp^(1<<j)] != -2) ans = max(ans, i - digit[temp^(1<<j)]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865762,
                "title": "a-simple-solution-in-c-using-bitmasks",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        vector<vector<int>> v(1500, vector<int>(0));\\n        int cur = 0;\\n        for(char x=\\'0\\'; x<=\\'9\\'; x++) if(s[0]==x) cur^=(1<<(x-\\'0\\'));\\n        v[cur].push_back(0);\\n        vector <int> p; p.push_back(0);\\n        for(int i=0; i<=9; i++) p.push_back(1<<i);\\n        int ans = 1;\\n        for(int i=1; i<n; i++) {\\n            for(char x=\\'0\\'; x<=\\'9\\'; x++) if(s[i]==x) cur^=(1<<(x-\\'0\\'));\\n            for(auto x: p) {\\n                if(cur==x) ans = max(ans, i+1);\\n                if(v[cur^x].size()>0) ans = max(ans, i-v[cur^x][0]);\\n            }\\n            v[cur].push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        vector<vector<int>> v(1500, vector<int>(0));\\n        int cur = 0;\\n        for(char x=\\'0\\'; x<=\\'9\\'; x++) if(s[0]==x) cur^=(1<<(x-\\'0\\'));\\n        v[cur].push_back(0);\\n        vector <int> p; p.push_back(0);\\n        for(int i=0; i<=9; i++) p.push_back(1<<i);\\n        int ans = 1;\\n        for(int i=1; i<n; i++) {\\n            for(char x=\\'0\\'; x<=\\'9\\'; x++) if(s[i]==x) cur^=(1<<(x-\\'0\\'));\\n            for(auto x: p) {\\n                if(cur==x) ans = max(ans, i+1);\\n                if(v[cur^x].size()>0) ans = max(ans, i-v[cur^x][0]);\\n            }\\n            v[cur].push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859733,
                "title": "unordered-map-bitmasks-c",
                "content": "Each character can be represented as 10 sized bitmask. For example we represent \\'0\\' as \\'0000000001\\'  \\'1\\' as \\'0000000010\\' \\'2\\' as \\'0000000100\\' so on. For a substring to form pallindrome on rearrangement the count of all characters except possibly one should be even. To check the parity of count of characters of a stirng we do the XOR of bitmasks of all the elements in it. Bits that are 0 are have corresponding letter even number of times and the bits that have 1 should have corresponding letter odd number of times. Therefore XORs like 0001000, 00100000, 000000, will form a pallindrome while 0001001001 etc wont form a pallindrome. So we maintain a cumulative XOR of the array from left to right and try to convert the current XOR to any of the previous form. Following code materialises the idea:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    inline int mask(char x) {\\n        return (1 << (x - \\'0\\'));\\n    }\\n    \\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        vector<int> arr(n);\\n        for(int i = 0; i < n; ++i) {\\n            arr[i] = mask(s[i]);\\n        }\\n        int i, j;\\n        unordered_map<int, int> H;\\n        H[arr[0]] = 0;\\n        int ans = 1;\\n        int cumXor = arr[0];\\n        H[0] = -1;\\n        for(i = 1; i < n; ++i) {\\n            int m = 0;\\n            int b = cumXor ^ arr[i];\\n            for(j = -1; j <= 9; ++j) {\\n                int newB;\\n                if(j == -1) {\\n                    newB = b;\\n                } else {\\n                    newB = b ^ (1 << j);\\n                }\\n                if(H.find(newB) != H.end()) {\\n                    int d = H[newB];\\n                    d++;\\n                    ans = max(ans, i - d + 1);\\n                }\\n            }\\n            if(H.find(b) == H.end()) {\\n                H[b] = i;\\n            }\\n            cumXor = b;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    inline int mask(char x) {\\n        return (1 << (x - \\'0\\'));\\n    }\\n    \\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        vector<int> arr(n);\\n        for(int i = 0; i < n; ++i) {\\n            arr[i] = mask(s[i]);\\n        }\\n        int i, j;\\n        unordered_map<int, int> H;\\n        H[arr[0]] = 0;\\n        int ans = 1;\\n        int cumXor = arr[0];\\n        H[0] = -1;\\n        for(i = 1; i < n; ++i) {\\n            int m = 0;\\n            int b = cumXor ^ arr[i];\\n            for(j = -1; j <= 9; ++j) {\\n                int newB;\\n                if(j == -1) {\\n                    newB = b;\\n                } else {\\n                    newB = b ^ (1 << j);\\n                }\\n                if(H.find(newB) != H.end()) {\\n                    int d = H[newB];\\n                    d++;\\n                    ans = max(ans, i - d + 1);\\n                }\\n            }\\n            if(H.find(b) == H.end()) {\\n                H[b] = i;\\n            }\\n            cumXor = b;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857578,
                "title": "python-list-solution-without-xor-in-comments",
                "content": "Why is 3 the expected answer for the string \"9498331\" ? My code returns 5 which i think is correct.\\nCould someone explain me why am I wrong? \\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        counter = [0]*10\\n\\n        for i in s:\\n            counter[int(i)] += 1\\n\\n        output = 0 \\n        flag = True\\n        \\n        for el in counter: \\n            output += el - el%2\\n            if flag and el%2 != 0 :\\n                flag = False\\n                output += 1\\n        \\n        return output\\n                \\n                \\n        \\n",
                "solutionTags": [],
                "code": "Why is 3 the expected answer for the string \"9498331\" ? My code returns 5 which i think is correct.\\nCould someone explain me why am I wrong? \\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        counter = [0]*10\\n\\n        for i in s:\\n            counter[int(i)] += 1\\n\\n        output = 0 \\n        flag = True\\n        \\n        for el in counter: \\n            output += el - el%2\\n            if flag and el%2 != 0 :\\n                flag = False\\n                output += 1\\n        \\n        return output\\n                \\n                \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 800720,
                "title": "concise-python",
                "content": "```\\ndef longestAwesome(self, s: str) -> int:\\n    memo, state = {}, 0\\n    memo[state], ans = -1, 0\\n    for i, c in enumerate(s):            \\n        state ^= 1 << int(c)                        \\n        if state not in memo: memo[state] = i\\n        else: ans = max(ans, i - memo[state])                            \\n        for n in range(10):\\n            state1 = state ^ (1 << n)                                 \\n            if state1 in memo: ans = max(ans, i - memo[state1])\\n    return ans",
                "solutionTags": [],
                "code": "```\\ndef longestAwesome(self, s: str) -> int:\\n    memo, state = {}, 0\\n    memo[state], ans = -1, 0\\n    for i, c in enumerate(s):            \\n        state ^= 1 << int(c)                        \\n        if state not in memo: memo[state] = i\\n        else: ans = max(ans, i - memo[state])                            \\n        for n in range(10):\\n            state1 = state ^ (1 << n)                                 \\n            if state1 in memo: ans = max(ans, i - memo[state1])\\n    return ans",
                "codeTag": "Python3"
            },
            {
                "id": 793647,
                "title": "python-3-solutions-with-and-without-bitmask",
                "content": "Without using bitmask.  \\n\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        res = 0\\n\\n        # pattern[i] True means we have even number of i so far\\n        # pattern[i] false means we have odd number of i so far\\n        pattern: List[bool] = [False] * 10\\n\\n        existing = {tuple(pattern): -1}\\n\\n        for cur_i, char in enumerate(s):\\n            num = int(char)\\n            pattern[num] = not pattern[num]\\n\\n            for i in range(10):\\n                new_pattern = pattern.copy()\\n                new_pattern[i] = not new_pattern[i]\\n                # `existing[new_pattern]` give us the position of j where\\n                # starting from `j` we know we have 1 odd number.\\n\\t\\t\\t\\t# Default to `cur_i` so that when it is missing from the \\n\\t\\t\\t\\t# existing dict, we don\\'t increase res\\n                res = max(res, cur_i - existing.get(tuple(new_pattern), cur_i))\\n\\n            # If we have `pattern` in `existing`, then we know it is also a palindrome starting from existing[pattern]\\n            res = max(res, cur_i - existing.get(tuple(pattern), cur_i))\\n\\n            existing.setdefault(tuple(pattern), cur_i)\\n\\n        return res\\n```\\n\\nExact same idea as the above but with bit mask. We know `pattern` can be fit inside an integer since it has only 10 possition numbers from `0` to `9` and the maximum will be `1 << 10` (or 1024). \\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        res = 0\\n        pattern = 0\\n\\n        existing = {pattern: -1}\\n\\n        for cur_i, char in enumerate(s):\\n            pattern ^= 1 << int(char)\\n\\n            for i in range(10):\\n                new_pattern = pattern ^ (1 << i)\\n                res = max(res, cur_i - existing.get(new_pattern, cur_i))\\n\\n            res = max(res, cur_i - existing.get(pattern, cur_i))\\n\\n            existing.setdefault(pattern, cur_i)\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        res = 0\\n\\n        # pattern[i] True means we have even number of i so far\\n        # pattern[i] false means we have odd number of i so far\\n        pattern: List[bool] = [False] * 10\\n\\n        existing = {tuple(pattern): -1}\\n\\n        for cur_i, char in enumerate(s):\\n            num = int(char)\\n            pattern[num] = not pattern[num]\\n\\n            for i in range(10):\\n                new_pattern = pattern.copy()\\n                new_pattern[i] = not new_pattern[i]\\n                # `existing[new_pattern]` give us the position of j where\\n                # starting from `j` we know we have 1 odd number.\\n\\t\\t\\t\\t# Default to `cur_i` so that when it is missing from the \\n\\t\\t\\t\\t# existing dict, we don\\'t increase res\\n                res = max(res, cur_i - existing.get(tuple(new_pattern), cur_i))\\n\\n            # If we have `pattern` in `existing`, then we know it is also a palindrome starting from existing[pattern]\\n            res = max(res, cur_i - existing.get(tuple(pattern), cur_i))\\n\\n            existing.setdefault(tuple(pattern), cur_i)\\n\\n        return res\\n```\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        res = 0\\n        pattern = 0\\n\\n        existing = {pattern: -1}\\n\\n        for cur_i, char in enumerate(s):\\n            pattern ^= 1 << int(char)\\n\\n            for i in range(10):\\n                new_pattern = pattern ^ (1 << i)\\n                res = max(res, cur_i - existing.get(new_pattern, cur_i))\\n\\n            res = max(res, cur_i - existing.get(pattern, cur_i))\\n\\n            existing.setdefault(pattern, cur_i)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793114,
                "title": "c-simple-sln-using-bitmasks-and-hashmap",
                "content": "```\\nint longestAwesome(string s) {\\n  int curr = 0;\\n  unordered_map<int, int> processed;\\n  processed.reserve(size(s));\\n  int ans = 0;\\n  for (int i = 0; i < size(s); ++i) {\\n    curr ^=  1 << (s[i] - \\'0\\');\\n    for (int j = -1; j < 26; ++j) {\\n      int search_value = j >= 0 ? (1 << j) : 0;\\n      if (curr == search_value) {\\n        ans = i + 1;\\n      }\\n      else {\\n        if (auto it = processed.find(curr ^ search_value); it != cend(processed))\\n          ans = max(ans, i - it->second);\\n      }\\n    }\\n    processed.emplace(curr, i);\\n  }\\n  return ans;\\n}",
                "solutionTags": [],
                "code": "```\\nint longestAwesome(string s) {\\n  int curr = 0;\\n  unordered_map<int, int> processed;\\n  processed.reserve(size(s));\\n  int ans = 0;\\n  for (int i = 0; i < size(s); ++i) {\\n    curr ^=  1 << (s[i] - \\'0\\');\\n    for (int j = -1; j < 26; ++j) {\\n      int search_value = j >= 0 ? (1 << j) : 0;\\n      if (curr == search_value) {\\n        ans = i + 1;\\n      }\\n      else {\\n        if (auto it = processed.find(curr ^ search_value); it != cend(processed))\\n          ans = max(ans, i - it->second);\\n      }\\n    }\\n    processed.emplace(curr, i);\\n  }\\n  return ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 792531,
                "title": "c-bit-manipulation-exclusive-or-solution",
                "content": "Actually, the problem is very simliar to https://leetcode.com/problems/subarray-sum-equals-k/. \\nInstead of compute pre-sum, we compute exculsive or. \\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        if(s.size()<=1){\\n            return s.size();\\n        }\\n        vector<int> a;\\n        for(int i = 0;i<10;i++){\\n            a.push_back(1<<i);\\n        }\\n        vector<int> m(1024,s.size()); \\n        int hash = 0; \\n        int ret = 0;\\n        for(int i = 0;i<s.size();i++) {\\n            int next_hash = hash ^ (1<<(s[i]-\\'0\\'));\\n            if(next_hash == 0) {\\n                ret = i + 1;\\n                hash = next_hash;\\n                continue;\\n            }\\n            for(auto x : a) {\\n                int y = x ^ next_hash; \\n                if(y == 0) {\\n                    ret = i + 1;\\n                    break;\\n                }\\n                ret = max(ret,i-m[y]);\\n                \\n            }\\n            hash = next_hash;\\n            m[hash] = min(m[hash],i);\\n        }\\n        return ret; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        if(s.size()<=1){\\n            return s.size();\\n        }\\n        vector<int> a;\\n        for(int i = 0;i<10;i++){\\n            a.push_back(1<<i);\\n        }\\n        vector<int> m(1024,s.size()); \\n        int hash = 0; \\n        int ret = 0;\\n        for(int i = 0;i<s.size();i++) {\\n            int next_hash = hash ^ (1<<(s[i]-\\'0\\'));\\n            if(next_hash == 0) {\\n                ret = i + 1;\\n                hash = next_hash;\\n                continue;\\n            }\\n            for(auto x : a) {\\n                int y = x ^ next_hash; \\n                if(y == 0) {\\n                    ret = i + 1;\\n                    break;\\n                }\\n                ret = max(ret,i-m[y]);\\n                \\n            }\\n            hash = next_hash;\\n            m[hash] = min(m[hash],i);\\n        }\\n        return ret; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791313,
                "title": "cpp-hashmap-bitmask-clean-commented-solution",
                "content": "\\n\\t\\n\\t\\n\\t  here we used bitmasking \\n\\t  the number 0000000001 represents odd occurence of \\'0\\' and even occurence off all remaining  digits\\n\\t  another example 0110010101 represents  even occrence of \\'9\\',\\'6\\',\\'5\\',\\'3\\',\\'1\\' and odd occrence of the remaining digits\\n\\t  int longestAwesome(string s)\\n\\t    {\\n          int curr=0;\\n          //to store the first occurance of an particular no\\n          unordered_map<int,int>occ;\\n          int max_len=0;\\n          //occ  of 0 is -1 cause maybe there\\'s and array starting with index 0\\n          occ[0]=-1;\\n             for(int i=0;i<s.length();i++)\\n              {      \\n                    //here we toggle the curr state of our number\\n                    curr^=1<<(s[i]-\\'0\\');\\n                   //if this state is encountered for the first time than store it\\'s it\\'s index\\n                    if(occ.find(curr)==occ.end()){\\n                         occ[curr]=i;\\n                     }\\n                   //here we check the case if there\\'s a number with only one bit toggled in our curr\\n                 //this will handle the palindrome with odd length \\n                //here we allow one number with odd occurance\\n               //this loop will do the work\\n                      for(int j=0;j<10;j++)\\n                      {\\n                              int prev=curr^(1<<j);\\n                              if(occ.find(prev)!=occ.end())\\n                                  {\\n                                    max_len=max(max_len,i-occ[prev]);\\n                                  }\\n                          \\n                      }\\n                 //this is to check the palindrome with even length\\n                    max_len=max(max_len,i-occ[curr]);\\n                    \\n             }\\n        return max_len;\\n    }",
                "solutionTags": [],
                "code": "\\n\\t\\n\\t\\n\\t  here we used bitmasking \\n\\t  the number 0000000001 represents odd occurence of \\'0\\' and even occurence off all remaining  digits\\n\\t  another example 0110010101 represents  even occrence of \\'9\\',\\'6\\',\\'5\\',\\'3\\',\\'1\\' and odd occrence of the remaining digits\\n\\t  int longestAwesome(string s)\\n\\t    {\\n          int curr=0;\\n          //to store the first occurance of an particular no\\n          unordered_map<int,int>occ;\\n          int max_len=0;\\n          //occ  of 0 is -1 cause maybe there\\'s and array starting with index 0\\n          occ[0]=-1;\\n             for(int i=0;i<s.length();i++)\\n              {      \\n                    //here we toggle the curr state of our number\\n                    curr^=1<<(s[i]-\\'0\\');\\n                   //if this state is encountered for the first time than store it\\'s it\\'s index\\n                    if(occ.find(curr)==occ.end()){\\n                         occ[curr]=i;\\n                     }\\n                   //here we check the case if there\\'s a number with only one bit toggled in our curr\\n                 //this will handle the palindrome with odd length \\n                //here we allow one number with odd occurance\\n               //this loop will do the work\\n                      for(int j=0;j<10;j++)\\n                      {\\n                              int prev=curr^(1<<j);\\n                              if(occ.find(prev)!=occ.end())\\n                                  {\\n                                    max_len=max(max_len,i-occ[prev]);\\n                                  }\\n                          \\n                      }\\n                 //this is to check the palindrome with even length\\n                    max_len=max(max_len,i-occ[curr]);\\n                    \\n             }\\n        return max_len;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 784749,
                "title": "python-sliding-window-solution-by-compacting-large-input-strings",
                "content": "```python\\nclass Solution(object):\\n    def longestAwesome(self, s):\\n        \\n        def compact_string(tempString):\\n            startPoint = 0\\n\\n            while startPoint < len(tempString):\\n                count = 1\\n                while startPoint+1 < len(tempString) and tempString[startPoint] == tempString[startPoint+1]:\\n                    tempString.pop(startPoint+1)\\n                    count += 1\\n\\n                if count >= 1000:\\n\\n                    startVal = tempString[startPoint]\\n                    for i in range(20):\\n                        tempString.insert(startPoint, startVal + \"1\")\\n                        startPoint += 1\\n                        count -= 1\\n                    while count > 1000:\\n                        tempString.insert(startPoint, startVal + \"1000\")\\n                        startPoint += 1\\n                        count -= 1000\\n                    count -= 20\\n                    if count % 2 != 0:\\n                        tempString[startPoint] = tempString[startPoint] + str(count-1)\\n                        tempString.insert(startPoint+1, tempString[startPoint][0] + str(1))\\n                        startPoint += 1\\n                    else:\\n                        tempString[startPoint] = tempString[startPoint] + str(count)\\n                    for i in range(20):\\n                        tempString.insert(startPoint, startVal + \"1\")\\n                        startPoint += 1\\n                else:\\n                    startVal = tempString[startPoint]\\n                    tempString[startPoint] = startVal + \"1\"\\n                    for i in range(count-1):\\n                        startPoint += 1\\n                        tempString.insert(startPoint, startVal + \"1\")\\n                startPoint += 1\\n            return tempString\\n        \\n        s = compact_string(list(s))\\n        \\n        def is_awesome_db(db):\\n            temp_db = {}\\n            for k, v in db.iteritems():\\n                if k[0] not in temp_db:\\n                    temp_db[k[0]] = 0\\n                temp_db[k[0]] += int(k[1:]) * v\\n            size = sum(temp_db.values())\\n            return len([x for x in temp_db.values() if x % 2 != 0]) < 2, size\\n       \\n        def sliding_window(size):\\n            db = {}\\n            for i in range((len(s)-size)+1):\\n                if len(db) == 0:\\n                    for v in s[i:i+size]:\\n                        if v not in db:\\n                            db[v] = 0\\n                        db[v] += 1\\n                else:\\n                    db[s[i-1]] -= 1\\n                    if s[i+size-1] not in db:\\n                        db[s[i+size-1]] = 0\\n                    db[s[i+size-1]] += 1\\n                    if db[s[i-1]] == 0:\\n                        del db[s[i-1]]\\n                success, string_size = is_awesome_db(db)\\n                if success:\\n                    return string_size\\n            return 0\\n        \\n        for i in range(len(s)):\\n            string_size = sliding_window(len(s)-i)\\n            if string_size > 0:\\n                return string_size\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def longestAwesome(self, s):\\n        \\n        def compact_string(tempString):\\n            startPoint = 0\\n\\n            while startPoint < len(tempString):\\n                count = 1\\n                while startPoint+1 < len(tempString) and tempString[startPoint] == tempString[startPoint+1]:\\n                    tempString.pop(startPoint+1)\\n                    count += 1\\n\\n                if count >= 1000:\\n\\n                    startVal = tempString[startPoint]\\n                    for i in range(20):\\n                        tempString.insert(startPoint, startVal + \"1\")\\n                        startPoint += 1\\n                        count -= 1\\n                    while count > 1000:\\n                        tempString.insert(startPoint, startVal + \"1000\")\\n                        startPoint += 1\\n                        count -= 1000\\n                    count -= 20\\n                    if count % 2 != 0:\\n                        tempString[startPoint] = tempString[startPoint] + str(count-1)\\n                        tempString.insert(startPoint+1, tempString[startPoint][0] + str(1))\\n                        startPoint += 1\\n                    else:\\n                        tempString[startPoint] = tempString[startPoint] + str(count)\\n                    for i in range(20):\\n                        tempString.insert(startPoint, startVal + \"1\")\\n                        startPoint += 1\\n                else:\\n                    startVal = tempString[startPoint]\\n                    tempString[startPoint] = startVal + \"1\"\\n                    for i in range(count-1):\\n                        startPoint += 1\\n                        tempString.insert(startPoint, startVal + \"1\")\\n                startPoint += 1\\n            return tempString\\n        \\n        s = compact_string(list(s))\\n        \\n        def is_awesome_db(db):\\n            temp_db = {}\\n            for k, v in db.iteritems():\\n                if k[0] not in temp_db:\\n                    temp_db[k[0]] = 0\\n                temp_db[k[0]] += int(k[1:]) * v\\n            size = sum(temp_db.values())\\n            return len([x for x in temp_db.values() if x % 2 != 0]) < 2, size\\n       \\n        def sliding_window(size):\\n            db = {}\\n            for i in range((len(s)-size)+1):\\n                if len(db) == 0:\\n                    for v in s[i:i+size]:\\n                        if v not in db:\\n                            db[v] = 0\\n                        db[v] += 1\\n                else:\\n                    db[s[i-1]] -= 1\\n                    if s[i+size-1] not in db:\\n                        db[s[i+size-1]] = 0\\n                    db[s[i+size-1]] += 1\\n                    if db[s[i-1]] == 0:\\n                        del db[s[i-1]]\\n                success, string_size = is_awesome_db(db)\\n                if success:\\n                    return string_size\\n            return 0\\n        \\n        for i in range(len(s)):\\n            string_size = sliding_window(len(s)-i)\\n            if string_size > 0:\\n                return string_size\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782677,
                "title": "java-simple-and-clear-solution-using-bitmap",
                "content": "```\\n\\tpublic int longestAwesome(String s) {\\n\\t\\tMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tmap.put(0, -1);\\n\\t\\tint res = 1;\\n\\t\\tint mask = 0;\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tmask ^= 1 << (s.charAt(i) - \\'0\\');\\n\\t\\t\\tList<Integer> possiblePrefix = generateValidPrefix(mask);\\n\\t\\t\\tfor (int prefix : possiblePrefix) {\\n\\t\\t\\t\\tif (map.containsKey(prefix)) {\\n\\t\\t\\t\\t\\tres = Math.max(res, i - map.get(prefix));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!map.containsKey(mask)) {\\n\\t\\t\\t\\tmap.put(mask, i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n    \\n    private List<Integer> generateValidPrefix(int mask) {\\n        List<Integer> prefixes = new ArrayList<>();\\n        prefixes.add(mask);\\n        for (int i = 0; i < 10; i++) {\\n            prefixes.add(1 << i ^ mask);\\n        }\\n        return prefixes;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int longestAwesome(String s) {\\n\\t\\tMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tmap.put(0, -1);\\n\\t\\tint res = 1;\\n\\t\\tint mask = 0;\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tmask ^= 1 << (s.charAt(i) - \\'0\\');\\n\\t\\t\\tList<Integer> possiblePrefix = generateValidPrefix(mask);\\n\\t\\t\\tfor (int prefix : possiblePrefix) {\\n\\t\\t\\t\\tif (map.containsKey(prefix)) {\\n\\t\\t\\t\\t\\tres = Math.max(res, i - map.get(prefix));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!map.containsKey(mask)) {\\n\\t\\t\\t\\tmap.put(mask, i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n    \\n    private List<Integer> generateValidPrefix(int mask) {\\n        List<Integer> prefixes = new ArrayList<>();\\n        prefixes.add(mask);\\n        for (int i = 0; i < 10; i++) {\\n            prefixes.add(1 << i ^ mask);\\n        }\\n        return prefixes;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781888,
                "title": "python-bitmask",
                "content": "Store in prefix if we have an odd or even number of elements for each numer from 0 to 9, update using xor, then check if have seen a valid state.\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        d = {i: 2**i for i in range(10)}\\n        lookup = {0: -1} \\n        prefix = 0\\n        ans = 0 \\n        for i, num in enumerate(map(int,s)):\\n            prefix ^= d[num]\\n            if prefix not in lookup: lookup[prefix] = i  \\n            k = min([lookup[prefix]]+[lookup[prefix^d[x]] for x in d if prefix^d[x] in lookup])\\n            ans = max(ans, i-k)\\n        return ans \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        d = {i: 2**i for i in range(10)}\\n        lookup = {0: -1} \\n        prefix = 0\\n        ans = 0 \\n        for i, num in enumerate(map(int,s)):\\n            prefix ^= d[num]\\n            if prefix not in lookup: lookup[prefix] = i  \\n            k = min([lookup[prefix]]+[lookup[prefix^d[x]] for x in d if prefix^d[x] in lookup])\\n            ans = max(ans, i-k)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 781730,
                "title": "o-n-1024-11-not-o-10-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        vector<int> m(1024, 200000), n(1024, -1);\\n        int p = 0, r = 0;\\n        m[0] = n[0] = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            p ^= (1 << (s[i] - \\'0\\'));\\n            n[p] = i + 1;\\n            if (m[p] == 200000) m[p] = i + 1;\\n        }\\n        for (int i = 0; i < 1024; ++i) {\\n            for (int j = 0; j < 10; ++j) {\\n                r = max(r, n[i ^ (1 << j)] - m[i]);\\n            }\\n            r = max(r, n[i] - m[i]);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        vector<int> m(1024, 200000), n(1024, -1);\\n        int p = 0, r = 0;\\n        m[0] = n[0] = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            p ^= (1 << (s[i] - \\'0\\'));\\n            n[p] = i + 1;\\n            if (m[p] == 200000) m[p] = i + 1;\\n        }\\n        for (int i = 0; i < 1024; ++i) {\\n            for (int j = 0; j < 10; ++j) {\\n                r = max(r, n[i ^ (1 << j)] - m[i]);\\n            }\\n            r = max(r, n[i] - m[i]);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781706,
                "title": "why-tle-passing-133-153-tcs-can-t-it-be-done-without-bitmasking",
                "content": "```\\nclass Solution {\\n    int max = 1;\\n    Map<String, Integer> memo = new HashMap<>();\\n    public int longestAwesome(String s) {\\n        return choice(new StringBuilder(s), 0, s.length());\\n    }\\n    \\n    private int choice(StringBuilder s, int i, int j) {\\n        if (j - i < max) return j - i;\\n        if (i >= j) return max;\\n        if (memo.containsKey(s.substring(i, j))) {\\n            return Math.max(max, memo.get(s.substring(i, j)));\\n        }\\n        if (isPalindrome(s, i, j)) {\\n            max = Math.max(max, j - i);\\n            return max;\\n        }\\n        int m = choice(s, i + 1, j - 1);\\n        memo.put(s.substring(i + 1, j - 1), m);\\n        int l = choice(s, i, j - 1);\\n        memo.put(s.substring(i, j - 1), l);\\n        int r = choice(s, i + 1, j);\\n        memo.put(s.substring(i + 1, j), r);\\n        return Math.max(m, Math.max(l, r));\\n    }\\n    \\n    Map<String, Boolean> memo2 = new HashMap<>();\\n    private boolean isPalindrome(StringBuilder s, int i, int j) {\\n        String key = i + \"_\" + j + \"_\" + s;\\n        if (memo2.containsKey(key)) return memo2.containsKey(key);\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(int k = i; k < j; k++) {\\n            char c = s.charAt(k);\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        int odd = 0;\\n        for(char c : map.keySet()) {\\n            if (map.get(c) % 2 != 0) odd++;\\n        }\\n        if (odd > 1) {\\n            memo2.put(key, false);\\n            return false;\\n        }\\n        memo2.put(key, true);\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int max = 1;\\n    Map<String, Integer> memo = new HashMap<>();\\n    public int longestAwesome(String s) {\\n        return choice(new StringBuilder(s), 0, s.length());\\n    }\\n    \\n    private int choice(StringBuilder s, int i, int j) {\\n        if (j - i < max) return j - i;\\n        if (i >= j) return max;\\n        if (memo.containsKey(s.substring(i, j))) {\\n            return Math.max(max, memo.get(s.substring(i, j)));\\n        }\\n        if (isPalindrome(s, i, j)) {\\n            max = Math.max(max, j - i);\\n            return max;\\n        }\\n        int m = choice(s, i + 1, j - 1);\\n        memo.put(s.substring(i + 1, j - 1), m);\\n        int l = choice(s, i, j - 1);\\n        memo.put(s.substring(i, j - 1), l);\\n        int r = choice(s, i + 1, j);\\n        memo.put(s.substring(i + 1, j), r);\\n        return Math.max(m, Math.max(l, r));\\n    }\\n    \\n    Map<String, Boolean> memo2 = new HashMap<>();\\n    private boolean isPalindrome(StringBuilder s, int i, int j) {\\n        String key = i + \"_\" + j + \"_\" + s;\\n        if (memo2.containsKey(key)) return memo2.containsKey(key);\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(int k = i; k < j; k++) {\\n            char c = s.charAt(k);\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        int odd = 0;\\n        for(char c : map.keySet()) {\\n            if (map.get(c) % 2 != 0) odd++;\\n        }\\n        if (odd > 1) {\\n            memo2.put(key, false);\\n            return false;\\n        }\\n        memo2.put(key, true);\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780773,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<String,Integer> map = new HashMap<>();\\n        int sum = 0;\\n        int ans = 0;\\n        map.put(\"0\" , -1);\\n        for(int j = 0 ; j < s.length() ; j++){\\n            int t = s.charAt(j) -\\'0\\';\\n            sum ^= (1 << t);\\n            \\n            for(int i = 0 ; i <= 9 ; i++){\\n                int m = sum ^ (1 << i);\\n                if(map.containsKey(String.valueOf(m))){\\n                    ans = Math.max(ans , j - map.get(String.valueOf(m)));\\n                }\\n            }\\n            if(!map.containsKey(sum+\"\")){\\n                map.put(sum+\"\" , j);\\n            }else{\\n                ans = Math.max(ans , j - map.get(String.valueOf(sum)));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<String,Integer> map = new HashMap<>();\\n        int sum = 0;\\n        int ans = 0;\\n        map.put(\"0\" , -1);\\n        for(int j = 0 ; j < s.length() ; j++){\\n            int t = s.charAt(j) -\\'0\\';\\n            sum ^= (1 << t);\\n            \\n            for(int i = 0 ; i <= 9 ; i++){\\n                int m = sum ^ (1 << i);\\n                if(map.containsKey(String.valueOf(m))){\\n                    ans = Math.max(ans , j - map.get(String.valueOf(m)));\\n                }\\n            }\\n            if(!map.containsKey(sum+\"\")){\\n                map.put(sum+\"\" , j);\\n            }else{\\n                ans = Math.max(ans , j - map.get(String.valueOf(sum)));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780419,
                "title": "c-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.length();\\n        unordered_map<int, int> m;\\n        int curr =0;\\n        m[0]=-1;\\n        int res =0;\\n        for(int i =0; i< n; i++){\\n            int sh = s[i]-\\'0\\';\\n            curr  ^= (1<<sh);\\n            for(int j =0; j< 10; j++){\\n                int temp = curr ^ (1<<j);\\n                if(m.count(temp)) res = max(res, i-m[temp]);\\n            }\\n            if(m.count(curr)) res = max(res, i-m[curr]);\\n            else m[curr]=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.length();\\n        unordered_map<int, int> m;\\n        int curr =0;\\n        m[0]=-1;\\n        int res =0;\\n        for(int i =0; i< n; i++){\\n            int sh = s[i]-\\'0\\';\\n            curr  ^= (1<<sh);\\n            for(int j =0; j< 10; j++){\\n                int temp = curr ^ (1<<j);\\n                if(m.count(temp)) res = max(res, i-m[temp]);\\n            }\\n            if(m.count(curr)) res = max(res, i-m[curr]);\\n            else m[curr]=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780336,
                "title": "java-prefix-mask",
                "content": "Ref: https://leetcode.com/problems/find-longest-awesome-substring/discuss/779919/JavaC%2B%2BPython-Prefix-%2B-BitMask\\n```\\n    public int longestAwesome(String s) {\\n        int n = s.length(), res = 0, len = (int) Math.pow(2, 10), mask[] = new int[len + 1], curr = 0;\\n        Arrays.fill(mask, n);\\n        mask[curr] = -1;  // prefix mask init\\n        for (int i = 0; i < n; i++) {\\n            int num = s.charAt(i) - \\'0\\';  // switch, even as 0, odd as 1;\\n            curr ^= 1 << num;\\n            for (int j = 0; j < 10; j++) res = Math.max(res, i - mask[curr ^ (1 << j)]);  // 212\\n            res = Math.max(res, i - mask[curr]); // 22\\n            mask[curr] = Math.min(i, mask[curr]);  // keep the first exists;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int longestAwesome(String s) {\\n        int n = s.length(), res = 0, len = (int) Math.pow(2, 10), mask[] = new int[len + 1], curr = 0;\\n        Arrays.fill(mask, n);\\n        mask[curr] = -1;  // prefix mask init\\n        for (int i = 0; i < n; i++) {\\n            int num = s.charAt(i) - \\'0\\';  // switch, even as 0, odd as 1;\\n            curr ^= 1 << num;\\n            for (int j = 0; j < 10; j++) res = Math.max(res, i - mask[curr ^ (1 << j)]);  // 212\\n            res = Math.max(res, i - mask[curr]); // 22\\n            mask[curr] = Math.min(i, mask[curr]);  // keep the first exists;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780077,
                "title": "java-o-n-one-pass-solution-with-easy-explanation-and-heavily-commented",
                "content": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        /*\\n        Check if the digit with value i(0-9) is present odd or even time in the present calculated number. Suppose x of the digits are present in odd numbers and 10-x are present in even numbers.\\n        If we get a previous calculated number, where the same x digits are present in odd numbers, then we can simply calculate the difference of the indices of the current number and the previous calculated number, in this case we can get a palindrome with all the digits present in even numbers. Now, we need to find such palindromes where one of the digit is present in odd number, rest in even number. To do so, we need to find for any previously calculated number where we have every other digits in the same parity(even/odd), except one.                \\n        */\\n        HashMap<Integer,Integer>hmap=new HashMap<>();\\n        hmap.put(0,-1); // number 0 has count of every digits 0, hence even.\\n        int n=s.length();\\n        /*\\n            sum stores the pesent calculated number after processing at index i.\\n            \\n            for every digit, I used one bit. The bit is set if the digit is found odd times else unset. Digit 0 given the right most bit and digit 9, the 10th bit from right.\\n            \\n            hmap maps the generated number to the index it was found first.\\n            \\n            max stores the maximum length.\\n            \\n            sum starts with 0 and for every digit we encounter, we xor that digits bit with 1, so that the value flips. If previously, it was in odd count, it will not become even count(unset) and vice versa.\\n        */\\n        \\n        int sum=0,z,max=0;\\n        for(int i=0;i<n;i++){\\n            z=s.charAt(i)-\\'0\\'; // the digit at ith place.\\n            sum^=(1<<z);       // the presently generated number.\\n            for(int j=0;j<10;j++) \\n                \\n                if(hmap.containsKey(sum^(1<<j))) // flipping one bit to find any previously generated number, hence finding palindromes with only one digit present odd number of times.\\n                    max=Math.max(max,i-hmap.get(sum^(1<<j)));\\n            \\n            // if same number was generated before, we get a palindrome with all digits appearing even number of times.\\n            if(hmap.containsKey(sum))\\n                    max=Math.max(max,i-hmap.get(sum));\\n            else\\n                hmap.put(sum,i);   // the present index is set only when no such number was found previously. This gives the maximum length of palindrome.\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        /*\\n        Check if the digit with value i(0-9) is present odd or even time in the present calculated number. Suppose x of the digits are present in odd numbers and 10-x are present in even numbers.\\n        If we get a previous calculated number, where the same x digits are present in odd numbers, then we can simply calculate the difference of the indices of the current number and the previous calculated number, in this case we can get a palindrome with all the digits present in even numbers. Now, we need to find such palindromes where one of the digit is present in odd number, rest in even number. To do so, we need to find for any previously calculated number where we have every other digits in the same parity(even/odd), except one.                \\n        */\\n        HashMap<Integer,Integer>hmap=new HashMap<>();\\n        hmap.put(0,-1); // number 0 has count of every digits 0, hence even.\\n        int n=s.length();\\n        /*\\n            sum stores the pesent calculated number after processing at index i.\\n            \\n            for every digit, I used one bit. The bit is set if the digit is found odd times else unset. Digit 0 given the right most bit and digit 9, the 10th bit from right.\\n            \\n            hmap maps the generated number to the index it was found first.\\n            \\n            max stores the maximum length.\\n            \\n            sum starts with 0 and for every digit we encounter, we xor that digits bit with 1, so that the value flips. If previously, it was in odd count, it will not become even count(unset) and vice versa.\\n        */\\n        \\n        int sum=0,z,max=0;\\n        for(int i=0;i<n;i++){\\n            z=s.charAt(i)-\\'0\\'; // the digit at ith place.\\n            sum^=(1<<z);       // the presently generated number.\\n            for(int j=0;j<10;j++) \\n                \\n                if(hmap.containsKey(sum^(1<<j))) // flipping one bit to find any previously generated number, hence finding palindromes with only one digit present odd number of times.\\n                    max=Math.max(max,i-hmap.get(sum^(1<<j)));\\n            \\n            // if same number was generated before, we get a palindrome with all digits appearing even number of times.\\n            if(hmap.containsKey(sum))\\n                    max=Math.max(max,i-hmap.get(sum));\\n            else\\n                hmap.put(sum,i);   // the present index is set only when no such number was found previously. This gives the maximum length of palindrome.\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780062,
                "title": "c-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int counter = 0;\\n        vector<int> state(1<<10, -1);        \\n        state[0] = 0;\\n        int ans = 0;\\n        int cur = 0;\\n        for(int i = 0; i < s.size(); ++i) {\\n            cur ^= 1 << (s[i] - \\'0\\');\\n            if(state[cur] == -1)\\n                state[cur] = i + 1;\\n            ans = max(ans, i - state[cur] + 1);\\n            for(int j = 0; j <= 9; ++j) {\\n                int ns = cur ^ (1 << j);\\n                if(state[ns]>=0)\\n                    ans = max(ans, i - state[ns] + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int counter = 0;\\n        vector<int> state(1<<10, -1);        \\n        state[0] = 0;\\n        int ans = 0;\\n        int cur = 0;\\n        for(int i = 0; i < s.size(); ++i) {\\n            cur ^= 1 << (s[i] - \\'0\\');\\n            if(state[cur] == -1)\\n                state[cur] = i + 1;\\n            ans = max(ans, i - state[cur] + 1);\\n            for(int j = 0; j <= 9; ++j) {\\n                int ns = cur ^ (1 << j);\\n                if(state[ns]>=0)\\n                    ans = max(ans, i - state[ns] + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780060,
                "title": "javascript",
                "content": "```\\nvar longestAwesome = function(s) {\\n  let Z = 0;\\n  for (let d = 0; d < 10; d += 1) Z = Math.max(Z, f(s, d));\\n  return Z;\\n};\\n\\nfunction f(s, d) {\\n  let sn = Array(1024).fill(-1);\\n  sn[0] = 0;\\n  let cur = 0;\\n  let z = 0;\\n  for (let i = 0; i < s.length; i += 1) {\\n    let x = +s[i] - 0;\\n    if (x != d) cur ^= 1 << x;\\n    if (~sn[cur]) z = Math.max(z, i - sn[cur] + 1);\\n    else sn[cur] = i + 1;\\n  }\\n  return z;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestAwesome = function(s) {\\n  let Z = 0;\\n  for (let d = 0; d < 10; d += 1) Z = Math.max(Z, f(s, d));\\n  return Z;\\n};\\n\\nfunction f(s, d) {\\n  let sn = Array(1024).fill(-1);\\n  sn[0] = 0;\\n  let cur = 0;\\n  let z = 0;\\n  for (let i = 0; i < s.length; i += 1) {\\n    let x = +s[i] - 0;\\n    if (x != d) cur ^= 1 << x;\\n    if (~sn[cur]) z = Math.max(z, i - sn[cur] + 1);\\n    else sn[cur] = i + 1;\\n  }\\n  return z;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779990,
                "title": "why-is-this-code-giving-tle",
                "content": "```  \\n class Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n=s.size() ;\\n        int dp[10][n+1] ;\\n               int i ; \\n        for(i=0;i<10;i++)\\n            dp[i][0]=0 ;\\n        map<vector<int>,int> p ;\\n       int x=1 ;\\n        vector<int> v ;\\n \\n        for(i=0;i<10;i++)\\n        {\\n            v.push_back(0) ;\\n        }\\n        p[v]=0 ;\\n        for(i=1;i<=n;i++)\\n        {\\n            int j ;\\n            for(j=0;j<10;j++)\\n                dp[j][i]=dp[j][i-1] ;\\n            dp[(s[i-1]-\\'0\\')][i]=(dp[(s[i-1]-\\'0\\')][i]^1) ;\\n            vector<int> v ;\\n            for(j=0;j<10;j++)\\n                v.push_back(dp[j][i]) ;\\n            if(p.find(v)!=p.end())\\n             x=max(x,i-p[v]) ; \\n            else p[v]=i ;\\n           \\n            for(int k=0;k<10;k++)\\n            {\\n                vector<int> ans=v ;\\n                ans[k]=v[k]^1 ;\\n                if(p.find(ans)!=p.end())\\n                {  \\n                    x=max(x,i-p[ans]) ; } \\n            }\\n          //  cout<<x<<\" \" ;\\n            \\n        }\\n        return x ;\\n        \\n        \\n    }\\n};   ```   \\nThe time complexity seems fine?\\n",
                "solutionTags": [],
                "code": "```  \\n class Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n=s.size() ;\\n        int dp[10][n+1] ;\\n               int i ; \\n        for(i=0;i<10;i++)\\n            dp[i][0]=0 ;\\n        map<vector<int>,int> p ;\\n       int x=1 ;\\n        vector<int> v ;\\n \\n        for(i=0;i<10;i++)\\n        {\\n            v.push_back(0) ;\\n        }\\n        p[v]=0 ;\\n        for(i=1;i<=n;i++)\\n        {\\n            int j ;\\n            for(j=0;j<10;j++)\\n                dp[j][i]=dp[j][i-1] ;\\n            dp[(s[i-1]-\\'0\\')][i]=(dp[(s[i-1]-\\'0\\')][i]^1) ;\\n            vector<int> v ;\\n            for(j=0;j<10;j++)\\n                v.push_back(dp[j][i]) ;\\n            if(p.find(v)!=p.end())\\n             x=max(x,i-p[v]) ; \\n            else p[v]=i ;\\n           \\n            for(int k=0;k<10;k++)\\n            {\\n                vector<int> ans=v ;\\n                ans[k]=v[k]^1 ;\\n                if(p.find(ans)!=p.end())\\n                {  \\n                    x=max(x,i-p[ans]) ; } \\n            }\\n          //  cout<<x<<\" \" ;\\n            \\n        }\\n        return x ;\\n        \\n        \\n    }\\n};   ```",
                "codeTag": "C++"
            },
            {
                "id": 779936,
                "title": "python-o-10-n-bitmask",
                "content": "```\\nclass Solution(object):\\n    def longestAwesome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        dp = collections.defaultdict(int)\\n        dp[0] = -1\\n        \\n        ans = 0\\n        curr = 0\\n        for i,c in enumerate(s):\\n            curr ^= (1 << int(c))\\n            \\n            if not curr:\\n                ans = max(ans,i-dp[curr])\\n            else:\\n                for j in reversed(range(10)):\\n                    if (curr ^ (1 << j)) in dp:\\n                        ans = max(ans,i-dp[(curr ^ (1 << j))])\\n            \\n            if curr not in dp:\\n                dp[curr] = i\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestAwesome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        dp = collections.defaultdict(int)\\n        dp[0] = -1\\n        \\n        ans = 0\\n        curr = 0\\n        for i,c in enumerate(s):\\n            curr ^= (1 << int(c))\\n            \\n            if not curr:\\n                ans = max(ans,i-dp[curr])\\n            else:\\n                for j in reversed(range(10)):\\n                    if (curr ^ (1 << j)) in dp:\\n                        ans = max(ans,i-dp[(curr ^ (1 << j))])\\n            \\n            if curr not in dp:\\n                dp[curr] = i\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779924,
                "title": "c-dp-with-bitmask-o-10-n",
                "content": "Use dp to solve this problem.\\nA substring is awesome if there is at most one digit has the odd number of appearance time.\\nFor each index i, we need to find the smallest index j in which s[j..i] is awesome substring.\\nTo determine the smallest proper index, we need a bitmask array f[0..2^10-1].\\n  - f[status] is the smallest index i if the substring s[0..i] has a bitmask is status.\\n  - status represents in bitmask from (0..9), bit (0,1) for digit j if s[0..i] has the number of appearance time is even or odd.\\n\\nTime: O(10*N)\\nSpace: O(2^10)\\n\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int f[1 << 10]; // this is a bitmask array to store the smallest index.\\n        int digits[10]; // to store the number of appearance for each digit.\\n        memset(f, -1, sizeof(f));\\n        memset(digits, 0, sizeof(digits));\\n        f[0] = 0;\\n        int res = 0;\\n        for (int i = 1; i <= s.length(); i++) {\\n            digits[s[i-1]-\\'0\\'] = (digits[s[i-1]-\\'0\\'] + 1) % 2;\\n            int value = 0;\\n            for (int j = 0; j < 10; j++)\\n                if (digits[j] == 1) value += 1 << j;\\n            if (f[value] > -1) res = max(res, i-f[value]);\\n            for (int j = 0; j < 10; j++) {\\n                if (digits[j] == 0) {\\n                    int newValue = value + (1 << j);\\n                    if (f[newValue] > -1) res = max(res, i-f[newValue]);\\n                } else {\\n                    int newValue = value - (1 << j);\\n                    if (f[newValue] > -1) res = max(res, i-f[newValue]);\\n                }\\n            }\\n            if (f[value] == -1) f[value] = i; // store the smallest index\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int f[1 << 10]; // this is a bitmask array to store the smallest index.\\n        int digits[10]; // to store the number of appearance for each digit.\\n        memset(f, -1, sizeof(f));\\n        memset(digits, 0, sizeof(digits));\\n        f[0] = 0;\\n        int res = 0;\\n        for (int i = 1; i <= s.length(); i++) {\\n            digits[s[i-1]-\\'0\\'] = (digits[s[i-1]-\\'0\\'] + 1) % 2;\\n            int value = 0;\\n            for (int j = 0; j < 10; j++)\\n                if (digits[j] == 1) value += 1 << j;\\n            if (f[value] > -1) res = max(res, i-f[value]);\\n            for (int j = 0; j < 10; j++) {\\n                if (digits[j] == 0) {\\n                    int newValue = value + (1 << j);\\n                    if (f[newValue] > -1) res = max(res, i-f[newValue]);\\n                } else {\\n                    int newValue = value - (1 << j);\\n                    if (f[newValue] > -1) res = max(res, i-f[newValue]);\\n                }\\n            }\\n            if (f[value] == -1) f[value] = i; // store the smallest index\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779923,
                "title": "java-bitmask-prefix-map-o-n",
                "content": "```\\n    public int longestAwesome(String s) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        int res = 0,mask = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            mask = mask ^ ( 1 << (s.charAt(i) - \\'0\\'));\\n            if(!map.containsKey(mask)) map.put(mask, i);\\n            res = Math.max(res, i - map.get(mask));\\n            int temp = mask;\\n            for(int j = 0; j <=9; j++){\\n                temp = mask ^(1 << j);\\n                if(map.containsKey(temp)) res = Math.max(res, i - map.get(temp));\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int longestAwesome(String s) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        int res = 0,mask = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            mask = mask ^ ( 1 << (s.charAt(i) - \\'0\\'));\\n            if(!map.containsKey(mask)) map.put(mask, i);\\n            res = Math.max(res, i - map.get(mask));\\n            int temp = mask;\\n            for(int j = 0; j <=9; j++){\\n                temp = mask ^(1 << j);\\n                if(map.containsKey(temp)) res = Math.max(res, i - map.get(temp));\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779914,
                "title": "tle-the-best-i-could-do",
                "content": "```\\nclass Solution {\\n    \\n    unordered_map<string,int> cache;\\n    \\n    bool isMapPalindrome(unordered_map<char,int>& myMap) {\\n        //one odd or no odd\\n        int oddCount = 0;\\n        \\n        for(auto& m: myMap) {\\n            if(m.second % 2 == 1)\\n                oddCount++;\\n        }\\n        \\n        if(oddCount <= 1)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<char,int> myMap;\\n        \\n        if(cache.find(s) != cache.end())\\n            return cache[s];\\n        \\n        for(auto& ch: s)\\n            myMap[ch]++;\\n        \\n        if(isMapPalindrome(myMap)) {\\n            \\n            cache[s] = s.length();\\n            \\n            return s.length();\\n        }\\n        \\n        string sleft =  s.substr(0, s.size() - 1);\\n        string sright = s.substr(1, s.size() - 1);\\n        string middle = s.substr(1, s.size() - 2);\\n        \\n        \\n        cache[s] = max(max(longestAwesome(sleft), longestAwesome(sright)),longestAwesome(middle));\\n        return cache[s];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    unordered_map<string,int> cache;\\n    \\n    bool isMapPalindrome(unordered_map<char,int>& myMap) {\\n        //one odd or no odd\\n        int oddCount = 0;\\n        \\n        for(auto& m: myMap) {\\n            if(m.second % 2 == 1)\\n                oddCount++;\\n        }\\n        \\n        if(oddCount <= 1)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<char,int> myMap;\\n        \\n        if(cache.find(s) != cache.end())\\n            return cache[s];\\n        \\n        for(auto& ch: s)\\n            myMap[ch]++;\\n        \\n        if(isMapPalindrome(myMap)) {\\n            \\n            cache[s] = s.length();\\n            \\n            return s.length();\\n        }\\n        \\n        string sleft =  s.substr(0, s.size() - 1);\\n        string sright = s.substr(1, s.size() - 1);\\n        string middle = s.substr(1, s.size() - 2);\\n        \\n        \\n        cache[s] = max(max(longestAwesome(sleft), longestAwesome(sright)),longestAwesome(middle));\\n        return cache[s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779895,
                "title": "java-prefix-bitmask-o-11-n",
                "content": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        HashMap<Integer, Integer> map = new HashMap();\\n        int fHash = 0;\\n        int n = s.length();\\n        int res = 0;\\n        map.put(fHash, -1);\\n        for(int i=0; i<n; i++){\\n            int cIndex = s.charAt(i)-\\'0\\';\\n            fHash = fHash^(1<<cIndex);\\n            res = Math.max(i-map.getOrDefault(fHash, i), res);\\n            for(int j=0; j<10; j++){\\n                int posHash = 1<<j;\\n                int prevHash = fHash^posHash;\\n                res = Math.max(i-map.getOrDefault(prevHash, i), res);\\n            }\\n            map.putIfAbsent(fHash, i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        HashMap<Integer, Integer> map = new HashMap();\\n        int fHash = 0;\\n        int n = s.length();\\n        int res = 0;\\n        map.put(fHash, -1);\\n        for(int i=0; i<n; i++){\\n            int cIndex = s.charAt(i)-\\'0\\';\\n            fHash = fHash^(1<<cIndex);\\n            res = Math.max(i-map.getOrDefault(fHash, i), res);\\n            for(int j=0; j<10; j++){\\n                int posHash = 1<<j;\\n                int prevHash = fHash^posHash;\\n                res = Math.max(i-map.getOrDefault(prevHash, i), res);\\n            }\\n            map.putIfAbsent(fHash, i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779891,
                "title": "same-concept-as-longest-subarray-with-given-sum",
                "content": "**Same Concept as longest subarray with given sum**\\n\\n```class Solution:\\n    def getRequired(self, currentCount):\\n        required = []\\n        required.append(\\'\\'.join(list(currentCount)))\\n        for i in range(10):\\n            currentCount[i] = str((int(currentCount[i]) + 1) % 2)\\n            required.append(\\'\\'.join(list(currentCount)))\\n            currentCount[i] = str((int(currentCount[i]) + 1) % 2)\\n        return required\\n            \\n    def longestAwesome(self, s: str) -> int:\\n        currentCount = [\\'0\\' for _ in range(10)]\\n        result = 0\\n        previousMap = { \\'\\'.join(list(currentCount)) : -1}\\n        for index,letter in enumerate(s):\\n            letter = int(letter)\\n            currentCount[letter] = str((int(currentCount[letter])+1) % 2)\\n            searchingFor = self.getRequired(currentCount)\\n            for searching in searchingFor:\\n                if searching in previousMap:\\n                    result = max(result, index - previousMap[searching])\\n            \\n            key = \\'\\'.join(currentCount)\\n            if key not in previousMap:\\n                previousMap[key] = index\\n        \\n        return result",
                "solutionTags": [],
                "code": "class Solution:\\n    def getRequired(self, currentCount):\\n        required = []\\n        required.append(\\'\\'.join(list(currentCount)))\\n        for i in range(10):\\n            currentCount[i] = str((int(currentCount[i]) + 1) % 2)\\n            required.append(\\'\\'.join(list(currentCount)))\\n            currentCount[i] = str((int(currentCount[i]) + 1) % 2)\\n        return required\\n            \\n    def longestAwesome(self, s: str) -> int:\\n        currentCount = [\\'0\\' for _ in range(10)]\\n        result = 0\\n        previousMap = { \\'\\'.join(list(currentCount)) : -1}",
                "codeTag": "Java"
            },
            {
                "id": 2699862,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    int longestAwesome(string s)\\n    {\\n        unordered_map<int,int> map;\\n        \\n        int mask = 0, maxL = 0;\\n        \\n        map[mask] = -1;\\n        \\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            int ch = s[i]-\\'0\\';\\n            \\n            mask = mask ^ (1<<ch);\\n            \\n            if(map.find(mask) != map.end())\\n            {\\n                maxL = max(maxL, i-map[mask]);\\n            }\\n            \\n            for(int x=0; x< 10; ++x)\\n            {\\n                int newMask = mask^(1<<x);\\n                \\n                if(map.find(newMask) != map.end())\\n                {\\n                    maxL = max(maxL, i-map[newMask]);\\n                }\\n            }\\n            \\n            if(map.find(mask) == map.end())\\n            {\\n                map[mask] = i;\\n            }\\n        }\\n        return maxL;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestAwesome(string s)\\n    {\\n        unordered_map<int,int> map;\\n        \\n        int mask = 0, maxL = 0;\\n        \\n        map[mask] = -1;\\n        \\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            int ch = s[i]-\\'0\\';\\n            \\n            mask = mask ^ (1<<ch);\\n            \\n            if(map.find(mask) != map.end())\\n            {\\n                maxL = max(maxL, i-map[mask]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1451029,
                "title": "bitmanipulation",
                "content": "Simply storing whether a digit occurs even or odd times in a map storing 1st occurence of a state so that the substring we get has maximum length\\n\\n```\\nclass Solution {\\n    int mp[1025],n,ans;\\npublic:\\n    \\n    void check(int s,int ind){\\n        // even length palindromes\\n        if(mp[s]!=-1)\\n            ans=max(ans,ind+1-mp[s]);\\n        \\n        // odd length palindromes\\n        for(int i=0;i<10;i++){\\n            int t=s^(1<<i);\\n            if(mp[t]!=-1){\\n                int l=ind-mp[t]+1;\\n                ans=max(ans,l);\\n            }\\n        }\\n    }\\n    \\n    int longestAwesome(string t) {\\n        int i;\\n        n=t.length();\\n        int state=0;\\n        memset(mp,-1,sizeof(mp));\\n        mp[0]=0;\\n        ans=1;\\n        \\n        for(i=0;i<n;i++){\\n            char c=t[i];\\n            state=state^(1<<(c-\\'0\\'));\\n            check(state,i);\\n            if(mp[state]==-1)\\n                mp[state]=i+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int mp[1025],n,ans;\\npublic:\\n    \\n    void check(int s,int ind){\\n        // even length palindromes\\n        if(mp[s]!=-1)\\n            ans=max(ans,ind+1-mp[s]);\\n        \\n        // odd length palindromes\\n        for(int i=0;i<10;i++){\\n            int t=s^(1<<i);\\n            if(mp[t]!=-1){\\n                int l=ind-mp[t]+1;\\n                ans=max(ans,l);\\n            }\\n        }\\n    }\\n    \\n    int longestAwesome(string t) {\\n        int i;\\n        n=t.length();\\n        int state=0;\\n        memset(mp,-1,sizeof(mp));\\n        mp[0]=0;\\n        ans=1;\\n        \\n        for(i=0;i<n;i++){\\n            char c=t[i];\\n            state=state^(1<<(c-\\'0\\'));\\n            check(state,i);\\n            if(mp[state]==-1)\\n                mp[state]=i+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337953,
                "title": "c-5-6-lines-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        vector<int>vis(1024,-2),keys={1,2,4,8,16,32,64,128,256,512};\\n        vis[0]=-1;\\n        int n=s.size(),ans=0,stage=0;\\n        for(int i=0;i<n;i++){\\n            stage=stage^(keys[s[i]-\\'0\\']);\\n            if(vis[stage]!=-2) ans=max(ans,i-vis[stage]); \\n            for(auto j: keys) if(vis[stage^j]!=-2) ans=max(ans,i-vis[stage^j]); \\n            if(vis[stage]==-2)vis[stage]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        vector<int>vis(1024,-2),keys={1,2,4,8,16,32,64,128,256,512};\\n        vis[0]=-1;\\n        int n=s.size(),ans=0,stage=0;\\n        for(int i=0;i<n;i++){\\n            stage=stage^(keys[s[i]-\\'0\\']);\\n            if(vis[stage]!=-2) ans=max(ans,i-vis[stage]); \\n            for(auto j: keys) if(vis[stage^j]!=-2) ans=max(ans,i-vis[stage^j]); \\n            if(vis[stage]==-2)vis[stage]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080538,
                "title": "short-bitmask-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s){\\n        int res = 0;\\n        vector<int> m(1024, s.size() + 7);\\n        m[0] = 0;\\n        for(int i = 0, mask = 0;i < s.size();i++){\\n            mask ^= (1 << (s[i] - \\'0\\'));\\n            m[mask] = min(m[mask], i);\\n            if(__builtin_popcount(mask) <= 1)\\n                res = i + 1;\\n            for(int digit = 0;digit < 10;digit++){\\n                int new_mask = mask ^ (1 << digit);\\n                res = max(res, i - m[new_mask]);\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestAwesome(string s){\\n        int res = 0;\\n        vector<int> m(1024, s.size() + 7);\\n        m[0] = 0;\\n        for(int i = 0, mask = 0;i < s.size();i++){\\n            mask ^= (1 << (s[i] - \\'0\\'));\\n            m[mask] = min(m[mask], i);\\n            if(__builtin_popcount(mask) <= 1)\\n                res = i + 1;\\n            for(int digit = 0;digit < 10;digit++){\\n                int new_mask = mask ^ (1 << digit);\\n                res = max(res, i - m[new_mask]);\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568413,
                "content": [
                    {
                        "username": "kg1910",
                        "content": "can we do Binary search in this problem? any idea?"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Binary search won\\'t work here"
                    },
                    {
                        "username": "dkray",
                        "content": "as I know binary search works only for searching for a specific value in a sorted array, but this is a palindrome task.\\nI tried using radix, but still failing"
                    },
                    {
                        "username": "beerus_25",
                        "content": "Can someone tell me some good resources to learn about bitmasking?\\nI have tried mutliple times but still unable to grasp the concept and how to apply in questions.\\n\\nThanks in advance :)"
                    },
                    {
                        "username": "leaopard_13",
                        "content": "see full playlist "
                    },
                    {
                        "username": "leaopard_13",
                        "content": "pepcoding bit manipulation on you tube"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "[Here](https://leetcode.com/problems/number-of-wonderful-substrings/description/) is exactly the same problem in disguise."
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "For the testcase \"9498331\" How the answer could be 3. \\nI got wrong answer on this testcase. \\nBut if you try it this testcase manually, you can create the longest palindromic substring as \"93139\" or \"93439\" and so on.. like this having the length as 5. How the answer can be 3?."
                    },
                    {
                        "username": "abhavgoel",
                        "content": "the questions asks for substrings ,  which are continuos. i guess you are confusing it with subsequences. the ans would be \"949\", which is continuous so 3 is returned."
                    }
                ]
            },
            {
                "id": 1574184,
                "content": [
                    {
                        "username": "kg1910",
                        "content": "can we do Binary search in this problem? any idea?"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Binary search won\\'t work here"
                    },
                    {
                        "username": "dkray",
                        "content": "as I know binary search works only for searching for a specific value in a sorted array, but this is a palindrome task.\\nI tried using radix, but still failing"
                    },
                    {
                        "username": "beerus_25",
                        "content": "Can someone tell me some good resources to learn about bitmasking?\\nI have tried mutliple times but still unable to grasp the concept and how to apply in questions.\\n\\nThanks in advance :)"
                    },
                    {
                        "username": "leaopard_13",
                        "content": "see full playlist "
                    },
                    {
                        "username": "leaopard_13",
                        "content": "pepcoding bit manipulation on you tube"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "[Here](https://leetcode.com/problems/number-of-wonderful-substrings/description/) is exactly the same problem in disguise."
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "For the testcase \"9498331\" How the answer could be 3. \\nI got wrong answer on this testcase. \\nBut if you try it this testcase manually, you can create the longest palindromic substring as \"93139\" or \"93439\" and so on.. like this having the length as 5. How the answer can be 3?."
                    },
                    {
                        "username": "abhavgoel",
                        "content": "the questions asks for substrings ,  which are continuos. i guess you are confusing it with subsequences. the ans would be \"949\", which is continuous so 3 is returned."
                    }
                ]
            },
            {
                "id": 2034555,
                "content": [
                    {
                        "username": "kg1910",
                        "content": "can we do Binary search in this problem? any idea?"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Binary search won\\'t work here"
                    },
                    {
                        "username": "dkray",
                        "content": "as I know binary search works only for searching for a specific value in a sorted array, but this is a palindrome task.\\nI tried using radix, but still failing"
                    },
                    {
                        "username": "beerus_25",
                        "content": "Can someone tell me some good resources to learn about bitmasking?\\nI have tried mutliple times but still unable to grasp the concept and how to apply in questions.\\n\\nThanks in advance :)"
                    },
                    {
                        "username": "leaopard_13",
                        "content": "see full playlist "
                    },
                    {
                        "username": "leaopard_13",
                        "content": "pepcoding bit manipulation on you tube"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "[Here](https://leetcode.com/problems/number-of-wonderful-substrings/description/) is exactly the same problem in disguise."
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "For the testcase \"9498331\" How the answer could be 3. \\nI got wrong answer on this testcase. \\nBut if you try it this testcase manually, you can create the longest palindromic substring as \"93139\" or \"93439\" and so on.. like this having the length as 5. How the answer can be 3?."
                    },
                    {
                        "username": "abhavgoel",
                        "content": "the questions asks for substrings ,  which are continuos. i guess you are confusing it with subsequences. the ans would be \"949\", which is continuous so 3 is returned."
                    }
                ]
            },
            {
                "id": 1963565,
                "content": [
                    {
                        "username": "kg1910",
                        "content": "can we do Binary search in this problem? any idea?"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Binary search won\\'t work here"
                    },
                    {
                        "username": "dkray",
                        "content": "as I know binary search works only for searching for a specific value in a sorted array, but this is a palindrome task.\\nI tried using radix, but still failing"
                    },
                    {
                        "username": "beerus_25",
                        "content": "Can someone tell me some good resources to learn about bitmasking?\\nI have tried mutliple times but still unable to grasp the concept and how to apply in questions.\\n\\nThanks in advance :)"
                    },
                    {
                        "username": "leaopard_13",
                        "content": "see full playlist "
                    },
                    {
                        "username": "leaopard_13",
                        "content": "pepcoding bit manipulation on you tube"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "[Here](https://leetcode.com/problems/number-of-wonderful-substrings/description/) is exactly the same problem in disguise."
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "For the testcase \"9498331\" How the answer could be 3. \\nI got wrong answer on this testcase. \\nBut if you try it this testcase manually, you can create the longest palindromic substring as \"93139\" or \"93439\" and so on.. like this having the length as 5. How the answer can be 3?."
                    },
                    {
                        "username": "abhavgoel",
                        "content": "the questions asks for substrings ,  which are continuos. i guess you are confusing it with subsequences. the ans would be \"949\", which is continuous so 3 is returned."
                    }
                ]
            }
        ]
    },
    {
        "title": "Fix Product Name Format",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1576626,
                "content": [
                    {
                        "username": "pkuaaron",
                        "content": "\\nselect lcase(trim(product_name)) as product_name, date_format(sale_date,\\'%Y-%m\\') as sale_date\\n, count(*) as total\\nfrom Sales\\ngroup by lcase(trim(product_name)), date_format(sale_date, \\'%Y-%m\\')\\norder by product_name, sale_date\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Make The String Great",
        "question_content": "<p>Given a string <code>s</code> of lower and upper case English letters.</p>\n\n<p>A good string is a string which doesn&#39;t have <strong>two adjacent characters</strong> <code>s[i]</code> and <code>s[i + 1]</code> where:</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt;= s.length - 2</code></li>\n\t<li><code>s[i]</code> is a lower-case letter and <code>s[i + 1]</code> is the same letter but in upper-case or <strong>vice-versa</strong>.</li>\n</ul>\n\n<p>To make the string good, you can choose <strong>two adjacent</strong> characters that make the string bad and remove them. You can keep doing this until the string becomes good.</p>\n\n<p>Return <em>the string</em> after making it good. The answer is guaranteed to be unique under the given constraints.</p>\n\n<p><strong>Notice</strong> that an empty string is also good.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;leEeetcode&quot;\n<strong>Output:</strong> &quot;leetcode&quot;\n<strong>Explanation:</strong> In the first step, either you choose i = 1 or i = 2, both will result &quot;leEeetcode&quot; to be reduced to &quot;leetcode&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abBAcC&quot;\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> We have many possible scenarios, and all lead to the same answer. For example:\n&quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot;\n&quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;s&quot;\n<strong>Output:</strong> &quot;s&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> contains only lower and upper case English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 781009,
                "title": "java-simple-solution-using-stack-explained",
                "content": "**Explanation** -\\nIt should be noted that the difference between the any lowercase and uppercase alphabet is 32. Example - ASCII value of `a is 97` and `A is 65` , 97-65 = 32\\n\\nUsing same trick, we can delete adjacent characters with absolute difference of 32.\\n\\n**`Example`** -\\nIf current character is A and a is at top of stack, we pop a and dont insert A.\\nOtherwise, we insert the current character in stack.\\nCollect result in String at the end.\\n\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stack = new Stack();\\n        for(int i=0;i<s.length();i++){\\n            if(!stack.isEmpty() && Math.abs(stack.peek()-s.charAt(i)) == 32)\\n                stack.pop();\\n            else\\n                stack.push(s.charAt(i));\\n        }\\n        char res[] = new char[stack.size()];\\n        int index = stack.size()-1;\\n        while(!stack.isEmpty()){\\n            res[index--] = stack.pop();\\n        }\\n        return new String(res);\\n    }\\n```\\n\\n`*Feel free to ask questions in comment section, do upvote if you understood the solution*`",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stack = new Stack();\\n        for(int i=0;i<s.length();i++){\\n            if(!stack.isEmpty() && Math.abs(stack.peek()-s.charAt(i)) == 32)\\n                stack.pop();\\n            else\\n                stack.push(s.charAt(i));\\n        }\\n        char res[] = new char[stack.size()];\\n        int index = stack.size()-1;\\n        while(!stack.isEmpty()){\\n            res[index--] = stack.pop();\\n        }\\n        return new String(res);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790806,
                "title": "c-easy-one-pass-o-n-space",
                "content": "\\t\\u2705 PLEASE UPVOTE IF YOU LIKE! \\u2705\\n\\t\\t\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        \\n        string ans;\\n        \\n        for(int i = 0 ; i < s.size() ; i++)\\n        {\\n            ans.push_back(s[i]);\\n            \\n            while(ans.size() && (ans.back()==s[i+1]+32 || ans.back()==s[i+1]-32))\\n            {\\n                ans.pop_back();\\n                i++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Explanation:**\\n\\n                    \\n                    Consider Sample Example 2   s = \"abBAcC\"\\n                    \\n*                     i = 0   ans = a          s[i+1] = b\\n*                     i = 1   ans = ab         s[i+1] = B\\n*                     i = 2   ans = a          s[i+1] = A\\n*                     i = 3   ans = \"\"         s[i+1] = c\\n*                     i = 4   ans = c          s[i+1] = C\\n*                     i = 5   ans = \"\" \\n*                     Finally ans = \"\"                 \\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        \\n        string ans;\\n        \\n        for(int i = 0 ; i < s.size() ; i++)\\n        {\\n            ans.push_back(s[i]);\\n            \\n            while(ans.size() && (ans.back()==s[i+1]+32 || ans.back()==s[i+1]-32))\\n            {\\n                ans.pop_back();\\n                i++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780897,
                "title": "c-brute-force-two-pointers",
                "content": "#### Brute-Force\\nJust do what the problem asks us to do until you can\\'t.\\n\\n```cpp\\nstring makeGood(string s, int sz = 0) {\\n    while (sz != s.size()) {\\n        sz = s.size();\\n        for (int i = 0; i + 1 < s.size(); ++i)\\n            if (abs(s[i] - s[i + 1]) == 32)\\n                s = s.substr(0, i) + s.substr(i + 2);\\n    }\\n    return s;\\n}\\n```\\n\\n**Complexity Analysis**\\n- Time: O(n * n) - in the worst case, we are going through the entire string n times, and also copyting it n times. \\n- Memory: O(n) to create a copy of the string.\\n\\n#### Optimized Solution\\nWe can use the two pointers pattern to construct the resulting string in one pass. `i` indicates the current pointer in the input string, and `p` - the insertion point in the result string. If the current character in the input string \"conflicts\" with the last character of the result string - we decrease `p`. Otherwise, we copy the current character to the input string and increase `p`.\\n\\nNote that we can use the same input string to hold the output - because `p` will never go ahead of `i`. In the end, we return the portion of the string till the insertion point `p`.\\n\\n```cpp\\nstring makeGood(string s, int p = 0) {\\n    for (int i = 0; i < s.size(); ++i) {\\n        if (p > 0 && abs(s[i] - s[p - 1]) == 32)\\n            --p;\\n        else\\n            s[p++] = s[i];\\n    }\\n    return s.substr(0, p);\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n). We are going through the string once.\\n- Memory: O(1), as we reuse the same string.",
                "solutionTags": [],
                "code": "```cpp\\nstring makeGood(string s, int sz = 0) {\\n    while (sz != s.size()) {\\n        sz = s.size();\\n        for (int i = 0; i + 1 < s.size(); ++i)\\n            if (abs(s[i] - s[i + 1]) == 32)\\n                s = s.substr(0, i) + s.substr(i + 2);\\n    }\\n    return s;\\n}\\n```\n```cpp\\nstring makeGood(string s, int p = 0) {\\n    for (int i = 0; i < s.size(); ++i) {\\n        if (p > 0 && abs(s[i] - s[p - 1]) == 32)\\n            --p;\\n        else\\n            s[p++] = s[i];\\n    }\\n    return s.substr(0, p);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780991,
                "title": "clean-python-3-stack-o-n",
                "content": "Just check if next character makes the string bad, if so pop the stack. Otherwise, push to the stack.\\nTime: `O(N)`\\nSpace: `O(N)`\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        result = []\\n        for c in s:\\n            if not result:\\n                result.append(c)\\n            elif result[-1].isupper() and result[-1].lower() == c:\\n                result.pop()\\n            elif result[-1].islower() and result[-1].upper() == c:\\n                result.pop()\\n            else:\\n                result.append(c)\\n        return \\'\\'.join(result)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        result = []\\n        for c in s:\\n            if not result:\\n                result.append(c)\\n            elif result[-1].isupper() and result[-1].lower() == c:\\n                result.pop()\\n            elif result[-1].islower() and result[-1].upper() == c:\\n                result.pop()\\n            else:\\n                result.append(c)\\n        return \\'\\'.join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791276,
                "title": "easy-java-solution-4-lines-of-code-with-explanation-recursive-lines-clean",
                "content": "You guys can add your solutions in the comments it will help other viewers .\\n```\\nclass Solution {\\n\\t public String makeGood(String s) {\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            //Now we check if the either the present or the next character is capital\\n            if (Math.abs(s.charAt(i) - s.charAt(i+1)) == 32) {  \\n                //recursive call for the rest of the string \\n                return makeGood(s.substring(0, i) + s.substring(i+2));\\n            }\\n        }     \\n        return s;\\n    }\\n}\\n```\\n**Upvote please **",
                "solutionTags": [
                    "Java",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\t public String makeGood(String s) {\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            //Now we check if the either the present or the next character is capital\\n            if (Math.abs(s.charAt(i) - s.charAt(i+1)) == 32) {  \\n                //recursive call for the rest of the string \\n                return makeGood(s.substring(0, i) + s.substring(i+2));\\n            }\\n        }     \\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781044,
                "title": "python3-5-line-stack-o-n",
                "content": "push \"good\" & pop \"bad\" \\n\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for c in s: \\n            if stack and abs(ord(stack[-1]) - ord(c)) == 32: stack.pop() #pop \"bad\"\\n            else: stack.append(c) #push \"good\"\\n        return \"\".join(stack)\\n```\\n\\nEdit: Surprisingly, one could use `chr(ord(c) ^ 32)` to convert a letter `c` to its corresponding uppercase/lowercase. Please see this [post](https://leetcode.com/problems/make-the-string-great/discuss/780930/JavaPython-3-Stack-O(n)-code-w-brief-explanation-and-analysis.).\\n\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for c in s: \\n            if stack and ord(stack[-1]) ^ ord(c) == 32: stack.pop() #pop \"bad\"\\n            else: stack.append(c) #push \"good\"\\n        return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for c in s: \\n            if stack and abs(ord(stack[-1]) - ord(c)) == 32: stack.pop() #pop \"bad\"\\n            else: stack.append(c) #push \"good\"\\n        return \"\".join(stack)\\n```\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for c in s: \\n            if stack and ord(stack[-1]) ^ ord(c) == 32: stack.pop() #pop \"bad\"\\n            else: stack.append(c) #push \"good\"\\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706082,
                "title": "easy-3-line-c-100-solution-o-n",
                "content": "\\n```\\nstring makeGood(string s) {\\n        for(int i=0;i<s.size();i++)\\n            if(abs(s[i]-s[i+1])==32)\\n                s.erase(i,2),i=max(-1,i-2);\\n        return s;\\n    }\\n```\\nPlease Upvote if find helpful, suggestions are welcomed :)\\nFind me on https://coderaky.com",
                "solutionTags": [],
                "code": "```\\nstring makeGood(string s) {\\n        for(int i=0;i<s.size();i++)\\n            if(abs(s[i]-s[i+1])==32)\\n                s.erase(i,2),i=max(-1,i-2);\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781271,
                "title": "javascript-clean-o-n-stack-solution",
                "content": "```javascript\\nvar makeGood = function(s) {\\n    const stack = [\\'\\'];\\n    \\n    for(let c of s) {\\n        let top = stack[stack.length-1];\\n        if(top.toLowerCase() === c.toLowerCase() && top !== c) stack.pop()\\n        else stack.push(c);\\n    }\\n    return stack.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar makeGood = function(s) {\\n    const stack = [\\'\\'];\\n    \\n    for(let c of s) {\\n        let top = stack[stack.length-1];\\n        if(top.toLowerCase() === c.toLowerCase() && top !== c) stack.pop()\\n        else stack.push(c);\\n    }\\n    return stack.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780930,
                "title": "java-python-3-stack-o-n-code-w-brief-explanation-and-analysis",
                "content": "credit to **@ras123  @singlemancombat**\\n ^ is logical xor:\\nThe decimal values of lowercase and uppercase English letters differ with each other by 32. Take an example: a -> 97(1100001), A -> 65 (1000001). So we have a ^ 32 = A, A ^ 32 = a.\\n```\\n   1 1 0 0 0 0 1 (97)\\n^  0 1 0 0 0 0 0 (32)\\n   1 0 0 0 0 0 1 (65)\\n```\\n\\n----\\n\\n \\n1. Use `^ 32` to toggle the case of a character;\\n2. Pair the lower and upper cases and cancel them.\\n\\n```java\\n    public String makeGood(String s) {\\n        var dq = new ArrayDeque<Character>();\\n        for (int i = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            if (!dq.isEmpty() && (dq.peekLast() ^ 32) == c) {\\n                dq.pollLast();\\n            }else {\\n                dq.offer(c);\\n            }\\n        }\\n        var ans = new StringBuilder();\\n        for (char c : dq) {\\n            ans.append(c);\\n        }\\n        return ans.toString();\\n    }\\n```\\nOr make it shorter: use StringBuilder as Stack. - credit to **@puru_cat**.\\n```java\\n    public String makeGood(String s) {\\n        var ans = new StringBuilder();\\n        for (int i = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            if (ans.length() > 0 && (ans.charAt(ans.length() - 1) ^ 32) == c) {\\n                ans.deleteCharAt(ans.length() - 1);\\n            }else {\\n                ans.append(c);\\n            }\\n        }\\n        return ans.toString();       \\n    }\\n```\\n```python\\n    def makeGood(self, s: str) -> str:\\n        stk = []\\n        for char in s:\\n            if stk and stk[-1] == chr(ord(char) ^ 32):\\n                stk.pop()\\n            else:\\n                stk.append(char)\\n        return \\'\\'.join(stk)\\n```\\n**Analysis:**\\n\\nTime & space: O(n), where n = s.length().",
                "solutionTags": [],
                "code": "```\\n   1 1 0 0 0 0 1 (97)\\n^  0 1 0 0 0 0 0 (32)\\n   1 0 0 0 0 0 1 (65)\\n```\n```java\\n    public String makeGood(String s) {\\n        var dq = new ArrayDeque<Character>();\\n        for (int i = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            if (!dq.isEmpty() && (dq.peekLast() ^ 32) == c) {\\n                dq.pollLast();\\n            }else {\\n                dq.offer(c);\\n            }\\n        }\\n        var ans = new StringBuilder();\\n        for (char c : dq) {\\n            ans.append(c);\\n        }\\n        return ans.toString();\\n    }\\n```\n```java\\n    public String makeGood(String s) {\\n        var ans = new StringBuilder();\\n        for (int i = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            if (ans.length() > 0 && (ans.charAt(ans.length() - 1) ^ 32) == c) {\\n                ans.deleteCharAt(ans.length() - 1);\\n            }else {\\n                ans.append(c);\\n            }\\n        }\\n        return ans.toString();       \\n    }\\n```\n```python\\n    def makeGood(self, s: str) -> str:\\n        stk = []\\n        for char in s:\\n            if stk and stk[-1] == chr(ord(char) ^ 32):\\n                stk.pop()\\n            else:\\n                stk.append(char)\\n        return \\'\\'.join(stk)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2790965,
                "title": "python-c-java-rust-make-the-string-great-again-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a stack to keep track of adjacent characters in one pass. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n\\n**Comment.** Stack is optimal here but there is also a brute-force apporach, i.e., \"replace till death\".\\n\\n**Python #1.** The naive brute-force aproach.\\n```\\nfrom string import ascii_lowercase as lc, ascii_uppercase as uc\\n\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        \\n        it1 = [lc[i] + uc[i] for i in range(26)]    # make pairs of letters of both\\n        it2 = [uc[i] + lc[i] for i in range(26)]    # types, e.g., aA and Aa\\n        \\n        while True:                                \\n            ss = s\\n            for cc in it1 : s = s.replace(cc, \"\")   # delete pairs of lowercase/uppercase\\n            for cc in it2 : s = s.replace(cc, \"\")   # letters until there is nothing left\\n            if s == ss: break\\n            \\n        return s\\n```\\n\\n**Python #2.** The optimal solution using stack.\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        \\n        ss = []\\n        \\n        for c in s: \\n            if ss and ss[-1] == c.swapcase():    # if the stack is not empty and the last letter on the stack is\\n                ss.pop()                         # a match for the current letter (e.g., \\'a\\' and \\'A\\'), remove both\\n            else: \\n                ss.append(c)                     # continue adding to stack to compare with next letter\\n        \\n        return \"\".join(ss)\\n```\\n\\nThis solution in other languages.\\n<iframe src=\"https://leetcode.com/playground/hn99gFjB/shared\" frameBorder=\"0\" width=\"800\" height=\"380\"></iframe>",
                "solutionTags": [],
                "code": "```\\nfrom string import ascii_lowercase as lc, ascii_uppercase as uc\\n\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        \\n        it1 = [lc[i] + uc[i] for i in range(26)]    # make pairs of letters of both\\n        it2 = [uc[i] + lc[i] for i in range(26)]    # types, e.g., aA and Aa\\n        \\n        while True:                                \\n            ss = s\\n            for cc in it1 : s = s.replace(cc, \"\")   # delete pairs of lowercase/uppercase\\n            for cc in it2 : s = s.replace(cc, \"\")   # letters until there is nothing left\\n            if s == ss: break\\n            \\n        return s\\n```\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        \\n        ss = []\\n        \\n        for c in s: \\n            if ss and ss[-1] == c.swapcase():    # if the stack is not empty and the last letter on the stack is\\n                ss.pop()                         # a match for the current letter (e.g., \\'a\\' and \\'A\\'), remove both\\n            else: \\n                ss.append(c)                     # continue adding to stack to compare with next letter\\n        \\n        return \"\".join(ss)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781446,
                "title": "very-easy-java-recursive-solution",
                "content": "if we find two adjacent characters is upper and lower case of same letter,\\nthen the result will get from the string which after remove these two letters.\\n\\nif we don\\'t find any two letters, means the string is good, just return it.\\n\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        int n = s.length();\\n        \\n        for (int i = 0; i < n - 1; i++) {\\n            if (Math.abs(s.charAt(i) - s.charAt(i+1)) == 32) {\\n                return makeGood(s.substring(0, i) + s.substring(i+2));\\n            }\\n        }\\n        \\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        int n = s.length();\\n        \\n        for (int i = 0; i < n - 1; i++) {\\n            if (Math.abs(s.charAt(i) - s.charAt(i+1)) == 32) {\\n                return makeGood(s.substring(0, i) + s.substring(i+2));\\n            }\\n        }\\n        \\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790782,
                "title": "python3-stack-approach-o-n",
                "content": "The idea is to compare ```s[i]``` and the last item in the stack ```stack[-1]``` to see if these two characters will make the string \"bad\"; if they are, then pop the last character from the stack, if they are not, then append s[i] to the stack.\\n\\nHere is a quick example illustrating the process:\\n\\n>i = 0 ------- stack = [] -------- s = \"**L**abBAcCC\" ------- stack = [L] ======= stack was empty **append**\\ni = 1 ------- stack = [L] ------- s = \"L**a**bBAcCC\" ------- stack = [L,a] ===== **append**\\ni = 2 ------- stack = [L,a] ----- s = \"La**b**BAcCC\" ------- stack = [L,a,b] ==== **append**\\ni = 3 ------- stack = [L,a,b] --- s = \"Lab**B**AcCC\" ------- stack = [L,a] ====== stack[-1]=\\'b\\', s[i]=\\'B\\', **pop**\\ni = 4 ------- stack = [L,a] ----- s = \"LabB**A**cCC\" ------- stack = [L] ======= stack[-1]=\\'a\\', s[i]=\\'A\\', **pop**\\ni = 5 ------- stack = [L] ------- s = \"LabBA**c**CC\" ------- stack = [L,c] ===== **append**\\ni = 6 ------- stack = [L,c] ----- s = \"LabBAc**C**C\" ------- stack = [L] ======= stack[-1]=\\'c\\', s[i]=\\'C\\', **pop**\\ni = 7 ------- stack = [L] ------- s = \"LabBAcC**C**\" ------- stack = [L,C] ===== **append**\\nreturn \"LC\"\\n\\n```python\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for i in range(len(s)):\\n            if stack and stack[-1] == s[i].swapcase():\\n                stack.pop(-1)\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```\\nor\\n```python\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for i in range(len(s)):\\n            if stack and abs(ord(s[i]) - ord(stack[-1])) == 32:\\n                stack.pop(-1)\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```s[i]```\n```stack[-1]```\n```python\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for i in range(len(s)):\\n            if stack and stack[-1] == s[i].swapcase():\\n                stack.pop(-1)\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```\n```python\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for i in range(len(s)):\\n            if stack and abs(ord(s[i]) - ord(stack[-1])) == 32:\\n                stack.pop(-1)\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791072,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/mYiz7HWN/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Kotlin",
                    "Stack"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/mYiz7HWN/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2791604,
                "title": "java-100-faster-solution-two-pointer-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int pt2 = 0;\\n        for(int i = 0; i<s.length(); i++){\\n            if(pt2>0 && Math.abs(sb.charAt(pt2-1) - s.charAt(i)) == 32){\\n                pt2--;\\n                sb.deleteCharAt(pt2);\\n            }\\n            else{\\n                sb.append(s.charAt(i));\\n                pt2++;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n**Upvote Please**",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int pt2 = 0;\\n        for(int i = 0; i<s.length(); i++){\\n            if(pt2>0 && Math.abs(sb.charAt(pt2-1) - s.charAt(i)) == 32){\\n                pt2--;\\n                sb.deleteCharAt(pt2);\\n            }\\n            else{\\n                sb.append(s.charAt(i));\\n                pt2++;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791272,
                "title": "detailed-explanation-of-the-python-solution-99-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        \\n        for i in range(len(s)):\\n            if stack and stack[-1] == s[i].swapcase():\\n                stack.pop()\\n            else:\\n                stack.append(s[i])\\n        \\n        return \\'\\'.join(stack)\\n```\\n**For Detail Explaination Refer this Blog:\\nhttps://www.python-techs.com/2022/11/make-the-string-great.html\\n(Please open this link in new tab)**\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        \\n        for i in range(len(s)):\\n            if stack and stack[-1] == s[i].swapcase():\\n                stack.pop()\\n            else:\\n                stack.append(s[i])\\n        \\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781448,
                "title": "java-1ms-beats-100-using-stringbuilder-and-while-loop",
                "content": "```\\nclass Solution {\\n  public String makeGood(String s) {\\n    \\n    /*\\n    Runtime: 1 ms, faster than 100.00% of Java online submissions for Make The String Great.\\n    Memory Usage: 37.9 MB, less than 100.00% of Java online submissions for Make The String Great.\\n\\tRuntime complexity: O(n)\\n\\tSpace complexity: O(n), since we duplicate the input String in a StringBuilder\\n    */\\n\\n    // edge case\\n    if (s.isEmpty()) {\\n      return s; // an empty String is a good String per problem requirements\\n    }\\n\\n    StringBuilder sb = new StringBuilder(s); // our working space and what we\\'ll return\\n    \\n    int index = 0; // to keep track of where in the StringBuilder we are\\n    \\n    while (index < sb.length() - 1) {\\n      if (Math.abs(sb.charAt(index) - sb.charAt(index + 1)) == 32) { // if lower-upper pair is found\\n        sb.deleteCharAt(index);\\n        sb.deleteCharAt(index);\\n        index = Math.max(index - 1, 0); // thanks to @prdp89 for the tip!\\n      } else {\\n        ++index; // move on to next char\\n      }\\n    }\\n    \\n    return sb.toString();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n  public String makeGood(String s) {\\n    \\n    /*\\n    Runtime: 1 ms, faster than 100.00% of Java online submissions for Make The String Great.\\n    Memory Usage: 37.9 MB, less than 100.00% of Java online submissions for Make The String Great.\\n\\tRuntime complexity: O(n)\\n\\tSpace complexity: O(n), since we duplicate the input String in a StringBuilder\\n    */\\n\\n    // edge case\\n    if (s.isEmpty()) {\\n      return s; // an empty String is a good String per problem requirements\\n    }\\n\\n    StringBuilder sb = new StringBuilder(s); // our working space and what we\\'ll return\\n    \\n    int index = 0; // to keep track of where in the StringBuilder we are\\n    \\n    while (index < sb.length() - 1) {\\n      if (Math.abs(sb.charAt(index) - sb.charAt(index + 1)) == 32) { // if lower-upper pair is found\\n        sb.deleteCharAt(index);\\n        sb.deleteCharAt(index);\\n        index = Math.max(index - 1, 0); // thanks to @prdp89 for the tip!\\n      } else {\\n        ++index; // move on to next char\\n      }\\n    }\\n    \\n    return sb.toString();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781103,
                "title": "c-using-a-stack-o-n-with-detailed-explanations",
                "content": "Put the characters on top of each other on a ```stack```. And remove them off the ```stack``` when the combination with the next neighbor makes a \"xX or Xx\" string. Remembering the [ASCII](http://cs.smu.ca/~porter/csc/ref/ascii.html) table, the small letters and capital letters have an absolute value of \"32\" difference (alternatively use ```int diff = \\'a\\'-\\'A\\'``` which sets diff to 32), thus, we can check whether the current index and neighbor make a \"xX or Xx\" string or not, by checking ```(st.top()==s[i+1]+32) || (st.top()==s[i+1]-32)```. \\nTime: O(n)\\nSpace: O(n)\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> st;\\n        for (int i = 0;i<s.size();i++){\\n            st.push(s[i]);\\n            while (!st.empty() && ((st.top()==s[i+1]+32) || (st.top()==s[i+1]-32))){\\n                st.pop();\\n                i++;\\n            }\\n        }\\n\\t\\tstring ret = \"\";\\n        while(!st.empty()){\\n            ret = st.top() + ret;\\n            st.pop();\\n        }\\n        return ret;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```stack```\n```stack```\n```int diff = \\'a\\'-\\'A\\'```\n```(st.top()==s[i+1]+32) || (st.top()==s[i+1]-32)```",
                "codeTag": "Unknown"
            },
            {
                "id": 781391,
                "title": "python-no-extra-space",
                "content": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        i = 0\\n        while i < len(s)-1:\\n            if s[i] == s[i+1]:\\n                i += 1\\n            elif s[i].lower() == s[i+1] or s[i].upper() == s[i+1]:\\n                s = s[:i] + s[i+2:]\\n                i = 0\\n            else:\\n                i += 1\\n        \\n        return s\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        i = 0\\n        while i < len(s)-1:\\n            if s[i] == s[i+1]:\\n                i += 1\\n            elif s[i].lower() == s[i+1] or s[i].upper() == s[i+1]:\\n                s = s[:i] + s[i+2:]\\n                i = 0\\n            else:\\n                i += 1\\n        \\n        return s\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790958,
                "title": "kotlin-using-stack-kotlin-infix-function",
                "content": "```kt\\nfun makeGood(s: String): String {\\n    return Stack<Char>().apply {\\n        s.forEach { ch ->\\n            if (isNotEmpty() && peek() isNotGoodPair ch) pop()\\n            else push(ch)\\n        }\\n    }.joinToString(\"\")\\n}\\n\\n// in ASCII & UNICODE, the difference between lowercase and uppercase is 32.\\nprivate infix fun Char.isNotGoodPair(ch: Char): Boolean {\\n    return abs(this - ch) == 32\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Stack"
                ],
                "code": "```kt\\nfun makeGood(s: String): String {\\n    return Stack<Char>().apply {\\n        s.forEach { ch ->\\n            if (isNotEmpty() && peek() isNotGoodPair ch) pop()\\n            else push(ch)\\n        }\\n    }.joinToString(\"\")\\n}\\n\\n// in ASCII & UNICODE, the difference between lowercase and uppercase is 32.\\nprivate infix fun Char.isNotGoodPair(ch: Char): Boolean {\\n    return abs(this - ch) == 32\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 965029,
                "title": "simple-c-stack-solution-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n        if(s.length()<2) return s;\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++) {\\n            if(!st.empty() && abs(st.top()-s[i])== (\\'a\\'-\\'A\\')) \\n            {\\n                st.pop();                \\n            }\\n            else \\n            st.push(s[i]);\\n        }\\n        while(!st.empty()) {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n        if(s.length()<2) return s;\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++) {\\n            if(!st.empty() && abs(st.top()-s[i])== (\\'a\\'-\\'A\\')) \\n            {\\n                st.pop();                \\n            }\\n            else \\n            st.push(s[i]);\\n        }\\n        while(!st.empty()) {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804803,
                "title": "python-using-stack-beats-99-o-n",
                "content": "```\\n        stack = []\\n        for char in s: \\n            # upper char\\n            if stack and stack[-1].isupper() and stack[-1].lower() == char:\\n                stack.pop()\\n            # lower char\\n            elif stack and stack[-1].islower() and stack[-1].upper() == char:\\n                stack.pop()\\n            else:\\n                stack.append(char)\\n        return \\'\\'.join(stack)\\n```\\nIf you like this solution please consider giving it a star on my [github](https://github.com/bwiens/leetcode-python). Means a lot to me.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        stack = []\\n        for char in s: \\n            # upper char\\n            if stack and stack[-1].isupper() and stack[-1].lower() == char:\\n                stack.pop()\\n            # lower char\\n            elif stack and stack[-1].islower() and stack[-1].upper() == char:\\n                stack.pop()\\n            else:\\n                stack.append(char)\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780961,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n     \\n      \\n        for(int i=0; i<s.length()-1; i++){       \\n            if((s[i]==s[i+1]+32) || (s[i]==s[i+1]-32))\\n            {  \\n                s.erase(i,2);\\n                i=max(-1,i-2);              \\n            }\\n            if(s.length()==0)\\n                break;    \\n        }\\n       return s; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n     \\n      \\n        for(int i=0; i<s.length()-1; i++){       \\n            if((s[i]==s[i+1]+32) || (s[i]==s[i+1]-32))\\n            {  \\n                s.erase(i,2);\\n                i=max(-1,i-2);              \\n            }\\n            if(s.length()==0)\\n                break;    \\n        }\\n       return s; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790939,
                "title": "javascript-neat-5-methods-regexp-and-officials",
                "content": "## RegExp and recursion\\n```js\\nconst abc = [...\\'abcdefghijklmnopqrstuvwxyz\\']\\n    .map(c => `${c}${c.toUpperCase()}|${c.toUpperCase()}${c}`).join(\\'|\\')\\nconst isBad = new RegExp(`(${abc})`, \\'g\\')\\nconst makeGood = (s) => isBad.test(s) ? makeGood(s.replace(isBad, \\'\\')) : s\\n```\\n\\n## 1st approach: Iteration\\n\\n```js\\nconst isBad = (...ab) => Math.abs(ab.map(x => x.charCodeAt()).reduce((a, b) => a - b)) === 32\\nconst makeGood = (s) => {\\n    for (let i = 0; i < s.length - 1; ++i)\\n        if (isBad(s[i], s[i + 1])) {\\n            s = s.slice(0, i) + s.slice(i + 2)\\n            i = Math.max(-1, i - 2)\\n        }\\n    return s\\n}\\n```\\n\\n## 2nd approach: Recursion\\n\\n```js\\nconst isBad = (s, i) => Math.abs(s.charCodeAt(i) - s.charCodeAt(i + 1)) === 32\\nconst makeGood = (s) => {\\n    for (let i = 0; i < s.length - 1; ++i)\\n        if (isBad(s, i))\\n            return makeGood(s.slice(0, i) + s.slice(i + 2))\\n    return s\\n}\\n```\\n\\n## 3rd approach: Stack\\n```js\\nconst isBad = (a, b) => a !== b && a.toLowerCase() === b.toLowerCase()\\nconst makeGood = (s) => {\\n    let stack = [\\'\\']\\n    for (const x of s)\\n        isBad(x, stack.at(-1)) ? stack.pop() : stack.push(x)\\n    return stack.join(\\'\\')\\n}\\n```\\n\\n## 4th approach: Two pointers, in-place modify\\n```js\\nconst isBad = (a, b) => Math.abs(a.charCodeAt() - b.charCodeAt()) === 32\\nconst makeGood = (s) => {\\n    s = [...s]\\n    let end = 1\\n    for (let i = 1, x; x = s[i]; ++i)\\n        if (end && isBad(x, s[end - 1]))\\n            end--\\n        else\\n            s[end++] = x\\n    return s.slice(0, end).join(\\'\\')\\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst abc = [...\\'abcdefghijklmnopqrstuvwxyz\\']\\n    .map(c => `${c}${c.toUpperCase()}|${c.toUpperCase()}${c}`).join(\\'|\\')\\nconst isBad = new RegExp(`(${abc})`, \\'g\\')\\nconst makeGood = (s) => isBad.test(s) ? makeGood(s.replace(isBad, \\'\\')) : s\\n```\n```js\\nconst isBad = (...ab) => Math.abs(ab.map(x => x.charCodeAt()).reduce((a, b) => a - b)) === 32\\nconst makeGood = (s) => {\\n    for (let i = 0; i < s.length - 1; ++i)\\n        if (isBad(s[i], s[i + 1])) {\\n            s = s.slice(0, i) + s.slice(i + 2)\\n            i = Math.max(-1, i - 2)\\n        }\\n    return s\\n}\\n```\n```js\\nconst isBad = (s, i) => Math.abs(s.charCodeAt(i) - s.charCodeAt(i + 1)) === 32\\nconst makeGood = (s) => {\\n    for (let i = 0; i < s.length - 1; ++i)\\n        if (isBad(s, i))\\n            return makeGood(s.slice(0, i) + s.slice(i + 2))\\n    return s\\n}\\n```\n```js\\nconst isBad = (a, b) => a !== b && a.toLowerCase() === b.toLowerCase()\\nconst makeGood = (s) => {\\n    let stack = [\\'\\']\\n    for (const x of s)\\n        isBad(x, stack.at(-1)) ? stack.pop() : stack.push(x)\\n    return stack.join(\\'\\')\\n}\\n```\n```js\\nconst isBad = (a, b) => Math.abs(a.charCodeAt() - b.charCodeAt()) === 32\\nconst makeGood = (s) => {\\n    s = [...s]\\n    let end = 1\\n    for (let i = 1, x; x = s[i]; ++i)\\n        if (end && isBad(x, s[end - 1]))\\n            end--\\n        else\\n            s[end++] = x\\n    return s.slice(0, end).join(\\'\\')\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2793757,
                "title": "python-o-1-memory",
                "content": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        i = 0\\n        while i < len(s) - 1:\\n            if ord(s[i]) - ord(s[i + 1]) == 32 or ord(s[i]) - ord(s[i + 1]) == -32:\\n                s = s[:i] + s[i + 2:]\\n                if i > 0:\\n                    i -= 1\\n            else:\\n                i += 1\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        i = 0\\n        while i < len(s) - 1:\\n            if ord(s[i]) - ord(s[i + 1]) == 32 or ord(s[i]) - ord(s[i + 1]) == -32:\\n                s = s[:i] + s[i + 2:]\\n                if i > 0:\\n                    i -= 1\\n            else:\\n                i += 1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606587,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nThe problem requires transforming a string into a \"good\" string by removing adjacent characters that violate the given conditions. To determine if a character violates the conditions, we need to compare it with its adjacent character and check if they have opposite cases (lower-case and upper-case) but represent the same letter. We can iterate through the string and continuously remove such adjacent characters until the string becomes \"good.\"\\n\\n\\n# Approach\\n1.\\tInitialize a boolean variable, test, as True, which will act as a flag to indicate whether there are still adjacent characters violating the conditions.\\n2.\\tEnter a while loop that will continue until no more violations are found (test becomes False).\\n3.\\tSet test to False at the beginning of each iteration to assume that there are no violations.\\n4.\\tInitialize a variable i as 0 to iterate through the string.\\n5.\\tEnter a nested while loop that will check adjacent characters at index i and i+1.\\n6.\\tIf the absolute difference between the ASCII values of the characters is exactly 32 (indicating that they are the same letter but with opposite cases), remove these characters from the string and update test to True to indicate that a violation has been found.\\n7.\\tIf no violation is found, increment i by 1 to move to the next pair of characters.\\n8.\\tOnce the inner while loop is exited, return the transformed string.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach depends on the length of the input string s. In the worst case, we might have to iterate through the string multiple times until it becomes \"good.\" Therefore, the time complexity is O(n^2), where n is the length of the string.\\n\\n\\n- Space complexity:\\nThe space complexity of this approach is O(n), where n is the length of the input string s. The space is used to store the modified string during each iteration.\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        test=True\\n        while test:\\n            test=False\\n            i=0\\n            while i<len(s)-1:\\n                if abs(ord(s[i])-ord(s[i+1]))==32:\\n                    s=s[:i]+s[i+2:]\\n                    test=True\\n                else:\\n                    i+=1\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        test=True\\n        while test:\\n            test=False\\n            i=0\\n            while i<len(s)-1:\\n                if abs(ord(s[i])-ord(s[i+1]))==32:\\n                    s=s[:i]+s[i+2:]\\n                    test=True\\n                else:\\n                    i+=1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792347,
                "title": "rust-stack-one-liner-with-comments",
                "content": "# Intuition\\nAny character added can form an unwanted pair with the last character added to the result, so we want to ignore all those pairs.\\n\\n# Approach\\nTreat the result string as a stack. For each character of `s`, check if it forms an unwanted pair with the top of the stack. Add only those characters that do not form unwanted pairs.\\n\\nA one-liner is its own reward. :)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn make_good(s: String) -> String {\\n        s.chars().fold(String::new(), |mut rez, c2| {\\n            match (rez.pop(), c2) {\\n                (None, c2) => c2.to_string(),\\n                (Some(c1), c2) \\n                    if c1 != c2 && c1.to_lowercase().eq(c2.to_lowercase())\\n                    => rez,\\n                (Some(c1), c2) => rez + &c1.to_string() + &c2.to_string(),\\n            }\\n        })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn make_good(s: String) -> String {\\n        s.chars().fold(String::new(), |mut rez, c2| {\\n            match (rez.pop(), c2) {\\n                (None, c2) => c2.to_string(),\\n                (Some(c1), c2) \\n                    if c1 != c2 && c1.to_lowercase().eq(c2.to_lowercase())\\n                    => rez,\\n                (Some(c1), c2) => rez + &c1.to_string() + &c2.to_string(),\\n            }\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2791190,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string str;\\n            int prev=s.size();\\n            int i=0;\\n        for(i=0;i<s.size()-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else str.push_back(s[i]);\\n        }\\n        if(i<s.size()){\\n        str.push_back(s[i]);\\n        }\\n        if(str.size()==prev||str.size()==0){\\n            ans=str;\\n            flag=0;\\n        }\\n        else{\\n            s=str;\\n        }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string str;\\n            int prev=s.size();\\n            int i=0;\\n        for(i=0;i<s.size()-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else str.push_back(s[i]);\\n        }\\n        if(i<s.size()){\\n        str.push_back(s[i]);\\n        }\\n        if(str.size()==prev||str.size()==0){\\n            ans=str;\\n            flag=0;\\n        }\\n        else{\\n            s=str;\\n        }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790953,
                "title": "python-3-code-golf",
                "content": "\\nThe following code is the code before code golf. **(288B)**\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        f = lambda x,y: abs(ord(x)-ord(y)) == 32\\n        for k in s:\\n            if stack and f(stack[-1], k):\\n                stack.pop()\\n            else:\\n                stack += k,\\n        return \"\".join(stack)\\n```\\nAbove code link: **https://leetcode.com/submissions/detail/839040013/**\\n\\nYou can remove **type hinting**, **lambda functions**, and **unnecessary white space**, and shorten variable names. **(212B)**\\n```\\nclass Solution:\\n    def makeGood(self,s):\\n        t=[]\\n        for k in s:\\n            if t and abs(ord(t[-1])-ord(k))==32:\\n                t.pop()\\n            else:\\n                t+=k,\\n        return\"\".join(t)\\n```\\nAbove code link: **https://leetcode.com/submissions/detail/839056824/**\\n\\nBy replacing the **if-else statement** with a **ternary operator**, you can shorten the length of the code, such as tap(4B).\\n```\\nif statement:\\n\\t[on_true]\\nelse:\\n\\t[on_false]\\n\\t\\n->\\n[on_true] if statement else [on_false]\\n```\\n\\n\\nIf the following format is applied, You can shorten the code. **(155B)**\\nBut You must replace **t+=k,** with **(t:=t+[k])** because of Runtime Error.\\n```\\nclass Solution:\\n    def makeGood(self,s):\\n        t=[]\\n        for k in s:t.pop()if t and abs(ord(t[-1])-ord(k))==32else(t:=t+[k])\\n        return\"\".join(t)\\n```\\nAbove code link: **https://leetcode.com/submissions/detail/839086569/**\\n\\nIn Python, you can reduce unnecessary tabs by using semicolons.\\nAnd you can attach the code after the colon.\\nLike this:\\n```\\ndef f():\\n\\ta=1\\n\\tb=2\\n(24B)\\ndef f():a=1;b=2\\n(15B)\\n```\\nHowever, the for statement cannot be attached in code golf using the semicolon above.\\nSo, You need to use a trick: **list comprehension**.\\n```\\nfor k in s:t.pop()if t and abs(ord(t[-1])-ord(k))==32else(t:=t+[k])\\n(67B)\\n[t.pop()if t and abs(ord(t[-1])-ord(k))==32else(t:=t+[k])for k in s]\\n(68B)\\n```\\nAlthough the length has increased by 1B, it is a benefit to be able to attach code with semicolons. **(131B)**\\n```\\nclass Solution:\\n    def makeGood(self,s):t=[];[t.pop()if t and abs(ord(t[-1])-ord(k))==32else(t:=t+[k])for k in s];return\"\".join(t)\\n```\\nAbove code link: **https://leetcode.com/submissions/detail/839070366/**\\n\\nSo far, the code has been using the stack. \\nif the stack is replaced with string, code would further shorten. **(125B)**\\n**But, this method can be risky because time complexity of slicing in str is O(n).**\\n\\n```\\nclass Solution:\\n    def makeGood(self,s):t=\\'\\';[(t:=t[:-1])if t and abs(ord(t[-1])-ord(k))==32else(t:=t+k)for k in s];return t\\n```\\nAbove code link: **https://leetcode.com/submissions/detail/839075113/**\\nIronically, this code is faster than 91%.\\n\\n**Addition**\\n```\\nabs(ord(t[-1])-ord(k))==32 (26B)\\nord(t[-1])^ord(k)==32      (21B)\\n```\\nSo, length of code is **120B**.\\n```\\nclass Solution:\\n    def makeGood(self,s):t=\\'\\';[(t:=t[:-1])if t and ord(t[-1])^ord(k)==32else(t:=t+k)for k in s];return t\\n```\\nAbove code link: **https://leetcode.com/submissions/detail/839094991/**\\n\\nNow, there is very little code to shorten.\\nI will edit the post whenever I have some idea.\\n\\n**Thanks for viewing my Post**\\n**All code lengths were measured in tio.run. https://tio.run/#\\nAll codes received AC.\\nSuggestions of mistakes in my post and how to shorten the code more are always welcome.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        f = lambda x,y: abs(ord(x)-ord(y)) == 32\\n        for k in s:\\n            if stack and f(stack[-1], k):\\n                stack.pop()\\n            else:\\n                stack += k,\\n        return \"\".join(stack)\\n```\n```\\nclass Solution:\\n    def makeGood(self,s):\\n        t=[]\\n        for k in s:\\n            if t and abs(ord(t[-1])-ord(k))==32:\\n                t.pop()\\n            else:\\n                t+=k,\\n        return\"\".join(t)\\n```\n```\\nif statement:\\n\\t[on_true]\\nelse:\\n\\t[on_false]\\n\\t\\n->\\n[on_true] if statement else [on_false]\\n```\n```\\nclass Solution:\\n    def makeGood(self,s):\\n        t=[]\\n        for k in s:t.pop()if t and abs(ord(t[-1])-ord(k))==32else(t:=t+[k])\\n        return\"\".join(t)\\n```\n```\\ndef f():\\n\\ta=1\\n\\tb=2\\n(24B)\\ndef f():a=1;b=2\\n(15B)\\n```\n```\\nfor k in s:t.pop()if t and abs(ord(t[-1])-ord(k))==32else(t:=t+[k])\\n(67B)\\n[t.pop()if t and abs(ord(t[-1])-ord(k))==32else(t:=t+[k])for k in s]\\n(68B)\\n```\n```\\nclass Solution:\\n    def makeGood(self,s):t=[];[t.pop()if t and abs(ord(t[-1])-ord(k))==32else(t:=t+[k])for k in s];return\"\".join(t)\\n```\n```\\nclass Solution:\\n    def makeGood(self,s):t=\\'\\';[(t:=t[:-1])if t and abs(ord(t[-1])-ord(k))==32else(t:=t+k)for k in s];return t\\n```\n```\\nabs(ord(t[-1])-ord(k))==32 (26B)\\nord(t[-1])^ord(k)==32      (21B)\\n```\n```\\nclass Solution:\\n    def makeGood(self,s):t=\\'\\';[(t:=t[:-1])if t and ord(t[-1])^ord(k)==32else(t:=t+k)for k in s];return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790938,
                "title": "javascript-typescript-two-solutions",
                "content": "1. use Upper Case & slice\\n```\\nfunction makeGood(s: string): string {\\n  let i:number = 0;\\n  while (i < s.length - 1) {\\n    if (s[i] !== s[i+1] && (s[i].toUpperCase() === s[i+1] || s[i].toLowerCase() === s[i+1])) {\\n      s = s.slice(0, i) + s.slice(i+2);\\n      i = 0;\\n      continue;\\n    }\\n    i++;\\n  }\\n  return s;\\n};\\n```\\n\\n2. use stack\\n```\\nfunction makeGood(s: string): string {\\n  let stack:Array<string> = [];\\n  \\n  for (let i = 0; i < s.length; i++) {\\n  if (stack) {\\n    if (Math.abs(stack[stack.length - 1]?.charCodeAt(0) - s[i].charCodeAt(0)) === 32) {\\n      stack.pop();  \\n    } \\n} else {\\n      stack.push(s[i]);\\n    }\\n  }\\n  return stack.join(\\'\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction makeGood(s: string): string {\\n  let i:number = 0;\\n  while (i < s.length - 1) {\\n    if (s[i] !== s[i+1] && (s[i].toUpperCase() === s[i+1] || s[i].toLowerCase() === s[i+1])) {\\n      s = s.slice(0, i) + s.slice(i+2);\\n      i = 0;\\n      continue;\\n    }\\n    i++;\\n  }\\n  return s;\\n};\\n```\n```\\nfunction makeGood(s: string): string {\\n  let stack:Array<string> = [];\\n  \\n  for (let i = 0; i < s.length; i++) {\\n  if (stack) {\\n    if (Math.abs(stack[stack.length - 1]?.charCodeAt(0) - s[i].charCodeAt(0)) === 32) {\\n      stack.pop();  \\n    } \\n} else {\\n      stack.push(s[i]);\\n    }\\n  }\\n  return stack.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2790818,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n=s.size();\\n        stack<char> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                if(abs(st.top()-s[i])==32)\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n=s.size();\\n        stack<char> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                if(abs(st.top()-s[i])==32)\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554257,
                "title": "python-96-faster-easy-solution",
                "content": "```\\ndef makeGood(self, s: str) -> str:\\n        i = 0\\n        s = list(s)\\n        while i<len(s)-1:\\n            if s[i].lower() == s[i+1].lower() and ((s[i].isupper() and s[i+1].islower()) or (s[i].islower() and s[i+1].isupper())):\\n                s.pop(i)\\n                s.pop(i)\\n                i -= 1 if i>0 else 0\\n                continue\\n            i +=1\\n        return \"\".join(s)\\n```\\n![image](https://assets.leetcode.com/users/images/08d40d57-cd80-4642-b414-8a86e06a9065_1662738381.1621356.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef makeGood(self, s: str) -> str:\\n        i = 0\\n        s = list(s)\\n        while i<len(s)-1:\\n            if s[i].lower() == s[i+1].lower() and ((s[i].isupper() and s[i+1].islower()) or (s[i].islower() and s[i+1].isupper())):\\n                s.pop(i)\\n                s.pop(i)\\n                i -= 1 if i>0 else 0\\n                continue\\n            i +=1\\n        return \"\".join(s)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 781021,
                "title": "python-one-pass-o-n-commented-solution",
                "content": "Here I have ch as a marker for where along the string we are. We move along the string until we find two consecutive letters that can be reduced. If we do find a spot where two consecutive leters can be reduced, we throw them out of the string and continue testing. We then have to move back one step because it is possible that a new reducable pair formed. \\nFor example, if s = \"abJjBq\", after we remove the Jj, bB is formed, so we move back a step to check for that.\\nThis way only one pass is needed. \\n\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        ch=0 #ch is a marker for where we are along the string\\n        while ch < len(s)-1: #we can stop once we reach the end of the string\\n            if (s[ch].upper()==s[ch+1] and s[ch]==s[ch+1].lower()) or (s[ch].lower()==s[ch+1] and s[ch]==s[ch+1].upper()): #checks if current letter and next letter form a pair we can reduce\\n                s=s[:ch]+s[ch+2:] #takes the reducable pair out of the string\\n                ch=max(0,ch-1) # moves back a step if we just reduced, but also makes sure we dont go negative\\n            else:\\n                ch+=1 #if we dont reduce, simply continue along the string\\n        return s \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        ch=0 #ch is a marker for where we are along the string\\n        while ch < len(s)-1: #we can stop once we reach the end of the string\\n            if (s[ch].upper()==s[ch+1] and s[ch]==s[ch+1].lower()) or (s[ch].lower()==s[ch+1] and s[ch]==s[ch+1].upper()): #checks if current letter and next letter form a pair we can reduce\\n                s=s[:ch]+s[ch+2:] #takes the reducable pair out of the string\\n                ch=max(0,ch-1) # moves back a step if we just reduced, but also makes sure we dont go negative\\n            else:\\n                ch+=1 #if we dont reduce, simply continue along the string\\n        return s \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792914,
                "title": "java-easy-stack-solution-o-n-beats-100",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder stack = new StringBuilder();\\n        int upperLowerCaseDiff = Math.abs(\\'A\\'-\\'a\\');\\n        for (char c: s.toCharArray()){\\n            if (stack.length()==0 || Math.abs(stack.charAt(stack.length()-1) - c)!=upperLowerCaseDiff)stack.append(c);\\n            else {\\n                stack.deleteCharAt(stack.length()-1);\\n            }\\n        }\\n        return stack.toString();\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder stack = new StringBuilder();\\n        int upperLowerCaseDiff = Math.abs(\\'A\\'-\\'a\\');\\n        for (char c: s.toCharArray()){\\n            if (stack.length()==0 || Math.abs(stack.charAt(stack.length()-1) - c)!=upperLowerCaseDiff)stack.append(c);\\n            else {\\n                stack.deleteCharAt(stack.length()-1);\\n            }\\n        }\\n        return stack.toString();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792407,
                "title": "java-easy-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n       Stack<Character> stack=new Stack<>();\\n       for(int i=0;i<s.length();i++){\\n           if(!stack.isEmpty() && Math.abs(stack.peek()-s.charAt(i))==32){\\n               stack.pop();\\n           }\\n           else stack.push(s.charAt(i));\\n       }\\n        char[] charArr=new char[stack.size()];\\n        int lastIndex=stack.size()-1;\\n        \\n        while(!stack.isEmpty()){\\n            charArr[lastIndex--]=stack.pop();\\n        }\\n       return new String(charArr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n       Stack<Character> stack=new Stack<>();\\n       for(int i=0;i<s.length();i++){\\n           if(!stack.isEmpty() && Math.abs(stack.peek()-s.charAt(i))==32){\\n               stack.pop();\\n           }\\n           else stack.push(s.charAt(i));\\n       }\\n        char[] charArr=new char[stack.size()];\\n        int lastIndex=stack.size()-1;\\n        \\n        while(!stack.isEmpty()){\\n            charArr[lastIndex--]=stack.pop();\\n        }\\n       return new String(charArr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791848,
                "title": "100-faster-and-easy-c-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRemove the pair of consecutive characters if one of them is the upercase of the other!!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStack\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack <char> stk; //create stack of characters\\n        stk.push(s[0]); //push the first element\\n        for(int i=1;i<s.length();++i) //start comparing from 2nd character if the string\\n        {\\n            if(stk.empty()|| (stk.top()-s[i] != 32 && s[i]-stk.top() != 32)) stk.push(s[i]); // push the character if the stack is empty or in the pair of consecutive characters one is uppercase of the other\\n            else stk.pop(); // difference of ASCII value of lowercase from its uppercase is 32\\n        }\\n        string ans=\"\";\\n        while(!stk.empty())  // pop the remaining stack\\n        {\\n            ans+=stk.top();\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end()); // reverse the string as stack pops in reverse order\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack <char> stk; //create stack of characters\\n        stk.push(s[0]); //push the first element\\n        for(int i=1;i<s.length();++i) //start comparing from 2nd character if the string\\n        {\\n            if(stk.empty()|| (stk.top()-s[i] != 32 && s[i]-stk.top() != 32)) stk.push(s[i]); // push the character if the stack is empty or in the pair of consecutive characters one is uppercase of the other\\n            else stk.pop(); // difference of ASCII value of lowercase from its uppercase is 32\\n        }\\n        string ans=\"\";\\n        while(!stk.empty())  // pop the remaining stack\\n        {\\n            ans+=stk.top();\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end()); // reverse the string as stack pops in reverse order\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791828,
                "title": "easy-c-solution-using-stack",
                "content": "\"\"\"\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        \\n        int i;\\n        stack<char> st;\\n        char x;\\n        string str=\"\";\\n        for(i=0;i<s.size();++i)\\n        {\\n            if(st.empty())\\n                st.push(s[i]);\\n            else\\n            {\\n                x = st.top();\\n                if(isupper(s[i]))\\n                {\\n                    if(islower(x) && toupper(x)==s[i])\\n                        st.pop();\\n                    else\\n                        st.push(s[i]);\\n                }\\n                if(islower(s[i]))\\n                {\\n                    if(isupper(x) && tolower(x)==s[i])\\n                        st.pop();\\n                    else\\n                        st.push(s[i]);\\n                }\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            x = st.top();\\n            str=str+x;\\n            st.pop();\\n        }\\n        reverse(str.begin(),str.end());\\n        return str;\\n    }\\n};\\n\"\"\"\\nTraverse through the string and push the current character only if the top of stack character and current character satisfy the conditions of a good string else don\\'t push the current character and pop the top element of stack.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        \\n        int i;\\n        stack<char> st;\\n        char x;\\n        string str=\"\";\\n        for(i=0;i<s.size();++i)\\n        {\\n            if(st.empty())\\n                st.push(s[i]);\\n            else\\n            {\\n                x = st.top();\\n                if(isupper(s[i]))\\n                {\\n                    if(islower(x) && toupper(x)==s[i])\\n                        st.pop();\\n                    else\\n                        st.push(s[i]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2791685,
                "title": "best-solution-in-c-o-1-sc",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n\\n***1st Approach : O(1) SC***\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n=s.size(),i=0;\\n        if(n==0 || n==1) \\n            return s;\\n        while(i<n-1){\\n            if(abs(s[i]-s[i+1])==32){  //ASCII diff b/w same characters of opposite case is always 32\\n                s.erase(s.begin()+i);\\n                s.erase(s.begin()+i); //As deleting a character in previous step shifts the next character to the current \\'i\\' index so thats why deleting at same position again to remove 2nd adjacent character\\n                if(i>0)\\n                    i--;\\n                n=s.size();\\n            }\\n            else\\n                i++;\\n        }\\n        return s;\\n    }\\n};\\n```\\n***2nd Approach : O(n) SC(Using Stack)***\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> sta;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(sta.size()==0){\\n                sta.push(s[i]);\\n                continue;\\n            }\\n            int x=sta.top();\\n            if(abs(x-s[i])==32)\\n                sta.pop();\\n            else{\\n                sta.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(sta.size()){\\n            ans+=sta.top();\\n            sta.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n**Happy LeetCoding**\\uD83D\\uDCAF\\n**Please Upvote**\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n=s.size(),i=0;\\n        if(n==0 || n==1) \\n            return s;\\n        while(i<n-1){\\n            if(abs(s[i]-s[i+1])==32){  //ASCII diff b/w same characters of opposite case is always 32\\n                s.erase(s.begin()+i);\\n                s.erase(s.begin()+i); //As deleting a character in previous step shifts the next character to the current \\'i\\' index so thats why deleting at same position again to remove 2nd adjacent character\\n                if(i>0)\\n                    i--;\\n                n=s.size();\\n            }\\n            else\\n                i++;\\n        }\\n        return s;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> sta;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(sta.size()==0){\\n                sta.push(s[i]);\\n                continue;\\n            }\\n            int x=sta.top();\\n            if(abs(x-s[i])==32)\\n                sta.pop();\\n            else{\\n                sta.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(sta.size()){\\n            ans+=sta.top();\\n            sta.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791513,
                "title": "java-100-faster-simplest-and-easiest-soln-using-for-loop-biginner-friendly",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder(s);\\n        int len=sb.length();\\n        for(int i=0;i<sb.length()-1;i++){\\n            char c1=sb.charAt(i);\\n            char c2=sb.charAt(i+1);\\n            if(c1==c2+32 || c1==c2-32){\\n                sb.delete(i,i+2);\\n                i=i==0?i-1:i-2;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder(s);\\n        int len=sb.length();\\n        for(int i=0;i<sb.length()-1;i++){\\n            char c1=sb.charAt(i);\\n            char c2=sb.charAt(i+1);\\n            if(c1==c2+32 || c1==c2-32){\\n                sb.delete(i,i+2);\\n                i=i==0?i-1:i-2;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791168,
                "title": "stack-based-approach-one-pass-c-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse char of string one by one and maintain a ans stack. For every element check if top of stack is lower case or upper case of current element, If yes, then pop it from the stack else pust current element to the stack itself. After traversing all characters we are left with out ans in the stack.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n        stack<char> st;\\n         int diff = \\'a\\'-\\'A\\';   //** diff b/w 2 same char (upper & lower)\\n        for(char c:s){\\n            if(st.size()==0)st.push(c);\\n               \\n            else{\\n               char a = st.top();\\n               if((c+diff==a || a+diff==c))st.pop(); //**if upper lower case combination found\\n               else\\n                 st.push(c);   \\n            }\\n\\n        }\\n\\n        string ans = \"\";\\n        while(st.size()!=0){\\n           ans = st.top()+ans;\\n           st.pop();\\n        }\\n        \\n        return ans;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n        stack<char> st;\\n         int diff = \\'a\\'-\\'A\\';   //** diff b/w 2 same char (upper & lower)\\n        for(char c:s){\\n            if(st.size()==0)st.push(c);\\n               \\n            else{\\n               char a = st.top();\\n               if((c+diff==a || a+diff==c))st.pop(); //**if upper lower case combination found\\n               else\\n                 st.push(c);   \\n            }\\n\\n        }\\n\\n        string ans = \"\";\\n        while(st.size()!=0){\\n           ans = st.top()+ans;\\n           st.pop();\\n        }\\n        \\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2790935,
                "title": "javascript",
                "content": "```\\n    let checkGoodStr = false;\\n    let array = s.split(\"\");\\n    let count = 0;\\n    \\n    while (checkGoodStr === false) {\\n\\t\\n\\t\\t//check if it is single-letter string\\n        if (array.length === 1) checkGoodStr = true;\\n\\t\\t\\n\\t\\t//if not single letter, each time we see uppercase and lowercase next to each other, \\n\\t\\t// we remove the 2 letters, condition set to false, counter + 1, break the loop\\n        for (let i = 0; i < array.length - 1; i++) {\\n            if (Math.abs(array[i].charCodeAt(0) - array[i + 1].charCodeAt(0)) === 32) {\\n                array.splice(i, 2);\\n                checkGoodStr = false;\\n                count++;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// if counter = 0, that means we have are good \\n\\t\\t//otherwise, set the counter to 0 \\n        if (count === 0) {\\n            checkGoodStr = true;\\n        } else {\\n            count = 0;\\n        }\\n    }\\n        \\n    //console.log(array)\\n    return array.join(\"\")",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n    let checkGoodStr = false;\\n    let array = s.split(\"\");\\n    let count = 0;\\n    \\n    while (checkGoodStr === false) {\\n\\t\\n\\t\\t//check if it is single-letter string\\n        if (array.length === 1) checkGoodStr = true;\\n\\t\\t\\n\\t\\t//if not single letter, each time we see uppercase and lowercase next to each other, \\n\\t\\t// we remove the 2 letters, condition set to false, counter + 1, break the loop\\n        for (let i = 0; i < array.length - 1; i++) {\\n            if (Math.abs(array[i].charCodeAt(0) - array[i + 1].charCodeAt(0)) === 32) {\\n                array.splice(i, 2);\\n                checkGoodStr = false;\\n                count++;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// if counter = 0, that means we have are good \\n\\t\\t//otherwise, set the counter to 0 \\n        if (count === 0) {\\n            checkGoodStr = true;\\n        } else {\\n            count = 0;\\n        }\\n    }\\n        \\n    //console.log(array)\\n    return array.join(\"\")",
                "codeTag": "Unknown"
            },
            {
                "id": 2790918,
                "title": "golang-stack",
                "content": "```\\nfunc makeGood(s string) string {\\n    bytes := make([]byte, 0)\\n    for i, _ := range s {\\n        n := len(bytes)\\n        if n > 0 && (bytes[n-1] == s[i] - \\'a\\' + \\'A\\' || bytes[n-1] == s[i] - \\'A\\' + \\'a\\') {\\n            bytes = bytes[:n-1]\\n        } else {\\n            bytes = append(bytes, s[i])\\n        }\\n    }\\n    return string(bytes)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc makeGood(s string) string {\\n    bytes := make([]byte, 0)\\n    for i, _ := range s {\\n        n := len(bytes)\\n        if n > 0 && (bytes[n-1] == s[i] - \\'a\\' + \\'A\\' || bytes[n-1] == s[i] - \\'A\\' + \\'a\\') {\\n            bytes = bytes[:n-1]\\n        } else {\\n            bytes = append(bytes, s[i])\\n        }\\n    }\\n    return string(bytes)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2790887,
                "title": "daily-leetcoding-challenge-november-8-o-n-t-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n=s.length();\\n        //first we will initialize epty string answer or strong\\n        //we will check that is there two adjacent char is in this string or not\\n        string ans=\"\";\\n        stack<int>st;\\n        for(int i=0;i<n;i++){\\n            //if stack is empty we will push element in the stack \\n            if(st.empty()) \\n                st.push(s[i]);\\n            else\\n            //here we are chacking top element of the stack is making string bad or not\\n            //if yes we will ignore currunt element and pop top element of that stack\\n                if(abs(st.top()-s[i])==32)\\n                    st.pop();\\n                else\\n                 //else we will push that element in the stack\\n                    st.push(s[i]);  \\n        }\\n        //push all elemnt int the stack but it will be in reverse order\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n         reverse(ans.begin(),ans.end());\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n=s.length();\\n        //first we will initialize epty string answer or strong\\n        //we will check that is there two adjacent char is in this string or not\\n        string ans=\"\";\\n        stack<int>st;\\n        for(int i=0;i<n;i++){\\n            //if stack is empty we will push element in the stack \\n            if(st.empty()) \\n                st.push(s[i]);\\n            else\\n            //here we are chacking top element of the stack is making string bad or not\\n            //if yes we will ignore currunt element and pop top element of that stack\\n                if(abs(st.top()-s[i])==32)\\n                    st.pop();\\n                else\\n                 //else we will push that element in the stack\\n                    st.push(s[i]);  \\n        }\\n        //push all elemnt int the stack but it will be in reverse order\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n         reverse(ans.begin(),ans.end());\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790762,
                "title": "daily-leetcoding-challenge-november-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/make-the-string-great/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/make-the-string-great/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2616477,
                "title": "java-simple-and-easy-to-understand-solution-using-stack",
                "content": "```\\npublic String makeGood(String s) {\\n        int n = s.length();\\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<n; i++){\\n            if(!stack.empty() && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                  stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.empty()){\\n            sb.append(String.valueOf(stack.pop()));\\n        }\\n        return sb.reverse().toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic String makeGood(String s) {\\n        int n = s.length();\\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<n; i++){\\n            if(!stack.empty() && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                  stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.empty()){\\n            sb.append(String.valueOf(stack.pop()));\\n        }\\n        return sb.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527693,
                "title": "java-5ms-runtime-easy-and-easy-solution",
                "content": "```\\nStringBuilder ss = new StringBuilder(s);\\nfor (int i = 0; i <= ss.length() - 2; i++)\\n\\tif (ss.codePointAt(i)+32 == ss.codePointAt(i + 1) || ss.codePointAt(i)-32 == ss.codePointAt(i + 1)) {\\n\\t\\tss.delete(i, i + 2);\\n\\t\\ti =- 1;\\n\\t}\\nreturn ss.toString();\\n```\\n\\n\\n# **explanation**\\nSee, codepoint gives unique Ascii(Decimal value) code of each character.\\ntry this code\\n\\nSystem.out.println(\"123\".codePointAt(0)); it will give 49 as output code for \"1\"\\n\\nSystem.out.println(\"A\".codePointAt(0))-->65\\nSystem.out.println(\"a\".codePointAt(0))-->97\\n\\n97-65 = 32\\n\\ncharacter-> A a --> if( \"Aa\".codePointAt(0) + 32 == \"Aa\".codePointAt(1) ) then delete both character\\nindex -> 0 1\\n\\nor\\n\\ncharacter-> a A --> if( \"aA\".codePointAt(0) - 32 == \"aA\".codePointAt(1) ) then delete both character\\nindex -> 0 1\\n\\ni=i-1--> when we delete both character we have to tell loop to come 1 index/step before then loop continue\\n\\nbelow is link for ASCII table\\nhttps://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/ASCII-Table-wide.svg/2560px-ASCII-Table-wide.svg.png\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE !**\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nStringBuilder ss = new StringBuilder(s);\\nfor (int i = 0; i <= ss.length() - 2; i++)\\n\\tif (ss.codePointAt(i)+32 == ss.codePointAt(i + 1) || ss.codePointAt(i)-32 == ss.codePointAt(i + 1)) {\\n\\t\\tss.delete(i, i + 2);\\n\\t\\ti =- 1;\\n\\t}\\nreturn ss.toString();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786233,
                "title": "java-easy-without-stringbuilder-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n    Stack <Character> stk = new Stack<>();\\n    for(int i=0;i<s.length();i++){\\n        if(s.charAt(i)>=65 && s.charAt(i)<=90){ //checking if character is uppercase //\\n            \\n            if(!stk.empty() && stk.peek()==Character.toLowerCase(s.charAt(i)) ){  // checking chacter at top of stack if it is lowercase of our current character then we will remove it //\\n                stk.pop();\\n            }else stk.push(s.charAt(i)); // otherwise we will add it to stack //\\n        }else{ // similarly it is for if our char is lower case//\\n            if(!stk.empty() && stk.peek()==Character.toUpperCase(s.charAt(i)) ){ \\n                stk.pop();\\n            }else stk.push(s.charAt(i));\\n        }\\n        \\n    }\\n        String ans =\"\";\\n        while(!stk.empty())ans=stk.pop()+ans;  retrieving our ans from stack//\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n    Stack <Character> stk = new Stack<>();\\n    for(int i=0;i<s.length();i++){\\n        if(s.charAt(i)>=65 && s.charAt(i)<=90){ //checking if character is uppercase //\\n            \\n            if(!stk.empty() && stk.peek()==Character.toLowerCase(s.charAt(i)) ){  // checking chacter at top of stack if it is lowercase of our current character then we will remove it //\\n                stk.pop();\\n            }else stk.push(s.charAt(i)); // otherwise we will add it to stack //\\n        }else{ // similarly it is for if our char is lower case//\\n            if(!stk.empty() && stk.peek()==Character.toUpperCase(s.charAt(i)) ){ \\n                stk.pop();\\n            }else stk.push(s.charAt(i));\\n        }\\n        \\n    }\\n        String ans =\"\";\\n        while(!stk.empty())ans=stk.pop()+ans;  retrieving our ans from stack//\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387662,
                "title": "c-tc-o-n-sc-o-n-stack",
                "content": "# Feel free to post your doubt in comment\\n```\\nstring makeGood(string s) {\\n\\tint n=s.size();\\n\\tstack<char> st;\\n\\tfor( int i=0; i<n; i++ ){\\n\\t\\tchar c = s[i];\\n\\t\\tif( st.empty() ){\\n\\t\\t\\tst.push( c );\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tchar t = st.top();\\n\\t\\tif( (t)==(char)(c-32) || (t)==(char)(c+32)  ){\\n\\t\\t\\tst.pop();\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tst.push( c );\\n\\t}\\n\\tstring ans=\"\";\\n\\twhile( !st.empty() ){\\n\\t\\tans+=st.top();\\n\\t\\tst.pop();\\n\\t}\\n\\treverse( ans.begin(), ans.end() );\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring makeGood(string s) {\\n\\tint n=s.size();\\n\\tstack<char> st;\\n\\tfor( int i=0; i<n; i++ ){\\n\\t\\tchar c = s[i];\\n\\t\\tif( st.empty() ){\\n\\t\\t\\tst.push( c );\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tchar t = st.top();\\n\\t\\tif( (t)==(char)(c-32) || (t)==(char)(c+32)  ){\\n\\t\\t\\tst.pop();\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tst.push( c );\\n\\t}\\n\\tstring ans=\"\";\\n\\twhile( !st.empty() ){\\n\\t\\tans+=st.top();\\n\\t\\tst.pop();\\n\\t}\\n\\treverse( ans.begin(), ans.end() );\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1156310,
                "title": "python-extremely-fast-and-easy-solution",
                "content": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        #Self done\\n        stack = []\\n        for i in s:\\n            if len(stack)==0:\\n                stack.append(i)\\n                continue\\n            if stack[-1]==i.swapcase():\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        return \"\".join(stack)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        #Self done\\n        stack = []\\n        for i in s:\\n            if len(stack)==0:\\n                stack.append(i)\\n                continue\\n            if stack[-1]==i.swapcase():\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        return \"\".join(stack)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1110640,
                "title": "c-easy-solution",
                "content": "\\tif u like plz upvote ->\\n\\t\\t\\tclass Solution {\\n\\t\\t\\t\\tpublic:\\n\\t\\t\\t\\t\\tstring makeGood(string s) {\\n\\t\\t\\t\\t\\t\\tint n=s.size();\\n\\t\\t\\t\\t\\t\\tstring ans=\"\";\\n\\t\\t\\t\\t\\t\\tif(s.size()==0)\\n\\t\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t\\tif(s.size()<2)\\n\\t\\t\\t\\t\\t\\t\\treturn s;\\n\\t\\t\\t\\t\\t\\tfor(int i=0;i<s.size();++i)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(abs(s[i]-s[i+1])==32)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\ts.erase(i,2);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(i==0)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ti-=2;\\n\\t\\t\\t\\t\\t\\t\\t}    \\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn s;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\tpublic:\\n\\t\\t\\t\\t\\tstring makeGood(string s) {\\n\\t\\t\\t\\t\\t\\tint n=s.size();\\n\\t\\t\\t\\t\\t\\tstring ans=\"\";\\n\\t\\t\\t\\t\\t\\tif(s.size()==0)\\n\\t\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t\\tif(s.size()<2)\\n\\t\\t\\t\\t\\t\\t\\treturn s;\\n\\t\\t\\t\\t\\t\\tfor(int i=0;i<s.size();++i)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(abs(s[i]-s[i+1])==32)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\ts.erase(i,2);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(i==0)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ti-=2;\\n\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 781011,
                "title": "java-recursive-solution",
                "content": "``` java\\nclass Solution {\\n    public String makeGood(String s) {\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            char a = s.charAt(i);\\n            char b = s.charAt(i + 1);\\n            if (a != b && Character.toLowerCase(a) == Character.toLowerCase(b)) {\\n                return makeGood(s.substring(0, i) + s.substring(i+2));\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public String makeGood(String s) {\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            char a = s.charAt(i);\\n            char b = s.charAt(i + 1);\\n            if (a != b && Character.toLowerCase(a) == Character.toLowerCase(b)) {\\n                return makeGood(s.substring(0, i) + s.substring(i+2));\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791593,
                "title": "easiest-of-all-0ms-faster-than-100-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n       string k;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            k.push_back(s[i]);\\n            while(k.size()&&(abs(k.back()-s[i+1])==32))\\n            {\\n                k.pop_back();\\n                i++;\\n            }\\n            i++;\\n        }\\n        return k;\\n    }\\n};\\n//Feedback and suggestions are welcomed , Happy coding!!\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n       string k;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            k.push_back(s[i]);\\n            while(k.size()&&(abs(k.back()-s[i+1])==32))\\n            {\\n                k.pop_back();\\n                i++;\\n            }\\n            i++;\\n        }\\n        return k;\\n    }\\n};\\n//Feedback and suggestions are welcomed , Happy coding!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790846,
                "title": "java-simple-solution-with-linkedlist",
                "content": "\\uD83D\\uDC69  If you like this solution, please click UpVote button. If you have any question, feel free write as a comment. Thanks. \\uD83D\\uDE0A\\n\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        char[] chArr = s.toCharArray(); String str=\"\";\\n        LinkedList<Character> linkedList = new LinkedList<>();\\n        for(int i = 0; i < chArr.length; i++){\\n            if(!linkedList.isEmpty() && Math.abs(linkedList.getLast() - chArr[i]) == \\'a\\' - \\'A\\'){\\n                linkedList.removeLast(); continue;\\n            }\\n            if(i + 1 != chArr.length && Math.abs(chArr[i + 1] - chArr[i]) == \\'a\\' - \\'A\\') i++;\\n            else linkedList.add(chArr[i]);\\n        }\\n        while(!linkedList.isEmpty()){\\n            str+=(linkedList.removeFirst());\\n        }\\n        return str;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public String makeGood(String s) {\\n        char[] chArr = s.toCharArray(); String str=\"\";\\n        LinkedList<Character> linkedList = new LinkedList<>();\\n        for(int i = 0; i < chArr.length; i++){\\n            if(!linkedList.isEmpty() && Math.abs(linkedList.getLast() - chArr[i]) == \\'a\\' - \\'A\\'){\\n                linkedList.removeLast(); continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1981476,
                "title": "javascript-solution-without-stack-runtime-90-memory-73",
                "content": "Just make step back after hitting the main case.\\n```\\nvar makeGood = function(s) {\\n    s = s.split(\\'\\');\\n    let i = 0;\\n    while (i < s.length - 1) {\\n        if (s[i] && s[i + 1] && s[i].toLowerCase() === s[i + 1].toLowerCase() && s[i] !== s[i + 1]) { // main check: two adjacent chars, one lowerCase another upperCase\\n            s.splice(i, 2); // remove those two chars\\n            i--; // go one step back to start checking if the main case check is relevant for previous char and chars next to removed chars\\n\\t\\t\\tcontinue;\\n        }\\n        i++;\\n    }\\n    \\n    return s.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar makeGood = function(s) {\\n    s = s.split(\\'\\');\\n    let i = 0;\\n    while (i < s.length - 1) {\\n        if (s[i] && s[i + 1] && s[i].toLowerCase() === s[i + 1].toLowerCase() && s[i] !== s[i + 1]) { // main check: two adjacent chars, one lowerCase another upperCase\\n            s.splice(i, 2); // remove those two chars\\n            i--; // go one step back to start checking if the main case check is relevant for previous char and chars next to removed chars\\n\\t\\t\\tcontinue;\\n        }\\n        i++;\\n    }\\n    \\n    return s.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1281860,
                "title": "brute-force-100-fast",
                "content": "```class Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> st;\\n        st.push(s[0]);\\n        for(int i=1;i<s.length();i++){\\n            if(!st.empty()&&(st.top()>=\\'a\\'&&st.top()<=\\'z\\')&&(st.top()-\\'a\\')!=(s[i]-\\'A\\')){\\n                st.push(s[i]);\\n            }\\n            else if(!st.empty()&&(st.top()>=\\'A\\'&&st.top()<=\\'Z\\')&&(st.top()-\\'A\\')!=(s[i]-\\'a\\')){\\n                st.push(s[i]);\\n            }\\n            else if(!st.empty()&&(st.top()>=\\'a\\'&&st.top()<=\\'z\\')&&(st.top()-\\'a\\')==(s[i]-\\'A\\')){\\n                st.pop();\\n            }\\n            else if(!st.empty()&&(st.top()>=\\'A\\'&&st.top()<=\\'Z\\')&&(st.top()-\\'A\\')==(s[i]-\\'a\\')){\\n                st.pop();\\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n        string res;\\n        int n=st.size();\\n        if(n==0) return \"\";\\n        for(int i=0;i<n;i++){\\n            res.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> st;\\n        st.push(s[0]);\\n        for(int i=1;i<s.length();i++){\\n            if(!st.empty()&&(st.top()>=\\'a\\'&&st.top()<=\\'z\\')&&(st.top()-\\'a\\')!=(s[i]-\\'A\\')){\\n                st.push(s[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1271399,
                "title": "easy-to-understand-c-solution-using-stack",
                "content": "**You can also approach this problem with C++STL, without using stack.**\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack<char>stk;\\n        string ans;\\n        for(char i:s)\\n        {\\n            if(!stk.empty() && (i + 32 == stk.top() || i-32 == stk.top()))\\n            {\\n                stk.pop();\\n            }\\n            else\\n            {\\n                stk.push(i);\\n            }\\n        }\\n        \\n        while(!stk.empty())\\n        {\\n            ans = stk.top()+ans;\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t able to understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack<char>stk;\\n        string ans;\\n        for(char i:s)\\n        {\\n            if(!stk.empty() && (i + 32 == stk.top() || i-32 == stk.top()))\\n            {\\n                stk.pop();\\n            }\\n            else\\n            {\\n                stk.push(i);\\n            }\\n        }\\n        \\n        while(!stk.empty())\\n        {\\n            ans = stk.top()+ans;\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243178,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn make_good(s: String) -> String {\\n        let diff_cases =\\n            |c1: char, c2: char| c1.to_ascii_lowercase() == c2.to_ascii_lowercase() && c1 != c2;\\n        s.chars()\\n            .into_iter()\\n            .fold(Vec::with_capacity(s.len()), |mut v: Vec<char>, c| {\\n                match v.last() {\\n                    Some(prev_c) if diff_cases(c, *prev_c) => {\\n                        v.pop();\\n                    }\\n                    _ => v.push(c),\\n                }\\n                v\\n            })\\n            .iter()\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn make_good(s: String) -> String {\\n        let diff_cases =\\n            |c1: char, c2: char| c1.to_ascii_lowercase() == c2.to_ascii_lowercase() && c1 != c2;\\n        s.chars()\\n            .into_iter()\\n            .fold(Vec::with_capacity(s.len()), |mut v: Vec<char>, c| {\\n                match v.last() {\\n                    Some(prev_c) if diff_cases(c, *prev_c) => {\\n                        v.pop();\\n                    }\\n                    _ => v.push(c),\\n                }\\n                v\\n            })\\n            .iter()\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 929909,
                "title": "c-5-solutions-compared-and-explained-100-time-80-space",
                "content": "This is a relatively easy problem; so let\\'s solve it in more than one way :)\\n\\n##  Mk I - marking pairs\\n\\nFirst we declare a few support variables:\\n* our string `res`, that will store the result;\\n* `mustCheck`, a boolean set to `true`  that will take note of changes was we go;\\n* `len` an int storing the size of the input string `s`, reduced by `- 1`.\\n\\nWe are then going to loop as long as `mustCheck == true`; inside the loop, we will:\\n* set `mustCheck` to `false`;\\n* run a for loop with `i` going from `0` to `len` and inside it:\\n\\t* set `j` to be initially `i + 1`, then in case it points to a marked character, move it right until you find another non-marked character;\\n\\t* check for a match, that you can easily do with `abs(s[i] - s[j]) == 32)`, since all lowercase characters are `32` positions away from their uppercase counterparts; when a match is found:\\n\\t\\t* mark both characters as `\\' \\'`;\\n\\t\\t* move `i` to `j`\\'s position, so that the next iteration of the for loop will put it to `j + 1`;\\n\\t\\t* set `mustCheck` again to `true`, since each new pair found will imply we need to scan again.\\n\\nOnce we have run a full loop without new changes, we can run one last time through `s`, collect all the characters not marked and push them into `res`, before returning it :)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res;\\n        bool mustCheck = true;\\n        int len = s.size() - 1;\\n        // loop to removes pairs\\n        while (mustCheck) {\\n            mustCheck = false;\\n            for (int i = 0, j; i < len; i++) {\\n                // skipping already marked characters\\n                if (s[i] == \\' \\') continue;\\n                j = i + 1;\\n                // moving j to the next non marked character\\n                while (j <= len && s[j] == \\' \\') j++;\\n                // checking for a match of upper-+lowercase\\n                if (abs(s[i] - s[j]) == 32) {\\n                    s[i] = \\' \\';\\n                    s[j] = \\' \\';\\n                    i = j -1;\\n                    mustCheck = true;\\n                }\\n            }\\n        }\\n        // extracting all \"surviving\" characters\\n        for (char c: s) if (c != \\' \\') res.push_back(c);\\n        return res;\\n    }\\n};\\n```\\n\\n## Mk II - marking pairs, improved\\n\\nSimilar to the above, but now when we find a match, we will also \"expand\" to the characters immediately before and after said match, to avoid finding them later with more expensive new iterations.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res;\\n        bool mustCheck = true;\\n        int len = s.size() - 1;\\n        // loop to removes pairs\\n        while (mustCheck) {\\n            mustCheck = false;\\n            for (int i = 0, j; i < len; i++) {\\n                // skipping already marked characters\\n                if (s[i] == \\' \\') continue;\\n                j = i + 1;\\n                // moving j to the next non marked character\\n                while (j <= len && s[j] == \\' \\') j++;\\n                // checking for a match of upper-+lowercase\\n                while (i >= 0 && j <= len && abs(s[i] - s[j]) == 32) {\\n                    s[i] = \\' \\';\\n                    s[j] = \\' \\';\\n                    // checking for more adjacent matches\\n                    i--, j++;\\n                    mustCheck = true;\\n                }\\n                if (mustCheck) i = j;\\n            }\\n        }\\n        // extracting all \"surviving\" characters\\n        for (char c: s) if (c != \\' \\') res.push_back(c);\\n        return res;\\n    }\\n};\\n```\\n\\n## Mk III - using substr\\n\\nBoring one, this one will also probably use more memory to deal with our substrings as we go.\\n\\nWe will create 2 support variables:\\n* `res` will store our polished string, initialised to be `s`;\\n* `len` will store the (constantly updated) length of the string.\\n\\nNotice that we do not need to use a boolean now - our main loop is turned into a `do... while` and it will check the if at the end of each iteration `res` is different from `s`, which means changes were made and maybe more are needed.\\n\\nInitially I put the condition as `res != s`, but then I realised that `len != s.size()` is just terribly more efficient: comparing a lot of characters one by one vs. comparing a couple of integers if a big win for larger strings!\\n\\nInside the loop, we will proceed similarly to the first method, having a `for` loop go through all the characters (starting from position `1` for convenience) up to `len`; once we find a match, we:\\n* update `res`, cutting the `2` matching characters from it;\\n* update `len` to be smaller by `2`;\\n* shift back `i` by one position, so that it will basically stay at the same place when the loop increments it, to check the new character on that position and potentially save us some loops.\\n\\nOnce we are done and no more changes can be done, we return `res` :)\\n\\nThis approach is significantly less efficient in both time and space than the previous two.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res = s;\\n        int len = s.size();\\n        // loop to removes pairs\\n        do {\\n            s = res;\\n            for (int i = 1; i < len; i++) {\\n                // cutting out matching pairs of characters\\n                if (abs(res[i - 1] - res[i]) == 32) {\\n                    // removing the chars from res\\n                    res = res.substr(0, i - 1) + res.substr(i + 1);\\n                    // updating len to the new value\\n                    len -= 2;\\n                    // moving back i to check the new character in the same position\\n                    i--;\\n                }\\n            }\\n        } while (len != s.size());\\n        return res;\\n    }\\n};\\n```\\n\\n## Mk IV - using substr, improved\\n\\nBasically a combination of version 3 with the logic of the expanding check from version 2, for the added advantage of doing only one string replacement for potentially multiple matching characters.\\n\\nSimilarly to the other `substr` method, this is still slower and more memory gulping than my first 2 versions.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res = s;\\n        int len = s.size();\\n        // loop to removes pairs\\n        do {\\n            s = res;\\n            for (int j = 1, i; j < len; j++) {\\n                i = j - 1;\\n                // cutting out matching pairs of characters\\n                while (i >= 0 && j < len && abs(res[i] - res[j]) == 32) {\\n                    // updating len to the new value\\n                    len -= 2;\\n                    // moving back i to check the new character in the same position\\n                    i--, j++;\\n                }\\n                // removing the matched chars from res\\n                res = res.substr(0, i + 1) + res.substr(j);\\n            }\\n        } while (len != s.size());\\n        return res;\\n    }\\n};\\n```\\n\\n## Mk V - using a stack (which is actually a cheaper array)\\n\\nSimilarly to the valid parentheses-family of problems, we store in a \"stack\" each character, unless it is a match (uppercase/lowercase pair), in which case we pop the last element and move on.\\n\\nThe logic is pretty simple, starting with a few variables:\\n* `res` is our initially empty response string;\\n* `st` is going to be our stack (we do not care if it is `char` or `int`, since they work the same for us) - set to be of length equal to `s.size()`, in case we get an input string without a single match;\\n* `pos` will tell us where to put our next element in the \"stack\", initialised to `0` (first element).\\n\\nLooping each character `c` from `s`, we will do 2 simple actions:\\n* if the \"stack\" is empty (`pos == 0`) or the character on top of it and the currently parsed one do not match (`abs(st[pos - 1] - c) != 32`), then we add `c` to the stack (`st[pos++] = c`);\\n* otherwise we just pop from the stack (`pos--`).\\n\\nNotice that on top of being much more efficient than a normal stack (at possibly the cost of a bit more memory in some cases), this approach also makes easier to extract data from it, since we can just now resize `res` to be `pos` long and write with a normal `for` loops all the characters in it, without having to cause multiple reallocations and/or reverse the string later as you would have to if you composed `res` popping one element at a time from the top of a stack.\\n\\nIf you really wanted to keep things even cheaper, you might have saved declaring `res` and just resized and over-written `s`.\\n\\nIn any case, once you are done you can just return your result string :)\\n\\nThis version seems to be the winner in speed and consumes as much memory as the first one.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res;\\n        int st[s.size()], pos = 0;\\n        // loop to removes pairs\\n        for (char c: s) {\\n            // adding a char to the stack if the stack is empty\\n            // or the top does not match the char\\n            if (!pos || abs(st[pos - 1] - c) != 32) st[pos++] = c;\\n            else pos--;\\n        }\\n        // moving the char out of the stack into res\\n        if (pos) res.resize(pos);\\n        for (int i = 0; i < pos; i++) res[i] = st[i];\\n        return res;\\n    }\\n};\\n```\\n\\nI planned on converting some solution to recursive, but then I got too bored with the same problem to continue eviscerating it :D",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res;\\n        bool mustCheck = true;\\n        int len = s.size() - 1;\\n        // loop to removes pairs\\n        while (mustCheck) {\\n            mustCheck = false;\\n            for (int i = 0, j; i < len; i++) {\\n                // skipping already marked characters\\n                if (s[i] == \\' \\') continue;\\n                j = i + 1;\\n                // moving j to the next non marked character\\n                while (j <= len && s[j] == \\' \\') j++;\\n                // checking for a match of upper-+lowercase\\n                if (abs(s[i] - s[j]) == 32) {\\n                    s[i] = \\' \\';\\n                    s[j] = \\' \\';\\n                    i = j -1;\\n                    mustCheck = true;\\n                }\\n            }\\n        }\\n        // extracting all \"surviving\" characters\\n        for (char c: s) if (c != \\' \\') res.push_back(c);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res;\\n        bool mustCheck = true;\\n        int len = s.size() - 1;\\n        // loop to removes pairs\\n        while (mustCheck) {\\n            mustCheck = false;\\n            for (int i = 0, j; i < len; i++) {\\n                // skipping already marked characters\\n                if (s[i] == \\' \\') continue;\\n                j = i + 1;\\n                // moving j to the next non marked character\\n                while (j <= len && s[j] == \\' \\') j++;\\n                // checking for a match of upper-+lowercase\\n                while (i >= 0 && j <= len && abs(s[i] - s[j]) == 32) {\\n                    s[i] = \\' \\';\\n                    s[j] = \\' \\';\\n                    // checking for more adjacent matches\\n                    i--, j++;\\n                    mustCheck = true;\\n                }\\n                if (mustCheck) i = j;\\n            }\\n        }\\n        // extracting all \"surviving\" characters\\n        for (char c: s) if (c != \\' \\') res.push_back(c);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res = s;\\n        int len = s.size();\\n        // loop to removes pairs\\n        do {\\n            s = res;\\n            for (int i = 1; i < len; i++) {\\n                // cutting out matching pairs of characters\\n                if (abs(res[i - 1] - res[i]) == 32) {\\n                    // removing the chars from res\\n                    res = res.substr(0, i - 1) + res.substr(i + 1);\\n                    // updating len to the new value\\n                    len -= 2;\\n                    // moving back i to check the new character in the same position\\n                    i--;\\n                }\\n            }\\n        } while (len != s.size());\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res = s;\\n        int len = s.size();\\n        // loop to removes pairs\\n        do {\\n            s = res;\\n            for (int j = 1, i; j < len; j++) {\\n                i = j - 1;\\n                // cutting out matching pairs of characters\\n                while (i >= 0 && j < len && abs(res[i] - res[j]) == 32) {\\n                    // updating len to the new value\\n                    len -= 2;\\n                    // moving back i to check the new character in the same position\\n                    i--, j++;\\n                }\\n                // removing the matched chars from res\\n                res = res.substr(0, i + 1) + res.substr(j);\\n            }\\n        } while (len != s.size());\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res;\\n        int st[s.size()], pos = 0;\\n        // loop to removes pairs\\n        for (char c: s) {\\n            // adding a char to the stack if the stack is empty\\n            // or the top does not match the char\\n            if (!pos || abs(st[pos - 1] - c) != 32) st[pos++] = c;\\n            else pos--;\\n        }\\n        // moving the char out of the stack into res\\n        if (pos) res.resize(pos);\\n        for (int i = 0; i < pos; i++) res[i] = st[i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834502,
                "title": "python-easy-to-understand-solution-using-stack",
                "content": "```\\nclass Solution(object):\\n    def makeGood(self, s):\\n        stack = []\\n        for item in s:\\n            if stack and abs(ord(stack[-1])-ord(item)) == 32:\\n                stack.pop()\\n            else:\\n                stack.append(item)\\n        return str.join(\"\", stack)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def makeGood(self, s):\\n        stack = []\\n        for item in s:\\n            if stack and abs(ord(stack[-1])-ord(item)) == 32:\\n                stack.pop()\\n            else:\\n                stack.append(item)\\n        return str.join(\"\", stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783905,
                "title": "simple-java-while-loop-solution-100-fast",
                "content": "```\\nclass Solution {\\n\\n\\tpublic String makeGood(String s) {\\n\\t\\tif(s.length()<=1)\\n\\t\\t\\treturn s;\\n        int i=0, j=1;\\n        StringBuilder sb = new StringBuilder(s);\\n        while(j < sb.length() && sb.length() > 1) {\\n        \\tif(Math.abs(sb.charAt(i) - sb.charAt(j)) == 32) {\\n        \\t\\tsb.deleteCharAt(i);\\n        \\t\\tsb.deleteCharAt(i);\\n        \\t\\tif(i>0)\\n        \\t\\t\\ti = i-1;\\n        \\t\\tj = i+1;\\n        \\t\\tcontinue;\\n        \\t}\\n        \\ti++;j++;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n\\tpublic String makeGood(String s) {\\n\\t\\tif(s.length()<=1)\\n\\t\\t\\treturn s;\\n        int i=0, j=1;\\n        StringBuilder sb = new StringBuilder(s);\\n        while(j < sb.length() && sb.length() > 1) {\\n        \\tif(Math.abs(sb.charAt(i) - sb.charAt(j)) == 32) {\\n        \\t\\tsb.deleteCharAt(i);\\n        \\t\\tsb.deleteCharAt(i);\\n        \\t\\tif(i>0)\\n        \\t\\t\\ti = i-1;\\n        \\t\\tj = i+1;\\n        \\t\\tcontinue;\\n        \\t}\\n        \\ti++;j++;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783827,
                "title": "python-by-recursion-ascii-property",
                "content": "Hint:\\n\\nall bad pair are with offset either +32 or -32 in ASCII code\\n\\n![image](https://assets.leetcode.com/users/images/ee77ed1e-468b-42c9-8304-cf894d90bb66_1597061856.1984293.png)\\n\\nASCII Code Table source:\\nhttp://www.cls-solutions.com/blog/?p=641\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        \\n        # initialized to \\'@\\' for dummy\\n        prev = \\'@\\'\\n        \\n        for idx, char in enumerate(s):\\n            \\n            if abs( ord(char)-ord(prev) ) == 32:\\n                \\n                # remove bad part and keep making remaining string good\\n                return self.makeGood(s[:idx-1] + s[idx+1:])\\n            \\n            prev = char\\n        \\n        # all good\\n        return s\\n```\\n\\n---\\n\\nReference:\\n[1] [Wiki: ASCII table](https://en.wikipedia.org/wiki/ASCII)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        \\n        # initialized to \\'@\\' for dummy\\n        prev = \\'@\\'\\n        \\n        for idx, char in enumerate(s):\\n            \\n            if abs( ord(char)-ord(prev) ) == 32:\\n                \\n                # remove bad part and keep making remaining string good\\n                return self.makeGood(s[:idx-1] + s[idx+1:])\\n            \\n            prev = char\\n        \\n        # all good\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780934,
                "title": "java-simple-o-n-time-o-1-space-no-extra-stack",
                "content": "```\\n    public String makeGood(String s) {\\n      if (s.length() <= 1) {\\n        return s;\\n      }\\n      StringBuilder sb = new StringBuilder();\\n      sb.append(s.charAt(0));\\n      for (int i = 1; i < s.length(); i++) {\\n        if (sb.length() > 0 && Math.abs(sb.charAt(sb.length() - 1) - s.charAt(i))==32) {\\n          sb.deleteCharAt(sb.length() - 1);\\n        } else {\\n          sb.append(s.charAt(i));\\n        }\\n      }\\n      return sb.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public String makeGood(String s) {\\n      if (s.length() <= 1) {\\n        return s;\\n      }\\n      StringBuilder sb = new StringBuilder();\\n      sb.append(s.charAt(0));\\n      for (int i = 1; i < s.length(); i++) {\\n        if (sb.length() > 0 && Math.abs(sb.charAt(sb.length() - 1) - s.charAt(i))==32) {\\n          sb.deleteCharAt(sb.length() - 1);\\n        } else {\\n          sb.append(s.charAt(i));\\n        }\\n      }\\n      return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3172903,
                "title": "c-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\nUsing string only and wothout stack\\n\\n# Approach\\n1. Create a new string and we will use it as a stack.\\n2. Check if string is not empty and it\\'s top and string\\'s current character\\'s difference is 32, If it is, then pop_back.\\n3. else, just push_back it in the string.\\n4. Return the string.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string str = \"\";\\n\\n        for(char ch : s){\\n            if( !str.empty() && (abs(str.back() - ch) == 32) ){\\n                str.pop_back();\\n            }else{\\n                str.push_back(ch);\\n            }\\n        }\\n\\n        return str;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string str = \"\";\\n\\n        for(char ch : s){\\n            if( !str.empty() && (abs(str.back() - ch) == 32) ){\\n                str.pop_back();\\n            }else{\\n                str.push_back(ch);\\n            }\\n        }\\n\\n        return str;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959377,
                "title": "java-stack-98-85-faster",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        char[] c = s.toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n        Stack<Character> stack = new Stack<>();\\n        for (char value : c) {\\n            if (!stack.isEmpty() && Math.abs(stack.peek() - value) == 32) stack.pop();\\n            else stack.push(value);\\n        }\\n        for (char ch : stack) {\\n            sb.append(ch);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        char[] c = s.toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n        Stack<Character> stack = new Stack<>();\\n        for (char value : c) {\\n            if (!stack.isEmpty() && Math.abs(stack.peek() - value) == 32) stack.pop();\\n            else stack.push(value);\\n        }\\n        for (char ch : stack) {\\n            sb.append(ch);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812879,
                "title": "c-easy-solution-using-stack",
                "content": "# Approach\\n1) We know that \\'a\\' - \\'A\\' = 32, and is same for every alphabatic character\\n2) To make the string good,we have to eliminate adjacent characters that make the string bad.\\n\\n3) check if top element of stack+32 is equal to strings character at i location or char+32 is equal to top element of stack, in both the cases you have to pop out the element else push following character of string\\n\\n4) append stack elements in ans string and return the reverse of it.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string str) {\\n        stack<char>s;\\n        for(int i=0; i<str.length(); i++){\\n            if(s.size()==0){\\n                s.push(str[i]);\\n                continue;\\n            }\\n            if(s.top()+32==str[i] || str[i]+32 == s.top()){\\n                s.pop();\\n            }else{\\n                s.push(str[i]);\\n            }\\n        }\\n        string ans = \"\";\\n        while(s.size()){\\n            ans+=s.top();\\n            s.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string str) {\\n        stack<char>s;\\n        for(int i=0; i<str.length(); i++){\\n            if(s.size()==0){\\n                s.push(str[i]);\\n                continue;\\n            }\\n            if(s.top()+32==str[i] || str[i]+32 == s.top()){\\n                s.pop();\\n            }else{\\n                s.push(str[i]);\\n            }\\n        }\\n        string ans = \"\";\\n        while(s.size()){\\n            ans+=s.top();\\n            s.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794692,
                "title": "one-pass-recursive-two-pointer-approach-o-n",
                "content": "This is a very easy and interesting problem. Using StringBuilder in java makes the code easier.\\n\\n```\\nclass Solution {\\n    StringBuilder sb;\\n    public String makeGood(String s) {\\n        // string builder provides good control over string modification.\\n        sb = new StringBuilder(s);\\n        recurMakeGood(0);\\n        return sb.toString();\\n    }\\n\\n    void recurMakeGood(int index){\\n        if(index<0)\\n            index=0;\\n        if(sb.length()<2)\\n            return;\\n        if(index==sb.length()-1){\\n            return;\\n        }\\n        char c1 = sb.charAt(index);\\n        char c2 = sb.charAt(index+1);\\n        if(areTheyPair(c1, c2)){\\n            sb.deleteCharAt(index);\\n            // length is reduced by one..\\n            // so index+1 element will now point to index\\n            sb.deleteCharAt(index);\\n            // two data are deleted, need to check next data with previous one so reduce by 2\\n            // later we are incrementing this by one\\n            index-=2;\\n        }\\n        // pointing to the next element\\n        recurMakeGood(index+1);\\n    }\\n\\n    boolean areTheyPair(char c1, char c2){\\n        return areTheypairInside(c1,c2) || areTheypairInside(c2, c1);\\n    }\\n\\n    boolean areTheypairInside(char c1, char c2){\\n        return c1-\\'a\\' == c2-\\'A\\';\\n    }\\n}\\n```\\n\\n# Here\\'s the prove:\\n\\n![image](https://assets.leetcode.com/users/images/b7789852-003b-4046-a4e5-c9d4a8fcdff4_1667945552.7049477.png)\\n\\n",
                "solutionTags": [
                    "Two Pointers",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    StringBuilder sb;\\n    public String makeGood(String s) {\\n        // string builder provides good control over string modification.\\n        sb = new StringBuilder(s);\\n        recurMakeGood(0);\\n        return sb.toString();\\n    }\\n\\n    void recurMakeGood(int index){\\n        if(index<0)\\n            index=0;\\n        if(sb.length()<2)\\n            return;\\n        if(index==sb.length()-1){\\n            return;\\n        }\\n        char c1 = sb.charAt(index);\\n        char c2 = sb.charAt(index+1);\\n        if(areTheyPair(c1, c2)){\\n            sb.deleteCharAt(index);\\n            // length is reduced by one..\\n            // so index+1 element will now point to index\\n            sb.deleteCharAt(index);\\n            // two data are deleted, need to check next data with previous one so reduce by 2\\n            // later we are incrementing this by one\\n            index-=2;\\n        }\\n        // pointing to the next element\\n        recurMakeGood(index+1);\\n    }\\n\\n    boolean areTheyPair(char c1, char c2){\\n        return areTheypairInside(c1,c2) || areTheypairInside(c2, c1);\\n    }\\n\\n    boolean areTheypairInside(char c1, char c2){\\n        return c1-\\'a\\' == c2-\\'A\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794610,
                "title": "python-3-6-lines-stack-w-explanation-t-m-95-82",
                "content": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        \\n        stack = deque()\\n\\n        for ch in s:\\n            \\n            if stack and abs(ord(stack[-1])-ord(ch)) == 32: # <- check whether two successive chars in s\\n                                                            #    are corresponding upper/lowercase letters\\n            \\n                stack.pop()                                 # <- if so, pop the stack and ignore ch, so\\n                                                            #    neither will be on the stack hereafter \\n\\n            else: stack.append(ch)                          # <-- if not, put ch on the stack to compare\\n                                                            #     with next ch in s\\n\\n        return \\'\\'.join(stack)                               # <-- remaining stack is the solution\\n```\\n[https://leetcode.com/submissions/detail/637453076/](http://)\\n\\nI could be wrong, but I think it\\'s O(n) / O(n).",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        \\n        stack = deque()\\n\\n        for ch in s:\\n            \\n            if stack and abs(ord(stack[-1])-ord(ch)) == 32: # <- check whether two successive chars in s\\n                                                            #    are corresponding upper/lowercase letters\\n            \\n                stack.pop()                                 # <- if so, pop the stack and ignore ch, so\\n                                                            #    neither will be on the stack hereafter \\n\\n            else: stack.append(ch)                          # <-- if not, put ch on the stack to compare\\n                                                            #     with next ch in s\\n\\n        return \\'\\'.join(stack)                               # <-- remaining stack is the solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793717,
                "title": "java-easy-to-understand-o-n-solution",
                "content": "\\n# Approach\\nKeep checking the difference between the last character in result and the `ith` character. The difference between the ASCII value of lower and upper case of same character is 32. \\n\\n# Code\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n         // create result with empty string\\n        StringBuilder res = new StringBuilder();\\n        for (char ch : s.toCharArray()) {\\n            int resLength = res.length();\\n            // if the difference between the ith character of s\\n            // and last character in result is 32\\n            // then remove the last character from result\\n            // otherwise append the latest character to result\\n            if (resLength!=0 && Math.abs(res.charAt(resLength-1) - ch) == 32) {\\n                res.deleteCharAt(resLength - 1);\\n            } else {\\n                res.append(ch);\\n            }\\n\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n         // create result with empty string\\n        StringBuilder res = new StringBuilder();\\n        for (char ch : s.toCharArray()) {\\n            int resLength = res.length();\\n            // if the difference between the ith character of s\\n            // and last character in result is 32\\n            // then remove the last character from result\\n            // otherwise append the latest character to result\\n            if (resLength!=0 && Math.abs(res.charAt(resLength-1) - ch) == 32) {\\n                res.deleteCharAt(resLength - 1);\\n            } else {\\n                res.append(ch);\\n            }\\n\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793502,
                "title": "java-simple-solution-with-the-following-complexities",
                "content": "Time complexity : O(n)\\nSpace complexity : O(1)\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuffer sb = new StringBuffer(s);\\n        for (int i = sb.length() - 1; i >= 0; i--) {\\n            if (i == sb.length() - 1)\\n                continue;\\n            char c1 = sb.charAt(i), c2 = sb.charAt(i + 1);\\n            if (sameLetterDifferentCase(c1, c2)) {\\n                sb.deleteCharAt(i + 1);\\n                sb.deleteCharAt(i);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n    public boolean sameLetterDifferentCase(char letter1, char letter2) {\\n        return Math.abs(letter1 - letter2) == \\'a\\' - \\'A\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuffer sb = new StringBuffer(s);\\n        for (int i = sb.length() - 1; i >= 0; i--) {\\n            if (i == sb.length() - 1)\\n                continue;\\n            char c1 = sb.charAt(i), c2 = sb.charAt(i + 1);\\n            if (sameLetterDifferentCase(c1, c2)) {\\n                sb.deleteCharAt(i + 1);\\n                sb.deleteCharAt(i);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n    public boolean sameLetterDifferentCase(char letter1, char letter2) {\\n        return Math.abs(letter1 - letter2) == \\'a\\' - \\'A\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793440,
                "title": "c-7-line-super-easy-solution-w-comments",
                "content": "# Intuition\\nErase adjucent same lower case and upper case laters every time by setting counter to 0.\\n\\n# Approach\\n1. Loop through s.\\n2. If any adjuscent characters are similar lower case and upper case characters are same, erase them.\\n3. Set counter to -1, as we are increasing the counter every time in the loop.\\n4. At the end return the modified s.\\n\\n# Complexity\\n- Time complexity:\\nBeats 82.74%\\n\\n- Space complexity:\\nBeats 97.69%\\n\\n**Please upvote** if you like the solution.\\nComments to make the solution bettter are welcome.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        for(int i = 0; i < s.length(); ++i)\\n        {\\n            int len = s.length();\\n            if(s[i] == s[i+1] + 32 || s[i] + 32 == s[i+1])\\n                s.erase(i, 2);\\n            if(len != s.length())\\n                i = -1;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        for(int i = 0; i < s.length(); ++i)\\n        {\\n            int len = s.length();\\n            if(s[i] == s[i+1] + 32 || s[i] + 32 == s[i+1])\\n                s.erase(i, 2);\\n            if(len != s.length())\\n                i = -1;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793273,
                "title": "easy-explained-c",
                "content": "Here are the following 2 approaches to the question:\\n\\n## 1) modifying string in place\\n``` C++ []\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int i{0}, l=s.length()-1;\\n\\n        // we will continue the process as long as the current index within the length of the string\\n        while (i<l) {\\n            // if the differnce between current and next character is 32, then either of them is lower and upper\\n            if (abs(s[i]-s[i+1])==32) {\\n                // modify s in place adding it\\'s part before current index and after the to be removed part\\n                s = s.substr(0,i) + s.substr(i+2);\\n                // length decreased by 2\\n                l-=2;\\n                // now that we have moved the character at index we need to check whether the \\n                // previous character matches with nex character so we decrease i\\n                if (i>0) i--;\\n            }\\n            else i++;\\n        }\\n\\n        return s;\\n    }\\n};\\n```\\n\\n## 2) creating a new string and adding characters to it one by one\\n``` C++ []\\nclass Solution \\n{\\npublic:\\n    string makeGood(string s) \\n    {\\n        string t;\\n\\n        for (char x:s) {\\n            // if the previous character in string t match the current character\\n            // we remove the previous character and don\\'t add the current one\\n            if (!t.empty() && abs(t.back()-x)==32) t.pop_back();\\n            // if the string is empty or if the character doesn\\'t match the existing previous\\n            // character we add it to string t\\n            else t.push_back(x);\\n        }\\n\\n        return t;\\n    }\\n};\\n```\\n\\n*Upvote the solution if you liked it*",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int i{0}, l=s.length()-1;\\n\\n        // we will continue the process as long as the current index within the length of the string\\n        while (i<l) {\\n            // if the differnce between current and next character is 32, then either of them is lower and upper\\n            if (abs(s[i]-s[i+1])==32) {\\n                // modify s in place adding it\\'s part before current index and after the to be removed part\\n                s = s.substr(0,i) + s.substr(i+2);\\n                // length decreased by 2\\n                l-=2;\\n                // now that we have moved the character at index we need to check whether the \\n                // previous character matches with nex character so we decrease i\\n                if (i>0) i--;\\n            }\\n            else i++;\\n        }\\n\\n        return s;\\n    }\\n};\\n```\n``` C++ []\\nclass Solution \\n{\\npublic:\\n    string makeGood(string s) \\n    {\\n        string t;\\n\\n        for (char x:s) {\\n            // if the previous character in string t match the current character\\n            // we remove the previous character and don\\'t add the current one\\n            if (!t.empty() && abs(t.back()-x)==32) t.pop_back();\\n            // if the string is empty or if the character doesn\\'t match the existing previous\\n            // character we add it to string t\\n            else t.push_back(x);\\n        }\\n\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793163,
                "title": "c-simple-solution-o-n-easy-to-understand-few-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n = s.size()-1;\\n        for(int i = 0 ; i < n ; i++) {\\n            if(abs(s[i] -s [i+1])==32 ){\\n                s.erase(i,2);\\n                i=-1;    n-=2;\\n            } }\\n        return s;\\n    }\\n};\\n\\n***if you found its useful and easy to understand then please upvote me ***\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n = s.size()-1;\\n        for(int i = 0 ; i < n ; i++) {\\n            if(abs(s[i] -s [i+1])==32 ){\\n                s.erase(i,2);\\n                i=-1;    n-=2;\\n            } }\\n        return s;\\n    }\\n};\\n\\n***if you found its useful and easy to understand then please upvote me ***\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792665,
                "title": "c-vector-beats-82-sol",
                "content": "# Intuition\\n<!-- it can be felt that we need to use some extra space to store our result and to modify the string using the stack was a great option -->\\nIt can be felt that we need to use some extra space to store our result and to modify the string using the stack was a great option.\\n\\n# Complexity\\n- Time complexity:\\no(n) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n=s.length()-1,i=0;\\n        stack<char> chk;\\n        string ans=\"\";\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(chk.empty())\\n            {\\n                chk.push(s[i]);\\n            }\\n            else{  \\n                   if(s[i]>=97&&s[i]<=122)\\n                   {\\n                       if(s[i]-chk.top()==32)\\n                       chk.pop();\\n                       else{chk.push(s[i]);}\\n                   }\\n                   else if(s[i]>=65&&s[i]<=90)\\n                   {\\n                       if(chk.top()-s[i]==32)\\n                       chk.pop();\\n                       else{chk.push(s[i]);}\\n                   }\\n\\n            }\\n        }\\n        while(!chk.empty())\\n        {\\n        ans.push_back(chk.top());\\n        chk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n=s.length()-1,i=0;\\n        stack<char> chk;\\n        string ans=\"\";\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(chk.empty())\\n            {\\n                chk.push(s[i]);\\n            }\\n            else{  \\n                   if(s[i]>=97&&s[i]<=122)\\n                   {\\n                       if(s[i]-chk.top()==32)\\n                       chk.pop();\\n                       else{chk.push(s[i]);}\\n                   }\\n                   else if(s[i]>=65&&s[i]<=90)\\n                   {\\n                       if(chk.top()-s[i]==32)\\n                       chk.pop();\\n                       else{chk.push(s[i]);}\\n                   }\\n\\n            }\\n        }\\n        while(!chk.empty())\\n        {\\n        ans.push_back(chk.top());\\n        chk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792284,
                "title": "java-iterative-easiest-no-stack-no-stringbuilder",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to traverse the whole string keeping in mind that we go on eliminating the bad string . \\nIn general scenario , if we just use a for loop for traversing, which checks whether character at index i and index i+1 do not form a bad string , this will work for some cases . But still there might be some bad strings left.\\n\\nConsider the case where String s =\"AbBacd\" , here according to our above approach , only \"bB\" will be eliminated and the loop will end , because in a single pass it found only one bad string.The String will become s=\"Aacd\".\\n\\nHere there is a **imp observation** that if we find any bad string and we eliminate it , we need to **check again if there can be a possible case where after eliminating this bad string ,the string formed contains a bad string or not** . \\nSo for this we need to recheck the string from **index , i= i-1** because the character at index **i-1** might form a bad string with character **i+2** as characters at **i** and **i+1** have been removed.\\nTo recheck we update the value of **index i to i-1 when i>0 else update i to 0.** Used MAX function for this.\\n**This was the main part.**\\n\\nThere is no need to use any stack or Stringbuilder to store the new string , we are going to use the given string only for this.\\nConsider , we eliminated characters at i and i+1. Now we update the string using substring function. **Take substring from 0 to i-1 and i+2 to s.length.**\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        int i=0;\\n// loop until strings gets empty or index does not exceed length-1.\\n        while(s!=\"\" && i<s.length()-1)\\n        {\\n// to get the ASCII values of characters as difference between values of same characters is 32.\\n            int a=(int) s.charAt(i);\\n            int b=(int) s.charAt(i+1);\\n            if(Math.abs(a-b)==32)\\n            {\\n                s=s.substring(0,i)+s.substring(i+2,s.length());\\n                i=Math.max(i-1,0);\\n            }\\n            else i++;\\n        }\\n        return s;\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        int i=0;\\n// loop until strings gets empty or index does not exceed length-1.\\n        while(s!=\"\" && i<s.length()-1)\\n        {\\n// to get the ASCII values of characters as difference between values of same characters is 32.\\n            int a=(int) s.charAt(i);\\n            int b=(int) s.charAt(i+1);\\n            if(Math.abs(a-b)==32)\\n            {\\n                s=s.substring(0,i)+s.substring(i+2,s.length());\\n                i=Math.max(i-1,0);\\n            }\\n            else i++;\\n        }\\n        return s;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792208,
                "title": "make-the-string-great",
                "content": "The code is very simple and comments are added for your understanding.\\n**Upvote if you like the solution. \\uD83D\\uDE09**\\n\\n```\\nclass Solution {\\n    \\n    //\\uD83D\\uDCA1 The logic behind using stack is for every ith charcater we want to check i+1th character and whenever some iterator depends on another iterator there is a possibility that we can optimize this using stack\\n    //watch first video of stack of Aditya Verma for better understanding of where to use Stack.\\n    \\n    public String makeGood(String s) {\\n        //First create a stack to store the good characters\\n        Stack<Character>stack=new Stack<>();\\n        \\n        for(int i=s.length()-1;i>=0;i--){\\n            //insert the characters from the last index of the string \\n            //\\uD83D\\uDCA1We are inserting from last because we want to add all the stack characters which is part of good string.. and stack is LIFO so we won\\'t need to reverse the final string..\\n            \\n            if(!stack.isEmpty()&&Math.abs(stack.peek()-s.charAt(i))==32){\\n                //here we first check if stack is not empty and top element of stack difference with current character is 32\\n                // \\uD83D\\uDCA1 here we are checking difference as 32 because difference of uppercase and lowercase of same alphabet is 32\\n                //if it is then we need to pop  as it\\'s making the pair of => eE oe Ee\\n                stack.pop();\\n            }else{\\n                //else if stack is empty or they are not making pairs of eE and Ee\\n                //then we can simply insert the character where we are standing as it will be the part of our good string \\uD83D\\uDE09\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        //at the end stack contains all the characters good string should possess by removing bad pairs.\\uD83E\\uDD29\\n        \\n        //created a empty string to store our answer \\n        String str=\"\";\\n        \\n        //till stack is not empty insert it in the string \\n        while(!stack.isEmpty()){\\n            str+=stack.pop();\\n        }\\n        \\n        //at last return the string.\\n        return str;\\n    }\\n    \\n}\\n```\\n\\nTime Complexity :- **O(N)**  => Because we are traversing each character of string once.\\uD83E\\uDDD0\\nSpace Complexity :- **O(N)** => Because Stack can hold all the characters of string (at worst case when there is no bad pairs \\uD83D\\uDE08).",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //\\uD83D\\uDCA1 The logic behind using stack is for every ith charcater we want to check i+1th character and whenever some iterator depends on another iterator there is a possibility that we can optimize this using stack\\n    //watch first video of stack of Aditya Verma for better understanding of where to use Stack.\\n    \\n    public String makeGood(String s) {\\n        //First create a stack to store the good characters\\n        Stack<Character>stack=new Stack<>();\\n        \\n        for(int i=s.length()-1;i>=0;i--){\\n            //insert the characters from the last index of the string \\n            //\\uD83D\\uDCA1We are inserting from last because we want to add all the stack characters which is part of good string.. and stack is LIFO so we won\\'t need to reverse the final string..\\n            \\n            if(!stack.isEmpty()&&Math.abs(stack.peek()-s.charAt(i))==32){\\n                //here we first check if stack is not empty and top element of stack difference with current character is 32\\n                // \\uD83D\\uDCA1 here we are checking difference as 32 because difference of uppercase and lowercase of same alphabet is 32\\n                //if it is then we need to pop  as it\\'s making the pair of => eE oe Ee\\n                stack.pop();\\n            }else{\\n                //else if stack is empty or they are not making pairs of eE and Ee\\n                //then we can simply insert the character where we are standing as it will be the part of our good string \\uD83D\\uDE09\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        //at the end stack contains all the characters good string should possess by removing bad pairs.\\uD83E\\uDD29\\n        \\n        //created a empty string to store our answer \\n        String str=\"\";\\n        \\n        //till stack is not empty insert it in the string \\n        while(!stack.isEmpty()){\\n            str+=stack.pop();\\n        }\\n        \\n        //at last return the string.\\n        return str;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792158,
                "title": "c-easy-deque",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOur task is to create a string which is good, to make a string good we need to consider\\nthis things first\\n* if `last_character == curr_character` like `a, a` then append it to data structure.\\n* if `last_character != curr_chracter` like `(a, b) or (a, A)` then\\n        * check `lower(last_character) == lower(curr_character)` `(a,A)` then pop_back from data structure.\\n        * else append to the data structure.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use deque here for sake of simplicity.\\n* Create a `deque of characters`.\\n* Iterate from start to end of the string.\\n* Check is `deque is empty` then simply append to it.\\n* else check `if(deque.back() == curr_char)` then append that character.\\n* else check `if(lower(deque.back()) != lower(curr_char))` then append that character.\\n* else pop_back from the character.\\n* After n iterations, create a string and append all characters of deque in it.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n***where `n` is the size of the string.***\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n***where `n` is the size of the string.***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(char a, char b) {\\n        if(a == b) {\\n            return true;\\n        }\\n        return tolower(a) != tolower(b); \\n    }\\n\\n    string makeGood(string s) {\\n        deque<char> st;\\n\\n        int n = s.length();\\n        for(int i = 0; i < n; i++) {\\n            if (st.empty()) {\\n                st.push_back(s[i]);\\n            }\\n            else if(check(st.back(), s[i])) {\\n                st.push_back(s[i]);\\n            } else {\\n                st.pop_back();\\n            }\\n        }\\n\\n        string ans = \"\";\\n        while(!st.empty()) {\\n            ans.push_back(st.front());\\n            st.pop_front();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(char a, char b) {\\n        if(a == b) {\\n            return true;\\n        }\\n        return tolower(a) != tolower(b); \\n    }\\n\\n    string makeGood(string s) {\\n        deque<char> st;\\n\\n        int n = s.length();\\n        for(int i = 0; i < n; i++) {\\n            if (st.empty()) {\\n                st.push_back(s[i]);\\n            }\\n            else if(check(st.back(), s[i])) {\\n                st.push_back(s[i]);\\n            } else {\\n                st.pop_back();\\n            }\\n        }\\n\\n        string ans = \"\";\\n        while(!st.empty()) {\\n            ans.push_back(st.front());\\n            st.pop_front();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791985,
                "title": "java-easy-to-understand-solution-recursion-stack-approach-also",
                "content": "*Upvote if you like the solution!!!*\\n**Here\\'s my accepted basic Java code [O(n^2) +O(n) ]**\\n```\\nclass Solution {\\n    \\n    public static int ContainUpperCase(String text) {\\n       int count=0;\\n       for(char c:text.toCharArray()){\\n           if(Character.isUpperCase(c)) count++;\\n       }\\n        return count;\\n}\\n    \\n    public String makeGood(String s) {\\n        int t = ContainUpperCase(s);\\n        while(t--!=0)\\n        s= helper(s);\\n        return s;\\n    }\\n    String helper(String s){\\n        char [] c = s.toCharArray();\\n        String ans = \"\";\\n        for(int i=0;i<c.length;i++){\\n            if(Character.isUpperCase(c[i])){\\n                if(i>0 && c[i-1]==(\\'a\\'+(c[i]-\\'A\\'))) \\n                    {c[i]=\\'1\\';c[i-1]=\\'1\\';}\\n                else if(i<c.length-1 && c[i+1]==(\\'a\\'+(c[i]-\\'A\\'))) \\n                    {c[i]=\\'1\\';c[i+1]=\\'1\\';}\\n            }\\n        }\\n        \\n        for(int i=0;i<c.length;i++){\\n            if(c[i]==\\'1\\')continue;\\n            ans+=c[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Here Recusive Approch[O(n^2) ] :**\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==(s.charAt(i+1)^32))\\n                //recursive call passing string removing pair found\\n                return makeGood(s.substring(0,i)+s.substring(i+2));\\n        }\\n        //if we didn\\'t found a pair, we\\'ll return s\\n        return s;\\n    }\\n}\\n```\\n\\n**But i found Stack approch best here\\'s the code [O(n)] :**\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        // Use stack to store the visited characters.\\n        Stack<Character> stack = new Stack<>();\\n        for(char c:s.toCharArray()){\\n            /* If the current character make a pair with the last character in the stack,\\n             remove both of them. Otherwise, we the add current character to stack.*/\\n            if(!stack.isEmpty() && c==(stack.lastElement()^32)){\\n                stack.pop();\\n            }\\n            else\\n                stack.add(c);\\n            \\n        }\\n        \\n        //Just converting all characters left in stack to string\\n        StringBuilder ans = new StringBuilder();\\n        for(char c:stack){\\n            ans.append(c);\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public static int ContainUpperCase(String text) {\\n       int count=0;\\n       for(char c:text.toCharArray()){\\n           if(Character.isUpperCase(c)) count++;\\n       }\\n        return count;\\n}\\n    \\n    public String makeGood(String s) {\\n        int t = ContainUpperCase(s);\\n        while(t--!=0)\\n        s= helper(s);\\n        return s;\\n    }\\n    String helper(String s){\\n        char [] c = s.toCharArray();\\n        String ans = \"\";\\n        for(int i=0;i<c.length;i++){\\n            if(Character.isUpperCase(c[i])){\\n                if(i>0 && c[i-1]==(\\'a\\'+(c[i]-\\'A\\'))) \\n                    {c[i]=\\'1\\';c[i-1]=\\'1\\';}\\n                else if(i<c.length-1 && c[i+1]==(\\'a\\'+(c[i]-\\'A\\'))) \\n                    {c[i]=\\'1\\';c[i+1]=\\'1\\';}\\n            }\\n        }\\n        \\n        for(int i=0;i<c.length;i++){\\n            if(c[i]==\\'1\\')continue;\\n            ans+=c[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==(s.charAt(i+1)^32))\\n                //recursive call passing string removing pair found\\n                return makeGood(s.substring(0,i)+s.substring(i+2));\\n        }\\n        //if we didn\\'t found a pair, we\\'ll return s\\n        return s;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        // Use stack to store the visited characters.\\n        Stack<Character> stack = new Stack<>();\\n        for(char c:s.toCharArray()){\\n            /* If the current character make a pair with the last character in the stack,\\n             remove both of them. Otherwise, we the add current character to stack.*/\\n            if(!stack.isEmpty() && c==(stack.lastElement()^32)){\\n                stack.pop();\\n            }\\n            else\\n                stack.add(c);\\n            \\n        }\\n        \\n        //Just converting all characters left in stack to string\\n        StringBuilder ans = new StringBuilder();\\n        for(char c:stack){\\n            ans.append(c);\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791734,
                "title": "stack-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Data Structure\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Stack\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n\\n            if((!st.empty())  && abs(st.top()-s[i])==(\\'a\\'-\\'A\\')){\\n                st.pop();\\n            }\\n            else\\n            st.push(s[i]);\\n        }\\n        string ans;\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n\\n            if((!st.empty())  && abs(st.top()-s[i])==(\\'a\\'-\\'A\\')){\\n                st.pop();\\n            }\\n            else\\n            st.push(s[i]);\\n        }\\n        string ans;\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791557,
                "title": "c-easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        if(s.size()==1 || s==\"\")\\n        {\\n           return s;\\n        }\\n        auto it=s.begin();\\n        while(it<s.end() && s.size()>0)\\n        {\\n           if((abs(*it - *(it+1))==32))\\n           {\\n               s.erase(it,it+2);\\n               it=s.begin();\\n           }\\n           else\\n           {\\n             it++;\\n           }\\n           \\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        if(s.size()==1 || s==\"\")\\n        {\\n           return s;\\n        }\\n        auto it=s.begin();\\n        while(it<s.end() && s.size()>0)\\n        {\\n           if((abs(*it - *(it+1))==32))\\n           {\\n               s.erase(it,it+2);\\n               it=s.begin();\\n           }\\n           else\\n           {\\n             it++;\\n           }\\n           \\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791434,
                "title": "c-using-stack-easy-and-simple-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach Using stack\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> st;\\n        for(auto i: s){\\n            if(st.empty()){\\n                st.push(i);\\n            }\\n            else{\\n                if(abs(i-st.top()) == 32){\\n                    st.pop();\\n                }\\n                else{\\n                    st.push(i);\\n                }\\n            }\\n            \\n        }\\n        string ans;\\n        /*\\n        //instead doing this below approach can also be done.\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        */\\n\\n    while (!st.empty()) {\\n        ans = st.top() + ans;\\n        st.pop();\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> st;\\n        for(auto i: s){\\n            if(st.empty()){\\n                st.push(i);\\n            }\\n            else{\\n                if(abs(i-st.top()) == 32){\\n                    st.pop();\\n                }\\n                else{\\n                    st.push(i);\\n                }\\n            }\\n            \\n        }\\n        string ans;\\n        /*\\n        //instead doing this below approach can also be done.\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        */\\n\\n    while (!st.empty()) {\\n        ans = st.top() + ans;\\n        st.pop();\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791378,
                "title": "simple-well-explained-stack-implemented-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStack is Excellent in getting the last probable element in string after deleting the adjacent characters\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>`!stack.isEmpty() && Math.abs(stack.peek()-ch)==(\\'a\\'-\\'A\\')` this code here checks if the stack is empty, then it just pushes the next character in the stack, but if its there then the absolute difference between capital letter and small letter of same character must be equal to the absolute difference between `a` and `A`.\\n\\n>In the final lines, poping from the stack and directly storing in string may result in reversed string. Thats when the best way to reverse the string would be inserting the elements in the string in the reverse order.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char ch : s.toCharArray()){\\n            if(!stack.isEmpty() && Math.abs(stack.peek()-ch)==(\\'a\\'-\\'A\\'))\\n                stack.pop();\\n            else stack.push(ch);\\n        }\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char ch : s.toCharArray()){\\n            if(!stack.isEmpty() && Math.abs(stack.peek()-ch)==(\\'a\\'-\\'A\\'))\\n                stack.pop();\\n            else stack.push(ch);\\n        }\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791209,
                "title": "c-clean-o-n-solution-using-stack-0-ms-runtime",
                "content": "We would be using the fact that the difference between the ascii values of same alphabets in capital ans small letters is 32.\\ni.e A - a=32 && a- A=32;\\n\\nSo, we will keep popping up the top element of the stack if we the current element and top of the stack has an absolute diffrenece of 32.\\n\\nHere is the C++ code-\\n\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            if(st.empty()) st.push(s[i]);\\n            else{\\n                int a=abs(s[i]-st.top());\\n                if(a==32) st.pop();\\n                else st.push(s[i]);\\n        }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        int ss=0,e=ans.size()-1;\\n        while(ss<e){\\n            swap(ans[ss],ans[e]);\\n            ss++;\\n            e--;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\nDo upvote if you understood the solution and suggestions are welcome.",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            if(st.empty()) st.push(s[i]);\\n            else{\\n                int a=abs(s[i]-st.top());\\n                if(a==32) st.pop();\\n                else st.push(s[i]);\\n        }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        int ss=0,e=ans.size()-1;\\n        while(ss<e){\\n            swap(ans[ss],ans[e]);\\n            ss++;\\n            e--;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790978,
                "title": "java-detailed-solution-using-stack-o-n",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\n        for (char c : s.toCharArray()) {\\n            if (!stack.isEmpty() && Math.abs(c - stack.peek()) == 32) {\\n                stack.pop();\\n            } else {\\n                stack.push(c);\\n            }\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (char c : stack) ans.append(c);\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\n        for (char c : s.toCharArray()) {\\n            if (!stack.isEmpty() && Math.abs(c - stack.peek()) == 32) {\\n                stack.pop();\\n            } else {\\n                stack.push(c);\\n            }\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (char c : stack) ans.append(c);\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790913,
                "title": "c-stack-two-easy-approaches-explained",
                "content": "**Approach 1:**\\n\\n```\\nclass Solution {\\npublic:\\n    //app 1: using stack [intuitive approach]\\n    string makeGood(string s) {\\n        stack<char> st;\\n        \\n        for(char &ch: s){\\n            if(st.empty()){\\n                st.push(ch);\\n            }\\n            //if cur char is same as top of stk but with opposite case ==> pop it\\n\\t\\t\\t//difference between the any lowercase and uppercase alphabet is 32\\n            else if(abs(ch - st.top()) == 32 ){\\n                st.pop();\\n            }\\n            else{\\n                st.push(ch);\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach 2:**\\n\\n```\\nclass Solution {\\npublic:\\n    //app 2: using string as stack\\n    string makeGood(string s) {\\n        string ans;\\n        \\n        for(char &ch: s){\\n            if(ans.length() == 0){\\n                ans += ch;\\n            }\\n            //difference between the any lowercase and uppercase alphabet is 32\\n            else if(abs(ch - ans.back()) == 32){\\n                ans.pop_back();\\n            }\\n            \\n            else{\\n                ans += ch;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nDo upvote the post, if it\\'s been any help to you! \\uD83D\\uDE80",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //app 1: using stack [intuitive approach]\\n    string makeGood(string s) {\\n        stack<char> st;\\n        \\n        for(char &ch: s){\\n            if(st.empty()){\\n                st.push(ch);\\n            }\\n            //if cur char is same as top of stk but with opposite case ==> pop it\\n\\t\\t\\t//difference between the any lowercase and uppercase alphabet is 32\\n            else if(abs(ch - st.top()) == 32 ){\\n                st.pop();\\n            }\\n            else{\\n                st.push(ch);\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //app 2: using string as stack\\n    string makeGood(string s) {\\n        string ans;\\n        \\n        for(char &ch: s){\\n            if(ans.length() == 0){\\n                ans += ch;\\n            }\\n            //difference between the any lowercase and uppercase alphabet is 32\\n            else if(abs(ch - ans.back()) == 32){\\n                ans.pop_back();\\n            }\\n            \\n            else{\\n                ans += ch;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790896,
                "title": "rust-simple-stack-solution",
                "content": "```\\nuse std::collections::VecDeque;\\nimpl Solution {\\n    pub fn make_good(s: String) -> String {\\n        if s == \"\" {\\n            return s;\\n        }\\n        \\n        let mut stack = VecDeque::<char>::new();\\n        let s = s.chars().collect::<Vec<char>>();\\n        \\n        let last = s[0];\\n        stack.push_back(s[0]);\\n        \\n        for i in 1..s.len() {\\n            if stack.len() > 0 {\\n                let last = stack.pop_back().unwrap();\\n                let is_eq = match last > s[i] {\\n                    true => {\\n                        (last as u8) - (s[i] as u8) == 32\\n                    },\\n                    false => {\\n                        (s[i] as u8) - (last as u8) == 32\\n                    }\\n                };\\n\\n                if is_eq {\\n                    continue;\\n                }\\n                \\n                stack.push_back(last);\\n            }\\n            \\n            stack.push_back(s[i]);\\n            \\n        }\\n        \\n        stack.into_iter().collect::<String>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Stack"
                ],
                "code": "```\\nuse std::collections::VecDeque;\\nimpl Solution {\\n    pub fn make_good(s: String) -> String {\\n        if s == \"\" {\\n            return s;\\n        }\\n        \\n        let mut stack = VecDeque::<char>::new();\\n        let s = s.chars().collect::<Vec<char>>();\\n        \\n        let last = s[0];\\n        stack.push_back(s[0]);\\n        \\n        for i in 1..s.len() {\\n            if stack.len() > 0 {\\n                let last = stack.pop_back().unwrap();\\n                let is_eq = match last > s[i] {\\n                    true => {\\n                        (last as u8) - (s[i] as u8) == 32\\n                    },\\n                    false => {\\n                        (s[i] as u8) - (last as u8) == 32\\n                    }\\n                };\\n\\n                if is_eq {\\n                    continue;\\n                }\\n                \\n                stack.push_back(last);\\n            }\\n            \\n            stack.push_back(s[i]);\\n            \\n        }\\n        \\n        stack.into_iter().collect::<String>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2790886,
                "title": "most-easy-c-solution-beginner-friendly",
                "content": "**Please Upvote if you like the Solution**\\n\\nclass Solution {\\npublic:\\n    \\n\\tstring makeGood(string s) {\\n        string ans = \"\";                    // String for storing result\\n        for(auto i : s) {                    \\n            if(ans.size()!= 0) {\\n                char temp = ans.back();\\n                char check = i;\\n                if((temp-\\'a\\' == check-\\'A\\') ||(check - \\'a\\' == temp - \\'A\\')) {     // checking for adjacent element if \\n                                                                                // such element is found then pop back last inserted\\n                                                                                // char from \\'ans\\' else push_back the current char.\\n                    ans.pop_back();\\n                } else {\\n                    ans += i;\\n                }\\n            } else {\\n                ans += i;                   // if \\'ans\\' string is empty then place the \\n                                            // currently visiting character in the \\'ans\\' string\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\tstring makeGood(string s) {\\n        string ans = \"\";                    // String for storing result\\n        for(auto i : s) {                    \\n            if(ans.size()!= 0) {\\n                char temp = ans.back();\\n                char check = i;\\n                if((temp-\\'a\\' == check-\\'A\\') ||(check - \\'a\\' == temp - \\'A\\')) {     // checking for adjacent element if \\n                                                                                // such element is found then pop back last inserted\\n                                                                                // char from \\'ans\\' else push_back the current char.\\n                    ans.pop_back();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1637899,
                "title": "i-can-t-make-it-more-easy-with-and-without-stack",
                "content": "### With stack\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string res;\\n        for(int i=0; i<s.size(); i++) {\\n            if(!res.empty() &&  abs(s[i] - res.back()) == 32 ) {\\n                res.pop_back();\\n            }\\n            else {\\n                res.push_back(s[i]);\\n            }   \\n        }\\n        return res;\\n    }\\n};\\n```\\n### Without Stack\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int j=0;\\n        for(int i=0; i<s.size(); i++) {\\n            \\n            if(j>0 &&  abs(s[i] - s[j-1]) == 32 ) {\\n                j--;\\n            }\\n            else {\\n                s[j]=s[i];\\n                j++;\\n            }   \\n\\n        }\\n        return s.substr(0,j);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string res;\\n        for(int i=0; i<s.size(); i++) {\\n            if(!res.empty() &&  abs(s[i] - res.back()) == 32 ) {\\n                res.pop_back();\\n            }\\n            else {\\n                res.push_back(s[i]);\\n            }   \\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int j=0;\\n        for(int i=0; i<s.size(); i++) {\\n            \\n            if(j>0 &&  abs(s[i] - s[j-1]) == 32 ) {\\n                j--;\\n            }\\n            else {\\n                s[j]=s[i];\\n                j++;\\n            }   \\n\\n        }\\n        return s.substr(0,j);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939965,
                "title": "java-simple-o-n-solution",
                "content": "```\\npublic String makeGood(String s) {\\n\\tif (s == null || s.length() < 2)\\n\\t\\treturn s;\\n\\n\\tStack<Character> st= new Stack<>();\\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tif (st.isEmpty())\\n\\t\\t\\tst.push(c);\\n\\t\\telse {\\n\\t\\t\\tif (Math.abs(c-st.peek()) != 32)\\n\\t\\t\\t\\tst.push(c);\\n\\t\\t\\telse\\n\\t\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tStringBuilder sb= new StringBuilder();\\n\\tfor(char s1 : st){\\n\\t\\tsb.append(s1);\\n\\t}\\n\\n\\treturn sb.toString();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String makeGood(String s) {\\n\\tif (s == null || s.length() < 2)\\n\\t\\treturn s;\\n\\n\\tStack<Character> st= new Stack<>();\\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tif (st.isEmpty())\\n\\t\\t\\tst.push(c);\\n\\t\\telse {\\n\\t\\t\\tif (Math.abs(c-st.peek()) != 32)\\n\\t\\t\\t\\tst.push(c);\\n\\t\\t\\telse\\n\\t\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tStringBuilder sb= new StringBuilder();\\n\\tfor(char s1 : st){\\n\\t\\tsb.append(s1);\\n\\t}\\n\\n\\treturn sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 906273,
                "title": "python-4-lines-97-faster-and-100-memory",
                "content": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        sol = []\\n        for el in s:\\n            if sol and el == sol[-1].swapcase(): sol.pop()\\n            else: sol.append(el)\\n        return \\'\\'.join(sol)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        sol = []\\n        for el in s:\\n            if sol and el == sol[-1].swapcase(): sol.pop()\\n            else: sol.append(el)\\n        return \\'\\'.join(sol)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864200,
                "title": "python-beats-99-5-and-simple-solution-using-stack",
                "content": "1) Define a stack to keep track of the results\\n2) Iterate over the string \\n3) For each letter, perfrom a case sensitive comparison against the last item in the stack if it exists\\n4) Add/remove an item from the result stack based on the comparison\\n\\n```\\n    def makeGood(self, s: str) -> str:\\n        stack = list()\\n        for c in s:\\n            if stack and stack[-1].lower() == c.lower():\\n                if stack[-1] == c:\\n                    stack.append(c)\\n                else:\\n                    stack.pop()\\n            else:\\n                stack.append(c)\\n        return \\'\\'.join(stack)\\n```\\n\\nO(N) runtime",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n    def makeGood(self, s: str) -> str:\\n        stack = list()\\n        for c in s:\\n            if stack and stack[-1].lower() == c.lower():\\n                if stack[-1] == c:\\n                    stack.append(c)\\n                else:\\n                    stack.pop()\\n            else:\\n                stack.append(c)\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 782596,
                "title": "rust-stack-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn make_good(s: String) -> String {\\n        let mut stack: Vec<char> = Vec::new();\\n        \\n        for l in s.chars() {\\n            if stack.len() > 0 && (l as i32 - stack[stack.len() - 1] as i32).abs() == 32 {\\n                stack.pop();\\n            }\\n            else {\\n                stack.push(l);\\n            }\\n        }\\n        \\n        return stack.iter().collect();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn make_good(s: String) -> String {\\n        let mut stack: Vec<char> = Vec::new();\\n        \\n        for l in s.chars() {\\n            if stack.len() > 0 && (l as i32 - stack[stack.len() - 1] as i32).abs() == 32 {\\n                stack.pop();\\n            }\\n            else {\\n                stack.push(l);\\n            }\\n        }\\n        \\n        return stack.iter().collect();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3168786,
                "title": "beats-54-75-make-the-string-great",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        l=[]\\n        for i in range(len(s)):\\n            if len(l)==0:\\n                l.append(s[i])\\n            elif l[len(l)-1]==s[i].lower() and s[i].isupper()==True or l[len(l)-1]==s[i].upper() and s[i].islower()==True:\\n                l.pop()\\n            else:\\n                l.append(s[i])\\n        return \"\".join(l)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        l=[]\\n        for i in range(len(s)):\\n            if len(l)==0:\\n                l.append(s[i])\\n            elif l[len(l)-1]==s[i].lower() and s[i].isupper()==True or l[len(l)-1]==s[i].upper() and s[i].islower()==True:\\n                l.pop()\\n            else:\\n                l.append(s[i])\\n        return \"\".join(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038384,
                "title": "two-pointers-in-place-modification-c",
                "content": "# Complexity\\n    Let n be the length of the input string s.\\n\\n- Time complexity : O(n)\\n\\n  We only need one iteration over s.\\nIn each step, we update the position of the two pointers and overwrite a character at most once, both of which take constant time.\\n- Space complexity : O(1)\\n\\n   We modify the input string s in place.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int last_index = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(last_index and abs(s[i]-s[last_index-1]) == 32)\\n            last_index--;\\n            else\\n            s[last_index++] = s[i];\\n        }\\n        return s.substr(0,last_index);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int last_index = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(last_index and abs(s[i]-s[last_index-1]) == 32)\\n            last_index--;\\n            else\\n            s[last_index++] = s[i];\\n        }\\n        return s.substr(0,last_index);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794221,
                "title": "java-easy-to-understand-self-explanatory",
                "content": "# Intuition\\nwe need to see last ele which can be find by stack\\n\\n# Approach\\nuse stack, if consition satisfy, pop, else push current\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean check(char a, char b){\\n        if(a >=\\'a\\' && a <=\\'z\\' && b >=\\'A\\' && b<=\\'Z\\'){\\n             return a == Character.toLowerCase(b); \\n        }\\n\\n        else if(a >=\\'A\\' && a <=\\'Z\\' && b>=\\'a\\' && b<=\\'z\\'){\\n            return a == Character.toUpperCase(b); \\n        }\\n        return false;\\n    }\\n\\n    public String makeGood(String s) {\\n        if(s.length()==0)\\n        return s;\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            if(!st.isEmpty() && check(st.peek(), s.charAt(i))){\\n                st.pop();\\n            }\\n            else{\\n            st.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean check(char a, char b){\\n        if(a >=\\'a\\' && a <=\\'z\\' && b >=\\'A\\' && b<=\\'Z\\'){\\n             return a == Character.toLowerCase(b); \\n        }\\n\\n        else if(a >=\\'A\\' && a <=\\'Z\\' && b>=\\'a\\' && b<=\\'z\\'){\\n            return a == Character.toUpperCase(b); \\n        }\\n        return false;\\n    }\\n\\n    public String makeGood(String s) {\\n        if(s.length()==0)\\n        return s;\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            if(!st.isEmpty() && check(st.peek(), s.charAt(i))){\\n                st.pop();\\n            }\\n            else{\\n            st.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793832,
                "title": "javascript-simple-solution-stack",
                "content": "I have used stack to solve this problem\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeGood = function(s) {\\n    var stack = []\\n    for ( let i = 0;i<s.length;i++)\\n    {\\n        if(stack.length &&Math.abs(s[i].charCodeAt()-stack[stack.length-1].charCodeAt())===32)\\n        {\\n            stack.pop();\\n\\n        }else{\\n            stack.push(s[i]);\\n\\n        }\\n\\n\\n    }\\n    return stack.join(\"\")\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeGood = function(s) {\\n    var stack = []\\n    for ( let i = 0;i<s.length;i++)\\n    {\\n        if(stack.length &&Math.abs(s[i].charCodeAt()-stack[stack.length-1].charCodeAt())===32)\\n        {\\n            stack.pop();\\n\\n        }else{\\n            stack.push(s[i]);\\n\\n        }\\n\\n\\n    }\\n    return stack.join(\"\")\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2793415,
                "title": "100-0ms-simple-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        for(int i=s.size()-1;i>0;i--){\\n            if(abs(s[i]-s[i-1])==32)\\n                s.erase(i-1,2);\\n\\t\\t\\t\\t}\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        for(int i=s.size()-1;i>0;i--){\\n            if(abs(s[i]-s[i-1])==32)\\n                s.erase(i-1,2);\\n\\t\\t\\t\\t}\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793031,
                "title": "go-clean-solution-stack-o-n",
                "content": "It could be much cleaner if we had native Stack implementation in Go, but we don\\'t, so the solution contains some slice operation to push and pop elements.\\n\\nThe `isBad` function uses the idea that two characters in different registers are placed at the same distance in the ASCII table, but we have to ensure that `a` is greather than `b` in order not to overflow the `byte` type which is unsigned integer when we calculate distance between `a` and `b`.\\n\\n```go\\nfunc makeGood(s string) string {\\n    if len(s) < 2 {\\n        return s\\n    }\\n    \\n    res := make([]byte, 0, len(s))\\n    for i := 0; i < len(s); i++ {\\n        last := len(res) - 1\\n\\n        if len(res) == 0 || !isBad(res[last], s[i]) {\\n            res = append(res, s[i])\\n        } else {\\n            res = res[:last]\\n        }\\n    }\\n    \\n    return string(res)\\n}\\n\\nfunc isBad(a, b byte) bool {\\n    if a < b {\\n        a, b = b, a\\n    }\\n    const distance = int(\\'a\\' - \\'A\\') // 32\\n    return int(a - b) == distance\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Stack"
                ],
                "code": "```go\\nfunc makeGood(s string) string {\\n    if len(s) < 2 {\\n        return s\\n    }\\n    \\n    res := make([]byte, 0, len(s))\\n    for i := 0; i < len(s); i++ {\\n        last := len(res) - 1\\n\\n        if len(res) == 0 || !isBad(res[last], s[i]) {\\n            res = append(res, s[i])\\n        } else {\\n            res = res[:last]\\n        }\\n    }\\n    \\n    return string(res)\\n}\\n\\nfunc isBad(a, b byte) bool {\\n    if a < b {\\n        a, b = b, a\\n    }\\n    const distance = int(\\'a\\' - \\'A\\') // 32\\n    return int(a - b) == distance\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2792812,
                "title": "simplest-c-solution-ever-seen",
                "content": "If you fine simplest one send me it. Thanks.)\\n\\n# Code\\n```\\npublic class Solution {\\n    public string MakeGood(string s) {      \\n        var sb = new StringBuilder(s);\\n        for (int i = 0; i < sb.Length - 1;)\\n            if (sb[i] - 32 == sb[i + 1]) { sb.Remove(i, 2); i = 0; }\\n            else if (sb[i] + 32 == sb[i + 1]) { sb.Remove(i, 2); i = 0; }\\n            else i++;\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string MakeGood(string s) {      \\n        var sb = new StringBuilder(s);\\n        for (int i = 0; i < sb.Length - 1;)\\n            if (sb[i] - 32 == sb[i + 1]) { sb.Remove(i, 2); i = 0; }\\n            else if (sb[i] + 32 == sb[i + 1]) { sb.Remove(i, 2); i = 0; }\\n            else i++;\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792792,
                "title": "c-easy-3ms-only-loops-and-substr",
                "content": "What I am doing here?\\nLets say we have aABbcCDD\\nnow you can see that we need to remove aA Bb and cC but not DD so our answer will be DD.\\nbut how we are gonna do this??\\nchecking two consecutive elements and if their ascii differs by 32, means 65+32==97 which is for \\'a\\' and \\'A\\' and 97-32==65 which is for \\'A\\' and \\'a\\' , using this we can find lowercase and uppercase letters easily using their ascii codes.\\nif two consecutive elements are same by ascii nature, we will remove both of them and our string will shrink by 2, like aABbcC-> BbcC-> cC -> \"\" empty string at last.\\nSo, we will remove these two characters using s.substr(0,i) function and it will help us to shrink the string, please I beg you to google this substr function otherwise no reason to see this solution, hardly take 5 mins for its understanding.\\nNow, this string shrinking will either empty the string or we will left with no pair to be removed. \\nSo, we will use a bool check, if it stays the same means nothing removed so the loop will break or if the string is empty the loop will end, returning the final string at the last.\\n\\n```\\nclass Solution\\n{\\n    public:\\n        string makeGood(string s)\\n        {\\n\\n            bool flag = false;\\n            while (true)\\n            {\\n                // cout<<\"Flag : \"<<flag<<endl;\\n                // cout<<\"S Size : \"<<s.size()<<endl;\\n                flag = false;\\n                for (int i = 1; i <= s.size() - 1; i++)\\n                {\\n                    // cout<<\"i : \"<<i<<endl;\\n                    // cout<<\"C Size : \"<<s.size()<<endl;\\n                    if (s[i - 1] - 32 == s[i] || s[i - 1] + 32 == s[i])\\n                    {\\n                        // cout<<\"Removal of \"<<s[i-1]<<\" and \"<<s[i]<<endl;\\n                        flag = true;\\n                        s = s.substr(0, i - 1) + s.substr(i + 1);\\n                        // cout<<\"New string : \"<<s<<endl;\\n                    }\\n                    if(s.size()==0){\\n                    // cout<<\"String empty, hence done\"<<endl;\\n                    break;\\n                    }\\n                }\\n                if(flag==false){\\n                    // cout<<\"No removal this time, hence done\"<<endl;\\n                    break;\\n                }\\n                if(s.size()==0){\\n                    // cout<<\"String empty, hence done\"<<endl;\\n                    break;\\n                }\\n            }\\n\\n            return s;\\n        }\\n};\\n```\\n\\nIf you loved it, pls guys upvote me so that I can post more.\\nFor any suggestions pls write the comment below.\\nThankyou for your time to read till now.\\n\\nHappy Leetcoding.",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        string makeGood(string s)\\n        {\\n\\n            bool flag = false;\\n            while (true)\\n            {\\n                // cout<<\"Flag : \"<<flag<<endl;\\n                // cout<<\"S Size : \"<<s.size()<<endl;\\n                flag = false;\\n                for (int i = 1; i <= s.size() - 1; i++)\\n                {\\n                    // cout<<\"i : \"<<i<<endl;\\n                    // cout<<\"C Size : \"<<s.size()<<endl;\\n                    if (s[i - 1] - 32 == s[i] || s[i - 1] + 32 == s[i])\\n                    {\\n                        // cout<<\"Removal of \"<<s[i-1]<<\" and \"<<s[i]<<endl;\\n                        flag = true;\\n                        s = s.substr(0, i - 1) + s.substr(i + 1);\\n                        // cout<<\"New string : \"<<s<<endl;\\n                    }\\n                    if(s.size()==0){\\n                    // cout<<\"String empty, hence done\"<<endl;\\n                    break;\\n                    }\\n                }\\n                if(flag==false){\\n                    // cout<<\"No removal this time, hence done\"<<endl;\\n                    break;\\n                }\\n                if(s.size()==0){\\n                    // cout<<\"String empty, hence done\"<<endl;\\n                    break;\\n                }\\n            }\\n\\n            return s;\\n        }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2792782,
                "title": "1544-make-the-string-great",
                "content": "**Runtime: 0 ms, faster than 100.00% of C++ online submissions for Make The String Great.\\nMemory Usage: 7.1 MB, less than 8.20% of C++ online submissions for Make The String Great.**\\n\\n```\\n string makeGood(string s) {\\n        \\n        stack<char>st;\\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n            //if stack is empty push element \\n            if(st.empty()){\\n                st.push(s[i]);\\n                continue;\\n            }\\n            \\n            //else check if the difference of stack\\'s top element and char is 32, if yes then remove the top most element of stack and if not then push char into the stack\\n            else{\\n                if(abs(st.top() - s[i])== 32){\\n                    st.pop();\\n                }\\n                else{\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        \\n        //Now insert the stack elements in string ans until the stack is empty and return\\n        string ans;\\n        while(!st.empty()){\\n            ans = st.top() + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Time Complexity = O(n)\\nSpace Complexity = O(n)**",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n string makeGood(string s) {\\n        \\n        stack<char>st;\\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n            //if stack is empty push element \\n            if(st.empty()){\\n                st.push(s[i]);\\n                continue;\\n            }\\n            \\n            //else check if the difference of stack\\'s top element and char is 32, if yes then remove the top most element of stack and if not then push char into the stack\\n            else{\\n                if(abs(st.top() - s[i])== 32){\\n                    st.pop();\\n                }\\n                else{\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        \\n        //Now insert the stack elements in string ans until the stack is empty and return\\n        string ans;\\n        while(!st.empty()){\\n            ans = st.top() + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2792716,
                "title": "easy-solution-one-pass-96-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        idx =0\\n        while(idx+1<len(s)):\\n            if(abs(ord(s[idx])-ord(s[idx+1]))==32):\\n                s= s[:idx]+s[idx+2:]\\n                idx =0\\n            else:\\n                idx+=1\\n        return s\\n\\n\\n\\n        \\n        \\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        idx =0\\n        while(idx+1<len(s)):\\n            if(abs(ord(s[idx])-ord(s[idx+1]))==32):\\n                s= s[:idx]+s[idx+2:]\\n                idx =0\\n            else:\\n                idx+=1\\n        return s\\n\\n\\n\\n        \\n        \\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792529,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        while(true) {\\n            int upd = 0;\\n            for(int i=1; i<s.size(); i++) {\\n                if(s[i-1]-\\'a\\' == s[i]-\\'A\\' or s[i-1]-\\'A\\' == s[i]-\\'a\\') {\\n                    s.erase(i-1, 2);\\n                    upd = 1;\\n                    break;\\n                }\\n            }\\n            if(!upd) break;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        while(true) {\\n            int upd = 0;\\n            for(int i=1; i<s.size(); i++) {\\n                if(s[i-1]-\\'a\\' == s[i]-\\'A\\' or s[i-1]-\\'A\\' == s[i]-\\'a\\') {\\n                    s.erase(i-1, 2);\\n                    upd = 1;\\n                    break;\\n                }\\n            }\\n            if(!upd) break;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792482,
                "title": "c-simple-stringbuilder-only-solution",
                "content": "```\\npublic class Solution {\\n    public string MakeGood(string s) {\\n        var sb = new StringBuilder();\\n        foreach (var c in s)\\n            if (sb.Length > 0 && Math.Abs(sb[^1]-c) == 32)\\n                    sb.Length--;\\n                else\\n                    sb.Append(c);\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String",
                    "Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public string MakeGood(string s) {\\n        var sb = new StringBuilder();\\n        foreach (var c in s)\\n            if (sb.Length > 0 && Math.Abs(sb[^1]-c) == 32)\\n                    sb.Length--;\\n                else\\n                    sb.Append(c);\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791897,
                "title": "easy-c-solution-0-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a stack and traverse over the string: \\n1. If the stack is empty then push the character in the stack. \\n2. If the element at the top of the stack is lowercase letter and next character in the string is same upper case letter or vice-versa then pop that character from the stack. \\n3. Otherwise push the character onto the stack.\\n\\nThe characters present in the stack forms the good string.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char>st;\\n        for (int i =0  ; i < s.size() ; i++)\\n        {\\n            if (st.size() == 0)\\n            {\\n                st.push(s[i]);\\n            }\\n            else if (st.top() == (s[i]+32) || st.top()+32 == s[i])\\n            st.pop();\\n            else\\n            st.push(s[i]);\\n        }\\n        string ans = \"\";\\n        while(!st.empty())\\n        {\\n            ans.insert(ans.begin(), st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char>st;\\n        for (int i =0  ; i < s.size() ; i++)\\n        {\\n            if (st.size() == 0)\\n            {\\n                st.push(s[i]);\\n            }\\n            else if (st.top() == (s[i]+32) || st.top()+32 == s[i])\\n            st.pop();\\n            else\\n            st.push(s[i]);\\n        }\\n        string ans = \"\";\\n        while(!st.empty())\\n        {\\n            ans.insert(ans.begin(), st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791620,
                "title": "o-n-stack-make-the-string-great",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stack=new Stack<>();\\n       \\n        for(int i=0;i<s.length();i++)\\n        {\\n            \\n            if(stack.size()>0&&stack.peek()!=s.charAt(i)){\\n               String t1=\"\"+stack.peek();\\n               String t2=\"\"+s.charAt(i);\\n                if(t1.toLowerCase().equals(t2.toLowerCase()))stack.pop();\\n                else stack.push(s.charAt(i));\\n            }\\n            else\\n               stack.push(s.charAt(i));  \\n            \\n        }\\n        String str=\"\";\\n        while(stack.size()>0){\\n            str=stack.pop()+str;\\n        }\\n        return str;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stack=new Stack<>();\\n       \\n        for(int i=0;i<s.length();i++)\\n        {\\n            \\n            if(stack.size()>0&&stack.peek()!=s.charAt(i)){\\n               String t1=\"\"+stack.peek();\\n               String t2=\"\"+s.charAt(i);\\n                if(t1.toLowerCase().equals(t2.toLowerCase()))stack.pop();\\n                else stack.push(s.charAt(i));\\n            }\\n            else\\n               stack.push(s.charAt(i));  \\n            \\n        }\\n        String str=\"\";\\n        while(stack.size()>0){\\n            str=stack.pop()+str;\\n        }\\n        return str;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791614,
                "title": "java-easy-solution-using-stacks",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        int n = s.length();\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(st.size()!=0){\\n                char ch2 = st.peek();\\n                if(Math.abs(ch-ch2) == 32) st.pop();  //abs(\\'a\\'-\\'A\\') = abs(\\'A\\'-\\'a\\') = abs(\\'z\\'-\\'Z\\')... = 32\\n                \\n                else st.push(ch);\\n            }\\n            else st.push(ch);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(st.size()!=0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public String makeGood(String s) {\\n        int n = s.length();\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(st.size()!=0){\\n                char ch2 = st.peek();\\n                if(Math.abs(ch-ch2) == 32) st.pop();  //abs(\\'a\\'-\\'A\\') = abs(\\'A\\'-\\'a\\') = abs(\\'z\\'-\\'Z\\')... = 32\\n                \\n                else st.push(ch);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2791602,
                "title": "java-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse the string and add character of string to the stack if it is empty , if stack is not empty check the difference of peek value of stack and character of string is 32 or not if it is then pop the character from the stack\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n      \\n        Stack<Character> st = new Stack<>();\\n        for(int i = 0;i<s.length();i++){\\n           \\n            if(!st.isEmpty() && Math.abs(st.peek()-s.charAt(i))==32) st.pop();\\n            else st.push(s.charAt(i));\\n        }\\n        String ans = \"\";\\n        while(!st.isEmpty()){\\n            ans += st.peek()+\"\";\\n            st.pop();\\n        }\\n        StringBuilder sb = new StringBuilder(ans);\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n      \\n        Stack<Character> st = new Stack<>();\\n        for(int i = 0;i<s.length();i++){\\n           \\n            if(!st.isEmpty() && Math.abs(st.peek()-s.charAt(i))==32) st.pop();\\n            else st.push(s.charAt(i));\\n        }\\n        String ans = \"\";\\n        while(!st.isEmpty()){\\n            ans += st.peek()+\"\";\\n            st.pop();\\n        }\\n        StringBuilder sb = new StringBuilder(ans);\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791154,
                "title": "beats-100-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string &s) {\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(abs(int(s[i+1]) - int(s[i])) == 32)\\n                s.erase(i,2),i=max(-1,i-2);\\n        }\\n        return s;\\n    }\\n};\\n// s.erase(i,2) will erase 2 letter from ith position\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string &s) {\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(abs(int(s[i+1]) - int(s[i])) == 32)\\n                s.erase(i,2),i=max(-1,i-2);\\n        }\\n        return s;\\n    }\\n};\\n// s.erase(i,2) will erase 2 letter from ith position\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791148,
                "title": "python3-stack-simple",
                "content": "# Complexity\\n- Time complexity: $$O(N)$$\\n\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n\\n        stack = []\\n        i = 0\\n\\n        def check(s1, s2):\\n            return abs(ord(s1)-ord(s2)) == 32\\n\\n        for i in range(len(s)):\\n            if not stack:\\n                stack.append(s[i])\\n                continue\\n\\n            l = stack[-1]\\n            r = s[i]\\n\\n            if check(l, r):\\n                stack.pop()\\n                continue\\n            \\n            stack.append(r)\\n        \\n        return \"\".join(stack)\\n```\\n\\n\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n\\n        stack = []\\n        i = 0\\n\\n        for i in range(len(s)):\\n            if not stack:\\n                stack.append(s[i])\\n                continue\\n\\n            l = stack[-1]\\n            r = s[i]\\n\\n            if (l.isupper() and l.lower() == r) or (l.islower() and l.upper() == r):\\n                stack.pop()\\n                continue\\n            \\n            stack.append(r)\\n        \\n        return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n\\n        stack = []\\n        i = 0\\n\\n        def check(s1, s2):\\n            return abs(ord(s1)-ord(s2)) == 32\\n\\n        for i in range(len(s)):\\n            if not stack:\\n                stack.append(s[i])\\n                continue\\n\\n            l = stack[-1]\\n            r = s[i]\\n\\n            if check(l, r):\\n                stack.pop()\\n                continue\\n            \\n            stack.append(r)\\n        \\n        return \"\".join(stack)\\n```\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n\\n        stack = []\\n        i = 0\\n\\n        for i in range(len(s)):\\n            if not stack:\\n                stack.append(s[i])\\n                continue\\n\\n            l = stack[-1]\\n            r = s[i]\\n\\n            if (l.isupper() and l.lower() == r) or (l.islower() and l.upper() == r):\\n                stack.pop()\\n                continue\\n            \\n            stack.append(r)\\n        \\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791107,
                "title": "c-simple-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n       while(1)\\n       {\\n           stack<char>st;\\n           st.push(s[0]);\\n           int ind=0;\\n           int a=s.size();\\n           for(int i=1;i<s.size();i++)\\n           {\\n               if(s[i]+32==st.top() or s[i]-32==st.top())\\n               {\\n                   s.erase(s.begin()+i);\\n                   s.erase(s.begin()+ind);\\n                   st.pop();\\n               }\\n               ind=i;\\n               st.push(s[i]);\\n           }\\n           if(a==s.size())\\n               return s;\\n       }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n       while(1)\\n       {\\n           stack<char>st;\\n           st.push(s[0]);\\n           int ind=0;\\n           int a=s.size();\\n           for(int i=1;i<s.size();i++)\\n           {\\n               if(s[i]+32==st.top() or s[i]-32==st.top())\\n               {\\n                   s.erase(s.begin()+i);\\n                   s.erase(s.begin()+ind);\\n                   st.pop();\\n               }\\n               ind=i;\\n               st.push(s[i]);\\n           }\\n           if(a==s.size())\\n               return s;\\n       }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791045,
                "title": "python3-stack-easy-smart-way-with-ascii-code-to-know-upper-lower-or-lower-upper-pairs",
                "content": "### Solution\\n1 Use the stack to eliminate the pairs defined in the problem -- `s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case  or **vice versa**`\\n2 In the loop, we check the pairs by knowing the difference of the two chars == `(ord(\\'a\\') - ord(\\'A\\'))`\\n\\n65 A\\n66 B\\n....\\n90 Z\\n91 [\\n92 \\\\\\n93 ]\\n...\\n97 a\\n98 b\\n\\nThat\\'s it!\\n\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        n = len(s)\\n        stack = []\\n        # for i in range(n - 1):\\n        for i in range(n):  # CAUTIOUS!\\n            if stack and abs(ord(stack[-1]) - ord(s[i])) == (ord(\\'a\\') - ord(\\'A\\')):\\n                stack.pop()\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        n = len(s)\\n        stack = []\\n        # for i in range(n - 1):\\n        for i in range(n):  # CAUTIOUS!\\n            if stack and abs(ord(stack[-1]) - ord(s[i])) == (ord(\\'a\\') - ord(\\'A\\')):\\n                stack.pop()\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790871,
                "title": "easy-solution-using-c",
                "content": "\" \"\\nstring makeGood(string s) \\n    {\\n   \\n\\n\\n\\t if(s==\"\")\\n            return s;\\n        if(s.size()==1)\\n            return s;\\n        int i=0;\\n        while(i<(s.size()-1) && (s.size()!=0))\\n        {\\n           if((s[i]>=65 && s[i]<=90)&& (s[i+1]>=65 && s[i+1]<=90))\\n           {\\n               i++;\\n               \\n           }\\n           else  if((s[i]>=97 && s[i]<=122)&& (s[i+1]>=97 && s[i+1]<=122))\\n           {\\n               i++;\\n               \\n           }\\n            else \\n            {\\n                \\n               int l=s[i];\\n               int u=s[i+1];\\n               \\n               if(l==u+32 || l+32==u)\\n               {\\n                   \\n                  s.erase(s.begin()+i,s.begin()+i+2);\\n                \\n                  i=0;\\n                 \\n                  \\n                  \\n                  \\n               }\\n                else\\n                {\\n                    i++;\\n                }\\n            }\\n            \\n            \\n        }\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "\" \"\\nstring makeGood(string s) \\n    {\\n   \\n\\n\\n\\t if(s==\"\")\\n            return s;\\n        if(s.size()==1)\\n            return s;\\n        int i=0;\\n        while(i<(s.size()-1) && (s.size()!=0))\\n        {\\n           if((s[i]>=65 && s[i]<=90)&& (s[i+1]>=65 && s[i+1]<=90))\\n           {\\n               i++;\\n               \\n           }\\n           else  if((s[i]>=97 && s[i]<=122)&& (s[i+1]>=97 && s[i+1]<=122))\\n           {\\n               i++;\\n               \\n           }\\n            else \\n            {\\n                \\n               int l=s[i];\\n               int u=s[i+1];\\n               \\n               if(l==u+32 || l+32==u)\\n               {\\n                   \\n                  s.erase(s.begin()+i,s.begin()+i+2);\\n                \\n                  i=0;\\n                 \\n                  \\n                  \\n                  \\n               }\\n                else\\n                {\\n                    i++;\\n                }\\n            }\\n            \\n            \\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2790816,
                "title": "ruby-no-brainer",
                "content": "# Code\\n```\\n# BAD = /aA|Aa|bB|Bb|.../\\nBAD = Regexp.compile((\\'a\\'..\\'z\\').flat_map{|c| [\"#{c}#{c.upcase}\", \"#{c.upcase}#{c}\"]}.join(\\'|\\'))\\n\\n# @param {String} s\\n# @return {String}\\ndef make_good(s)\\n  s.gsub!(BAD, \"\") ? make_good(s) : s\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# BAD = /aA|Aa|bB|Bb|.../\\nBAD = Regexp.compile((\\'a\\'..\\'z\\').flat_map{|c| [\"#{c}#{c.upcase}\", \"#{c.upcase}#{c}\"]}.join(\\'|\\'))\\n\\n# @param {String} s\\n# @return {String}\\ndef make_good(s)\\n  s.gsub!(BAD, \"\") ? make_good(s) : s\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2790787,
                "title": "simple-python-solution-faster-than-99-57-stack-implementation",
                "content": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        st = []\\n        for i in s:\\n            if st:\\n                if i.isupper() and st[-1].islower() and st[-1].upper() == i: \\n                    st.pop()\\n                    continue\\n                elif i.islower() and st[-1].isupper() and st[-1].lower() == i:\\n                    st.pop()\\n                    continue\\n                else:\\n                    st.append(i)\\n                    continue \\n            else:\\n                st.append(i)\\n                continue\\n        return \"\".join(st)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        st = []\\n        for i in s:\\n            if st:\\n                if i.isupper() and st[-1].islower() and st[-1].upper() == i: \\n                    st.pop()\\n                    continue\\n                elif i.islower() and st[-1].isupper() and st[-1].lower() == i:\\n                    st.pop()\\n                    continue\\n                else:\\n                    st.append(i)\\n                    continue \\n            else:\\n                st.append(i)\\n                continue\\n        return \"\".join(st)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716661,
                "title": "js-very-easy-solution",
                "content": "```\\nvar makeGood = function(s) {\\n    const stack = [s[0]];\\n    \\n    for (let i = 1; i < s.length; i++) {\\n        if ([32, -32].includes(s.charCodeAt(i) - s.charCodeAt(i - 1))) {\\n            s = s.substring(0, i - 1) + s.substring(i + 1, s.length);\\n            i-=2;\\n            stack.pop();\\n        } else {\\n            stack.push(s[i]);\\n        }\\n    }\\n    \\n    return stack.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar makeGood = function(s) {\\n    const stack = [s[0]];\\n    \\n    for (let i = 1; i < s.length; i++) {\\n        if ([32, -32].includes(s.charCodeAt(i) - s.charCodeAt(i - 1))) {\\n            s = s.substring(0, i - 1) + s.substring(i + 1, s.length);\\n            i-=2;\\n            stack.pop();\\n        } else {\\n            stack.push(s[i]);\\n        }\\n    }\\n    \\n    return stack.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2619198,
                "title": "js-with-explanation-easy-to-understand-stack",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/09/1544-make-string-great-stack.html\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nconst makeGood = function (s) {\\n    if (s.length == 1) return s;\\n    let stack = [s[0]];\\n    for (let i = 1; i < s.length; i++) {\\n        if (stack.length == 0){\\n            stack.push(s[i]);\\n        }  else {\\n            let end = stack[stack.length - 1];\\n            if ((isUpperCase(end) && isLowerCase(s[i]) && isEqual(end, s[i])) || (isLowerCase(end) && isUpperCase(s[i]) && isEqual(end, s[i]))) {\\n                stack.pop();\\n                continue;\\n            }\\n            stack.push(s[i]);\\n        }\\n    }\\n    return stack.join(\"\");\\n};\\n\\n\\nconst isEqual = (s1, s2) => {\\n    if (s1.toLowerCase() == s2.toLowerCase()) {\\n        return true;\\n    }\\n    return false;\\n};\\n\\nconst isUpperCase = (character) => {\\n    if (character == character.toUpperCase()) {\\n        return true;\\n    }\\n    return false;\\n};\\n\\nconst isLowerCase = (character) => {\\n    if (character == character.toLowerCase()) {\\n        return true;\\n    }\\n    return false;\\n};\\n```\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nconst makeGood = function (s) {\\n    if (s.length == 1) return s;\\n    let stack = [s[0]];\\n    for (let i = 1; i < s.length; i++) {\\n        if (stack.length == 0){\\n            stack.push(s[i]);\\n        }  else {\\n            let end = stack[stack.length - 1];\\n            if ((isUpperCase(end) && isLowerCase(s[i]) && isEqual(end, s[i])) || (isLowerCase(end) && isUpperCase(s[i]) && isEqual(end, s[i]))) {\\n                stack.pop();\\n                continue;\\n            }\\n            stack.push(s[i]);\\n        }\\n    }\\n    return stack.join(\"\");\\n};\\n\\n\\nconst isEqual = (s1, s2) => {\\n    if (s1.toLowerCase() == s2.toLowerCase()) {\\n        return true;\\n    }\\n    return false;\\n};\\n\\nconst isUpperCase = (character) => {\\n    if (character == character.toUpperCase()) {\\n        return true;\\n    }\\n    return false;\\n};\\n\\nconst isLowerCase = (character) => {\\n    if (character == character.toLowerCase()) {\\n        return true;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2606408,
                "title": "c-stack-solution",
                "content": "class Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n      stack<char>st;\\n      int n=s.length();\\n      for(int i=0;i<s.length();i++)\\n      {\\n          int flag=0;\\n        if(!st.empty()&&(char(s[i]-32)==char(st.top())||char(s[i]+32)==char(st.top())))\\n        {\\n        flag=1;\\n        st.pop();\\n        }\\n        else\\n        {\\n        st.push(s[i]);\\n        }\\n      }\\n    string ans;\\n        while(!st.empty())\\n        {\\n           ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n      stack<char>st;\\n      int n=s.length();\\n      for(int i=0;i<s.length();i++)\\n      {\\n          int flag=0;\\n        if(!st.empty()&&(char(s[i]-32)==char(st.top())||char(s[i]+32)==char(st.top())))\\n        {\\n        flag=1;\\n        st.pop();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2606399,
                "title": "c-solution-using-stack",
                "content": "class Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack<char>st;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                int flag=0;\\n                if(abs(st.top()-s[i])==32)\\n                {\\n                flag=1;\\n                st.pop();\\n                }\\n                if(flag==0)\\n            st.push(s[i]);\\n            }\\n        i++;\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans=st.top()+ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack<char>st;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2457890,
                "title": "c-t-c-o-n-s-c-o-n-stack-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        \\n         stack<char>stk;\\n         for(int i=0;i<s.length();i++)\\n         {\\n             if(stk.size()==0)\\n             {\\n                stk.push(s[i]);   \\n             }\\n             else if(stk.size()>0)\\n             {\\n                char currchar=s[i];\\n                 \\n                char upperchar=toupper(currchar);\\n                char lowerchar=tolower(currchar);\\n                 \\n                if(stk.top()==upperchar and s[i]==lowerchar)\\n                {\\n                    //code\\n                    stk.pop();\\n                }\\n                else if(stk.top()==lowerchar and s[i]==upperchar)\\n                {\\n                    stk.pop();\\n                }\\n                else  //upper upper lower lower or not equal\\n                {\\n                    stk.push(s[i]);\\n                }\\n                 \\n             }\\n         }\\n        string ans=\"\";\\n        while(!stk.empty())\\n        {\\n            ans=stk.top()+ans;\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        \\n         stack<char>stk;\\n         for(int i=0;i<s.length();i++)\\n         {\\n             if(stk.size()==0)\\n             {\\n                stk.push(s[i]);   \\n             }\\n             else if(stk.size()>0)\\n             {\\n                char currchar=s[i];\\n                 \\n                char upperchar=toupper(currchar);\\n                char lowerchar=tolower(currchar);\\n                 \\n                if(stk.top()==upperchar and s[i]==lowerchar)\\n                {\\n                    //code\\n                    stk.pop();\\n                }\\n                else if(stk.top()==lowerchar and s[i]==upperchar)\\n                {\\n                    stk.pop();\\n                }\\n                else  //upper upper lower lower or not equal\\n                {\\n                    stk.push(s[i]);\\n                }\\n                 \\n             }\\n         }\\n        string ans=\"\";\\n        while(!stk.empty())\\n        {\\n            ans=stk.top()+ans;\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381942,
                "title": "java-easy-solution-o-n",
                "content": "class Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> st = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(!st.empty()) {\\n                if(  Math.abs(s.charAt(i) - st.peek()) ==32  ){\\n                    st.pop();\\n                    continue;\\n                } \\n            }\\n            st.push(s.charAt(i));\\n        }\\n        String ans=\"\";\\n         while(!st.empty())\\n            ans=st.pop()+ans;\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> st = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(!st.empty()) {\\n                if(  Math.abs(s.charAt(i) - st.peek()) ==32  ){\\n                    st.pop();\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2185879,
                "title": "java-easy-solution-98-44-faster",
                "content": "![image](https://assets.leetcode.com/users/images/940e35ab-c7fe-4c60-9c59-884c92c8c4a9_1655961391.3109472.png)\\n**Please UpVote If you like**\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        for(int i=0; i<sb.length()-1; i++)\\n        {\\n\\t\\t// Checking if two adjacent characters are in upper and lower case. \\n\\t\\t//If both are same then their ASCII difference will always be 32 (For Ex - A->65 and a-> 97 therefore |65-97| = 32) \\n            if(Math.abs((int)sb.charAt(i) - (int)sb.charAt(i+1)) == 32)  \\n            {\\n                sb.deleteCharAt(i);\\n                sb.deleteCharAt(i);\\n                if(i == 0)\\n                    --i;\\n                else\\n                    i = i-2;\\n            }\\n            if(sb.length() == 0)\\n                return \"\";\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        for(int i=0; i<sb.length()-1; i++)\\n        {\\n\\t\\t// Checking if two adjacent characters are in upper and lower case. \\n\\t\\t//If both are same then their ASCII difference will always be 32 (For Ex - A->65 and a-> 97 therefore |65-97| = 32) \\n            if(Math.abs((int)sb.charAt(i) - (int)sb.charAt(i+1)) == 32)  \\n            {\\n                sb.deleteCharAt(i);\\n                sb.deleteCharAt(i);\\n                if(i == 0)\\n                    --i;\\n                else\\n                    i = i-2;\\n            }\\n            if(sb.length() == 0)\\n                return \"\";\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939297,
                "title": "very-simple-solution-beats-96-in-java",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        if(s.length()==0 || s.length()==1)return s;\\n        int i=0;\\n\\t\\t\\n        while(i<s.length()-1){\\n            char c=s.charAt(i);\\n            char ch=s.charAt(i+1);\\n            if(c-\\'a\\'==ch-\\'A\\' || c-\\'A\\'==ch-\\'a\\'){\\n                if(i==0){\\n                    s=s.substring(2);\\n                }\\n                else{\\n                    s=s.substring(0,i)+s.substring(i+2);\\n                }\\n                i--;\\n                if(i<0){\\n                    i=0;\\n                }\\n            }\\n            else{\\n                i++;\\n            }  \\n        }\\n        return s;\\n    }\\n}",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\n    public String makeGood(String s) {\\n        if(s.length()==0 || s.length()==1)return s;\\n        int i=0;\\n\\t\\t\\n        while(i<s.length()-1){\\n            char c=s.charAt(i);\\n            char ch=s.charAt(i+1);\\n            if(c-\\'a\\'==ch-\\'A\\' || c-\\'A\\'==ch-\\'a\\'){\\n                if(i==0){\\n                    s=s.substring(2);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1569653,
                "title": "very-easy-java-solution-o-n",
                "content": "\\nclass Solution {\\n    public String makeGood(String s) {\\n       \\n         StringBuilder stringBuilder = new StringBuilder(s);\\n        \\n        for (int i = 1; i < stringBuilder.length(); i++) {\\n            if (Math.abs((int) stringBuilder.charAt(i) - (int) stringBuilder.charAt(i - 1)) == 32) {\\n                stringBuilder.deleteCharAt(i - 1);\\n\\t\\t\\t\\t//after deleting index (i-1) , stringBuilder\\'s length shrinks so again delete index (i - 1)\\n                stringBuilder.deleteCharAt(i - 1);\\n                i = 0;\\n            }\\n        }\\n        return stringBuilder.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String makeGood(String s) {\\n       \\n         StringBuilder stringBuilder = new StringBuilder(s);\\n        \\n        for (int i = 1; i < stringBuilder.length(); i++) {\\n            if (Math.abs((int) stringBuilder.charAt(i) - (int) stringBuilder.charAt(i - 1)) == 32) {\\n                stringBuilder.deleteCharAt(i - 1);\\n\\t\\t\\t\\t//after deleting index (i-1) , stringBuilder\\'s length shrinks so again delete index (i - 1)\\n                stringBuilder.deleteCharAt(i - 1);\\n                i = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1526033,
                "title": "java-simple-solution-and-100-faster",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder(s);\\n        \\n        for(int i=0; i<str.length()-1;){\\n            if(Math.abs(str.charAt(i)-str.charAt(i+1))==32){\\n                str.delete(i, i+2);\\n                i= i-1>0?i-1:0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        \\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder(s);\\n        \\n        for(int i=0; i<str.length()-1;){\\n            if(Math.abs(str.charAt(i)-str.charAt(i+1))==32){\\n                str.delete(i, i+2);\\n                i= i-1>0?i-1:0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        \\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359253,
                "title": "two-simple-java-solutions",
                "content": "\\nHere every character should be checked with last visited character so if they are same character(either one is in lowercase and other one is in upercase) then we have to remove both the character from our final string. \\n\\nSolution 1: Using stack\\ncheck each character with stack\\'s peek character. if they above condition matches then pop the character otherwise push current character into stack.\\n\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            if(!stack.isEmpty() && Math.abs(s.charAt(i) - stack.peek())==32) \\n                stack.pop();\\n            else\\n                stack.push(s.charAt(i));\\n        }\\n        while(!stack.isEmpty()) {\\n            str.insert(0, stack.pop());\\n        }\\n        return str.toString();\\n    }\\n}\\n```\\n\\n\\nSolution 2: \\nIn the above solution we are comparing only last visited character with current character so instead of using stack, we can directly use final string and compare last appended character with current character.\\n\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int size=0;\\n        for(int i=0;i<s.length();i++){\\n            size = str.length();\\n            if(str.length()>0 && Math.abs(s.charAt(i) - str.charAt(size-1))==32) {\\n                str.deleteCharAt(size-1);\\n            }\\n            else{\\n                str.append(s.charAt(i));\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            if(!stack.isEmpty() && Math.abs(s.charAt(i) - stack.peek())==32) \\n                stack.pop();\\n            else\\n                stack.push(s.charAt(i));\\n        }\\n        while(!stack.isEmpty()) {\\n            str.insert(0, stack.pop());\\n        }\\n        return str.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int size=0;\\n        for(int i=0;i<s.length();i++){\\n            size = str.length();\\n            if(str.length()>0 && Math.abs(s.charAt(i) - str.charAt(size-1))==32) {\\n                str.deleteCharAt(size-1);\\n            }\\n            else{\\n                str.append(s.charAt(i));\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333217,
                "title": "simple-c-using-stack-0ms",
                "content": "```\\nstring makeGood(string s) {\\n        stack<char> Stack;\\n        for(int i=0;i<s.length();i++){\\n            if(Stack.empty())\\n                Stack.push(s[i]);\\n            else{\\n                if(abs(Stack.top()-s[i])==32)\\n                    Stack.pop();\\n                else\\n                    Stack.push(s[i]);\\n            }\\n        }\\n        string ret;\\n        while(!Stack.empty()){\\n            ret=Stack.top()+ret;\\n            Stack.pop();\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring makeGood(string s) {\\n        stack<char> Stack;\\n        for(int i=0;i<s.length();i++){\\n            if(Stack.empty())\\n                Stack.push(s[i]);\\n            else{\\n                if(abs(Stack.top()-s[i])==32)\\n                    Stack.pop();\\n                else\\n                    Stack.push(s[i]);\\n            }\\n        }\\n        string ret;\\n        while(!Stack.empty()){\\n            ret=Stack.top()+ret;\\n            Stack.pop();\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1209460,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n     Stack<Character> stk=new Stack<Character>();\\n        char[] ch=s.toCharArray();\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(Character.isUpperCase(ch[i]))\\n            {\\n                char curr=Character.toLowerCase(ch[i]);\\n                if(!stk.empty()&&curr==stk.peek())\\n                {\\n                    stk.pop();\\n                    continue;\\n                }\\n            }\\n            else\\n            {\\n                char curr=Character.toUpperCase(ch[i]);\\n                if(!stk.empty()&&curr==stk.peek())\\n                {\\n                    stk.pop();\\n                    continue;\\n                }\\n            }\\n            \\n            stk.push(ch[i]);\\n        }\\n        StringBuilder res=new StringBuilder();\\n        while(!stk.empty())\\n        {\\n            res.append(stk.pop());\\n        }\\n        return res.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n     Stack<Character> stk=new Stack<Character>();\\n        char[] ch=s.toCharArray();\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(Character.isUpperCase(ch[i]))\\n            {\\n                char curr=Character.toLowerCase(ch[i]);\\n                if(!stk.empty()&&curr==stk.peek())\\n                {\\n                    stk.pop();\\n                    continue;\\n                }\\n            }\\n            else\\n            {\\n                char curr=Character.toUpperCase(ch[i]);\\n                if(!stk.empty()&&curr==stk.peek())\\n                {\\n                    stk.pop();\\n                    continue;\\n                }\\n            }\\n            \\n            stk.push(ch[i]);\\n        }\\n        StringBuilder res=new StringBuilder();\\n        while(!stk.empty())\\n        {\\n            res.append(stk.pop());\\n        }\\n        return res.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190421,
                "title": "java-solution-100",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.length(); i++){\\n            if(sb.length() == 0 || Math.abs((sb.charAt(sb.length() - 1) - s.charAt(i))) != 32){\\n                sb.append(s.charAt(i));\\n            }else{\\n                sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.length(); i++){\\n            if(sb.length() == 0 || Math.abs((sb.charAt(sb.length() - 1) - s.charAt(i))) != 32){\\n                sb.append(s.charAt(i));\\n            }else{\\n                sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099787,
                "title": "0-ms-faster-than-100-00-of-c-using-stack-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char>st;\\n        string ans=\"\";\\n       if(!s.empty()){\\n          for (int i = 0; i < s.size(); i++) {\\n            if (st.empty()) st.push(s[i]);\\n            else if (abs(s[i] - st.top()) == 32) st.pop();\\n            else st.push(s[i]);\\n          }\\n          while(!st.empty()){\\n              ans+=st.top();\\n              st.pop();\\n          }\\n            reverse(ans.begin(),ans.end());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char>st;\\n        string ans=\"\";\\n       if(!s.empty()){\\n          for (int i = 0; i < s.size(); i++) {\\n            if (st.empty()) st.push(s[i]);\\n            else if (abs(s[i] - st.top()) == 32) st.pop();\\n            else st.push(s[i]);\\n          }\\n          while(!st.empty()){\\n              ans+=st.top();\\n              st.pop();\\n          }\\n            reverse(ans.begin(),ans.end());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092337,
                "title": "c-solution-simple-one-pass-version",
                "content": "```\\n\\nint badPair(char ch1, char ch2){\\n    /* Wacky ASCII assumption version:\\n    return (ch1 ^ ch2) == 0x20; */\\n    \\n    return ch1 != ch2 && tolower(ch1) == tolower(ch2);\\n}\\n\\nchar * makeGood(char * s){\\n    const char * in = s;\\n    char * out = s;\\n    \\n    for(; *in != \\'\\\\0\\'; ++in){\\n        if(out > s && badPair(*(out - 1), *in)){\\n            --out;\\n        }else{\\n            *(out++) = *in;\\n        }\\n    }\\n    \\n    *out = \\'\\\\0\\';\\n    \\n    return s;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint badPair(char ch1, char ch2){\\n    /* Wacky ASCII assumption version:\\n    return (ch1 ^ ch2) == 0x20; */\\n    \\n    return ch1 != ch2 && tolower(ch1) == tolower(ch2);\\n}\\n\\nchar * makeGood(char * s){\\n    const char * in = s;\\n    char * out = s;\\n    \\n    for(; *in != \\'\\\\0\\'; ++in){\\n        if(out > s && badPair(*(out - 1), *in)){\\n            --out;\\n        }else{\\n            *(out++) = *in;\\n        }\\n    }\\n    \\n    *out = \\'\\\\0\\';\\n    \\n    return s;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1044617,
                "title": "my-python-solution",
                "content": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n\\t\\n        stack_that = []\\n\\t\\t\\n        for c in s:\\n\\t\\t\\tif stack_that and stack_that[-1] == c.swapcase(): #saw this on a posted solution\\n\\t\\t# if stack_that and stack_that[-1] == chr(ord(c) ^ 32): # cool trick on a posted solution\\n         # if stack_that and abs(ord(stack_that[-1]) - ord(c)) == 32:  # my original approach\\n                stack_that.pop()\\n            else:\\n                stack_that.append(c)\\n                \\n        return \\'\\'.join(stack_that)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n\\t\\n        stack_that = []\\n\\t\\t\\n        for c in s:\\n\\t\\t\\tif stack_that and stack_that[-1] == c.swapcase(): #saw this on a posted solution\\n\\t\\t# if stack_that and stack_that[-1] == chr(ord(c) ^ 32): # cool trick on a posted solution\\n         # if stack_that and abs(ord(stack_that[-1]) - ord(c)) == 32:  # my original approach\\n                stack_that.pop()\\n            else:\\n                stack_that.append(c)\\n                \\n        return \\'\\'.join(stack_that)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933041,
                "title": "simple-java-brute-force",
                "content": "```\\npublic String makeGood(String s) {\\n        for(int i=0;i>=0 && i<s.length()-1;){\\n            if((s.charAt(i)+32==s.charAt(i+1) || s.charAt(i)-32==s.charAt(i+1))){\\n                s=s.substring(0, i) + s.substring(i+2); \\n                i--;\\n                if(i<0)i=0;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String makeGood(String s) {\\n        for(int i=0;i>=0 && i<s.length()-1;){\\n            if((s.charAt(i)+32==s.charAt(i+1) || s.charAt(i)-32==s.charAt(i+1))){\\n                s=s.substring(0, i) + s.substring(i+2); \\n                i--;\\n                if(i<0)i=0;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 852380,
                "title": "100-faster-solution-c-with-xor-explained",
                "content": "From the ASCII table, we see that there\\'s always a difference of exactly 32 between the value of a lowercase and uppercase letter. Therefore, if we do (UPPERCASE(of a letter i))^(lowercase(of  a letter i)), we get 32. I used that in my code to get 100% C++ faster Solution.\\n```\\nstd::string Solution::MakeStringGreat::makeGood(std::string s) const {\\n    if (s.empty()) return \"\";\\n    if (s.size() == 1) return s;\\n    for (int i = 0; i < static_cast<int>(s.size() - 1); ++i) {\\n        if ((s.at(i) ^ s.at(i + 1)) == 32) {\\n            s.erase(i,2); // erases two character starting from pos i.\\n            i = -1; // returns to the begin of s.\\n        }\\n    return s;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstd::string Solution::MakeStringGreat::makeGood(std::string s) const {\\n    if (s.empty()) return \"\";\\n    if (s.size() == 1) return s;\\n    for (int i = 0; i < static_cast<int>(s.size() - 1); ++i) {\\n        if ((s.at(i) ^ s.at(i + 1)) == 32) {\\n            s.erase(i,2); // erases two character starting from pos i.\\n            i = -1; // returns to the begin of s.\\n        }\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 825637,
                "title": "python-3-stack-based-o-n-time-and-o-n-space",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nIf the requirement is of using O(1) space, then don\\'t use stack. Implement the below algorithm by updating the input string s.\\n\\n**Explanation of below algo:**\\n2 characters are equal if after converting them to lowercase results True. And without conversion they return True. In this case, we are confident that this character can stay in our output.\\n\\nIf our new character and the top element in the stack are same character but different in cases, then don\\'t add the new character to the stack. Also remove the top element from the stack.\\n\\n```\\ndef makeGood(self, s: str) -> str:\\n\\tstack: = []\\n\\tfor i in range(len(s)):\\n\\t\\tif not stack: stack.append(s[i])                 # if stack is empty, then add our new character. We cannot compare empty stack with anything.\\n\\t\\telse:\\n\\t\\t\\tif s[i].lower()==stack[-1].lower() and s[i]!=stack[-1]:\\n\\t\\t\\t\\tstack.pop()\\n\\t\\t\\telse:\\n\\t\\t\\t\\tstack.append(s[i])\\n\\treturn \\'\\'.join(stack)\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\ndef makeGood(self, s: str) -> str:\\n\\tstack: = []\\n\\tfor i in range(len(s)):\\n\\t\\tif not stack: stack.append(s[i])                 # if stack is empty, then add our new character. We cannot compare empty stack with anything.\\n\\t\\telse:\\n\\t\\t\\tif s[i].lower()==stack[-1].lower() and s[i]!=stack[-1]:\\n\\t\\t\\t\\tstack.pop()\\n\\t\\t\\telse:\\n\\t\\t\\t\\tstack.append(s[i])\\n\\treturn \\'\\'.join(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 819101,
                "title": "simple-7-lines-code-in-python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack=[]\\n        for char in s:\\n            if stack and ((stack[-1].islower() and char==stack[-1].upper()) or (stack[-1].isupper() and char==stack[-1].lower())):\\n                stack.pop()\\n            else:\\n                stack.append(char)\\n        return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack=[]\\n        for char in s:\\n            if stack and ((stack[-1].islower() and char==stack[-1].upper()) or (stack[-1].isupper() and char==stack[-1].lower())):\\n                stack.pop()\\n            else:\\n                stack.append(char)\\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819077,
                "title": "php-solution-faster-than-100-4ms",
                "content": "**Simple solution and faster than 100%, takes only 4ms:**\\n* Start from the first to the penultimate char of the string.\\n* Compare the char with the next with **strcasecmp** because it\\'s case insensitive.\\n* If different or both (original) chars are equal continue (everything is good).\\n* Both chars are therefore not equal in upper/lowercase so use **substr_replace** to cut out both.\\n* Set iterator 2 steps back to continue with the last char (1 will be balanced through the $i++ of the loop) with a min of -1 (so the index is not getting smaller than 0) because through deletion of chars could be last char with next char getting bad.\\n\\n```\\n    function makeGood($s) {\\n\\t\\tfor ($i=0; $i<strlen ($s)-1; $i++) {\\n\\t\\t\\tif (strcasecmp($s[$i], $s[$i+1])!=0 || $s[$i]==$s[$i+1])\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t$s = substr_replace($s, \\'\\', $i, 2);\\n\\t\\t\\t$i = max(-1,$i-2);\\n\\t\\t}\\n\\t\\treturn $s;\\n\\t}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\n    function makeGood($s) {\\n\\t\\tfor ($i=0; $i<strlen ($s)-1; $i++) {\\n\\t\\t\\tif (strcasecmp($s[$i], $s[$i+1])!=0 || $s[$i]==$s[$i+1])\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t$s = substr_replace($s, \\'\\', $i, 2);\\n\\t\\t\\t$i = max(-1,$i-2);\\n\\t\\t}\\n\\t\\treturn $s;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 802261,
                "title": "c-stack-faster-than-98-34",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string kq = \"\";\\n        stack<char> temp;\\n        temp.push(s[0]);\\n        for(int i=1; i<s.length(); i++){\\n            if(temp.empty()) temp.push(s[i]);\\n            else{\\n                int ich = (int)s[i]; //ASCII of s[i]\\n                int itop = (int)temp.top(); //ASCII of temp.top()\\n                int cl = abs(ich - itop);  // ASCII upper - ASCII lower =32\\n                if(cl == 32) temp.pop();\\n                else temp.push(s[i]);\\n            }\\n        }\\n        while(!temp.empty()){\\n            kq = temp.top() + kq;\\n            temp.pop();\\n        }\\n        return kq;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string kq = \"\";\\n        stack<char> temp;\\n        temp.push(s[0]);\\n        for(int i=1; i<s.length(); i++){\\n            if(temp.empty()) temp.push(s[i]);\\n            else{\\n                int ich = (int)s[i]; //ASCII of s[i]\\n                int itop = (int)temp.top(); //ASCII of temp.top()\\n                int cl = abs(ich - itop);  // ASCII upper - ASCII lower =32\\n                if(cl == 32) temp.pop();\\n                else temp.push(s[i]);\\n            }\\n        }\\n        while(!temp.empty()){\\n            kq = temp.top() + kq;\\n            temp.pop();\\n        }\\n        return kq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786278,
                "title": "simple-java-solution-for-good-string",
                "content": "class Solution {\\n    public String makeGood(String s) {\\n\\n        Stack<Character> st= new Stack<>();\\n        char[] chars= s.toCharArray();\\n        for(int i=0;i<chars.length;i++){\\n            char currLetter=chars[i];\\n            if(!st.isEmpty()){\\n                char top=st.peek();\\n                int topLetter=top;\\n                 if( (currLetter+32)==top || (currLetter-32)==top){\\n                    st.pop();\\n                }else{\\n                    st.push(currLetter);\\n                }\\n            }else{\\n                st.push(currLetter);\\n            }\\n\\n        }\\n        StringBuilder sb= new StringBuilder();\\n        for(char s1:st){\\n            sb.append(Character.toString(s1));\\n        }\\n        return sb.toString();\\n\\n\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String makeGood(String s) {\\n\\n        Stack<Character> st= new Stack<>();\\n        char[] chars= s.toCharArray();\\n        for(int i=0;i<chars.length;i++){\\n            char currLetter=chars[i];\\n            if(!st.isEmpty()){\\n                char top=st.peek();\\n                int topLetter=top;\\n                 if( (currLetter+32)==top || (currLetter-32)==top){\\n                    st.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 783147,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Make The String Great.\\nMemory Usage: 2.1 MB, less than 100.00% of Go online submissions for Make The String Great.\\n\\n```go\\nfunc makeGood(s string) string {\\n    stack := []byte{}\\n    for i := 0; i < len(s); i++ {\\n        if len(stack) > 0 && abs(int(stack[len(stack) - 1]) - int(s[i])) == 32 {\\n            stack = stack[:len(stack) - 1]\\n        } else {\\n            stack = append(stack, s[i])\\n        }\\n    }\\n    return string(stack)\\n}\\n\\nfunc abs(n int) int {\\n    if n > 0 { return n }\\n    return -n\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc makeGood(s string) string {\\n    stack := []byte{}\\n    for i := 0; i < len(s); i++ {\\n        if len(stack) > 0 && abs(int(stack[len(stack) - 1]) - int(s[i])) == 32 {\\n            stack = stack[:len(stack) - 1]\\n        } else {\\n            stack = append(stack, s[i])\\n        }\\n    }\\n    return string(stack)\\n}\\n\\nfunc abs(n int) int {\\n    if n > 0 { return n }\\n    return -n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781161,
                "title": "swift-stack-solution-with-explanation",
                "content": "* The question asks us to make the string great by removing consecutive characters that are the same but are differently cased.\\n* Use a stack to store the characters of the given string.\\n* As you continue to the push the characters, check if the present character is the uppercased or the lowercased form of the last element pushed in the stack. If true, Pop the last element.\\n```\\nfunc makeGood(_ s: String) -> String {\\n    var stack : [Character] = []\\n    for c in s{\\n        if stack.isEmpty{\\n            stack.append(c)\\n        }\\n        else{\\n            if stack.last?.uppercased() == String(c) && stack.last!.isLowercase && c.isUppercase{\\n                stack.popLast()\\n            }\\n            else if stack.last?.lowercased() == String(c) && c.isLowercase && stack.last!.isUppercase{\\n                stack.popLast()\\n            }\\n            else{\\n                stack.append(c)\\n            }\\n        }\\n    }\\n    return String(stack)\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc makeGood(_ s: String) -> String {\\n    var stack : [Character] = []\\n    for c in s{\\n        if stack.isEmpty{\\n            stack.append(c)\\n        }\\n        else{\\n            if stack.last?.uppercased() == String(c) && stack.last!.isLowercase && c.isUppercase{\\n                stack.popLast()\\n            }\\n            else if stack.last?.lowercased() == String(c) && c.isLowercase && stack.last!.isUppercase{\\n                stack.popLast()\\n            }\\n            else{\\n                stack.append(c)\\n            }\\n        }\\n    }\\n    return String(stack)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781019,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        ## RC ##\\n        ## APPROACH : GREEDY ##\\n        i = 0\\n        while(i >= 0 and i < len(s)-1):\\n            if s[i].lower() == s[i+1].lower() and ( (s[i].islower() and s[i+1].isupper()) or (s[i].isupper() and s[i+1].islower()) ):\\n                s = s[:i] + s[i+2:]\\n                i -= 1\\n            else:\\n                i += 1\\n            if i < 0:\\n                i = 0\\n        return s\\n```\\nPLEASE UPVOTE IF YOU LIKE MY SOLUTION.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        ## RC ##\\n        ## APPROACH : GREEDY ##\\n        i = 0\\n        while(i >= 0 and i < len(s)-1):\\n            if s[i].lower() == s[i+1].lower() and ( (s[i].islower() and s[i+1].isupper()) or (s[i].isupper() and s[i+1].islower()) ):\\n                s = s[:i] + s[i+2:]\\n                i -= 1\\n            else:\\n                i += 1\\n            if i < 0:\\n                i = 0\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781001,
                "title": "c-o-n-stack-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring makeGood(string s) {\\n\\t\\t\\tstack<char> st;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(!st.empty() && ((st.top()-\\'a\\'==s[i]-\\'A\\') ||(st.top()-\\'A\\'==s[i]-\\'a\\')))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tst.push(s[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tstring ans;\\n\\t\\t\\twhile(!st.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar cur=st.top();\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\tans=cur+ans;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring makeGood(string s) {\\n\\t\\t\\tstack<char> st;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(!st.empty() && ((st.top()-\\'a\\'==s[i]-\\'A\\') ||(st.top()-\\'A\\'==s[i]-\\'a\\')))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 780905,
                "title": "java-o-n-time-o-n-space-stack",
                "content": "We continuously push characters to a stack and if there exists a violation (which we can detect by seeing if the difference of the current character and top stack character is exactly 32. See Ascii Table.), we pop a character instead and don\\'t push the current character.\\n\\n```\\npublic String makeGood(String s) {\\n    Stack<Character> stack = new Stack<>();\\n    for (int i=0;i<s.length();i++) {\\n        if (!stack.isEmpty() && Math.abs(stack.peek() - s.charAt(i)) == 32) stack.pop();\\n        else stack.push(s.charAt(i));\\n    }\\n    StringBuilder sb = new StringBuilder();\\n    while (!stack.isEmpty()) sb.append(stack.pop());\\n    return sb.reverse().toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String makeGood(String s) {\\n    Stack<Character> stack = new Stack<>();\\n    for (int i=0;i<s.length();i++) {\\n        if (!stack.isEmpty() && Math.abs(stack.peek() - s.charAt(i)) == 32) stack.pop();\\n        else stack.push(s.charAt(i));\\n    }\\n    StringBuilder sb = new StringBuilder();\\n    while (!stack.isEmpty()) sb.append(stack.pop());\\n    return sb.reverse().toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4032851,
                "title": "c-easy-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> stk;\\n        string ans;\\n        stk.push(\\'-\\');\\n        for(int i=0;i<s.size();i++){\\n            char curr=s[i];\\n            stk.push(curr);\\n            if(curr>=\\'a\\'&&curr<=\\'z\\'){\\n                char temp=curr-32;\\n                stk.pop();\\n                if(stk.top()==temp){\\n                    stk.pop();\\n                }else{\\n                    stk.push(curr);\\n                }\\n            }else if(curr>=\\'A\\'&&curr<=\\'Z\\'){\\n                char temp=curr+32;\\n                stk.pop();\\n                if(stk.top()==temp){\\n                    stk.pop();\\n                }else{\\n                    stk.push(curr);\\n                }\\n            }\\n\\n        }\\n        while(stk.size()!=1){\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> stk;\\n        string ans;\\n        stk.push(\\'-\\');\\n        for(int i=0;i<s.size();i++){\\n            char curr=s[i];\\n            stk.push(curr);\\n            if(curr>=\\'a\\'&&curr<=\\'z\\'){\\n                char temp=curr-32;\\n                stk.pop();\\n                if(stk.top()==temp){\\n                    stk.pop();\\n                }else{\\n                    stk.push(curr);\\n                }\\n            }else if(curr>=\\'A\\'&&curr<=\\'Z\\'){\\n                char temp=curr+32;\\n                stk.pop();\\n                if(stk.top()==temp){\\n                    stk.pop();\\n                }else{\\n                    stk.push(curr);\\n                }\\n            }\\n\\n        }\\n        while(stk.size()!=1){\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030695,
                "title": "java-easy-solution-using-stack-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        \\n        if(s.length()==1)\\n            return s;\\n        \\n        Stack <Character> st=new Stack<>();\\n            \\n    for (char c : s.toCharArray()) {\\n        if (!st.isEmpty() && Math.abs(st.peek() - c) == 32) {\\n            st.pop();\\n        } else {\\n            st.push(c);\\n        }\\n    }\\nStringBuilder strange = new StringBuilder();  \\n        while(!st.isEmpty())\\n        {\\n            strange.append(st.pop());\\n        }\\n        strange.reverse();\\n        return strange.toString();\\n    }\\n}\\n\\n\\n   \\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        \\n        if(s.length()==1)\\n            return s;\\n        \\n        Stack <Character> st=new Stack<>();\\n            \\n    for (char c : s.toCharArray()) {\\n        if (!st.isEmpty() && Math.abs(st.peek() - c) == 32) {\\n            st.pop();\\n        } else {\\n            st.push(c);\\n        }\\n    }\\nStringBuilder strange = new StringBuilder();  \\n        while(!st.isEmpty())\\n        {\\n            strange.append(st.pop());\\n        }\\n        strange.reverse();\\n        return strange.toString();\\n    }\\n}\\n\\n\\n   \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022146,
                "title": "c-using-stack",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public string MakeGood(string s)\\n    {\\n        var stack = new Stack<char>();\\n        foreach (var c in s)\\n        {\\n            if (stack.Count > 0 && stack.Peek() != c && char.ToLower(stack.Peek()) == char.ToLower(c))\\n            {\\n                stack.Pop();\\n            }\\n            else\\n            {\\n                stack.Push(c);\\n            }\\n        }\\n\\n        var sb = new StringBuilder();\\n        while (stack.Count > 0)\\n        {\\n            sb.Append(stack.Pop());\\n        }\\n\\n        return new string(sb.ToString().Reverse().ToArray());\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public string MakeGood(string s)\\n    {\\n        var stack = new Stack<char>();\\n        foreach (var c in s)\\n        {\\n            if (stack.Count > 0 && stack.Peek() != c && char.ToLower(stack.Peek()) == char.ToLower(c))\\n            {\\n                stack.Pop();\\n            }\\n            else\\n            {\\n                stack.Push(c);\\n            }\\n        }\\n\\n        var sb = new StringBuilder();\\n        while (stack.Count > 0)\\n        {\\n            sb.Append(stack.Pop());\\n        }\\n\\n        return new string(sb.ToString().Reverse().ToArray());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833385,
                "title": "java-beginner-solution-runtime-100-memory-100-with-explanation",
                "content": "# Approach\\n\\nThe approach used in the given solution is to iterate through the input string `s`, and for each character encountered, check if it forms a \"bad\" pair with the previous character in the `StringBuilder`. If a \"bad\" pair is found, we remove both characters from the `StringBuilder`. Otherwise, we append the current character to the `StringBuilder`. In the end, the `StringBuilder` will contain the modified \"good\" string, which is the desired output.\\n\\nLogic:\\n\\n1. Create an empty `StringBuilder` called `sb` to store the characters of the modified string.\\n\\n2. Iterate through the characters of the input string `s`.\\n\\n3. For each character `c`, check if the `StringBuilder` is not empty (`len != 0`) and if the absolute difference between the ASCII values of the last character in the `StringBuilder` and the current character `c` is equal to 32. ASCII values of lowercase and uppercase English letters differ by 32. If this condition is true, it means that the characters form a \"bad\" pair, and we need to remove both characters from the `StringBuilder`.\\n\\n4. If the condition in step 3 is false, it means that the current character `c` does not form a \"bad\" pair with the last character in the `StringBuilder`. In this case, we can safely append the current character `c` to the `StringBuilder`.\\n\\n5. Repeat steps 3-4 for all characters in the input string `s`.\\n\\n6. After the iteration is complete, the `StringBuilder` will contain the modified \"good\" string, and we can convert it to a regular string using `sb.toString()` and return it as the output.\\n\\nThe solution effectively removes all the \"bad\" pairs of adjacent characters from the input string and returns the resulting \"good\" string. Since the solution processes each character in a single pass, the time complexity of this approach is O(n), where n is the length of the input string. The space complexity is also O(n) due to the usage of the `StringBuilder`. Overall, the solution is clear, concise, and efficient, making it easy to understand for beginners as well.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (char c : s.toCharArray()) {\\n            int len = sb.length();\\n\\n            if (len != 0 && Math.abs(sb.charAt(len - 1) - c) == 32)\\n                sb.deleteCharAt(len - 1);\\n            else\\n                sb.append(c);\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "String",
                    "Stack",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (char c : s.toCharArray()) {\\n            int len = sb.length();\\n\\n            if (len != 0 && Math.abs(sb.charAt(len - 1) - c) == 32)\\n                sb.deleteCharAt(len - 1);\\n            else\\n                sb.append(c);\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717965,
                "title": "easy-solution-using-stack-and-stringbuilder",
                "content": "# Intuition\\nSince in Java we can\\'t modify the string in place (because the string is immutable), so we have to use extra space for building the result.\\nPair is great if the difference of thier ASCII values is differnt than 323232\\n\\n# Approach\\nloop over the string, and for each character:\\n\\ncompare its value with the last character in the result,\\nif this pair makes the string bad:\\nremove the last character from the result\\nelse\\nadd the current character to the result.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stk = new Stack<>();\\n        for(char ch : s.toCharArray()){\\n            if(stk.size()>0 && (stk.peek()==ch-32 || stk.peek()==ch+32)){\\n                stk.pop();\\n            }\\n            else{\\n                stk.push(ch);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(stk.size()>0){\\n            char ch = stk.pop();\\n            sb.append(ch);\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stk = new Stack<>();\\n        for(char ch : s.toCharArray()){\\n            if(stk.size()>0 && (stk.peek()==ch-32 || stk.peek()==ch+32)){\\n                stk.pop();\\n            }\\n            else{\\n                stk.push(ch);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(stk.size()>0){\\n            char ch = stk.pop();\\n            sb.append(ch);\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614500,
                "title": "100-beats-c-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<int>st;\\n        for(int i=0;i<s.size();i++){\\n            if(!st.empty() && (st.top()-32==s[i] || s[i]-32==st.top())){\\n                st.pop();\\n            }\\n            else\\n            st.push(s[i]);\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<int>st;\\n        for(int i=0;i<s.size();i++){\\n            if(!st.empty() && (st.top()-32==s[i] || s[i]-32==st.top())){\\n                st.pop();\\n            }\\n            else\\n            st.push(s[i]);\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605507,
                "title": "easy-one-stop-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere as we have to remove adjacent characters of a string if the string is a bad string. As we have to keep the track of the previous character processed of the string along with the current character we proceed using the stack approach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we use ASCII difference to compare the characters. We know ASCII value of A-Z is from 65 to 90 and ASCII value of a-z is from a-z. Here we notice that difference between any lower case character and corresponding upper case character is 32. \\n(E.g : a-A => 97-65 = 32).\\n\\nIf the difference between the top character of the stack and the current character of the string is equal to 32, this implies we have found a pair (eE or Ee) to be removed.\\nWe then remove the top character of the stack and move forward. This goes until we reach the end of the string and all such pairs.\\n\\nAt the end we run a loop on the stack and transfer all characters of the stack to the ans string variable in such a way that stack is reversed and we get the desired string,\\n# Complexity\\n- Time complexity:  O(n)\\n- As we are traversing the string only once , hence the time complexity of the above solution is O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n- As we are using a stack which in worst case may store all the characters of the string , hence the space complexity of the above approach is O(n). \\n\\n- The space complexity can be optimized to O(1) using two pointers and proceeding with a similar trend changing the string in place.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char>st;\\n        string ans=\"\";\\n        int n=s.size();\\n        for(int i=0;i<n;i++) {\\n            if(!st.empty() && abs(s[i]-st.top())==32) // If we find a bad pair such as Aa or aA , then we remove the previous character processed\\n            st.pop();\\n            else\\n            st.push(s[i]); // if the stack is empty or if the pair is not a bad one.\\n        }\\n\\n        while (!st.empty()) {\\n            ans = st.top() + ans;\\n            st.pop();\\n        }\\n\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char>st;\\n        string ans=\"\";\\n        int n=s.size();\\n        for(int i=0;i<n;i++) {\\n            if(!st.empty() && abs(s[i]-st.top())==32) // If we find a bad pair such as Aa or aA , then we remove the previous character processed\\n            st.pop();\\n            else\\n            st.push(s[i]); // if the stack is empty or if the pair is not a bad one.\\n        }\\n\\n        while (!st.empty()) {\\n            ans = st.top() + ans;\\n            st.pop();\\n        }\\n\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427077,
                "title": "100-cpp-stack-reverse-basic-ascii",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        \\n        stack<char> st;\\n        string ans = \"\";\\n        st.push(s[0]);\\n        \\n        for(int i = 1; i < s.size(); i++){\\n            \\n            if(st.empty()){\\n                \\n                st.push(s[i]);\\n                continue;\\n                \\n            }\\n            \\n            if(abs(st.top() - s[i]) == 32)\\n                st.pop();\\n            \\n            else\\n                st.push(s[i]);\\n            \\n        }\\n        \\n        while(!st.empty()){\\n            \\n            ans.push_back(st.top());\\n            st.pop();\\n            \\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        \\n        stack<char> st;\\n        string ans = \"\";\\n        st.push(s[0]);\\n        \\n        for(int i = 1; i < s.size(); i++){\\n            \\n            if(st.empty()){\\n                \\n                st.push(s[i]);\\n                continue;\\n                \\n            }\\n            \\n            if(abs(st.top() - s[i]) == 32)\\n                st.pop();\\n            \\n            else\\n                st.push(s[i]);\\n            \\n        }\\n        \\n        while(!st.empty()){\\n            \\n            ans.push_back(st.top());\\n            st.pop();\\n            \\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568416,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1675928,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1675654,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1676486,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1675558,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1676344,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1676294,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1968723,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1893781,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1876253,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1568416,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1675928,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1675654,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1676486,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1675558,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1676344,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1676294,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1968723,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1893781,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1876253,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1764869,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1764471,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1756055,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1714129,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1681372,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1678915,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1676903,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1676850,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1676797,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1676620,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1676551,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            },
            {
                "id": 1676548,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            },
            {
                "id": 1676395,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            },
            {
                "id": 1676323,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            },
            {
                "id": 1676226,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            },
            {
                "id": 1676174,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            },
            {
                "id": 1675977,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            },
            {
                "id": 1675963,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            },
            {
                "id": 1675896,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            },
            {
                "id": 1675741,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Kth Bit in Nth Binary String",
        "question_content": "<p>Given two positive integers <code>n</code> and <code>k</code>, the binary string <code>S<sub>n</sub></code> is formed as follows:</p>\n\n<ul>\n\t<li><code>S<sub>1</sub> = &quot;0&quot;</code></li>\n\t<li><code>S<sub>i</sub> = S<sub>i - 1</sub> + &quot;1&quot; + reverse(invert(S<sub>i - 1</sub>))</code> for <code>i &gt; 1</code></li>\n</ul>\n\n<p>Where <code>+</code> denotes the concatenation operation, <code>reverse(x)</code> returns the reversed string <code>x</code>, and <code>invert(x)</code> inverts all the bits in <code>x</code> (<code>0</code> changes to <code>1</code> and <code>1</code> changes to <code>0</code>).</p>\n\n<p>For example, the first four strings in the above sequence are:</p>\n\n<ul>\n\t<li><code>S<sub>1 </sub>= &quot;0&quot;</code></li>\n\t<li><code>S<sub>2 </sub>= &quot;0<strong>1</strong>1&quot;</code></li>\n\t<li><code>S<sub>3 </sub>= &quot;011<strong>1</strong>001&quot;</code></li>\n\t<li><code>S<sub>4</sub> = &quot;0111001<strong>1</strong>0110001&quot;</code></li>\n</ul>\n\n<p>Return <em>the</em> <code>k<sup>th</sup></code> <em>bit</em> <em>in</em> <code>S<sub>n</sub></code>. It is guaranteed that <code>k</code> is valid for the given <code>n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, k = 1\n<strong>Output:</strong> &quot;0&quot;\n<strong>Explanation:</strong> S<sub>3</sub> is &quot;<strong><u>0</u></strong>111001&quot;.\nThe 1<sup>st</sup> bit is &quot;0&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, k = 11\n<strong>Output:</strong> &quot;1&quot;\n<strong>Explanation:</strong> S<sub>4</sub> is &quot;0111001101<strong><u>1</u></strong>0001&quot;.\nThe 11<sup>th</sup> bit is &quot;1&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>1 &lt;= k &lt;= 2<sup>n</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 781181,
                "title": "java-c-python-iterative-solutions",
                "content": "# **Explanation**\\n1. If `k` is on the left part of the string, we do nothing.\\n\\n2. If `K` is right in the middle, and the middle is 1.\\nWe flip `count` times, we return `count % 2 == 0 ? \\'1\\' : \\'0\\'`\\n\\n3. If `k` is on the right part of the string,\\nfind it\\'s symeric postion `k = l + 1 - k`.\\nAlso we increment `count++`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n# Solution 0\\nSame code as explained above.\\n**Java**\\n```java\\n    public char findKthBit(int n, int k) {\\n        int count = 0, l = (1 << n) - 1;\\n        while (k > 1) {\\n            if (k == l / 2 + 1)\\n                return count % 2 == 0 ? \\'1\\' : \\'0\\';\\n            if (k > l / 2) {\\n                k = l + 1 - k;\\n                count++;\\n            }\\n            l /= 2;\\n        }\\n        return count % 2 == 0 ? \\'0\\' : \\'1\\';\\n    }\\n```\\n<br>\\n\\n# Solution 2\\nRemove the `count`, just use a `flip` boolean, (short for isFlipped).\\n**Java:**\\n```java\\n    public char findKthBit(int n, int k) {\\n        int flip = 0, l = (1 << n) - 1;\\n        while (k > 1) {\\n            if (k == l / 2 + 1)\\n                return flip == 0 ? \\'1\\' : \\'0\\';\\n            if (k > l / 2) {\\n                k = l + 1 - k;\\n                flip ^= 1;\\n            }\\n            l /= 2;\\n        }\\n        return flip == 0 ? \\'0\\' : \\'1\\';\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    char findKthBit(int n, int k) {\\n        int flip = 0, l = (1 << n) - 1;\\n        while (k > 1) {\\n            if (k == l / 2 + 1)\\n                return \\'0\\' + (flip ^ 1);\\n            if (k > l / 2) {\\n                k = l + 1 - k;\\n                flip ^= 1;\\n            }\\n            l /= 2;\\n        }\\n        return \\'0\\' + flip;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def findKthBit(self, n, k):\\n        flip = 0\\n        l = 2 ** n - 1\\n        while k > 1:\\n            if k == l / 2 + 1:\\n                return str(1 ^ flip)\\n            if k > l / 2:\\n                k = l + 1 - k\\n                flip = 1 - flip\\n            l /= 2\\n        return str(flip)\\n```\\n<br>\\n\\n# Solution 3: O(1) One Line\\ninspired by @hCaulfield and @luffy_is_joyboy, I updated this `O(1)` solution,\\n[O(1) One Line Solutions](https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/discuss/785548/JavaC++Python-O(1)-Solutions)",
                "solutionTags": [],
                "code": "```java\\n    public char findKthBit(int n, int k) {\\n        int count = 0, l = (1 << n) - 1;\\n        while (k > 1) {\\n            if (k == l / 2 + 1)\\n                return count % 2 == 0 ? \\'1\\' : \\'0\\';\\n            if (k > l / 2) {\\n                k = l + 1 - k;\\n                count++;\\n            }\\n            l /= 2;\\n        }\\n        return count % 2 == 0 ? \\'0\\' : \\'1\\';\\n    }\\n```\n```java\\n    public char findKthBit(int n, int k) {\\n        int flip = 0, l = (1 << n) - 1;\\n        while (k > 1) {\\n            if (k == l / 2 + 1)\\n                return flip == 0 ? \\'1\\' : \\'0\\';\\n            if (k > l / 2) {\\n                k = l + 1 - k;\\n                flip ^= 1;\\n            }\\n            l /= 2;\\n        }\\n        return flip == 0 ? \\'0\\' : \\'1\\';\\n    }\\n```\n```cpp\\n    char findKthBit(int n, int k) {\\n        int flip = 0, l = (1 << n) - 1;\\n        while (k > 1) {\\n            if (k == l / 2 + 1)\\n                return \\'0\\' + (flip ^ 1);\\n            if (k > l / 2) {\\n                k = l + 1 - k;\\n                flip ^= 1;\\n            }\\n            l /= 2;\\n        }\\n        return \\'0\\' + flip;\\n    }\\n```\n```py\\n    def findKthBit(self, n, k):\\n        flip = 0\\n        l = 2 ** n - 1\\n        while k > 1:\\n            if k == l / 2 + 1:\\n                return str(1 ^ flip)\\n            if k > l / 2:\\n                k = l + 1 - k\\n                flip = 1 - flip\\n            l /= 2\\n        return str(flip)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 785548,
                "title": "java-c-python-o-1-solutions",
                "content": "# Preword\\nThis solution involves all kinds of bit manipulation.\\nSo if you are beginner and not familar with bit manipulation,\\nit\\'s quite normal tht you find that I can\\'t explain well enough.\\n\\nLike: lowbit = x & -x\\n<br>\\n\\n# **Explanation 1**\\nLet\\'s define some notation:\\nOdd sequence: the sequence on odd positions\\nEven sequence: the sequence on even positions\\nZero-One sequence: The sequence of 1,0,1,0,1,0\\nOne-Zero sequence: The sequence of 1,0,1,0,1,0\\nSequence `S`, defined as the description.\\nMagic sequence: we\\'ll talk about that later\\n<br>\\n\\n1. Take an observation on the odd sequence of `S`:\\nThey are 0,1,0,1,0,1,0.... a Zero-One sequence.   **(a)**\\nif `k >> 1` is even, return 0,\\nif `k >> 1` is odd, return 1,\\nwhere `k` is 1-based.\\n\\nSo, return `k >> 1 & 1`\\n\\n2. Take an observation of the sequence on even position:\\nThey are 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0\\n\\nWe call this sequence as magic sequence `M`.\\nThe properties of `M`:\\n1). It\\'s odd sequence is a One-Zero sequence.      **(b)**\\n2). It\\'s even sequence is still a Magic sequence   **(c)**\\n\\nIf for a even number `k`, it\\'s in case c.\\nWe do `k = k / 2`, if it\\'s even, still in case c.\\nWe keep doing this, until k is odd, now it\\'s in case b.\\n\\nso for a even number k = k2 * pow(2), where `k2` is odd,\\nif `k2 >> 1` is odd, return 1\\nif `k2 >> 1` is even, return 0\\nwe return `k2 >> 1 & 1 ^ 1`\\n<br>\\n\\n\\n# **Explanation 2**\\nEvery time we want a symmetical of `k`, we do `k = pow(2) - k`.\\nFor example:\\nk = 215, k = 256 - 215 = 41\\nk = 41 , k = 64 - 41 = 23\\nk = 23 , k = 32 - 23 = 9\\nk = 9  , k = 16 - 9 = 7\\nk = 7  , k = 8 - 7 = 1,\\nk = 1, flipped 5 times, return 0.\\n\\nIn general cases,\\nif `k = 1` in the end, `S(1) = 0`\\nfliped odd times, return 1\\nfliped even times, return 0\\n\\nif `k = pow(2)` (or `k = 0`) in the end, `S(pow(2)) = 1`\\nfliped odd times, return 0\\nfliped even times, return 1\\n\\nSo it depends how many times we will flip,\\nand what\\'s the last value.\\n\\nAssume k = x * pow(2), where x is odd.\\nThe number of flip time, equals to the number of 0,1 groups in `x >> 1`.\\nIf x >> 1 is odd, we\\'ll flip odd times.\\xA0\\nIf x >> 1 is even, we\\'ll flip even times.\\n<br>\\n\\n# **Complexity**\\nTime `O(1)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public char findKthBit(int n, int k) {\\n        return (char)((k / (k & -k) >> 1 & 1) ^ (k & 1 ^ 1) + \\'0\\');\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    char findKthBit(int n, int k) {\\n        return \\'0\\' + (k / (k & -k) >> 1 & 1) ^ (k & 1 ^ 1);\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def findKthBit1(self, n, k):\\n        return str(k / (k & -k) >> 1 & 1 ^ k & 1 ^ 1)\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public char findKthBit(int n, int k) {\\n        return (char)((k / (k & -k) >> 1 & 1) ^ (k & 1 ^ 1) + \\'0\\');\\n    }\\n```\n```cpp\\n    char findKthBit(int n, int k) {\\n        return \\'0\\' + (k / (k & -k) >> 1 & 1) ^ (k & 1 ^ 1);\\n    }\\n```\n```py\\n    def findKthBit1(self, n, k):\\n        return str(k / (k & -k) >> 1 & 1 ^ k & 1 ^ 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 780976,
                "title": "c-simple-recursion-with-explanation",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Recursion\\n\\nThe length of the string `len` is `2^n - 1`.\\n\\nIf `k - 1 == len / 2`, then this is the middle of the string, return `1` unless `n == 1`.\\n\\nIf `k - 1 < len / 2`, this is in the left part of `Sn`, which is the same as `findKthBit(n - 1, k)`.\\n\\nIf `k - 1 > len / 2`, this is the `len - k + 1`-th bit from the right in the right part, which is the invert of `findKthBit(n - 1, len - k + 1)`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-201/problems/find-kth-bit-in-nth-binary-string/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        if (n == 1) return \\'0\\';\\n        int len = pow(2, n) - 1;\\n        if (k - 1 == len / 2) return \\'1\\';\\n        if (k - 1 < len / 2) return findKthBit(n - 1, k);\\n        return findKthBit(n - 1, len - k + 1) == \\'0\\' ? \\'1\\' : \\'0\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-201/problems/find-kth-bit-in-nth-binary-string/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        if (n == 1) return \\'0\\';\\n        int len = pow(2, n) - 1;\\n        if (k - 1 == len / 2) return \\'1\\';\\n        if (k - 1 < len / 2) return findKthBit(n - 1, k);\\n        return findKthBit(n - 1, len - k + 1) == \\'0\\' ? \\'1\\' : \\'0\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780984,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if (n == 1) {\\n            return \\'0\\';\\n        }\\n        int len = (1 << n) - 1;\\n        if (k == len / 2 + 1) {\\n            return \\'1\\';\\n        } else if (k > len / 2 + 1) {\\n            return findKthBit(n - 1, len - k + 1) == \\'0\\' ? \\'1\\' : \\'0\\';\\n        } else {\\n            return findKthBit(n - 1, k);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if (n == 1) {\\n            return \\'0\\';\\n        }\\n        int len = (1 << n) - 1;\\n        if (k == len / 2 + 1) {\\n            return \\'1\\';\\n        } else if (k > len / 2 + 1) {\\n            return findKthBit(n - 1, len - k + 1) == \\'0\\' ? \\'1\\' : \\'0\\';\\n        } else {\\n            return findKthBit(n - 1, k);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780955,
                "title": "java-brutal-force",
                "content": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(\\'0\\');\\n        for (int i = 2, l = 1; i <= n; i++){\\n            l = l * 2 + 1;\\n            String add = invert(sb);\\n            sb.append(\\'1\\').append(add);\\n            if (l >= k) return sb.charAt(k - 1);\\n        }\\n        return \\'0\\'; // dummy return;\\n    }\\n    \\n    private String invert(StringBuilder s) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int l = s.length(), i = l - 1; i >= 0; i--) {\\n            sb.append(s.charAt(i) == \\'0\\' ? \\'1\\' : \\'0\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(\\'0\\');\\n        for (int i = 2, l = 1; i <= n; i++){\\n            l = l * 2 + 1;\\n            String add = invert(sb);\\n            sb.append(\\'1\\').append(add);\\n            if (l >= k) return sb.charAt(k - 1);\\n        }\\n        return \\'0\\'; // dummy return;\\n    }\\n    \\n    private String invert(StringBuilder s) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int l = s.length(), i = l - 1; i >= 0; i--) {\\n            sb.append(s.charAt(i) == \\'0\\' ? \\'1\\' : \\'0\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494211,
                "title": "java-simple-recursive-solution-with-detailed-explanation",
                "content": "This problem is all about observations. If you correctly find the pattern, it is a piece of cake. \\n\\nIt is given that Si = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\\n\\nWhich means that till the mid length, the string Si will be the same as string Si-1. \\n\\n```\\n  N = 1         S1 = \"0\"\\n  N = 2         S2 = \"011\"\\n  N = 3         S3 = \"0111001\"\\n  N = 4         S4 = \"011100110110001\"\\n```\\n\\nTo calculate length for a row we just need to find a pattern. e.g. if N = 1, length = 1. If N = 2, length = 3. If N = 3, length = 7. If N = 4, length = 15.\\n\\nSo basically, for any row N, length = (2 ^ N)  - 1\\n\\nAnd mid is simply length/2;\\n\\nNow, lets take N  = 2 and N = 3 strings.\\n\\n ```\\n  N = 2         S2 = \"011\"\\n  N = 3         S3 = \"0111001\"\\n```\\n\\nIf we see, till length = 3, the strings are same. Which means, if we are given N = 3 and k = 1 or 2 or 3 as input, we just need to look at what is the bit at kth place for N = 2\\n\\n```\\nIf k <= mid then we simply find the kth bit of n-1th row \\n```\\n\\nAnother case is when k is mid+ 1. It is given in problem that in every new row, we add an extra \"1\" after copying previous row. Which means the bit at mid + 1 for any row is always 1. \\n\\n```\\nIf k = mid + 1 we don\\'t need to do anything apart from simply returning \\'1\\'.\\n```\\n\\nFinally, we have the last case where k > mid + 1.\\n\\ne.g. for N = 3, if k = 5 we have to return 0. Now, lets compare the last three bits of N = 3 with the bits of N = 2\\n\\t\\nWe know these last three bits for S3 are generated as reverse(invert(\"011\"))\\n\\nThis means, the 5th bit in S3 is just the 3rd bit in S2 but inverted. \\nSimilarly, the 6th bit in S3 is just the 2nd bit in S2 but inverted.\\nAnd finally, the 7th bit in S3 is just 1st bit in S2 but inverted.\\n\\n```\\nIf k > mid + 1 then k for n-1 row is -> length - k + 1\\n```\\n\\ne.g. for N = 3, if k = 5. then for N = 2, \\n\\t\\t\\t\\tk = 7 - 5 + 1 => 3\\n\\t\\t\\t\\t\\nAnd based on all these observations, our code will be ->\\n\\n```\\npublic char findKthBit(int n, int k) {\\n        //Base Condition\\n        if(n == 1){\\n            return \\'0\\';\\n        }\\n        \\n        int numberOfColumns = (int)Math.pow(2,n) - 1;\\n        int mid = numberOfColumns/2;\\n                \\n        if(k <= mid){\\n            return findKthBit(n-1,k);\\n        } else if (k == mid + 1){ //Since we are adding that extra \"1\" in each new row\\n            return \\'1\\';\\n        } else {\\n           k = numberOfColumns - k + 1;\\n           char c = findKthBit(n-1,k);\\n           return c == \\'0\\' ? \\'1\\' : \\'0\\';\\n        }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n  N = 1         S1 = \"0\"\\n  N = 2         S2 = \"011\"\\n  N = 3         S3 = \"0111001\"\\n  N = 4         S4 = \"011100110110001\"\\n```\n```\\n  N = 2         S2 = \"011\"\\n  N = 3         S3 = \"0111001\"\\n```\n```\\nIf k <= mid then we simply find the kth bit of n-1th row \\n```\n```\\nIf k = mid + 1 we don\\'t need to do anything apart from simply returning \\'1\\'.\\n```\n```\\nIf k > mid + 1 then k for n-1 row is -> length - k + 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780910,
                "title": "c-brute-force",
                "content": "```cpp\\nchar findKthBit(int n, int k) {\\n    string s = \"0\";\\n    while (true) {\\n        if (k <= s.size())\\n            return s[k - 1];\\n        auto ss = s;\\n        reverse(begin(ss), end(ss));\\n        for (auto &ch : ss)\\n            ch = ch == \\'0\\' ? \\'1\\' : \\'0\\';\\n        s += \"1\" + ss;\\n    }\\n    return \\'0\\';\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nchar findKthBit(int n, int k) {\\n    string s = \"0\";\\n    while (true) {\\n        if (k <= s.size())\\n            return s[k - 1];\\n        auto ss = s;\\n        reverse(begin(ss), end(ss));\\n        for (auto &ch : ss)\\n            ch = ch == \\'0\\' ? \\'1\\' : \\'0\\';\\n        s += \"1\" + ss;\\n    }\\n    return \\'0\\';\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781132,
                "title": "java-simple-recursion",
                "content": "```\\n    public char findKthBit(int n, int k) {\\n        if(n == 1)\\n            return \\'0\\'; // S1 can only give \\'0\\'\\n        \\n        int len = 1 << n; // length of imaginary Sn (same as doing \\'Math.pow(2,n)\\' )\\n        \\n        if(k < len/2) \\n            return findKthBit(n-1, k);  // the string to the left of middle character is the same as the string Sn-1\\n        \\n        if(k == len/2)\\n            return \\'1\\'; // the middle character from S2 ... Sn will always be \\'1\\'\\n        \\n        return findKthBit(n-1, len - k) == \\'0\\' ? \\'1\\' : \\'0\\'; // if you want a character after mid you have to reverse both the position and the character\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    public char findKthBit(int n, int k) {\\n        if(n == 1)\\n            return \\'0\\'; // S1 can only give \\'0\\'\\n        \\n        int len = 1 << n; // length of imaginary Sn (same as doing \\'Math.pow(2,n)\\' )\\n        \\n        if(k < len/2) \\n            return findKthBit(n-1, k);  // the string to the left of middle character is the same as the string Sn-1\\n        \\n        if(k == len/2)\\n            return \\'1\\'; // the middle character from S2 ... Sn will always be \\'1\\'\\n        \\n        return findKthBit(n-1, len - k) == \\'0\\' ? \\'1\\' : \\'0\\'; // if you want a character after mid you have to reverse both the position and the character\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780941,
                "title": "python-simple-recursive-solution-with-explanation",
                "content": "**Idea**\\nWe can calculate the length of `S_n` based on `n`. Then we check `k` is on which half of `S_n` and use recursion to get the answer.\\n\\n <br />\\n\\n**Complexity**\\n\\nTime complexity: `O(N)`\\nSpace complexity: `O(N)`\\n\\n<br />\\n\\n**Python**\\n```Python\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        # base case\\n        if n == 1:\\n            return \"0\"\\n        \\n        # calculate length of S_n\\n        l = 2 ** n - 1\\n        \\n        # recursion\\n        mid = l // 2 + 1\\n        if k == mid:\\n            return \"1\"\\n        elif k < mid:\\n            return self.findKthBit(n - 1, k)\\n        else:\\n            return str(1 - int(self.findKthBit(n - 1, l - k + 1)))\\n```\\n\\n <br />\\n \\n**Edit**\\nWe can use` l = 2 ** n - 1` instead of the for loop to get the length of S_n. Credit to @bobby569.\\n",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        # base case\\n        if n == 1:\\n            return \"0\"\\n        \\n        # calculate length of S_n\\n        l = 2 ** n - 1\\n        \\n        # recursion\\n        mid = l // 2 + 1\\n        if k == mid:\\n            return \"1\"\\n        elif k < mid:\\n            return self.findKthBit(n - 1, k)\\n        else:\\n            return str(1 - int(self.findKthBit(n - 1, l - k + 1)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789003,
                "title": "c-simple-recursion-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/346902fb-17e1-4f02-8e6e-abd8d5342cbe_1597299053.5764208.png)\\nsize = (2^n)-1 (number of binary digits)\\nmid = size/2\\n**If we have k==1 or n==1 we simply return 0.**\\nIf we have **k<=mid** then our answer lies in **(n-1,k)**.\\nIf we have **k==mid+1** then our answer will always be **1**.\\nIf we have **k>mid** the our answer lies in **(n-1,size-k+1)** and we have to  **invert our answer**\\n**size-k+1 leads us to the reverse position of the bit in the previous n.**\\n```\\nchar findKthBit(int n, int k) {\\n        int temp = findChar(n,k);\\n        return (temp+\\'0\\');\\n    }\\n\\t\\nint findChar(int n,int k)\\n    {\\n        if(n==1 || k==1)\\n            return 0;\\n        int size = (pow(2,n))-1;\\n        int mid = (size)/2;\\n        if(mid+1 == k)\\n            return 1;\\n        if(k<=mid)\\n            return findChar(n-1,k);\\n        else\\n            return !findChar(n-1,(size-k+1));\\n    }\\n```\\nThis questions is a variation of [https://leetcode.com/problems/k-th-symbol-in-grammar/](http://)",
                "solutionTags": [],
                "code": "```\\nchar findKthBit(int n, int k) {\\n        int temp = findChar(n,k);\\n        return (temp+\\'0\\');\\n    }\\n\\t\\nint findChar(int n,int k)\\n    {\\n        if(n==1 || k==1)\\n            return 0;\\n        int size = (pow(2,n))-1;\\n        int mid = (size)/2;\\n        if(mid+1 == k)\\n            return 1;\\n        if(k<=mid)\\n            return findChar(n-1,k);\\n        else\\n            return !findChar(n-1,(size-k+1));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781062,
                "title": "python3-4-line-recursive",
                "content": "The first digit is always \"0\" regardless of `n`. The middle digit at `2**(n-1)` is always `1`. If `k < 2**(n-1)`, one could reduce the problem to `n-1` which is half the size. Otherwise, focus on the other half by reversing the position and \"0\"/\"1\". \\n\\n```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        if k == 1: return \"0\"\\n        if k == 2**(n-1): return \"1\"\\n        if k < 2**(n-1): return self.findKthBit(n-1, k)\\n        return \"0\" if self.findKthBit(n-1, 2**n-k) == \"1\" else \"1\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        if k == 1: return \"0\"\\n        if k == 2**(n-1): return \"1\"\\n        if k < 2**(n-1): return self.findKthBit(n-1, k)\\n        return \"0\" if self.findKthBit(n-1, 2**n-k) == \"1\" else \"1\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440070,
                "title": "3-solutions-for-all-levels-of-programmers-brute-force-to-efficient-c-understand-easily",
                "content": "***3 Solutions for all levels of programmers:***\\nPlease upvote if found useful!!\\n\\n1. Solution that is easy to understand and formulate. Follows Brute Force approach:\\n```\\nclass Solution {\\npublic:    \\n    \\n    string invert(string x){\\n        for(int i=0; i<x.size(); i++){\\n            if(x[i]==\\'0\\') x[i] =\\'1\\';\\n            else x[i] =\\'0\\';\\n        }            \\n        return x;\\n    }      \\n    \\n    string formSequence(int n){\\n        if(n==0)\\n            return \"0\";                \\n        \\n        string s = formSequence(n-1);\\n        string result=\"\";        \\n        \\n        // Compute formSequence(n)                \\n        string rev = invert(s);\\n        reverse(rev.begin(), rev.end());\\n        result = s + \"1\" + rev;\\n        \\n        return result;\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        string s = formSequence(n);\\n        return s[k-1];\\n    }\\n};\\n```\\n\\n2. Solution using XOR Technique. Complex to come up with! \\n```\\nchar findKthBit(int n, int k) {\\n        int flip = 0, l = (1 << n) - 1;\\n        while (k > 1) {\\n            if (k == l / 2 + 1)\\n                return \\'0\\' + (flip ^ 1);\\n            if (k > l / 2) {\\n                k = l + 1 - k;\\n                flip ^= 1;\\n            }\\n            l /= 2;\\n        }\\n        return \\'0\\' + flip;\\n    }\\n```\\n3. Fast solution not too difficult to come up with using Divide and Conquer! (**100% Faster and 92% less Space used)**\\n\\n```\\nclass Solution {\\npublic:    \\n    \\n   int form(int n, int k){\\n        if(n == 1 && k == 1) \\n            return 0;\\n       \\n        int mid = (1 << (n-1));\\n       \\n        if(k < mid) \\n            return form(n - 1, k);\\n        else if(k == mid) \\n            return 1;\\n        else \\n            return !( form(n - 1, (mid << 1) - k));\\n    }\\n    \\n    char findKthBit(int n, int k) {                       \\n        return (form(n,k) + \\'0\\');\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    \\n    string invert(string x){\\n        for(int i=0; i<x.size(); i++){\\n            if(x[i]==\\'0\\') x[i] =\\'1\\';\\n            else x[i] =\\'0\\';\\n        }            \\n        return x;\\n    }      \\n    \\n    string formSequence(int n){\\n        if(n==0)\\n            return \"0\";                \\n        \\n        string s = formSequence(n-1);\\n        string result=\"\";        \\n        \\n        // Compute formSequence(n)                \\n        string rev = invert(s);\\n        reverse(rev.begin(), rev.end());\\n        result = s + \"1\" + rev;\\n        \\n        return result;\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        string s = formSequence(n);\\n        return s[k-1];\\n    }\\n};\\n```\n```\\nchar findKthBit(int n, int k) {\\n        int flip = 0, l = (1 << n) - 1;\\n        while (k > 1) {\\n            if (k == l / 2 + 1)\\n                return \\'0\\' + (flip ^ 1);\\n            if (k > l / 2) {\\n                k = l + 1 - k;\\n                flip ^= 1;\\n            }\\n            l /= 2;\\n        }\\n        return \\'0\\' + flip;\\n    }\\n```\n```\\nclass Solution {\\npublic:    \\n    \\n   int form(int n, int k){\\n        if(n == 1 && k == 1) \\n            return 0;\\n       \\n        int mid = (1 << (n-1));\\n       \\n        if(k < mid) \\n            return form(n - 1, k);\\n        else if(k == mid) \\n            return 1;\\n        else \\n            return !( form(n - 1, (mid << 1) - k));\\n    }\\n    \\n    char findKthBit(int n, int k) {                       \\n        return (form(n,k) + \\'0\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653278,
                "title": "java-recursion-0ms-easy-to-understand-similar-to-kth-symbol-in-grammar",
                "content": "Grammar Defintion : \\n```\\n* S1 = \"0\"\\n* Si = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\\n```\\n\\nreverse(\"abc\") -> \"cba\" {reversed the given string}\\ninvert(\\'0\\') -> \\'1\\' \\ninvert(\\'1\\') -> \\'0\\'\\ninvert() is just flipping the bit.\\n\\nNow according to given equation \\n``` S2 = S1 + \"1\" + reverse(invert(S1))\\n\\t=> S2 = \"0\" + \"1\" + reverse(invert(\"0\"))\\n\\t=> S2 = \"0\" + \"1\" + reverse(\"1\")\\n\\t=> S2 = \"0\" + \"1\" + \"1\"\\n\\t=> S2 = \"011\"\\n```\\n\\nNow lets generate few strings from starting to see if there were any patterns.\\n```\\nS1 = \"0\"\\nS2 = \"011\"\\nS3 = \"0111001\"\\nS4 = \"011100110110001\"\\n```\\n\\n**Observation 1**: We can make some observations regarding length of the string as\\n```Length of string Si = Math.pow(2, i) - 1```\\nLength 0f S1 = 1 => 2 - 1\\nLength of S2 = 3 => 4 - 1\\nLength of S3 = 7 => 8 - 1\\n\\n**Observation2**: Length of all the strings are odd numbers.\\n\\nObserve S3 and S2\\nS2 = \"011\"\\nS3 = \"0111001\"\\nSplit S3 nto 3 parts as per the given equations S2 + \"1\" + reverse(invert(S2))\\nIf we were to find kth bit in S3 then we can limit our search by observing where the kth bit came from by using the equation.\\n\\nlength of S3 = 7\\nmid = length of S3 / 2 => 3\\nend = 2\\n\\nSplit the String S3 from indexes 1 to mid, mid + 1 and mid +2 to end => String from 1 to 3, String at 4 and String from 5 to 7.\\n\\nIn S3 first 3 characters(k=1,2,3) are same as the characters in S2\\n* This means if we want to find a character among the first partition (1 to mid) the we can get it from the character at same index from the previous string(in this case S2).\\n\\nNext character(k = 4) is the \"1\" added while generating the string S3\\n\\nThe remaining 3 characters(k = 5,6,7) are the inverse of reversed character of S2 i.e\\n* **5th** character in S3 is inverse of **3rd** character in S2\\n* **6th** character in S3 in inverse of **2nd** character in S2\\n* **7th** character in S3 is inverser of **1st** character in S2.\\n\\nIf we observe the numbers those sum up to **8** which is the length of String S3 + 1.\\n\\nThis means if we want to find a character among the last partition with index k then we can get the character by inverting the character at index length + 1 - k in the prevous string(in this case S2).\\n\\nThe same observations can be made for strings S4, S3 and S2, S1. By using these repeated patterns we can solve the problem.\\n\\nCode using the observations:\\n\\n```\\npublic char findKthBit(int n, int k) {\\n        if(n==1 && k==1) return \\'0\\';\\n        int length = (int)Math.pow(2,n) - 1;\\n        int mid = length / 2;\\n        if(k <= mid) return findKthBit(n-1, k);\\n        else if(k > mid + 1) return invert(findKthBit(n-1, length + 1 - k));\\n        else return \\'1\\';\\n    }\\n```\\n\\ninvert() was not provided so we have to write it\\n```\\npublic char invert(char c) {\\n        if(c == \\'0\\') return \\'1\\';\\n        else return \\'0\\';\\n    }\\n```\\n\\nThis problem is similar to [K-th Symbol in Grammar](https://leetcode.com/problems/k-th-symbol-in-grammar/).\\n\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n* S1 = \"0\"\\n* Si = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\\n```\n``` S2 = S1 + \"1\" + reverse(invert(S1))\\n\\t=> S2 = \"0\" + \"1\" + reverse(invert(\"0\"))\\n\\t=> S2 = \"0\" + \"1\" + reverse(\"1\")\\n\\t=> S2 = \"0\" + \"1\" + \"1\"\\n\\t=> S2 = \"011\"\\n```\n```\\nS1 = \"0\"\\nS2 = \"011\"\\nS3 = \"0111001\"\\nS4 = \"011100110110001\"\\n```\n```Length of string Si = Math.pow(2, i) - 1```\n```\\npublic char findKthBit(int n, int k) {\\n        if(n==1 && k==1) return \\'0\\';\\n        int length = (int)Math.pow(2,n) - 1;\\n        int mid = length / 2;\\n        if(k <= mid) return findKthBit(n-1, k);\\n        else if(k > mid + 1) return invert(findKthBit(n-1, length + 1 - k));\\n        else return \\'1\\';\\n    }\\n```\n```\\npublic char invert(char c) {\\n        if(c == \\'0\\') return \\'1\\';\\n        else return \\'0\\';\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1585009,
                "title": "c-beats-100-time-beats-70-space-recursive-solution",
                "content": "**Observations-:**\\n1. First half of string of length `n` is same as that of string for `n-1`\\n2. Total length of string is always `(2^n)-1`\\n3. Second half the string each letter at position `x` is the complement of element at position `(2^n)-x` \\n\\n**Approach-:**\\n*Base Cases:* \\n1. if `n==1 or k==1` value always `0`\\n2. if `(k==(2^n)/2)` value is `1`, as we adding 1 before string and its reverse\\n3. if `k==(2^n)-1` that is last character for particular `n`, then value is 1\\n\\nSince we can get the string for `n` using `n-1` and value of `k` changes as explained above that goes in recursive case. \\nIf `k<(2^n/2)`, then `k` is pass `k` as it is.\\nIf `k>(2^n/2)`, then `k` is the complement of `(2^n)-k` th position element.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int recur(int n,int k){\\n        if(n==1 || k==1) return 0;\\n        if(k==(pow(2,n)/2) || k==(pow(2,n)-1)) return 1;\\n        else if(k<(pow(2,n)/2)) return recur(n-1,k);\\n        else if(k>(pow(2,n)/2)) return !recur(n-1,(int)(pow(2,n)-k));\\n        return 0;\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        int ch = recur(n,k);\\n        return ch+\\'0\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recur(int n,int k){\\n        if(n==1 || k==1) return 0;\\n        if(k==(pow(2,n)/2) || k==(pow(2,n)-1)) return 1;\\n        else if(k<(pow(2,n)/2)) return recur(n-1,k);\\n        else if(k>(pow(2,n)/2)) return !recur(n-1,(int)(pow(2,n)-k));\\n        return 0;\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        int ch = recur(n,k);\\n        return ch+\\'0\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566054,
                "title": "java-string-straightforward-solution",
                "content": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        String str = \"0\";\\n        for(int i=0;i<n-1;i++){\\n            String temp = str;\\n            temp = temp.replace(\"1\",\"*\");\\n            temp = temp.replace(\"0\",\"1\");\\n            temp = temp.replace(\"*\",\"0\");\\n            StringBuilder sb = new StringBuilder(temp);\\n            str=str+\"1\"+sb.reverse().toString();\\n        }\\n        return str.charAt(k-1);\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        String str = \"0\";\\n        for(int i=0;i<n-1;i++){\\n            String temp = str;\\n            temp = temp.replace(\"1\",\"*\");\\n            temp = temp.replace(\"0\",\"1\");\\n            temp = temp.replace(\"*\",\"0\");\\n            StringBuilder sb = new StringBuilder(temp);\\n            str=str+\"1\"+sb.reverse().toString();\\n        }\\n        return str.charAt(k-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782719,
                "title": "o-n-time-complexity-o-1-space-beats-100-binary-search",
                "content": "This is O(n) solution works for n = 64\\n```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if (n == 1)\\n            return \\'0\\';\\n        k--;\\n        long len = (long) Math.pow(2, n) - 2;\\n        long low = 0, high = len, mid = len / 2;\\n        char bit = \\'1\\';\\n        while ((high - low) > 2){\\n            if (k == mid)\\n                break;\\n            if (k < mid) {\\n                bit = \\'1\\';\\n                high = mid - 1;\\n            }\\n            else {\\n                bit = \\'0\\';\\n                low = mid + 1;\\n            }\\n            mid = (high + low) / 2;\\n        }\\n        if (k == mid)\\n            return bit;\\n        return (k == low) ? \\'0\\' : \\'1\\';\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if (n == 1)\\n            return \\'0\\';\\n        k--;\\n        long len = (long) Math.pow(2, n) - 2;\\n        long low = 0, high = len, mid = len / 2;\\n        char bit = \\'1\\';\\n        while ((high - low) > 2){\\n            if (k == mid)\\n                break;\\n            if (k < mid) {\\n                bit = \\'1\\';\\n                high = mid - 1;\\n            }\\n            else {\\n                bit = \\'0\\';\\n                low = mid + 1;\\n            }\\n            mid = (high + low) / 2;\\n        }\\n        if (k == mid)\\n            return bit;\\n        return (k == low) ? \\'0\\' : \\'1\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781105,
                "title": "modular-clean-code-easy-to-read-easy-to-write",
                "content": "```\\nclass Solution {\\npublic:\\n    void inverse(string &s) {\\n        for (auto &c: s) {\\n            c = (c == \\'0\\') ? \\'1\\' : \\'0\\';\\n        }\\n    }\\n    string reverseInverse(string s) {\\n        inverse(s);     \\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        map<int, string> m;\\n        string current = \"0\";\\n        for (int i=2; i<=n; i++) {\\n            current += \"1\" + reverseInverse(current);\\n        }\\n        return current[k-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void inverse(string &s) {\\n        for (auto &c: s) {\\n            c = (c == \\'0\\') ? \\'1\\' : \\'0\\';\\n        }\\n    }\\n    string reverseInverse(string s) {\\n        inverse(s);     \\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        map<int, string> m;\\n        string current = \"0\";\\n        for (int i=2; i<=n; i++) {\\n            current += \"1\" + reverseInverse(current);\\n        }\\n        return current[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508890,
                "title": "recursive-solution-c-easy",
                "content": "\\t******please upvote*********\\uD83D\\uDE0D\\uD83D\\uDE0D\\n\\tclass Solution\\n\\t\\t{\\n\\t\\tpublic:\\n\\t\\tchar findKthBit(int n, int k)\\n\\t\\t{\\n\\t\\t\\tif (n == 1 && k == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn \\'0\\';\\n\\t\\t\\t}\\n\\t\\t\\tint l = pow(2, n);\\n\\t\\t\\tint mid = l / 2;\\n\\t\\t\\tif (k == mid)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn \\'1\\';  //cz mid element will be always 1\\n\\t\\t\\t}\\n\\t\\t\\telse if (k < mid)\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar ans = findKthBit(n - 1, k);//previous row and will be same as before  the mid of current row\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar ans = findKthBit(n - 1, l - k);\\n\\t\\t\\t\\tif (ans == \\'0\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn \\'1\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn \\'0\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution\\n\\t\\t{\\n\\t\\tpublic:\\n\\t\\tchar findKthBit(int n, int k)\\n\\t\\t{\\n\\t\\t\\tif (n == 1 && k == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn \\'0\\';\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1470721,
                "title": "java-recursion-solution",
                "content": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        return getChar(\"0\", n, k);\\n    }\\n    static char getChar(String s, int n, int k) {\\n        if (s.length() >= k)\\n            return s.charAt(k - 1);\\n        return getChar(s + \"1\" + reverseInvert(s), n - 1, k);\\n    }\\n    static String reverseInvert(String s) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'0\\')\\n                sb.append(\\'1\\');\\n            else \\n                sb.append(\\'0\\');\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        return getChar(\"0\", n, k);\\n    }\\n    static char getChar(String s, int n, int k) {\\n        if (s.length() >= k)\\n            return s.charAt(k - 1);\\n        return getChar(s + \"1\" + reverseInvert(s), n - 1, k);\\n    }\\n    static String reverseInvert(String s) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'0\\')\\n                sb.append(\\'1\\');\\n            else \\n                sb.append(\\'0\\');\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780893,
                "title": "javascript-math-problem-o-min-n-logk",
                "content": "The idea is to check the invert times of the specific digits\\nex: `n = 4, k = 11 (011100110110001)`\\n`s[11] = ~s[5] = ~(~s[3]) = ~(~(~s[1])) = \\'1\\'`\\nFrom above case, we can notice that\\n`8 < 11 < 16`, the mirror number is `16 - 11 = 5`;\\n`4 < 5 < 8`, the mirror number is `8 - 5 = 3`;\\n`2 < 3 < 4`, the mirror number is `4 - 3 = 1`;\\n \\n ```\\n var findKthBit = function(n, k) {\\n    if (k === 1)    return \\'0\\';\\n    if (k === 2)    return \\'1\\';\\n    \\n    let binary = 2;\\n    while (binary < k) {\\n        binary *= 2;\\n    }\\n    \\n    let count = 0;\\n    while (binary > 2) {\\n        if (k == binary/2) {\\n//             The starting number is 1 if at position power of 2 (2^x)\\n            return (count%2 == 0) ? \\'1\\' : \\'0\\';\\n        }\\n        if (k > binary/2) {\\n            k = binary-k;\\n            count++;\\n        }\\n        binary /= 2;\\n    }\\n\\n    return (count%2 == 0) ? \\'0\\' : \\'1\\';\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "The idea is to check the invert times of the specific digits\\nex: `n = 4, k = 11 (011100110110001)`\\n`s[11] = ~s[5] = ~(~s[3]) = ~(~(~s[1])) = \\'1\\'`\\nFrom above case, we can notice that\\n`8 < 11 < 16`, the mirror number is `16 - 11 = 5`;\\n`4 < 5 < 8`, the mirror number is `8 - 5 = 3`;\\n`2 < 3 < 4`, the mirror number is `4 - 3 = 1`;\\n \\n ```\\n var findKthBit = function(n, k) {\\n    if (k === 1)    return \\'0\\';\\n    if (k === 2)    return \\'1\\';\\n    \\n    let binary = 2;\\n    while (binary < k) {\\n        binary *= 2;\\n    }\\n    \\n    let count = 0;\\n    while (binary > 2) {\\n        if (k == binary/2) {\\n//             The starting number is 1 if at position power of 2 (2^x)\\n            return (count%2 == 0) ? \\'1\\' : \\'0\\';\\n        }\\n        if (k > binary/2) {\\n            k = binary-k;\\n            count++;\\n        }\\n        binary /= 2;\\n    }\\n\\n    return (count%2 == 0) ? \\'0\\' : \\'1\\';\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3077109,
                "title": "recursive-solution-simple-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string invert(string s){\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\')s[i]=\\'0\\';\\n            else\\n            s[i]=\\'1\\';\\n        }\\n        return s;\\n    }\\n    string reverse(string s){\\n        int i=0,j=s.length()-1;\\n        while(i<=j){\\n            swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n    string findValue(int n,string s){\\n        if(n==1){\\n            return s+\"0\";\\n        }\\n        string temp1=findValue(n-1,s);\\n        string temp2=invert(temp1);\\n        string temp3=reverse(temp2);\\n        return temp1+\"1\"+temp3;\\n    }\\n    char findKthBit(int n, int k) {\\n        string res=findValue(n,\"\");\\n        return res[k-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string invert(string s){\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\')s[i]=\\'0\\';\\n            else\\n            s[i]=\\'1\\';\\n        }\\n        return s;\\n    }\\n    string reverse(string s){\\n        int i=0,j=s.length()-1;\\n        while(i<=j){\\n            swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n    string findValue(int n,string s){\\n        if(n==1){\\n            return s+\"0\";\\n        }\\n        string temp1=findValue(n-1,s);\\n        string temp2=invert(temp1);\\n        string temp3=reverse(temp2);\\n        return temp1+\"1\"+temp3;\\n    }\\n    char findKthBit(int n, int k) {\\n        string res=findValue(n,\"\");\\n        return res[k-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958055,
                "title": "c-recursion-faster-than-100",
                "content": "# Find Kth Bit in Nth Binary String\\nHere\\'s a comprehensive guide to the solution.\\n\\n![Screenshot 2022-12-27 171237.jpg](https://assets.leetcode.com/users/images/72127d92-d773-444a-a6e6-807616302496_1672141365.2253892.jpeg)\\n\\n\\n## Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea of solving this through recursion comes fairly naturally. Considering that the constraints tell that the length number could be as large as 2^20 -- this eliminates the possibility to use string-to-long-long conversion since even iterating through one for loop with these contraints will be computationally impossible for one machine.\\n\\n## Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is fairly simple:\\n- If n==1, then return *\\'0\\'* since the start of every number is the bit *\\'0\\'*.\\n- if k is the middle bit of the string, return *\\'1\\'* since we concatenate two strings with *\\'1\\'* in between.\\n- if k is anywhere before the middle bit of the string, answer will be same as *findKthBit(n-1,k)* since k belongs to the first concatenated string (which isn\\'t reversed).\\n- Else if k is a value after the middle bit, we must do some [calculations](##calculations) for k\\n\\n## Calculations for last case:\\nFirst we must reduce k to the number of bits it is ahead of the middle bit. Hence \\n```\\n=> knew = k - (2^(n))/2 \\n=> knew = k - 2^(n-1)\\n```\\nNow, we need to find the value of this knew when the string is reversed (remember this is the reversed string). Hence,\\n```\\n=> knew = 2^(nnew)-knew\\nputting values of nnew and knew, this becomes:\\n=> knew = 2^(n-1)-(k-2^(n-1))\\n=> knew = 2*2^(n-1)-k\\n=> knew = 2^(n)-k\\n```\\n## Complexity\\n- Time complexity: *O(log(n))*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *O(1)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        if(n==1){\\n            return \\'0\\'; \\n        }\\n        if(pow(2,n)/k==2){\\n            return \\'1\\';\\n        }\\n        if(k<pow(2,n)/2){\\n            return findKthBit(n-1,k);\\n        }\\n        k = pow(2,n)-k;\\n        if(findKthBit(n-1,k)==\\'1\\'){\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n=> knew = k - (2^(n))/2 \\n=> knew = k - 2^(n-1)\\n```\n```\\n=> knew = 2^(nnew)-knew\\nputting values of nnew and knew, this becomes:\\n=> knew = 2^(n-1)-(k-2^(n-1))\\n=> knew = 2*2^(n-1)-k\\n=> knew = 2^(n)-k\\n```\n```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        if(n==1){\\n            return \\'0\\'; \\n        }\\n        if(pow(2,n)/k==2){\\n            return \\'1\\';\\n        }\\n        if(k<pow(2,n)/2){\\n            return findKthBit(n-1,k);\\n        }\\n        k = pow(2,n)-k;\\n        if(findKthBit(n-1,k)==\\'1\\'){\\n            return \\'0\\';\\n        }\\n        return \\'1\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956159,
                "title": "c-100-faster-solution-easy-recursive-implementation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        if(n==1)\\n            return \\'0\\';\\n        int half = pow(2,n-1);\\n        if(k<half)\\n            return findKthBit(n-1,k);\\n        else if(k==half){\\n            return \\'1\\';\\n        }\\n        else{\\n            if(findKthBit(n-1,(2*half)-k) == \\'1\\')\\n                return \\'0\\';\\n            else\\n                return \\'1\\';\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        if(n==1)\\n            return \\'0\\';\\n        int half = pow(2,n-1);\\n        if(k<half)\\n            return findKthBit(n-1,k);\\n        else if(k==half){\\n            return \\'1\\';\\n        }\\n        else{\\n            if(findKthBit(n-1,(2*half)-k) == \\'1\\')\\n                return \\'0\\';\\n            else\\n                return \\'1\\';\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028230,
                "title": "c-recursion-easy-100-faster",
                "content": "**[C++] Recursive Based Solution**\\n**Easy Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        // This is the base Case\\n        if(n==1 && k==1)\\n            return \\'0\\';\\n        \\n        int mid=(1<<(n-1));    // This means pow(2,n-1) or 2^(n-1).\\n        \\n        // If our k is equal to mid then we will return \\'1\\', Mid bit will Always \\'1\\';\\n        if(k==mid)\\n            return \\'1\\';\\n        \\n        // In this case if our k<mid\\n        // Then our kth bit we found in (n-1)th string so we recursively return (n-1,k) \\n        if(k<mid)\\n            return findKthBit(n-1,k);\\n        \\n        // If k is greater than mid then kth bit will be reverse of [(2^n)-k]th bit.\\n        // Check on pen paper once\\n        if(findKthBit(n-1,mid*2-k)==\\'0\\')\\n            return \\'1\\';\\n        else\\n            return \\'0\\';\\n    }\\n};\\n```\\n**If YOU Find it helpful Kindly UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        // This is the base Case\\n        if(n==1 && k==1)\\n            return \\'0\\';\\n        \\n        int mid=(1<<(n-1));    // This means pow(2,n-1) or 2^(n-1).\\n        \\n        // If our k is equal to mid then we will return \\'1\\', Mid bit will Always \\'1\\';\\n        if(k==mid)\\n            return \\'1\\';\\n        \\n        // In this case if our k<mid\\n        // Then our kth bit we found in (n-1)th string so we recursively return (n-1,k) \\n        if(k<mid)\\n            return findKthBit(n-1,k);\\n        \\n        // If k is greater than mid then kth bit will be reverse of [(2^n)-k]th bit.\\n        // Check on pen paper once\\n        if(findKthBit(n-1,mid*2-k)==\\'0\\')\\n            return \\'1\\';\\n        else\\n            return \\'0\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706698,
                "title": "c-100-fast-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        \\n        // if k is 1, we know it is 0.. given in question\\n        if(k == 1)\\n            return \\'0\\';\\n        \\n        // if k was a 1 that was added in middle with going from Si-1 to Si\\n        if((k&(k-1)) == 0)\\n            return \\'1\\';\\n        k--;\\n        int x = 1;\\n        \\n        // storing total string length in x\\n        while(n--)\\n        {\\n            x<<=1;\\n        }\\n        x--;\\n        \\n        // So we will reverse the process of string formation...\\n        // the general approach is that we will reduce the string size to half at every iteration\\n        // till the time string size is 1.. that is.. the string becomes the initial \\'0\\'\\n        // at each step, if kth bit is in 2nd half, the reverse and invert operation will take placee.. So apply them..\\n        // if kth bit is in 1st half, then it stays the same... no operation needed..\\n        \\n        // now lets assume that kth bit is 1... and let z represent the kth bit\\n        // now we will try to reduce k to 1st bit while applying the given rules..\\n        // if z becomes 0 (at last when it is reduced to 1st bit), then initially z being 1 at kth was true so return 1\\n        // else if finally z becomes 1, then our assumption was opposite to answer so just return 0...\\n        int z = 1;\\n        while(x!=1)\\n        {\\n            // if at any point, k becomes that bit at which 1 was added while going from Si-1 to Si, then break the loop and put an extra \\n            // invert operation....\\n            if((k&(k+1)) == 0 && k == x/2)\\n            {\\n                z^=1;\\n                break;\\n            }\\n            // if k is in first half of the string, we know that no changes happen to it in this iteration of halving the string...\\n            // But if k is in 2nd half, map k to the number from which it came!!! also invert it...\\n            if(k>x/2)\\n            {\\n                z^=1;\\n                k = x/2 - (k - x/2);\\n            }\\n            x>>=1;\\n                \\n        }\\n            \\n        return z==0? \\'1\\':\\'0\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        \\n        // if k is 1, we know it is 0.. given in question\\n        if(k == 1)\\n            return \\'0\\';\\n        \\n        // if k was a 1 that was added in middle with going from Si-1 to Si\\n        if((k&(k-1)) == 0)\\n            return \\'1\\';\\n        k--;\\n        int x = 1;\\n        \\n        // storing total string length in x\\n        while(n--)\\n        {\\n            x<<=1;\\n        }\\n        x--;\\n        \\n        // So we will reverse the process of string formation...\\n        // the general approach is that we will reduce the string size to half at every iteration\\n        // till the time string size is 1.. that is.. the string becomes the initial \\'0\\'\\n        // at each step, if kth bit is in 2nd half, the reverse and invert operation will take placee.. So apply them..\\n        // if kth bit is in 1st half, then it stays the same... no operation needed..\\n        \\n        // now lets assume that kth bit is 1... and let z represent the kth bit\\n        // now we will try to reduce k to 1st bit while applying the given rules..\\n        // if z becomes 0 (at last when it is reduced to 1st bit), then initially z being 1 at kth was true so return 1\\n        // else if finally z becomes 1, then our assumption was opposite to answer so just return 0...\\n        int z = 1;\\n        while(x!=1)\\n        {\\n            // if at any point, k becomes that bit at which 1 was added while going from Si-1 to Si, then break the loop and put an extra \\n            // invert operation....\\n            if((k&(k+1)) == 0 && k == x/2)\\n            {\\n                z^=1;\\n                break;\\n            }\\n            // if k is in first half of the string, we know that no changes happen to it in this iteration of halving the string...\\n            // But if k is in 2nd half, map k to the number from which it came!!! also invert it...\\n            if(k>x/2)\\n            {\\n                z^=1;\\n                k = x/2 - (k - x/2);\\n            }\\n            x>>=1;\\n                \\n        }\\n            \\n        return z==0? \\'1\\':\\'0\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597260,
                "title": "java-simple-brute-force-recursive-maths-solutions-100-faster",
                "content": "**Brute Force using StringBuilder**\\n```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if (n == 1)\\n            return \\'0\\';\\n        StringBuilder builder = new StringBuilder();\\n        builder.append(0);\\n        for (int i = 2; i <= n; i++) {\\n            String current = builder.toString();\\n            builder = generate(builder, new StringBuilder());\\n            if (builder.length() >= k)\\n                return builder.charAt(k - 1);\\n        }\\n        return builder.charAt(k - 1);\\n    }\\n    StringBuilder generate(StringBuilder old, StringBuilder current) {\\n        String oldS = old.toString();\\n        current.append(oldS);\\n        current.append(1);\\n        old = old.reverse();\\n        String invert = old.toString().replace(\\'0\\', \\'2\\').replace(\\'1\\', \\'0\\').replace(\\'2\\', \\'1\\');\\n        current.append(invert);\\n        return current;\\n    }\\n}\\n```\\n**Recursive 100% Faster**\\n```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if (n == 1 || k == 1)\\n            return \\'0\\';\\n        if (k == (Math.pow(2, n) / 2) || (k == (Math.pow(2, n) - 1)))\\n            return \\'1\\';\\n        if (k < Math.pow(2, n) / 2)\\n            return findKthBit(n - 1, k);\\n        if (k > Math.pow(2,n) / 2) \\n            return findKthBit(n - 1, (int) Math.pow(2, n) - k) == \\'0\\' ? \\'1\\' : \\'0\\';\\n        return \\'0\\';\\n    }\\n}\\n```\\nPlease **upvote** :-)",
                "solutionTags": [
                    "Java",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if (n == 1)\\n            return \\'0\\';\\n        StringBuilder builder = new StringBuilder();\\n        builder.append(0);\\n        for (int i = 2; i <= n; i++) {\\n            String current = builder.toString();\\n            builder = generate(builder, new StringBuilder());\\n            if (builder.length() >= k)\\n                return builder.charAt(k - 1);\\n        }\\n        return builder.charAt(k - 1);\\n    }\\n    StringBuilder generate(StringBuilder old, StringBuilder current) {\\n        String oldS = old.toString();\\n        current.append(oldS);\\n        current.append(1);\\n        old = old.reverse();\\n        String invert = old.toString().replace(\\'0\\', \\'2\\').replace(\\'1\\', \\'0\\').replace(\\'2\\', \\'1\\');\\n        current.append(invert);\\n        return current;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if (n == 1 || k == 1)\\n            return \\'0\\';\\n        if (k == (Math.pow(2, n) / 2) || (k == (Math.pow(2, n) - 1)))\\n            return \\'1\\';\\n        if (k < Math.pow(2, n) / 2)\\n            return findKthBit(n - 1, k);\\n        if (k > Math.pow(2,n) / 2) \\n            return findKthBit(n - 1, (int) Math.pow(2, n) - k) == \\'0\\' ? \\'1\\' : \\'0\\';\\n        return \\'0\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1463201,
                "title": "simple-recursion-using-c",
                "content": "```\\nbool findans(int n,int k){\\n        if(n==1&&k==1){\\n            return 0;\\n        }\\n        cout<<k<<endl;\\n        int u=pow(2,n);\\n        if(k==u/2){\\n            return 1;\\n        }\\n        if(k>u/2){\\n            return !findans(n-1,u-k);\\n        }else{\\n            return findans(n-1,k);\\n        }\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        if(findans(n,k)){\\n            return \\'1\\';\\n        }else{\\n            return \\'0\\';\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool findans(int n,int k){\\n        if(n==1&&k==1){\\n            return 0;\\n        }\\n        cout<<k<<endl;\\n        int u=pow(2,n);\\n        if(k==u/2){\\n            return 1;\\n        }\\n        if(k>u/2){\\n            return !findans(n-1,u-k);\\n        }else{\\n            return findans(n-1,k);\\n        }\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        if(findans(n,k)){\\n            return \\'1\\';\\n        }else{\\n            return \\'0\\';\\n        }\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 781185,
                "title": "binary-string-properties",
                "content": "It\\'s easy to see that sequence that starts from S_1=\"1\" differs from the original only in odd places (1-based, bits in odd places are inverted in the new sequence). The new sequence has the following properties (can be proved by induction):\\n1) Subsequence of the bits in odd places form the sequence 1010...10.\\n2) Subsequence of the bits in even places for S_n form the sequence S_(n-1).\\n\\nThe following solution is based on the above properties.\\n```\\nchar findKthBit(int n, int k)\\n{\\n\\tif (k % 2 == 1) return (k / 2 & 1) + \\'0\\';\\n\\twhile (k % 2 == 0) k /= 2;\\n\\treturn ((k + 1) / 2 & 1) + \\'0\\';\\n}\\n```\\n\\nSketch of the proof for property 2.\\n\\nDenote by e(str) the subsequence of the bits in even places of the string str. From the defenition of the sequence S_n we have S_n = S_(n-1) + \"1\" + reverse(invert(S_(n-1)). Length of the S_n is always odd. Thus, reverse moves every bit in even place to the new even place (e and reverse commute). This implies that e(S_n) = e(S_(n-1)) + \"1\" + e(reverse(invert(S_(n-1)))) = e(S_(n-1)) + \"1\" + reverse(invert(e(S_(n-1)))) = S_(n-2) + \"1\" + reverse(invert(S_(n-2))) = S_(n-1).",
                "solutionTags": [],
                "code": "```\\nchar findKthBit(int n, int k)\\n{\\n\\tif (k % 2 == 1) return (k / 2 & 1) + \\'0\\';\\n\\twhile (k % 2 == 0) k /= 2;\\n\\treturn ((k + 1) / 2 & 1) + \\'0\\';\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781067,
                "title": "c-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        vector<string> s(n);\\n        \\n        s[0] = \"0\";\\n        for(int i = 1; i < n; i++) {\\n            s[i] = s[i-1] + \"1\" + reverseStr(invert(s[i-1]));\\n        }\\n       // cout<<s[n]<<endl;\\n        string res = s[n-1];\\n        return res[k-1];\\n    }\\n    string invert(string s) {\\n       for(int i = 0; i < s.length(); i++) {\\n           if(s[i] == \\'1\\')\\n               s[i] = \\'0\\';\\n           else\\n               s[i] = \\'1\\';\\n       }\\n        return s;\\n    }\\n    string reverseStr(string s) {\\n        int start = 0, end = s.length() -1;\\n        while(start<end) {\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        vector<string> s(n);\\n        \\n        s[0] = \"0\";\\n        for(int i = 1; i < n; i++) {\\n            s[i] = s[i-1] + \"1\" + reverseStr(invert(s[i-1]));\\n        }\\n       // cout<<s[n]<<endl;\\n        string res = s[n-1];\\n        return res[k-1];\\n    }\\n    string invert(string s) {\\n       for(int i = 0; i < s.length(); i++) {\\n           if(s[i] == \\'1\\')\\n               s[i] = \\'0\\';\\n           else\\n               s[i] = \\'1\\';\\n       }\\n        return s;\\n    }\\n    string reverseStr(string s) {\\n        int start = 0, end = s.length() -1;\\n        while(start<end) {\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2959608,
                "title": "java-recursion-0ms-runtime",
                "content": "**Given:** \\n\\n```\\nS1 = \"0\"\\nSi = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\\nS2 = \"011\"\\nS3 = \"0111001\"\\n```\\n**Runtime : 0ms**\\n\\n![image.png](https://assets.leetcode.com/users/images/ecdb4d13-ce07-455a-aaa0-d56d51134f6a_1672165358.8072896.png)\\n\\n\\n# Approach\\n**XOR Property**\\n```\\n1^0=1\\n1^1=0\\n```\\n**Example:**\\n ```\\n S3 = S2 + \"1\" + reverse(invert(S2))\\n S3 = \"011\" + \"1\" + \"100\" = 011 1 100\\n here we can observe that invert of 011 which is S2 is 100 \\n ----------- Sn^1 = Invert of Sn ----------\\n so by simply adding S2+\"1\"+S2^1 we get the same answer of S3 or\\n Si is just Si-1 + \"1\" + Si-1^1 \\n```\\n\\n**Points through observation:**\\n\\n1. Middle element is always \"1\" (mid).\\n2. The part on right-side (>mid) from mid is invert of the elements on the  left-side (<mid) from mid. \\n3. Same process as **779. K-th Symbol in Grammar**\\n\\n**LeetCode : 779.K-th Symbol in Grammar will help understand this problem as it\\'s related:**\\n \\n```\\nclass Solution {\\n    public int kthGrammar(int n, int k) {\\n        return solve(n,k);\\n    }\\n    public static int solve(int n,int k)\\n    {\\n        if(n==1 || k==1)\\n        {\\n            return 0;\\n        }\\n        int mid=(int)((Math.pow(2,n))/2);\\n        if(k<=mid)\\n        {\\n            return solve(n-1,k);\\n        }\\n        else\\n        {\\n            return solve(n-1,)^1;\\n        }\\n    }\\n}\\n```\\n\\n\\n**How to get the element from left-side of mid which is ^1/inverse of right-side element???**\\n\\n```\\nTaking example:\\nString with index starting from 1:\\nString S = abcde\\nindex    = 12345\\n\\nreverse of S:\\nString S = edcba\\nindex    = 12345\\n\\nchar d is at index 4 on original string S, \\n             index 2 on reverse string  S\\n\\nlength of S    = 5\\noriginal index = 4\\nnew index      = (length of s)-(original index)+1;\\n```\\n\\n# Code\\n```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        int cc=solve(n,k);\\n        return cc==0?\\'0\\':\\'1\\';\\n    }\\n    public static int solve(int n,int k)\\n    {\\n        if(n==1||k==1)\\n        {\\n            return 0;\\n        }\\n        int len=(int)Math.pow(2,n)-1;\\n        int mid=((len)/2);\\n        if(mid==k-1)\\n        {\\n            return 1;\\n        }\\n        if(k-1<mid)\\n        {\\n            return solve(n-1,k);\\n        }\\n        else\\n        {\\n            return solve(n-1,len-k+1)^1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Shortest Path"
                ],
                "code": "```\\nS1 = \"0\"\\nSi = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\\nS2 = \"011\"\\nS3 = \"0111001\"\\n```\n```\\n1^0=1\\n1^1=0\\n```\n```\\n S3 = S2 + \"1\" + reverse(invert(S2))\\n S3 = \"011\" + \"1\" + \"100\" = 011 1 100\\n here we can observe that invert of 011 which is S2 is 100 \\n ----------- Sn^1 = Invert of Sn ----------\\n so by simply adding S2+\"1\"+S2^1 we get the same answer of S3 or\\n Si is just Si-1 + \"1\" + Si-1^1 \\n```\n```\\nclass Solution {\\n    public int kthGrammar(int n, int k) {\\n        return solve(n,k);\\n    }\\n    public static int solve(int n,int k)\\n    {\\n        if(n==1 || k==1)\\n        {\\n            return 0;\\n        }\\n        int mid=(int)((Math.pow(2,n))/2);\\n        if(k<=mid)\\n        {\\n            return solve(n-1,k);\\n        }\\n        else\\n        {\\n            return solve(n-1,)^1;\\n        }\\n    }\\n}\\n```\n```\\nTaking example:\\nString with index starting from 1:\\nString S = abcde\\nindex    = 12345\\n\\nreverse of S:\\nString S = edcba\\nindex    = 12345\\n\\nchar d is at index 4 on original string S, \\n             index 2 on reverse string  S\\n\\nlength of S    = 5\\noriginal index = 4\\nnew index      = (length of s)-(original index)+1;\\n```\n```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        int cc=solve(n,k);\\n        return cc==0?\\'0\\':\\'1\\';\\n    }\\n    public static int solve(int n,int k)\\n    {\\n        if(n==1||k==1)\\n        {\\n            return 0;\\n        }\\n        int len=(int)Math.pow(2,n)-1;\\n        int mid=((len)/2);\\n        if(mid==k-1)\\n        {\\n            return 1;\\n        }\\n        if(k-1<mid)\\n        {\\n            return solve(n-1,k);\\n        }\\n        else\\n        {\\n            return solve(n-1,len-k+1)^1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483224,
                "title": "c-solution-recursion",
                "content": "~~~\\nstring value(int n){\\n        if(n==1)\\n            return \"0\";\\n        string ans=value(n-1);\\n        string k=ans+\"1\";\\n        for(int i=0;i<ans.length();++i){\\n            if(ans[i]==\\'0\\')\\n                ans[i]=\\'1\\';\\n            else\\n                ans[i]=\\'0\\';\\n        }\\n        reverse(ans.begin(),ans.end());\\n        k+=ans; \\n        return k;\\n    }\\n    char findKthBit(int n, int k) {\\n        string ans= value(n);\\n        \\n        return ans[k-1];\\n    }\\n~~~",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "~~~\\nstring value(int n){\\n        if(n==1)\\n            return \"0\";\\n        string ans=value(n-1);\\n        string k=ans+\"1\";\\n        for(int i=0;i<ans.length();++i){\\n            if(ans[i]==\\'0\\')\\n                ans[i]=\\'1\\';\\n            else\\n                ans[i]=\\'0\\';\\n        }\\n        reverse(ans.begin(),ans.end());\\n        k+=ans; \\n        return k;\\n    }\\n    char findKthBit(int n, int k) {\\n        string ans= value(n);\\n        \\n        return ans[k-1];\\n    }\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2130176,
                "title": "java-bit-manipulation-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        return findKthBit(k); // n is irrelevant\\n    }\\n    \\n    public char findKthBit(int k) {\\n        if(k == 1)\\n            return \\'0\\';\\n        if((k & (k-1)) == 0) // k is a power of 2\\n            return \\'1\\';\\n        return findKthBit(upper(k) - k) == \\'0\\' ? \\'1\\' : \\'0\\';\\n    }\\n    \\n    private static int upper(int k){\\n\\t\\t// Find the smallest power of 2 greater than k\\n\\t\\t// E.g., if k = 1, return 2.\\n\\t\\t// If k = 2 or k = 3, return 4.\\n\\t\\t// If 4 <= k <= 7, return 8.\\n        int mask = 0x80000000, c = 0;\\n        while((mask & k) == 0){\\n            ++c;\\n            k <<= 1;\\n        }\\n        return mask >>> (c-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        return findKthBit(k); // n is irrelevant\\n    }\\n    \\n    public char findKthBit(int k) {\\n        if(k == 1)\\n            return \\'0\\';\\n        if((k & (k-1)) == 0) // k is a power of 2\\n            return \\'1\\';\\n        return findKthBit(upper(k) - k) == \\'0\\' ? \\'1\\' : \\'0\\';\\n    }\\n    \\n    private static int upper(int k){\\n\\t\\t// Find the smallest power of 2 greater than k\\n\\t\\t// E.g., if k = 1, return 2.\\n\\t\\t// If k = 2 or k = 3, return 4.\\n\\t\\t// If 4 <= k <= 7, return 8.\\n        int mask = 0x80000000, c = 0;\\n        while((mask & k) == 0){\\n            ++c;\\n            k <<= 1;\\n        }\\n        return mask >>> (c-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723036,
                "title": "java-recursive-easy",
                "content": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        return rec(n).charAt(k-1);\\n    }\\n    \\n\\t\\n    public String rec(int n) {\\n        if (n == 1){ \\n            return \"0\";\\n        } else {\\n            String s = rec(n-1);\\n            return s + \"1\" + reverse_and_invert(s);\\n        }\\n    }\\n    \\n\\t\\n    public String reverse_and_invert(String s) {\\n        char[] c = s.toCharArray();\\n        \\n        int i = 0;\\n        int j = c.length-1;\\n        \\n        while(i < j) {\\n            Character temp = c[i];\\n            c[i] = c[j] == \\'0\\' ? \\'1\\' : \\'0\\';\\n            c[j] = temp == \\'0\\' ? \\'1\\': \\'0\\';\\n            \\n            i++;\\n            j--;\\n        }\\n        \\n        if (c.length % 2 == 1) {\\n            c[i] = c[i] == \\'0\\' ? \\'1\\' : \\'0\\';\\n        }\\n        \\n        return String.valueOf(c);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        return rec(n).charAt(k-1);\\n    }\\n    \\n\\t\\n    public String rec(int n) {\\n        if (n == 1){ \\n            return \"0\";\\n        } else {\\n            String s = rec(n-1);\\n            return s + \"1\" + reverse_and_invert(s);\\n        }\\n    }\\n    \\n\\t\\n    public String reverse_and_invert(String s) {\\n        char[] c = s.toCharArray();\\n        \\n        int i = 0;\\n        int j = c.length-1;\\n        \\n        while(i < j) {\\n            Character temp = c[i];\\n            c[i] = c[j] == \\'0\\' ? \\'1\\' : \\'0\\';\\n            c[j] = temp == \\'0\\' ? \\'1\\': \\'0\\';\\n            \\n            i++;\\n            j--;\\n        }\\n        \\n        if (c.length % 2 == 1) {\\n            c[i] = c[i] == \\'0\\' ? \\'1\\' : \\'0\\';\\n        }\\n        \\n        return String.valueOf(c);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668278,
                "title": "recursive-java-brute-force-solution",
                "content": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if(k==1)\\n            return \\'0\\';\\n        return findNthString(\"0\", n).charAt(k-1);\\n    }\\n    \\n    public String findNthString(String s, int n) {\\n        if(n==0)\\n            return s;\\n        \\n        s = s + \"1\" + invertReverse(s);\\n        return findNthString(s, n-1);\\n    }\\n    \\n\\n    public String invertReverse(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<s.length(); i++) {\\n            if(s.charAt(i)==\\'1\\')\\n                sb.append(\\'0\\');\\n            else\\n                sb.append(\\'1\\');\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if(k==1)\\n            return \\'0\\';\\n        return findNthString(\"0\", n).charAt(k-1);\\n    }\\n    \\n    public String findNthString(String s, int n) {\\n        if(n==0)\\n            return s;\\n        \\n        s = s + \"1\" + invertReverse(s);\\n        return findNthString(s, n-1);\\n    }\\n    \\n\\n    public String invertReverse(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<s.length(); i++) {\\n            if(s.charAt(i)==\\'1\\')\\n                sb.append(\\'0\\');\\n            else\\n                sb.append(\\'1\\');\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539685,
                "title": "easy-c-solution",
                "content": "**If you like the solution please upvote it**\\n\\n    class Solution { \\n     public:\\n     char findKthBit(int n, int k) {        \\n        if(n==1 )\\n            return \\'0\\';\\n        \\n        int mid=((pow(2,n)-1)/2)+1;\\n        \\n        if(k==mid)\\n            return \\'1\\';\\n        \\n        else if(k<mid)\\n         return findKthBit(n-1,k);\\n        \\n        else\\n            return (findKthBit(n-1,mid-(k-mid))==\\'0\\')?\\'1\\':\\'0\\';\\n        \\n        }\\n\\t    };",
                "solutionTags": [],
                "code": "class Solution { \\n     public:\\n     char findKthBit(int n, int k) {        \\n        if(n==1 )\\n            return \\'0\\';\\n        \\n        int mid=((pow(2,n)-1)/2)+1;\\n        \\n        if(k==mid)\\n            return \\'1\\';\\n        \\n        else if(k<mid)\\n         return findKthBit(n-1,k);\\n        \\n        else\\n            return (findKthBit(n-1,mid-(k-mid))==\\'0\\')?\\'1\\':\\'0\\';\\n        \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1402188,
                "title": "cpp-recursive-solution",
                "content": "```\\nstring invertReverse(string str){\\n        int i =0;\\n        while(i<str.size()){\\n            if(str[i] == \\'0\\') str[i] = \\'1\\';\\n            else if(str[i] == \\'1\\') str[i] = \\'0\\';\\n            i++;\\n        }\\n        reverse(str.begin(), str.end());\\n        return str;\\n    }\\n    \\n    string findsn(int n){\\n        if (n==1) return \"0\";\\n        return (findsn(n-1) + \"1\" + invertReverse(findsn(n-1)));\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        string sn = findsn(n);\\n        return sn[k-1];\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nstring invertReverse(string str){\\n        int i =0;\\n        while(i<str.size()){\\n            if(str[i] == \\'0\\') str[i] = \\'1\\';\\n            else if(str[i] == \\'1\\') str[i] = \\'0\\';\\n            i++;\\n        }\\n        reverse(str.begin(), str.end());\\n        return str;\\n    }\\n    \\n    string findsn(int n){\\n        if (n==1) return \"0\";\\n        return (findsn(n-1) + \"1\" + invertReverse(findsn(n-1)));\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        string sn = findsn(n);\\n        return sn[k-1];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1373848,
                "title": "java-recursion-faster-than-100-o-n",
                "content": "Approach -  If k is the mid index of the string than bit will be \\'1\\'.\\n\\t\\t\\t\\t\\tIf k is less than mid than bit will be same as bit at k in S(n - 1).\\n\\t\\t\\t\\t\\tIf k is more than mid index than the bit at k in S(n) will be inverse of (2 * mid - k)th bit in S(n - 1)\\n```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if(n == 1) return \\'0\\';\\n        int mid = (int)Math.pow(2, n - 1);\\n        if(k == mid)\\n            return \\'1\\';\\n        else if(k < mid)\\n            return findKthBit(n - 1, k);\\n        char ch = findKthBit(n - 1, 2 * mid - k);\\n        return ch == \\'0\\' ? \\'1\\' : \\'0\\';\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if(n == 1) return \\'0\\';\\n        int mid = (int)Math.pow(2, n - 1);\\n        if(k == mid)\\n            return \\'1\\';\\n        else if(k < mid)\\n            return findKthBit(n - 1, k);\\n        char ch = findKthBit(n - 1, 2 * mid - k);\\n        return ch == \\'0\\' ? \\'1\\' : \\'0\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366862,
                "title": "c-tricky-solution-recursion",
                "content": "```\\nint solve(int n,int k){\\n     if(n==1 and k==1)\\n            return 0;\\n        int mid= pow(2,n)/2;\\n        if(k<mid)\\n            return solve(n-1,k);\\n        if(k==mid)\\n            return 1;\\n        \\n            return (!(solve(n-1,(2*mid)-k)));\\n    }\\n        \\n    char findKthBit(int n, int k) {\\n        int ans=solve(n,k);\\n        char res=ans+\\'0\\';\\n        return res;\\n       \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint solve(int n,int k){\\n     if(n==1 and k==1)\\n            return 0;\\n        int mid= pow(2,n)/2;\\n        if(k<mid)\\n            return solve(n-1,k);\\n        if(k==mid)\\n            return 1;\\n        \\n            return (!(solve(n-1,(2*mid)-k)));\\n    }\\n        \\n    char findKthBit(int n, int k) {\\n        int ans=solve(n,k);\\n        char res=ans+\\'0\\';\\n        return res;\\n       \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 902466,
                "title": "simple-recursive-c-solution-0ms-just-follows-problem-description",
                "content": "```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        if(n==1) {\\n            return \\'0\\';\\n        }\\n        int ln_1 = length(n-1);\\n        if(k <= ln_1) {\\n            return findKthBit(n-1, k);\\n        } else if(k == ln_1+1) {\\n            return \\'1\\';\\n        } else {\\n            int k1 = ln_1 - (k-ln_1-1) + 1;\\n            return (findKthBit(n-1, k1)==\\'0\\') ? \\'1\\' : \\'0\\';\\n        }\\n    }\\n    int length(int n) {\\n        if(n==1) {\\n            return 1;\\n        }\\n        return 2*length(n-1) + 1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        if(n==1) {\\n            return \\'0\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 823935,
                "title": "c-clear-recursion-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        \\tint mid = (int)pow(2,n-1);\\n            if(n == 1)\\n                return \\'0\\';\\n\\t\\t\\tif (k == mid)\\n\\t\\t\\t\\treturn \\'1\\';\\n\\t\\t\\telse if (k < mid)\\n\\t\\t\\t\\treturn findKthBit(n - 1, k);\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn \\'0\\' + \\'1\\' - findKthBit(n - 1, (int)pow(2, n) - k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        \\tint mid = (int)pow(2,n-1);\\n            if(n == 1)\\n                return \\'0\\';\\n\\t\\t\\tif (k == mid)\\n\\t\\t\\t\\treturn \\'1\\';\\n\\t\\t\\telse if (k < mid)\\n\\t\\t\\t\\treturn findKthBit(n - 1, k);\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn \\'0\\' + \\'1\\' - findKthBit(n - 1, (int)pow(2, n) - k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781719,
                "title": "python-simple-recursive-solution-28ms",
                "content": "1. Base case when `n=1 || k = 1`, return `0`\\n2. `k = mid`, return the middle `1`\\n3. If `k < mid`, we can find the `k`th  bit from `s_{n-1}`\\n4. Otherwise, when `k > mid`,  we first find the `2**n - k`th bit from `invert(s_{n-1})` and then  invert this bit. \\n For example, when `n = 4, k = 9, s_4 == 0111001 1 0110001` and `s_3 = 0111001`. The 9th bit of `s_4` is `0`, the `16 - 9 = 7`th bit of `s_3` is `1`, whose reverse is exactly `0`. \\n\\n\\n```python\\nclass Solution:\\n    def __init__(self):\\n        self.map = {\\'0\\': \\'1\\', \\'1\\': \\'0\\'}\\n\\n    def findKthBit(self, n: int, k: int) -> str:\\n        mid = 2**(n-1)\\n        if n == 1 or k == 1: return \\'0\\'\\n        if k == mid: return \\'1\\'\\n        if k < mid: return self.findKthBit(n - 1, k)\\n        else:\\n            sbit = self.findKthBit(n - 1, 2**n - k)\\n            return self.map[sbit]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def __init__(self):\\n        self.map = {\\'0\\': \\'1\\', \\'1\\': \\'0\\'}\\n\\n    def findKthBit(self, n: int, k: int) -> str:\\n        mid = 2**(n-1)\\n        if n == 1 or k == 1: return \\'0\\'\\n        if k == mid: return \\'1\\'\\n        if k < mid: return self.findKthBit(n - 1, k)\\n        else:\\n            sbit = self.findKthBit(n - 1, 2**n - k)\\n            return self.map[sbit]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781437,
                "title": "java",
                "content": "````\\npublic static char findKthBit(int n, int k) {\\n        String e = generateStrig(n, k);\\n        return e.charAt(k - 1);\\n    }\\n\\n    private static String generateStrig(int n, int k) {\\n        String s = \"0\";\\n        for (int i = 1; i < n; i++) {\\n            s = s + \"1\" + (invert(s));\\n        }\\n        return s;\\n    }\\n\\n\\n    private static String invert(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                sb.append(\"1\");\\n            } else {\\n                sb.append(\"0\");\\n            }\\n        }\\n        return sb.reverse().toString();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\npublic static char findKthBit(int n, int k) {\\n        String e = generateStrig(n, k);\\n        return e.charAt(k - 1);\\n    }\\n\\n    private static String generateStrig(int n, int k) {\\n        String s = \"0\";\\n        for (int i = 1; i < n; i++) {\\n            s = s + \"1\" + (invert(s));\\n        }\\n        return s;\\n    }\\n\\n\\n    private static String invert(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                sb.append(\"1\");\\n            } else {\\n                sb.append(\"0\");\\n            }\\n        }\\n        return sb.reverse().toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 781160,
                "title": "simple-python-solution-with-clean-and-understandable-code",
                "content": "```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        s = \"0\"\\n        def findInvert(s):\\n            newString = \"\"\\n            for i in range(len(s)):\\n                # print(\"Input\",s)\\n                if s[i] == \"0\":\\n                    newString += \"1\"\\n                    # print(\"Invert\",s)\\n                else:\\n                    newString += \"0\"\\n            return newString\\n        \\n        def findReverse(s):\\n            return s[::-1]\\n        \\n        for i in range(n):\\n            invert = findInvert(s)\\n            reverse = findReverse(invert)\\n            s = s + \"1\" + reverse\\n            # print(s)\\n        \\n        return s[k-1]\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        s = \"0\"\\n        def findInvert(s):\\n            newString = \"\"\\n            for i in range(len(s)):\\n                # print(\"Input\",s)\\n                if s[i] == \"0\":\\n                    newString += \"1\"\\n                    # print(\"Invert\",s)\\n                else:\\n                    newString += \"0\"\\n            return newString\\n        \\n        def findReverse(s):\\n            return s[::-1]\\n        \\n        for i in range(n):\\n            invert = findInvert(s)\\n            reverse = findReverse(invert)\\n            s = s + \"1\" + reverse\\n            # print(s)\\n        \\n        return s[k-1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 780962,
                "title": "python-solution-find-the-pattern-8-lines-and-super-easy",
                "content": "S1 = \\'0\\'\\nS2 = \\'0**1**1\\'\\nS3 = \\'011**1**001\\'\\nS4 = \\'0111001**1**0110001\\' => S3 + \\'1\\' + \\'011\\'+\\'0\\'+\\'001\\'\\nThe Sn =  Sn-1 + \\'1\\' + the half left part of Sn-1 + \\'0\\' + the right half part of Sn-1.\\n```\\nclass Solution(object):\\n    \\n    def findKthBit(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        if n == 1:\\n            return \"0\"\\n        s = \\'011\\'\\n        \\n        for i in range(2,n):\\n            mid = len(s)//2\\n            news = s + \\'1\\'+ s[:mid] + \\'0\\' + s[mid+1:]\\n            s = news\\n            #print(i,s)\\n        return s[k-1]\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    \\n    def findKthBit(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        if n == 1:\\n            return \"0\"\\n        s = \\'011\\'\\n        \\n        for i in range(2,n):\\n            mid = len(s)//2\\n            news = s + \\'1\\'+ s[:mid] + \\'0\\' + s[mid+1:]\\n            s = news\\n            #print(i,s)\\n        return s[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780946,
                "title": "java-o-n-time-o-n-space-recursive",
                "content": "Let f(n,k) be the kth bit of S_{n}. We then have that (assuming valid k): f(1, k) = 0. To compute f(n, k), we count the size of S_{n-1} and determine the whether the appropriate bit lies in S_{n-1}, \\'1\\', or reverse(inverse(S_{n-1})), which we can note is equivalent to inverse(reverse(S_{n-1})).\\n\\n```\\npublic char findKthBit(int n, int k) {\\n\\tif (n == 1) return \\'0\\';\\n\\tint leftHalfSize = ((1 << n) - 1)/2;\\n\\tif (k <= leftHalfSize) return findKthBit(n-1, k);\\n\\tif (k == leftHalfSize + 1) return \\'1\\';\\n\\treturn findKthBit(n-1, 2*leftHalfSize - k + 2) == \\'0\\' ? \\'1\\' : \\'0\\';\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic char findKthBit(int n, int k) {\\n\\tif (n == 1) return \\'0\\';\\n\\tint leftHalfSize = ((1 << n) - 1)/2;\\n\\tif (k <= leftHalfSize) return findKthBit(n-1, k);\\n\\tif (k == leftHalfSize + 1) return \\'1\\';\\n\\treturn findKthBit(n-1, 2*leftHalfSize - k + 2) == \\'0\\' ? \\'1\\' : \\'0\\';\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780909,
                "title": "java-c-python3-easy",
                "content": "```\\nJava:-\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        StringBuilder s = new StringBuilder(\"0\");\\n        int j = 1;\\n        while(j++ <= n){\\n            s.append(\"1\");\\n            int i = s.length() - 2;\\n            while(i >= 0){\\n                if(s.charAt(i) == \\'0\\')\\n                    s.append(\"1\");\\n                else\\n                    s.append(\"0\");\\n                i--;\\n            }\\n        }\\n        return s.charAt(k - 1);\\n    }\\n}\\n\\nC++:-\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        string s = \"0\";\\n        int j = 1;\\n        while(j++ <= n){\\n            s.append(\"1\");\\n            int i = s.length() - 2;\\n            while(i >= 0){\\n                if(s.at(i) == \\'0\\')\\n                    s.append(\"1\");\\n                else\\n                    s.append(\"0\");\\n                i--;\\n            }\\n        }\\n        return s.at(k - 1);\\n    }\\n};\\n\\n\\nPython3:-\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        s = \"0\"\\n        j = 1\\n        while j <= n:\\n            s += \"1\"\\n            i = len(s) - 2;\\n            while i >= 0:\\n                if s[i] == \\'0\\':\\n                    s += \"1\"\\n                else:\\n                    s += \"0\"\\n                i -= 1\\n            j += 1;\\n        return s[k - 1]\\n```",
                "solutionTags": [],
                "code": "```\\nJava:-\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        StringBuilder s = new StringBuilder(\"0\");\\n        int j = 1;\\n        while(j++ <= n){\\n            s.append(\"1\");\\n            int i = s.length() - 2;\\n            while(i >= 0){\\n                if(s.charAt(i) == \\'0\\')\\n                    s.append(\"1\");\\n                else\\n                    s.append(\"0\");\\n                i--;\\n            }\\n        }\\n        return s.charAt(k - 1);\\n    }\\n}\\n\\nC++:-\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        string s = \"0\";\\n        int j = 1;\\n        while(j++ <= n){\\n            s.append(\"1\");\\n            int i = s.length() - 2;\\n            while(i >= 0){\\n                if(s.at(i) == \\'0\\')\\n                    s.append(\"1\");\\n                else\\n                    s.append(\"0\");\\n                i--;\\n            }\\n        }\\n        return s.at(k - 1);\\n    }\\n};\\n\\n\\nPython3:-\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        s = \"0\"\\n        j = 1\\n        while j <= n:\\n            s += \"1\"\\n            i = len(s) - 2;\\n            while i >= 0:\\n                if s[i] == \\'0\\':\\n                    s += \"1\"\\n                else:\\n                    s += \"0\"\\n                i -= 1\\n            j += 1;\\n        return s[k - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857083,
                "title": "c-beats-100-optimised-solution-using-binary-search",
                "content": "# Intuition\\nThe problem requires finding the k-th bit of a binary string constructed following a specific pattern.\\n\\n# Approach\\nThe code follows a binary search approach to locate the k-th bit. It initializes two pointers, `low` and `high`, which represent the range of indices in the binary string. Then, it iteratively divides the range in half and checks if the k-th bit lies within the lower or upper half of the range. Based on this, it sets the character `ch` to \\'0\\' or \\'1\\', respectively. This process continues until the mid index matches the k-1 index.\\n\\n# Complexity\\n- Time complexity: O(log(2^n)) , ie, O(n) \\n- Space complexity: O(1) - The space used is constant.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    void toggle(char &ch) {\\n        if (ch == \\'1\\')\\n            ch = \\'0\\';\\n        else\\n            ch = \\'1\\';\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        int low = 0;\\n        int high = pow(2, n) - 2;\\n        char ch = \\'1\\';\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid == k - 1)\\n                break;\\n            else if (mid < k - 1) {\\n                ch = \\'0\\';\\n                low = mid + 1;\\n            } else {\\n                ch = \\'1\\';\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (low == high) {\\n            toggle(ch);\\n        }\\n        \\n        return ch;\\n    }\\n};\\n```\\n\\nIf you found it helpful, do upvote.",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void toggle(char &ch) {\\n        if (ch == \\'1\\')\\n            ch = \\'0\\';\\n        else\\n            ch = \\'1\\';\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        int low = 0;\\n        int high = pow(2, n) - 2;\\n        char ch = \\'1\\';\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (mid == k - 1)\\n                break;\\n            else if (mid < k - 1) {\\n                ch = \\'0\\';\\n                low = mid + 1;\\n            } else {\\n                ch = \\'1\\';\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        if (low == high) {\\n            toggle(ch);\\n        }\\n        \\n        return ch;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856793,
                "title": "c-detailed-bruteforce-solution-for-beginners",
                "content": "# Intuition\\nThe problem requires generating a sequence of strings and finding the kth character in the final string. The sequence generation involves two operations: reversal and inversion. We will build the sequence iteratively, starting with \"0\" and for each new string, append \"1\" and the reversed and inverted version of the previous string.\\n\\n# Approach\\n1. Create two helper functions: `reverse` and `invert`, to reverse and invert a string, respectively.\\n2. Initialize a vector of strings `ans` to store the generated sequence. Add the initial string \"0\" to `ans`.\\n3. Use a loop to generate the sequence. For each new string, concatenate \"1\" and the reversed and inverted version of the previous string, and add it to `ans`.\\n4. Return the kth character (0-based index) of the final string obtained from `ans[n-1]`.\\n\\n# Code\\n```cpp\\n#include <iostream>\\n#include <string>\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    // Helper function to reverse a string\\n    string reverse(string s) {\\n        string rev = \"\";\\n        for (int i = s.size() - 1; i >= 0; i--) {\\n            rev += s[i];\\n        }\\n        return rev;\\n    }\\n\\n    // Helper function to invert a string\\n    string invert(string s) {\\n        string inv = \"\";\\n        for (auto c : s) {\\n            if (c == \\'0\\') inv += \\'1\\';\\n            else inv += \\'0\\';\\n        }\\n        return inv;\\n    }\\n\\n    char findKthBit(int n, int k) {\\n        vector<string> ans;\\n        string s = \"0\";\\n        ans.push_back(s);\\n\\n        // Generate the sequence\\n        for (int i = 1; i < n; i++) {\\n            string s = ans[i - 1] + \"1\" + reverse(invert(ans[i - 1]));\\n            ans.push_back(s);\\n        }\\n\\n        // Return the kth character (0-based index) in the final string\\n        return ans[n - 1][k - 1];\\n    }\\n};\\n\\n```\\n If you find this solution helpful, don\\'t forget to upvote!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\n#include <iostream>\\n#include <string>\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    // Helper function to reverse a string\\n    string reverse(string s) {\\n        string rev = \"\";\\n        for (int i = s.size() - 1; i >= 0; i--) {\\n            rev += s[i];\\n        }\\n        return rev;\\n    }\\n\\n    // Helper function to invert a string\\n    string invert(string s) {\\n        string inv = \"\";\\n        for (auto c : s) {\\n            if (c == \\'0\\') inv += \\'1\\';\\n            else inv += \\'0\\';\\n        }\\n        return inv;\\n    }\\n\\n    char findKthBit(int n, int k) {\\n        vector<string> ans;\\n        string s = \"0\";\\n        ans.push_back(s);\\n\\n        // Generate the sequence\\n        for (int i = 1; i < n; i++) {\\n            string s = ans[i - 1] + \"1\" + reverse(invert(ans[i - 1]));\\n            ans.push_back(s);\\n        }\\n\\n        // Return the kth character (0-based index) in the final string\\n        return ans[n - 1][k - 1];\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3830676,
                "title": "easy-c-solution-simple-recursion-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string invert(string x){\\n        for(int i=0; i<x.size(); i++){\\n            if(x[i]==\\'0\\')   \\n                x[i] =\\'1\\';\\n            else\\n                x[i] =\\'0\\';\\n        }            \\n        return x;\\n    }\\n\\n    string helper(int n){\\n        if(n==1)\\n            return \"0\";\\n        string s = helper(n-1);\\n        \\n        string rev = invert(s);\\n        reverse(rev.begin(), rev.end());\\n        \\n        return s + \"1\" + rev;\\n    }\\n\\n    char findKthBit(int n, int k){\\n        string ans = helper(n);\\n        return ans[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string invert(string x){\\n        for(int i=0; i<x.size(); i++){\\n            if(x[i]==\\'0\\')   \\n                x[i] =\\'1\\';\\n            else\\n                x[i] =\\'0\\';\\n        }            \\n        return x;\\n    }\\n\\n    string helper(int n){\\n        if(n==1)\\n            return \"0\";\\n        string s = helper(n-1);\\n        \\n        string rev = invert(s);\\n        reverse(rev.begin(), rev.end());\\n        \\n        return s + \"1\" + rev;\\n    }\\n\\n    char findKthBit(int n, int k){\\n        string ans = helper(n);\\n        return ans[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733201,
                "title": "c-recursion-normal-solution-optimized-solution-explaination",
                "content": "# optimized(beats 100%)(tougher ans)\\nwe can observe a pattern of string length\\n1\\n3\\n7\\n15\\n31\\nthis is 2^n -1 ;\\n\\nthe mid point will be at (length of string n-1) +1.\\nhere we check k with 2^n-1 because 2^n-1=2^(n-1)-1 +1; \\nif it is same as mid then return 1;\\nif less just return n-1;\\nif greater return opposite of n-1 we should also change k to be the element of distance k from the end\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int solve(int n,int k)\\n    {\\n        if(n==1)return 0;\\n        int mid=1<<(n-1);\\n        if(k==mid)return 1;\\n        if(k<mid)return solve(n-1,k);        \\n        return !solve(n-1,2*mid-k);\\n    }\\n\\npublic:\\n    char findKthBit(int n, int k) \\n    {\\n        return solve(n,k)+\\'0\\';\\n    }\\n};\\n```\\n\\n# normal solution basic\\nwe build the string then return ans\\n\\n# Code\\n```\\nclass Solution {\\n\\n    string create(int i)\\n    {\\n        if(i==1)return \"0\";\\n        string s=create(i-1);\\n        string end;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'0\\')end.push_back(\\'1\\');\\n            else end.push_back(\\'0\\');\\n        }    \\n        return s+\"1\"+end;\\n\\n    }\\n\\npublic:\\n    char findKthBit(int n, int k) \\n    {\\n        string s=create(n); \\n        return s[k-1];\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    int solve(int n,int k)\\n    {\\n        if(n==1)return 0;\\n        int mid=1<<(n-1);\\n        if(k==mid)return 1;\\n        if(k<mid)return solve(n-1,k);        \\n        return !solve(n-1,2*mid-k);\\n    }\\n\\npublic:\\n    char findKthBit(int n, int k) \\n    {\\n        return solve(n,k)+\\'0\\';\\n    }\\n};\\n```\n```\\nclass Solution {\\n\\n    string create(int i)\\n    {\\n        if(i==1)return \"0\";\\n        string s=create(i-1);\\n        string end;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'0\\')end.push_back(\\'1\\');\\n            else end.push_back(\\'0\\');\\n        }    \\n        return s+\"1\"+end;\\n\\n    }\\n\\npublic:\\n    char findKthBit(int n, int k) \\n    {\\n        string s=create(n); \\n        return s[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665545,
                "title": "easy-recursive-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  char findKthBit(int n, int k) {\\n        int temp = findChar(n,k);\\n        return (temp+\\'0\\');\\n    }\\n\\t\\nint findChar(int n,int k)\\n    {\\n        if(n==1 || k==1)\\n            return 0;\\n        int size = (pow(2,n))-1;\\n        int mid = (size)/2;\\n        if(mid+1 == k)\\n            return 1;\\n        if(k<=mid)\\n            return findChar(n-1,k);\\n        else\\n            return !findChar(n-1,(size-k+1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  char findKthBit(int n, int k) {\\n        int temp = findChar(n,k);\\n        return (temp+\\'0\\');\\n    }\\n\\t\\nint findChar(int n,int k)\\n    {\\n        if(n==1 || k==1)\\n            return 0;\\n        int size = (pow(2,n))-1;\\n        int mid = (size)/2;\\n        if(mid+1 == k)\\n            return 1;\\n        if(k<=mid)\\n            return findChar(n-1,k);\\n        else\\n            return !findChar(n-1,(size-k+1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635869,
                "title": "easy-o-n-python-solution-beats-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        length = 2**n-1\\n        invert = 0\\n        while length !=1:\\n            mid = (length+1)//2\\n            if k <mid:\\n                pass\\n            elif k>mid:\\n                invert= abs(1-invert)\\n                k = 2*mid-k\\n            else:\\n                return \\'1\\' if invert==0 else \\'0\\'\\n            length = mid-1\\n        return \\'0\\' if invert == 0 else \\'1\\'\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        length = 2**n-1\\n        invert = 0\\n        while length !=1:\\n            mid = (length+1)//2\\n            if k <mid:\\n                pass\\n            elif k>mid:\\n                invert= abs(1-invert)\\n                k = 2*mid-k\\n            else:\\n                return \\'1\\' if invert==0 else \\'0\\'\\n            length = mid-1\\n        return \\'0\\' if invert == 0 else \\'1\\'\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592799,
                "title": "very-easy-to-understand-no-use-of-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        String st = \"0\";\\n        for(int i=0 ; i<n-1 ; i++){\\n            String temp = st;\\n            temp = temp.replace(\"1\", \"*\");\\n            temp = temp.replace(\"0\" , \"1\");\\n            temp = temp.replace(\"*\" , \"0\");\\n\\n            StringBuilder sb = new StringBuilder(temp);\\n            st = st + \"1\" + sb.reverse().toString(); \\n        }\\n        return st.charAt(k-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        String st = \"0\";\\n        for(int i=0 ; i<n-1 ; i++){\\n            String temp = st;\\n            temp = temp.replace(\"1\", \"*\");\\n            temp = temp.replace(\"0\" , \"1\");\\n            temp = temp.replace(\"*\" , \"0\");\\n\\n            StringBuilder sb = new StringBuilder(temp);\\n            st = st + \"1\" + sb.reverse().toString(); \\n        }\\n        return st.charAt(k-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449936,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nchar findKthBit(int n, int k){\\n    int count=0;\\n    while(k != 1){\\n        if((k & k-1 ) == 0){\\n            count++;\\n            break;\\n        }\\n        int i=1;\\n        while(i<k){\\n            i = i<<1;\\n        }\\n        k = i-k;\\n        count++;\\n    }\\n    if(count & 1){\\n        return \\'1\\';\\n    }\\n    else{\\n        return \\'0\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar findKthBit(int n, int k){\\n    int count=0;\\n    while(k != 1){\\n        if((k & k-1 ) == 0){\\n            count++;\\n            break;\\n        }\\n        int i=1;\\n        while(i<k){\\n            i = i<<1;\\n        }\\n        k = i-k;\\n        count++;\\n    }\\n    if(count & 1){\\n        return \\'1\\';\\n    }\\n    else{\\n        return \\'0\\';\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3204689,
                "title": "easy-to-understand-map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        \\n        unordered_map<int,string>mp;\\n        mp[1]=\"0\";\\n        for(int i=2;i<=n;i++)\\n        {\\n            \\n            int j=mp[i-1].length()-1;\\n            string s1=\"\";\\n            while(j>=0){\\n            if(mp[i-1][j--]==\\'0\\')\\n            s1+=\\'1\\';\\n            else s1+=\\'0\\';\\n            }\\n            \\n            mp[i]+=mp[i-1]+\"1\"+s1;\\n        }\\n        \\n        string ans=mp[n];\\n        return ans[k-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        \\n        unordered_map<int,string>mp;\\n        mp[1]=\"0\";\\n        for(int i=2;i<=n;i++)\\n        {\\n            \\n            int j=mp[i-1].length()-1;\\n            string s1=\"\";\\n            while(j>=0){\\n            if(mp[i-1][j--]==\\'0\\')\\n            s1+=\\'1\\';\\n            else s1+=\\'0\\';\\n            }\\n            \\n            mp[i]+=mp[i-1]+\"1\"+s1;\\n        }\\n        \\n        string ans=mp[n];\\n        return ans[k-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835948,
                "title": "python3-solution-clean-concise-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n\\n### Recursive Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K, R = True):\\n        if K == 1: return \\'0\\' if R else \\'1\\'\\n        mid = (1 << (N - 1))\\n        if K < mid: return self.findKthBit(N - 1, K, R)\\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\\n        return \\'1\\' if R else \\'0\\'\\n```\\n\\n### Iterative Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K):\\n        ans = 1\\n        mid = (1 << (N - 1))\\n        while K > 1:\\n            if K == mid: return str(ans)\\n            if K > mid: \\n                K = 2 * mid - K\\n                ans ^= 1\\n            mid >>= 1\\n        return str(ans^1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findKthBit(self, N, K, R = True):\\n        if K == 1: return \\'0\\' if R else \\'1\\'\\n        mid = (1 << (N - 1))\\n        if K < mid: return self.findKthBit(N - 1, K, R)\\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\\n        return \\'1\\' if R else \\'0\\'\\n```\n```\\nclass Solution:\\n    def findKthBit(self, N, K):\\n        ans = 1\\n        mid = (1 << (N - 1))\\n        while K > 1:\\n            if K == mid: return str(ans)\\n            if K > mid: \\n                K = 2 * mid - K\\n                ans ^= 1\\n            mid >>= 1\\n        return str(ans^1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802580,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        char findKthBit(int n, int k) {\\n        int flip = 0, l = (1 << n) - 1;\\n        while (k > 1) {\\n            if (k == l / 2 + 1)\\n                return \\'0\\' + (flip ^ 1);\\n            if (k > l / 2) {\\n                k = l + 1 - k;\\n                flip ^= 1;\\n            }\\n            l /= 2;\\n        }\\n        return \\'0\\' + flip;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        char findKthBit(int n, int k) {\\n        int flip = 0, l = (1 << n) - 1;\\n        while (k > 1) {\\n            if (k == l / 2 + 1)\\n                return \\'0\\' + (flip ^ 1);\\n            if (k > l / 2) {\\n                k = l + 1 - k;\\n                flip ^= 1;\\n            }\\n            l /= 2;\\n        }\\n        return \\'0\\' + flip;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600734,
                "title": "c-language-solution-0ms",
                "content": "```\\nchar findKthBit(int n, int k) {\\n  int mid = pow(2, n - 1);\\n\\n  if (n == 1 || k == 1) return \\'0\\';\\n  if (k == mid) return \\'1\\';\\n  if (k < mid) return findKthBit(n - 1, k);\\n  return findKthBit(n - 1, mid * 2 - k) == \\'0\\' ? \\'1\\' : \\'0\\';\\n}",
                "solutionTags": [],
                "code": "```\\nchar findKthBit(int n, int k) {\\n  int mid = pow(2, n - 1);\\n\\n  if (n == 1 || k == 1) return \\'0\\';\\n  if (k == mid) return \\'1\\';\\n  if (k < mid) return findKthBit(n - 1, k);\\n  return findKthBit(n - 1, mid * 2 - k) == \\'0\\' ? \\'1\\' : \\'0\\';\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2470690,
                "title": "python-easy-solution",
                "content": "***Upvote if you like the solution!!!!!!***\\n```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        s=\\'0\\'\\n        size=1\\n        while size<k:\\n            s+=\"1\"+\\'\\'.join([\"1\" if ch==\"0\" else \"0\" for ch in s][::-1])\\n            size=(size<<1)+1\\n        return s[k-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        s=\\'0\\'\\n        size=1\\n        while size<k:\\n            s+=\"1\"+\\'\\'.join([\"1\" if ch==\"0\" else \"0\" for ch in s][::-1])\\n            size=(size<<1)+1\\n        return s[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457573,
                "title": "python-solution-dynamic-approach-storing-nth-string-in-a-hashmap-simple-to-understand",
                "content": "```\\nclass Solution(object):\\n    def findKthBit(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        def invert(s):\\n            res = \"\"\\n            for i in s:\\n                if i==\"0\":\\n                    res += \"1\"\\n                elif i==\"1\":\\n                    res += \"0\"\\n            return res\\n        def reverse(s):\\n            s = s[::-1]\\n            return s\\n        \\n        dict = {1:\"0\"}\\n        for i in range(2,n+1):\\n            dict[i] = dict[i-1]+\"1\"+reverse(invert(dict[i-1]))\\n\\n        s = dict[n]\\n        return s[k-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findKthBit(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        def invert(s):\\n            res = \"\"\\n            for i in s:\\n                if i==\"0\":\\n                    res += \"1\"\\n                elif i==\"1\":\\n                    res += \"0\"\\n            return res\\n        def reverse(s):\\n            s = s[::-1]\\n            return s\\n        \\n        dict = {1:\"0\"}\\n        for i in range(2,n+1):\\n            dict[i] = dict[i-1]+\"1\"+reverse(invert(dict[i-1]))\\n\\n        s = dict[n]\\n        return s[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397487,
                "title": "reacursion-easy-solution",
                "content": "https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/discuss/780984/Java-Recursive-Solution/649132\\n\\n-simple use of binary search if you able to find pettern \\n\\n    public char findKthBit(int n, int k) {\\n        if(n == 1 ) return \\'0\\';\\n        \\n        int l = (int) Math.pow(2,n) -1;\\n        int mid = l/2 +1;\\n        if(k == mid) return \\'1\\';\\n        else if (k < mid ) return findKthBit(n-1, k);\\n                else return findKthBit(n-1, l+1-k) == \\'0\\' ? \\'1\\' : \\'0\\';\\n        \\n    }",
                "solutionTags": [
                    "Java",
                    "C",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/discuss/780984/Java-Recursive-Solution/649132\\n\\n-simple use of binary search if you able to find pettern \\n\\n    public char findKthBit(int n, int k) {\\n        if(n == 1 ) return \\'0\\';\\n        \\n        int l = (int) Math.pow(2,n) -1;\\n        int mid = l/2 +1;\\n        if(k == mid) return \\'1\\';\\n        else if (k < mid ) return findKthBit(n-1, k);\\n                else return findKthBit(n-1, l+1-k) == \\'0\\' ? \\'1\\' : \\'0\\';\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2286164,
                "title": "very-easy-approach",
                "content": "```\\nconst revers= function(s){\\n    return s.split(``).reverse().join(``); //reverse the binary string\\n}\\n\\nconst invert=function(s){\\n    let is=``;\\n    for(let i=0;i<s.length;i++){\\n        is=is+(s[i]==`0`?`1`:`0`);  // inverting\\n    }\\n    return is;\\n}\\nvar findKthBit = function(n, k) {\\n    \\n    function solve(n){\\n        if(n==1){\\n            return `0`;\\n        }\\n        \\n        else{\\n            let t= solve(n-1);\\n            return (t+`1`+revers(invert(t)));  //backtracking to build solution\\n        }\\n    }\\n    \\n    return (solve(n)[k-1]);\\n};\\n\\n```\\n\\n***Do upvote if it helped! :)***",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nconst revers= function(s){\\n    return s.split(``).reverse().join(``); //reverse the binary string\\n}\\n\\nconst invert=function(s){\\n    let is=``;\\n    for(let i=0;i<s.length;i++){\\n        is=is+(s[i]==`0`?`1`:`0`);  // inverting\\n    }\\n    return is;\\n}\\nvar findKthBit = function(n, k) {\\n    \\n    function solve(n){\\n        if(n==1){\\n            return `0`;\\n        }\\n        \\n        else{\\n            let t= solve(n-1);\\n            return (t+`1`+revers(invert(t)));  //backtracking to build solution\\n        }\\n    }\\n    \\n    return (solve(n)[k-1]);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2273517,
                "title": "c-simple-recursive-solution-o-n-time-complexity",
                "content": "**My Solution:**\\n`T(n) = T(n-1) + 1 => TC = O(n)`\\n`Stack Space = O(n) (bcoz depth of tree is n)`\\n```\\nchar findKthBit(int n, int k) {\\n\\tif(n == 1)\\n\\t\\treturn \\'0\\';\\n\\tif(k == pow(2, n - 1))\\n\\t\\treturn \\'1\\';\\n\\tif(k < pow(2, n - 1))\\n\\t\\treturn findKthBit(n - 1, k);\\n\\tchar ch = findKthBit(n - 1, pow(2, n) - k);\\n\\tif(ch == \\'0\\') return \\'1\\';\\n\\treturn \\'0\\';\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/2e340bfb-66a9-4040-b560-2208d6af1ac3_1657648812.773466.jpeg)\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nchar findKthBit(int n, int k) {\\n\\tif(n == 1)\\n\\t\\treturn \\'0\\';\\n\\tif(k == pow(2, n - 1))\\n\\t\\treturn \\'1\\';\\n\\tif(k < pow(2, n - 1))\\n\\t\\treturn findKthBit(n - 1, k);\\n\\tchar ch = findKthBit(n - 1, pow(2, n) - k);\\n\\tif(ch == \\'0\\') return \\'1\\';\\n\\treturn \\'0\\';\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230651,
                "title": "py3-recursive-iterative-solution-do-not-click",
                "content": "CODE:\\n\\n```\\n\\t#Recursive\\n        def helper(nums,c):\\n            if c==n: return nums[k-1]\\n            nums=nums+\\'1\\'+\\'\\'.join([\\'1\\' if i==\\'0\\' else \\'0\\' for i in nums])[::-1]\\n            return helper(nums,c+1)\\n               \\n        return helper(\\'0\\',1)\\n    \\n    #Iterative\\n        res=[\\'0\\' for i in range(n+1)]\\n        for i in range(2,len(res)): res[i]=res[i-1]+\\'1\\'+\\'\\'.join([\\'1\\' if i==\\'0\\' else \\'0\\' for i in res[i-1]])[::-1]\\n        return res[-1][k-1]\\n```",
                "solutionTags": [],
                "code": "```\\n\\t#Recursive\\n        def helper(nums,c):\\n            if c==n: return nums[k-1]\\n            nums=nums+\\'1\\'+\\'\\'.join([\\'1\\' if i==\\'0\\' else \\'0\\' for i in nums])[::-1]\\n            return helper(nums,c+1)\\n               \\n        return helper(\\'0\\',1)\\n    \\n    #Iterative\\n        res=[\\'0\\' for i in range(n+1)]\\n        for i in range(2,len(res)): res[i]=res[i-1]+\\'1\\'+\\'\\'.join([\\'1\\' if i==\\'0\\' else \\'0\\' for i in res[i-1]])[::-1]\\n        return res[-1][k-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2186575,
                "title": "c-3-solutions-recursion-easy-understanding",
                "content": "Solution 1:\\n```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        pair<string,string>p={\"0\",\"1\"};\\n        int x=1;\\n        while(x<n){\\n            string s1=p.first,s2=p.second;\\n            p.first=s1+\"1\"+s2;\\n            p.second=s1+\"0\"+s2;\\n            x++;\\n        }\\n        return p.first[k-1];\\n    }\\n};\\n```\\nSolution 2:\\n```\\nclass Solution {\\npublic:\\n    void find(pair<string,string>&p,int n){\\n        if(n==1)\\n            return;\\n         string s1=p.first,s2=p.second;\\n            p.first=s1+\"1\"+s2;\\n            p.second=s1+\"0\"+s2;\\n        find(p,n-1);\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        pair<string,string>p={\"0\",\"1\"};\\n        find(p,n);\\n        return p.first[k-1];\\n    }\\n};\\n```\\nSolution 3:\\n```\\nclass Solution {\\npublic:\\n    int find(int n,int k){\\n        if(n==1 || k==1)\\n            return 0;\\n        int l=pow(2,n)-1;\\n        if(k==(l/2)+1)\\n            return 1;\\n        else if(k<=(l/2))\\n            return find(n-1,k);\\n        else\\n            return !find(n-1,l-k+1);\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        if(find(n,k))\\n            return \\'1\\';\\n        else\\n            return \\'0\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        pair<string,string>p={\"0\",\"1\"};\\n        int x=1;\\n        while(x<n){\\n            string s1=p.first,s2=p.second;\\n            p.first=s1+\"1\"+s2;\\n            p.second=s1+\"0\"+s2;\\n            x++;\\n        }\\n        return p.first[k-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void find(pair<string,string>&p,int n){\\n        if(n==1)\\n            return;\\n         string s1=p.first,s2=p.second;\\n            p.first=s1+\"1\"+s2;\\n            p.second=s1+\"0\"+s2;\\n        find(p,n-1);\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        pair<string,string>p={\"0\",\"1\"};\\n        find(p,n);\\n        return p.first[k-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int find(int n,int k){\\n        if(n==1 || k==1)\\n            return 0;\\n        int l=pow(2,n)-1;\\n        if(k==(l/2)+1)\\n            return 1;\\n        else if(k<=(l/2))\\n            return find(n-1,k);\\n        else\\n            return !find(n-1,l-k+1);\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        if(find(n,k))\\n            return \\'1\\';\\n        else\\n            return \\'0\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127277,
                "title": "cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    string revinv(string s)\\n    {\\n        reverse(s.begin(),s.end());\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'0\\')s[i]=\\'1\\';\\n            else\\n                s[i]=\\'0\\';\\n            \\n        }\\n        return s;\\n    }\\n    \\n    char findKthBit(int n, int k) \\n    {\\n        string arr[n];\\n        arr[0]=\"0\";\\n        for(int i=1;i<n;i++)\\n        {\\n            arr[i]=arr[i-1]+\"1\"+revinv(arr[i-1]);\\n        }\\n        return arr[n-1][k-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string revinv(string s)\\n    {\\n        reverse(s.begin(),s.end());\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'0\\')s[i]=\\'1\\';\\n            else\\n                s[i]=\\'0\\';\\n            \\n        }\\n        return s;\\n    }\\n    \\n    char findKthBit(int n, int k) \\n    {\\n        string arr[n];\\n        arr[0]=\"0\";\\n        for(int i=1;i<n;i++)\\n        {\\n            arr[i]=arr[i-1]+\"1\"+revinv(arr[i-1]);\\n        }\\n        return arr[n-1][k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091929,
                "title": "python-4-lines-simple-solution",
                "content": "```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        i, s, hash_map = 1, \\'0\\', {\\'1\\': \\'0\\', \\'0\\': \\'1\\'}\\n        for i in range(1, n):\\n            s = s + \\'1\\' + \\'\\'.join((hash_map[i] for i in s))[::-1]\\n        return s[k-1]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        i, s, hash_map = 1, \\'0\\', {\\'1\\': \\'0\\', \\'0\\': \\'1\\'}",
                "codeTag": "Java"
            },
            {
                "id": 2050212,
                "title": "python-recursion",
                "content": "```\\nclass Solution(object):\\n    def findKthBit(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        ans=[]\\n        \\n        \\n        def invert(st):\\n            ans=\\'\\'\\n            for x in st:\\n                if x==\\'0\\':\\n                    ans+=\\'1\\'\\n                else:\\n                    ans+=\\'0\\'\\n            return ans[::-1]\\n        \\n        \\n        def Recur(s,ans):\\n            if len(ans)==n:\\n                return  ans\\n            new=s+\\'1\\'+ invert(s)\\n            ans.append(new)\\n            Recur(new,ans)\\n            return ans[n-1][k-1]\\n            \\n        return Recur(\\'0\\',[])\\n        \\n            \\n        ```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def findKthBit(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        ans=[]\\n        \\n        \\n        def invert(st):\\n            ans=\\'\\'\\n            for x in st:\\n                if x==\\'0\\':\\n                    ans+=\\'1\\'\\n                else:\\n                    ans+=\\'0\\'\\n            return ans[::-1]\\n        \\n        \\n        def Recur(s,ans):\\n            if len(ans)==n:\\n                return  ans\\n            new=s+\\'1\\'+ invert(s)\\n            ans.append(new)\\n            Recur(new,ans)\\n            return ans[n-1][k-1]\\n            \\n        return Recur(\\'0\\',[])\\n        \\n            \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 1972317,
                "title": "java-recursion-easy-60-faster",
                "content": "## **Please Upvote if you understood this** (\\uFF5E\\uFFE3\\u25BD\\uFFE3)\\uFF5E\\n```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        return make(n,k,new StringBuilder(\"0\"),1);\\n    }\\n    public char make(int n, int k, StringBuilder str, int l){\\n        \\n        if(l/2>k) return str.charAt(k-1); // if character index is lesser than half of the length of current string \\n        if(l>=k) return str.charAt(k-1); // if character index is lesser than the length of currnt string\\n        if(n==0) return str.charAt(k-1); // finally if the our n becomes 0\\n        \\n        String add = invertAndReverse(str);\\n        str.append(\\'1\\').append(add); // appending 1 and invert and reverse string\\n        return make(n-1, k, str, (l*2)+1); // here l * 2 is the lenght of string and we adding 1 because we appending 1 also\\n    }\\n    public String invertAndReverse(StringBuilder str){\\n        StringBuilder strs = new StringBuilder();\\n        int len = str.length();\\n        for(int i=len-1;i>=0;i--){\\n            strs.append(str.charAt(i) ==\\'1\\'? \\'0\\' : \\'1\\');\\n        }\\n        return strs.toString();\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        return make(n,k,new StringBuilder(\"0\"),1);\\n    }\\n    public char make(int n, int k, StringBuilder str, int l){\\n        \\n        if(l/2>k) return str.charAt(k-1); // if character index is lesser than half of the length of current string \\n        if(l>=k) return str.charAt(k-1); // if character index is lesser than the length of currnt string\\n        if(n==0) return str.charAt(k-1); // finally if the our n becomes 0\\n        \\n        String add = invertAndReverse(str);\\n        str.append(\\'1\\').append(add); // appending 1 and invert and reverse string\\n        return make(n-1, k, str, (l*2)+1); // here l * 2 is the lenght of string and we adding 1 because we appending 1 also\\n    }\\n    public String invertAndReverse(StringBuilder str){\\n        StringBuilder strs = new StringBuilder();\\n        int len = str.length();\\n        for(int i=len-1;i>=0;i--){\\n            strs.append(str.charAt(i) ==\\'1\\'? \\'0\\' : \\'1\\');\\n        }\\n        return strs.toString();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911984,
                "title": "c-solution-100-faster-easy-to-understand",
                "content": "```\\n//This question is almost similar to the kth symbol in the grammar with slight changes...\\n//Here 3 cases arise for K\\n1. If k<mid\\n2. If k==mid\\n3. If k>mid\\nint help(int n,int k)\\n    {\\n        if(n==1)\\n            return 0;\\n        else\\n        {\\n            int l=pow(2,n)-1;\\n            l=l+1;// the length is always odd and it is mentioned that we need to add 1 before reversing it....\\n            if(k<(l/2))// if k is less than mid...\\n                return help(n-1,k);\\n            else if(k==l/2)// if it is the mid directly return 1.....\\n                return 1;\\n            else// if k>mid\\n                return !help(n-1,l-k);\\n        }\\n    }\\n    char findKthBit(int n, int k) {\\n        int x=help(n,k);\\n        if(x==1)\\n            return \\'1\\';\\n        else\\n            return \\'0\\';\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//This question is almost similar to the kth symbol in the grammar with slight changes...\\n//Here 3 cases arise for K\\n1. If k<mid\\n2. If k==mid\\n3. If k>mid\\nint help(int n,int k)\\n    {\\n        if(n==1)\\n            return 0;\\n        else\\n        {\\n            int l=pow(2,n)-1;\\n            l=l+1;// the length is always odd and it is mentioned that we need to add 1 before reversing it....\\n            if(k<(l/2))// if k is less than mid...\\n                return help(n-1,k);\\n            else if(k==l/2)// if it is the mid directly return 1.....\\n                return 1;\\n            else// if k>mid\\n                return !help(n-1,l-k);\\n        }\\n    }\\n    char findKthBit(int n, int k) {\\n        int x=help(n,k);\\n        if(x==1)\\n            return \\'1\\';\\n        else\\n            return \\'0\\';\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1881440,
                "title": "very-simple-understandable-solution-in-java",
                "content": "class Solution {\\n\\n    public StringBuilder invertAndReverse(String s){\\n    \\n        //inverting the bits of the given string using XOR with 1;\\n        char[] chars = new char[s.length()];\\n        \\n        for(int i=0;i<s.length();i++){\\n            chars[i] = (char)(s.charAt(i)^1);\\n        }\\n        String flipped = new String(chars);\\n        \\n        StringBuilder str = new StringBuilder(flipped); \\n      \\n        return str.reverse();\\n    }\\n    \\n    public char findKthBit(int n, int k) {\\n        \\n       String arr[] = new String[21];//See the given contraints;\\n        \\n        StringBuilder str = new StringBuilder();\\n        arr[1] = \"0\";\\n        \\n        for(int i=2;i<=20;i++){\\n        \\n           arr[i] = arr[i-1]+\"1\" + invertAndReverse(arr[i-1]);\\n            \\n       }\\n        \\n        String s = arr[n]; // Getting the desired string with the value of n in the formed array;;\\n       \\n        return s.charAt(k-1);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\n    public StringBuilder invertAndReverse(String s){\\n    \\n        //inverting the bits of the given string using XOR with 1;\\n        char[] chars = new char[s.length()];\\n        \\n        for(int i=0;i<s.length();i++){\\n            chars[i] = (char)(s.charAt(i)^1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1801801,
                "title": "python-easy-understanding-solution",
                "content": "```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        s1 = \\'0\\'\\n        for i in range(1, n+1):\\n            a = self.invert_reverse(s1)\\n            s1 = (s1 + \\'1\\' + a)\\n            a = s1\\n        return s1[k-1]\\n\\n    def invert_reverse(self, s):\\n        ans = \\'\\'\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                ans += \\'1\\'\\n            elif s[i] == \\'1\\':\\n                ans += \\'0\\'\\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        s1 = \\'0\\'\\n        for i in range(1, n+1):\\n            a = self.invert_reverse(s1)\\n            s1 = (s1 + \\'1\\' + a)\\n            a = s1\\n        return s1[k-1]\\n\\n    def invert_reverse(self, s):\\n        ans = \\'\\'\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                ans += \\'1\\'\\n            elif s[i] == \\'1\\':\\n                ans += \\'0\\'\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759728,
                "title": "python-very-simple-recursive-solution",
                "content": "```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        \\n        invert = {\"0\":\"1\", \"1\":\"0\"}\\n        \\n        def helper(n, k): # 0 <= k <= n-1\\n            mid = 2**(n-1) -1 \\n            if n == 0:\\n                return \"0\"\\n            elif n == 1:\\n                return \"011\"[k]\\n            elif k == mid:\\n                return \"1\"\\n            elif k < mid:\\n                return helper(n-1, k)\\n            else: # k> mid\\n                return invert[helper(n, 2*mid-k)]\\n    \\n        return helper(n, k-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        \\n        invert = {\"0\":\"1\", \"1\":\"0\"}\\n        \\n        def helper(n, k): # 0 <= k <= n-1\\n            mid = 2**(n-1) -1 \\n            if n == 0:\\n                return \"0\"\\n            elif n == 1:\\n                return \"011\"[k]\\n            elif k == mid:\\n                return \"1\"\\n            elif k < mid:\\n                return helper(n-1, k)\\n            else: # k> mid\\n                return invert[helper(n, 2*mid-k)]\\n    \\n        return helper(n, k-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673068,
                "title": "java-recursion-simple-slow",
                "content": "```\\nclass Solution { \\n    public char findKthBit(int n, int k) { \\n        if(k==1)\\n            return \\'0\\'; \\n        return helper(n,\"0\").charAt(k-1); \\n    }\\n    String helper(int n,String s){\\n        if(n==0){ \\n            return s;\\n        }\\n        s=s+\"1\" + invertHeper(s);\\n        return helper(n-1,s) ;\\n    }\\n    String invertHeper(String s){\\n        StringBuilder sb = new StringBuilder();\\n        for(char ch:s.toCharArray()){\\n            if(ch==\\'0\\')\\n                sb.append(\\'1\\');\\n            else sb.append(\\'0\\');\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { \\n    public char findKthBit(int n, int k) { \\n        if(k==1)\\n            return \\'0\\'; \\n        return helper(n,\"0\").charAt(k-1); \\n    }\\n    String helper(int n,String s){\\n        if(n==0){ \\n            return s;\\n        }\\n        s=s+\"1\" + invertHeper(s);\\n        return helper(n-1,s) ;\\n    }\\n    String invertHeper(String s){\\n        StringBuilder sb = new StringBuilder();\\n        for(char ch:s.toCharArray()){\\n            if(ch==\\'0\\')\\n                sb.append(\\'1\\');\\n            else sb.append(\\'0\\');\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1574052,
                "title": "easy-c-recursive-solution",
                "content": "class Solution {\\npublic:\\n\\n    //rev function\\n     string rev(string str){\\n         reverse(str.begin(),str.end());\\n         return str;\\n     }\\n\\t \\n    //invert function\\n    string invert(string str){\\n        for(int i=0;i<str.size();i++){\\n            if(str[i]==\\'1\\'){\\n                str[i]=\\'0\\';\\n            }\\n            else{\\n                str[i]=\\'1\\';\\n            }\\n        }\\n        return str;\\n    }\\n\\t\\n    //recursive function\\n    string s(int n){\\n        if(n==1){\\n            return \"0\";\\n        }\\n        else{\\n            string str = s(n-1);\\n            string inv = invert(str);\\n            return(str+\"1\"+ rev(inv));\\n        }\\n    }\\n\\t\\n    //given function\\n    char findKthBit(int n, int k) {\\n      return (s(n)[k-1]);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    //rev function\\n     string rev(string str){\\n         reverse(str.begin(),str.end());\\n         return str;\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 1563527,
                "title": "c-solution",
                "content": "```\\nchar findKthBit(int n, int k) {\\n        if(n == 1 && k == 1)\\n            return \\'0\\';\\n        int length = pow(2, n);\\n        int mid = length/2;\\n        if(k < mid) {\\n            return findKthBit(n-1, k);\\n        }\\n        else if(k > mid) {\\n            char c = findKthBit(n-1, length-k);\\n            return c == \\'0\\'  ? \\'1\\' : \\'0\\';\\n        }\\n        else {\\n            return \\'1\\';\\n        }\\n    }",
                "solutionTags": [],
                "code": "```\\nchar findKthBit(int n, int k) {\\n        if(n == 1 && k == 1)\\n            return \\'0\\';\\n        int length = pow(2, n);\\n        int mid = length/2;\\n        if(k < mid) {\\n            return findKthBit(n-1, k);\\n        }\\n        else if(k > mid) {\\n            char c = findKthBit(n-1, length-k);\\n            return c == \\'0\\'  ? \\'1\\' : \\'0\\';\\n        }\\n        else {\\n            return \\'1\\';\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1532890,
                "title": "c-simulation-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    string invert(string s){\\n        for(int i=0; i<s.size(); i++){\\n              if(s[i]==\\'0\\') s[i]=\\'1\\';\\n            else s[i]=\\'0\\';\\n        }\\n        return s;\\n    }\\n    char findKthBit(int n, int k) {\\n        string s=\"0\";\\n        for(int i=1; i<n;i++){\\n            string temp=s;\\n            temp=invert(temp);\\n             reverse(temp.begin(),temp.end());\\n            s=s+\"1\"+temp;\\n        }\\n        \\n        char ch=s[k-1];\\n           return ch;\\n       }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string invert(string s){\\n        for(int i=0; i<s.size(); i++){\\n              if(s[i]==\\'0\\') s[i]=\\'1\\';\\n            else s[i]=\\'0\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1484360,
                "title": "c-soln-recursion-observations-code",
                "content": "//Please Upvote the sol. on liking the solution.\\n\\n//Observation : 1) The String at nth row is 2^n+1 in length.\\n// 2) The mid element is always 1.\\n// 3) The Second Half of the string is exactly same as the first half but with one difference i.e. the mid element of the second half is inverted. \\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int n,int k){\\n        if(n==1&&k==1)\\n            return 0;\\n        int mid=pow(2,n)/2;\\n        if(k<mid)\\n            return solve(n-1,k);\\n        else if(k==mid)\\n            return 1;\\n        else \\n        {\\n            if(k==(mid+mid/2))\\n                return !solve(n-1,k-mid);\\n            else\\n                return solve(n-1,k-mid);\\n        }\\n    }\\n    char findKthBit(int n, int k) {\\n        int bit=solve(n,k);\\n        return (char)(bit+48);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n,int k){\\n        if(n==1&&k==1)\\n            return 0;\\n        int mid=pow(2,n)/2;\\n        if(k<mid)\\n            return solve(n-1,k);\\n        else if(k==mid)\\n            return 1;\\n        else \\n        {\\n            if(k==(mid+mid/2))\\n                return !solve(n-1,k-mid);\\n            else\\n                return solve(n-1,k-mid);\\n        }\\n    }\\n    char findKthBit(int n, int k) {\\n        int bit=solve(n,k);\\n        return (char)(bit+48);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451812,
                "title": "c-solution-recursion-100-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int findLen(int n)\\n    {\\n        if(n==1)\\n            return 1;\\n        return 2*findLen(n-1)+1;\\n    }\\n    \\n    char opp(char ch)\\n    {\\n        return (ch==\\'0\\'?\\'1\\':\\'0\\');\\n    }\\n    \\n    char solve(int n, int k, int len)\\n    {\\n        if(n==1 && k==1)\\n            return \\'0\\';\\n        int childLen = len/2;\\n        if(k==childLen+1)\\n            return \\'1\\';\\n        else if(k<=childLen)\\n            return solve(n-1,k,childLen);\\n        else\\n            return opp(solve(n-1, len-k+1, childLen));\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        int len = findLen(n);\\n        return solve(n,k,len);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findLen(int n)\\n    {\\n        if(n==1)\\n            return 1;\\n        return 2*findLen(n-1)+1;\\n    }\\n    \\n    char opp(char ch)\\n    {\\n        return (ch==\\'0\\'?\\'1\\':\\'0\\');\\n    }\\n    \\n    char solve(int n, int k, int len)\\n    {\\n        if(n==1 && k==1)\\n            return \\'0\\';\\n        int childLen = len/2;\\n        if(k==childLen+1)\\n            return \\'1\\';\\n        else if(k<=childLen)\\n            return solve(n-1,k,childLen);\\n        else\\n            return opp(solve(n-1, len-k+1, childLen));\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        int len = findLen(n);\\n        return solve(n,k,len);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449260,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        if n == 1:\\n            return \"0\"\\n        i = 1\\n        s = \\'0\\'\\n        while i < n:\\n            z = s + \\'1\\'\\n            s = s.replace(\\'0\\',\\',\\').replace(\\'1\\',\\'0\\').replace(\\',\\',\\'1\\')\\n            z += s[::-1]\\n            i += 1\\n            s = z\\n        return s[k-1]\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        if n == 1:\\n            return \"0\"\\n        i = 1\\n        s = \\'0\\'\\n        while i < n:\\n            z = s + \\'1\\'\\n            s = s.replace(\\'0\\',\\',\\').replace(\\'1\\',\\'0\\').replace(\\',\\',\\'1\\')\\n            z += s[::-1]\\n            i += 1\\n            s = z\\n        return s[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428467,
                "title": "java-iterative",
                "content": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        int total = (int)(Math.pow(2,n)) - 1;\\n        boolean invert = false;\\n        while(total > 1){\\n            if(k == (total+1)/2) return invert == true ? \\'0\\' : \\'1\\';\\n            if(k > (total+1)/2){\\n                k = total - k + 1;\\n                invert = !invert;\\n            }\\n            total = total>>1;\\n        }\\n        if(invert)\\n            return k == 1 ? \\'1\\': \\'0\\';\\n        else\\n            return k == 1 ? \\'0\\': \\'1\\';\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        int total = (int)(Math.pow(2,n)) - 1;\\n        boolean invert = false;\\n        while(total > 1){\\n            if(k == (total+1)/2) return invert == true ? \\'0\\' : \\'1\\';\\n            if(k > (total+1)/2){\\n                k = total - k + 1;\\n                invert = !invert;\\n            }\\n            total = total>>1;\\n        }\\n        if(invert)\\n            return k == 1 ? \\'1\\': \\'0\\';\\n        else\\n            return k == 1 ? \\'0\\': \\'1\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386743,
                "title": "c-recurssion-faster-than-100",
                "content": "- Variation of  ``` Leetcode : 779. K-th Symbol in Grammar ```\\n\\n- We have to do some observation and apply recurssion for smaller input.\\n\\n```\\n    int KthBit(int n,int k){\\n         //Base case :\\n        if(n==1 and k==1){\\n            return 0;\\n        }\\n        \\n        int mid=pow(2,n)/2;\\n        \\n        if(k==mid){\\n            return 1;\\n        }\\n        else if(k>mid){\\n            return !(KthBit(n-1,((2*mid) - k)));\\n        }\\n        else{\\n            return KthBit(n-1,k);\\n        }\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        int ans=KthBit(n,k);   \\n        char s = ans + \\'0\\';\\n        \\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "``` Leetcode : 779. K-th Symbol in Grammar ```\n```\\n    int KthBit(int n,int k){\\n         //Base case :\\n        if(n==1 and k==1){\\n            return 0;\\n        }\\n        \\n        int mid=pow(2,n)/2;\\n        \\n        if(k==mid){\\n            return 1;\\n        }\\n        else if(k>mid){\\n            return !(KthBit(n-1,((2*mid) - k)));\\n        }\\n        else{\\n            return KthBit(n-1,k);\\n        }\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        int ans=KthBit(n,k);   \\n        char s = ans + \\'0\\';\\n        \\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1339766,
                "title": "javascript-solution-with-recursion",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {character}\\n */\\nvar findKthBit = function(n, k) {\\n    const recursion = (n) => {\\n        if (n === 1) {\\n            return \"0\"\\n        }\\n        const str = recursion(n - 1)\\n        return str + \"1\" + str.split(\\'\\').map(char => char === \\'0\\' ? \\'1\\': \\'0\\').reverse().join(\\'\\')\\n    }\\n    return recursion(n)[k - 1]\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {character}\\n */\\nvar findKthBit = function(n, k) {\\n    const recursion = (n) => {\\n        if (n === 1) {\\n            return \"0\"\\n        }\\n        const str = recursion(n - 1)\\n        return str + \"1\" + str.split(\\'\\').map(char => char === \\'0\\' ? \\'1\\': \\'0\\').reverse().join(\\'\\')\\n    }\\n    return recursion(n)[k - 1]\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1304491,
                "title": "recursive-java-solution-with-comments-beats-100",
                "content": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if(n == 1 && k == 1)        //the base case\\n            return \\'0\\';\\n        \\n        int len = (int)Math.pow(2,n)-1;       //length of each level\\n        int mid = (len+2)/2;\\n        \\n        if(k < mid)         //for k < mid, we just need to look up to the kth bit of n-1th level\\n            return findKthBit(n-1,k);\\n\\t\\telse if(k == mid)         //the mid bit will always be 1 for each level\\n            return \\'1\\';\\n        \\n\\t\\t//Now for the case, where k > mid\\n        int prevLen = mid-1;     //length of previous level\\n\\t\\t\\n        int prevBitPosFromStart = k-mid;     //this will give the position bit whose inverse is the current node\\'s k value\\n\\t\\t                                     //but this will be from starting so to obtain it from the end(because it was\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t //reversed), we need to subtract it from the prevLen and then, add one to it \\n        return (findKthBit(n-1, prevLen-prevBitPosFromStart+1) == \\'0\\'? \\'1\\':\\'0\\');    \\n    }\\n}\\n```\\n\\nFor better uderstanding, try dry running it for n = 4, k = 10. \\nFeel free to ask any queries below.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if(n == 1 && k == 1)        //the base case\\n            return \\'0\\';\\n        \\n        int len = (int)Math.pow(2,n)-1;       //length of each level\\n        int mid = (len+2)/2;\\n        \\n        if(k < mid)         //for k < mid, we just need to look up to the kth bit of n-1th level\\n            return findKthBit(n-1,k);\\n\\t\\telse if(k == mid)         //the mid bit will always be 1 for each level\\n            return \\'1\\';\\n        \\n\\t\\t//Now for the case, where k > mid\\n        int prevLen = mid-1;     //length of previous level\\n\\t\\t\\n        int prevBitPosFromStart = k-mid;     //this will give the position bit whose inverse is the current node\\'s k value\\n\\t\\t                                     //but this will be from starting so to obtain it from the end(because it was\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t //reversed), we need to subtract it from the prevLen and then, add one to it \\n        return (findKthBit(n-1, prevLen-prevBitPosFromStart+1) == \\'0\\'? \\'1\\':\\'0\\');    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931804,
                "title": "c-solution-0ms-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    //O(20) ~ constant time \\n    //O(n) for n > 20\\n    char findKthBit(int n, int k) {\\n        if(n == 1)\\n            return \\'0\\';\\n        int length = len(n);\\n        int tmp = (length-1)/2;\\n        if(k <= tmp)\\n            return findKthBit(n-1,k);\\n        else if(k == tmp+1)\\n            return \\'1\\';\\n        else{\\n            char ch = findKthBit(n-1,(tmp+1) - (k-(tmp+1)));\\n            if(ch == \\'1\\')\\n                return \\'0\\';\\n            else\\n                return \\'1\\';   \\n        }\\n        \\n    }\\n    \\n    //O(20) ~ Constant Time\\n    int len(int n){\\n        if(n == 1) return 1;\\n        return 2*len(n-1) +1;\\n    }\\n};\\n\\n/*\\n\\nlen Si = 2x(len Si-1) + 1\\nS1 = 0          \\nS2 = 0-1-1\\nS3 = 011-1-001\\nS4 = 0111001-1-01(1)0001\\nS5 = 011100110110001 -1- 011100100110001\\n\\nS1 = len 1\\nS2 = len 3\\nS3 = len 7\\nS4 = len 15\\nS5 = len 31\\n\\n20,1211\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //O(20) ~ constant time \\n    //O(n) for n > 20\\n    char findKthBit(int n, int k) {\\n        if(n == 1)\\n            return \\'0\\';\\n        int length = len(n);\\n        int tmp = (length-1)/2;\\n        if(k <= tmp)\\n            return findKthBit(n-1,k);\\n        else if(k == tmp+1)\\n            return \\'1\\';\\n        else{\\n            char ch = findKthBit(n-1,(tmp+1) - (k-(tmp+1)));\\n            if(ch == \\'1\\')\\n                return \\'0\\';\\n            else\\n                return \\'1\\';   \\n        }\\n        \\n    }\\n    \\n    //O(20) ~ Constant Time\\n    int len(int n){\\n        if(n == 1) return 1;\\n        return 2*len(n-1) +1;\\n    }\\n};\\n\\n/*\\n\\nlen Si = 2x(len Si-1) + 1\\nS1 = 0          \\nS2 = 0-1-1\\nS3 = 011-1-001\\nS4 = 0111001-1-01(1)0001\\nS5 = 011100110110001 -1- 011100100110001\\n\\nS1 = len 1\\nS2 = len 3\\nS3 = len 7\\nS4 = len 15\\nS5 = len 31\\n\\n20,1211\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923991,
                "title": "simple-python-iteration-solution",
                "content": "No fancy algorithm. Just simple simulation.\\n```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        left, right = \\'0\\', \\'1\\'\\n        for _ in range(n):\\n            left, right = left+\\'1\\'+right, left+\\'0\\'+right\\n        return left[k-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        left, right = \\'0\\', \\'1\\'\\n        for _ in range(n):\\n            left, right = left+\\'1\\'+right, left+\\'0\\'+right\\n        return left[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876949,
                "title": "c-iterative-36ms",
                "content": "```\\nclass Solution {\\n    string ri(string s) {\\n        int l = 0, r = s.size() - 1;\\n        while (l < r) swap(s[l++] ^= 1, s[r--] ^= 1);\\n        s[l] ^= 1;\\n        return s;\\n    }\\npublic:\\n    char findKthBit(int n, int k) {\\n        string s = \"0\";\\n        while (s.size() < k) s += \"1\" + ri(s);\\n        return s[k-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    string ri(string s) {\\n        int l = 0, r = s.size() - 1;\\n        while (l < r) swap(s[l++] ^= 1, s[r--] ^= 1);\\n        s[l] ^= 1;\\n        return s;\\n    }\\npublic:\\n    char findKthBit(int n, int k) {\\n        string s = \"0\";\\n        while (s.size() < k) s += \"1\" + ri(s);\\n        return s[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870240,
                "title": "simple-and-easy-solution-with-c-non-recursive-solution",
                "content": "class Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        string bin = \"0\";\\n        while(bin.length() <k)\\n        {\\n            bin += \\'1\\';\\n                for(int itr=bin.size()-2;itr>=0 && bin.length()<k;itr--)\\n                    bin+= bin[itr] == \\'1\\' ? \\'0\\' : \\'1\\';\\n        }\\n        return bin[k-1];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        string bin = \"0\";\\n        while(bin.length() <k)\\n        {\\n            bin += \\'1\\';\\n                for(int itr=bin.size()-2;itr>=0 && bin.length()<k;itr--)\\n                    bin+= bin[itr] == \\'1\\' ? \\'0\\' : \\'1\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 822581,
                "title": "java-recursive-beat-100-n-is-useless",
                "content": "1. caculate `pw`(floor 2 pow) of `k`\\n2. if `k=pw`, return `1`, otherwise return `invert(f(pw-(k-pw)))`=`invert(f(2*pw-k))`\\n```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if (k==0) return \\'1\\';\\n        if (k==1) return \\'0\\';\\n        \\n        int lg = (int) (Math.log(k)/Math.log(2));\\n        int pw = (int) Math.pow(2,lg);\\n        if (pw==k) {\\n            return \\'1\\';\\n        }\\n        int v=findKthBit(n,2*pw-k);\\n        return v==\\'0\\'?\\'1\\':\\'0\\';\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if (k==0) return \\'1\\';\\n        if (k==1) return \\'0\\';\\n        \\n        int lg = (int) (Math.log(k)/Math.log(2));\\n        int pw = (int) Math.pow(2,lg);\\n        if (pw==k) {\\n            return \\'1\\';\\n        }\\n        int v=findKthBit(n,2*pw-k);\\n        return v==\\'0\\'?\\'1\\':\\'0\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810704,
                "title": "java-simple",
                "content": "public char findKthBit(int n, int k) {\\n        String s = \"0\";\\n        if(n == 1)\\n            return \\'0\\';\\n        while(n-- - 1 > 0) {\\n            s += \"1\" + Solution.invertAndReverse(s);\\n        }\\n        return s.charAt(k - 1);    \\n    }\\n\\t\\n\\t    public static String invertAndReverse(String s) {\\n        StringBuffer buffer = new StringBuffer(\"\");\\n        for(char c : s.toCharArray()) {\\n            buffer.append(c == \\'0\\' ? \\'1\\' : \\'0\\');\\n        }\\n        return buffer.reverse().toString();\\n    }",
                "solutionTags": [],
                "code": "public char findKthBit(int n, int k) {\\n        String s = \"0\";\\n        if(n == 1)\\n            return \\'0\\';\\n        while(n-- - 1 > 0) {\\n            s += \"1\" + Solution.invertAndReverse(s);\\n        }\\n        return s.charAt(k - 1);    \\n    }\\n\\t\\n\\t    public static String invertAndReverse(String s) {\\n        StringBuffer buffer = new StringBuffer(\"\");\\n        for(char c : s.toCharArray()) {\\n            buffer.append(c == \\'0\\' ? \\'1\\' : \\'0\\');\\n        }\\n        return buffer.reverse().toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 797078,
                "title": "c-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    char invert(char a){\\n        if(a==\\'1\\')\\n            return \\'0\\';\\n        return \\'1\\';\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        if(k==1 or n==1)    return \\'0\\';\\n        if(k==pow(2,n-1))  return \\'1\\';\\n        if(k<pow(2,n-1))\\n            return findKthBit(n-1,k);\\n        return invert(findKthBit(n-1,pow(2,n)-k));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char invert(char a){\\n        if(a==\\'1\\')\\n            return \\'0\\';\\n        return \\'1\\';\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        if(k==1 or n==1)    return \\'0\\';\\n        if(k==pow(2,n-1))  return \\'1\\';\\n        if(k<pow(2,n-1))\\n            return findKthBit(n-1,k);\\n        return invert(findKthBit(n-1,pow(2,n)-k));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794939,
                "title": "rust-translated",
                "content": "```rust\\n// https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/discuss/785548/JavaC%2B%2BPython-O(1)-Solutions\\nimpl Solution {\\n    pub fn find_kth_bit(n: i32, k: i32) -> char {\\n        (((k / (k & -k) >> 1 & 1) ^ (k & 1 ^ 1)) as u8 + b\\'0\\') as char\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_find_kth_bit() {\\n        assert_eq!(Solution::find_kth_bit(3, 1), \\'0\\')\\n    }\\n\\n    #[test]\\n    fn test_find_kth_bit_02() {\\n        assert_eq!(Solution::find_kth_bit(4, 11), \\'1\\')\\n    }\\n\\n    #[test]\\n    fn test_find_kth_bit_03() {\\n        assert_eq!(Solution::find_kth_bit(1, 1), \\'0\\')\\n    }\\n\\n    #[test]\\n    fn test_find_kth_bit_04() {\\n        assert_eq!(Solution::find_kth_bit(2, 3), \\'1\\')\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\n// https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/discuss/785548/JavaC%2B%2BPython-O(1)-Solutions\\nimpl Solution {\\n    pub fn find_kth_bit(n: i32, k: i32) -> char {\\n        (((k / (k & -k) >> 1 & 1) ^ (k & 1 ^ 1)) as u8 + b\\'0\\') as char\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_find_kth_bit() {\\n        assert_eq!(Solution::find_kth_bit(3, 1), \\'0\\')\\n    }\\n\\n    #[test]\\n    fn test_find_kth_bit_02() {\\n        assert_eq!(Solution::find_kth_bit(4, 11), \\'1\\')\\n    }\\n\\n    #[test]\\n    fn test_find_kth_bit_03() {\\n        assert_eq!(Solution::find_kth_bit(1, 1), \\'0\\')\\n    }\\n\\n    #[test]\\n    fn test_find_kth_bit_04() {\\n        assert_eq!(Solution::find_kth_bit(2, 3), \\'1\\')\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 790991,
                "title": "java-recursion-beats-100",
                "content": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if(n == 1)\\n            return \\'0\\';\\n        if(n==2 )\\n        {\\n            char[] arr = {\\'0\\',\\'0\\',\\'1\\',\\'1\\'};\\n            return arr[k];\\n        }\\n        if( k == (int) Math.pow(2,n-1))\\n            return \\'1\\';\\n        else if (k<(int) Math.pow(2,n-1))\\n        {\\n            return findKthBit(n-1,k);\\n        }\\n        else\\n        {\\n            int tmp = k -(int) Math.pow(2,n-1);\\n            return (char) (\\'1\\' - findKthBit(n-1, 2 * (int) Math.pow(2,n-1)-k)+\\'0\\');\\n        } \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if(n == 1)\\n            return \\'0\\';\\n        if(n==2 )\\n        {\\n            char[] arr = {\\'0\\',\\'0\\',\\'1\\',\\'1\\'};\\n            return arr[k];\\n        }\\n        if( k == (int) Math.pow(2,n-1))\\n            return \\'1\\';\\n        else if (k<(int) Math.pow(2,n-1))\\n        {\\n            return findKthBit(n-1,k);\\n        }\\n        else\\n        {\\n            int tmp = k -(int) Math.pow(2,n-1);\\n            return (char) (\\'1\\' - findKthBit(n-1, 2 * (int) Math.pow(2,n-1)-k)+\\'0\\');\\n        } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787373,
                "title": "java-bruteforce-using-recursion",
                "content": "```\\nclass Solution {\\n    Map<Integer, String> map;\\n    public char findKthBit(int n, int k) {\\n        map = new HashMap<>();\\n        String s = recursive(n);\\n        return s.charAt(k - 1);\\n    }\\n    \\n    private String recursive(int n) {\\n       \\n        if(n == 1) {\\n            return \"0\";\\n        }\\n        if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        StringBuilder sb = new StringBuilder(recursive(n - 1));\\n        sb.append(\"1\");\\n        for(int i = sb.length() - 2; i >= 0; i--) {\\n            sb.append(sb.charAt(i) == \\'1\\' ? \\'0\\' : \\'1\\');\\n        }\\n        String ans = sb.toString();\\n        map.put(n, ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, String> map;\\n    public char findKthBit(int n, int k) {\\n        map = new HashMap<>();\\n        String s = recursive(n);\\n        return s.charAt(k - 1);\\n    }\\n    \\n    private String recursive(int n) {\\n       \\n        if(n == 1) {\\n            return \"0\";\\n        }\\n        if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        StringBuilder sb = new StringBuilder(recursive(n - 1));\\n        sb.append(\"1\");\\n        for(int i = sb.length() - 2; i >= 0; i--) {\\n            sb.append(sb.charAt(i) == \\'1\\' ? \\'0\\' : \\'1\\');\\n        }\\n        String ans = sb.toString();\\n        map.put(n, ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782621,
                "title": "one-line-python-solution-no-recursion",
                "content": "```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        return str(int((bin(k).split(\\'1\\')[-2]==\\'\\') == k%2))\\n```\\n\\nThis may be hard to understand, I\\'ll provide two ways to explain it:\\n\\n\\n# First explanation:\\nThis is equivalent to:\\n```\\n        if k%2:\\n            return \\'1\\' if k%4==3 else \\'0\\'\\n        b = k\\n\\t\\twhile b//2: k = b//2\\n        return \\'0\\' if b%4==3 else \\'1\\'\\n```\\nNotice `k%4 == 3` or `not k%2 and  b%4 == 3` is equivalent to the character before last `\\'1\\'` in `bin(k) `is also `\\'1\\'`, i.e. `bin(k).split(\\'1\\')[-1] == \\'\\'`.\\n\\nFirst observe that n is useless. S_n is the first half of S_n+1. So just imagine there\\'s an infinite array S (**index from 1**) with the following property:\\n\\n1.` S[1] = 0`\\n2. `S[2**i] = 1` (i is positive integer)\\n3. `S[2**i+1: 2**(i+1)] = reverse(invert(S[1:2**i))`\\n\\nThen we only need to return the kth element in this array.\\nAn observation is that all elements with odd index is like ` 0, 1, 0, 1,... ` This could be proved by induction. So we can immediately know that if k is odd:\\n```\\nS[k] = 0 if k%4 == 1\\nS[k] = 1 if k%4 == 3\\n```\\n\\nNow delete all elements with odd index and we can get a subarray  `S\\' = 1,1,0,1,1,0,0...` You can prove that this array also satisfies the property 2 and 3 but starts from 1. And in this new array the odd-indexed elements are like `1,0,1,0,...` So:\\n```\\nS[k] = S\\'[k//2] = 1 if k is even and (k//2)%4 == 1\\nS[k] = S\\'[k//2] = 0 if k is even and (k//2)%4 == 3\\n```\\nDelete all elements with odd index in S\\' and the new subarray is just the same as S\\'. So if k%4==0, S[k] = S[k//2].\\n\\n\\n# Second Explanation:\\nThis is based on an interesting fact. Compare Si and reverse(invert(Si)):\\n\\ni=1: 1 vs 0\\ni = 2: 011 vs 001\\ni = 3: 0111001 vs 0110001\\n...\\n\\nThen we can find that they are the same expect the middle element. \\n\\nThis could be proved by induction:\\nDenote Sn\\' = reverse(invert(Sn)) and they are the same expect the middle element. Then Sn+1 = Sn+\\'1\\'+Sn\\'. reverse(invert(Sn+1)) = reverse(invert(Sn\\')) + \\'0\\' + reverse(invert(Sn)) = Sn+\\'0\\'+Sn\\'. And it\\'s the same as Sn+1 except the element in the middle.\\n\\nConsider the binary of k with n bits, it\\'s equivalent to consider k-2^n unless it\\'s of the form 11(000...), i.e. k=2^n+2^(n-1).\\n\\nFor example:\\n(Denote the result of k is f(k). )\\n(f(2^n)=1 if n is positive)\\nf(11001010) = f(1001010) = f(1010) = f(10) = 1\\nf(11001011) = f(1001011) = f(1011) = f(11) = invert(f(1)) = invert(0) = 1\\nf(11001100) = f(1001100) = f(1100) = invert(f(100)) = invert(1) = 0\\n\\nSo:\\nIf bin(k) ends with 01, it\\'s safe to delete all 1 before it: return f(1) = 0\\nIf bin(k) ends with 11, it\\'s safe to delete all 1 before it: return f(11) = invert(f(1)) = invert(0) = 1\\nIf bin(k) ends with 010...0, it\\'s safe to delete all 1 before it: return f(010...0) = 1\\nIf bin(k) ends with 110...0, it\\'s safe to delete all 1 before it: return f(110...0) = invert(f(10...0)) = invert(1) = 0\\n\\n\\nI hope I have put is clearly. BTW, this is the first time that I\\'m still satisfied with my solution after I read Lee\\'s post \\u0F3C\\uA27A.\\u032B\\uA27A\\u0F3D\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        return str(int((bin(k).split(\\'1\\')[-2]==\\'\\') == k%2))\\n```\n```\\n        if k%2:\\n            return \\'1\\' if k%4==3 else \\'0\\'\\n        b = k\\n\\t\\twhile b//2: k = b//2\\n        return \\'0\\' if b%4==3 else \\'1\\'\\n```\n```\\nS[k] = 0 if k%4 == 1\\nS[k] = 1 if k%4 == 3\\n```\n```\\nS[k] = S\\'[k//2] = 1 if k is even and (k//2)%4 == 1\\nS[k] = S\\'[k//2] = 0 if k is even and (k//2)%4 == 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782254,
                "title": "java-very-short-code-easy-to-understand",
                "content": "```\\n    public char findKthBit(int n, int k) {\\n        StringBuilder curr = new StringBuilder(\"0\");\\n        for (int i = 2; i <= n; i++) {\\n            String s = new String(curr);\\n            s = s.replace(\"1\", \"2\");\\n            s = s.replace(\"0\", \"1\");\\n            s = s.replace(\"2\", \"0\");\\n            curr.append(\"1\").append(new StringBuilder(s).reverse());   \\n        }\\n        return curr.charAt(k - 1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public char findKthBit(int n, int k) {\\n        StringBuilder curr = new StringBuilder(\"0\");\\n        for (int i = 2; i <= n; i++) {\\n            String s = new String(curr);\\n            s = s.replace(\"1\", \"2\");\\n            s = s.replace(\"0\", \"1\");\\n            s = s.replace(\"2\", \"0\");\\n            curr.append(\"1\").append(new StringBuilder(s).reverse());   \\n        }\\n        return curr.charAt(k - 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781958,
                "title": "java-iterative-brute-force",
                "content": "Just following the description of the question. \\nBrute Force.\\n\\n```java\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        String s = \"0\";\\n        for(int i=1; i<n; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j=0; j< s.length(); j++){\\n                sb.append(s.charAt(j) == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            s = s + \"1\" + sb.reverse().toString();\\n        }\\n        return s.charAt(k-1);\\n    }\\n}\\n```\\nFeel free to post any question.",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        String s = \"0\";\\n        for(int i=1; i<n; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j=0; j< s.length(); j++){\\n                sb.append(s.charAt(j) == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            s = s + \"1\" + sb.reverse().toString();\\n        }\\n        return s.charAt(k-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781624,
                "title": "javascript-simple-dp-solution-o-k",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {character}\\n */\\nvar findKthBit = function(n, k) {\\n    //dp is the digit array of the formed string, and num is the supposed length \\n    let dp = [0], num = 1 \\n    for(let i = 1; i < k; i++) {\\n        if(i === num) {  \\n            num = 2 * num + 1\\n            dp[i] = 1 \\n        } else {\\n            dp[i] = dp[num - 1 - i] ^ 1\\n        }\\n    }\\n    return dp[k - 1] + \\'\\'\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {character}\\n */\\nvar findKthBit = function(n, k) {\\n    //dp is the digit array of the formed string, and num is the supposed length \\n    let dp = [0], num = 1 \\n    for(let i = 1; i < k; i++) {\\n        if(i === num) {  \\n            num = 2 * num + 1\\n            dp[i] = 1 \\n        } else {\\n            dp[i] = dp[num - 1 - i] ^ 1\\n        }\\n    }\\n    return dp[k - 1] + \\'\\'\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781430,
                "title": "kotlin-iterative-solution",
                "content": "Pretty-much self-explanatory, feel free to ask in comments if you have any questions.\\n\\n```\\nfun findKthBit(n: Int, k: Int): Char {\\n        when (k) {\\n            1 -> return \\'0\\'\\n            2 -> return \\'1\\'\\n        }\\n        \\n        val list = mutableListOf<String>()\\n        list.add(\"0\") // 1st element always 0\\n        \\n        for (i in 1 until n) {\\n            list.add(makeString(list[i-1])) // Forming S(i-1)\\n        }\\n\\n        return list[n-1][k-1] // Nth string\\'s kth character\\n    }\\n    \\n    fun makeString(str: String): String {\\n        val sb = StringBuilder(str)\\n        sb.append(\"1\") // By given rule\\n        \\n        for (i in str.indices.reversed()) { // Reverse and flip at the same time\\n            if (str[i] == \\'1\\')\\n                sb.append(\"0\")\\n            else\\n                sb.append(\"1\")\\n        }\\n        \\n        return sb.toString()\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun findKthBit(n: Int, k: Int): Char {\\n        when (k) {\\n            1 -> return \\'0\\'\\n            2 -> return \\'1\\'\\n        }\\n        \\n        val list = mutableListOf<String>()\\n        list.add(\"0\") // 1st element always 0\\n        \\n        for (i in 1 until n) {\\n            list.add(makeString(list[i-1])) // Forming S(i-1)\\n        }\\n\\n        return list[n-1][k-1] // Nth string\\'s kth character\\n    }\\n    \\n    fun makeString(str: String): String {\\n        val sb = StringBuilder(str)\\n        sb.append(\"1\") // By given rule\\n        \\n        for (i in str.indices.reversed()) { // Reverse and flip at the same time\\n            if (str[i] == \\'1\\')\\n                sb.append(\"0\")\\n            else\\n                sb.append(\"1\")\\n        }\\n        \\n        return sb.toString()\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781246,
                "title": "c-since-n-20-generate-all-strings-and-find-kth-char-in-nth-string",
                "content": "```csharp\\npublic char FindKthBit(int n, int k)\\n{\\n\\tstring[] s = new string[n + 1];\\n\\ts[0] = \"0\";\\n\\n\\tfor (int i = 1; i < n; i++)\\n\\t{\\n\\t\\ts[i] = s[i - 1] + \"1\" + invert(s[i - 1]);            \\n\\t}\\n\\n\\treturn s[n - 1][k - 1];\\n}\\n\\nprivate string invert(string s)\\n{\\n\\tchar[] result = new char[s.Length];\\n\\tfor (int i = 0; i < s.Length; i++)\\n\\t{\\n\\t\\tresult[s.Length - i - 1] = s[i] == \\'0\\' ? \\'1\\': \\'0\\';\\n\\t}\\n\\n\\treturn new string(result);\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic char FindKthBit(int n, int k)\\n{\\n\\tstring[] s = new string[n + 1];\\n\\ts[0] = \"0\";\\n\\n\\tfor (int i = 1; i < n; i++)\\n\\t{\\n\\t\\ts[i] = s[i - 1] + \"1\" + invert(s[i - 1]);            \\n\\t}\\n\\n\\treturn s[n - 1][k - 1];\\n}\\n\\nprivate string invert(string s)\\n{\\n\\tchar[] result = new char[s.Length];\\n\\tfor (int i = 0; i < s.Length; i++)\\n\\t{\\n\\t\\tresult[s.Length - i - 1] = s[i] == \\'0\\' ? \\'1\\': \\'0\\';\\n\\t}\\n\\n\\treturn new string(result);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781189,
                "title": "python-binary-search-28ms",
                "content": "s(i+2) = s(i) + 1 + r(i(s(i)) +   1   + s(i) + 0 + r(i(s(i))\\n\\nSo use binary search :\\n    if move to left , then mid is 1\\n    if move to right, then mid is 0\\n\\nBut we need to conside some special cases :\\n    1. when there are [0, 1, 1] => right - left == 3,\\n            then move to left , mid is 0\\n            move to right, mid i s 1\\n    2. when n= 1, k = 1, the very first is 0. So here we can use :\\n            if k == 1, then return 0\\n```\\nclass Solution(object):\\n    def findKthBit(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        if k == 1:\\n            return \"0\"\\n        num = 1\\n        while n > 1:\\n            num = 2 * num + 1\\n            n -= 1\\n        # print(num)\\n        left, right = 1, num+1\\n        flag = True\\n        while left < right:\\n            mid = (right - left) // 2 + left\\n            if mid == k:\\n                return \"1\" if flag == True else \"0\"\\n            elif mid > k:\\n                flag = True if right - left > 2 else False\\n                if right - left == 3:\\n                    flag = not flag\\n                right = mid\\n            else:\\n                flag = False if right - left > 2 else True\\n                if right - left == 3:\\n                    flag = not flag\\n                left = mid + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findKthBit(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        if k == 1:\\n            return \"0\"\\n        num = 1\\n        while n > 1:\\n            num = 2 * num + 1\\n            n -= 1\\n        # print(num)\\n        left, right = 1, num+1\\n        flag = True\\n        while left < right:\\n            mid = (right - left) // 2 + left\\n            if mid == k:\\n                return \"1\" if flag == True else \"0\"\\n            elif mid > k:\\n                flag = True if right - left > 2 else False\\n                if right - left == 3:\\n                    flag = not flag\\n                right = mid\\n            else:\\n                flag = False if right - left > 2 else True\\n                if right - left == 3:\\n                    flag = not flag\\n                left = mid + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781158,
                "title": "c-1-liner-recursive-solution-beats-100-with-detailed-explanation",
                "content": "0\\n011, the reflection point is the middle 1 (place 2)\\n0111001, the reflection point is the middle 1 (place 4)\\nif k is not a power of 2, then we reduce it bit by bit, reflect from the rightmost pivot left to k (simply the greatest power of 2 less than k) and reverse the bit\\n\\'0\\' is 48, \\'1\\' is 49, we can use xor to inverse it\\ninteresing fact is that n is of no use\\n```\\nchar findKthBit(int n, int k) \\n{\\n\\tif(k==1) return \\'0\\';//ending case when k is 1\\n\\tif(!(k&(k-1))) return \\'1\\';//if k is power of 2, then it is the reflection point and must be \\'1\\'\\n\\treturn (char)(findKthBit(n,2*(1<<(int)log2(k))-k)^1);//2*max_power-k\\n}\\n```\\n1 liner if you wish lol\\n```\\nchar findKthBit(int n, int k) \\n{\\n\\treturn (k==1)?\\'0\\':(!(k&(k-1)))?\\'1\\':(char)(findKthBit(n,2*(1<<(int)log2(k))-k)^1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar findKthBit(int n, int k) \\n{\\n\\tif(k==1) return \\'0\\';//ending case when k is 1\\n\\tif(!(k&(k-1))) return \\'1\\';//if k is power of 2, then it is the reflection point and must be \\'1\\'\\n\\treturn (char)(findKthBit(n,2*(1<<(int)log2(k))-k)^1);//2*max_power-k\\n}\\n```\n```\\nchar findKthBit(int n, int k) \\n{\\n\\treturn (k==1)?\\'0\\':(!(k&(k-1)))?\\'1\\':(char)(findKthBit(n,2*(1<<(int)log2(k))-k)^1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781157,
                "title": "java-iterative-solution-do-not-need-to-concatenate-string",
                "content": "The key idea of this iterative solution is to every time shorten the String Sn, and find the symmetry on the left part if k is bigger than mid point. Using boolean \\'toFlip\\' to record whether or not need to flip after iteration.\\n```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        \\n        boolean toFlip=false;\\n        k--;\\n        char res = \\'0\\';\\n        int count=1;\\n        \\n        //find the length of Sn stored in \\'count\\'.\\n        for(int i=1;i<n;i++){\\n            count = count*2 +1;\\n        } \\n        \\n        while(n>1){\\n            int mid = count/2;\\n            \\n            //if k is exactly the mid point, the temporary result is \\'1\\'.\\n            if(k==mid){\\n                res = \\'1\\';\\n                break;\\n            }\\n            //if k is bigger than mid, which means on the right side if Sn, \\n            // we can find the symmetry left part and just flip it.\\n            else if(k>mid){\\n                toFlip = !toFlip;\\n                int diff = k-mid;\\n                k = mid-diff;\\n            }\\n            n--;  \\n            count /=2;\\n        }\\n        \\n        if(toFlip){\\n            if(res==\\'0\\'){\\n                res=\\'1\\';\\n            }\\n            else{\\n                res=\\'0\\';\\n            }\\n        }\\n        \\n        return res;\\n                \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public char findKthBit(int n, int k) {\\n        \\n        boolean toFlip=false;\\n        k--;\\n        char res = \\'0\\';\\n        int count=1;\\n        \\n        //find the length of Sn stored in \\'count\\'.\\n        for(int i=1;i<n;i++){\\n            count = count*2 +1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 781092,
                "title": "python-concise-binary-search-like-recursive-solution",
                "content": "```\\nclass Solution(object):\\n    def findKthBit(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        if n == 1: \\n            return \"0\"\\n        \\n        mid = 2**(n-1)\\n        if k == mid: return \"1\"\\n        if k < mid:\\n            return self.findKthBit(n-1, k)\\n        else:\\n            return \"1\" if self.findKthBit(n-1, 2*mid-k) == \"0\" else \"0\"\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def findKthBit(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        if n == 1: \\n            return \"0\"\\n        \\n        mid = 2**(n-1)\\n        if k == mid: return \"1\"\\n        if k < mid:\\n            return self.findKthBit(n-1, k)\\n        else:\\n            return \"1\" if self.findKthBit(n-1, 2*mid-k) == \"0\" else \"0\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781069,
                "title": "c-o-n-o-n-recursive-solution",
                "content": "The main idea here is the self-similarity of the string. Because the string of length ```n``` is constructed from the string of length ```n-1``` we can solve this recursively.\\n\\nIn this recursion, the level is always decreased by 1, and no string is actually generated, so the algorithm is O(n) time and O(1) space.\\n```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n\\t    // First bit is always 0\\n        if (k == 1) return \\'0\\';\\n\\t\\t\\n\\t\\t// The length of the string at level n is 2^n-1, so 2^(n-1) is the halfway index\\n        int half_len = 1 << (n-1);\\n\\t\\t// The halfway index is set to be 1\\n        if (k == half_len) return \\'1\\';\\n\\t\\t\\n\\t\\t// If the index is in the first half, we are effectively searching in the string of size n-1\\n        else if (k < half_len) return findKthBit(n-1, k);\\n\\t\\t\\n\\t\\t// If the index is in the second half, we are searching in the reversed and inverted string of size n-1\\n\\t\\t// To invert a bit x, we could normally use 1 - x, but because these are characters, we have to account \\n\\t\\t// for their ASCII values.\\n        else return \\'0\\' + 1 - (findKthBit(n-1, (half_len << 1) - k) - \\'0\\');\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```n```\n```n-1```\n```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n\\t    // First bit is always 0\\n        if (k == 1) return \\'0\\';\\n\\t\\t\\n\\t\\t// The length of the string at level n is 2^n-1, so 2^(n-1) is the halfway index\\n        int half_len = 1 << (n-1);\\n\\t\\t// The halfway index is set to be 1\\n        if (k == half_len) return \\'1\\';\\n\\t\\t\\n\\t\\t// If the index is in the first half, we are effectively searching in the string of size n-1\\n        else if (k < half_len) return findKthBit(n-1, k);\\n\\t\\t\\n\\t\\t// If the index is in the second half, we are searching in the reversed and inverted string of size n-1\\n\\t\\t// To invert a bit x, we could normally use 1 - x, but because these are characters, we have to account \\n\\t\\t// for their ASCII values.\\n        else return \\'0\\' + 1 - (findKthBit(n-1, (half_len << 1) - k) - \\'0\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781043,
                "title": "c-ugly-c-brute-force-solution",
                "content": "```\\npublic class Solution {\\n    public char FindKthBit(int n, int k) {\\n        \\n        string s = \"0\";\\n        while(n > 1)\\n        {\\n            s = s + \"1\" + Reverse(Invert(s));\\n            n--;\\n        }\\n        \\n        return s[k-1];\\n    }\\n    \\n    public string Invert(string str)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        foreach(char c in str)\\n        {\\n            if(c == \\'0\\')\\n                sb.Append(\"1\");\\n            else\\n                sb.Append(\"0\");\\n        }\\n        \\n        return sb.ToString();\\n    }\\n    \\n    public string Reverse(string str)\\n    {\\n        int i = 0, j = str.Length - 1;\\n        char[] arr = str.ToArray();\\n        \\n        while(i < j)\\n        {\\n            char temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] = temp;\\n            i++;\\n            j--;\\n        }\\n        \\n        return new string(arr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public char FindKthBit(int n, int k) {\\n        \\n        string s = \"0\";\\n        while(n > 1)\\n        {\\n            s = s + \"1\" + Reverse(Invert(s));\\n            n--;\\n        }\\n        \\n        return s[k-1];\\n    }\\n    \\n    public string Invert(string str)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        foreach(char c in str)\\n        {\\n            if(c == \\'0\\')\\n                sb.Append(\"1\");\\n            else\\n                sb.Append(\"0\");\\n        }\\n        \\n        return sb.ToString();\\n    }\\n    \\n    public string Reverse(string str)\\n    {\\n        int i = 0, j = str.Length - 1;\\n        char[] arr = str.ToArray();\\n        \\n        while(i < j)\\n        {\\n            char temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] = temp;\\n            i++;\\n            j--;\\n        }\\n        \\n        return new string(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780994,
                "title": "o-n-solution-c",
                "content": "Idea:\\nThere are two possible origins of a digit, i.e. the initail `0` or `1` that\\'s added during concatenation.\\nFind out how many time this origin was flipped.\\n```\\nchar findKthBit(int n, int k) {\\n    int cnt = 0;\\n    while (n>0) {\\n        int pivot = 1 << (n-1);\\n        if (k == pivot)  // if k equals to 1 << (n-1), it has found the origin\\n            break;\\n        if (k > pivot)\\n            cnt++, k = 2 * pivot - k;  // this is because s was reversed\\n        n--;\\n    }\\n    if (n == 1)\\n        return cnt % 2 ? \\'1\\' : \\'0\\';  // if n == 1, it means the origin is 0\\n    return cnt % 2 ? \\'0\\' : \\'1\\';  // otherwise, the origin is 1\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar findKthBit(int n, int k) {\\n    int cnt = 0;\\n    while (n>0) {\\n        int pivot = 1 << (n-1);\\n        if (k == pivot)  // if k equals to 1 << (n-1), it has found the origin\\n            break;\\n        if (k > pivot)\\n            cnt++, k = 2 * pivot - k;  // this is because s was reversed\\n        n--;\\n    }\\n    if (n == 1)\\n        return cnt % 2 ? \\'1\\' : \\'0\\';  // if n == 1, it means the origin is 0\\n    return cnt % 2 ? \\'0\\' : \\'1\\';  // otherwise, the origin is 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780936,
                "title": "c-recursive-approach",
                "content": "\\n\\t int helper(int n,int k){\\n        if(n==1){\\n            return 0;\\n        }\\n          if(k==(n+1)/2){\\n              return 1;\\n          }\\n        else if(k>n/2){\\n            return !helper(n/2,n-k+1);\\n        }\\n        else {\\n            return helper(n/2,k);\\n        }\\n    }\\n    char findKthBit(int n, int k) {\\n           \\n         int i=1;\\n         int len=1;\\n        while(i<n){\\n            len=2*len+1;\\n            i++;\\n        }\\n        return helper(len,k)+\\'0\\';\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "\\n\\t int helper(int n,int k){\\n        if(n==1){\\n            return 0;\\n        }\\n          if(k==(n+1)/2){\\n              return 1;\\n          }\\n        else if(k>n/2){\\n            return !helper(n/2,n-k+1);\\n        }\\n        else {\\n            return helper(n/2,k);\\n        }\\n    }\\n    char findKthBit(int n, int k) {\\n           \\n         int i=1;\\n         int len=1;\\n        while(i<n){\\n            len=2*len+1;\\n            i++;\\n        }\\n        return helper(len,k)+\\'0\\';\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 780915,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if(n == 1){\\n            return \\'0\\';\\n        }\\n        int total = (1 << n) - 1;\\n        int half = (total - 1) / 2;\\n        int mid = half + 1;\\n        if(k == mid){\\n            return \\'1\\';\\n        }else if(k < mid){\\n            return findKthBit(n - 1, k);\\n        }else{\\n            char c = findKthBit(n - 1, (mid - (k - mid)));\\n            return c == \\'1\\' ? \\'0\\' : \\'1\\';\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if(n == 1){\\n            return \\'0\\';\\n        }\\n        int total = (1 << n) - 1;\\n        int half = (total - 1) / 2;\\n        int mid = half + 1;\\n        if(k == mid){\\n            return \\'1\\';\\n        }else if(k < mid){\\n            return findKthBit(n - 1, k);\\n        }else{\\n            char c = findKthBit(n - 1, (mid - (k - mid)));\\n            return c == \\'1\\' ? \\'0\\' : \\'1\\';\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780890,
                "title": "javascript-python3-c-recursive-solutions",
                "content": "**Synopsis:**\\n\\nReturn the k-th value of the recursively generated n-th sequence.\\n\\n---\\n\\n**Screenshare:** https://www.youtube.com/watch?v=cMqzxy8npo0&feature=youtu.be\\n\\n---\\n\\n*Javascript*\\n```\\nlet findKthBit = (n, k) => {\\n    let go = i => {\\n        if (!i)\\n            return [\\'0\\'];\\n        let pre = go(i - 1);\\n        return pre.concat(\\'1\\', [...pre].map(c => c == \\'0\\' ? \\'1\\' : \\'0\\').reverse());\\n    };\\n    return go(n - 1)[k - 1];\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        def go(i):\\n            if not i:\\n                return [\\'0\\']\\n            pre = go(i - 1)\\n            return pre + [\\'1\\'] + list(map(lambda c: \\'1\\' if c == \\'0\\' else \\'0\\', pre))[::-1]\\n        return go(n - 1)[k - 1]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using fun = function<string(int)>;\\n    char findKthBit(int n, int k) {\\n        fun go = [&](int i) -> string {\\n            if (!i)\\n                return \"0\";\\n            auto pre = go(i - 1),\\n                 rev = pre;\\n            transform(rev.begin(), rev.end(), rev.begin(), [](auto c) { return c == \\'0\\' ? \\'1\\' : \\'0\\'; });\\n            return pre.append(\"1\").append({ rev.rbegin(), rev.rend() });\\n        };\\n        return go(n - 1)[k - 1];\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nlet findKthBit = (n, k) => {\\n    let go = i => {\\n        if (!i)\\n            return [\\'0\\'];\\n        let pre = go(i - 1);\\n        return pre.concat(\\'1\\', [...pre].map(c => c == \\'0\\' ? \\'1\\' : \\'0\\').reverse());\\n    };\\n    return go(n - 1)[k - 1];\\n};\\n```\n```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        def go(i):\\n            if not i:\\n                return [\\'0\\']\\n            pre = go(i - 1)\\n            return pre + [\\'1\\'] + list(map(lambda c: \\'1\\' if c == \\'0\\' else \\'0\\', pre))[::-1]\\n        return go(n - 1)[k - 1]\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<string(int)>;\\n    char findKthBit(int n, int k) {\\n        fun go = [&](int i) -> string {\\n            if (!i)\\n                return \"0\";\\n            auto pre = go(i - 1),\\n                 rev = pre;\\n            transform(rev.begin(), rev.end(), rev.begin(), [](auto c) { return c == \\'0\\' ? \\'1\\' : \\'0\\'; });\\n            return pre.append(\"1\").append({ rev.rbegin(), rev.rend() });\\n        };\\n        return go(n - 1)[k - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083312,
                "title": "100-java-binary-search-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity :o(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if(n==1)return \\'0\\';\\n\\n        int len = (int)Math.pow(2,n)-1;\\n        int mid = len/2+1;\\n\\n        if(k==mid)return \\'1\\';\\n        else if(k>mid){\\n            char c =findKthBit(n-1 , len-k+1);\\n\\n            return c==\\'0\\'?\\'1\\':\\'0\\';\\n        }\\n\\n        return findKthBit(n-1,k);\\n\\n\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public char findKthBit(int n, int k) {\\n        if(n==1)return \\'0\\';\\n\\n        int len = (int)Math.pow(2,n)-1;\\n        int mid = len/2+1;\\n\\n        if(k==mid)return \\'1\\';\\n        else if(k>mid){\\n            char c =findKthBit(n-1 , len-k+1);\\n\\n            return c==\\'0\\'?\\'1\\':\\'0\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4078177,
                "title": "beats-100-java-easy-to-understand-simple-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public char findKthBit(int n, int k) \\n    {\\n        if(n==1)return \\'0\\';\\n        int tot=(int)Math.pow(2,n)-1; \\n        k=k-1;\\n\\n        if(k==tot/2)return \\'1\\';\\n        int i=k;\\n        boolean b=true;\\n        if(k>=(tot/2 +1) && k<=(tot-1))\\n        {\\n            b=false;\\n        }   \\n\\n        if(!b)\\n        {\\n            i=tot-k-1;\\n        }\\n\\n        char prev=findKthBit(n-1,i+1);\\n        if(!b)\\n        {\\n            if(prev==\\'1\\')return \\'0\\';\\n            return \\'1\\';\\n        }\\n        return prev;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\n    public char findKthBit(int n, int k) \\n    {\\n        if(n==1)return \\'0\\';\\n        int tot=(int)Math.pow(2,n)-1; \\n        k=k-1;\\n\\n        if(k==tot/2)return \\'1\\';\\n        int i=k;\\n        boolean b=true;\\n        if(k>=(tot/2 +1) && k<=(tot-1))\\n        {\\n            b=false;\\n        }   \\n\\n        if(!b)\\n        {\\n            i=tot-k-1;\\n        }\\n\\n        char prev=findKthBit(n-1,i+1);\\n        if(!b)\\n        {\\n            if(prev==\\'1\\')return \\'0\\';\\n            return \\'1\\';\\n        }\\n        return prev;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044554,
                "title": "using-particular-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string invert(string s){\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == \\'0\\'){\\n                s[i] = \\'1\\';\\n            }\\n            else{\\n                s[i] = \\'0\\';\\n            }\\n        }\\n\\n        return s;\\n    }\\n\\n    string reversee(string s){\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        string s1 = \"0\";\\n\\n        while(n != 0){\\n            n--;\\n            string temp = \"\";           \\n            string del = invert(s1);\\n            reverse(del.begin(), del.end());\\n            temp += s1 + \"1\" + del;\\n            s1 = temp;\\n        }\\n\\n        return s1[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string invert(string s){\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == \\'0\\'){\\n                s[i] = \\'1\\';\\n            }\\n            else{\\n                s[i] = \\'0\\';\\n            }\\n        }\\n\\n        return s;\\n    }\\n\\n    string reversee(string s){\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        string s1 = \"0\";\\n\\n        while(n != 0){\\n            n--;\\n            string temp = \"\";           \\n            string del = invert(s1);\\n            reverse(del.begin(), del.end());\\n            temp += s1 + \"1\" + del;\\n            s1 = temp;\\n        }\\n\\n        return s1[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043531,
                "title": "easy-python-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code uses a recursive approach to generate a binary sequence and find the kth character in it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe findKthBit function takes two arguments: n and k.\\nInside the findKthBit function, there is a recursive helper function called helper.\\nThe helper function is used to generate the binary sequence up to the nth level.\\nIf n is 1, the base case is reached, and it returns \"0\".\\nOtherwise, it recursively calls itself to generate the binary sequence for n-1, appends \"1\" in the middle, and then appends the reversed inverted version of the binary sequence for n-1.\\n\\n# Complexity\\nTime complexity: The recursive function generates the binary sequence up to the nth level. In the worst case, it will have a time complexity of O(2^n) because each level approximately doubles the length of the sequence. Therefore, the time complexity is exponential, O(2^n).\\n\\nSpace complexity: The space complexity depends on the depth of the recursion stack. In the worst case, it will be O(2^n) due to the recursive calls, as each call adds to the stack. Additionally, there\\'s a temporary string temp that is built during the recursion, which also contributes to the space complexity. So, the space complexity is also exponential, O(2^n).\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        def helper(n, k):\\n            if n == 1:\\n                return \"0\"\\n            temp = helper(n-1, k) + \"1\" + \\'\\'.join([\\'1\\' if bit == \\'0\\' else \\'0\\' for bit in helper(n-1, k)])[::-1]\\n            return temp\\n\\n        \\n        return helper(n, k)[k-1]\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        def helper(n, k):\\n            if n == 1:\\n                return \"0\"\\n            temp = helper(n-1, k) + \"1\" + \\'\\'.join([\\'1\\' if bit == \\'0\\' else \\'0\\' for bit in helper(n-1, k)])[::-1]\\n            return temp\\n\\n        \\n        return helper(n, k)[k-1]\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035549,
                "title": "easy-to-understand-c-solution-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string i(string s)\\n    {\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                s[i]=\\'1\\';\\n            }\\n            else \\n            {\\n                s[i]=\\'0\\';\\n            }\\n        }\\n        return s;\\n    }\\n    string fun(int n)\\n    {\\n        if(n==1){\\n            return \"0\";\\n        }\\n\\n       string s= fun(n-1);\\n       string t=i(s);\\n       reverse(t.begin(),t.end());\\n\\n        return s+\"1\"+t;\\n    }\\n    char findKthBit(int n, int k) {\\n        string ans=fun(n);\\n\\n        return ans[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string i(string s)\\n    {\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                s[i]=\\'1\\';\\n            }\\n            else \\n            {\\n                s[i]=\\'0\\';\\n            }\\n        }\\n        return s;\\n    }\\n    string fun(int n)\\n    {\\n        if(n==1){\\n            return \"0\";\\n        }\\n\\n       string s= fun(n-1);\\n       string t=i(s);\\n       reverse(t.begin(),t.end());\\n\\n        return s+\"1\"+t;\\n    }\\n    char findKthBit(int n, int k) {\\n        string ans=fun(n);\\n\\n        return ans[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027584,
                "title": "java-code-easy",
                "content": "# **1.Recursive Solution**\\n\\n- The code uses a recursive approach to find the kth bit in Sn by comparing k with the midpoint of Sn, which is 2^(n-1).\\n- \\n- The base case is when n is 1, Sn is \\u201C0\\u201D and the kth bit is \\u201C0\\u201D.\\n- \\n- If k is equal to the midpoint, the kth bit is always \\u201C1\\u201D.\\n- \\n- If k is greater than the midpoint, the kth bit is the inverted version of the mirrored bit in the first half of Sn, which can be found by subtracting k from the length of Sn and passing it to the recursive call.\\n- \\n- If k is less than the midpoint, the kth bit is the same as the kth bit in Sn - 1, which can be found by passing k to the recursive call.\\n- \\n- The **time complexity** of the code is O(n), where n is the given parameter. This is because the code makes at most n recursive calls, each taking O(1) time.\\n- \\n- The **space complexity** of the code is O(n), where n is the given parameter. This is because the code uses O(n) space for the call stack and O(1) space for each call.\\n# Code\\n```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        // Base case: when n is 1, Sn is \"0\" and the kth bit is \"0\"\\n        if (n == 1) return \\'0\\';\\n        \\n        // Find the midpoint and the length of Sn\\n        int mid = (int) Math.pow(2, n - 1);\\n        int len = (int) Math.pow(2, n) - 1;\\n        \\n        // If k is equal to the midpoint, the kth bit is \"1\"\\n        if (k == mid) return \\'1\\';\\n        \\n        // If k is greater than the midpoint, find the corresponding bit in the first half\\n        // and invert it\\n        else if (k > mid) {\\n            // Subtract k from the length and pass it to the recursive call\\n            char c = findKthBit(n - 1, len - k + 1);\\n            // Invert the bit by checking if it is equal to \"0\" and returning \"1\" if true,\\n            // or \"0\" if false\\n            return (c == \\'0\\') ? \\'1\\' : \\'0\\';\\n        }\\n        \\n        // If k is less than the midpoint, return the same as the kth bit in Sn - 1\\n        else return findKthBit(n - 1, k);\\n    }\\n}\\n\\n```\\n\\n#  Dry run\\nLet\\'s dry run the code for the given inputs: \\n\\n1. **n=3 and k=7:**\\n\\n   - The base case doesn\\'t apply here since n is not 1.\\n   - Calculate the midpoint: mid = 2^(3-1) = 4.\\n   - Calculate the length of S3: len = 2^3 - 1 = 7.\\n   - k (7) is greater than mid (4), so we take the mirrored position in the first half: len - k + 1 = 7 - 7 + 1 = 1.\\n   - Now, we recursively call `findKthBit(2, 1)`.\\n\\n   - **n=2 and k=1:**\\n\\n     - The base case doesn\\'t apply.\\n     - Calculate the midpoint: mid = 2^(2-1) = 2.\\n     - Calculate the length of S2: len = 2^2 - 1 = 3.\\n     - k (1) is less than mid (2), so we return the same as the kth bit in S2 - 1, which is `findKthBit(1, 1)`.\\n\\n     - **n=1 and k=1:**\\n\\n       - Now we reach the base case where n is 1, so we return \\'0\\'.\\n\\n     - So, `findKthBit(2, 1)` returns \\'0\\'.\\n\\n   - Now, back to the previous call `findKthBit(3, 7)`. We have the result from the recursion, which is \\'0\\'.\\n   - Invert the bit since k was greater than mid, so return \\'1\\'.\\n\\n   - So, for n=3 and k=7, the result is \\'1\\'.\\n\\n2. **n=5 and k=4:**\\n\\n   - The base case doesn\\'t apply here since n is not 1.\\n   - Calculate the midpoint: mid = 2^(5-1) = 16.\\n   - Calculate the length of S5: len = 2^5 - 1 = 31.\\n   - k (4) is less than mid (16), so we return the same as the kth bit in S4, which is `findKthBit(4, 4)`.\\n\\n   - **n=4 and k=4:**\\n\\n     - The base case doesn\\'t apply here since n is not 1.\\n     - Calculate the midpoint: mid = 2^(4-1) = 8.\\n     - Calculate the length of S4: len = 2^4 - 1 = 15.\\n     - k (4) is equal to mid (8), so return \\'1\\'.\\n\\n   - So, for n=5 and k=4, the result is \\'1\\'.\\n\\nFor n=3 and k=7, the result is \\'1\\'.\\nFor n=5 and k=4, the result is \\'1\\'.\\n\\n---\\n\\n\\n\\n\\n# **2. Bitmanipulation approach**\\n\\n\\n\\n\\n1. **Base Case:** If N is 1, it represents the first sequence S1, where the only bit is \\'0\\', so we return \\'0\\' as the kth bit.\\n\\n2. **Midpoint and Length:** Calculate the midpoint and length of the current sequence Sn based on N. The midpoint represents the position where the sequence switches from \\'0\\'s to \\'1\\'s, and the length is the total number of bits in Sn.\\n\\n3. **Kth Bit at Midpoint:** If K is equal to the midpoint, return \\'1\\' since it\\'s the midpoint where the bit changes to \\'1\\'.\\n\\n4. **Kth Bit Beyond Midpoint:** If K is greater than the midpoint, find the corresponding bit in the first half of the sequence, invert it (change \\'0\\' to \\'1\\' or \\'1\\' to \\'0\\'), and return it as a character. This is done by subtracting K from the length to get the mirrored position, XORing it with \\'1\\' to invert it, and casting it back to a character.\\n\\n5. **Kth Bit Before Midpoint:** If K is less than the midpoint, return the same as the kth bit in the previous sequence Sn-1 by making a recursive call to findKthBit with N-1 and K.\\n\\n\\n\\nThe **time complexity** of this code is O(log N) because it recursively divides the problem into smaller halves by reducing N by 1 in each recursive call. The depth of the recursion is determined by the value of N.\\n\\nThe **space complexity** is O(log N) as well because of the space used by the recursive function calls on the call stack. In the worst case, the call stack can have a depth of log N, corresponding to the maximum recursion depth.\\n\\n\\n# code \\n```\\n`class Solution {\\n    public char findKthBit(int N, int K) {\\n        // Base case: when N is 1, Sn is \"0\" and the kth bit is \"0\"\\n        if (N == 1) return \\'0\\';\\n        \\n        // Find the midpoint and the length of Sn\\n        int mid = 1 << (N - 1);\\n        int len = (mid << 1) - 1;\\n        \\n        // If K is equal to the midpoint, the kth bit is \"1\"\\n        if (K == mid) return \\'1\\';\\n        \\n        // If K is greater than the midpoint, find the corresponding bit in the first half\\n        // and invert and reverse it\\n        if (K > mid) {\\n            // Subtract K from the length and cast it to a char\\n            char c = (char)(len - K + 1);\\n            // XOR the char with \\'1\\' to invert it\\n            c ^= \\'1\\';\\n            // Return the result as a char\\n            return c;\\n        }\\n        \\n        // If K is less than the midpoint, return the same as the kth bit in Sn - 1\\n        return findKthBit(N - 1, K);\\n    }\\n}\\n``\\n\\n\\n# **dry run -**\\nfindKthBit(3, 7) is called.\\n\\nSince N (3) is not equal to 1, we proceed with the code.\\n\\nMidpoint (mid) is calculated as 1 << (3 - 1) = 4.\\nLength (len) is calculated as (4 << 1) - 1 = 7.\\n\\nK (7) is equal to the midpoint (mid), so we return \\'1\\'.\\n\\nThe result for findKthBit(3, 7) is \\'1\\'.\\n\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        // Base case: when n is 1, Sn is \"0\" and the kth bit is \"0\"\\n        if (n == 1) return \\'0\\';\\n        \\n        // Find the midpoint and the length of Sn\\n        int mid = (int) Math.pow(2, n - 1);\\n        int len = (int) Math.pow(2, n) - 1;\\n        \\n        // If k is equal to the midpoint, the kth bit is \"1\"\\n        if (k == mid) return \\'1\\';\\n        \\n        // If k is greater than the midpoint, find the corresponding bit in the first half\\n        // and invert it\\n        else if (k > mid) {\\n            // Subtract k from the length and pass it to the recursive call\\n            char c = findKthBit(n - 1, len - k + 1);\\n            // Invert the bit by checking if it is equal to \"0\" and returning \"1\" if true,\\n            // or \"0\" if false\\n            return (c == \\'0\\') ? \\'1\\' : \\'0\\';\\n        }\\n        \\n        // If k is less than the midpoint, return the same as the kth bit in Sn - 1\\n        else return findKthBit(n - 1, k);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026046,
                "title": "recursive-solution-with-example",
                "content": "## Lets break down the problem through example : \\n\\n## ***(pow(2 , n ) - 1)*** in each level\\n1 -> 0  (1)\\n2 -> 0 1 1  (3)                                      \\n3 -> 0 1 1 1 0 0 1   (7) \\n4 -> 0 1 1 1 0 0 1 1 0 1  1  0  0  0  1 (15)\\nIDX: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \\n\\n## **For any level if the value of k is equal to the value of pow(n , 2) // 2 which is half then it is \"1\"**\\n\\n(n, k) can be divided into 2 possible ways where the pattern repeats itself for every consecutive \\n\\t**1) One way is (n, k) :**\\n\\texample :\\n\\t\\t(5 , 1)\\n\\t\\t(4 , 1)\\n\\t\\t(3 , 1)\\n\\t\\t(2 , 1)\\n\\t\\t(1 , 1) \\n\\t\\twe can see all are the same thus one way is to divide (n, k) --> (n -1, k) \\n\\t* when should this done?\\n\\t\\twhen the value of k is same as the above level, i.e: less than or equal to (half of the current level -1 )\\n\\t**k = (pow(n , 2) - 1 ) // 2**\\n\\t\\n    2) second way is (n , ?) :\\n\\t\\t* how to find the second value of k provided if it exceeds the value more than the previous level i.e (4 , 11) --> (3 , 11) its wrong as no 11 in level of 3 \\n\\t\\t* lets take an example of values of level 3 and level 4 :\\n\\t\\t\\t\\n\\t\\t\\t1 -> 0 |  15 -> 1 ( ~ of value in 1 )\\n\\t\\t\\t2 -> 1 |  14 -> 0 ( ~ of value in 2 )\\n\\t\\t\\t3 -> 1 |  13 -> 0 ( ~ of value in 3 )\\n\\t\\t\\t4 -> 1 |  12 -> 0 ( ~ of value in 4 )\\n\\t\\t\\t5 -> 0 |  11 -> 1 ( ~ of value in 5 )\\n\\t\\t\\t6 -> 0 |  10 -> 1 ( ~ of value in 6 )\\n\\t\\t\\t7 -> 1 |  9  -> 0 ( ~ of value in 7 ) \\n\\n\\t\\t* value of (4 , 11) is similar to ((3 , 5) ^ 1 ) i.e :\\n\\t\\t\\t (4 , 11) == 1 and \\n\\t\\t\\t ((3 , 5) == 0) ^ 1 == 1 \\n\\t\\t\\twhich are equal \\n\\t\\t* think about this and draw a conclusion of how to convert higher level value of k to lower level by above example \\n\\n# Code\\n```\\nclass Solution:\\n    def solve(self , n , k) :\\n        if n == 1 and k == 1 :\\n            return 0 \\n        if k == (1 << n) // 2 :\\n            return 1\\n        t = ((1 << n )  - 1) // 2 \\n        if k <= t :\\n            return self.solve(n - 1, k) \\n        return self.solve(n - 1 , (1 << n) - k) ^ 1 \\n        \\n    def findKthBit(self, n: int, k: int) -> str:\\n        return str(self.solve(n , k))\\n        \\n\\n        \\n \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self , n , k) :\\n        if n == 1 and k == 1 :\\n            return 0 \\n        if k == (1 << n) // 2 :\\n            return 1\\n        t = ((1 << n )  - 1) // 2 \\n        if k <= t :\\n            return self.solve(n - 1, k) \\n        return self.solve(n - 1 , (1 << n) - k) ^ 1 \\n        \\n    def findKthBit(self, n: int, k: int) -> str:\\n        return str(self.solve(n , k))\\n        \\n\\n        \\n \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020708,
                "title": "easy-for-beginners-simple-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstring re(string s){\\n    for(int i=0;i<s.length();i++){\\n        if(s[i]==\\'1\\') s[i]=\\'0\\';\\n        else s[i]=\\'1\\';\\n    }\\n    reverse(s.begin(),s.end());\\n    return s;\\n}\\nstring fun(int n){\\n    if(n==1){\\n        return \"0\";\\n    }\\n    string sk=fun(n-1);\\n    return fun(n-1)+\"1\"+re(sk);\\n}\\n    char findKthBit(int n, int k) {\\n        string st=fun(n);\\n        cout<<st;\\n        return st[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstring re(string s){\\n    for(int i=0;i<s.length();i++){\\n        if(s[i]==\\'1\\') s[i]=\\'0\\';\\n        else s[i]=\\'1\\';\\n    }\\n    reverse(s.begin(),s.end());\\n    return s;\\n}\\nstring fun(int n){\\n    if(n==1){\\n        return \"0\";\\n    }\\n    string sk=fun(n-1);\\n    return fun(n-1)+\"1\"+re(sk);\\n}\\n    char findKthBit(int n, int k) {\\n        string st=fun(n);\\n        cout<<st;\\n        return st[k-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4018069,
                "title": "java-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static char func(String p,int n,int target){\\n        if(n==0){\\n            return p.charAt(target-1);\\n        }\\n        String u=p.replace(\\'0\\',\\'2\\').replace(\\'1\\',\\'0\\').replace(\\'2\\',\\'1\\');\\n        StringBuilder up=new StringBuilder(u);\\n        up.reverse();\\n        return func(p+\"1\"+up,n-1,target);\\n    }\\n    public char findKthBit(int n, int k) {\\n        return func(\"0\",n-1,k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    static char func(String p,int n,int target){\\n        if(n==0){\\n            return p.charAt(target-1);\\n        }\\n        String u=p.replace(\\'0\\',\\'2\\').replace(\\'1\\',\\'0\\').replace(\\'2\\',\\'1\\');\\n        StringBuilder up=new StringBuilder(u);\\n        up.reverse();\\n        return func(p+\"1\"+up,n-1,target);\\n    }\\n    public char findKthBit(int n, int k) {\\n        return func(\"0\",n-1,k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010647,
                "title": "easy-c-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        if(n == 1)\\n            return \\'0\\';\\n\\n        int mid = pow(2, n-1);\\n        if(k < mid)\\n            return findKthBit(n-1, k);\\n\\n        else if(k == mid)\\n            return \\'1\\';\\n        \\n        else{\\n            if(findKthBit(n-1, (2 * mid) - k) == \\'1\\')\\n                return \\'0\\';\\n            else\\n                return \\'1\\';\\n        }\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/b751a99a-c298-44d0-9504-9f50175583a5_1694017747.7871609.png)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        if(n == 1)\\n            return \\'0\\';\\n\\n        int mid = pow(2, n-1);\\n        if(k < mid)\\n            return findKthBit(n-1, k);\\n\\n        else if(k == mid)\\n            return \\'1\\';\\n        \\n        else{\\n            if(findKthBit(n-1, (2 * mid) - k) == \\'1\\')\\n                return \\'0\\';\\n            else\\n                return \\'1\\';\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002541,
                "title": "java-0ms-easy-to-understand-with-comments-o-n",
                "content": "# Intuition\\nTotal # of characters present in string is dependent on n which is (2^n)-1 .\\nAll characters in Sn can be divided into two parts . \\n1. Those before its mid point , i.e before 2^n/2, are exactly same to Sn-1  .\\n2. Those after mid point are reverse of invert of Sn-1.\\n\\nIt forms a recursion .\\nFor 1st , character at kth pos in Sn = char.At( kth pos in Sn-1 )\\nFor 2nd , char.At( kth pos in Sn ) = invert of char.At( (2^n)-k th pos in Sn-1 ).\\nWhy (2^n)-k ? \\nBecause we reverse Sn-1 . So gth pos in Sn , where g> mid index in Sn , is (2^n)-g th pos in Sn-1.\\nFew corner cases -\\nWhen k==1 , its always \\'0\\'\\nWhne k is mid point , its always \\'1\\'.\\n# Approach\\nWe first find the lowest n required to cover k characters . It can be lesser than n . Max n steps .\\nMax 20 steps in recursion . log(2^n)\\n\\n# Complexity\\n- Time complexity:\\nn+O(log(2^n)) ~ n\\n\\n- Space complexity:\\nO(1)\\n\\nIf having doubts , feel free to comment .\\n\\n# Code\\n```\\nclass Solution {\\n    char inv(char ch){\\n        return (ch==\\'1\\')?\\'0\\':\\'1\\';\\n    }\\n    char rec(int k,int n){\\n        if(k<((int)Math.pow(2,n)/2)){\\n            return rec(k,n-1);\\n        }\\n        if(k==1){\\n            return \\'0\\';\\n        }\\n        if(n>1 && (int)Math.pow(2,n)/2==k){\\n            return \\'1\\';\\n        }\\n        return inv(rec((int)Math.pow(2,n)-k,n-1));\\n\\n    }\\n    public char findKthBit(int n, int k) {\\n        if(k==1){\\n            return \\'0\\';\\n        }\\n        int l=1,v=2;\\n        while(v<=k){\\n            l++;\\n            v*=2;\\n        }\\n        return rec(k,l);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    char inv(char ch){\\n        return (ch==\\'1\\')?\\'0\\':\\'1\\';\\n    }\\n    char rec(int k,int n){\\n        if(k<((int)Math.pow(2,n)/2)){\\n            return rec(k,n-1);\\n        }\\n        if(k==1){\\n            return \\'0\\';\\n        }\\n        if(n>1 && (int)Math.pow(2,n)/2==k){\\n            return \\'1\\';\\n        }\\n        return inv(rec((int)Math.pow(2,n)-k,n-1));\\n\\n    }\\n    public char findKthBit(int n, int k) {\\n        if(k==1){\\n            return \\'0\\';\\n        }\\n        int l=1,v=2;\\n        while(v<=k){\\n            l++;\\n            v*=2;\\n        }\\n        return rec(k,l);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980843,
                "title": "cpp-simple-solution-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        vector<pair<string,string>>str;\\n        str.push_back({\"0\",\"1\"});\\n        for(int i=1;i<n;i++){\\n            str.push_back({str[i-1].first+\"1\"+str[i-1].second,str[i-1].first+\"0\"+str[i-1].second});\\n        }\\n        return str[n-1].first[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        vector<pair<string,string>>str;\\n        str.push_back({\"0\",\"1\"});\\n        for(int i=1;i<n;i++){\\n            str.push_back({str[i-1].first+\"1\"+str[i-1].second,str[i-1].first+\"0\"+str[i-1].second});\\n        }\\n        return str[n-1].first[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964409,
                "title": "recursion-optimize-n",
                "content": "# Approach\\nInstead of n I use the smallest n value that contains k (log2(k) + 1). The n parameter is ignored. This reduces the number of recursive calls when k is small.\\n\\n# Complexity\\n- Time complexity:\\n$$O(logk)$$ <= $$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if (k == 1) return \\'0\\';\\n        // reduce n to the smallest n that contains k. log2(k)+1\\n        int result = findK((int)Math.floor(Math.log(k)/Math.log(2))+1, k);\\n        return result == 1 ? \\'1\\' : \\'0\\';\\n    }\\n\\n    private int findK(int n, int k) {\\n        if (n == 1) return 0;\\n\\n        int mid = 1 << n-1; \\n        if (k == mid) return 1;\\n\\n        if (k < mid) {\\n            return findK(n-1, k);\\n        } else {\\n            return 1 ^ findK(n-1, 2 * mid - k);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if (k == 1) return \\'0\\';\\n        // reduce n to the smallest n that contains k. log2(k)+1\\n        int result = findK((int)Math.floor(Math.log(k)/Math.log(2))+1, k);\\n        return result == 1 ? \\'1\\' : \\'0\\';\\n    }\\n\\n    private int findK(int n, int k) {\\n        if (n == 1) return 0;\\n\\n        int mid = 1 << n-1; \\n        if (k == mid) return 1;\\n\\n        if (k < mid) {\\n            return findK(n-1, k);\\n        } else {\\n            return 1 ^ findK(n-1, 2 * mid - k);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956189,
                "title": "go-lang-solution-beats-100-recursion",
                "content": "# Code\\n```\\nfunc findKthBit(n int, k int) byte {\\n    return findKth(k)[0]\\n}\\n\\nfunc findKth(k int) string {\\n    if k == 1 {\\n        return \"0\"\\n    }\\n\\n    curr := 1\\n\\n    for k > curr {\\n        if k == curr + 1 {\\n            return \"1\"\\n        }\\n\\n        curr += 1 + curr\\n    }\\n\\n    if k == curr {\\n        return reverse(findKth(1))\\n    } else {\\n        return reverse(findKth(curr - k + 1))\\n    }\\n}\\n\\nfunc reverse(s string) string {\\n    if s == \"0\" {\\n        return \"1\"\\n    } else {\\n        return \"0\"\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc findKthBit(n int, k int) byte {\\n    return findKth(k)[0]\\n}\\n\\nfunc findKth(k int) string {\\n    if k == 1 {\\n        return \"0\"\\n    }\\n\\n    curr := 1\\n\\n    for k > curr {\\n        if k == curr + 1 {\\n            return \"1\"\\n        }\\n\\n        curr += 1 + curr\\n    }\\n\\n    if k == curr {\\n        return reverse(findKth(1))\\n    } else {\\n        return reverse(findKth(curr - k + 1))\\n    }\\n}\\n\\nfunc reverse(s string) string {\\n    if s == \"0\" {\\n        return \"1\"\\n    } else {\\n        return \"0\"\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3945768,
                "title": "cpp-easy-implementation-brute-force-code-short-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string revers(string r){\\n        reverse(r.begin(),r.end());\\n        return r;\\n    }\\n    string invert(string s){\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\')s[i]=\\'0\\';\\n            else s[i]=\\'1\\';\\n        }\\n        return s;\\n    }\\n    char findKthBit(int n, int k) {\\n        string ans=\"0\";\\n        for(int i=0;i<n;i++){\\n            string temp1=invert(ans);\\n            temp1=revers(temp1);\\n            ans=ans+\"1\"+temp1;\\n        }\\n        return ans[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string revers(string r){\\n        reverse(r.begin(),r.end());\\n        return r;\\n    }\\n    string invert(string s){\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\')s[i]=\\'0\\';\\n            else s[i]=\\'1\\';\\n        }\\n        return s;\\n    }\\n    char findKthBit(int n, int k) {\\n        string ans=\"0\";\\n        for(int i=0;i<n;i++){\\n            string temp1=invert(ans);\\n            temp1=revers(temp1);\\n            ans=ans+\"1\"+temp1;\\n        }\\n        return ans[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929944,
                "title": "easy-to-understand-javascript-solution-recursion",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar findKthBit = function(n, k) {\\n    if (n == 1) return \\'0\\';\\n    const size = (1 << n) - 1;\\n\\n    if (k === (size + 1) / 2) return \\'1\\';\\n    if (k > (size + 1) / 2) {\\n        return findKthBit(n - 1, size - k + 1) === \\'0\\' ? \\'1\\' : \\'0\\';\\n    } else {\\n        return findKthBit(n - 1, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findKthBit = function(n, k) {\\n    if (n == 1) return \\'0\\';\\n    const size = (1 << n) - 1;\\n\\n    if (k === (size + 1) / 2) return \\'1\\';\\n    if (k > (size + 1) / 2) {\\n        return findKthBit(n - 1, size - k + 1) === \\'0\\' ? \\'1\\' : \\'0\\';\\n    } else {\\n        return findKthBit(n - 1, k);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3912995,
                "title": "javascript-1545-find-kth-bit-in-nth-binary-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nDo exactly as question says\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n**1 Using string - 2.5 seconds**\\n\\n```\\nvar findKthBit = function (n, k) {\\n  function reverse(s) {\\n    return s.split(\\'\\').reverse().join(\\'\\')\\n  }\\n\\n  function invert(s) {\\n    let ns = \\'\\'\\n    for (let ch of s) {\\n      ns += ch === \\'0\\'\\n        ? \\'1\\'\\n        : \\'0\\'\\n    }\\n    return ns\\n  }\\n\\n  let s = \\'0\\'\\n  while (n--) {\\n    let ns = s + \\'1\\' + reverse(invert(s))\\n    s = ns\\n  }\\n  return s[k - 1]\\n}\\n```\\n\\n\\n**2 Using array - 400 milli seconds**\\n\\n```\\nvar findKthBit = function (n, k) {\\n  function reverse(a) {\\n    return a.reverse()\\n  }\\n\\n  function invert(a) {\\n    let na = []\\n    for (let ch of a) {\\n      na.push(ch === \\'0\\'\\n        ? \\'1\\'\\n        : \\'0\\')\\n    }\\n    return na\\n  }\\n\\n  let a = [\\'0\\']\\n  for (let i = 1; i < n; i++) {\\n    let na = []\\n    na.push(...a)\\n    na.push(\\'1\\')\\n    na.push(...reverse(invert(a)))\\n    a = na\\n  }\\n  return a[k - 1]\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findKthBit = function (n, k) {\\n  function reverse(s) {\\n    return s.split(\\'\\').reverse().join(\\'\\')\\n  }\\n\\n  function invert(s) {\\n    let ns = \\'\\'\\n    for (let ch of s) {\\n      ns += ch === \\'0\\'\\n        ? \\'1\\'\\n        : \\'0\\'\\n    }\\n    return ns\\n  }\\n\\n  let s = \\'0\\'\\n  while (n--) {\\n    let ns = s + \\'1\\' + reverse(invert(s))\\n    s = ns\\n  }\\n  return s[k - 1]\\n}\\n```\n```\\nvar findKthBit = function (n, k) {\\n  function reverse(a) {\\n    return a.reverse()\\n  }\\n\\n  function invert(a) {\\n    let na = []\\n    for (let ch of a) {\\n      na.push(ch === \\'0\\'\\n        ? \\'1\\'\\n        : \\'0\\')\\n    }\\n    return na\\n  }\\n\\n  let a = [\\'0\\']\\n  for (let i = 1; i < n; i++) {\\n    let na = []\\n    na.push(...a)\\n    na.push(\\'1\\')\\n    na.push(...reverse(invert(a)))\\n    a = na\\n  }\\n  return a[k - 1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3911388,
                "title": "my-c-solution-brute-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstring rev(string x){\\n    reverse(x.begin(),x.end());\\n    return x;\\n}\\nstring inv(string x){\\n    for(int i=0;i<x.size();i++){\\n        if(x[i]==\\'0\\'){\\n            x[i]=\\'1\\';\\n        }\\n        else{\\n            x[i]=\\'0\\';\\n        }\\n    }\\n    return x;\\n}\\n    char findKthBit(int n, int k) {\\n        char ans;\\n        vector<string>res(n);\\n        res[0]=\"0\";\\n        for(int i=1;i<n;i++){\\nres[i]=res[i-1]+\"1\"+rev(inv(res[i-1]));\\n\\n        }\\n        string r=res[n-1];\\n        for(int i=0;i<r.size();i++){\\n            if(i==k-1){\\n                ans=r[i];\\n            }\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstring rev(string x){\\n    reverse(x.begin(),x.end());\\n    return x;\\n}\\nstring inv(string x){\\n    for(int i=0;i<x.size();i++){\\n        if(x[i]==\\'0\\'){\\n            x[i]=\\'1\\';\\n        }\\n        else{\\n            x[i]=\\'0\\';\\n        }\\n    }\\n    return x;\\n}\\n    char findKthBit(int n, int k) {\\n        char ans;\\n        vector<string>res(n);\\n        res[0]=\"0\";\\n        for(int i=1;i<n;i++){\\nres[i]=res[i-1]+\"1\"+rev(inv(res[i-1]));\\n\\n        }\\n        string r=res[n-1];\\n        for(int i=0;i<r.size();i++){\\n            if(i==k-1){\\n                ans=r[i];\\n            }\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890662,
                "title": "beats-100-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public char findKthBit(int n, int k) {\\n        return helper(n, k);\\n    }\\n    \\n    private char helper(int n, int k) {\\n        if (n == 1) {\\n            return \\'0\\';\\n        }\\n        \\n        int length = (1 << n) - 1; // Total length of the string for depth n\\n        int mid = length / 2 + 1; // Middle position\\n        \\n        if (k == mid) {\\n            return \\'1\\';\\n        } else if (k < mid) {\\n            return helper(n - 1, k);\\n        } else {\\n            char oppositeBit = helper(n - 1, length - k + 1);\\n            return oppositeBit == \\'0\\' ? \\'1\\' : \\'0\\';\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public char findKthBit(int n, int k) {\\n        return helper(n, k);\\n    }\\n    \\n    private char helper(int n, int k) {\\n        if (n == 1) {\\n            return \\'0\\';\\n        }\\n        \\n        int length = (1 << n) - 1; // Total length of the string for depth n\\n        int mid = length / 2 + 1; // Middle position\\n        \\n        if (k == mid) {\\n            return \\'1\\';\\n        } else if (k < mid) {\\n            return helper(n - 1, k);\\n        } else {\\n            char oppositeBit = helper(n - 1, length - k + 1);\\n            return oppositeBit == \\'0\\' ? \\'1\\' : \\'0\\';\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884685,
                "title": "efficient-solution-in-python3-also-using-bit-manipulation-with-xor-and-for-speedup",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor a given n, the string `s` has 2**n - 1 binary digits. Of these, the first element is always \\'0\\' and the middle element is always \\'1\\'.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst iteration:\\nConstruct an integer `mid` to denote index of the middle element of the string.\\nIf `k == mid`, return \\'1\\'.\\n\\nIf `k < mid`, focus on finding the k-th element in the first half of the string.\\n\\nIf `k > mid`, look at the complement of element (2*mid - k) in the first half of string s. In the code, `invert_flag = 1` implies a complement.\\n\\nSubsequent iterations:\\nRepeat above steps, cutting down the length of the binary string by half in each successive iteration.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNo. of iterations ~ log_2 (2**n - 1) ~ n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        # Map k to indices in binary string s.\\n        k = k-1\\n        if k==0:\\n            return \\'0\\'\\n        # A string at stage n contains (2**n -1) binary digits.\\n        invert_flag = 0\\n        length = (1 << (n+1)) - 1\\n        while length > 1:\\n            mid = length // 2 # Index of the middle element\\n            if k==mid:\\n                # The middle element is always 1.\\n                return \\'1\\' if invert_flag==0 else \\'0\\'\\n            elif k < mid:\\n                # Focus on returning the k-th element of the first half of string s.\\n                length = mid\\n            else:\\n                # k-th element in back half of string s = \\n                # Complement of element (2*mid - k) in first half of string s\\n                k = 2*mid - k\\n                length = mid\\n                # Flip invert flag.\\n                invert_flag ^= 1\\n        if invert_flag:\\n            return \\'1\\'\\n        else:\\n            return \\'0\\'    \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n        # Map k to indices in binary string s.\\n        k = k-1\\n        if k==0:\\n            return \\'0\\'\\n        # A string at stage n contains (2**n -1) binary digits.\\n        invert_flag = 0\\n        length = (1 << (n+1)) - 1\\n        while length > 1:\\n            mid = length // 2 # Index of the middle element\\n            if k==mid:\\n                # The middle element is always 1.\\n                return \\'1\\' if invert_flag==0 else \\'0\\'\\n            elif k < mid:\\n                # Focus on returning the k-th element of the first half of string s.\\n                length = mid\\n            else:\\n                # k-th element in back half of string s = \\n                # Complement of element (2*mid - k) in first half of string s\\n                k = 2*mid - k\\n                length = mid\\n                # Flip invert flag.\\n                invert_flag ^= 1\\n        if invert_flag:\\n            return \\'1\\'\\n        else:\\n            return \\'0\\'    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883616,
                "title": "java-brute-force-solution",
                "content": "# Intuition\\nDo the concatination for each string from 1 to n.\\nReturn the kth element from nth string.\\n\\n# Approach\\nCreate an invert method which will invert the Si string.\\nDefine s string as s1 = \"0\".\\nRun a loop from 1 to n. For each iteration call the invert method on si string.\\nUpdate the s string by concatinating the strings as told.\\nAt the end we have the final string sn.\\nReturn the kth element from the sn string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        \\n        String s = \"0\";\\n\\n        for(int i=1; i<n; i++){\\n            StringBuffer invertedString = invert(s);\\n            s = s + \"1\" + invertedString.reverse();\\n        }\\n\\n        return s.charAt(k-1);\\n    }\\n\\n    public static StringBuffer invert(String str){\\n        StringBuffer tempInverted = new StringBuffer();\\n        for(int i=0; i<str.length(); i++){\\n            if(str.charAt(i)==\\'0\\'){\\n                tempInverted.append(\"1\");\\n            } else{\\n                tempInverted.append(\"0\");\\n            }\\n        }\\n        return tempInverted;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        \\n        String s = \"0\";\\n\\n        for(int i=1; i<n; i++){\\n            StringBuffer invertedString = invert(s);\\n            s = s + \"1\" + invertedString.reverse();\\n        }\\n\\n        return s.charAt(k-1);\\n    }\\n\\n    public static StringBuffer invert(String str){\\n        StringBuffer tempInverted = new StringBuffer();\\n        for(int i=0; i<str.length(); i++){\\n            if(str.charAt(i)==\\'0\\'){\\n                tempInverted.append(\"1\");\\n            } else{\\n                tempInverted.append(\"0\");\\n            }\\n        }\\n        return tempInverted;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881685,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string invert(string s) {\\n        for(int i=0;i<s.length();i++) {\\n            if(s[i] == \\'0\\') {\\n                s[i] = \\'1\\';\\n            }\\n            else {\\n                s[i] = \\'0\\';\\n            }\\n        }\\n\\n        return s;\\n    }\\n    char findKthBit(int n, int k) {\\n        vector<string> s;\\n        s.push_back(\"0\");\\n\\n        for(int i=1;i<n;i++) {\\n            string inverted = invert(s[i-1]);\\n            reverse(inverted.begin(), inverted.end());\\n            string temp = s[i-1] + \"1\" + inverted;\\n            s.push_back(temp);\\n        }\\n\\n        return s[n-1][k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string invert(string s) {\\n        for(int i=0;i<s.length();i++) {\\n            if(s[i] == \\'0\\') {\\n                s[i] = \\'1\\';\\n            }\\n            else {\\n                s[i] = \\'0\\';\\n            }\\n        }\\n\\n        return s;\\n    }\\n    char findKthBit(int n, int k) {\\n        vector<string> s;\\n        s.push_back(\"0\");\\n\\n        for(int i=1;i<n;i++) {\\n            string inverted = invert(s[i-1]);\\n            reverse(inverted.begin(), inverted.end());\\n            string temp = s[i-1] + \"1\" + inverted;\\n            s.push_back(temp);\\n        }\\n\\n        return s[n-1][k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866275,
                "title": "most-easy-approach-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string invert(string str){\\n        string k=\"\";\\n        for(int i=0;i<str.size();i++){\\n            if(str[i]==\\'1\\'){\\n                k+=\\'0\\';\\n            }\\n            else{\\n                k+=\\'1\\';\\n            }\\n        }\\n        return k;\\n    }\\n    void solve(string &str,int n,int k,int x){\\n        if(n==k){\\n            return;\\n        }\\n        if(x>=k){\\n            cout<<str;\\n            return;\\n        }\\n        string s1=invert(str);\\n        reverse(s1.begin(),s1.end());\\n        str=((str+\\'1\\')+s1);\\n        x=str.size();\\n        solve(str,n+1,k,x);\\n    }\\n    char findKthBit(int n, int k) {\\n        if(k==1){\\n            return \\'0\\';\\n        }\\n        string str=\"\";\\n        str+=\\'0\\';\\n        int x=str.size();\\n        solve(str,1,k,x);\\n        return str[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string invert(string str){\\n        string k=\"\";\\n        for(int i=0;i<str.size();i++){\\n            if(str[i]==\\'1\\'){\\n                k+=\\'0\\';\\n            }\\n            else{\\n                k+=\\'1\\';\\n            }\\n        }\\n        return k;\\n    }\\n    void solve(string &str,int n,int k,int x){\\n        if(n==k){\\n            return;\\n        }\\n        if(x>=k){\\n            cout<<str;\\n            return;\\n        }\\n        string s1=invert(str);\\n        reverse(s1.begin(),s1.end());\\n        str=((str+\\'1\\')+s1);\\n        x=str.size();\\n        solve(str,n+1,k,x);\\n    }\\n    char findKthBit(int n, int k) {\\n        if(k==1){\\n            return \\'0\\';\\n        }\\n        string str=\"\";\\n        str+=\\'0\\';\\n        int x=str.size();\\n        solve(str,1,k,x);\\n        return str[k-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3863872,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static char helper(int n,int k){\\n        if(n==1) return \\'0\\';\\n\\n        int len = (int)Math.pow(2,n)-1;\\n        int mid = len/2;\\n\\n        if(k<=mid) return helper(n-1,k);\\n        else if(k==mid+1) return \\'1\\';\\n        else{\\n            k = len-k+1;\\n            char ch = helper(n-1,k);\\n            if(ch==\\'1\\') return \\'0\\';\\n            else return \\'1\\';\\n        }\\n    }\\n\\n    public char findKthBit(int n, int k) {\\n\\n        return helper(n,k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static char helper(int n,int k){\\n        if(n==1) return \\'0\\';\\n\\n        int len = (int)Math.pow(2,n)-1;\\n        int mid = len/2;\\n\\n        if(k<=mid) return helper(n-1,k);\\n        else if(k==mid+1) return \\'1\\';\\n        else{\\n            k = len-k+1;\\n            char ch = helper(n-1,k);\\n            if(ch==\\'1\\') return \\'0\\';\\n            else return \\'1\\';\\n        }\\n    }\\n\\n    public char findKthBit(int n, int k) {\\n\\n        return helper(n,k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857042,
                "title": "2-solution-c-recursion-n-2-o-n",
                "content": "```\\nclass Solution { // O(N^2)\\npublic:\\n    string reverse_invert(string & string_to_rev_inv){ // reversing & inverting \\n        string st;\\n        for(auto it : string_to_rev_inv){ // inverting \\n            if(it==\\'0\\'){\\n                st+=\\'1\\';\\n            }\\n            else{\\n                st+=\\'0\\';\\n            }\\n        }\\n        reverse(st.begin(),st.end()); // reversing \\n        return st;\\n    }\\n    string genrate_st(int n){\\n        if(n==1){ // base case\\n            return \"0\";\\n        }\\n        else{\\n            string prev_string =genrate_st(n-1);  // this giving us the prev result like S2=011 it give us of S1=0\\n            return prev_string +\"1\"+reverse_invert(prev_string); // just folloeing the question instruction\\n        }\\n    }\\n    char findKthBit(int n, int k) {\\n        string s=genrate_st(n);\\n        return s[k-1]; // returning answer\\n    }\\n};\\n\\n\\n// O(N) -> optimise version\\nclass Solution {\\npublic:\\n    string reverse_invert(const string& string_to_rev_inv) {\\n        string st;\\n        for (char it : string_to_rev_inv) {\\n            if (it == \\'0\\') {\\n                st += \\'1\\';\\n            } else {\\n                st += \\'0\\';\\n            }\\n        }\\n        reverse(st.begin(), st.end());\\n        return st;\\n    }\\n\\n    char findKthBit(int n, int k) {\\n        string s = \"0\";\\n        for (int i = 2; i <= n; i++) {\\n            s = s + \"1\" + reverse_invert(s); // here we already have for S1=1 adding 1 acc to instruction and reverse &* invert\\n        }\\n        return s[k - 1];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution { // O(N^2)\\npublic:\\n    string reverse_invert(string & string_to_rev_inv){ // reversing & inverting \\n        string st;\\n        for(auto it : string_to_rev_inv){ // inverting \\n            if(it==\\'0\\'){\\n                st+=\\'1\\';\\n            }\\n            else{\\n                st+=\\'0\\';\\n            }\\n        }\\n        reverse(st.begin(),st.end()); // reversing \\n        return st;\\n    }\\n    string genrate_st(int n){\\n        if(n==1){ // base case\\n            return \"0\";\\n        }\\n        else{\\n            string prev_string =genrate_st(n-1);  // this giving us the prev result like S2=011 it give us of S1=0\\n            return prev_string +\"1\"+reverse_invert(prev_string); // just folloeing the question instruction\\n        }\\n    }\\n    char findKthBit(int n, int k) {\\n        string s=genrate_st(n);\\n        return s[k-1]; // returning answer\\n    }\\n};\\n\\n\\n// O(N) -> optimise version\\nclass Solution {\\npublic:\\n    string reverse_invert(const string& string_to_rev_inv) {\\n        string st;\\n        for (char it : string_to_rev_inv) {\\n            if (it == \\'0\\') {\\n                st += \\'1\\';\\n            } else {\\n                st += \\'0\\';\\n            }\\n        }\\n        reverse(st.begin(), st.end());\\n        return st;\\n    }\\n\\n    char findKthBit(int n, int k) {\\n        string s = \"0\";\\n        for (int i = 2; i <= n; i++) {\\n            s = s + \"1\" + reverse_invert(s); // here we already have for S1=1 adding 1 acc to instruction and reverse &* invert\\n        }\\n        return s[k - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854824,
                "title": "c-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void revToggle(string &t){\\n        for(int i=0; i < t.size(); i++){\\n            if(t[i] == \\'0\\'){\\n                t[i] = \\'1\\';\\n            }\\n            else{\\n                t[i] = \\'0\\';\\n            }\\n        }\\n\\n        reverse(t.begin(),t.end());\\n    }\\n    char findKthBit(int n, int k) {\\n        string s = \"0\";\\n        string t = \"0\";\\n        for(int i=2; i<=n; i++){\\n            s = s + \"1\";\\n            revToggle(t);\\n            s = s + t;\\n            t = s;\\n        }\\n\\n       return s[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void revToggle(string &t){\\n        for(int i=0; i < t.size(); i++){\\n            if(t[i] == \\'0\\'){\\n                t[i] = \\'1\\';\\n            }\\n            else{\\n                t[i] = \\'0\\';\\n            }\\n        }\\n\\n        reverse(t.begin(),t.end());\\n    }\\n    char findKthBit(int n, int k) {\\n        string s = \"0\";\\n        string t = \"0\";\\n        for(int i=2; i<=n; i++){\\n            s = s + \"1\";\\n            revToggle(t);\\n            s = s + t;\\n            t = s;\\n        }\\n\\n       return s[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853491,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    String s=\"0\";\\n    void chk(int n,int i){\\n        if(n==i)\\n        return;\\n        String t=s.replace(\\'0\\', \\'2\\').replace(\\'1\\', \\'0\\').replace(\\'2\\', \\'1\\');\\n        \\n        StringBuilder sb=new StringBuilder(t);\\n        sb=sb.reverse();\\n        String te=sb.toString();\\n        s+=\"1\"+te;\\n        chk(n,i+1);\\n    }\\n    public char findKthBit(int n, int k) {\\n        chk(n,1);\\n        return s.charAt(k-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    String s=\"0\";\\n    void chk(int n,int i){\\n        if(n==i)\\n        return;\\n        String t=s.replace(\\'0\\', \\'2\\').replace(\\'1\\', \\'0\\').replace(\\'2\\', \\'1\\');\\n        \\n        StringBuilder sb=new StringBuilder(t);\\n        sb=sb.reverse();\\n        String te=sb.toString();\\n        s+=\"1\"+te;\\n        chk(n,i+1);\\n    }\\n    public char findKthBit(int n, int k) {\\n        chk(n,1);\\n        return s.charAt(k-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844621,
                "title": "beginner-friendly-o-n-2-solution",
                "content": "The provided code aims to find the k-th bit in a binary string generated using a specific pattern. The approach involves generating the binary sequence iteratively by inverting and reversing the previous sequences to create the next sequence.\\n\\n## Intuition\\nTo find the k-th bit, the code constructs the binary sequences step by step. It starts with \"0\" and then, for each new sequence, inverts and reverses the previous sequence before appending \"1\" to it.\\n\\n## Approach\\n1. Initialize the `sequence` string with \"0\" (as the first sequence always starts with \"0\").\\n2. Iterate from 2 to n (inclusive) to generate the next n-1 sequences:\\n   a. Create a copy of the current `sequence` called `previous`.\\n   b. Invert the bits in the `previous` string in-place.\\n   c. Reverse the `previous` string in-place.\\n   d. Append \"1\" to the end of the `sequence`.\\n   e. Append the `previous` string to the end of the `sequence`.\\n3. Finally, return the k-th character in the `sequence` (index k-1 as C++ is zero-based).\\n\\n## Complexity Analysis\\n- Time complexity: The time complexity of generating the entire sequence is O(n^2) due to inverting and reversing the string in each step. Additionally, accessing the k-th bit in the `sequence` takes O(1) time. So, the overall time complexity is O(n^2 + 1), which can be simplified to O(n^2).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void invert(string &previous)\\n    {\\n        int left = 0;\\n        int right = previous.length() - 1;\\n\\n        while (left < right)\\n        {\\n            // Flip the bits (assuming the input string contains only \\'0\\' and \\'1\\')\\n            previous[left] = \\'0\\' + (\\'1\\' - previous[left]);\\n            previous[right] = \\'0\\' + (\\'1\\' - previous[right]);\\n            left++;\\n            right--;\\n        }\\n\\n        // In case of an odd-length string, flip the middle character if necessary\\n        if (left == right)\\n        {\\n            previous[left] = \\'0\\' + (\\'1\\' - previous[left]);\\n        }\\n    }\\n    void reverse(string &rev)\\n    {\\n        int start = 0, end = rev.size() - 1;\\n        while (start <= end)\\n        {\\n            swap(rev[start], rev[end]);\\n            start++, end--;\\n        }\\n    }\\n    char findKthBit(int n, int k) {\\n         // How should I generate the first n sequence?\\n        char first = \\'0\\'; //Chosing first charachter (S1 = 0) as \\'0\\n        string sequence = \"\"; //This will store the final string for returning the Kth bit\\n        sequence.push_back(first); //pushing the first bit into sequence as all starts with it\\n        //loop from i = 2 because we already have first sequence above\\n        for (int i = 2; i <= n; i++)\\n        {   \\n            //Maintain a previous string to make sure you have a previously generated string which we will use to invert and reverse\\n            string previous = sequence;\\n\\n            //Invert previous string (using reference, in-place)\\n            invert(previous);\\n\\n            //Reverse inverted-previous string (using reference, in-place)\\n            reverse(previous);\\n\\n            //pushing the \\'1\\' into string as asked in question\\n            sequence.push_back(\\'1\\');\\n\\n            //This gives sequence by adding reverse(invert()) string;\\n            sequence += previous;\\n        }\\n        //return Kth-1 char\\n        return sequence[k - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void invert(string &previous)\\n    {\\n        int left = 0;\\n        int right = previous.length() - 1;\\n\\n        while (left < right)\\n        {\\n            // Flip the bits (assuming the input string contains only \\'0\\' and \\'1\\')\\n            previous[left] = \\'0\\' + (\\'1\\' - previous[left]);\\n            previous[right] = \\'0\\' + (\\'1\\' - previous[right]);\\n            left++;\\n            right--;\\n        }\\n\\n        // In case of an odd-length string, flip the middle character if necessary\\n        if (left == right)\\n        {\\n            previous[left] = \\'0\\' + (\\'1\\' - previous[left]);\\n        }\\n    }\\n    void reverse(string &rev)\\n    {\\n        int start = 0, end = rev.size() - 1;\\n        while (start <= end)\\n        {\\n            swap(rev[start], rev[end]);\\n            start++, end--;\\n        }\\n    }\\n    char findKthBit(int n, int k) {\\n         // How should I generate the first n sequence?\\n        char first = \\'0\\'; //Chosing first charachter (S1 = 0) as \\'0\\n        string sequence = \"\"; //This will store the final string for returning the Kth bit\\n        sequence.push_back(first); //pushing the first bit into sequence as all starts with it\\n        //loop from i = 2 because we already have first sequence above\\n        for (int i = 2; i <= n; i++)\\n        {   \\n            //Maintain a previous string to make sure you have a previously generated string which we will use to invert and reverse\\n            string previous = sequence;\\n\\n            //Invert previous string (using reference, in-place)\\n            invert(previous);\\n\\n            //Reverse inverted-previous string (using reference, in-place)\\n            reverse(previous);\\n\\n            //pushing the \\'1\\' into string as asked in question\\n            sequence.push_back(\\'1\\');\\n\\n            //This gives sequence by adding reverse(invert()) string;\\n            sequence += previous;\\n        }\\n        //return Kth-1 char\\n        return sequence[k - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825140,
                "title": "very-easy-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string rev(string arr){\\n        for(int i=0; i<arr.size(); i++) {\\n            if(arr[i]==\\'0\\') arr[i]=\\'1\\';\\n            else arr[i]=\\'0\\';\\n        }\\n        reverse(arr.begin(),arr.end());\\n        return arr;\\n    }\\n    \\n    string binaryString(int n) {\\n        if(n==1) return \"0\";\\n        \\n        return binaryString(n-1) + \"1\" + rev(binaryString(n-1));\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        string myArr = binaryString(n);\\n        return myArr[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string rev(string arr){\\n        for(int i=0; i<arr.size(); i++) {\\n            if(arr[i]==\\'0\\') arr[i]=\\'1\\';\\n            else arr[i]=\\'0\\';\\n        }\\n        reverse(arr.begin(),arr.end());\\n        return arr;\\n    }\\n    \\n    string binaryString(int n) {\\n        if(n==1) return \"0\";\\n        \\n        return binaryString(n-1) + \"1\" + rev(binaryString(n-1));\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        string myArr = binaryString(n);\\n        return myArr[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806555,
                "title": "using-recursion-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    string rec(int n){\\n        if(n == 1) return \"0\";\\n        else {\\n            string temp = rec(n-1);\\n            string temp_dash;\\n            for(auto i : temp){\\n                if(i == \\'0\\'){\\n                    temp_dash.push_back(\\'1\\');\\n\\n                }else {\\n                    temp_dash.push_back(\\'0\\');\\n                }\\n            }\\n            reverse(temp_dash.begin(), temp_dash.end());\\n            return temp + \"1\" + temp_dash;\\n        }\\n    }\\n\\n    char findKthBit(int n, int k) {\\n\\n        string s = rec(n);\\n        cout<<s;\\n        return s[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    string rec(int n){\\n        if(n == 1) return \"0\";\\n        else {\\n            string temp = rec(n-1);\\n            string temp_dash;\\n            for(auto i : temp){\\n                if(i == \\'0\\'){\\n                    temp_dash.push_back(\\'1\\');\\n\\n                }else {\\n                    temp_dash.push_back(\\'0\\');\\n                }\\n            }\\n            reverse(temp_dash.begin(), temp_dash.end());\\n            return temp + \"1\" + temp_dash;\\n        }\\n    }\\n\\n    char findKthBit(int n, int k) {\\n\\n        string s = rec(n);\\n        cout<<s;\\n        return s[k-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3805292,
                "title": "1545-find-kth-bit-in-nth-binary-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstring invert(string s){\\n    int n=s.size();\\n    for(int i=0;i<n;i++){\\n        if(s[i]==\\'0\\'){\\n            s[i]=\\'1\\';\\n        }\\n        else{\\n            s[i]=\\'0\\';\\n        }\\n    }\\n    return s;\\n}\\nstring rev(string s){\\n    int n=s.size();\\n    for(int i=0;i<n/2;i++){\\n        swap(s[i],s[n-1-i]);\\n    }\\n    return s;\\n}\\nstring bits(int n,vector<string>&s){\\nif(s[n].size()!=0){\\n    return s[n];\\n}\\n    if(n==1){\\n        return \"0\";\\n    }\\n\\ns[n]=bits(n-1,s)+\"1\"+rev(invert(bits(n-1,s)));\\nreturn s[n];\\n}\\n    char findKthBit(int n, int k) {\\n        if(n==1){\\n            return \\'0\\';\\n        }\\n        vector<string>s(n+1);\\n        s[0]=\"0\";\\n        s[1]=\"0\";\\n        return bits(n,s)[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstring invert(string s){\\n    int n=s.size();\\n    for(int i=0;i<n;i++){\\n        if(s[i]==\\'0\\'){\\n            s[i]=\\'1\\';\\n        }\\n        else{\\n            s[i]=\\'0\\';\\n        }\\n    }\\n    return s;\\n}\\nstring rev(string s){\\n    int n=s.size();\\n    for(int i=0;i<n/2;i++){\\n        swap(s[i],s[n-1-i]);\\n    }\\n    return s;\\n}\\nstring bits(int n,vector<string>&s){\\nif(s[n].size()!=0){\\n    return s[n];\\n}\\n    if(n==1){\\n        return \"0\";\\n    }\\n\\ns[n]=bits(n-1,s)+\"1\"+rev(invert(bits(n-1,s)));\\nreturn s[n];\\n}\\n    char findKthBit(int n, int k) {\\n        if(n==1){\\n            return \\'0\\';\\n        }\\n        vector<string>s(n+1);\\n        s[0]=\"0\";\\n        s[1]=\"0\";\\n        return bits(n,s)[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803327,
                "title": "c-recursion-inverse-reverse-add-return",
                "content": "```\\nclass Solution {\\npublic:\\n    string findbit(int n){\\n        if(n==1) return \"0\";\\n        string s=findbit(n-1);\\n        string ans=s+\\'1\\';\\n        for(int i=0;i<s.size();i++)\\n            {if(s[i]==\\'1\\') s[i]=\\'0\\';\\n            else s[i]=\\'1\\';}\\n        reverse(s.begin(),s.end());\\n        ans=ans+s;\\n        return ans;\\n    }\\n    \\n    char findKthBit(int n, int k) {\\n        string s=findbit(n);\\n        return s[k-1];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string findbit(int n){\\n        if(n==1) return \"0\";\\n        string s=findbit(n-1);\\n        string ans=s+\\'1\\';\\n        for(int i=0;i<s.size();i++)\\n            {if(s[i]==\\'1\\') s[i]=\\'0\\';\\n            else s[i]=\\'1\\';}",
                "codeTag": "Java"
            },
            {
                "id": 3785615,
                "title": "wow-nice-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if (n == 1) {\\n            return \\'0\\';\\n        }\\n        \\n        String pre = \"0\";\\n        String current = \"\";\\n        \\n        for (int i = 2; i <= n; i++) {\\n            current = pre + \"1\" + invert(pre);\\n            pre = current;\\n        }\\n        \\n        return current.charAt(k - 1);\\n    }\\n    \\n    private String invert(String pre) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < pre.length(); i++) {\\n            if (pre.charAt(i) == \\'0\\') {\\n                sb.append(\\'1\\');\\n            } else {\\n                sb.append(\\'0\\');\\n            }\\n        }\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        if (n == 1) {\\n            return \\'0\\';\\n        }\\n        \\n        String pre = \"0\";\\n        String current = \"\";\\n        \\n        for (int i = 2; i <= n; i++) {\\n            current = pre + \"1\" + invert(pre);\\n            pre = current;\\n        }\\n        \\n        return current.charAt(k - 1);\\n    }\\n    \\n    private String invert(String pre) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < pre.length(); i++) {\\n            if (pre.charAt(i) == \\'0\\') {\\n                sb.append(\\'1\\');\\n            } else {\\n                sb.append(\\'0\\');\\n            }\\n        }\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780957,
                "title": "cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        \\n    string s=\"0\";\\n    \\n\\n    for(int i=0;i<n-1;i++){\\n\\n        s=s+\\'1\\';   // s=0 ....-> s=01\\n        \\n        //first part bit change  ->  (0)1(1)\\n        string tmp=\"\";\\n        for(int j=0;j<s.length()-1;j++){\\n            if(s[j]==\\'0\\') tmp+=\\'1\\';\\n            else tmp+=\\'0\\';\\n        }\\n\\n        //reverse of second part ->  (0)1(1)\\n        reverse(tmp.begin(),tmp.end());\\n       \\n        s+=tmp; //adding to string\\n    }\\n    return s[k-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        \\n    string s=\"0\";\\n    \\n\\n    for(int i=0;i<n-1;i++){\\n\\n        s=s+\\'1\\';   // s=0 ....-> s=01\\n        \\n        //first part bit change  ->  (0)1(1)\\n        string tmp=\"\";\\n        for(int j=0;j<s.length()-1;j++){\\n            if(s[j]==\\'0\\') tmp+=\\'1\\';\\n            else tmp+=\\'0\\';\\n        }\\n\\n        //reverse of second part ->  (0)1(1)\\n        reverse(tmp.begin(),tmp.end());\\n       \\n        s+=tmp; //adding to string\\n    }\\n    return s[k-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777803,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        if(k==1)return \\'0\\';\\n        string s=\"0\";\\n        n--;\\n\\n        while(n){\\n            if(k<=s.size())return s[k-1];\\n            s+=\\'1\\';\\n            for(int i=s.size()-2;i>=0;i--){\\n                if(s[i]==\\'1\\')s+=\\'0\\';\\n                else s+=\\'1\\';\\n            }\\n        }\\n        return s[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char findKthBit(int n, int k) {\\n        if(k==1)return \\'0\\';\\n        string s=\"0\";\\n        n--;\\n\\n        while(n){\\n            if(k<=s.size())return s[k-1];\\n            s+=\\'1\\';\\n            for(int i=s.size()-2;i>=0;i--){\\n                if(s[i]==\\'1\\')s+=\\'0\\';\\n                else s+=\\'1\\';\\n            }\\n        }\\n        return s[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775037,
                "title": "recursion",
                "content": "# Intuition\\nGo all the way down to the base case, then just build up from bottom up\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n\\n        def get_n(n):\\n\\n            if n == 1:\\n                return \"0\"\\n            \\n            previous = get_n(n-1)\\n            r_invert = \"\".join(reversed([ \"0\" if c == \"1\" else \"1\" for c in previous]))\\n\\n            return previous + \"1\" + r_invert\\n        \\n        return get_n(n)[k-1]\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findKthBit(self, n: int, k: int) -> str:\\n\\n        def get_n(n):\\n\\n            if n == 1:\\n                return \"0\"\\n            \\n            previous = get_n(n-1)\\n            r_invert = \"\".join(reversed([ \"0\" if c == \"1\" else \"1\" for c in previous]))\\n\\n            return previous + \"1\" + r_invert\\n        \\n        return get_n(n)[k-1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741479,
                "title": "easy-to-understand-beats-100-0ms-recursion",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n   public char findKthBit(int n, int k) {\\n        if(n == 1){\\n            return \\'0\\';\\n        }\\n        \\n        int numberOfColumns = (int)Math.pow(2,n) - 1;\\n        int mid = numberOfColumns/2;\\n                \\n        if(k <= mid){\\n            return findKthBit(n-1,k);\\n        } else if (k == mid + 1){\\n            return \\'1\\';\\n        } else {\\n           k = numberOfColumns - k + 1;\\n           char ch = findKthBit(n-1,k);\\n           return ch == \\'0\\' ? \\'1\\' : \\'0\\';\\n        }\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public char findKthBit(int n, int k) {\\n        if(n == 1){\\n            return \\'0\\';\\n        }\\n        \\n        int numberOfColumns = (int)Math.pow(2,n) - 1;\\n        int mid = numberOfColumns/2;\\n                \\n        if(k <= mid){\\n            return findKthBit(n-1,k);\\n        } else if (k == mid + 1){\\n            return \\'1\\';\\n        } else {\\n           k = numberOfColumns - k + 1;\\n           char ch = findKthBit(n-1,k);\\n           return ch == \\'0\\' ? \\'1\\' : \\'0\\';\\n        }\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723487,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    string fn(string s)\\n    {\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                s[i]=\\'1\\';\\n            }\\n\\n            else\\n            {\\n                s[i]=\\'0\\';\\n            }\\n        }\\n\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n\\n    char findKthBit(int n, int k) \\n    {\\n        n--;\\n        string s=\"0\";\\n\\n        while(n--)\\n        {\\n            s=s+\"1\"+fn(s);\\n        }\\n\\n        return s[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string fn(string s)\\n    {\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                s[i]=\\'1\\';\\n            }\\n\\n            else\\n            {\\n                s[i]=\\'0\\';\\n            }\\n        }\\n\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n\\n    char findKthBit(int n, int k) \\n    {\\n        n--;\\n        string s=\"0\";\\n\\n        while(n--)\\n        {\\n            s=s+\"1\"+fn(s);\\n        }\\n\\n        return s[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702801,
                "title": "easy-recursive-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse Rcursion,and apply method given in problem statement.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int count,int n,int k,string s,string &ans){\\n        if(count==n){\\n            ans=s;\\n            return;\\n        }\\n        string p=\"\";\\n        for(int i=0;i<s.length();i++){\\n            int x=s[i]-\\'0\\';\\n       if(x==0){\\n           p+=\\'1\\';\\n       }\\n       else\\n       {\\n           p+=\\'0\\';\\n       }\\n        }\\n        reverse(p.begin(),p.end());\\n        string str=s+\"1\"+p;\\n        solve(count+1,n,k,str,ans);\\n\\n    }\\n    char   findKthBit(int n, int k) {\\n        if(n==1 && k==1){\\n            return \\'0\\';\\n        }\\n        string ans;\\n        string s=\"0\";\\n        solve(1,n,k,s,ans);\\n        int count=0;\\n        for(int i=0;i<ans.length();i++){\\n            count++;\\n            if(count==k){\\n                return ans[i];\\n            }\\n        }\\n        return \\'0\\';\\n    }\\n};\\n********PLEASE UPVOTE IF FOUND USEFUL************\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int count,int n,int k,string s,string &ans){\\n        if(count==n){\\n            ans=s;\\n            return;\\n        }\\n        string p=\"\";\\n        for(int i=0;i<s.length();i++){\\n            int x=s[i]-\\'0\\';\\n       if(x==0){\\n           p+=\\'1\\';\\n       }\\n       else\\n       {\\n           p+=\\'0\\';\\n       }\\n        }\\n        reverse(p.begin(),p.end());\\n        string str=s+\"1\"+p;\\n        solve(count+1,n,k,str,ans);\\n\\n    }\\n    char   findKthBit(int n, int k) {\\n        if(n==1 && k==1){\\n            return \\'0\\';\\n        }\\n        string ans;\\n        string s=\"0\";\\n        solve(1,n,k,s,ans);\\n        int count=0;\\n        for(int i=0;i<ans.length();i++){\\n            count++;\\n            if(count==k){\\n                return ans[i];\\n            }\\n        }\\n        return \\'0\\';\\n    }\\n};\\n********PLEASE UPVOTE IF FOUND USEFUL************\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691032,
                "title": "c-solution-recursion",
                "content": "![image.png](https://assets.leetcode.com/users/images/b4f77b22-7088-4a94-8cde-28f5ffabf42d_1687920441.537195.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string invertStr(string s)\\n    {\\n        int len = s.length();\\n        for (int i = 0; i < len; i++)\\n        {\\n            if (s[i] == \\'0\\')\\n                s[i] = \\'1\\';\\n            else\\n                if (s[i] == \\'1\\')\\n                    s[i] = \\'0\\';\\n        }\\n        return s;\\n    }\\n    string reverseStr(string s)\\n    {\\n        string str = \"\";\\n        int len = s.length();\\n        for (int i = len - 1; i >= 0; i--)\\n            str += s[i];\\n        return str;\\n    }\\n    string recursion(string ans, int n, int k)\\n    {\\n        if (n == 1)\\n            return \"0\";\\n        return recursion(ans, n - 1, k) + \"1\" + reverseStr(invertStr(recursion(ans, n - 1, k)));\\n    }\\n    char findKthBit(int n, int k) {\\n        string ans = \"\";\\n        string res = recursion(ans, n, k);\\n        return res[k - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string invertStr(string s)\\n    {\\n        int len = s.length();\\n        for (int i = 0; i < len; i++)\\n        {\\n            if (s[i] == \\'0\\')\\n                s[i] = \\'1\\';\\n            else\\n                if (s[i] == \\'1\\')\\n                    s[i] = \\'0\\';\\n        }\\n        return s;\\n    }\\n    string reverseStr(string s)\\n    {\\n        string str = \"\";\\n        int len = s.length();\\n        for (int i = len - 1; i >= 0; i--)\\n            str += s[i];\\n        return str;\\n    }\\n    string recursion(string ans, int n, int k)\\n    {\\n        if (n == 1)\\n            return \"0\";\\n        return recursion(ans, n - 1, k) + \"1\" + reverseStr(invertStr(recursion(ans, n - 1, k)));\\n    }\\n    char findKthBit(int n, int k) {\\n        string ans = \"\";\\n        string res = recursion(ans, n, k);\\n        return res[k - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1676948,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "This problem was fun to solve \\uD83D\\uDE29"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "in my submission all 63/63 test case passed , but it show TLE for n=, that is not a valid integer. What are the problem\n\ncode::: \nclass Solution {\n      public static String binary(int n,String str) {\n        if (n == 1) {\n            str = \"0\";\n            return str;\n        }\n\n        str = binary(n - 1, str);\n        String strinv= str;\n        //Invert String\n        strinv = strinv.replaceAll(\"0\", \"x\");\n        strinv = strinv.replaceAll(\"1\", \"0\");\n        strinv = strinv.replaceAll(\"x\", \"1\");\n        StringBuilder sb  =new StringBuilder(strinv);\n        sb.reverse();//Reverse  String \n        String strfinal = str+\"1\"+sb.toString();\n        return strfinal;\n    }\n    public char findKthBit(int n, int k) {\n     \n        String s =\"\";\n        String str =  binary(n,s);\n        return str.charAt(k-1);\n    }\n}"
                    },
                    {
                        "username": "shreplusly",
                        "content": "I\\'m getting an index out of bounds error with this code.Need HELP!!\\n\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        int num = 2;\\n        sb.append(\"0\");\\n        while (num <= n) {\\n            StringBuilder temp = new StringBuilder();\\n            sb.append(\"1\").append(helper(temp));\\n            num++;\\n        }\\n        return (char) (sb.charAt(k - 1));\\n    }\\n\\n    public String helper(StringBuilder temp) {\\n        for (int i = temp.length() - 1; i >= 0; i--) {\\n            if (temp.charAt(i) == \\'1\\')\\n                temp.append(\"0\");\\n            else\\n                temp.append(\"1\");\\n        }\\n        return temp.toString();\\n    }\\n}"
                    },
                    {
                        "username": "shivanigam",
                        "content": "it is showing tle\\nString val=recur(n,k);\\n        char ch=val.charAt(k-1);\\n        return ch;\\n\\n    }\\n    public String recur(int n,int k){\\n        if(n==1)\\n        return \"0\";\\n\\n        return recur(n-1,k)+\"1\"+helping(invert(recur(n-1,k)));\\n    }\\npublic String helping(String rev){\\n        StringBuilder str=new StringBuilder();\\n        str.append(rev);\\n        str.reverse();\\n        return str.toString();\\n    }\\n\\npublic String invert(String inv){\\n        String emp=\"\";\\n        for(int i=0;i<inv.length();i++){\\n            if(inv.charAt(i)==\\'1\\')\\n            emp=emp+\"0\";\\n            else\\n            emp=emp+\"1\";\\n        }\\n        return emp;\\nplease tell where i have to make changes\\n\\n"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "2 Keep observation\\n\\n1. Size of the string which contain k length would be pow(2,n)-1;\\n2. Middle element of string is always 1 except n=1."
                    },
                    {
                        "username": "M01NALI",
                        "content": "Anyone can tell me why its giving me TLE.\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n     String ans=helper(n);\\n     return ans.charAt(k-1);\\n         }\\n    public String helper(int n)\\n    {\\n        if(n==1)\\n        {\\n            return \"0\";\\n        }\\n        String temp=helper(n-1);\\n        return temp +\"1\"+(rev(inv(temp)));\\n    }\\n    public String inv(String s)\\n    {\\n        String temp=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int j=s.charAt(i)-\\'0\\';\\n            temp=temp+(j^1);\\n        }\\n        return temp;\\n    }\\n    public String rev(String s)\\n    {\\n        String temp=\"\";\\n        for(int i=s.length()-1;i>-1;i--)\\n        {\\n            temp=temp+s.charAt(i);\\n        }\\n        return temp;\\n    }\\n}"
                    },
                    {
                        "username": "subhamjha4444",
                        "content": "  Can anyone please say why returning \\'1\\' within else if block in the code below doesn\\'t work???\\n\\nchar findKthBit(int n, int k) {\\n\\n\\n        if(n==1 || k==1){\\n            return \\'0\\';\\n            }\\n         int num=1<<n;\\n\\n         if(k== ( num/2) return \\'1\\';\\n\\n         if(k<num/2) return findKthBit(n-1,k);\\n\\n        else if(k>(num/2 )) {\\n            if(findKthBit(n-1,num-k)==\\'1\\') return \\'0\\';\\n         else return \\'1\\';---->[this doesn\\'t work]\\n            \\n       \\n        }\\n\\nreturn \\'1\\'; --->this works\\n}\\n\\n\\n        "
                    }
                ]
            },
            {
                "id": 1722887,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "This problem was fun to solve \\uD83D\\uDE29"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "in my submission all 63/63 test case passed , but it show TLE for n=, that is not a valid integer. What are the problem\n\ncode::: \nclass Solution {\n      public static String binary(int n,String str) {\n        if (n == 1) {\n            str = \"0\";\n            return str;\n        }\n\n        str = binary(n - 1, str);\n        String strinv= str;\n        //Invert String\n        strinv = strinv.replaceAll(\"0\", \"x\");\n        strinv = strinv.replaceAll(\"1\", \"0\");\n        strinv = strinv.replaceAll(\"x\", \"1\");\n        StringBuilder sb  =new StringBuilder(strinv);\n        sb.reverse();//Reverse  String \n        String strfinal = str+\"1\"+sb.toString();\n        return strfinal;\n    }\n    public char findKthBit(int n, int k) {\n     \n        String s =\"\";\n        String str =  binary(n,s);\n        return str.charAt(k-1);\n    }\n}"
                    },
                    {
                        "username": "shreplusly",
                        "content": "I\\'m getting an index out of bounds error with this code.Need HELP!!\\n\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        int num = 2;\\n        sb.append(\"0\");\\n        while (num <= n) {\\n            StringBuilder temp = new StringBuilder();\\n            sb.append(\"1\").append(helper(temp));\\n            num++;\\n        }\\n        return (char) (sb.charAt(k - 1));\\n    }\\n\\n    public String helper(StringBuilder temp) {\\n        for (int i = temp.length() - 1; i >= 0; i--) {\\n            if (temp.charAt(i) == \\'1\\')\\n                temp.append(\"0\");\\n            else\\n                temp.append(\"1\");\\n        }\\n        return temp.toString();\\n    }\\n}"
                    },
                    {
                        "username": "shivanigam",
                        "content": "it is showing tle\\nString val=recur(n,k);\\n        char ch=val.charAt(k-1);\\n        return ch;\\n\\n    }\\n    public String recur(int n,int k){\\n        if(n==1)\\n        return \"0\";\\n\\n        return recur(n-1,k)+\"1\"+helping(invert(recur(n-1,k)));\\n    }\\npublic String helping(String rev){\\n        StringBuilder str=new StringBuilder();\\n        str.append(rev);\\n        str.reverse();\\n        return str.toString();\\n    }\\n\\npublic String invert(String inv){\\n        String emp=\"\";\\n        for(int i=0;i<inv.length();i++){\\n            if(inv.charAt(i)==\\'1\\')\\n            emp=emp+\"0\";\\n            else\\n            emp=emp+\"1\";\\n        }\\n        return emp;\\nplease tell where i have to make changes\\n\\n"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "2 Keep observation\\n\\n1. Size of the string which contain k length would be pow(2,n)-1;\\n2. Middle element of string is always 1 except n=1."
                    },
                    {
                        "username": "M01NALI",
                        "content": "Anyone can tell me why its giving me TLE.\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n     String ans=helper(n);\\n     return ans.charAt(k-1);\\n         }\\n    public String helper(int n)\\n    {\\n        if(n==1)\\n        {\\n            return \"0\";\\n        }\\n        String temp=helper(n-1);\\n        return temp +\"1\"+(rev(inv(temp)));\\n    }\\n    public String inv(String s)\\n    {\\n        String temp=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int j=s.charAt(i)-\\'0\\';\\n            temp=temp+(j^1);\\n        }\\n        return temp;\\n    }\\n    public String rev(String s)\\n    {\\n        String temp=\"\";\\n        for(int i=s.length()-1;i>-1;i--)\\n        {\\n            temp=temp+s.charAt(i);\\n        }\\n        return temp;\\n    }\\n}"
                    },
                    {
                        "username": "subhamjha4444",
                        "content": "  Can anyone please say why returning \\'1\\' within else if block in the code below doesn\\'t work???\\n\\nchar findKthBit(int n, int k) {\\n\\n\\n        if(n==1 || k==1){\\n            return \\'0\\';\\n            }\\n         int num=1<<n;\\n\\n         if(k== ( num/2) return \\'1\\';\\n\\n         if(k<num/2) return findKthBit(n-1,k);\\n\\n        else if(k>(num/2 )) {\\n            if(findKthBit(n-1,num-k)==\\'1\\') return \\'0\\';\\n         else return \\'1\\';---->[this doesn\\'t work]\\n            \\n       \\n        }\\n\\nreturn \\'1\\'; --->this works\\n}\\n\\n\\n        "
                    }
                ]
            },
            {
                "id": 1966843,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "This problem was fun to solve \\uD83D\\uDE29"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "in my submission all 63/63 test case passed , but it show TLE for n=, that is not a valid integer. What are the problem\n\ncode::: \nclass Solution {\n      public static String binary(int n,String str) {\n        if (n == 1) {\n            str = \"0\";\n            return str;\n        }\n\n        str = binary(n - 1, str);\n        String strinv= str;\n        //Invert String\n        strinv = strinv.replaceAll(\"0\", \"x\");\n        strinv = strinv.replaceAll(\"1\", \"0\");\n        strinv = strinv.replaceAll(\"x\", \"1\");\n        StringBuilder sb  =new StringBuilder(strinv);\n        sb.reverse();//Reverse  String \n        String strfinal = str+\"1\"+sb.toString();\n        return strfinal;\n    }\n    public char findKthBit(int n, int k) {\n     \n        String s =\"\";\n        String str =  binary(n,s);\n        return str.charAt(k-1);\n    }\n}"
                    },
                    {
                        "username": "shreplusly",
                        "content": "I\\'m getting an index out of bounds error with this code.Need HELP!!\\n\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        int num = 2;\\n        sb.append(\"0\");\\n        while (num <= n) {\\n            StringBuilder temp = new StringBuilder();\\n            sb.append(\"1\").append(helper(temp));\\n            num++;\\n        }\\n        return (char) (sb.charAt(k - 1));\\n    }\\n\\n    public String helper(StringBuilder temp) {\\n        for (int i = temp.length() - 1; i >= 0; i--) {\\n            if (temp.charAt(i) == \\'1\\')\\n                temp.append(\"0\");\\n            else\\n                temp.append(\"1\");\\n        }\\n        return temp.toString();\\n    }\\n}"
                    },
                    {
                        "username": "shivanigam",
                        "content": "it is showing tle\\nString val=recur(n,k);\\n        char ch=val.charAt(k-1);\\n        return ch;\\n\\n    }\\n    public String recur(int n,int k){\\n        if(n==1)\\n        return \"0\";\\n\\n        return recur(n-1,k)+\"1\"+helping(invert(recur(n-1,k)));\\n    }\\npublic String helping(String rev){\\n        StringBuilder str=new StringBuilder();\\n        str.append(rev);\\n        str.reverse();\\n        return str.toString();\\n    }\\n\\npublic String invert(String inv){\\n        String emp=\"\";\\n        for(int i=0;i<inv.length();i++){\\n            if(inv.charAt(i)==\\'1\\')\\n            emp=emp+\"0\";\\n            else\\n            emp=emp+\"1\";\\n        }\\n        return emp;\\nplease tell where i have to make changes\\n\\n"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "2 Keep observation\\n\\n1. Size of the string which contain k length would be pow(2,n)-1;\\n2. Middle element of string is always 1 except n=1."
                    },
                    {
                        "username": "M01NALI",
                        "content": "Anyone can tell me why its giving me TLE.\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n     String ans=helper(n);\\n     return ans.charAt(k-1);\\n         }\\n    public String helper(int n)\\n    {\\n        if(n==1)\\n        {\\n            return \"0\";\\n        }\\n        String temp=helper(n-1);\\n        return temp +\"1\"+(rev(inv(temp)));\\n    }\\n    public String inv(String s)\\n    {\\n        String temp=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int j=s.charAt(i)-\\'0\\';\\n            temp=temp+(j^1);\\n        }\\n        return temp;\\n    }\\n    public String rev(String s)\\n    {\\n        String temp=\"\";\\n        for(int i=s.length()-1;i>-1;i--)\\n        {\\n            temp=temp+s.charAt(i);\\n        }\\n        return temp;\\n    }\\n}"
                    },
                    {
                        "username": "subhamjha4444",
                        "content": "  Can anyone please say why returning \\'1\\' within else if block in the code below doesn\\'t work???\\n\\nchar findKthBit(int n, int k) {\\n\\n\\n        if(n==1 || k==1){\\n            return \\'0\\';\\n            }\\n         int num=1<<n;\\n\\n         if(k== ( num/2) return \\'1\\';\\n\\n         if(k<num/2) return findKthBit(n-1,k);\\n\\n        else if(k>(num/2 )) {\\n            if(findKthBit(n-1,num-k)==\\'1\\') return \\'0\\';\\n         else return \\'1\\';---->[this doesn\\'t work]\\n            \\n       \\n        }\\n\\nreturn \\'1\\'; --->this works\\n}\\n\\n\\n        "
                    }
                ]
            },
            {
                "id": 1868959,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "This problem was fun to solve \\uD83D\\uDE29"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "in my submission all 63/63 test case passed , but it show TLE for n=, that is not a valid integer. What are the problem\n\ncode::: \nclass Solution {\n      public static String binary(int n,String str) {\n        if (n == 1) {\n            str = \"0\";\n            return str;\n        }\n\n        str = binary(n - 1, str);\n        String strinv= str;\n        //Invert String\n        strinv = strinv.replaceAll(\"0\", \"x\");\n        strinv = strinv.replaceAll(\"1\", \"0\");\n        strinv = strinv.replaceAll(\"x\", \"1\");\n        StringBuilder sb  =new StringBuilder(strinv);\n        sb.reverse();//Reverse  String \n        String strfinal = str+\"1\"+sb.toString();\n        return strfinal;\n    }\n    public char findKthBit(int n, int k) {\n     \n        String s =\"\";\n        String str =  binary(n,s);\n        return str.charAt(k-1);\n    }\n}"
                    },
                    {
                        "username": "shreplusly",
                        "content": "I\\'m getting an index out of bounds error with this code.Need HELP!!\\n\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        int num = 2;\\n        sb.append(\"0\");\\n        while (num <= n) {\\n            StringBuilder temp = new StringBuilder();\\n            sb.append(\"1\").append(helper(temp));\\n            num++;\\n        }\\n        return (char) (sb.charAt(k - 1));\\n    }\\n\\n    public String helper(StringBuilder temp) {\\n        for (int i = temp.length() - 1; i >= 0; i--) {\\n            if (temp.charAt(i) == \\'1\\')\\n                temp.append(\"0\");\\n            else\\n                temp.append(\"1\");\\n        }\\n        return temp.toString();\\n    }\\n}"
                    },
                    {
                        "username": "shivanigam",
                        "content": "it is showing tle\\nString val=recur(n,k);\\n        char ch=val.charAt(k-1);\\n        return ch;\\n\\n    }\\n    public String recur(int n,int k){\\n        if(n==1)\\n        return \"0\";\\n\\n        return recur(n-1,k)+\"1\"+helping(invert(recur(n-1,k)));\\n    }\\npublic String helping(String rev){\\n        StringBuilder str=new StringBuilder();\\n        str.append(rev);\\n        str.reverse();\\n        return str.toString();\\n    }\\n\\npublic String invert(String inv){\\n        String emp=\"\";\\n        for(int i=0;i<inv.length();i++){\\n            if(inv.charAt(i)==\\'1\\')\\n            emp=emp+\"0\";\\n            else\\n            emp=emp+\"1\";\\n        }\\n        return emp;\\nplease tell where i have to make changes\\n\\n"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "2 Keep observation\\n\\n1. Size of the string which contain k length would be pow(2,n)-1;\\n2. Middle element of string is always 1 except n=1."
                    },
                    {
                        "username": "M01NALI",
                        "content": "Anyone can tell me why its giving me TLE.\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n     String ans=helper(n);\\n     return ans.charAt(k-1);\\n         }\\n    public String helper(int n)\\n    {\\n        if(n==1)\\n        {\\n            return \"0\";\\n        }\\n        String temp=helper(n-1);\\n        return temp +\"1\"+(rev(inv(temp)));\\n    }\\n    public String inv(String s)\\n    {\\n        String temp=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int j=s.charAt(i)-\\'0\\';\\n            temp=temp+(j^1);\\n        }\\n        return temp;\\n    }\\n    public String rev(String s)\\n    {\\n        String temp=\"\";\\n        for(int i=s.length()-1;i>-1;i--)\\n        {\\n            temp=temp+s.charAt(i);\\n        }\\n        return temp;\\n    }\\n}"
                    },
                    {
                        "username": "subhamjha4444",
                        "content": "  Can anyone please say why returning \\'1\\' within else if block in the code below doesn\\'t work???\\n\\nchar findKthBit(int n, int k) {\\n\\n\\n        if(n==1 || k==1){\\n            return \\'0\\';\\n            }\\n         int num=1<<n;\\n\\n         if(k== ( num/2) return \\'1\\';\\n\\n         if(k<num/2) return findKthBit(n-1,k);\\n\\n        else if(k>(num/2 )) {\\n            if(findKthBit(n-1,num-k)==\\'1\\') return \\'0\\';\\n         else return \\'1\\';---->[this doesn\\'t work]\\n            \\n       \\n        }\\n\\nreturn \\'1\\'; --->this works\\n}\\n\\n\\n        "
                    }
                ]
            },
            {
                "id": 1826397,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "This problem was fun to solve \\uD83D\\uDE29"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "in my submission all 63/63 test case passed , but it show TLE for n=, that is not a valid integer. What are the problem\n\ncode::: \nclass Solution {\n      public static String binary(int n,String str) {\n        if (n == 1) {\n            str = \"0\";\n            return str;\n        }\n\n        str = binary(n - 1, str);\n        String strinv= str;\n        //Invert String\n        strinv = strinv.replaceAll(\"0\", \"x\");\n        strinv = strinv.replaceAll(\"1\", \"0\");\n        strinv = strinv.replaceAll(\"x\", \"1\");\n        StringBuilder sb  =new StringBuilder(strinv);\n        sb.reverse();//Reverse  String \n        String strfinal = str+\"1\"+sb.toString();\n        return strfinal;\n    }\n    public char findKthBit(int n, int k) {\n     \n        String s =\"\";\n        String str =  binary(n,s);\n        return str.charAt(k-1);\n    }\n}"
                    },
                    {
                        "username": "shreplusly",
                        "content": "I\\'m getting an index out of bounds error with this code.Need HELP!!\\n\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        int num = 2;\\n        sb.append(\"0\");\\n        while (num <= n) {\\n            StringBuilder temp = new StringBuilder();\\n            sb.append(\"1\").append(helper(temp));\\n            num++;\\n        }\\n        return (char) (sb.charAt(k - 1));\\n    }\\n\\n    public String helper(StringBuilder temp) {\\n        for (int i = temp.length() - 1; i >= 0; i--) {\\n            if (temp.charAt(i) == \\'1\\')\\n                temp.append(\"0\");\\n            else\\n                temp.append(\"1\");\\n        }\\n        return temp.toString();\\n    }\\n}"
                    },
                    {
                        "username": "shivanigam",
                        "content": "it is showing tle\\nString val=recur(n,k);\\n        char ch=val.charAt(k-1);\\n        return ch;\\n\\n    }\\n    public String recur(int n,int k){\\n        if(n==1)\\n        return \"0\";\\n\\n        return recur(n-1,k)+\"1\"+helping(invert(recur(n-1,k)));\\n    }\\npublic String helping(String rev){\\n        StringBuilder str=new StringBuilder();\\n        str.append(rev);\\n        str.reverse();\\n        return str.toString();\\n    }\\n\\npublic String invert(String inv){\\n        String emp=\"\";\\n        for(int i=0;i<inv.length();i++){\\n            if(inv.charAt(i)==\\'1\\')\\n            emp=emp+\"0\";\\n            else\\n            emp=emp+\"1\";\\n        }\\n        return emp;\\nplease tell where i have to make changes\\n\\n"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "2 Keep observation\\n\\n1. Size of the string which contain k length would be pow(2,n)-1;\\n2. Middle element of string is always 1 except n=1."
                    },
                    {
                        "username": "M01NALI",
                        "content": "Anyone can tell me why its giving me TLE.\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n     String ans=helper(n);\\n     return ans.charAt(k-1);\\n         }\\n    public String helper(int n)\\n    {\\n        if(n==1)\\n        {\\n            return \"0\";\\n        }\\n        String temp=helper(n-1);\\n        return temp +\"1\"+(rev(inv(temp)));\\n    }\\n    public String inv(String s)\\n    {\\n        String temp=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int j=s.charAt(i)-\\'0\\';\\n            temp=temp+(j^1);\\n        }\\n        return temp;\\n    }\\n    public String rev(String s)\\n    {\\n        String temp=\"\";\\n        for(int i=s.length()-1;i>-1;i--)\\n        {\\n            temp=temp+s.charAt(i);\\n        }\\n        return temp;\\n    }\\n}"
                    },
                    {
                        "username": "subhamjha4444",
                        "content": "  Can anyone please say why returning \\'1\\' within else if block in the code below doesn\\'t work???\\n\\nchar findKthBit(int n, int k) {\\n\\n\\n        if(n==1 || k==1){\\n            return \\'0\\';\\n            }\\n         int num=1<<n;\\n\\n         if(k== ( num/2) return \\'1\\';\\n\\n         if(k<num/2) return findKthBit(n-1,k);\\n\\n        else if(k>(num/2 )) {\\n            if(findKthBit(n-1,num-k)==\\'1\\') return \\'0\\';\\n         else return \\'1\\';---->[this doesn\\'t work]\\n            \\n       \\n        }\\n\\nreturn \\'1\\'; --->this works\\n}\\n\\n\\n        "
                    }
                ]
            },
            {
                "id": 1740955,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "This problem was fun to solve \\uD83D\\uDE29"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "in my submission all 63/63 test case passed , but it show TLE for n=, that is not a valid integer. What are the problem\n\ncode::: \nclass Solution {\n      public static String binary(int n,String str) {\n        if (n == 1) {\n            str = \"0\";\n            return str;\n        }\n\n        str = binary(n - 1, str);\n        String strinv= str;\n        //Invert String\n        strinv = strinv.replaceAll(\"0\", \"x\");\n        strinv = strinv.replaceAll(\"1\", \"0\");\n        strinv = strinv.replaceAll(\"x\", \"1\");\n        StringBuilder sb  =new StringBuilder(strinv);\n        sb.reverse();//Reverse  String \n        String strfinal = str+\"1\"+sb.toString();\n        return strfinal;\n    }\n    public char findKthBit(int n, int k) {\n     \n        String s =\"\";\n        String str =  binary(n,s);\n        return str.charAt(k-1);\n    }\n}"
                    },
                    {
                        "username": "shreplusly",
                        "content": "I\\'m getting an index out of bounds error with this code.Need HELP!!\\n\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        int num = 2;\\n        sb.append(\"0\");\\n        while (num <= n) {\\n            StringBuilder temp = new StringBuilder();\\n            sb.append(\"1\").append(helper(temp));\\n            num++;\\n        }\\n        return (char) (sb.charAt(k - 1));\\n    }\\n\\n    public String helper(StringBuilder temp) {\\n        for (int i = temp.length() - 1; i >= 0; i--) {\\n            if (temp.charAt(i) == \\'1\\')\\n                temp.append(\"0\");\\n            else\\n                temp.append(\"1\");\\n        }\\n        return temp.toString();\\n    }\\n}"
                    },
                    {
                        "username": "shivanigam",
                        "content": "it is showing tle\\nString val=recur(n,k);\\n        char ch=val.charAt(k-1);\\n        return ch;\\n\\n    }\\n    public String recur(int n,int k){\\n        if(n==1)\\n        return \"0\";\\n\\n        return recur(n-1,k)+\"1\"+helping(invert(recur(n-1,k)));\\n    }\\npublic String helping(String rev){\\n        StringBuilder str=new StringBuilder();\\n        str.append(rev);\\n        str.reverse();\\n        return str.toString();\\n    }\\n\\npublic String invert(String inv){\\n        String emp=\"\";\\n        for(int i=0;i<inv.length();i++){\\n            if(inv.charAt(i)==\\'1\\')\\n            emp=emp+\"0\";\\n            else\\n            emp=emp+\"1\";\\n        }\\n        return emp;\\nplease tell where i have to make changes\\n\\n"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "2 Keep observation\\n\\n1. Size of the string which contain k length would be pow(2,n)-1;\\n2. Middle element of string is always 1 except n=1."
                    },
                    {
                        "username": "M01NALI",
                        "content": "Anyone can tell me why its giving me TLE.\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n     String ans=helper(n);\\n     return ans.charAt(k-1);\\n         }\\n    public String helper(int n)\\n    {\\n        if(n==1)\\n        {\\n            return \"0\";\\n        }\\n        String temp=helper(n-1);\\n        return temp +\"1\"+(rev(inv(temp)));\\n    }\\n    public String inv(String s)\\n    {\\n        String temp=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int j=s.charAt(i)-\\'0\\';\\n            temp=temp+(j^1);\\n        }\\n        return temp;\\n    }\\n    public String rev(String s)\\n    {\\n        String temp=\"\";\\n        for(int i=s.length()-1;i>-1;i--)\\n        {\\n            temp=temp+s.charAt(i);\\n        }\\n        return temp;\\n    }\\n}"
                    },
                    {
                        "username": "subhamjha4444",
                        "content": "  Can anyone please say why returning \\'1\\' within else if block in the code below doesn\\'t work???\\n\\nchar findKthBit(int n, int k) {\\n\\n\\n        if(n==1 || k==1){\\n            return \\'0\\';\\n            }\\n         int num=1<<n;\\n\\n         if(k== ( num/2) return \\'1\\';\\n\\n         if(k<num/2) return findKthBit(n-1,k);\\n\\n        else if(k>(num/2 )) {\\n            if(findKthBit(n-1,num-k)==\\'1\\') return \\'0\\';\\n         else return \\'1\\';---->[this doesn\\'t work]\\n            \\n       \\n        }\\n\\nreturn \\'1\\'; --->this works\\n}\\n\\n\\n        "
                    }
                ]
            },
            {
                "id": 1739450,
                "content": [
                    {
                        "username": "codewhisperer__",
                        "content": "This problem was fun to solve \\uD83D\\uDE29"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "in my submission all 63/63 test case passed , but it show TLE for n=, that is not a valid integer. What are the problem\n\ncode::: \nclass Solution {\n      public static String binary(int n,String str) {\n        if (n == 1) {\n            str = \"0\";\n            return str;\n        }\n\n        str = binary(n - 1, str);\n        String strinv= str;\n        //Invert String\n        strinv = strinv.replaceAll(\"0\", \"x\");\n        strinv = strinv.replaceAll(\"1\", \"0\");\n        strinv = strinv.replaceAll(\"x\", \"1\");\n        StringBuilder sb  =new StringBuilder(strinv);\n        sb.reverse();//Reverse  String \n        String strfinal = str+\"1\"+sb.toString();\n        return strfinal;\n    }\n    public char findKthBit(int n, int k) {\n     \n        String s =\"\";\n        String str =  binary(n,s);\n        return str.charAt(k-1);\n    }\n}"
                    },
                    {
                        "username": "shreplusly",
                        "content": "I\\'m getting an index out of bounds error with this code.Need HELP!!\\n\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        int num = 2;\\n        sb.append(\"0\");\\n        while (num <= n) {\\n            StringBuilder temp = new StringBuilder();\\n            sb.append(\"1\").append(helper(temp));\\n            num++;\\n        }\\n        return (char) (sb.charAt(k - 1));\\n    }\\n\\n    public String helper(StringBuilder temp) {\\n        for (int i = temp.length() - 1; i >= 0; i--) {\\n            if (temp.charAt(i) == \\'1\\')\\n                temp.append(\"0\");\\n            else\\n                temp.append(\"1\");\\n        }\\n        return temp.toString();\\n    }\\n}"
                    },
                    {
                        "username": "shivanigam",
                        "content": "it is showing tle\\nString val=recur(n,k);\\n        char ch=val.charAt(k-1);\\n        return ch;\\n\\n    }\\n    public String recur(int n,int k){\\n        if(n==1)\\n        return \"0\";\\n\\n        return recur(n-1,k)+\"1\"+helping(invert(recur(n-1,k)));\\n    }\\npublic String helping(String rev){\\n        StringBuilder str=new StringBuilder();\\n        str.append(rev);\\n        str.reverse();\\n        return str.toString();\\n    }\\n\\npublic String invert(String inv){\\n        String emp=\"\";\\n        for(int i=0;i<inv.length();i++){\\n            if(inv.charAt(i)==\\'1\\')\\n            emp=emp+\"0\";\\n            else\\n            emp=emp+\"1\";\\n        }\\n        return emp;\\nplease tell where i have to make changes\\n\\n"
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "2 Keep observation\\n\\n1. Size of the string which contain k length would be pow(2,n)-1;\\n2. Middle element of string is always 1 except n=1."
                    },
                    {
                        "username": "M01NALI",
                        "content": "Anyone can tell me why its giving me TLE.\\nclass Solution {\\n    public char findKthBit(int n, int k) {\\n     String ans=helper(n);\\n     return ans.charAt(k-1);\\n         }\\n    public String helper(int n)\\n    {\\n        if(n==1)\\n        {\\n            return \"0\";\\n        }\\n        String temp=helper(n-1);\\n        return temp +\"1\"+(rev(inv(temp)));\\n    }\\n    public String inv(String s)\\n    {\\n        String temp=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int j=s.charAt(i)-\\'0\\';\\n            temp=temp+(j^1);\\n        }\\n        return temp;\\n    }\\n    public String rev(String s)\\n    {\\n        String temp=\"\";\\n        for(int i=s.length()-1;i>-1;i--)\\n        {\\n            temp=temp+s.charAt(i);\\n        }\\n        return temp;\\n    }\\n}"
                    },
                    {
                        "username": "subhamjha4444",
                        "content": "  Can anyone please say why returning \\'1\\' within else if block in the code below doesn\\'t work???\\n\\nchar findKthBit(int n, int k) {\\n\\n\\n        if(n==1 || k==1){\\n            return \\'0\\';\\n            }\\n         int num=1<<n;\\n\\n         if(k== ( num/2) return \\'1\\';\\n\\n         if(k<num/2) return findKthBit(n-1,k);\\n\\n        else if(k>(num/2 )) {\\n            if(findKthBit(n-1,num-k)==\\'1\\') return \\'0\\';\\n         else return \\'1\\';---->[this doesn\\'t work]\\n            \\n       \\n        }\\n\\nreturn \\'1\\'; --->this works\\n}\\n\\n\\n        "
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Number of Non-Overlapping Subarrays With Sum Equals Target",
        "question_content": "<p>Given an array <code>nums</code> and an integer <code>target</code>, return <em>the maximum number of <strong>non-empty</strong> <strong>non-overlapping</strong> subarrays such that the sum of values in each subarray is equal to</em> <code>target</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,1,1,1], target = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are 2 non-overlapping subarrays [<strong>1,1</strong>,1,<strong>1,1</strong>] with sum equals to target(2).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,3,5,1,4,2,-9], target = 6\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are 3 subarrays with sum equal to 6.\n([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= target &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 780887,
                "title": "java-detailed-explanation-dp-map-prefix-o-n",
                "content": "**Key Notes:**\\n- It is very similar to other prefix sum/map problems, but O(N2) cannot pass instead.\\n- O(N2) solution is pretty naive, dp[i] means: optimal solution when using 0...i elements. But it is TLE. Transition function is: **dp[i] = Math.max(dp[i], 1 + dp[j])** if you can make a sum from j...i which is **equal to target.**\\n\\t- **Observations for O(N2) solution:**\\n\\t\\t- Search from i - 1 to 0, if you find a sum equal to target, **you can stop searching**, since longer dp[j] is alwasy better than shorter dp[j].\\n\\t\\t- You don\\'t need to search one by one, **but using a map**.\\n\\t\\t- Let\\'s coding!\\n```java\\nMap<Integer, Integer> map = new HashMap<>();\\nmap.put(0, 0);\\n\\nint res = 0;\\nint sum = 0;\\n\\nfor (int i = 0; i < nums.length; ++i) {\\n\\tsum += nums[i];\\n\\tif (map.containsKey(sum - target)) {\\n\\t\\tres = Math.max(res, map.get(sum - target) + 1);\\n\\t}\\n\\tmap.put(sum, res);\\n}\\n\\nreturn res;\\n```\\n  \\n\\n**TLE O(N2) DP Solution:**\\n```java\\nint N = nums.length;\\nint[] dp = new int[N + 1];\\n\\nfor (int i = 0; i < N; ++i) {\\n\\n\\tint sum = 0;\\n\\tfor (int j = i; j >= 0; --j) {\\n\\t\\tsum += nums[j];\\n\\t\\tdp[i + 1] = Math.max(dp[i + 1], dp[j] + (sum == target ? 1 : 0));\\n\\t}\\n}\\n\\nreturn dp[N];\\n```",
                "solutionTags": [],
                "code": "```java\\nMap<Integer, Integer> map = new HashMap<>();\\nmap.put(0, 0);\\n\\nint res = 0;\\nint sum = 0;\\n\\nfor (int i = 0; i < nums.length; ++i) {\\n\\tsum += nums[i];\\n\\tif (map.containsKey(sum - target)) {\\n\\t\\tres = Math.max(res, map.get(sum - target) + 1);\\n\\t}\\n\\tmap.put(sum, res);\\n}\\n\\nreturn res;\\n```\n```java\\nint N = nums.length;\\nint[] dp = new int[N + 1];\\n\\nfor (int i = 0; i < N; ++i) {\\n\\n\\tint sum = 0;\\n\\tfor (int j = i; j >= 0; --j) {\\n\\t\\tsum += nums[j];\\n\\t\\tdp[i + 1] = Math.max(dp[i + 1], dp[j] + (sum == target ? 1 : 0));\\n\\t}\\n}\\n\\nreturn dp[N];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780921,
                "title": "c-o-n",
                "content": "Well, we all know how to find all arrays that sum to a target in O(n) - track prefix sum in a hash map and look up complements (`sum - target`) there.\\n\\nNow, how do we count non-overlapping arrays? The intuition here is that the `right` side of our array is only increasing, and we can greedily track the smallest `right`. Value in `dp` is the left index of the subarray with the target sum. If we find a non-overlapping array (`right` <= `left`), we increase `cnt` and update `right` to the current position.\\n\\n```cpp\\nint maxNonOverlapping(vector<int>& nums, int target) {\\n    unordered_map<int, int> dp;\\n    dp[0] = -1;\\n    int sum = 0, right = -1, cnt = 0;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        sum += nums[i];\\n        if (dp.count(sum - target)) {\\n            int left = dp[sum - target];\\n            if (right <= left) {\\n                ++cnt;\\n                right = i;\\n            }\\n        }\\n        dp[sum] = i;\\n    }\\n    return cnt;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxNonOverlapping(vector<int>& nums, int target) {\\n    unordered_map<int, int> dp;\\n    dp[0] = -1;\\n    int sum = 0, right = -1, cnt = 0;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        sum += nums[i];\\n        if (dp.count(sum - target)) {\\n            int left = dp[sum - target];\\n            if (right <= left) {\\n                ++cnt;\\n                right = i;\\n            }\\n        }\\n        dp[sum] = i;\\n    }\\n    return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780882,
                "title": "java-14-lines-greedy-prefixsum-with-line-by-line-explanation-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/db055156-9c75-4f94-ae84-30891792fe7e_1596945767.5826385.png)\\n\\n```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        Map<Integer, Integer> map= new HashMap<>();\\n        int prefixSum=0, availableIdx=-1, res=0;\\n        map.put(0,-1);\\n        for (int i=0; i<nums.length; i++){\\n            prefixSum+=nums[i];\\n            int remain = prefixSum - target;\\n            if (map.containsKey(remain) && map.get(remain)>=availableIdx){\\n                res++;\\n                availableIdx=i;\\n            }\\n            map.put(prefixSum, i);\\n        }\\n        return res;\\n    }\\n}\\n```\\nHappy Coding!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        Map<Integer, Integer> map= new HashMap<>();\\n        int prefixSum=0, availableIdx=-1, res=0;\\n        map.put(0,-1);\\n        for (int i=0; i<nums.length; i++){\\n            prefixSum+=nums[i];\\n            int remain = prefixSum - target;\\n            if (map.containsKey(remain) && map.get(remain)>=availableIdx){\\n                res++;\\n                availableIdx=i;\\n            }\\n            map.put(prefixSum, i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780926,
                "title": "python-simple-presum-dict-greedy-solution-with-explaination-o-n",
                "content": "**Idea**\\nThe idea is similar to two-sum. \\n\\nWe maintain a `seen` dict and increment `ans` greedily. Once we found a valid subarray, we can reset the `seen` dict because all the subsequent valid subarrays are non-overlapping. Repeating this operation until we\\'ve iterated through the whole array.\\n\\n <br />\\n\\n**Complexity**\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(n)`\\n\\n<br />\\n\\n**Python**\\n```Python\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        presum = [0] * (n + 1)\\n        for i in range(n):\\n            presum[i+1] = presum[i] + nums[i]\\n            \\n        seen = {0: 0}\\n        ans = 0\\n        for i in range(1, n + 1):\\n            curr = presum[i]\\n            prev = curr - target\\n            if prev in seen:\\n                ans += 1\\n                seen = {}\\n            seen[curr] = i\\n        \\n        return ans\\n```\\n\\nWe can also do this in one-pass. The time and space complexities are the same.\\n```Python\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        seen = set([0])\\n        ans = curr = 0\\n\\t\\t\\n        for i, num in enumerate(nums):\\n            curr += num\\n            prev = curr - target\\n            if prev in seen:\\n                ans += 1\\n                seen = set()\\n            seen.add(curr)\\n        \\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        presum = [0] * (n + 1)\\n        for i in range(n):\\n            presum[i+1] = presum[i] + nums[i]\\n            \\n        seen = {0: 0}\\n        ans = 0\\n        for i in range(1, n + 1):\\n            curr = presum[i]\\n            prev = curr - target\\n            if prev in seen:\\n                ans += 1\\n                seen = {}\\n            seen[curr] = i\\n        \\n        return ans\\n```\n```Python\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        seen = set([0])\\n        ans = curr = 0\\n\\t\\t\\n        for i, num in enumerate(nums):\\n            curr += num\\n            prev = curr - target\\n            if prev in seen:\\n                ans += 1\\n                seen = set()\\n            seen.add(curr)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780885,
                "title": "c-similar-to-subarray-sum-equals-k-with-a-small-change",
                "content": "In question 560, we record how many times a sum appeared.\\nIn this one, there is no overlap.  So we can give up whatever was recorded before once we find that target could be made, because whatever was recorded before, will not be used in next section--to achieve the max number of sub-arrays.\\n\\n```\\nint maxNonOverlapping(vector<int>& nums, int target) {\\n        int res = 0, sum = 0;\\n        unordered_set<int> sets;\\n        sets.insert(0);\\n        for(int x : nums) {\\n            sum += x;\\n\\n            if(sets.count(sum - target)) {\\n                //restart, clear whatever was recorded\\n                ++res;\\n                sets= {0};\\n                sum = 0;\\n            } else{\\n                sets.insert(sum);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxNonOverlapping(vector<int>& nums, int target) {\\n        int res = 0, sum = 0;\\n        unordered_set<int> sets;\\n        sets.insert(0);\\n        for(int x : nums) {\\n            sum += x;\\n\\n            if(sets.count(sum - target)) {\\n                //restart, clear whatever was recorded\\n                ++res;\\n                sets= {0};\\n                sum = 0;\\n            } else{\\n                sets.insert(sum);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781047,
                "title": "java-greedy-approach-explained-hashmap-prefix-sum",
                "content": "**Steps** -\\nWe follow greedy approach here.\\n-  If we find a subarray with target sum, ending at index i, we count that subarray greedily. And we update last index to i.\\n- Next time, we make sure that we count subarray only when it starts after last index. \\n**Approach**\\nWe store all the sums seen so far in hashmap with key = sum, value = end index of subarray with that sum.\\n**Example -** \\n`[1,1,1,1,1]`, `target sum = 2`\\n1.` index = 0`, hashmap` [1 -> 0]`  *`sum 1 at index 0`*\\n2.` index = 1`, hashmap `[1 -> 0, 2 -> 1] `  *`sum 2 at index 1`*  \\nWe find that there is subarray with sum 2 ending at index 1. Hence we increment count and set` lastIndex = 1`\\n3. index = 2, hashmap [1 -> 0, 2 -> 1, 3 -> 2]  *`sum 3 at index 2`*\\nWe again find there is subarray with sum 3. \\nBut the start index is 0 {from hashmap}. So we cannot consider this sum, since our lastIndex is already 1. Which means that we have already counted subarray ending at index 1 and cannot again count subarray starting at index 0.\\n\\n*Also, another trick is that , we always consider smallest subarray with a particular sum.` map.put(sum, i)` This will override the a particular sum, if it already exists in map, so that we always consider the smallest subarray*\\n```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int sum = 0;\\n        int count = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        int lastIndex =-1;\\n\\t\\tfor (int i = 0; i<nums.length; i++) {\\n\\t\\t// calculate cumulative sum\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\t// check if there is subarray ending at index i & it starts after lastIndex\\n\\t\\t\\tif (map.containsKey(sum - target) && map.get(sum-target)>=lastIndex){\\n\\t\\t\\t\\tcount++;\\n                lastIndex = i;\\n            }\\n\\t\\t\\tmap.put(sum, i);\\n\\t\\t}\\n\\t\\treturn count;\\n\\n    }\\n}\\n```\\n\\n*Feel free to ask questions in comment section.Do upvote if you understood the solution*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int sum = 0;\\n        int count = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        int lastIndex =-1;\\n\\t\\tfor (int i = 0; i<nums.length; i++) {\\n\\t\\t// calculate cumulative sum\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\t// check if there is subarray ending at index i & it starts after lastIndex\\n\\t\\t\\tif (map.containsKey(sum - target) && map.get(sum-target)>=lastIndex){\\n\\t\\t\\t\\tcount++;\\n                lastIndex = i;\\n            }\\n\\t\\t\\tmap.put(sum, i);\\n\\t\\t}\\n\\t\\treturn count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780957,
                "title": "java-python-3-12-10-lines-prefix-sum-greedy-o-n-code-w-brief-explanation-and-analysis",
                "content": "**Q & A:**\\nQ1: Why do we have to only initialize seen = {0} only the first time?\\nA1: We need a `0` in the Set in case the prefix sum itself is equal to target; Whenever we find a subarray sums to `target`, we reset the `prefixSum` to `0` and the `seen` to an empty set, then we add the `prefixSum` to `seen`, into which we actually put a `0` ( `prefixSum == 0`).\\n**End of Q & A**\\n\\n\\n1. Loop through the array `nums`, calculate the prefix sum on the run;\\n2. Use a HashSet `seen` to check if any subarry sum to `target`; if yes, increase the counter `count`, reset the `prefixSum` to `0` and reset `seen` so that it contains only a single `0`.\\n3. Note: Initialize/reset the HashSet with a `0` in order to check if `prefixSum` itsef is equal to `target`.\\n\\n```java\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        Set<Integer> seen = new HashSet<>(Arrays.asList(0));\\n        int prefixSum = 0, count = 0;\\n        for (int num : nums) {\\n            prefixSum += num;\\n            if (seen.contains(prefixSum - target)) {\\n                ++count;\\n                prefixSum = 0;\\n                seen = new HashSet<>();\\n            }\\n            seen.add(prefixSum);\\n        }\\n        return count;\\n    }\\n```\\n```python\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        prefix_sum = count = 0\\n        seen = {0}\\n        for num in nums:\\n            prefix_sum += num\\n            if prefix_sum - target in seen:\\n                prefix_sum = 0\\n                count += 1\\n                seen = set()\\n            seen.add(prefix_sum)\\n        return count\\n```\\n\\nLooks like some prefer HashMap/Dict solution, here they are:\\n```java\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        Map<Integer, Integer> seen = new HashMap<>();\\n        seen.put(0, -1);\\n        int cnt = 0;\\n        for (int i = 0, prefixSum = 0, prevSubarrayEnd = -1; i < nums.length; ++i) {\\n            prefixSum += nums[i];\\n            if (seen.getOrDefault(prefixSum - target, -2) >= prevSubarrayEnd) {\\n                ++cnt;\\n                prevSubarrayEnd = i;\\n            }\\n            seen.put(prefixSum, i);\\n        }\\n        return cnt;\\n    }\\n```\\n```python\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        prefix_sum = count = 0\\n        prev_subarray_end = -1\\n        seen = {0 : -1}\\n        for i, num in enumerate(nums):\\n            prefix_sum += num\\n            if seen.get(prefix_sum - target, -2) >= prev_subarray_end:\\n                count += 1\\n                prev_subarray_end = i\\n            seen[prefix_sum] = i\\n        return count\\n```\\n**Analysis:**\\n\\nTime & space: O(n), where n = nums.length.",
                "solutionTags": [],
                "code": "```java\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        Set<Integer> seen = new HashSet<>(Arrays.asList(0));\\n        int prefixSum = 0, count = 0;\\n        for (int num : nums) {\\n            prefixSum += num;\\n            if (seen.contains(prefixSum - target)) {\\n                ++count;\\n                prefixSum = 0;\\n                seen = new HashSet<>();\\n            }\\n            seen.add(prefixSum);\\n        }\\n        return count;\\n    }\\n```\n```python\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        prefix_sum = count = 0\\n        seen = {0}\\n        for num in nums:\\n            prefix_sum += num\\n            if prefix_sum - target in seen:\\n                prefix_sum = 0\\n                count += 1\\n                seen = set()\\n            seen.add(prefix_sum)\\n        return count\\n```\n```java\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        Map<Integer, Integer> seen = new HashMap<>();\\n        seen.put(0, -1);\\n        int cnt = 0;\\n        for (int i = 0, prefixSum = 0, prevSubarrayEnd = -1; i < nums.length; ++i) {\\n            prefixSum += nums[i];\\n            if (seen.getOrDefault(prefixSum - target, -2) >= prevSubarrayEnd) {\\n                ++cnt;\\n                prevSubarrayEnd = i;\\n            }\\n            seen.put(prefixSum, i);\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        prefix_sum = count = 0\\n        prev_subarray_end = -1\\n        seen = {0 : -1}\\n        for i, num in enumerate(nums):\\n            prefix_sum += num\\n            if seen.get(prefix_sum - target, -2) >= prev_subarray_end:\\n                count += 1\\n                prev_subarray_end = i\\n            seen[prefix_sum] = i\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 780954,
                "title": "python-simple-solution-2-sum-variant",
                "content": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        ## RC ##\\n        ## APPROACH : HASHMAP - 2 SUM VARIANT ##\\n        lookup = {0 : -1}\\n        running_sum  = 0\\n        count = 0\\n        for i in range(len(nums)):\\n            running_sum += nums[i]\\n            if running_sum - target in lookup:\\n                count += 1\\n                lookup = {} #reset the map\\n            lookup[running_sum] = i\\n        return count\\n                \\n```\\nPLEASE UPVOTE IF YOU LIKE MY SOLUTION.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        ## RC ##\\n        ## APPROACH : HASHMAP - 2 SUM VARIANT ##\\n        lookup = {0 : -1}\\n        running_sum  = 0\\n        count = 0\\n        for i in range(len(nums)):\\n            running_sum += nums[i]\\n            if running_sum - target in lookup:\\n                count += 1\\n                lookup = {} #reset the map\\n            lookup[running_sum] = i\\n        return count\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 780973,
                "title": "c-o-n-greedy-easy-to-understand",
                "content": "Take Aways:\\nI am using the notion that :\\n\\n`prefix[i:j] = target`\\n`prefix[j] - prefix[i] = target`\\n`prefix[j] - target = prefix[i]`\\n\\nNow we can use hashmaps to store the index at which last `prefix[i]` was seen\\n`map<int, int> f // f[prefix[i]] = i`\\n\\nNow, for a `prefix[j]` if `prefix[j] - target` is found in the hashmap, we can use that as our valid interval `[i:j]`\\n\\nNow it\\'s just maximum disjoint interval problem which can be solved by sorting the array of intervals by their endpoints and greedily picking the intervals\\n\\nTime : `O(n)`\\n\\n```\\nclass Solution {\\npublic:\\n    static bool comp (pair<int, int> &a, pair<int, int> &b) {\\n        return a.second < b.second;\\n    }\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        map<int, int> f;\\n        int ctr = 0;\\n        f[0] = ctr;\\n        vector<pair<int, int>> ps;\\n        int pre = 0;\\n        for(int i=0; i<nums.size(); i++) {\\n            ctr++;\\n            pre += nums[i];\\n            // if prefix-target exists, make a new interval\\n            if (f.find(pre-target) != f.end()) {\\n                ps.push_back({f[pre-target], i});\\n            }\\n            // update pointer for the current prefix sum\\n            f[pre] = ctr;\\n        }\\n        int ans = 0;\\n        if (ps.size()) {\\n            // if there are valid intervals, always take the first one\\n            ans = 1;\\n            int r1 = ps[0].second;\\n            for(int i=1; i<ps.size(); i++) {\\n                int l = ps[i].first;\\n                int r2 = ps[i].second;\\n                if (l > r1) {\\n                    ans++;\\n                    r1 = r2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp (pair<int, int> &a, pair<int, int> &b) {\\n        return a.second < b.second;\\n    }\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        map<int, int> f;\\n        int ctr = 0;\\n        f[0] = ctr;\\n        vector<pair<int, int>> ps;\\n        int pre = 0;\\n        for(int i=0; i<nums.size(); i++) {\\n            ctr++;\\n            pre += nums[i];\\n            // if prefix-target exists, make a new interval\\n            if (f.find(pre-target) != f.end()) {\\n                ps.push_back({f[pre-target], i});\\n            }\\n            // update pointer for the current prefix sum\\n            f[pre] = ctr;\\n        }\\n        int ans = 0;\\n        if (ps.size()) {\\n            // if there are valid intervals, always take the first one\\n            ans = 1;\\n            int r1 = ps[0].second;\\n            for(int i=1; i<ps.size(); i++) {\\n                int l = ps[i].first;\\n                int r2 = ps[i].second;\\n                if (l > r1) {\\n                    ans++;\\n                    r1 = r2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782242,
                "title": "simple-java-prefix-sum-hashset",
                "content": "```\\npublic int maxNonOverlapping(int[] nums, int target) {\\n        int res=0;\\n        HashSet<Integer> preSum = new HashSet<>();\\n        preSum.add(0);\\n        int prev = 0;\\n        for(int i=0;i<nums.length;i++){\\n            int val = prev + nums[i];\\n            if(preSum.contains(val - target)){\\n                res++;\\n                preSum = new HashSet<>();\\n            }\\n            preSum.add(val);\\n            prev = val;\\n        }       \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\npublic int maxNonOverlapping(int[] nums, int target) {\\n        int res=0;\\n        HashSet<Integer> preSum = new HashSet<>();\\n        preSum.add(0);\\n        int prev = 0;\\n        for(int i=0;i<nums.length;i++){\\n            int val = prev + nums[i];\\n            if(preSum.contains(val - target)){\\n                res++;\\n                preSum = new HashSet<>();\\n            }\\n            preSum.add(val);\\n            prev = val;\\n        }       \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780966,
                "title": "python-in-8-lines-super-simple",
                "content": "Taking a walk through the array, if we can ever make the target, we might as well because we\\'d like the border for the last subarray to be as far left as possible for the next.  To see if we can make the target, we just take the total sum so far and see if we ever had the right previous total sum to chop off.  We also check that the chop point does not overlap another subarray end point we used.\\n\\n```\\ndef maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n    res = total = 0\\n    d, last = {0:-1}, -1\\n    for i,v in enumerate(nums):\\n        total += v\\n        if total - target in d and d[total - target] >= last: \\n            res += 1; last = i\\n        d[total] = i\\n    return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n    res = total = 0\\n    d, last = {0:-1}, -1\\n    for i,v in enumerate(nums):\\n        total += v\\n        if total - target in d and d[total - target] >= last: \\n            res += 1; last = i\\n        d[total] = i\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 780943,
                "title": "dp-o-n-code-with-detailed-comments",
                "content": "```\\nusing index = int;\\nclass Solution {\\n    // Dynamic programming problem, so answers of smaller subproblems will\\n    // be used to find answer of bigger problem.\\n    \\n    unordered_map<index, int> ans; // Keys are indices from 0 to n-1.\\n                                   // Stores the number of non-overlapping\\n                                   // subarrays of an array nums[0..i] with \\n                                   // target sum upto index.\\n                                   // So ans[n-1] is what we need at the end.\\n    unordered_map<int, index> m;   // Keys are cumulative sums from index 0 to\\n                                   // each index.\\n                                   // If sum of elements from index 0 to `i` \\n                                   // is S, then the map will store the key S\\n                                   // with value `i`.\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int n = nums.size();           // Total numbers.\\n        m[0] = -1;                     // If no elements are taken, 0 sum is still\\n                                       // still possible.\\n        ans[-1] = 0;                   // Number of subarrays without taking any\\n                                       // element is 0.\\n        int prefixSum = 0;             // Stores sum from 0th index.\\n        for (int i=0; i<n; i++) {      // For each index -\\n            prefixSum += nums[i]; \\n            ans[i] = ans[i-1];         // If no subarray ends at index `i` that has\\n                                       // the target sum, we can simply copy the answer\\n                                       // from previous index.\\n\\n            \\n            if (m.find(prefixSum-target) != m.end()) { // (prefixSum-target) exists in the map.\\n            /*\\n                E.g. If sum so far is 10 and target is 4, then if we find (10-4) = 6 in our\\n                map, then certainly there is exists a subarray that will have sum 4.\\n                This is because, we are storing the prefix sum in the map to begin with.\\n                We can get the index from the map and add the nonoverlapping subarrays\\n                with target sum before that index.\\n            */\\n                ans[i] = max(ans[i],                 \\n                             1 + ans[m[prefixSum-target]]); \\n            }\\n            m[prefixSum] = i; \\n        }\\n        return ans[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing index = int;\\nclass Solution {\\n    // Dynamic programming problem, so answers of smaller subproblems will\\n    // be used to find answer of bigger problem.\\n    \\n    unordered_map<index, int> ans; // Keys are indices from 0 to n-1.\\n                                   // Stores the number of non-overlapping\\n                                   // subarrays of an array nums[0..i] with \\n                                   // target sum upto index.\\n                                   // So ans[n-1] is what we need at the end.\\n    unordered_map<int, index> m;   // Keys are cumulative sums from index 0 to\\n                                   // each index.\\n                                   // If sum of elements from index 0 to `i` \\n                                   // is S, then the map will store the key S\\n                                   // with value `i`.\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int n = nums.size();           // Total numbers.\\n        m[0] = -1;                     // If no elements are taken, 0 sum is still\\n                                       // still possible.\\n        ans[-1] = 0;                   // Number of subarrays without taking any\\n                                       // element is 0.\\n        int prefixSum = 0;             // Stores sum from 0th index.\\n        for (int i=0; i<n; i++) {      // For each index -\\n            prefixSum += nums[i]; \\n            ans[i] = ans[i-1];         // If no subarray ends at index `i` that has\\n                                       // the target sum, we can simply copy the answer\\n                                       // from previous index.\\n\\n            \\n            if (m.find(prefixSum-target) != m.end()) { // (prefixSum-target) exists in the map.\\n            /*\\n                E.g. If sum so far is 10 and target is 4, then if we find (10-4) = 6 in our\\n                map, then certainly there is exists a subarray that will have sum 4.\\n                This is because, we are storing the prefix sum in the map to begin with.\\n                We can get the index from the map and add the nonoverlapping subarrays\\n                with target sum before that index.\\n            */\\n                ans[i] = max(ans[i],                 \\n                             1 + ans[m[prefixSum-target]]); \\n            }\\n            m[prefixSum] = i; \\n        }\\n        return ans[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783391,
                "title": "c-beats-100-subs-in-time",
                "content": "```\\nint maxNonOverlapping(vector<int>& nums, int target) {\\n        int res = 0;\\n        int endIndex = -1;\\n        int sum = 0;\\n        unordered_map<int,int> map;\\n        map[0] = 0;\\n        for(int i = 1; i <= nums.size(); i++){\\n            sum += nums[i - 1];\\n            if(map.count(sum - target)){\\n                int index = map[sum - target];\\n                if(index >= endIndex){\\n                    res++;\\n                    endIndex = i;\\n                }\\n            }\\n            map[sum] = i;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nint maxNonOverlapping(vector<int>& nums, int target) {\\n        int res = 0;\\n        int endIndex = -1;\\n        int sum = 0;\\n        unordered_map<int,int> map;\\n        map[0] = 0;\\n        for(int i = 1; i <= nums.size(); i++){\\n            sum += nums[i - 1];\\n            if(map.count(sum - target)){\\n                int index = map[sum - target];\\n                if(index >= endIndex){\\n                    res++;\\n                    endIndex = i;\\n                }\\n            }\\n            map[sum] = i;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780986,
                "title": "c-o-n-prefixsum",
                "content": "```\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int, int> m;\\n        m[0] = -1;\\n        int res = 0;\\n        int sum = 0;\\n        int prev = -1;\\n        for(int i =0; i < nums.size(); ++i)\\n        {\\n            sum += nums[i];\\n            if(m.count(sum-target) && m[sum-target]+1 > prev)\\n            {\\n                res++;\\n                prev = i;\\n            }\\n            m[sum]=i;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int, int> m;\\n        m[0] = -1;\\n        int res = 0;\\n        int sum = 0;\\n        int prev = -1;\\n        for(int i =0; i < nums.size(); ++i)\\n        {\\n            sum += nums[i];\\n            if(m.count(sum-target) && m[sum-target]+1 > prev)\\n            {\\n                res++;\\n                prev = i;\\n            }\\n            m[sum]=i;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1496413,
                "title": "c-hashmap-efficient-solution",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int , int> mp;\\n        int sum = 0, ans = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            sum += nums[i];  // summing up the current element\\n            if(mp.find(sum - target )!= mp.end()){ // if target sum is Found\\n                ans+= 1; //increament the result\\n                mp.clear(); // clear the map (as the sum is useless , as it will create overlapping sum)\\n                sum = 0; //make current sum = 0;\\n            }\\n            else if(sum == target){ //if sum is equal to target\\n                sum = 0; \\n                ans+= 1;\\n                mp.clear();\\n            }\\n            else{\\n                mp[sum]++; // else store the sum\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int , int> mp;\\n        int sum = 0, ans = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            sum += nums[i];  // summing up the current element\\n            if(mp.find(sum - target )!= mp.end()){ // if target sum is Found\\n                ans+= 1; //increament the result\\n                mp.clear(); // clear the map (as the sum is useless , as it will create overlapping sum)\\n                sum = 0; //make current sum = 0;\\n            }\\n            else if(sum == target){ //if sum is equal to target\\n                sum = 0; \\n                ans+= 1;\\n                mp.clear();\\n            }\\n            else{\\n                mp[sum]++; // else store the sum\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313429,
                "title": "python-easy-beats-100",
                "content": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        f={}\\n        f[0]=1;s=0;ans=0\\n        for j in nums:\\n            s+=j\\n            if s-target in f:ans+=1;f={}\\n            f[s]=1\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        f={}\\n        f[0]=1;s=0;ans=0\\n        for j in nums:\\n            s+=j\\n            if s-target in f:ans+=1;f={}\\n            f[s]=1\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131199,
                "title": "python-one-pass-solution-easy-understanding",
                "content": "class Solution:\\n\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        prefix = 0\\n        cum = 0\\n        s = set([0])\\n        for i in range(len(nums)):\\n            prefix+=nums[i]\\n            if prefix-target in s:\\n                cum+=1\\n                prefix = 0\\n                s = set([0])\\n            s.add(prefix) # we must add prefix at the end, in order to deal with target == 0\\n        return cum",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        prefix = 0\\n        cum = 0\\n        s = set([0])\\n        for i in range(len(nums)):\\n            prefix+=nums[i]\\n            if prefix-target in s:\\n                cum+=1\\n                prefix = 0\\n                s = set([0])\\n            s.add(prefix) # we must add prefix at the end, in order to deal with target == 0\\n        return cum",
                "codeTag": "Java"
            },
            {
                "id": 781234,
                "title": "c-o-n-time-o-n-space-using-hashset",
                "content": "```csharp\\npublic int MaxNonOverlapping(int[] nums, int target)\\n{\\n\\tHashSet<int> visited = new HashSet<int>() { 0 };\\n\\tint result = 0;            \\n\\tint sum = 0;\\n\\n\\tforeach(int num in nums)\\n\\t{\\n\\t\\tsum += num;\\n\\n\\t\\tif (visited.Contains(sum - target))\\n\\t\\t{\\n\\t\\t\\tresult++;\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tvisited.Clear();\\n\\t\\t}\\n\\n\\t\\tvisited.Add(sum);\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MaxNonOverlapping(int[] nums, int target)\\n{\\n\\tHashSet<int> visited = new HashSet<int>() { 0 };\\n\\tint result = 0;            \\n\\tint sum = 0;\\n\\n\\tforeach(int num in nums)\\n\\t{\\n\\t\\tsum += num;\\n\\n\\t\\tif (visited.Contains(sum - target))\\n\\t\\t{\\n\\t\\t\\tresult++;\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tvisited.Clear();\\n\\t\\t}\\n\\n\\t\\tvisited.Add(sum);\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3337017,
                "title": "python-3-10-lines-prefix-sum-w-example-t-m-97-61",
                "content": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n\\n        d, ans = defaultdict(list), 0                   #  Example: nums = [2,2,5,2,5,9,4] target = 9       \\n\\n        pref = enumerate(accumulate(nums, initial = 0)) #           pref = [(0, 0),(1, 2),(2, 4),(3, 9),\\n                                                        #                   (4,11),(5,16),(6,25),(7,29)]\\n \\n        for i, num in pref:                             #    i   num  comp   d          ans\\n            comp = num - target                         #   \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013         \\u2013\\u2013\\u2013 \\n                                                        #    0    0   -9     {0:0}           0\\n            if comp in d:                               #    1    2   -7     {0:0,2:1}       0\\n                ans += 1                                #    2    4   -5     {0:0,2:1,4:2}   0 \\n                d.clear()                               #    3    9    0     {9:3}           1 <-[2,2,5]\\n                                                        #    4   11    2     {9:3,11:4}      1\\n            d[num] = i                                  #    5   16    7     {9:3,11:4,16:5} 1  \\n                                                        #    6   25   16     {25:6}          2 <-[9]\\n        return ans                                      #    7   29   20     {25:6, 29:7}    2 <----------return\\n\\n```\\n[https://leetcode.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/submissions/921465408/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n\\n        d, ans = defaultdict(list), 0                   #  Example: nums = [2,2,5,2,5,9,4] target = 9       \\n\\n        pref = enumerate(accumulate(nums, initial = 0)) #           pref = [(0, 0),(1, 2),(2, 4),(3, 9),\\n                                                        #                   (4,11),(5,16),(6,25),(7,29)]\\n \\n        for i, num in pref:                             #    i   num  comp   d          ans\\n            comp = num - target                         #   \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013         \\u2013\\u2013\\u2013 \\n                                                        #    0    0   -9     {0:0}           0\\n            if comp in d:                               #    1    2   -7     {0:0,2:1}       0\\n                ans += 1                                #    2    4   -5     {0:0,2:1,4:2}   0 \\n                d.clear()                               #    3    9    0     {9:3}           1 <-[2,2,5]\\n                                                        #    4   11    2     {9:3,11:4}      1\\n            d[num] = i                                  #    5   16    7     {9:3,11:4,16:5} 1  \\n                                                        #    6   25   16     {25:6}          2 <-[9]\\n        return ans                                      #    7   29   20     {25:6, 29:7}    2 <----------return\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331129,
                "title": "beats-100-other-s-solutions",
                "content": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        ans, s = 0, 0\\n        sumset = set()\\n        sumset.add(0)\\n        for i in nums:\\n            s += i\\n            if (s-target) in sumset:\\n                ans += 1\\n                s = 0\\n                sumset.clear()\\n                sumset.add(0)\\n            else:\\n                sumset.add(s)\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        ans, s = 0, 0\\n        sumset = set()\\n        sumset.add(0)\\n        for i in nums:\\n            s += i\\n            if (s-target) in sumset:\\n                ans += 1\\n                s = 0\\n                sumset.clear()\\n                sumset.add(0)\\n            else:\\n                sumset.add(s)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854406,
                "title": "c-prefix-sum-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n         int ans = 0;\\n         set<int> st;\\n         st.insert(0);\\n         int ps = 0;\\n         for(int a : nums){\\n             ps += a;\\n             if(st.find(ps - target) != st.end()){\\n                 ans++;\\n                 st.clear();\\n                 ps = 0;\\n             }\\n               st.insert(ps);\\n         }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n         int ans = 0;\\n         set<int> st;\\n         st.insert(0);\\n         int ps = 0;\\n         for(int a : nums){\\n             ps += a;\\n             if(st.find(ps - target) != st.end()){\\n                 ans++;\\n                 st.clear();\\n                 ps = 0;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1506691,
                "title": "c-easy-to-understand-linear-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int count=0,sum=0,end=-1;\\n        unordered_map<int,int> mp;\\n        mp[0]=-1;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n           sum+=nums[j];\\n            if(mp.find(sum-target)!=mp.end()&&mp[sum-target]>=end)\\n            {\\n                count++;\\n                end=j;\\n            }\\n            mp[sum]=j;\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int count=0,sum=0,end=-1;\\n        unordered_map<int,int> mp;\\n        mp[0]=-1;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n           sum+=nums[j];\\n            if(mp.find(sum-target)!=mp.end()&&mp[sum-target]>=end)\\n            {\\n                count++;\\n                end=j;\\n            }\\n            mp[sum]=j;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103707,
                "title": "c-faster-than-99",
                "content": "This is just an ordinary O(n) solution, for some reason it\\'s faster than 99%.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_set<int> s;\\n        \\n        int sum = 0, i = 0;\\n        \\n        int ans = 0;\\n        while(i < nums.size()) {\\n            sum += nums[i];\\n            if(s.count(sum - target) || sum == target) {\\n                ans++;\\n                sum = 0;\\n                s.clear();\\n            } else {\\n                s.insert(sum);\\n            }\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_set<int> s;\\n        \\n        int sum = 0, i = 0;\\n        \\n        int ans = 0;\\n        while(i < nums.size()) {\\n            sum += nums[i];\\n            if(s.count(sum - target) || sum == target) {\\n                ans++;\\n                sum = 0;\\n                s.clear();\\n            } else {\\n                s.insert(sum);\\n            }\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781967,
                "title": "java-prefix-sum-map-o-n",
                "content": "We iterate through the array and aompute the prefix sum and calculate which sum we need to have in previous steps.\\n\\nIf we have that sum in past we get its index and compare with previous subarray range that we had (`prev` index). \\n\\nIn the beggining `prev = -1` which means we do not have any subarray for now, then when we find that subarray we update its value equal to the end index of that range. \\n\\nAnd at each subarray which we found we compare the beggining of new range `index` wih the end index of the last range `prev` and if `index` >= `prev` we increment our answer.\\n```\\nclass Solution {\\n    public int maxNonOverlapping(int[] a, int t) {\\n        int prev = -1;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        int sum = 0;\\n        int count = 0;\\n        for(int i = 0; i < a.length; i++) {\\n            sum+=a[i];\\n            int need = sum - t;\\n            if (map.containsKey(need)) {\\n                int index = map.get(need);\\n                if (index >= prev) {\\n                    prev = i;\\n                    count++;\\n                }\\n            }\\n            map.put(sum,i);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] a, int t) {\\n        int prev = -1;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        int sum = 0;\\n        int count = 0;\\n        for(int i = 0; i < a.length; i++) {\\n            sum+=a[i];\\n            int need = sum - t;\\n            if (map.containsKey(need)) {\\n                int index = map.get(need);\\n                if (index >= prev) {\\n                    prev = i;\\n                    count++;\\n                }\\n            }\\n            map.put(sum,i);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781168,
                "title": "javascript-clean-o-n-solution",
                "content": "```javascript\\nvar maxNonOverlapping = function(nums, target) {\\n    const seen = new Set();\\n    let total = 0, result = 0;\\n    \\n    for(let n of nums) {\\n        total += n;\\n        \\n        if(total === target || seen.has(total - target)) {\\n            total = 0;\\n            result++;\\n            seen.clear()\\n        } else seen.add(total)\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar maxNonOverlapping = function(nums, target) {\\n    const seen = new Set();\\n    let total = 0, result = 0;\\n    \\n    for(let n of nums) {\\n        total += n;\\n        \\n        if(total === target || seen.has(total - target)) {\\n            total = 0;\\n            result++;\\n            seen.clear()\\n        } else seen.add(total)\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781127,
                "title": "java-greedy-prefix-sum-hashset-o-n-easy-to-understand",
                "content": "This solution is similar to figure out any subArray with target sum. Addition thing is to find maximum such subarray. \\nWe can go with greedy by collecting smallest subarray with targetSum, and all such small subarray count will always be maximum.\\n\\nExample to find single subArray with targetSum:\\n`[-2,6,6,3,5,4,1,2,8]` \\npreSum array: `[-2, 4, 10, 13, 18, 22, 23, 25, 33]`\\n\\nIf you can store all previous seen preSum, it\\'s easy to see if targetSum can be achieved by just checking if `preSum-target` exist in set. To store previous seen, i used hashSet.\\n\\ni.e. when i = 6 (a[i] = 1, presum = 23) , i check if preSum-target (13) exist in set, since 13 already exist in set, subArray `5,4,1` can make to targetSum.\\n\\nThis was idea behind finding out single subArray. For maximum subarray, there are three targetSum subarray\\n`[-2,6,6]` \\n`[5,4,1]`\\n`[2,8]`\\n\\nThat means when ever i see first targetSum array `[-2,6,6]`, i found one subArray, now imagine that i don\\'t have my previous elements at all in array, or array is splitted in to two half.\\n`[-2,6,6 ||| 3,5,4,1,2,8]` -> from this point onwards i just had to search targetSum subarray in `[3,5,4,1,2,8]` array.\\n\\nThat means when ever i see first targetSum array `[5,4,1]`, i collect and split my input array from here\\n`[-2,6,6 ||| 3,5,4,1, ||| 2,8]`\\nSince expectation is to just collect count, everytime i just increase `ans` variable.\\n\\n```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int ans = 0; int preSum = 0;\\n        \\n        Set<Integer> set = new HashSet<>();\\n        set.add(0);\\n        \\n        for (int i = 0; i< nums.length; i++) {\\n            preSum += nums[i];\\n            if (set.contains(preSum-target)) {\\n\\t\\t\\t\\t//Since we one subArray, clear all previous values to have fresh start\\n                set.clear(); set.add(0);  \\n                preSum=0;\\n                ans++;\\n            }\\n            set.add(preSum);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int ans = 0; int preSum = 0;\\n        \\n        Set<Integer> set = new HashSet<>();\\n        set.add(0);\\n        \\n        for (int i = 0; i< nums.length; i++) {\\n            preSum += nums[i];\\n            if (set.contains(preSum-target)) {\\n\\t\\t\\t\\t//Since we one subArray, clear all previous values to have fresh start\\n                set.clear(); set.add(0);  \\n                preSum=0;\\n                ans++;\\n            }\\n            set.add(preSum);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268933,
                "title": "python-o-n-prefix-sum-greedy",
                "content": "```\\n#Baraa\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        seen = set()\\n        current_sum = 0\\n        count = 0\\n        n = len(nums)\\n        for i in range(n):\\n            current_sum += nums[i]\\n            #if the sum until this point is equal to target we take it\\n            #reset current_sum and seen set to not overlap\\n            if current_sum == target:\\n                count += 1\\n                current_sum = 0\\n                seen = set()\\n            #if there is some subarray previously that has summation that if we delete\\n            #we can obtain the target then we increment\\n            #once this is taken we reset seen summations as we do not want to overlap\\n            #also reset current_sum\\n            elif current_sum - target in seen:\\n                count += 1\\n                current_sum = 0\\n                seen = set()\\n            seen.add(current_sum)\\n        return count\\n               \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n#Baraa\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        seen = set()\\n        current_sum = 0\\n        count = 0\\n        n = len(nums)\\n        for i in range(n):\\n            current_sum += nums[i]\\n            #if the sum until this point is equal to target we take it\\n            #reset current_sum and seen set to not overlap\\n            if current_sum == target:\\n                count += 1\\n                current_sum = 0\\n                seen = set()\\n            #if there is some subarray previously that has summation that if we delete\\n            #we can obtain the target then we increment\\n            #once this is taken we reset seen summations as we do not want to overlap\\n            #also reset current_sum\\n            elif current_sum - target in seen:\\n                count += 1\\n                current_sum = 0\\n                seen = set()\\n            seen.add(current_sum)\\n        return count\\n               \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201894,
                "title": "c-well-explained-o-n-prefix-sum-dry-run",
                "content": "we will just use prefix sum , and store the running sum along with the index in the map, just a slight variation from the normal subarray sum equals k question ,  here we will use end variable which will indicate the last subarray \\'s last index so that we will only count non repeated subarrays .\\n\\npls dive into  the code first and then try to understand the dry run\\n\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int sum=0;\\n        int count=0;\\n        unordered_map<int,int> m;\\n        \\n        m[0]=-1;\\n        int end=-1;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            sum+=nums[i];\\n            int need = sum - target;\\n            \\n            if(m.count(need) && m[need]>=end){\\n                count++;\\n                end=i;\\n            \\n            }\\n            \\n            m[sum]=i;\\n            \\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/876e0bc1-1bf8-405d-a0d3-39a2c20e0982_1656267494.8578818.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int sum=0;\\n        int count=0;\\n        unordered_map<int,int> m;\\n        \\n        m[0]=-1;\\n        int end=-1;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            sum+=nums[i];\\n            int need = sum - target;\\n            \\n            if(m.count(need) && m[need]>=end){\\n                count++;\\n                end=i;\\n            \\n            }\\n            \\n            m[sum]=i;\\n            \\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969040,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Unordered MAp***\\n\\n* ***Time Complexity :  O(N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        \\n        int n = nums.size();\\n        \\n        int curr_sum = 0;\\n        \\n        int count = 0;\\n        \\n        int end = -1;\\n        \\n        unordered_map<int, int> mp;\\n        \\n        mp[0] = -1;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            curr_sum += nums[i];\\n            \\n            int need = curr_sum - target;\\n            \\n            if(mp.count(need) && mp[need] >= end)\\n            {\\n                count++;\\n                \\n                end = i;\\n            }\\n            \\n            mp[curr_sum] = i;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        \\n        int n = nums.size();\\n        \\n        int curr_sum = 0;\\n        \\n        int count = 0;\\n        \\n        int end = -1;\\n        \\n        unordered_map<int, int> mp;\\n        \\n        mp[0] = -1;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            curr_sum += nums[i];\\n            \\n            int need = curr_sum - target;\\n            \\n            if(mp.count(need) && mp[need] >= end)\\n            {\\n                count++;\\n                \\n                end = i;\\n            }\\n            \\n            mp[curr_sum] = i;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234767,
                "title": "c-solution-using-map-and-prefix-sum-fully-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n      int count=0;//will store fina\\n      int next_index=-1;//storing next imdex\\n      int curr_sum=0;//storing prefix sum\\n      unordered_map<int,int>mymap;//to store indices of preffix sum \\n      mymap[0]=-1;\\n      for(int i=0;i<nums.size();i++)\\n      {\\n        curr_sum+=nums[i];\\n        //cehck if subarray is present or not\\n        if(mymap.find(curr_sum-target)!=mymap.end()&&mymap[curr_sum-target]>=next_index)\\n        {\\n          count++;//increase count\\n          next_index=i;//update next_index\\n        }mymap[curr_sum]=i;//update map with the current sum and current index\\n      }return count;\\n    }\\n};\\ndo upvote if you find it useful\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n      int count=0;//will store fina\\n      int next_index=-1;//storing next imdex\\n      int curr_sum=0;//storing prefix sum\\n      unordered_map<int,int>mymap;//to store indices of preffix sum \\n      mymap[0]=-1;\\n      for(int i=0;i<nums.size();i++)\\n      {\\n        curr_sum+=nums[i];\\n        //cehck if subarray is present or not\\n        if(mymap.find(curr_sum-target)!=mymap.end()&&mymap[curr_sum-target]>=next_index)\\n        {\\n          count++;//increase count\\n          next_index=i;//update next_index\\n        }mymap[curr_sum]=i;//update map with the current sum and current index\\n      }return count;\\n    }\\n};\\ndo upvote if you find it useful\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979387,
                "title": "why-greedy-works",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int> &v, int trg) {\\n       \\n    /*  Why greedy Works\\n        [-----A-----[--]--B-]  [--C--] [--D--] [--E--]\\n        Lets assume A grows slowly and achive trg is a long time\\n        Now assuming approach isnt greedy and skip taking A instead lets take B which is shorter thus giving \\n        more possiblities for no. of subarrays\\n        If this happens we get B C D ie ct=3\\n        If we had taken A instead then it would have finished up at earlier indx than B\\'s end idx\\n        and thus providing even better chances of higher count\\n    */      \\n        unordered_map<int,int> mp;\\n        int i,sm,n,ct,r,p;\\n        ct=0;\\n        r=-1;\\n        sm=0;\\n        n=v.size();\\n        for(i=0;i<n;i++)\\n        {\\n           sm+=v[i];\\n           p=mp[sm-trg]-1;\\n             if((sm==trg&&r==-1)||(p>=r&&p+1!=0))\\n             {\\n                 ct++;\\n                 r=i;\\n             }          \\n            mp[sm]=i+1;\\n        }\\n          return ct;\\n    }   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int> &v, int trg) {\\n       \\n    /*  Why greedy Works\\n        [-----A-----[--]--B-]  [--C--] [--D--] [--E--]\\n        Lets assume A grows slowly and achive trg is a long time\\n        Now assuming approach isnt greedy and skip taking A instead lets take B which is shorter thus giving \\n        more possiblities for no. of subarrays\\n        If this happens we get B C D ie ct=3\\n        If we had taken A instead then it would have finished up at earlier indx than B\\'s end idx\\n        and thus providing even better chances of higher count\\n    */      \\n        unordered_map<int,int> mp;\\n        int i,sm,n,ct,r,p;\\n        ct=0;\\n        r=-1;\\n        sm=0;\\n        n=v.size();\\n        for(i=0;i<n;i++)\\n        {\\n           sm+=v[i];\\n           p=mp[sm-trg]-1;\\n             if((sm==trg&&r==-1)||(p>=r&&p+1!=0))\\n             {\\n                 ct++;\\n                 r=i;\\n             }          \\n            mp[sm]=i+1;\\n        }\\n          return ct;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874794,
                "title": "python-faster-than-99-5-simple-prefix-sum-explanation",
                "content": "LOGIC:\\nwe have to traverse the array and   maintain a running sum .\\nwe will store the running sum in a dictionary \\nwhenever an valid subarray is found, reset the dictionary to avoid overlapping subarray\\n\\nTime complexity: O(n)\\n\\n\\n\\'\\'\\'\\n\\n     def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n              dict={0:1};count=0\\n              runningsum=0\\n              for num in nums:\\n                runningsum+=num   # running sum\\n                prevsum=runningsum-target\\n\\t\\t\\t\\t# check whether the prevsum has already occured , if occured then it is a valid subarray\\n                if prevsum in dict: \\n                    count+=1    \\n                    dict={0:1}  # reset the dictionary to avoid overlapping subarray\\n                    runningsum=0  # reset runningsum to 0 to start from next number\\n                else:\\n                    dict[runningsum]=1  #store runningsum in the dictionary\\n              return count\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "LOGIC:\\nwe have to traverse the array and   maintain a running sum .\\nwe will store the running sum in a dictionary \\nwhenever an valid subarray is found, reset the dictionary to avoid overlapping subarray\\n\\nTime complexity: O(n)\\n\\n\\n\\'\\'\\'\\n\\n     def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n              dict={0:1};count=0\\n              runningsum=0\\n              for num in nums:\\n                runningsum+=num   # running sum\\n                prevsum=runningsum-target\\n\\t\\t\\t\\t# check whether the prevsum has already occured , if occured then it is a valid subarray\\n                if prevsum in dict: \\n                    count+=1    \\n                    dict={0:1}  # reset the dictionary to avoid overlapping subarray\\n                    runningsum=0  # reset runningsum to 0 to start from next number\\n                else:\\n                    dict[runningsum]=1  #store runningsum in the dictionary\\n              return count\\n\\t\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 802650,
                "title": "concise-python-solution",
                "content": "m is a map from a prefix sum to the latest index with that sum, and j is the minimum valid index for a new interval\\n```\\ndef maxNonOverlapping(self, a: List[int], t: int) -> int:\\n\\tans, m, j, cur = 0, {0:-1}, -1, 0            \\n\\tfor i, x in enumerate(a):\\n\\t\\tcur += x\\n\\t\\tk = cur - t            \\n\\t\\tif k in m and m[k] >= j:\\n\\t\\t\\tans += 1; j = i \\n\\t\\tm[cur] = i\\n\\treturn ans",
                "solutionTags": [],
                "code": "m is a map from a prefix sum to the latest index with that sum, and j is the minimum valid index for a new interval\\n```\\ndef maxNonOverlapping(self, a: List[int], t: int) -> int:\\n\\tans, m, j, cur = 0, {0:-1}, -1, 0            \\n\\tfor i, x in enumerate(a):\\n\\t\\tcur += x\\n\\t\\tk = cur - t            \\n\\t\\tif k in m and m[k] >= j:\\n\\t\\t\\tans += 1; j = i \\n\\t\\tm[cur] = i\\n\\treturn ans",
                "codeTag": "Python3"
            },
            {
                "id": 786169,
                "title": "java-recursive-memoization-dp-approach",
                "content": "```\\n- Each of the numbers can be the start of a subarray\\n- If we have found a subarray from i -> j that contains a subarray sum of target\\n\\t- Then our next subarray sum will start from \\'j + 1\\'\\n- Since, there may be multiple subarrays that gives us the target sum\\n\\t- We will want to pick the choice that will give us the maximum number of non-overlapping subarrays\\n```\\n```\\npublic class MaximumNonOverlappingSubarrayWithTargetSumRecursiveApproach {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        return maxNonOverlapping(0, nums, target);\\n    }\\n\\n    private int maxNonOverlapping(int start, int[] nums, int target) {\\n        if (start >= nums.length) return 0;\\n\\n        int maxNonOverlap = 0, sum = 0;\\n\\n        for (int i = start; i < nums.length; i++) {\\n            sum += nums[i];\\n            maxNonOverlap = Math.max(maxNonOverlap, maxNonOverlapping(i + 1, nums, target) + (sum == target ? 1 : 0));\\n\\n            if (sum == target) break;\\n        }\\n\\n        return maxNonOverlap;\\n    }\\n}\\n```\\n```\\npublic class MaximumNonOverlappingSubarrayWithTargetSumMemoizationApproach {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int[] memo = new int[nums.length];\\n        Arrays.fill(memo, -1);\\n        return maxNonOverlapping(0, nums, target, memo);\\n    }\\n\\n    private int maxNonOverlapping(int start, int[] nums, int target, int[] memo) {\\n        if (start >= nums.length) return 0;\\n        if (memo[start] >= 0) return memo[start];\\n\\n        int maxNonOverlap = 0, sum = 0;\\n\\n        for (int i = start; i < nums.length; i++) {\\n            sum += nums[i];\\n            maxNonOverlap = Math.max(maxNonOverlap, maxNonOverlapping(i + 1, nums, target, memo) + (sum == target ? 1 : 0));\\n\\n            if (sum == target) break;\\n        }\\n\\n        memo[start] = maxNonOverlap;\\n        return maxNonOverlap;\\n    }\\n}\\n```\\n```\\n- We will need a quick way to check the current subarray contains our target sum\\n\\t- We can use prefix sum\\n\\t\\t- If our current running sum if equal to \\'x\\' and we have our \\'target\\'\\n\\t\\t\\t- We know we have a subarray of sum \\'target\\' if the prefix sum \\'x - target\\' exists\\n- We can keep track of all of the previous prefix sums and also the maximum non-overlapping subarray\\n  count at the prefix sum\\n\\t- Then if our current prefix sum is equal to \\'x\\' and \\'x - target\\' exists\\n\\t\\t- We can increment 1 to the maximum non-overlapping subarray at \\'x - target\\' to account for the\\n\\t\\t  current non-overlapping subarray\\n\\n```\\n```\\npublic class MaximumNonOverlappingSubarrayWithTargetSumDPApproach {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 0);\\n        int sum = 0, maxOverlaps = 0;\\n\\n        for (int num: nums) {\\n            sum += num;\\n\\n            if (map.containsKey(sum - target)) {\\n                maxOverlaps = Math.max(maxOverlaps, map.get(sum - target) + 1);\\n            }\\n\\n            map.put(sum, maxOverlaps);\\n        }\\n\\n        return maxOverlaps;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n- Each of the numbers can be the start of a subarray\\n- If we have found a subarray from i -> j that contains a subarray sum of target\\n\\t- Then our next subarray sum will start from \\'j + 1\\'\\n- Since, there may be multiple subarrays that gives us the target sum\\n\\t- We will want to pick the choice that will give us the maximum number of non-overlapping subarrays\\n```\n```\\npublic class MaximumNonOverlappingSubarrayWithTargetSumRecursiveApproach {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        return maxNonOverlapping(0, nums, target);\\n    }\\n\\n    private int maxNonOverlapping(int start, int[] nums, int target) {\\n        if (start >= nums.length) return 0;\\n\\n        int maxNonOverlap = 0, sum = 0;\\n\\n        for (int i = start; i < nums.length; i++) {\\n            sum += nums[i];\\n            maxNonOverlap = Math.max(maxNonOverlap, maxNonOverlapping(i + 1, nums, target) + (sum == target ? 1 : 0));\\n\\n            if (sum == target) break;\\n        }\\n\\n        return maxNonOverlap;\\n    }\\n}\\n```\n```\\npublic class MaximumNonOverlappingSubarrayWithTargetSumMemoizationApproach {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int[] memo = new int[nums.length];\\n        Arrays.fill(memo, -1);\\n        return maxNonOverlapping(0, nums, target, memo);\\n    }\\n\\n    private int maxNonOverlapping(int start, int[] nums, int target, int[] memo) {\\n        if (start >= nums.length) return 0;\\n        if (memo[start] >= 0) return memo[start];\\n\\n        int maxNonOverlap = 0, sum = 0;\\n\\n        for (int i = start; i < nums.length; i++) {\\n            sum += nums[i];\\n            maxNonOverlap = Math.max(maxNonOverlap, maxNonOverlapping(i + 1, nums, target, memo) + (sum == target ? 1 : 0));\\n\\n            if (sum == target) break;\\n        }\\n\\n        memo[start] = maxNonOverlap;\\n        return maxNonOverlap;\\n    }\\n}\\n```\n```\\n- We will need a quick way to check the current subarray contains our target sum\\n\\t- We can use prefix sum\\n\\t\\t- If our current running sum if equal to \\'x\\' and we have our \\'target\\'\\n\\t\\t\\t- We know we have a subarray of sum \\'target\\' if the prefix sum \\'x - target\\' exists\\n- We can keep track of all of the previous prefix sums and also the maximum non-overlapping subarray\\n  count at the prefix sum\\n\\t- Then if our current prefix sum is equal to \\'x\\' and \\'x - target\\' exists\\n\\t\\t- We can increment 1 to the maximum non-overlapping subarray at \\'x - target\\' to account for the\\n\\t\\t  current non-overlapping subarray\\n\\n```\n```\\npublic class MaximumNonOverlappingSubarrayWithTargetSumDPApproach {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 0);\\n        int sum = 0, maxOverlaps = 0;\\n\\n        for (int num: nums) {\\n            sum += num;\\n\\n            if (map.containsKey(sum - target)) {\\n                maxOverlaps = Math.max(maxOverlaps, map.get(sum - target) + 1);\\n            }\\n\\n            map.put(sum, maxOverlaps);\\n        }\\n\\n        return maxOverlaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784512,
                "title": "c-greedy-prefix-sums-explained-with-intuition",
                "content": "**Basic Intuition**\\n* Look Its Likely to have few continous subarray that are not supposed to be intersecting and should match the target value as the total Sum\\n* A classic defination : subarray sum is just the difference between two prefix sum \\n* I get a match if pref[j] - pref[i] = n for j > i , therefore pref[i] = pref[j] - n\\n* Now this is where Greedy comes into the picture that I get a match of pref[i] for the current pref[j], then lets make this subarray and then say that I cannot use any prefix sum till this j idx (or else further subarrays would intersect with the current one)\\n* But what if we get continous occurance of same prefix sum, then I am greedily claiming that the last occurance of this prefix sum if always best to have (cuz the length of subarray doesnt matter only count does)\\n* So the whole problem boils down the storing the last occurances of the prefix sums and each time u get a match and that match is after the last subarray you made lets make this one too and update my last subarray as this one \\n\\n**Explaining the implementation**\\n* Have a unordered Map for storing the last occurance of prefix sums  \\n* Updating prefix[0] = -1 (empty prefix)\\n* Have a r variable that would let me know that what is the range I am not supposed to use\\n* greedy if i get a match for this pos i, update the r, update the ans and move forward\\n* Anyways, updating the last occurance of the current prefix sum\\n\\nHappy Coding ^_^\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> pref;\\n\\t\\n    int maxNonOverlapping(vector<int>& a, int target) {\\n\\t\\tint n = a.size();\\n\\t\\tint sum = 0, ans = 0, r = -1;\\n\\t\\tpref[0] = -1;\\n        \\t\\t\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\tsum += a[i];\\n\\t\\t\\tif (pref.count(sum - target) and pref[sum - target] >= r) \\n\\t\\t\\t\\tans++, r = i;\\n\\t\\t\\tpref[sum] = i;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    unordered_map<int, int> pref;\\n\\t\\n    int maxNonOverlapping(vector<int>& a, int target) {\\n\\t\\tint n = a.size();\\n\\t\\tint sum = 0, ans = 0, r = -1;\\n\\t\\tpref[0] = -1;\\n        \\t\\t\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\tsum += a[i];\\n\\t\\t\\tif (pref.count(sum - target) and pref[sum - target] >= r) \\n\\t\\t\\t\\tans++, r = i;\\n\\t\\t\\tpref[sum] = i;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 782730,
                "title": "python-clean-prefixsum-solution-with-video-explanation",
                "content": "Video with clear visualization and explanation: \\nhttps://youtu.be/9p_IJIkX664\\n\\n\\nIntuition: prefixSum/Hashmap/Two pointers\\n\\nCode:\\n\\n```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        m = collections.defaultdict(int)\\n        m[0] = -1\\n        res = 0; right = -1; pre_sum = 0\\n        \\n        for i in range(len(nums)):\\n            pre_sum += nums[i]\\n            compliment = pre_sum-target\\n            if compliment in m and m[compliment] >= right:\\n                res += 1\\n                right = i\\n            m[pre_sum] = i\\n            \\n        return res\\n```\\n\\nFeel free to subscribe to my channel. More LeetCoding videos coming up!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        m = collections.defaultdict(int)\\n        m[0] = -1\\n        res = 0; right = -1; pre_sum = 0\\n        \\n        for i in range(len(nums)):\\n            pre_sum += nums[i]\\n            compliment = pre_sum-target\\n            if compliment in m and m[compliment] >= right:\\n                res += 1\\n                right = i\\n            m[pre_sum] = i\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781265,
                "title": "simple-solution-using-hashmap-java-100-faster",
                "content": "This problem is similar to the the problem - find the subarray which sums to given value X. But the variation here is that we need to find number of non-overlapping subarrays whose sum to the target value. So lets take the same approach what we use in the find the subarray which sums to given value X but we need to maintain 1 condition that is-\\n1. subarrays shouls be non-overlapping-so for this,again reinitialize the hashmap with the value(h.put(0,1)) and sum =0. again re-start the process of finding subarray of the given value X.\\n\\n```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int count = 0;\\n        int n = nums.length;\\n       int sum=0;\\n        HashMap<Integer,Integer> h = new HashMap<>();\\n        h.put(0,1);\\n        for(int i=0;i<n;i++){\\n             sum += nums[i];\\n            if(h.containsKey(sum - target)){\\n                count++;\\n                h =new HashMap<Integer,Integer>();\\n                h.put(0,1);\\n                sum=0;\\n            }\\n            else{\\n                h.put(sum,1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int count = 0;\\n        int n = nums.length;\\n       int sum=0;\\n        HashMap<Integer,Integer> h = new HashMap<>();\\n        h.put(0,1);\\n        for(int i=0;i<n;i++){\\n             sum += nums[i];\\n            if(h.containsKey(sum - target)){\\n                count++;\\n                h =new HashMap<Integer,Integer>();\\n                h.put(0,1);\\n                sum=0;\\n            }\\n            else{\\n                h.put(sum,1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781150,
                "title": "python-o-n-solution",
                "content": "have a set that keeps track of visited sums and go through the list greedily\\n\\n```\\nclass Solution:\\n    def maxNonOverlapping(self, nums, target):\\n        num_of_subarrays, temp, visited = 0, 0, {0}\\n        for i, num in enumerate(nums):\\n            temp += num\\n            prev = temp - target\\n            if prev in visited:\\n                visited = set()\\n                num_of_subarrays += 1\\n            visited.add(temp)\\n        return num_of_subarrays\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums, target):\\n        num_of_subarrays, temp, visited = 0, 0, {0}\\n        for i, num in enumerate(nums):\\n            temp += num\\n            prev = temp - target\\n            if prev in visited:\\n                visited = set()\\n                num_of_subarrays += 1\\n            visited.add(temp)\\n        return num_of_subarrays\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781096,
                "title": "top-down-dp-with-memoization-tle",
                "content": "Putting this here if anyone is looking for a top down DP solution with memoization. It is possible but it will TLE\\nIdeal solution revolves around using prefix sums\\n```\\nclass Solution {\\n    int nums[];\\n    int target;\\n    int memo[];\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        this.nums = nums;\\n        this.target = target;\\n        this.memo = new int[nums.length];\\n        Arrays.fill(this.memo, -1);\\n        int max = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            max = Math.max(max, helper(i));\\n        }\\n        return max;\\n    }\\n    \\n    public int helper(int pos) {\\n        if (pos >= nums.length) {\\n            return 0;\\n        }\\n        if (memo[pos] != -1) {\\n            return memo[pos];\\n        }\\n        int sum = 0;\\n        int endex = pos;\\n        for (int i = pos; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (sum == target) {\\n                endex = i + 1;\\n                break;\\n            }\\n        }\\n\\t\\t\\n        if (sum < target || sum > target) {\\n            memo[pos] = 0;\\n            return 0;\\n        }\\n        int max = 0;\\n        \\n        for (int i = endex; i < nums.length; i++) {\\n            max = Math.max(helper(i), max);\\n        }\\n        \\n        memo[pos] = max + 1;\\n        return max + 1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int nums[];\\n    int target;\\n    int memo[];\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        this.nums = nums;\\n        this.target = target;\\n        this.memo = new int[nums.length];\\n        Arrays.fill(this.memo, -1);\\n        int max = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            max = Math.max(max, helper(i));\\n        }\\n        return max;\\n    }\\n    \\n    public int helper(int pos) {\\n        if (pos >= nums.length) {\\n            return 0;\\n        }\\n        if (memo[pos] != -1) {\\n            return memo[pos];\\n        }\\n        int sum = 0;\\n        int endex = pos;\\n        for (int i = pos; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (sum == target) {\\n                endex = i + 1;\\n                break;\\n            }\\n        }\\n\\t\\t\\n        if (sum < target || sum > target) {\\n            memo[pos] = 0;\\n            return 0;\\n        }\\n        int max = 0;\\n        \\n        for (int i = endex; i < nums.length; i++) {\\n            max = Math.max(helper(i), max);\\n        }\\n        \\n        memo[pos] = max + 1;\\n        return max + 1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781075,
                "title": "python3-o-n-prefix-sum",
                "content": "Compute the prefix sum `prefix` and check if `prefix - target` has appeared already. \\n\\n```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        ans = prefix = 0\\n        seen = set([0]) #prefix sum seen so far ()\\n        for i, x in enumerate(nums): \\n            prefix += x\\n            if prefix - target in seen:\\n                ans += 1\\n                seen.clear() #reset seen\\n            seen.add(prefix)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        ans = prefix = 0\\n        seen = set([0]) #prefix sum seen so far ()\\n        for i, x in enumerate(nums): \\n            prefix += x\\n            if prefix - target in seen:\\n                ans += 1\\n                seen.clear() #reset seen\\n            seen.add(prefix)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 781031,
                "title": "c-dp-solution-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int, int> m;\\n        m[0] = -1;\\n        vector<int> dp(nums.size() + 1);\\n        int sum = 0;\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); ++i) {\\n            sum += nums[i];\\n            if(m.count(sum - target)) {\\n                int idx = m[sum - target];\\n                dp[i + 1] = max(ans, dp[idx + 1] + 1);\\n            }else\\n                dp[i + 1] = ans;\\n            ans = max(ans, dp[i + 1]);\\n            m[sum] = i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int, int> m;\\n        m[0] = -1;\\n        vector<int> dp(nums.size() + 1);\\n        int sum = 0;\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); ++i) {\\n            sum += nums[i];\\n            if(m.count(sum - target)) {\\n                int idx = m[sum - target];\\n                dp[i + 1] = max(ans, dp[idx + 1] + 1);\\n            }else\\n                dp[i + 1] = ans;\\n            ans = max(ans, dp[i + 1]);\\n            m[sum] = i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780933,
                "title": "java-one-pass",
                "content": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        int ans = 0, last = -2, sum = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(map.containsKey(sum - target) && map.get(sum - target) >= last){\\n                last = i;\\n                ans++;\\n            }\\n            map.put(sum, i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        int ans = 0, last = -2, sum = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(map.containsKey(sum - target) && map.get(sum - target) >= last){\\n                last = i;\\n                ans++;\\n            }\\n            map.put(sum, i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780879,
                "title": "java-o-n-easy-using-map",
                "content": "\\t  public int maxNonOverlapping(int[] nums, int target) {\\n          HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        int count = 0;\\n        map.put(0, 1);\\n        for(int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            if(map.containsKey(sum - target)) {\\n                count++;\\n                map = new HashMap<>();\\n            }\\n            map.put(sum, 1);\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "\\t  public int maxNonOverlapping(int[] nums, int target) {\\n          HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        int count = 0;\\n        map.put(0, 1);\\n        for(int i = 0; i < nums.length; i++) {\\n            sum = sum + nums[i];\\n            if(map.containsKey(sum - target)) {\\n                count++;\\n                map = new HashMap<>();\\n            }\\n            map.put(sum, 1);\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3373039,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        HashSet<Integer>h=new HashSet<>();\\n        int c=0,s=0;\\n        h.add(0);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            s+=nums[i];\\n            if(h.contains(s-target)==true)\\n            {\\n                c+=1;\\n                s=0;\\n                h.removeAll(h);\\n                h.add(0);\\n            }\\n            else h.add(s);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        HashSet<Integer>h=new HashSet<>();\\n        int c=0,s=0;\\n        h.add(0);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            s+=nums[i];\\n            if(h.contains(s-target)==true)\\n            {\\n                c+=1;\\n                s=0;\\n                h.removeAll(h);\\n                h.add(0);\\n            }\\n            else h.add(s);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696809,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int maxNonOverlapping(vector<int>& nums, int target) {\\n    unordered_map<int, int> dp;\\n    dp[0] = -1;\\n    int sum = 0, right = -1, cnt = 0;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        sum += nums[i];\\n        if (dp.count(sum - target)) {\\n            int left = dp[sum - target];\\n            if (right <= left) {\\n                ++cnt;\\n                right = i;\\n            }\\n        }\\n        dp[sum] = i;\\n    }\\n    return cnt;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int maxNonOverlapping(vector<int>& nums, int target) {\\n    unordered_map<int, int> dp;\\n    dp[0] = -1;\\n    int sum = 0, right = -1, cnt = 0;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        sum += nums[i];\\n        if (dp.count(sum - target)) {\\n            int left = dp[sum - target];\\n            if (right <= left) {\\n                ++cnt;\\n                right = i;\\n            }\\n        }\\n        dp[sum] = i;\\n    }\\n    return cnt;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2476300,
                "title": "c-hashmap-o-n-time-and-o-n-space",
                "content": "class Solution {\\npublic:\\n  \\n  int maxNonOverlapping(vector<int>& nums, int target) {\\n        \\n        unordered_map<int,int> mp;\\n        int ans = 0;\\n        int sum = 0;\\n        int n = nums.size();\\n        mp[0] = 1;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            sum += nums[i];\\n            \\n            if(mp.find(sum-target) != mp.end()){\\n                ans ++;\\n                mp.clear();\\n            }\\n            \\n            mp[sum] ++;\\n            \\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n  \\n  int maxNonOverlapping(vector<int>& nums, int target) {\\n        \\n        unordered_map<int,int> mp;\\n        int ans = 0;\\n        int sum = 0;\\n        int n = nums.size();\\n        mp[0] = 1;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            sum += nums[i];\\n            \\n            if(mp.find(sum-target) != mp.end()){\\n                ans ++;\\n                mp.clear();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2440181,
                "title": "c-greedy",
                "content": "--------------------BRUTE FORCE (TLE)------------\\n```\\nclass Solution {\\npublic:\\n    \\n    bool find(vector<int>& prefix,int num,int f,int l){\\n        for(int i=f;i<=l;i++)\\n            if(prefix[i]==num)\\n                return true;\\n        return false;\\n    }\\n    \\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<int>prefix(n,0);\\n        prefix[0]=nums[0];\\n        int f=0;\\n        for(int i=1;i<n;i++)\\n            prefix[i]=prefix[i-1]+nums[i];\\n        bool flag=false;\\n        for(int i=0;i<n;i++){\\n            if(prefix[i]-target==0 && f==0 && flag==false){\\n                f=i;\\n                ans++;\\n                flag=true;\\n            }\\n            else if(find(prefix,prefix[i]-target,f,i-1)){\\n                f=i;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n-----------------------USING MAP---------------------\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        mp[0]=-1;\\n        int pre=-1;\\n        int ans=0,sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            if(mp.find(sum-target)!=mp.end() && mp[sum-target]>=pre){\\n                ans++;\\n                pre=i;\\n            }\\n            mp[sum]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool find(vector<int>& prefix,int num,int f,int l){\\n        for(int i=f;i<=l;i++)\\n            if(prefix[i]==num)\\n                return true;\\n        return false;\\n    }\\n    \\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<int>prefix(n,0);\\n        prefix[0]=nums[0];\\n        int f=0;\\n        for(int i=1;i<n;i++)\\n            prefix[i]=prefix[i-1]+nums[i];\\n        bool flag=false;\\n        for(int i=0;i<n;i++){\\n            if(prefix[i]-target==0 && f==0 && flag==false){\\n                f=i;\\n                ans++;\\n                flag=true;\\n            }\\n            else if(find(prefix,prefix[i]-target,f,i-1)){\\n                f=i;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        mp[0]=-1;\\n        int pre=-1;\\n        int ans=0,sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            if(mp.find(sum-target)!=mp.end() && mp[sum-target]>=pre){\\n                ans++;\\n                pre=i;\\n            }\\n            mp[sum]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424801,
                "title": "hash-map-o-n",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxNonOverlapping(vector<int>& nums, int target) {\\n\\t\\t\\t// -1,3,5,1,4,2,-9\\n\\t\\t\\t// -1,2,7,8,12,14,5\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tunordered_map<int,int> mp;\\n\\t\\t\\tmp[0] = 1;\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int i = 0; i < nums.size(); i++) {\\n\\t\\t\\t\\tsum += nums[i];\\n\\t\\t\\t\\tif(mp.count(sum - target) > 0) {\\n\\t\\t\\t\\t\\t// cout << sum << endl;\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\tmp.clear();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmp[sum]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxNonOverlapping(vector<int>& nums, int target) {\\n\\t\\t\\t// -1,3,5,1,4,2,-9\\n\\t\\t\\t// -1,2,7,8,12,14,5\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tunordered_map<int,int> mp;\\n\\t\\t\\tmp[0] = 1;\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int i = 0; i < nums.size(); i++) {\\n\\t\\t\\t\\tsum += nums[i];\\n\\t\\t\\t\\tif(mp.count(sum - target) > 0) {\\n\\t\\t\\t\\t\\t// cout << sum << endl;\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\tmp.clear();\\n\\t\\t\\t\\t}",
                "codeTag": "C++"
            },
            {
                "id": 2219264,
                "title": "java-greedy-by-set",
                "content": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int res = 0;\\n        Set<Integer> set = new HashSet<>();\\n        set.add(0);\\n        int curr = 0;\\n        int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            curr += nums[i];\\n            if (set.contains(curr - target)) {\\n                res++;\\n                set.clear();\\n                set.add(0);\\n                curr = 0;\\n            }\\n            else {\\n                set.add(curr);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int res = 0;\\n        Set<Integer> set = new HashSet<>();\\n        set.add(0);\\n        int curr = 0;\\n        int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            curr += nums[i];\\n            if (set.contains(curr - target)) {\\n                res++;\\n                set.clear();\\n                set.add(0);\\n                curr = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1885809,
                "title": "c-map-based-solution-o-n-time-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        //INTUITION: Sliding window (WORKS ONLY FOR +VE NOS. in ARRAY, WON\\'T WORK HERE!!)\\n        // int sum = nums[0];\\n        // int i = 0, j = 0;\\n        // int cnt = 0;\\n        // while(j<nums.size())\\n        // {\\n        //     if(sum==target)\\n        //     {\\n        //         ++cnt;\\n        //         sum = 0;\\n        //         ++j;\\n        //         i = j;\\n        //         if(j<nums.size())\\n        //             sum+=nums[j];\\n        //     }\\n        //     else if(sum>target)\\n        //     {\\n        //         if(i==j)\\n        //         {\\n        //             sum-=nums[i];\\n        //             i++,j++;\\n        //             if(j<nums.size())\\n        //                 sum+=nums[j];\\n        //         }\\n        //         else\\n        //         {\\n        //             sum-=nums[i];\\n        //             i++;\\n        //         }\\n        //     }\\n        //     else\\n        //     {\\n        //             ++j;\\n        //             if(j<nums.size())\\n        //                 sum+=nums[j];\\n        //     }\\n        // }\\n        \\n        //=============works for both +ve and -ve numbers in array==================//\\n        \\n        //INTUITION: Store the sum encountered at each index in a map and \\n        //if we have two pointers, one at the end of previous subarray meeting the criteria, and one at the starting of a new subarray meeting the criteria\\n        //we can check if these two subarrays overlap\\n        \\n        \\n        unordered_map<int,int> mp;\\n        mp[0] = -1; //for handling the case if subarray with sum ==5 starts from the 0th index itself \\n        int cnt = 0, sum = 0, right = -1, left = 0;\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            sum+=nums[i]; //recurring sum\\n            if(mp.count(sum-target))\\n            {\\n                left = mp[sum-target]; //starting point of current subarray with sum == target\\n                if(left>=right) //non-overlapping condition\\n                {\\n                    ++cnt;\\n                    right = i; //marking the ending of current subarray which has been counted\\n                }\\n            }\\n            mp[sum] = i; // marking each encountered sum\\'s index\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        //INTUITION: Sliding window (WORKS ONLY FOR +VE NOS. in ARRAY, WON\\'T WORK HERE!!)\\n        // int sum = nums[0];\\n        // int i = 0, j = 0;\\n        // int cnt = 0;\\n        // while(j<nums.size())\\n        // {\\n        //     if(sum==target)\\n        //     {\\n        //         ++cnt;\\n        //         sum = 0;\\n        //         ++j;\\n        //         i = j;\\n        //         if(j<nums.size())\\n        //             sum+=nums[j];\\n        //     }\\n        //     else if(sum>target)\\n        //     {\\n        //         if(i==j)\\n        //         {\\n        //             sum-=nums[i];\\n        //             i++,j++;\\n        //             if(j<nums.size())\\n        //                 sum+=nums[j];\\n        //         }\\n        //         else\\n        //         {\\n        //             sum-=nums[i];\\n        //             i++;\\n        //         }\\n        //     }\\n        //     else\\n        //     {\\n        //             ++j;\\n        //             if(j<nums.size())\\n        //                 sum+=nums[j];\\n        //     }\\n        // }\\n        \\n        //=============works for both +ve and -ve numbers in array==================//\\n        \\n        //INTUITION: Store the sum encountered at each index in a map and \\n        //if we have two pointers, one at the end of previous subarray meeting the criteria, and one at the starting of a new subarray meeting the criteria\\n        //we can check if these two subarrays overlap\\n        \\n        \\n        unordered_map<int,int> mp;\\n        mp[0] = -1; //for handling the case if subarray with sum ==5 starts from the 0th index itself \\n        int cnt = 0, sum = 0, right = -1, left = 0;\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            sum+=nums[i]; //recurring sum\\n            if(mp.count(sum-target))\\n            {\\n                left = mp[sum-target]; //starting point of current subarray with sum == target\\n                if(left>=right) //non-overlapping condition\\n                {\\n                    ++cnt;\\n                    right = i; //marking the ending of current subarray which has been counted\\n                }\\n            }\\n            mp[sum] = i; // marking each encountered sum\\'s index\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775947,
                "title": "c-prefix-sum-hashmap-easy-commented-solution",
                "content": "**C++ Code :**\\n```\\n //IDEA: We need to make sure we keep moving the left window to the last sum we counted.\\n    int maxNonOverlapping(vector<int>& nums, int tar) {\\n        int n=nums.size();\\n        int ans=0;\\n        \\n        //create a map to store sum and idx(sum,idx) pair\\n        unordered_map<int,int> sumCnt;\\n        sumCnt[0]=-1;\\n        \\n        //rightIdx ptr is the ptr to keep track of our end point of our last subarray having sum target\\n        int rightIdx=-1;\\n        int sum=0;\\n        \\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            \\n            //look for sum-tar in map\\n            if(sumCnt.count(sum - tar)){\\n                //(leftIdx+1) is the starting idx of our subarray with sum equals target \\n                int leftIdx= sumCnt[sum - tar];\\n                //check if it is overlapping or not with condn : right <= left\\n               \\n                 //below line is make sure that we don\\'t count a long array which has this subarray inside.\\n                if(rightIdx <= leftIdx){\\n                    ans ++;\\n                    rightIdx = i;//update left window of our subarray\\n                }\\n            }\\n            \\n            sumCnt[sum]=i;\\n            \\n        }\\n        return ans;\\n    }\\n```\\n**Don\\'t forget to Upvote if you understood the solution!**",
                "solutionTags": [],
                "code": "```\\n //IDEA: We need to make sure we keep moving the left window to the last sum we counted.\\n    int maxNonOverlapping(vector<int>& nums, int tar) {\\n        int n=nums.size();\\n        int ans=0;\\n        \\n        //create a map to store sum and idx(sum,idx) pair\\n        unordered_map<int,int> sumCnt;\\n        sumCnt[0]=-1;\\n        \\n        //rightIdx ptr is the ptr to keep track of our end point of our last subarray having sum target\\n        int rightIdx=-1;\\n        int sum=0;\\n        \\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            \\n            //look for sum-tar in map\\n            if(sumCnt.count(sum - tar)){\\n                //(leftIdx+1) is the starting idx of our subarray with sum equals target \\n                int leftIdx= sumCnt[sum - tar];\\n                //check if it is overlapping or not with condn : right <= left\\n               \\n                 //below line is make sure that we don\\'t count a long array which has this subarray inside.\\n                if(rightIdx <= leftIdx){\\n                    ans ++;\\n                    rightIdx = i;//update left window of our subarray\\n                }\\n            }\\n            \\n            sumCnt[sum]=i;\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1684728,
                "title": "python-easy-o-n-solution-using-set-and-prefix-sum",
                "content": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        # create set to keep track of prefix sums seen\\n        prefix_sums = {0}   # we add 0 initially since there can be empty array prefix sum. ex [1] k = 1\\n        \\n        subarrays = 0\\n        \\n        rolling_sum = 0\\n        for num in nums:\\n            # calculate prefix sum for current index\\n            rolling_sum += num\\n            \\n            # calculate complement for current prefix sum\\n            comp = rolling_sum - target\\n            \\n            # check if there is prefix_sum(sub array that sums to complement) that we can subtract to equal target\\n            if comp in prefix_sums:\\n                # we know there is a subarray that equals target, so increment\\n                subarrays += 1\\n                # we dont want overlapping subarrays, so clear all previous subarrays\\n                prefix_sums.clear()\\n            \\n            # add prefix sum for current index in set\\n            prefix_sums.add(rolling_sum)\\n        \\n        return subarrays\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        # create set to keep track of prefix sums seen\\n        prefix_sums = {0}   # we add 0 initially since there can be empty array prefix sum. ex [1] k = 1\\n        \\n        subarrays = 0\\n        \\n        rolling_sum = 0\\n        for num in nums:\\n            # calculate prefix sum for current index\\n            rolling_sum += num\\n            \\n            # calculate complement for current prefix sum\\n            comp = rolling_sum - target\\n            \\n            # check if there is prefix_sum(sub array that sums to complement) that we can subtract to equal target\\n            if comp in prefix_sums:\\n                # we know there is a subarray that equals target, so increment\\n                subarrays += 1\\n                # we dont want overlapping subarrays, so clear all previous subarrays\\n                prefix_sums.clear()\\n            \\n            # add prefix sum for current index in set\\n            prefix_sums.add(rolling_sum)\\n        \\n        return subarrays\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409251,
                "title": "kotlin-prefix-sum-clean-solution",
                "content": "```\\nclass Solution {\\n    fun maxNonOverlapping(nums: IntArray, target: Int): Int {\\n        val currentSums = mutableSetOf(0)\\n        return IntArray(nums.size).also {\\n            it[0] = nums[0]\\n            for (i in 1..nums.lastIndex) {\\n                it[i] = it[i - 1] + nums[i]\\n            }\\n        }.fold(0) { acc, currentSum ->\\n            if (currentSums.contains(currentSum - target)) {\\n                currentSums.clear()\\n                currentSums.add(currentSum)\\n                acc + 1\\n            } else {\\n                currentSums.add(currentSum)\\n                acc\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maxNonOverlapping(nums: IntArray, target: Int): Int {\\n        val currentSums = mutableSetOf(0)\\n        return IntArray(nums.size).also {\\n            it[0] = nums[0]\\n            for (i in 1..nums.lastIndex) {\\n                it[i] = it[i - 1] + nums[i]\\n            }\\n        }.fold(0) { acc, currentSum ->\\n            if (currentSums.contains(currentSum - target)) {\\n                currentSums.clear()\\n                currentSums.add(currentSum)\\n                acc + 1\\n            } else {\\n                currentSums.add(currentSum)\\n                acc\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210774,
                "title": "o-n-2-o-n-in-c",
                "content": "\\ndp[i] = stores the maximum answer from 0 to i-1 elements.\\n**transition state : dp[i+1] = max(dp[i+1], dp[j] + 1);**\\n*if sum from i to j == target.*\\n\\nTime Complexity = O(N^2).\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n     \\n    int n = nums.size();\\n    vector<int> dp(n+1,0);\\n    for(int i =0; i<n; i++){\\n        int s= 0;\\n        for(int j =i; j>=0; j--){\\n            s+=nums[j];\\n            dp[i+1] = max(dp[i+1],dp[j]+(s==target?1:0));\\n        }\\n    }\\n    return dp[n];\\n        \\n    }\\n};\\n```\\n\\nSimilar to subarray of sum k, Time Complexity - O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n     \\n    int sum =0;\\n    int ans =0;\\n    unordered_set<int> st = {0};\\n    for(int i =0; i<nums.size(); i++){\\n        \\n        sum+=nums[i];\\n        \\n        if(st.find(sum-target)!=st.end()){\\n            ans++;\\n            sum =0;\\n            st ={0};\\n        }\\n        else {\\n            st.insert(sum);\\n        }\\n    }\\n        \\n     \\n        return ans;\\n    }\\n};\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n     \\n    int n = nums.size();\\n    vector<int> dp(n+1,0);\\n    for(int i =0; i<n; i++){\\n        int s= 0;\\n        for(int j =i; j>=0; j--){\\n            s+=nums[j];\\n            dp[i+1] = max(dp[i+1],dp[j]+(s==target?1:0));\\n        }\\n    }\\n    return dp[n];\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n     \\n    int sum =0;\\n    int ans =0;\\n    unordered_set<int> st = {0};\\n    for(int i =0; i<nums.size(); i++){\\n        \\n        sum+=nums[i];\\n        \\n        if(st.find(sum-target)!=st.end()){\\n            ans++;\\n            sum =0;\\n            st ={0};\\n        }\\n        else {\\n            st.insert(sum);\\n        }\\n    }\\n        \\n     \\n        return ans;\\n    }\\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189004,
                "title": "c-map-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int,int> mp;\\n        int sum = 0,count=0,previ=0;\\n        mp[0] = 0;\\n        count = 0;\\n        for(int i=1;i<nums.size()+1;i++)\\n        {\\n            sum+=nums[i-1];\\n            if(mp.find(sum-target)!=mp.end() && mp[sum-target]>=previ)\\n            {\\n                count++;\\n                previ = i;\\n            }\\n            mp[sum] = i;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int,int> mp;\\n        int sum = 0,count=0,previ=0;\\n        mp[0] = 0;\\n        count = 0;\\n        for(int i=1;i<nums.size()+1;i++)\\n        {\\n            sum+=nums[i-1];\\n            if(mp.find(sum-target)!=mp.end() && mp[sum-target]>=previ)\\n            {\\n                count++;\\n                previ = i;\\n            }\\n            mp[sum] = i;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188324,
                "title": "67-python-explained",
                "content": "```\\n# from functools import lru_cache\\n\\nclass Solution:\\n    # The problem boils down to finding the maximum number of non overlapping intervals\\n    # Can be solved using recursion and optimized using memoization\\n    # Possible TLE\\n    \\'\\'\\'\\n    @lru_cache(None)\\n    def maxNonOverlappingIntervals(self, curr_index, last_ending):\\n        if curr_index == len(self.targets):\\n            return 0\\n        do_not_include = self.maxNonOverlappingIntervals(curr_index + 1, last_ending)\\n        \\n        if self.targets[curr_index][0] > last_ending:\\n            return max(do_not_include, 1 + self.maxNonOverlappingIntervals(curr_index + 1, self.targets[curr_index][1]))\\n        else:\\n            return do_not_include\\n    \\'\\'\\'\\n    # Greedy solution since according to the structure of the problem, the targets will already be sorted\\n    def maxNonOverlappingIntervals(self, targets):\\n        last_ending, ans = -1, 0\\n        for i in range(len(targets)):\\n            if targets[i][0] > last_ending:\\n                last_ending = targets[i][1]\\n                ans += 1\\n        return ans\\n    \\n    # Keep track of the prefix sums and update the position according to the latest index\\n    # The latter point is really important because we want the intervals to be as small as possible\\n    # Just a clever heuristic\\n    \\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        # Prefix sums\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i - 1]\\n        nums = [0] + nums\\n        \\n        sums_seen_so_far, targets = dict(), []\\n        \\n        # Commented out portion is because we donot want all the possible intervals\\n        # Instead we want the smallest interval possible\\n        \\n        for i in range(len(nums)):\\n            if nums[i] - target in sums_seen_so_far:\\n                for entry in sums_seen_so_far[nums[i] - target]:\\n                    targets.append((entry, i - 1))\\n            # if nums[i] not in sums_seen_so_far:\\n            sums_seen_so_far[nums[i]] = [i]\\n            # sums_seen_so_far[nums[i]].append(i)\\n        \\n        return self.maxNonOverlappingIntervals(targets)\\n                \\n```",
                "solutionTags": [],
                "code": "```\\n# from functools import lru_cache\\n\\nclass Solution:\\n    # The problem boils down to finding the maximum number of non overlapping intervals\\n    # Can be solved using recursion and optimized using memoization\\n    # Possible TLE\\n    \\'\\'\\'\\n    @lru_cache(None)\\n    def maxNonOverlappingIntervals(self, curr_index, last_ending):\\n        if curr_index == len(self.targets):\\n            return 0\\n        do_not_include = self.maxNonOverlappingIntervals(curr_index + 1, last_ending)\\n        \\n        if self.targets[curr_index][0] > last_ending:\\n            return max(do_not_include, 1 + self.maxNonOverlappingIntervals(curr_index + 1, self.targets[curr_index][1]))\\n        else:\\n            return do_not_include\\n    \\'\\'\\'\\n    # Greedy solution since according to the structure of the problem, the targets will already be sorted\\n    def maxNonOverlappingIntervals(self, targets):\\n        last_ending, ans = -1, 0\\n        for i in range(len(targets)):\\n            if targets[i][0] > last_ending:\\n                last_ending = targets[i][1]\\n                ans += 1\\n        return ans\\n    \\n    # Keep track of the prefix sums and update the position according to the latest index\\n    # The latter point is really important because we want the intervals to be as small as possible\\n    # Just a clever heuristic\\n    \\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        # Prefix sums\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i - 1]\\n        nums = [0] + nums\\n        \\n        sums_seen_so_far, targets = dict(), []\\n        \\n        # Commented out portion is because we donot want all the possible intervals\\n        # Instead we want the smallest interval possible\\n        \\n        for i in range(len(nums)):\\n            if nums[i] - target in sums_seen_so_far:\\n                for entry in sums_seen_so_far[nums[i] - target]:\\n                    targets.append((entry, i - 1))\\n            # if nums[i] not in sums_seen_so_far:\\n            sums_seen_so_far[nums[i]] = [i]\\n            # sums_seen_so_far[nums[i]].append(i)\\n        \\n        return self.maxNonOverlappingIntervals(targets)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163582,
                "title": "java-set-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int sum = 0;\\n        Set<Integer> set = new HashSet<>();\\n        int count = 0;\\n        set.add(0);\\n        for(int i : nums) {\\n            sum += i;\\n            if(set.contains(sum - target)) {\\n                count++;\\n                sum = 0;\\n                set = new HashSet<>();\\n                set.add(0);\\n            }else {\\n                set.add(sum);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int sum = 0;\\n        Set<Integer> set = new HashSet<>();\\n        int count = 0;\\n        set.add(0);\\n        for(int i : nums) {\\n            sum += i;\\n            if(set.contains(sum - target)) {\\n                count++;\\n                sum = 0;\\n                set = new HashSet<>();\\n                set.add(0);\\n            }else {\\n                set.add(sum);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138814,
                "title": "python-cumulative-sum-and-hash-faster-than-97",
                "content": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        sums = {0 : -1}\\n        cumsum = counter = 0\\n        prev_end = -1\\n        \\n        for i in range(len(nums)):\\n            cumsum += nums[i]\\n\\t\\t\\t# if the sum of array nums[sums[cumsum-target]:i] is target and not overlapping previous arrays\\n            if ((cumsum - target) in sums) and (prev_end < 1 + sums[cumsum-target]):\\n                counter += 1\\n                prev_end = i\\n            sums[cumsum] = i\\n            \\n        return counter\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        sums = {0 : -1}\\n        cumsum = counter = 0\\n        prev_end = -1\\n        \\n        for i in range(len(nums)):\\n            cumsum += nums[i]\\n\\t\\t\\t# if the sum of array nums[sums[cumsum-target]:i] is target and not overlapping previous arrays\\n            if ((cumsum - target) in sums) and (prev_end < 1 + sums[cumsum-target]):\\n                counter += 1\\n                prev_end = i\\n            sums[cumsum] = i\\n            \\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011170,
                "title": "python-solution-with-o-t-n-with-explanations",
                "content": "```\\n# Instead calculating all possible combinations  by bruteforce\\n# we could use incremental sum . sum( nums[i:j])  = incremental_sum(j) - incremental_sum(i)\\ndef maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        # key => incremental sum\\n        # valu => index of element in list\\n        sums = {0:-1}\\n        min_indx = -2\\n        count =0\\n        prev = 0\\n        # We are calculating incremental sum \\n        # and lookups as we go\\n        for i, num in enumerate(nums):\\n            c = num + prev\\n            #increment count only if the intended value is at an index\\n            # greater than the last index we counted\\n            if c- target in sums and sums[c -target ] > min_indx:\\n                count += 1\\n                #print (sums[c -target ], i)\\n                min_indx = i-1\\n            sums[c] = i\\n            prev = c\\n        #print (sums)\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\n# Instead calculating all possible combinations  by bruteforce\\n# we could use incremental sum . sum( nums[i:j])  = incremental_sum(j) - incremental_sum(i)\\ndef maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        # key => incremental sum\\n        # valu => index of element in list\\n        sums = {0:-1}\\n        min_indx = -2\\n        count =0\\n        prev = 0\\n        # We are calculating incremental sum \\n        # and lookups as we go\\n        for i, num in enumerate(nums):\\n            c = num + prev\\n            #increment count only if the intended value is at an index\\n            # greater than the last index we counted\\n            if c- target in sums and sums[c -target ] > min_indx:\\n                count += 1\\n                #print (sums[c -target ], i)\\n                min_indx = i-1\\n            sums[c] = i\\n            prev = c\\n        #print (sums)\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 878598,
                "title": "c-prefix-sum-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int, int> map;\\n        int p = INT_MIN;\\n        int sum = 0;\\n        map[0] = -1;\\n        int res = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            if (map.count(sum - target) && p <= map[sum - target] ) {\\n                res++;\\n                p = i;\\n            }\\n            map[sum] = i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int, int> map;\\n        int p = INT_MIN;\\n        int sum = 0;\\n        map[0] = -1;\\n        int res = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            if (map.count(sum - target) && p <= map[sum - target] ) {\\n                res++;\\n                p = i;\\n            }\\n            map[sum] = i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822928,
                "title": "c-hashing",
                "content": "```\\n int maxNonOverlapping(vector<int>& nums, int target) \\n    {\\n       unordered_map <int,int> m;\\n        m[0]=-1;\\n        int x=-1,sum=0,count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            if(m.count(sum-target))\\n            {\\n                if(m[sum-target]>=x)\\n                {\\n                 count++;\\n                 x=i;\\n                }\\n            }\\n            m[sum]=i;\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "```\\n int maxNonOverlapping(vector<int>& nums, int target) \\n    {\\n       unordered_map <int,int> m;\\n        m[0]=-1;\\n        int x=-1,sum=0,count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            if(m.count(sum-target))\\n            {\\n                if(m[sum-target]>=x)\\n                {\\n                 count++;\\n                 x=i;\\n                }\\n            }\\n            m[sum]=i;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 813959,
                "title": "c-easy-to-read-consise-o-n-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        set<int> s;\\n        s.insert(0);\\n        int PrefixSum=0,ans=0;\\n        for(int i : nums){\\n            PrefixSum+=i;\\n            if(s.find(PrefixSum-target)!=s.end()){\\n                ans++;\\n                s.clear();\\n            }\\n            s.insert(PrefixSum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        set<int> s;\\n        s.insert(0);\\n        int PrefixSum=0,ans=0;\\n        for(int i : nums){\\n            PrefixSum+=i;\\n            if(s.find(PrefixSum-target)!=s.end()){\\n                ans++;\\n                s.clear();\\n            }\\n            s.insert(PrefixSum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796782,
                "title": "top-down-approach",
                "content": "Use of top down approach in 1 D array and then hashMap\\n```\\nclass Solution {\\n    public int maxNonOverlapping(int[] arr, int target) {\\n        int[] pre = new int[arr.length];\\n        int[] ref = new int[arr.length];\\n        pre[0] = arr[0];\\n        for (int i = 1; i < arr.length; i++){\\n            pre[i] = pre[i - 1] + arr[i];\\n        }\\n        HashMap<Integer, Integer> hash = new HashMap<Integer, Integer>();\\n //       System.out.println(Arrays.toString(pre));\\n        for (int i = 0; i < pre.length; i++){\\n            \\n            if (pre[i] == target && (i == 0 || ref[i - 1] == 0)){\\n                ref[i] = 1;\\n                }\\n            \\n            else{\\n            int l = pre[i] - target; int pos = -1;\\n            pos = hash.getOrDefault(l, -1);\\n            if (pos == -1){\\n                if (i != 0)\\n                ref[i] = ref[i - 1];}\\n            else{\\n                ref[i] = Math.max(ref[pos] + 1, ref[i -1]);\\n            }\\n           //    System.out.println(pos);\\n               \\n        }\\n             hash.put(pre[i], i);\\n      //      System.out.println(Arrays.toString(ref));\\n        \\n       \\n    }\\n        return ref[ref.length - 1];}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] arr, int target) {\\n        int[] pre = new int[arr.length];\\n        int[] ref = new int[arr.length];\\n        pre[0] = arr[0];\\n        for (int i = 1; i < arr.length; i++){\\n            pre[i] = pre[i - 1] + arr[i];\\n        }\\n        HashMap<Integer, Integer> hash = new HashMap<Integer, Integer>();\\n //       System.out.println(Arrays.toString(pre));\\n        for (int i = 0; i < pre.length; i++){\\n            \\n            if (pre[i] == target && (i == 0 || ref[i - 1] == 0)){\\n                ref[i] = 1;\\n                }\\n            \\n            else{\\n            int l = pre[i] - target; int pos = -1;\\n            pos = hash.getOrDefault(l, -1);\\n            if (pos == -1){\\n                if (i != 0)\\n                ref[i] = ref[i - 1];}\\n            else{\\n                ref[i] = Math.max(ref[pos] + 1, ref[i -1]);\\n            }\\n           //    System.out.println(pos);\\n               \\n        }\\n             hash.put(pre[i], i);\\n      //      System.out.println(Arrays.toString(ref));\\n        \\n       \\n    }\\n        return ref[ref.length - 1];}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787074,
                "title": "straightforward-java-solution-dp-time-o-n",
                "content": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 0);\\n        int ans = 0;\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (map.containsKey(sum - target)) {\\n                ans = Math.max(ans, map.get(sum - target) + 1);\\n            }\\n            map.put(sum, ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 0);\\n        int ans = 0;\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (map.containsKey(sum - target)) {\\n                ans = Math.max(ans, map.get(sum - target) + 1);\\n            }\\n            map.put(sum, ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785670,
                "title": "python-solution-faster-than-95-21-of-solutions-o-n",
                "content": "Dp problems are hard I kept on thinking of DP approach for this problem, but submission got TLE later, being a newbie at leetcode this way using prefix sum was complete new to me. Feeling glad, It passed with TLE.\\n\\n```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        dic = {0:0}\\n        ans = 0\\n        sum = 0\\n        for i in range(len(nums)):\\n            sum+=nums[i]\\n            if sum-target in dic:\\n                ans+=1\\n                dic = {}\\n            dic[sum] = i\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        dic = {0:0}\\n        ans = 0\\n        sum = 0\\n        for i in range(len(nums)):\\n            sum+=nums[i]\\n            if sum-target in dic:\\n                ans+=1\\n                dic = {}\\n            dic[sum] = i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783030,
                "title": "trick-of-the-question-maximum-number-of-non-overlapping-subarrays-with-sum-equals-target",
                "content": "Just here to document every question that I do with 1 comment on the basic \"trick\" of the question\\n\\nTrick:\\n- https://leetcode.com/problems/subarray-sum-equals-k/\\n\\t- knowing this question REALLY helps\\n\\t- basically same concept of hashmap used in terms of getting subarray sum = k\\n\\t- k  = 4, array  = 0,3,1,2,2,1\\n\\t\\t- prefixSumHashmap = {0,0,3,4,6,8,9}\\n\\t\\t- ask \"does prefixSum - k exist in array, if so, we have found one subarray\\n\\t\\t- 8 - 4 = 4, 4 exists in hashMap\\n\\t\\t- 4 - 4 =0, 0 exists in hashMap\\n- to make sure there is no overlap in subarray, make the prefix sum = 0 after every valid subarray sum = k (knowing above problem really helps in understanding what I mean)\\n\\t- using same concept as the prev problem shown\\n\\t- to not get ANY overlap, simply make prefixSum = 0 once a subarray is found so that there is no trace of using previous subarray\\n\\t\\t- if you properly understand the previous problem, setting prefixSum = 0 essentially means the array given can essentially be cutoff once that subarray sum is found\\n\\t\\t- k  = 4, array  = 0,3,1,2,2,1\\n\\t\\t\\t- prefixSumHashmap = {0,0,3,4,6,8,9}\\n\\t\\t\\t- prefixSumHashmap = {0,0,3,0,2,0,1} -> {0,0,3,4} \\'cut\\'{0,2,4} \\'cut\\' {0,1}\\n\\t\\t\\t\\t- we can \"cut\" off the previous elements before that subarray sum is solved\\n- for the layman, we simply set prefix sum to zero once a subarray sum is found",
                "solutionTags": [],
                "code": "Just here to document every question that I do with 1 comment on the basic \"trick\" of the question\\n\\nTrick:\\n- https://leetcode.com/problems/subarray-sum-equals-k/\\n\\t- knowing this question REALLY helps\\n\\t- basically same concept of hashmap used in terms of getting subarray sum = k\\n\\t- k  = 4, array  = 0,3,1,2,2,1\\n\\t\\t- prefixSumHashmap = {0,0,3,4,6,8,9}\\n\\t\\t- ask \"does prefixSum - k exist in array, if so, we have found one subarray\\n\\t\\t- 8 - 4 = 4, 4 exists in hashMap\\n\\t\\t- 4 - 4 =0, 0 exists in hashMap\\n- to make sure there is no overlap in subarray, make the prefix sum = 0 after every valid subarray sum = k (knowing above problem really helps in understanding what I mean)\\n\\t- using same concept as the prev problem shown\\n\\t- to not get ANY overlap, simply make prefixSum = 0 once a subarray is found so that there is no trace of using previous subarray\\n\\t\\t- if you properly understand the previous problem, setting prefixSum = 0 essentially means the array given can essentially be cutoff once that subarray sum is found\\n\\t\\t- k  = 4, array  = 0,3,1,2,2,1\\n\\t\\t\\t- prefixSumHashmap = {0,0,3,4,6,8,9}\\n\\t\\t\\t- prefixSumHashmap = {0,0,3,0,2,0,1} -> {0,0,3,4} \\'cut\\'{0,2,4} \\'cut\\' {0,1}\\n\\t\\t\\t\\t- we can \"cut\" off the previous elements before that subarray sum is solved\\n- for the layman, we simply set prefix sum to zero once a subarray sum is found",
                "codeTag": "Unknown"
            },
            {
                "id": 781273,
                "title": "java-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        set.add(0);\\n        int sum = 0;\\n        int count = 0;\\n        for (int num : nums) {\\n            sum += num;\\n            if (set.contains(sum - target)) {\\n                count++;\\n                sum = 0;\\n                set.clear();\\n                set.add(0);\\n            } else {\\n                set.add(sum);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        set.add(0);\\n        int sum = 0;\\n        int count = 0;\\n        for (int num : nums) {\\n            sum += num;\\n            if (set.contains(sum - target)) {\\n                count++;\\n                sum = 0;\\n                set.clear();\\n                set.add(0);\\n            } else {\\n                set.add(sum);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781173,
                "title": "python-easy-o-n-soln-using-hash-map-and-prefix-sum",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        mp = defaultdict(int)\\n        mp = {0:-1}\\n        curr_sum = 0\\n        res = 0\\n        for i in range(n):\\n            curr_sum+=nums[i]\\n            if curr_sum-target in mp:\\n                mp.clear()\\n                res+=1\\n            mp[curr_sum] = i\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        mp = defaultdict(int)\\n        mp = {0:-1}\\n        curr_sum = 0\\n        res = 0\\n        for i in range(n):\\n            curr_sum+=nums[i]\\n            if curr_sum-target in mp:\\n                mp.clear()\\n                res+=1\\n            mp[curr_sum] = i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780999,
                "title": "java-prefix-sum-map-o-n",
                "content": "```\\nclass Solution\\n{\\n    public int maxNonOverlapping(int[] nums, int target)\\n    {\\n        int count = 0;\\n        Map<Integer, List<Integer>> sumIdxesMap = new HashMap<>();\\n        sumIdxesMap.computeIfAbsent(0, k -> new ArrayList<>()).add(-1);\\n        int sum = 0;\\n        int prev = -1;\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            sum += nums[i];\\n            List<Integer> idxes = sumIdxesMap.getOrDefault(sum - target, new ArrayList<>());\\n            if (idxes.size() > 0 && idxes.get(idxes.size() - 1) + 1 > prev)\\n            {\\n                count++;\\n                prev = i;\\n            }\\n            sumIdxesMap.computeIfAbsent(sum, k -> new ArrayList<>());\\n            sumIdxesMap.get(sum).add(i);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int maxNonOverlapping(int[] nums, int target)\\n    {\\n        int count = 0;\\n        Map<Integer, List<Integer>> sumIdxesMap = new HashMap<>();\\n        sumIdxesMap.computeIfAbsent(0, k -> new ArrayList<>()).add(-1);\\n        int sum = 0;\\n        int prev = -1;\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            sum += nums[i];\\n            List<Integer> idxes = sumIdxesMap.getOrDefault(sum - target, new ArrayList<>());\\n            if (idxes.size() > 0 && idxes.get(idxes.size() - 1) + 1 > prev)\\n            {\\n                count++;\\n                prev = i;\\n            }\\n            sumIdxesMap.computeIfAbsent(sum, k -> new ArrayList<>());\\n            sumIdxesMap.get(sum).add(i);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780932,
                "title": "c-easy-to-understand-solution",
                "content": "Intuition :\\nStore index of last \"curr\" everytime and use last index of \"curr - target\" for calculation\\n\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int, int> mp;\\n        mp[0] = -1;\\n        int sum = 0, count = 0, last = -1;\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            if (mp.find(sum - target) != mp.end() && mp[sum - target] + 1 > last) {\\n                count++;\\n                last = i;\\n            }\\n            mp[sum] = i;\\n        }\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int, int> mp;\\n        mp[0] = -1;\\n        int sum = 0, count = 0, last = -1;\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            if (mp.find(sum - target) != mp.end() && mp[sum - target] + 1 > last) {\\n                count++;\\n                last = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 780931,
                "title": "python-o-n-comments-and-explaination-job-schedulling",
                "content": "EXPLAINATION:-\\n#     ***Firstly find all subarry with sum equal to TARGET then form a list having stating index and end index of every subarray than greedily apply job schedulling algo so than maximum number of subarrays can be found in O(n)***\\n   ```\\n\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        # job schedulling\\n        d={}\\n        d[0]=-1\\n        l=[]\\n        pref=0\\n        for i in range(len(nums)):\\n            pref+=nums[i]\\n            if pref-target in d:\\n                l.append([d[pref-target]+1,i])\\n            d[pref]=i\\n        # l contains starting and end of each possible subarray equal to target\\n        l.sort(key=lambda x:x[1])\\n        prev=-2\\n        ans=0\\n        for i in l:\\n            if i[0]>prev:\\n                ans+=1\\n                prev=i[1]\\n        return ans\\n   ```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        # job schedulling\\n        d={}\\n        d[0]=-1\\n        l=[]\\n        pref=0\\n        for i in range(len(nums)):\\n            pref+=nums[i]\\n            if pref-target in d:\\n                l.append([d[pref-target]+1,i])\\n            d[pref]=i\\n        # l contains starting and end of each possible subarray equal to target\\n        l.sort(key=lambda x:x[1])\\n        prev=-2\\n        ans=0\\n        for i in l:\\n            if i[0]>prev:\\n                ans+=1\\n                prev=i[1]\\n        return ans\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 780913,
                "title": "javascript-extended-problem-of-finding-subarray-o-n",
                "content": "It is the extended question for finding the subarray whose sum === target\\nNote that if at index `j` we could find the targeted subarray between `[i, j]`, it means that we cannot use the subarray `[0, j]` anymore because the remaining possible subarrays cannot be overlapping.\\nBased on this idea, if this index is achieved, we only need to\\n1. clean the subsum set, and\\n2. restart finding the new subarray starting from the new index.\\n\\n```\\nvar maxNonOverlapping = function(nums, target) {\\n    let set = new Set(), res = 0, total = 0;\\n    \\n    for (let num of nums) {\\n        total += num;\\n        if (set.has(total-target) || total === target) {\\n            res++;\\n            set.clear();\\n            total = 0;\\n        } else {\\n            set.add(total);\\n        }\\n    }\\n    \\n    return res;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "It is the extended question for finding the subarray whose sum === target\\nNote that if at index `j` we could find the targeted subarray between `[i, j]`, it means that we cannot use the subarray `[0, j]` anymore because the remaining possible subarrays cannot be overlapping.\\nBased on this idea, if this index is achieved, we only need to\\n1. clean the subsum set, and\\n2. restart finding the new subarray starting from the new index.\\n\\n```\\nvar maxNonOverlapping = function(nums, target) {\\n    let set = new Set(), res = 0, total = 0;\\n    \\n    for (let num of nums) {\\n        total += num;\\n        if (set.has(total-target) || total === target) {\\n            res++;\\n            set.clear();\\n            total = 0;\\n        } else {\\n            set.add(total);\\n        }\\n    }\\n    \\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 780896,
                "title": "python3-o-n-one-pass-with-explanation",
                "content": "```python\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        res = 0\\n        prefix_sum = 0\\n        \\n        # prefix sums seen since last solution (subarray that sums to target)\\n        seen = { 0 }\\n\\n        for x in nums:\\n            # add value to prefix sum\\n            prefix_sum += x\\n            \\n            # if we find another solution subarray\\n            if prefix_sum - target in seen:\\n                # increment number of subarrays\\n                res += 1\\n                # and reset seen set\\n                seen = { prefix_sum }\\n            else:\\n                seen.add(prefix_sum)\\n        return res\\n```\\n\\nTime: O(N)\\nSpace: O(N)",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        res = 0\\n        prefix_sum = 0\\n        \\n        # prefix sums seen since last solution (subarray that sums to target)\\n        seen = { 0 }\\n\\n        for x in nums:\\n            # add value to prefix sum\\n            prefix_sum += x\\n            \\n            # if we find another solution subarray\\n            if prefix_sum - target in seen:\\n                # increment number of subarrays\\n                res += 1\\n                # and reset seen set\\n                seen = { prefix_sum }\\n            else:\\n                seen.add(prefix_sum)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780881,
                "title": "java-hashset-o-n",
                "content": "```\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        Set<Integer> hs = new HashSet();\\n        int ans = 0;\\n        int sum = 0;\\n        for(int i: nums){\\n            sum += i;\\n            if(sum == target || hs.contains(sum-target)){\\n                ans ++;\\n                sum = 0;\\n                hs = new HashSet();\\n            }else{\\n                hs.add(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        Set<Integer> hs = new HashSet();\\n        int ans = 0;\\n        int sum = 0;\\n        for(int i: nums){\\n            sum += i;\\n            if(sum == target || hs.contains(sum-target)){\\n                ans ++;\\n                sum = 0;\\n                hs = new HashSet();\\n            }else{\\n                hs.add(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092444,
                "title": "answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int answer=0;\\n        int i=0,n=nums.length;\\n\\n        while(i<n)\\n        {\\n            int s=0;\\n            Set<Integer> seen =new HashSet<>();\\n            seen.add(0);\\n            while(i<n)\\n            {\\n                s+=nums[i];\\n                if(seen.contains(s-target))\\n                {\\n                    ++answer;\\n                    break;\\n                }\\n                ++i;\\n                seen.add(s);\\n            }\\n            ++i;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int answer=0;\\n        int i=0,n=nums.length;\\n\\n        while(i<n)\\n        {\\n            int s=0;\\n            Set<Integer> seen =new HashSet<>();\\n            seen.add(0);\\n            while(i<n)\\n            {\\n                s+=nums[i];\\n                if(seen.contains(s-target))\\n                {\\n                    ++answer;\\n                    break;\\n                }\\n                ++i;\\n                seen.add(s);\\n            }\\n            ++i;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000227,
                "title": "easy-to-understand-do-as-you-think",
                "content": "# Intuition \\nwe have to require to trake previous sum to get target in subsequent sub array and for counting the total number of subarray.\\nData Structure require: map.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsurely you are able to think about it. if u get any subarray of sum == target than it will be your answer and this interval will be not consider in further subarray...\\nso we have now other subarray for which we have to find target again...and so on. **LET\\'S CODE**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N) +O(log N) ....to clear all element from map\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int prefix=0; // track prefix sum\\n        int cnt=0; // total count\\n        unordered_map<int,int> mp; \\n        mp[0]=-1;  // for edge case\\n        for(int i=0;i<nums.size();i++){\\n            prefix+=nums[i]; // update prefix sum till that index\\n            if(mp.find(prefix-target)!=mp.end()){  // if prefix-target find it means it will be answer\\n                cnt++; // for this increse count\\n                mp.clear();// now we have solve another problem to get target so clear map\\n                prefix=0; // set prefixsum=0;\\n            }\\n            mp[prefix]++; // otherwise insert in map\\n        }\\n        return cnt;\\n    }\\n};\\n\\n*****PLEASE UPVOTE IF IT\\'S HELP*****\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int prefix=0; // track prefix sum\\n        int cnt=0; // total count\\n        unordered_map<int,int> mp; \\n        mp[0]=-1;  // for edge case\\n        for(int i=0;i<nums.size();i++){\\n            prefix+=nums[i]; // update prefix sum till that index\\n            if(mp.find(prefix-target)!=mp.end()){  // if prefix-target find it means it will be answer\\n                cnt++; // for this increse count\\n                mp.clear();// now we have solve another problem to get target so clear map\\n                prefix=0; // set prefixsum=0;\\n            }\\n            mp[prefix]++; // otherwise insert in map\\n        }\\n        return cnt;\\n    }\\n};\\n\\n*****PLEASE UPVOTE IF IT\\'S HELP*****\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930572,
                "title": "c-unordered-map-prefix-sum-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int t) {\\n        unordered_map<int,int> mp;\\n        int sum=0;\\n        mp[sum]=0;\\n        int ans=0;\\n        int h=-1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(mp.count(sum-t)){\\n                if(mp[sum-t]>=h){\\n                    ans++;\\n                    mp[sum]=i+1;\\n                    h=mp[sum];\\n                    // ans++;\\n                }\\n                else{\\n                    mp[sum]=i+1; \\n                }\\n            }\\n            else\\n            mp[sum]=i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int t) {\\n        unordered_map<int,int> mp;\\n        int sum=0;\\n        mp[sum]=0;\\n        int ans=0;\\n        int h=-1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(mp.count(sum-t)){\\n                if(mp[sum-t]>=h){\\n                    ans++;\\n                    mp[sum]=i+1;\\n                    h=mp[sum];\\n                    // ans++;\\n                }\\n                else{\\n                    mp[sum]=i+1; \\n                }\\n            }\\n            else\\n            mp[sum]=i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930023,
                "title": "easy-to-understand-javascript-solution-prefix-sum",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar maxNonOverlapping = function(nums, target) {\\n    const prefixSum = new Set([0]);\\n    let current = result = 0;\\n\\n    for (let index = 0; index < nums.length; index++) {\\n        current += nums[index];\\n\\n        if (prefixSum.has(current - target)) {\\n            current = 0;\\n            result += 1;\\n            prefixSum.clear();\\n            prefixSum.add(0);\\n        } \\n        else prefixSum.add(current);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxNonOverlapping = function(nums, target) {\\n    const prefixSum = new Set([0]);\\n    let current = result = 0;\\n\\n    for (let index = 0; index < nums.length; index++) {\\n        current += nums[index];\\n\\n        if (prefixSum.has(current - target)) {\\n            current = 0;\\n            result += 1;\\n            prefixSum.clear();\\n            prefixSum.add(0);\\n        } \\n        else prefixSum.add(current);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923182,
                "title": "easy-solution-begineer-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n      \\n        map<int,int> mp;\\n        mp[0]=-1;\\n        int count=0;\\n        int n=nums.size();\\n        int sum=0,lastIndex=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            if(mp.find(sum-target)!=mp.end() && mp[sum-target]>=lastIndex)\\n            {\\n                cout<<i<<endl;\\n                count++;\\n                lastIndex=i;\\n            }\\n            mp[sum]=i;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n      \\n        map<int,int> mp;\\n        mp[0]=-1;\\n        int count=0;\\n        int n=nums.size();\\n        int sum=0,lastIndex=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            if(mp.find(sum-target)!=mp.end() && mp[sum-target]>=lastIndex)\\n            {\\n                cout<<i<<endl;\\n                count++;\\n                lastIndex=i;\\n            }\\n            mp[sum]=i;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3906698,
                "title": "c-prefix-sum-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int count = 0;\\n        vector<int> prefix(n);\\n        prefix[0] = nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i] = prefix[i-1]+nums[i];\\n        }\\n        set<int> st;\\n        st.insert(0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!st.empty() && st.find(prefix[i]-target)!=st.end())\\n            {\\n                st.clear();\\n                count++;\\n                //st.insert(prefix[i]);\\n            }\\n            st.insert(prefix[i]);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int count = 0;\\n        vector<int> prefix(n);\\n        prefix[0] = nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i] = prefix[i-1]+nums[i];\\n        }\\n        set<int> st;\\n        st.insert(0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!st.empty() && st.find(prefix[i]-target)!=st.end())\\n            {\\n                st.clear();\\n                count++;\\n                //st.insert(prefix[i]);\\n            }\\n            st.insert(prefix[i]);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894965,
                "title": "go-lang-solution-with-map-in-one-pass",
                "content": "# Intuition\\n\\nI first implemented solution without maps, then realisec it won\\'t work, then implemented greedy solution with maps and added memo as it timed out and only then understood that non of that coplexity was necessary and we can do it in one pass. Leaving the last iteration I had before I implemented solution downbelow, so if you feel frustrated \\u2014 please don\\'t be.\\n\\n```\\nfunc maxNonOverlapping(nums []int, target int) int {\\n    // Clear between runs\\n    memo = map[int]int{}\\n    return maxNonOverlappingMemo(nums, 0, target)\\n}\\n\\nvar memo = map[int]int{}\\n\\nfunc maxNonOverlappingMemo(nums []int, from int, target int) int {\\n    if ans, ok := memo[from]; ok {\\n        return ans\\n    }\\n\\n    subSlicesWithSum := func() []int {\\n        // Use map to store sum seen so far\\n        sums := map[int]bool{0: true}\\n        var sum int\\n        var ans []int\\n        for i := from; i < len(nums); i++ {\\n            sum += nums[i]\\n            if _, ok := sums[sum-target]; ok {\\n                ans = append(ans, i)\\n            }\\n            sums[sum] = true\\n        }\\n        return ans\\n    }\\n\\n    var ans int\\n    for _, opt := range subSlicesWithSum() {\\n        ans = max(ans, 1+maxNonOverlappingMemo(nums, opt+1, target))\\n    }\\n\\n    memo[from] = ans\\n    return ans    \\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\\n\\n# Approach\\n\\nOne run with checking the borders of last picked solution.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfunc maxNonOverlapping(nums []int, target int) int {\\n    sums := map[int]int{0:0}\\n    var sum hint\\n    var last int\\n    var ans int\\n    for i := 0; i < len(nums); i++ {\\n        sum += nums[i]\\n        if begin, ok := sums[sum-target]; ok && begin >= last {\\n            delete(sums, sum-target)\\n            last = i\\n            ans++\\n        }\\n        sums[sum] = i\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table"
                ],
                "code": "```\\nfunc maxNonOverlapping(nums []int, target int) int {\\n    // Clear between runs\\n    memo = map[int]int{}\\n    return maxNonOverlappingMemo(nums, 0, target)\\n}\\n\\nvar memo = map[int]int{}\\n\\nfunc maxNonOverlappingMemo(nums []int, from int, target int) int {\\n    if ans, ok := memo[from]; ok {\\n        return ans\\n    }\\n\\n    subSlicesWithSum := func() []int {\\n        // Use map to store sum seen so far\\n        sums := map[int]bool{0: true}\\n        var sum int\\n        var ans []int\\n        for i := from; i < len(nums); i++ {\\n            sum += nums[i]\\n            if _, ok := sums[sum-target]; ok {\\n                ans = append(ans, i)\\n            }\\n            sums[sum] = true\\n        }\\n        return ans\\n    }\\n\\n    var ans int\\n    for _, opt := range subSlicesWithSum() {\\n        ans = max(ans, 1+maxNonOverlappingMemo(nums, opt+1, target))\\n    }\\n\\n    memo[from] = ans\\n    return ans    \\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\n```\\nfunc maxNonOverlapping(nums []int, target int) int {\\n    sums := map[int]int{0:0}\\n    var sum hint\\n    var last int\\n    var ans int\\n    for i := 0; i < len(nums); i++ {\\n        sum += nums[i]\\n        if begin, ok := sums[sum-target]; ok && begin >= last {\\n            delete(sums, sum-target)\\n            last = i\\n            ans++\\n        }\\n        sums[sum] = i\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3884811,
                "title": "easy-c-beats-90-time",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        unordered_map<int,int> mp;\\n        mp[0] = -1;\\n        int prev=-1,ans=0,sum=0;\\n        for(int i=0; i<n; i++) {\\n            sum += nums[i];\\n            if(mp.find(sum-target)!=mp.end()) {\\n                if(mp[sum-target] >= prev) {\\n                    ans++;\\n                    prev = i;\\n                }\\n            }\\n            mp[sum] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        unordered_map<int,int> mp;\\n        mp[0] = -1;\\n        int prev=-1,ans=0,sum=0;\\n        for(int i=0; i<n; i++) {\\n            sum += nums[i];\\n            if(mp.find(sum-target)!=mp.end()) {\\n                if(mp[sum-target] >= prev) {\\n                    ans++;\\n                    prev = i;\\n                }\\n            }\\n            mp[sum] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858916,
                "title": "simple-python3-solution-with-sets-and-running-sums-99",
                "content": "# Intuition\\nWe want to greedily find the end index of the subarray, but don\\'t care about the start index. As long as we end the subarray at the lowest possible index, we \"leave room\" for as many additional subarrays as possible.\\n\\nSince we\\'re looking at subarrays, we are probably going to want some kind of running sum. However, because the input can contain negative numbers, we can\\'t easily use the common approach of a moving window, since we can\\'t determine how to change the window borders using only the sum of the current window.\\n\\n# Approach\\nTraverse through *nums* storing the running sum at each index.\\n\\nNotice that for a list *L*, with *j* > *i*,\\n`L[:i] + L[i:j] == L[:j]`, so\\n`sum(L[:i]) + sum(L[i:j]) == sum(L[:j])`\\nRearranged, this becomes\\n`sum(L[:i]) - sum(L[:j]) == sum(L[i:j])`\\n\\nTherefore, if the difference between the running sum at index *j* and a prior running sum at index *i* is equal to *target*, we know that the sum of the subarray from indices *i* to *j* will be equal to *target*.\\nIn other words, *j* is the end of a subarray that sums to target if and only if\\n`runningSum[j] - runningSum[i] == target`\\nfor some *i*. Instead of looping over each possible *i*, we can rearrange this to\\n`runningSum[j] - target == runningSum[i]`. We can now simply compute `runningSum[j] - target` and check if the value is present in our running sums. Since we don\\'t need to find the indices of the subarrays, only count them, we can use a set to track running sums instead of a list, reducing the time complexity of checking for a value to `O(1)`.\\n\\nSo our solution is:\\n- Initialize `runningSums = set([0])` and `currentSum = 0`, as well as a tracker `subarraysFound = 0`\\n- Iterate over `nums`. For each `num`:\\n-- add `num` to `currentSum`\\n-- check if `currentSum - target` is in `runningSums`\\n-- if it is, we\\'ve found the end of a subarray with the target sum. So, increment `subarraysFound`, and reset `runningSums` and `currentSum`\\n-- if it\\'s not, add `currentSum` to `runningSums`\\n- When we\\'ve finished iterating over `nums`, return `subarraysFound`\\n\\n\\nTime and space complexity: `O(n)`\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        runningSums = set([0])\\n        subarraysFound = 0\\n        currentSum = 0\\n        for num in nums:\\n            currentSum += num\\n            if currentSum - target in runningSums:\\n                subarraysFound += 1\\n                runningSums = set([0])\\n                currentSum = 0\\n            else:\\n                runningSums.add(currentSum)\\n        return subarraysFound\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        runningSums = set([0])\\n        subarraysFound = 0\\n        currentSum = 0\\n        for num in nums:\\n            currentSum += num\\n            if currentSum - target in runningSums:\\n                subarraysFound += 1\\n                runningSums = set([0])\\n                currentSum = 0\\n            else:\\n                runningSums.add(currentSum)\\n        return subarraysFound\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853931,
                "title": "prefix-sum-of-latest-index-with-a-pointer-to-the-next-index",
                "content": "# Intuition\\nInital idea was to use sliding window, however, as the array consist of negative number that is not possible.\\nHence, this hints to prefix sum.\\nNow this is a typical prefix sum, find target. with just ignoring overlaps sub arrays. To do that we keep a start pointer for the next sub array that sums up to the target. The start pointer will always be i + 1 indicating the next possible position of the non overlapping next sub array.\\nAlso out prefix hashmap will maintain, sum of latest index, by maintaing sum of latest index we can ensure that the resultant array will aleast be the rightmost portion,\\n\\n# Approach\\nPrefix sum hashmap of latest index\\nA next pointer to avoid all the sub arrays whos start point is less than the next pointer\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n\\n        #prefixsum hashtable\\n        pre = {\\n            0 : -1\\n        }\\n        #prefix sum\\n        p = 0\\n        #answer count\\n        c = 0\\n        #next available starting position for the valid subarray\\n        #that aint overlapping\\n        next_ = 0\\n\\n        for i in range(len(nums)):\\n            #current number\\n            n = nums[i]\\n            #updating the prefix sum\\n            p += n\\n            #diff\\n            d = p - target\\n            #previous index \\n            idx = pre.get(d,None) \\n            if idx is not None and idx + 1 >= next_:                \\n                c +=1\\n                next_ = i + 1\\n            #updating the prefix sum hashtable\\n            pre[p] = i\\n\\n        return c\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n\\n        #prefixsum hashtable\\n        pre = {\\n            0 : -1\\n        }\\n        #prefix sum\\n        p = 0\\n        #answer count\\n        c = 0\\n        #next available starting position for the valid subarray\\n        #that aint overlapping\\n        next_ = 0\\n\\n        for i in range(len(nums)):\\n            #current number\\n            n = nums[i]\\n            #updating the prefix sum\\n            p += n\\n            #diff\\n            d = p - target\\n            #previous index \\n            idx = pre.get(d,None) \\n            if idx is not None and idx + 1 >= next_:                \\n                c +=1\\n                next_ = i + 1\\n            #updating the prefix sum hashtable\\n            pre[p] = i\\n\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830776,
                "title": "hashing-prefix-and-few-lines-of-codes-which-are-well-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        set<int>s;\\n        s.insert(0);\\n        int ps = 0 ,ans = 0 ;\\n        for(int x:nums){\\n           ps+=x;\\n           if(s.find(ps-target)!=s.end()){\\n               ans++;\\n               ps = 0 ;\\n               s.clear();\\n           }\\n           s.insert(ps);\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        set<int>s;\\n        s.insert(0);\\n        int ps = 0 ,ans = 0 ;\\n        for(int x:nums){\\n           ps+=x;\\n           if(s.find(ps-target)!=s.end()){\\n               ans++;\\n               ps = 0 ;\\n               s.clear();\\n           }\\n           s.insert(ps);\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781307,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\npublic:\\n  int maxNonOverlapping(const vector<int> &nums, const int target) {\\n    const int n = static_cast<int>(nums.size());\\n    unordered_set<int> sums({0});\\n    int ret = 0;\\n    for (int sum = 0, i = 0; i < n; ++i) {\\n      sum += nums[i];\\n      if (sums.find(sum - target) != sums.end()) {\\n        ++ret;\\n        sums = {0};\\n        sum = 0;\\n        continue;\\n      }\\n      \\n      sums.emplace(sum);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\npublic:\\n  int maxNonOverlapping(const vector<int> &nums, const int target) {\\n    const int n = static_cast<int>(nums.size());\\n    unordered_set<int> sums({0});\\n    int ret = 0;\\n    for (int sum = 0, i = 0; i < n; ++i) {\\n      sum += nums[i];\\n      if (sums.find(sum - target) != sums.end()) {\\n        ++ret;\\n        sums = {0};\\n        sum = 0;\\n        continue;\\n      }\\n      \\n      sums.emplace(sum);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752990,
                "title": "simple-o-n-using-set-very-easy",
                "content": "# Intuition\\nStore the running sum while traversing through the array.\\n\\n# Approach\\nPrefix Sum, record the running sum and check if current (sum - target) already exists in the set. If it exists, it means that we found a subarray. Clear the values in the set (to avoid overlapping subarrays) and set the running sum to 0.Repeat the same process from the next element.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) for set.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        \\n        set<int> s;\\n        int rs = 0;\\n        int cnt = 0;\\n\\n        for(int i = 0; i < nums.size(); i++){\\n\\n            rs+= nums[i];\\n            if(s.find(rs - target) != s.end() || rs == target){\\n                s.clear();\\n                rs = 0;\\n                cnt++;\\n            }\\n            s.insert(rs);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        \\n        set<int> s;\\n        int rs = 0;\\n        int cnt = 0;\\n\\n        for(int i = 0; i < nums.size(); i++){\\n\\n            rs+= nums[i];\\n            if(s.find(rs - target) != s.end() || rs == target){\\n                s.clear();\\n                rs = 0;\\n                cnt++;\\n            }\\n            s.insert(rs);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740510,
                "title": "optimal-solution-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        prefix = 0\\n        count = set([0])\\n        ans = 0\\n\\n        for n in nums:\\n            prefix += n\\n            if prefix - target in count:\\n                ans += 1\\n                count = set()\\n            count.add(prefix)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        prefix = 0\\n        count = set([0])\\n        ans = 0\\n\\n        for n in nums:\\n            prefix += n\\n            if prefix - target in count:\\n                ans += 1\\n                count = set()\\n            count.add(prefix)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672648,
                "title": "c-using-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        set<int> st;\\n        int ps=0; int ans=0;\\n        st.insert(0);\\n        for (int it:nums){\\n            ps+=it;\\n            if (st.find(ps-target)!=st.end()){\\n                ans++;\\n            st.clear();\\n            }\\n            st.insert(ps);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        set<int> st;\\n        int ps=0; int ans=0;\\n        st.insert(0);\\n        for (int it:nums){\\n            ps+=it;\\n            if (st.find(ps-target)!=st.end()){\\n                ans++;\\n            st.clear();\\n            }\\n            st.insert(ps);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597369,
                "title": "simple-using-unordered-map-easy-elegant-solution-o-n-specially-designed-for-beginner-s",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int ans=0;\\n        int n = nums.size();\\n        int preSum=0;\\n        unordered_map<int,int>mp;\\n        mp[0]=1;\\n        for(auto x: nums){\\n            preSum+=x;\\n            if(mp.count(preSum - target)){\\n                ans++;\\n                mp.clear(); // clearing the mp as we don\\'t require the subarray to be overlapping, by clearning this the subarray considered will be non overlapping!\\n            }\\n            mp[preSum]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int ans=0;\\n        int n = nums.size();\\n        int preSum=0;\\n        unordered_map<int,int>mp;\\n        mp[0]=1;\\n        for(auto x: nums){\\n            preSum+=x;\\n            if(mp.count(preSum - target)){\\n                ans++;\\n                mp.clear(); // clearing the mp as we don\\'t require the subarray to be overlapping, by clearning this the subarray considered will be non overlapping!\\n            }\\n            mp[preSum]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578624,
                "title": "c-python-dynamic-programming-solution-with-explanation",
                "content": "\\n### dynamic programming\\nWe can use prefix sum to find subarrays\\'s sum are equal to ```target```, but only focus on the shortest subarray, we can use these shortest subarray at some positions to construct max number answer.\\n```dp[i]``` means maximum number of non-empty non-overlapping subarrays\\'s sum == ```target``` in ```nums[0~i-1]```, and return last dp value.\\nFirst, we can use prefix sum to find shortest subarray end at cuurent position.\\n```\\ndp[0] is 0 because nums[0~-1] is empty. \\ndp[i] = max(dp[i-1], dp[preifx[current sum - target]]+1) if current sum - target in preifx else dp[i-1]\\n```\\ntc and sc are O(n)\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int leng = nums.size();\\n        vector<int> dp (leng+1, 0);\\n        unordered_map<int, int> prefix;\\n        prefix.emplace(0, 0);\\n        for (int i=0, s=0; i<leng; i+=1) {\\n            s += nums[i];\\n            if (prefix.count(s-target)) dp[i+1] = max(1+dp[prefix[s-target]], dp[i]);\\n            else dp[i+1] = dp[i];\\n            prefix[s] = i+1;\\n        }\\n        return dp.back();\\n    }\\n};\\n```\\n### python\\n```python\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        leng = len(nums)\\n        dp = [0] * (leng + 1)\\n        prefix = {0:0}\\n        s = 0\\n        for idx, n in enumerate(nums):\\n            s += n\\n            if s - target in prefix:\\n                dp[idx+1] = max(dp[prefix[s-target]] + 1, dp[idx])\\n            else: dp[idx+1] = dp[idx]\\n            prefix[s] = idx + 1\\n        return dp[-1] \\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```target```\n```dp[i]```\n```target```\n```nums[0~i-1]```\n```\\ndp[0] is 0 because nums[0~-1] is empty. \\ndp[i] = max(dp[i-1], dp[preifx[current sum - target]]+1) if current sum - target in preifx else dp[i-1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int leng = nums.size();\\n        vector<int> dp (leng+1, 0);\\n        unordered_map<int, int> prefix;\\n        prefix.emplace(0, 0);\\n        for (int i=0, s=0; i<leng; i+=1) {\\n            s += nums[i];\\n            if (prefix.count(s-target)) dp[i+1] = max(1+dp[prefix[s-target]], dp[i]);\\n            else dp[i+1] = dp[i];\\n            prefix[s] = i+1;\\n        }\\n        return dp.back();\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        leng = len(nums)\\n        dp = [0] * (leng + 1)\\n        prefix = {0:0}\\n        s = 0\\n        for idx, n in enumerate(nums):\\n            s += n\\n            if s - target in prefix:\\n                dp[idx+1] = max(dp[prefix[s-target]] + 1, dp[idx])\\n            else: dp[idx+1] = dp[idx]\\n            prefix[s] = idx + 1\\n        return dp[-1] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569634,
                "title": "sub-array-sum-k-with-twist",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def maxNonOverlapping(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n\\n\\n        sub array sum = k\\n        \"\"\"\\n\\n\\n\\n        seen = {0:1}\\n\\n        prefix = 0\\n        ans = 0\\n\\n        for n in nums:\\n            prefix +=n\\n\\n            needed = prefix - target \\n            \\n            if needed in seen:\\n                ans+=1\\n\\n                # start of sub new array\\n                prefix = 0\\n                seen = {}\\n\\n            seen[prefix] = 1\\n\\n        return ans\\n            \\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxNonOverlapping(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n\\n\\n        sub array sum = k\\n        \"\"\"\\n\\n\\n\\n        seen = {0:1}\\n\\n        prefix = 0\\n        ans = 0\\n\\n        for n in nums:\\n            prefix +=n\\n\\n            needed = prefix - target \\n            \\n            if needed in seen:\\n                ans+=1\\n\\n                # start of sub new array\\n                prefix = 0\\n                seen = {}\\n\\n            seen[prefix] = 1\\n\\n        return ans\\n            \\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565282,
                "title": "python-thought-process-and-debugging-steps-follow-along",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        \\'\\'\\'\\n        Initial thought: Keep two pointers and if the sum is equal to target, increase the count and set p1,p2 to p2+1\\n        If sum > target: increase p1, reduce s by nums[p1]\\n        And if sum < target: increase p2, increase s by nums[p2]\\n\\n        Why that won\\'t work: Take an example [3,4,-1,4,3,1], target = 6 now p1 = 0 and p2 = 1, sum = 7 Now we incr p1, which isn\\'t right\\n        We would never be able to find [3,4,-1] like that\\n\\n        Another approach: Store the prefix sums and remember which is the last used index\\n        for each number, we see if a subarray starting from last_used +1 or later can have a sum == target\\n        If so\\n        \\'\\'\\'\\n        ps = {}\\n        ps[0] = -1\\n        last_used = -2#We have\\'t used anything. -2 so that we get to inclde p[0]\\n        s = 0\\n        ans = 0\\n        for i in range(len(nums)):\\n            # Prefix sum till ith num\\n            s += nums[i]\\n            #We want a subarray with prefix sum rem\\n            rem = s-target\\n            # We have a sub array after last_used index\\n            if rem in ps and ps[rem] >= last_used:\\n                ans += 1\\n                last_used = i\\n            ps[s] = i\\n        return ans        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```python []\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        \\'\\'\\'\\n        Initial thought: Keep two pointers and if the sum is equal to target, increase the count and set p1,p2 to p2+1\\n        If sum > target: increase p1, reduce s by nums[p1]\\n        And if sum < target: increase p2, increase s by nums[p2]\\n\\n        Why that won\\'t work: Take an example [3,4,-1,4,3,1], target = 6 now p1 = 0 and p2 = 1, sum = 7 Now we incr p1, which isn\\'t right\\n        We would never be able to find [3,4,-1] like that\\n\\n        Another approach: Store the prefix sums and remember which is the last used index\\n        for each number, we see if a subarray starting from last_used +1 or later can have a sum == target\\n        If so\\n        \\'\\'\\'\\n        ps = {}\\n        ps[0] = -1\\n        last_used = -2#We have\\'t used anything. -2 so that we get to inclde p[0]\\n        s = 0\\n        ans = 0\\n        for i in range(len(nums)):\\n            # Prefix sum till ith num\\n            s += nums[i]\\n            #We want a subarray with prefix sum rem\\n            rem = s-target\\n            # We have a sub array after last_used index\\n            if rem in ps and ps[rem] >= last_used:\\n                ans += 1\\n                last_used = i\\n            ps[s] = i\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479051,
                "title": "c-prefix-sum-o-n-1-pass-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int ans=0;\\n        unordered_map<int,int> mp;\\n        for(int i=1;i<nums.size();i++){\\n            nums[i]+=nums[i-1];\\n        }\\n        mp.insert({0,0});\\n        int pre=0;\\n        for(int i=0;i<nums.size();i++){\\n            auto itr=mp.find(nums[i]-target);\\n            int res=pre;\\n            if(itr!=mp.end()){\\n                res=max(res,itr->second+1);\\n                ans=max(ans,res);\\n            }\\n            \\n            if(mp.find(nums[i])==mp.end() || res>mp[nums[i]]){\\n                mp[nums[i]]=res;\\n            }\\n            pre=ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int ans=0;\\n        unordered_map<int,int> mp;\\n        for(int i=1;i<nums.size();i++){\\n            nums[i]+=nums[i-1];\\n        }\\n        mp.insert({0,0});\\n        int pre=0;\\n        for(int i=0;i<nums.size();i++){\\n            auto itr=mp.find(nums[i]-target);\\n            int res=pre;\\n            if(itr!=mp.end()){\\n                res=max(res,itr->second+1);\\n                ans=max(ans,res);\\n            }\\n            \\n            if(mp.find(nums[i])==mp.end() || res>mp[nums[i]]){\\n                mp[nums[i]]=res;\\n            }\\n            pre=ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468823,
                "title": "python-greedy-solution",
                "content": "```py\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        \\n        \\n        total = 0\\n        hashset = {0}\\n        count = 0\\n        \\n        for i in nums:\\n            total += i\\n            if total - target in hashset:\\n                count += 1\\n                hashset.clear()\\n                hashset.add(0)\\n                total = 0\\n            hashset.add(total)\\n            \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```py\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        \\n        \\n        total = 0\\n        hashset = {0}\\n        count = 0\\n        \\n        for i in nums:\\n            total += i\\n            if total - target in hashset:\\n                count += 1\\n                hashset.clear()\\n                hashset.add(0)\\n                total = 0\\n            hashset.add(total)\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457562,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int t) \\n    {\\n             \\n        int c=0;\\n        unordered_map<long long,int>m;\\n        long long ts=0;\\n        int it=1;\\n        for(int i=0;i<nums.size();++i)\\n        {\\n           ts+=nums[i];\\n           if((ts==t)||m[(ts-t)]==it)\\n           {\\n              cout<<i<<\" \";\\n               ++c;\\n               ts=0;\\n               ++it;\\n           }\\n           else\\n               m[ts]=it;\\n        }\\n        return c;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int t) \\n    {\\n             \\n        int c=0;\\n        unordered_map<long long,int>m;\\n        long long ts=0;\\n        int it=1;\\n        for(int i=0;i<nums.size();++i)\\n        {\\n           ts+=nums[i];\\n           if((ts==t)||m[(ts-t)]==it)\\n           {\\n              cout<<i<<\" \";\\n               ++c;\\n               ts=0;\\n               ++it;\\n           }",
                "codeTag": "C++"
            },
            {
                "id": 3456855,
                "title": "maximum-number-of-non-overlapping-subarrays-with-sum-equals-target",
                "content": "---------------- Easy C++ Solution -------------------\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        unordered_map<int, int> sum2count;\\n        int sum = 0;\\n        int count = 0;\\n        \\n        sum2count[0] = 0;\\n        \\n        for(int i = 0; i < n; ++i){\\n            sum += nums[i];\\n            \\n            if(sum2count.find(sum-target) != sum2count.end()){\\n                count = max(count, sum2count[sum-target] + 1);\\n            }\\n            sum2count[sum] = count;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        unordered_map<int, int> sum2count;\\n        int sum = 0;\\n        int count = 0;\\n        \\n        sum2count[0] = 0;\\n        \\n        for(int i = 0; i < n; ++i){\\n            sum += nums[i];\\n            \\n            if(sum2count.find(sum-target) != sum2count.end()){\\n                count = max(count, sum2count[sum-target] + 1);\\n            }\\n            sum2count[sum] = count;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397607,
                "title": "c-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int>a1 , pair<int,int>a2){\\n        return a1.second<=a2.second;\\n    }\\n    int maxNonOverlapping(vector<int>& a, int k)\\n    { int i,n;\\n      n=a.size();\\n      int sum=0;\\n      map<int,int>m;\\n      m[0]=-1;\\n      vector<pair<int,int>>v;\\n      for(i=0;i<n;i++){\\n          sum+=a[i];\\n          if(m.count(sum-k)){\\n              v.push_back({m[sum-k]+1 , i});\\n          }\\n          m[sum]=i;\\n      }\\n      sort(v.begin() , v.end(),cmp);\\n      int ans=0,end=-1;\\n      for(auto va:v){\\n          if(va.first>end){\\n              end=va.second; ans++;\\n          } \\n      }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int>a1 , pair<int,int>a2){\\n        return a1.second<=a2.second;\\n    }\\n    int maxNonOverlapping(vector<int>& a, int k)\\n    { int i,n;\\n      n=a.size();\\n      int sum=0;\\n      map<int,int>m;\\n      m[0]=-1;\\n      vector<pair<int,int>>v;\\n      for(i=0;i<n;i++){\\n          sum+=a[i];\\n          if(m.count(sum-k)){\\n              v.push_back({m[sum-k]+1 , i});\\n          }\\n          m[sum]=i;\\n      }\\n      sort(v.begin() , v.end(),cmp);\\n      int ans=0,end=-1;\\n      for(auto va:v){\\n          if(va.first>end){\\n              end=va.second; ans++;\\n          } \\n      }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393256,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int ans=0;\\n        map<int,int>mp;\\n        mp[0]=-1;\\n        int sum=0;\\n        int end=-1;\\n        for (int i=0;i<nums.size();i++)\\n        {\\n          sum+=nums[i];\\n          if (mp.count(sum-target) && mp[sum-target]>=end)\\n          {\\n              ans++;\\n              end=i;\\n          }\\n          mp[sum]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int ans=0;\\n        map<int,int>mp;\\n        mp[0]=-1;\\n        int sum=0;\\n        int end=-1;\\n        for (int i=0;i<nums.size();i++)\\n        {\\n          sum+=nums[i];\\n          if (mp.count(sum-target) && mp[sum-target]>=end)\\n          {\\n              ans++;\\n              end=i;\\n          }\\n          mp[sum]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382804,
                "title": "c-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck desired target for every iteration.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nit is similiar to subarray sum equal to k.\\nFirst take a set and for array size check if desired target is present in set or not if present then move.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n       unordered_set<int> st;\\n       int count=0;\\n       int sum=0;\\n       st.insert(0);\\n       for(auto &i:nums){\\n           sum+=i;\\n           if(st.count(sum-target)){\\n               count++;\\n               st={0};\\n               sum=0;\\n           }\\n           else \\n            st.insert(sum);\\n       }\\n       return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n       unordered_set<int> st;\\n       int count=0;\\n       int sum=0;\\n       st.insert(0);\\n       for(auto &i:nums){\\n           sum+=i;\\n           if(st.count(sum-target)){\\n               count++;\\n               st={0};\\n               sum=0;\\n           }\\n           else \\n            st.insert(sum);\\n       }\\n       return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313744,
                "title": "python-prefixsum-w-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxNonOverlapping(self, A: List[int], k: int) -> int:\\n        d = {0 : -1}\\n        cumsum, res, lastEndIdx = 0, 0, -1\\n        for i, x in enumerate(A):\\n            cumsum += x\\n            if cumsum-k in d and d[cumsum-k] >= lastEndIdx: #startingIdx-1 >= lastEndingIdx\\n                res += 1\\n                lastEndIdx = i\\n            d[cumsum] = i #endingIdx of subarr\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, A: List[int], k: int) -> int:\\n        d = {0 : -1}\\n        cumsum, res, lastEndIdx = 0, 0, -1\\n        for i, x in enumerate(A):\\n            cumsum += x\\n            if cumsum-k in d and d[cumsum-k] >= lastEndIdx: #startingIdx-1 >= lastEndingIdx\\n                res += 1\\n                lastEndIdx = i\\n            d[cumsum] = i #endingIdx of subarr\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308776,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) perform a reverse linear scan of the suffix sums `S` of the input array `A`, then for each suffix sum total `t`, the corresponding previously seen suffix sum total we `need` to reach target `T` is `t - T`.  Thus, we keep track of each previous suffix sum total `t` which we `have` in a set for O(1) lookups, and increment the subarray count `cnt` when we `have` what we `need` (and we clear what we `have` to only consider non-overlapping the subarrays).\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxNonOverlapping(A: IntArray, T: Int): Int {\\n        var N = A.size\\n        var S = intArrayOf(*A, 0)\\n        for (i in N - 1 downTo 0)\\n            S[i] += S[i + 1]\\n        var (cnt, have) = Pair(0, mutableSetOf<Int>())\\n        for (t in S.reversed()) {\\n            var need = t - T\\n            if (have.contains(need)) {\\n                ++cnt; have.clear()\\n            }\\n            have.add(t)\\n        }\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maxNonOverlapping = (A, T, have = new Set(), cnt = 0) => {\\n    let N = A.length;\\n    let S = [...A, 0];\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] += S[i + 1];\\n    for (let t of S.reverse()) {\\n        let need = t - T;\\n        if (have.has(need))\\n            ++cnt, have.clear();\\n        have.add(t);\\n    }\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxNonOverlapping(self, A: List[int], T: int, cnt = 0) -> int:\\n        S = A[:] + [0]\\n        for i in reversed(range(len(A))):\\n            S[i] += S[i + 1]\\n        have = set()\\n        for t in reversed(S):\\n            need = t - T\\n            if need in have:\\n                cnt += 1; have.clear()\\n            have.add(t)\\n        return cnt\\n```\\n\\n*Rust*\\n```\\nuse std::collections::HashSet;\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn max_non_overlapping(mut A: VI, T: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = A.drain(..).collect::<VI>(); S.push(0);\\n        for i in (0..N - 1).rev() {\\n            S[i] += S[i + 1];\\n        }\\n        let (mut cnt, mut have) = (0, HashSet::new());\\n        for t in S.into_iter().rev() {\\n            let need = t - T;\\n            if have.contains(&need) {\\n                cnt += 1; have.clear();\\n            }\\n            have.insert(t);\\n        }\\n        cnt\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    int maxNonOverlapping(VI& A, int T, Set have = {}, int cnt = 0) {\\n        int N = A.size();\\n        VI S{ A }; S.push_back(0);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] += S[i + 1];\\n        for (auto t: VI{ S.rbegin(), S.rend() }) {\\n            auto need = t - T;\\n            if (have.find(need) != have.end())\\n                ++cnt, have.clear();\\n            have.insert(t);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxNonOverlapping(A: IntArray, T: Int): Int {\\n        var N = A.size\\n        var S = intArrayOf(*A, 0)\\n        for (i in N - 1 downTo 0)\\n            S[i] += S[i + 1]\\n        var (cnt, have) = Pair(0, mutableSetOf<Int>())\\n        for (t in S.reversed()) {\\n            var need = t - T\\n            if (have.contains(need)) {\\n                ++cnt; have.clear()\\n            }\\n            have.add(t)\\n        }\\n        return cnt\\n    }\\n}\\n```\n```\\nlet maxNonOverlapping = (A, T, have = new Set(), cnt = 0) => {\\n    let N = A.length;\\n    let S = [...A, 0];\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] += S[i + 1];\\n    for (let t of S.reverse()) {\\n        let need = t - T;\\n        if (have.has(need))\\n            ++cnt, have.clear();\\n        have.add(t);\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def maxNonOverlapping(self, A: List[int], T: int, cnt = 0) -> int:\\n        S = A[:] + [0]\\n        for i in reversed(range(len(A))):\\n            S[i] += S[i + 1]\\n        have = set()\\n        for t in reversed(S):\\n            need = t - T\\n            if need in have:\\n                cnt += 1; have.clear()\\n            have.add(t)\\n        return cnt\\n```\n```\\nuse std::collections::HashSet;\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn max_non_overlapping(mut A: VI, T: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = A.drain(..).collect::<VI>(); S.push(0);\\n        for i in (0..N - 1).rev() {\\n            S[i] += S[i + 1];\\n        }\\n        let (mut cnt, mut have) = (0, HashSet::new());\\n        for t in S.into_iter().rev() {\\n            let need = t - T;\\n            if have.contains(&need) {\\n                cnt += 1; have.clear();\\n            }\\n            have.insert(t);\\n        }\\n        cnt\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    int maxNonOverlapping(VI& A, int T, Set have = {}, int cnt = 0) {\\n        int N = A.size();\\n        VI S{ A }; S.push_back(0);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] += S[i + 1];\\n        for (auto t: VI{ S.rbegin(), S.rend() }) {\\n            auto need = t - T;\\n            if (have.find(need) != have.end())\\n                ++cnt, have.clear();\\n            have.insert(t);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280703,
                "title": "set-based",
                "content": "public int maxNonOverlapping(int[] nums, int target) {\\n        Set<Integer> set = new HashSet<>();\\n        int sum = 0;\\n        int ans = 0;\\n        set.add(0);\\n        0,1,1 , target = 2\\n        for(int x:nums){\\n            sum += x;\\n            int complement = sum - target;\\n            if (set.contains(complement)){\\n                ans++;\\n                sum = 0;\\n                set  = new HashSet<>();\\n                set.add(0);\\n            } else {\\n                set.add(sum);\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "public int maxNonOverlapping(int[] nums, int target) {\\n        Set<Integer> set = new HashSet<>();\\n        int sum = 0;\\n        int ans = 0;\\n        set.add(0);\\n        0,1,1 , target = 2\\n        for(int x:nums){\\n            sum += x;\\n            int complement = sum - target;\\n            if (set.contains(complement)){\\n                ans++;\\n                sum = 0;\\n                set  = new HashSet<>();\\n                set.add(0);\\n            } else {\\n                set.add(sum);\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3262873,
                "title": "c-prefix-hashmap-o-n",
                "content": "# Approach\\nIt is similar to problem like count subarray sum equal to k. Only difference is here we need to ensure that no overlapping takes place so as we found any subarray with sum equal to target we need to remove from our space.\\n\\n# Complexity\\n- Time complexity:\\nLinear Time O(n) as traversing whole take place in O(n) and finding and clearing map takes O(1) average so overall O(n) TC\\n\\n- Space complexity:\\n O(n) (unordered_map)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n           unordered_map<int,int>trackSum;\\n           int n=nums.size();\\n\\n           // calculating running sum till ith index\\n           int sum=0;\\n\\n           // cnt non overlapping subarray with sum equal to target \\n           int cnt=0;\\n\\n           // fixed sum will help in subtracting sum of already subarray found to avoid recalculation of prefixSum.\\n           int fixedSum=0;\\n           // when single element  equal to target\\n           trackSum[0]=1;\\n\\n           for(int i=0;i<n;i++)\\n           {\\n                sum+=nums[i];\\n                // if we already found prefixsum of sum-target then we can clear our trackSum and start again \\n                if(trackSum.find(-target+sum)!=trackSum.end())\\n                {\\n                    trackSum.clear();\\n                    trackSum[0]=1;\\n                    fixedSum=sum;\\n                    // subtracting to start prefixSum from current index\\n                    sum-=fixedSum;\\n                    cnt++;\\n                }\\n                trackSum[sum]++;\\n\\n           }\\n           return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n           unordered_map<int,int>trackSum;\\n           int n=nums.size();\\n\\n           // calculating running sum till ith index\\n           int sum=0;\\n\\n           // cnt non overlapping subarray with sum equal to target \\n           int cnt=0;\\n\\n           // fixed sum will help in subtracting sum of already subarray found to avoid recalculation of prefixSum.\\n           int fixedSum=0;\\n           // when single element  equal to target\\n           trackSum[0]=1;\\n\\n           for(int i=0;i<n;i++)\\n           {\\n                sum+=nums[i];\\n                // if we already found prefixsum of sum-target then we can clear our trackSum and start again \\n                if(trackSum.find(-target+sum)!=trackSum.end())\\n                {\\n                    trackSum.clear();\\n                    trackSum[0]=1;\\n                    fixedSum=sum;\\n                    // subtracting to start prefixSum from current index\\n                    sum-=fixedSum;\\n                    cnt++;\\n                }\\n                trackSum[sum]++;\\n\\n           }\\n           return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140491,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int ans =0, ps =0;\\n        set<int>s;\\n        s.insert( 0);\\n        for(auto x : nums){\\n            ps+=x;\\n\\n            if( s.find( ps -target)!=s.end()){\\n                ans++;\\n                s.clear();\\n            }\\n            s.insert( ps);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int ans =0, ps =0;\\n        set<int>s;\\n        s.insert( 0);\\n        for(auto x : nums){\\n            ps+=x;\\n\\n            if( s.find( ps -target)!=s.end()){\\n                ans++;\\n                s.clear();\\n            }\\n            s.insert( ps);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137884,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought was to use a sliding window approach, where the window\\'s size is denoted by the target.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI decided to use a variation of the sliding window approach, where instead of keeping track of the sum of the elements in the window, we keep track of the current running sum and subtract the target from it to find out if it exists in the past. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        seen = {0: -1}\\n        cur_sum = 0\\n        res = 0\\n        last = -1\\n        for i, num in enumerate(nums):\\n            cur_sum += num\\n            if cur_sum - target in seen and seen[cur_sum - target] >= last:\\n                last = i\\n                res += 1\\n            seen[cur_sum] = i\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        seen = {0: -1}\\n        cur_sum = 0\\n        res = 0\\n        last = -1\\n        for i, num in enumerate(nums):\\n            cur_sum += num\\n            if cur_sum - target in seen and seen[cur_sum - target] >= last:\\n                last = i\\n                res += 1\\n            seen[cur_sum] = i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132765,
                "title": "greedy-running-sum-with-memory",
                "content": "**time: `O(N)`; space: `O(N)`**\\n```\\nint maxNonOverlapping(vector<int>& nn, int t)\\n{\\n\\tint out{};\\n\\tunordered_set<int> us{{}};\\n\\tfor(int s{}; const auto & n : nn)\\n\\t{\\n\\t\\ts+=n;\\n\\t\\tif(us.count(s-t)) us.clear(), ++out;\\n\\t\\tus.insert(s);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxNonOverlapping(vector<int>& nn, int t)\\n{\\n\\tint out{};\\n\\tunordered_set<int> us{{}};\\n\\tfor(int s{}; const auto & n : nn)\\n\\t{\\n\\t\\ts+=n;\\n\\t\\tif(us.count(s-t)) us.clear(), ++out;\\n\\t\\tus.insert(s);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3111139,
                "title": "explained-and-commented-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    static bool comp (pair<int, int> &a, pair<int, int> &b) {\\n        return a.second < b.second;\\n    }\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        map<int, int> f;\\n        int ctr = 0;\\n        f[0] = ctr;\\n        vector<pair<int, int>> ps;\\n        int pre = 0;\\n        for(int i=0; i<nums.size(); i++) {\\n            ctr++;\\n            pre += nums[i];\\n            // if prefix-target exists, make a new interval\\n            if (f.find(pre-target) != f.end()) {\\n                ps.push_back({f[pre-target], i});\\n            }\\n            // update pointer for the current prefix sum\\n            f[pre] = ctr;\\n        }\\n        int ans = 0;\\n        if (ps.size()) {\\n            // if there are valid intervals, always take the first one\\n            ans = 1;\\n            int r1 = ps[0].second;\\n            for(int i=1; i<ps.size(); i++) {\\n                int l = ps[i].first;\\n                int r2 = ps[i].second;\\n                if (l > r1) {\\n                    ans++;\\n                    r1 = r2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp (pair<int, int> &a, pair<int, int> &b) {\\n        return a.second < b.second;\\n    }\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        map<int, int> f;\\n        int ctr = 0;\\n        f[0] = ctr;\\n        vector<pair<int, int>> ps;\\n        int pre = 0;\\n        for(int i=0; i<nums.size(); i++) {\\n            ctr++;\\n            pre += nums[i];\\n            // if prefix-target exists, make a new interval\\n            if (f.find(pre-target) != f.end()) {\\n                ps.push_back({f[pre-target], i});\\n            }\\n            // update pointer for the current prefix sum\\n            f[pre] = ctr;\\n        }\\n        int ans = 0;\\n        if (ps.size()) {\\n            // if there are valid intervals, always take the first one\\n            ans = 1;\\n            int r1 = ps[0].second;\\n            for(int i=1; i<ps.size(); i++) {\\n                int l = ps[i].first;\\n                int r2 = ps[i].second;\\n                if (l > r1) {\\n                    ans++;\\n                    r1 = r2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086788,
                "title": "c-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxNonOverlapping(int[] nums, int target) {\\n        HashSet<int> numSet = new(){0};\\n        int result =0, sum=0;\\n\\n        foreach(int num in nums)\\n        {\\n            sum+= num;\\n            if(numSet.Contains(sum- target))\\n            {\\n                result++;\\n                numSet.Clear();\\n                sum=0;\\n            }\\n            numSet.Add(sum);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxNonOverlapping(int[] nums, int target) {\\n        HashSet<int> numSet = new(){0};\\n        int result =0, sum=0;\\n\\n        foreach(int num in nums)\\n        {\\n            sum+= num;\\n            if(numSet.Contains(sum- target))\\n            {\\n                result++;\\n                numSet.Clear();\\n                sum=0;\\n            }\\n            numSet.Add(sum);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085433,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int, int> mp;\\n        mp[0] = -1; // sum -> index\\n\\n        int sum = 0, prev = -1, n = nums.size(), count = 0;\\n        for(int i = 0; i < n; i++) {\\n            sum += nums[i];\\n\\n            if(mp.count(sum - target) and mp[sum - target] >= prev) {\\n                prev = i;\\n                count++;\\n            }\\n\\n            mp[sum] = i;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int, int> mp;\\n        mp[0] = -1; // sum -> index\\n\\n        int sum = 0, prev = -1, n = nums.size(), count = 0;\\n        for(int i = 0; i < n; i++) {\\n            sum += nums[i];\\n\\n            if(mp.count(sum - target) and mp[sum - target] >= prev) {\\n                prev = i;\\n                count++;\\n            }\\n\\n            mp[sum] = i;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041928,
                "title": "c-solution-using-prefix-sum-map",
                "content": "# Intuition\\nTry to pick as many subarrays as possible right from the start thats the only way to maximize the count of the sub-arrays picked, that are non-overlapping.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRemember how to get sum of a sub-array via prfix sum difference.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n\\n        int n = nums.size();\\n        vector<int> prfx(n+1, 0);\\n\\n        for(int i=0;i<n;i++){\\n            prfx[i+1] = prfx[i] + nums[i];\\n        }\\n        int res = 0;\\n        map<int,bool> mp;mp[0] = true;\\n        for(int i = 1;i<=n;i++){\\n            int now = prfx[i];\\n            int req = prfx[i] - target;\\n\\n            if(mp.find(req)!=mp.end()){\\n                res ++;\\n                mp.clear();\\n                mp[now] = true;\\n                continue;\\n            }\\n            mp[now] = true;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n\\n        int n = nums.size();\\n        vector<int> prfx(n+1, 0);\\n\\n        for(int i=0;i<n;i++){\\n            prfx[i+1] = prfx[i] + nums[i];\\n        }\\n        int res = 0;\\n        map<int,bool> mp;mp[0] = true;\\n        for(int i = 1;i<=n;i++){\\n            int now = prfx[i];\\n            int req = prfx[i] - target;\\n\\n            if(mp.find(req)!=mp.end()){\\n                res ++;\\n                mp.clear();\\n                mp[now] = true;\\n                continue;\\n            }\\n            mp[now] = true;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012616,
                "title": "c",
                "content": "```\\nint maxNonOverlapping(int* nums, int numsSize, int target){\\n    int n = numsSize;\\n    int N = n * 5;\\n    int** hash = calloc(N , sizeof(int*));\\n    hash[0] = malloc(2 * sizeof(int));\\n    hash[0][0] = 0;\\n    hash[0][1] = -1;\\n    int* dp = malloc((n+1) * sizeof(int)) ;\\n    dp[0] = 0;\\n    int sum = 0;\\n    for(int i = 0; i < n; i++){\\n        sum += nums[i];\\n        dp[i+1] = dp[i];\\n        int remain = sum - target;\\n        int d = abs(remain);\\n        int t = INT_MIN;\\n        while(1){\\n            if(hash[d % N] == NULL){\\n                break;\\n            }\\n            else if(hash[d % N][0] == remain){\\n                t = hash[d % N][1];\\n                break;\\n            }\\n            else\\n                d++;\\n        }\\n        if(t != INT_MIN)\\n            dp[i+1] = fmax(dp[i], 1 + dp[t+1]);\\n         d =  abs(sum);\\n        while(1){\\n            if(hash[d % N] == NULL){\\n                hash[d % N] = malloc(2 * sizeof(int));\\n                hash[d % N][0] = sum;\\n                hash[d % N][1] = i;\\n                break;\\n            }\\n            else if(hash[d % N][0] == sum){\\n                hash[d % N][1] = i;\\n                break;\\n            }\\n            else\\n                d++;\\n        }\\n    }\\n    int ans = dp[n];\\n    for(int i = 0; i < N; i++){\\n        if(hash[i])\\n            free(hash[i]);\\n    }\\n    free(hash);\\n    free(dp);\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxNonOverlapping(int* nums, int numsSize, int target){\\n    int n = numsSize;\\n    int N = n * 5;\\n    int** hash = calloc(N , sizeof(int*));\\n    hash[0] = malloc(2 * sizeof(int));\\n    hash[0][0] = 0;\\n    hash[0][1] = -1;\\n    int* dp = malloc((n+1) * sizeof(int)) ;\\n    dp[0] = 0;\\n    int sum = 0;\\n    for(int i = 0; i < n; i++){\\n        sum += nums[i];\\n        dp[i+1] = dp[i];\\n        int remain = sum - target;\\n        int d = abs(remain);\\n        int t = INT_MIN;\\n        while(1){\\n            if(hash[d % N] == NULL){\\n                break;\\n            }\\n            else if(hash[d % N][0] == remain){\\n                t = hash[d % N][1];\\n                break;\\n            }\\n            else\\n                d++;\\n        }\\n        if(t != INT_MIN)\\n            dp[i+1] = fmax(dp[i], 1 + dp[t+1]);\\n         d =  abs(sum);\\n        while(1){\\n            if(hash[d % N] == NULL){\\n                hash[d % N] = malloc(2 * sizeof(int));\\n                hash[d % N][0] = sum;\\n                hash[d % N][1] = i;\\n                break;\\n            }\\n            else if(hash[d % N][0] == sum){\\n                hash[d % N][1] = i;\\n                break;\\n            }\\n            else\\n                d++;\\n        }\\n    }\\n    int ans = dp[n];\\n    for(int i = 0; i < N; i++){\\n        if(hash[i])\\n            free(hash[i]);\\n    }\\n    free(hash);\\n    free(dp);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2953201,
                "title": "easy-c-solution-prefix-sum",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        // 1 1 1 1 1\\n        // 1 2 3 4 5\\n        // 0 1 2 3 4  5   6\\n        //-1 3 5 1 4  2  -9\\n        //-1 2 7 8 12 14  5\\n        //s_idx=2   e_idx=3\\n        //s_idx=4   e_idx=5\\n        //s_idx=1   e_idx=6\\n        unordered_map<int,int>mp;\\n        set<pair<int,int>>st;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            nums[i]+=nums[i-1];\\n        } \\n        mp[0]=-1;\\n        int e_idx=-1;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp.find(nums[i]-target)!=mp.end())\\n            {\\n                if(e_idx==-1)\\n                {\\n                    e_idx=i;\\n                    ans++;\\n                }\\n                else\\n                {\\n                   int j=mp[nums[i]-target]+1;\\n                   if(j>e_idx)\\n                   {\\n                       ans++;\\n                       e_idx=i;\\n                   }\\n                }\\n            }\\n            mp[nums[i]]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        // 1 1 1 1 1\\n        // 1 2 3 4 5\\n        // 0 1 2 3 4  5   6\\n        //-1 3 5 1 4  2  -9\\n        //-1 2 7 8 12 14  5\\n        //s_idx=2   e_idx=3\\n        //s_idx=4   e_idx=5\\n        //s_idx=1   e_idx=6\\n        unordered_map<int,int>mp;\\n        set<pair<int,int>>st;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            nums[i]+=nums[i-1];\\n        } \\n        mp[0]=-1;\\n        int e_idx=-1;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp.find(nums[i]-target)!=mp.end())\\n            {\\n                if(e_idx==-1)\\n                {\\n                    e_idx=i;\\n                    ans++;\\n                }\\n                else\\n                {\\n                   int j=mp[nums[i]-target]+1;\\n                   if(j>e_idx)\\n                   {\\n                       ans++;\\n                       e_idx=i;\\n                   }\\n                }\\n            }\\n            mp[nums[i]]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888644,
                "title": "o-n-beats-93-runtime-76-memory-explanation-in-a-plain-language",
                "content": "# Intuition\\nThe idea is to move through the values of the array, write the cumulative sum obtained by sequentially adding the values at each iteration to the set.\\n\\nThis is necessary in order to know if there was previously a consecutive segment, the removal of which (measured as the difference between the cummulative sum of the entire segment and the target value) will equate the sum of the remaining part of the values to the target.\\n\\n# Approach\\nIterating by `nums` list to check for any of the following condition meet:\\n1. ith value == target\\n2. sum of nums from start to ith == target.\\n3. any of continous chunk start from any index before ith to ith == target.\\nThen add 1 to subarray\\'s counter and reset set and cumsum values once any of listed conditions are detected. Iterating so until the end of `nums` list.\\n\\nreturn counter of unqiue subarrays (`subs_cnt`).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        \\n        subs_cnt = 0\\n        csum = 0\\n        csums_set = set()\\n\\n        for i_val in nums:\\n            csum += i_val\\n            csum_tar_diff = csum - target\\n\\n            if csum_tar_diff != 0:\\n                diff_indices = csum_tar_diff in csums_set\\n                csums_set.add(csum)\\n\\n            if (csum_tar_diff == 0) or ((csum_tar_diff != 0) and (diff_indices != False)):\\n                subs_cnt += 1\\n                csum = 0\\n                csums_set = set()\\n\\n        return subs_cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        \\n        subs_cnt = 0\\n        csum = 0\\n        csums_set = set()\\n\\n        for i_val in nums:\\n            csum += i_val\\n            csum_tar_diff = csum - target\\n\\n            if csum_tar_diff != 0:\\n                diff_indices = csum_tar_diff in csums_set\\n                csums_set.add(csum)\\n\\n            if (csum_tar_diff == 0) or ((csum_tar_diff != 0) and (diff_indices != False)):\\n                subs_cnt += 1\\n                csum = 0\\n                csums_set = set()\\n\\n        return subs_cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859879,
                "title": "python-hashmap-based-o-n-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        sumMap, res, sm = defaultdict(int), 0, 0\\n        sumMap[0] = 0\\n        for idx in range(len(nums)):\\n            sm += nums[idx]\\n            if sm - target in sumMap:\\n                res = max(res, sumMap[sm - target] + 1)\\n            sumMap[sm] = res\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        sumMap, res, sm = defaultdict(int), 0, 0\\n        sumMap[0] = 0\\n        for idx in range(len(nums)):\\n            sm += nums[idx]\\n            if sm - target in sumMap:\\n                res = max(res, sumMap[sm - target] + 1)\\n            sumMap[sm] = res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855571,
                "title": "python-prefix-sum",
                "content": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], k: int) -> int:\\n        cur = 0\\n        visited = set([0])\\n        res = 0\\n        for num in nums:\\n            cur = cur + num\\n            if cur - k in visited:\\n                res += 1\\n                visited = set([0])\\n                cur = 0\\n            else:\\n                visited.add(cur)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], k: int) -> int:\\n        cur = 0\\n        visited = set([0])\\n        res = 0\\n        for num in nums:\\n            cur = cur + num\\n            if cur - k in visited:\\n                res += 1\\n                visited = set([0])\\n                cur = 0\\n            else:\\n                visited.add(cur)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2848713,
                "title": "c-with-readable-variable-names",
                "content": "```\\nint maxNonOverlapping(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        map<int, int> pre;\\n        pre[0] = -1; // base case\\n\\t\\tint lastFoundPrefixTargetAt = -1;\\n        \\n\\t\\tint cumulativeSum = 0;\\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            cumulativeSum += nums[i];\\n            if(pre.count(cumulativeSum - target)) {\\n                int prefixSumStartingIndex = pre[cumulativeSum - target] + 1;\\n                if(lastFoundPrefixTargetAt < prefixSumStartingIndex) {\\n                    count++;\\n                    lastFoundPrefixTargetAt = i;\\n                }\\n            }\\n            pre[cumulativeSum] = i;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxNonOverlapping(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        map<int, int> pre;\\n        pre[0] = -1; // base case\\n\\t\\tint lastFoundPrefixTargetAt = -1;\\n        \\n\\t\\tint cumulativeSum = 0;\\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            cumulativeSum += nums[i];\\n            if(pre.count(cumulativeSum - target)) {\\n                int prefixSumStartingIndex = pre[cumulativeSum - target] + 1;\\n                if(lastFoundPrefixTargetAt < prefixSumStartingIndex) {\\n                    count++;\\n                    lastFoundPrefixTargetAt = i;\\n                }\\n            }\\n            pre[cumulativeSum] = i;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2827669,
                "title": "elixir-solution",
                "content": "Learning a new language...\\n# Code\\n```\\ndefmodule Solution do\\n  @spec max_non_overlapping(nums :: [integer], target :: integer) :: integer\\n  def max_non_overlapping(nums, target) do\\n    Enum.reduce(nums, {0, 0, 0, 0, %{0 => 0}, target}, &do_find/2)\\n    |> elem(0)\\n  end\\n\\n  defp do_find(x, {ans, start, i, sum, hash, target}) do\\n    sum2 = sum + x\\n    hash2 = Map.put(hash, sum2, i + 1)\\n    if Map.get(hash, sum2 - target, -1) >= start do\\n      {ans + 1, i + 1, i + 1, sum2, hash2, target}\\n    else\\n      {ans, start, i + 1, sum2, hash2, target}\\n    end\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir",
                    "Hash Table",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec max_non_overlapping(nums :: [integer], target :: integer) :: integer\\n  def max_non_overlapping(nums, target) do\\n    Enum.reduce(nums, {0, 0, 0, 0, %{0 => 0}, target}, &do_find/2)\\n    |> elem(0)\\n  end\\n\\n  defp do_find(x, {ans, start, i, sum, hash, target}) do\\n    sum2 = sum + x\\n    hash2 = Map.put(hash, sum2, i + 1)\\n    if Map.get(hash, sum2 - target, -1) >= start do\\n      {ans + 1, i + 1, i + 1, sum2, hash2, target}\\n    else\\n      {ans, start, i + 1, sum2, hash2, target}\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2819414,
                "title": "c-o-n-time-and-o-1-space-explanation-in-hindi",
                "content": "\\n    \\n\\n        //yahan \"right\" aur \"left\" kya bata raha hai ye samajhna sbse important hai\\n        \\n        //suppose ek subarray hai jiska (sum = target) hai\\n        // to iss subarray me \"left\" = Starting point of the Subarray\\n        // aur \"right\" = Ending point of the Subarray\\n        \\n        //non overlapping banane ke liye, (sum=target) wala next subarray, ka \"left\" \\n\\t\\t//previous (sum=target) waale subarray ke \"right\" se > hona chahiye, \\n\\t\\t//yahi main idea hai yahan \\n        \\n\\t\\t**Code**\\n\\t\\t\\n        int n=nums.size();\\n        \\n        \\n        map<int,int> mp;\\n        \\n        \\n        int sum=0,right=-1,ans=0;\\n        \\n        mp[0]=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            \\n            if(mp.find(sum-target)!=mp.end()){\\n                int left=mp[sum-target]+1;\\n                if(right<left){\\n                    ans++;\\n                    right=i;\\n                }\\n            }\\n            mp[sum]=i;\\n        }\\n        \\n        return ans;\\n       \\n        \\n    }",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "\\n    \\n\\n        //yahan \"right\" aur \"left\" kya bata raha hai ye samajhna sbse important hai\\n        \\n        //suppose ek subarray hai jiska (sum = target) hai\\n        // to iss subarray me \"left\" = Starting point of the Subarray\\n        // aur \"right\" = Ending point of the Subarray\\n        \\n        //non overlapping banane ke liye, (sum=target) wala next subarray, ka \"left\" \\n\\t\\t//previous (sum=target) waale subarray ke \"right\" se > hona chahiye, \\n\\t\\t//yahi main idea hai yahan \\n        \\n\\t\\t**Code**\\n\\t\\t\\n        int n=nums.size();\\n        \\n        \\n        map<int,int> mp;\\n        \\n        \\n        int sum=0,right=-1,ans=0;\\n        \\n        mp[0]=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            \\n            if(mp.find(sum-target)!=mp.end()){\\n                int left=mp[sum-target]+1;\\n                if(right<left){\\n                    ans++;\\n                    right=i;\\n                }\\n            }\\n            mp[sum]=i;\\n        }\\n        \\n        return ans;\\n       \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2816513,
                "title": "easy-c-o-n-solution-99-96-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int cnt=0;\\n        unordered_set<int> st;\\n        ll sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            ll toFind=sum-target;\\n            //check if there is a subarry of  sum = target\\n            if(st.find(toFind)!=st.end() || sum==target)\\n            {\\n                //got a subarray \\n                sum=0;\\n                cnt++;\\n                st.clear();\\n            }\\n            else{\\n                st.insert(sum);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int cnt=0;\\n        unordered_set<int> st;\\n        ll sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            ll toFind=sum-target;\\n            //check if there is a subarry of  sum = target\\n            if(st.find(toFind)!=st.end() || sum==target)\\n            {\\n                //got a subarray \\n                sum=0;\\n                cnt++;\\n                st.clear();\\n            }\\n            else{\\n                st.insert(sum);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788015,
                "title": "various-prefix-sum-solutions-python",
                "content": "Solution 1:\\n```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        ans = 0\\n        prefixSum = {0}\\n        runningSum = 0\\n        for n in nums:\\n            runningSum += n\\n            if runningSum - target in prefixSum:\\n                ans += 1\\n                prefixSum = set()\\n            prefixSum.add(runningSum)\\n        return ans\\n    # Time: O(N)\\n    # Space: O(N)\\n```\\n\\\\\\nSolution 2:\\n```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        ans = 0\\n        runningSum = 0\\n        prefixSum = {0: 0} # runningSum --> valid subarrays found so far\\n        for n in nums:\\n            runningSum += n\\n            if runningSum - target in prefixSum:\\n                ans = max(ans, prefixSum[runningSum - target] + 1)\\n            prefixSum[runningSum] = ans\\n        return ans\\n    # Time: O(N)\\n    # Space: O(N)\\n```\\n\\\\\\nSolution 3:\\n```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        ans = 0\\n        runningSum = 0\\n        prefixSum = {0: -1}\\n        previousRight = -1\\n        for i, n in enumerate(nums):\\n            runningSum += n\\n            if runningSum - target in prefixSum:\\n                if previousRight <= prefixSum[runningSum - target]:\\n                    ans += 1\\n                    previousRight = i\\n            prefixSum[runningSum] = i\\n        return ans\\n    # Time: O(N)\\n    # Space: O(N)\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        ans = 0\\n        prefixSum = {0}\\n        runningSum = 0\\n        for n in nums:\\n            runningSum += n\\n            if runningSum - target in prefixSum:\\n                ans += 1\\n                prefixSum = set()\\n            prefixSum.add(runningSum)\\n        return ans\\n    # Time: O(N)\\n    # Space: O(N)\\n```\n```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        ans = 0\\n        runningSum = 0\\n        prefixSum = {0: 0} # runningSum --> valid subarrays found so far\\n        for n in nums:\\n            runningSum += n\\n            if runningSum - target in prefixSum:\\n                ans = max(ans, prefixSum[runningSum - target] + 1)\\n            prefixSum[runningSum] = ans\\n        return ans\\n    # Time: O(N)\\n    # Space: O(N)\\n```\n```\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        ans = 0\\n        runningSum = 0\\n        prefixSum = {0: -1}\\n        previousRight = -1\\n        for i, n in enumerate(nums):\\n            runningSum += n\\n            if runningSum - target in prefixSum:\\n                if previousRight <= prefixSum[runningSum - target]:\\n                    ans += 1\\n                    previousRight = i\\n            prefixSum[runningSum] = i\\n        return ans\\n    # Time: O(N)\\n    # Space: O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743629,
                "title": "java-hashset-easy-to-understand",
                "content": "\\tpublic int maxNonOverlapping(int[] nums, int target) {\\n        \\n        HashSet<Integer> hashSet = new HashSet<>();\\n        hashSet.add(0);\\n        int count = 0;\\n        int sum = 0;\\n        for(int i = 0;i<nums.length;i++){\\n            sum+=nums[i];\\n            if(hashSet.contains(sum-target)){\\n                count++;\\n                hashSet = new HashSet<>();\\n                \\n            }\\n            hashSet.add(sum);\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int maxNonOverlapping(int[] nums, int target) {\\n        \\n        HashSet<Integer> hashSet = new HashSet<>();\\n        hashSet.add(0);\\n        int count = 0;\\n        int sum = 0;\\n        for(int i = 0;i<nums.length;i++){\\n            sum+=nums[i];\\n            if(hashSet.contains(sum-target)){\\n                count++;\\n                hashSet = new HashSet<>();\\n                \\n            }\\n            hashSet.add(sum);\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2742232,
                "title": "rust-solution-using-prefix-sum-and-greeedy",
                "content": "```\\nuse std::collections::*;\\n\\nimpl Solution {\\n    pub fn max_non_overlapping(nums: Vec<i32>, target: i32) -> i32 {\\n        let n = nums.len();\\n        let mut memo = vec![0;n+1];\\n        for i in 0..n {\\n            memo[i+1] = memo[i] + nums[i];\\n        }\\n\\n        let mut count = 0;\\n        let mut set = HashSet::new();\\n        for i in (0..=n).rev() {\\n            let v = memo[i];\\n            let need = v + target;\\n            if set.contains(&need) {\\n                count += 1;\\n                set = HashSet::new();\\n            }\\n            set.insert(v);\\n        }\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nimpl Solution {\\n    pub fn max_non_overlapping(nums: Vec<i32>, target: i32) -> i32 {\\n        let n = nums.len();\\n        let mut memo = vec![0;n+1];\\n        for i in 0..n {\\n            memo[i+1] = memo[i] + nums[i];\\n        }\\n\\n        let mut count = 0;\\n        let mut set = HashSet::new();\\n        for i in (0..=n).rev() {\\n            let v = memo[i];\\n            let need = v + target;\\n            if set.contains(&need) {\\n                count += 1;\\n                set = HashSet::new();\\n            }\\n            set.insert(v);\\n        }\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2740684,
                "title": "simple-c-solution-using-cumulative-sum-and-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        \\n        int csum = 0;\\n        \\n        unordered_map<int,int> mp;\\n        mp[0] = -1;\\n        \\n        int end = -1;\\n        int ct = 0;\\n        \\n        for(int i=0 ; i<n ; i++){\\n            csum += arr[i];\\n            if(mp.find(csum-k)!=mp.end() and mp[csum-k]>=end){\\n                ct++;\\n                end = i;\\n            }\\n            mp[csum] = i;\\n        }\\n        \\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        \\n        int csum = 0;\\n        \\n        unordered_map<int,int> mp;\\n        mp[0] = -1;\\n        \\n        int end = -1;\\n        int ct = 0;\\n        \\n        for(int i=0 ; i<n ; i++){\\n            csum += arr[i];\\n            if(mp.find(csum-k)!=mp.end() and mp[csum-k]>=end){\\n                ct++;\\n                end = i;\\n            }\\n            mp[csum] = i;\\n        }\\n        \\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711891,
                "title": "c-prefix-sum-set-and-unique-subarrays",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        long long prefsum=0;\\n        int count=0;\\n        unordered_set<int>s;\\n        s.insert(0);\\n        for(auto &it:nums)\\n        {\\n            prefsum+=it;\\n            if(s.find(prefsum-target)!=s.end()){\\n                s.clear();\\n                prefsum=0;\\n                count++;\\n            }\\n            \\n            s.insert(prefsum);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        long long prefsum=0;\\n        int count=0;\\n        unordered_set<int>s;\\n        s.insert(0);\\n        for(auto &it:nums)\\n        {\\n            prefsum+=it;\\n            if(s.find(prefsum-target)!=s.end()){\\n                s.clear();\\n                prefsum=0;\\n                count++;\\n            }\\n            \\n            s.insert(prefsum);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698161,
                "title": "cpp-easy-solution",
                "content": "\\tint maxNonOverlapping(vector<int>& arr, int target) {\\n        unordered_set<int>st;\\n        st.insert(0);\\n        int n = arr.size(),j=0,sum=0,ans=0;\\n        while(j<n){\\n            sum+=arr[j];\\n            if(st.find(sum - target)!=st.end()){\\n                ans++;\\n                \\n                \\n                st.clear();\\n            }\\n            st.insert(sum);\\n            j++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\tint maxNonOverlapping(vector<int>& arr, int target) {\\n        unordered_set<int>st;\\n        st.insert(0);\\n        int n = arr.size(),j=0,sum=0,ans=0;\\n        while(j<n){\\n            sum+=arr[j];\\n            if(st.find(sum - target)!=st.end()){\\n                ans++;\\n                \\n                \\n                st.clear();\\n            }\\n            st.insert(sum);\\n            j++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2684202,
                "title": "c-short-concise-using-hashmap-prefix-sum-easy-to-understand",
                "content": "```\\nint maxNonOverlapping(vector<int>& nums, int target) {\\n        \\n        unordered_map< int , int >  mp;\\n        \\n        int sum=0;\\n        \\n        int idx=-1;\\n        \\n        int count=0;\\n        \\n        mp[0]=-1;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            \\n            if(mp.find(sum-target)!=mp.end())\\n            {\\n                if(idx<=mp[sum-target])\\n                {\\n                    idx=i;\\n                    count++;\\n                }\\n                \\n            }\\n            \\n            mp[sum]=i;\\n        }\\n        \\n        return count;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nint maxNonOverlapping(vector<int>& nums, int target) {\\n        \\n        unordered_map< int , int >  mp;\\n        \\n        int sum=0;\\n        \\n        int idx=-1;\\n        \\n        int count=0;\\n        \\n        mp[0]=-1;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            \\n            if(mp.find(sum-target)!=mp.end())\\n            {\\n                if(idx<=mp[sum-target])\\n                {\\n                    idx=i;\\n                    count++;\\n                }\\n                \\n            }\\n            \\n            mp[sum]=i;\\n        }\\n        \\n        return count;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2666965,
                "title": "tle-solution-nested-loops-and-sort-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nIntuitive sort solution, but TLE\\n\\n# Code\\n```\\nclass Solution {\\n    public int res = 0;\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        List<int[]> lis = new LinkedList<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            int curr = nums[i]; // \\n            if(curr == target) {\\n                lis.add(new int[]{i, i});\\n                continue;\\n            }\\n            for(int j = i + 1; j < nums.length; j++) {\\n                curr += nums[j];\\n                if(curr == target) {\\n                    lis.add(new int[]{i, j});\\n                    continue;\\n                }\\n            }\\n        }\\n        if(lis.size() == 0) return 0;\\n        \\n        Collections.sort(lis, (a, b) -> {return a[1] - b[1];});\\n        int[] curr = lis.get(0);\\n        res++;\\n        int end = curr[1];\\n        for(int i = 1; i < lis.size(); i++) {\\n            int[] tmp = lis.get(i);\\n            if(tmp[0] > end) {\\n                res++;\\n                end = tmp[1];\\n            }\\n            \\n        }\\n\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int res = 0;\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        List<int[]> lis = new LinkedList<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            int curr = nums[i]; // \\n            if(curr == target) {\\n                lis.add(new int[]{i, i});\\n                continue;\\n            }\\n            for(int j = i + 1; j < nums.length; j++) {\\n                curr += nums[j];\\n                if(curr == target) {\\n                    lis.add(new int[]{i, j});\\n                    continue;\\n                }\\n            }\\n        }\\n        if(lis.size() == 0) return 0;\\n        \\n        Collections.sort(lis, (a, b) -> {return a[1] - b[1];});\\n        int[] curr = lis.get(0);\\n        res++;\\n        int end = curr[1];\\n        for(int i = 1; i < lis.size(); i++) {\\n            int[] tmp = lis.get(i);\\n            if(tmp[0] > end) {\\n                res++;\\n                end = tmp[1];\\n            }\\n            \\n        }\\n\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648588,
                "title": "set-o-n-solution",
                "content": "Pretty similar to subarray sum  equals k. The tricky part of this is making you add to your set during hte correct time.\\n\\n\"\"\"\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n      seen = set()\\n      total = 0\\n      output = 0 \\n      \\n      for i, num in enumerate(nums):\\n        seen.add(total)\\n        total += num\\n\\n        if total - target in seen:\\n          output+=1\\n          #now we need to reset\\n          total = 0 \\n          seen = set()\\n        \\n      return output\\n\"\"\"",
                "solutionTags": [],
                "code": "Pretty similar to subarray sum  equals k. The tricky part of this is making you add to your set during hte correct time.\\n\\n\"\"\"\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n      seen = set()\\n      total = 0\\n      output = 0 \\n      \\n      for i, num in enumerate(nums):\\n        seen.add(total)\\n        total += num\\n\\n        if total - target in seen:\\n          output+=1\\n          #now we need to reset\\n          total = 0 \\n          seen = set()\\n        \\n      return output\\n\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 2627696,
                "title": "c-o-n-simple-easy-understanding",
                "content": "class Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& A, int k) {\\n            \\n            unordered_map<int, int> mp;\\n            \\n            int n = A.size();\\n            \\n            vector<int> pre(n);\\n            \\n            pre[0] = A[0];\\n            \\n            for(int i =1; i<n; i++){\\n                    \\n                    pre[i] = pre[i-1]+A[i];\\n            }\\n            \\n            int  lastind = -1 ,cnt = 0;\\n            \\n            mp[0] = -1;\\n            \\n             for(int i =0; i<n; i++){\\n                    \\n                    if(A[i]==k){\\n                            \\n                          \\n                             cnt++;\\n                           \\n                             lastind = i;\\n                            \\n                    } else if(mp.find(pre[i]-k)!=mp.end()){\\n                            \\n                            int ind = mp[pre[i]-k]+1;\\n                            \\n                            if(ind>lastind){\\n                                    cnt++;\\n                                  \\n                                    lastind = i;\\n                            }\\n                    }\\n                    \\n                   mp[pre[i]] = i;\\n            }\\n            \\n            return cnt;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& A, int k) {\\n            \\n            unordered_map<int, int> mp;\\n            \\n            int n = A.size();\\n            \\n            vector<int> pre(n);\\n            \\n            pre[0] = A[0];\\n            \\n            for(int i =1; i<n; i++){\\n                    \\n                    pre[i] = pre[i-1]+A[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2599243,
                "title": "java-hashset-solution-easy-to-understand",
                "content": "class Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        Set<Integer> set = new HashSet<>();\\n        set.add(0);\\n        int count = 0;\\n        int sum = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if(set.contains(sum - target)) {\\n                count++;\\n                set = new HashSet<>(); \\n            } \\n            set.add(sum);\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        Set<Integer> set = new HashSet<>();\\n        set.add(0);\\n        int count = 0;\\n        int sum = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if(set.contains(sum - target)) {\\n                count++;\\n                set = new HashSet<>(); \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2598300,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int, int> m;\\n        m[0]++;\\n        int s = 0, ans = 0;\\n        for(int i : nums) {\\n            s += i;\\n            if(m.find(s - target) != m.end()) ans++, m.clear();\\n            m[s]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int, int> m;\\n        m[0]++;\\n        int s = 0, ans = 0;\\n        for(int i : nums) {\\n            s += i;\\n            if(m.find(s - target) != m.end()) ans++, m.clear();\\n            m[s]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586673,
                "title": "explanation-concise-java-solution-hashset",
                "content": "Ideas:\\n1. Calculate preSum from 0 to i \\n\\te.g.  nums = [1,2,3],  target = 3\\n\\t```\\n\\t\\tpreSum array = [0, 1, 1+2, 1+2+3]\\n\\t\\tpreSum array = [0, 1, 3, 6]\\n\\t```\\n\\tRemenber to add the initial 0 to deal with situations where target subarray starts from first value in nums\\n2. target = preSum[end] - preSum[start]  -> target can be found in subarray nums[end - 1] to nums[start] \\n3. We can check for a given preSum[end], whether the previous preSum array exist (target - preSum[end]). \\n\\tIf yes, we found a subarray.\\n4. To avoid overlapping subarray:\\n\\tOnce we found a subarray, we need to start looking from current index.\\n\\nOptimize:\\nHere, index doesn\\'t really matters. We can use a hashSet as the previous mentioned preSum array. We only need to make sure that once we found a subarray, we reset the hashSet to avoid overlaping arrays.\\n```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        HashSet<Integer> preSum = new HashSet<>();\\n        preSum.add(0);\\n        int sum = 0;\\n        int count = 0;\\n        \\n        for(int n: nums){\\n            sum += n;\\n            if(preSum.contains(sum - target)){\\n                count ++;\\n                preSum = new HashSet<>();\\n            }\\n            preSum.add(sum);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\n\\t\\tpreSum array = [0, 1, 1+2, 1+2+3]\\n\\t\\tpreSum array = [0, 1, 3, 6]\\n\\t```\n```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        HashSet<Integer> preSum = new HashSet<>();\\n        preSum.add(0);\\n        int sum = 0;\\n        int count = 0;\\n        \\n        for(int n: nums){\\n            sum += n;\\n            if(preSum.contains(sum - target)){\\n                count ++;\\n                preSum = new HashSet<>();\\n            }\\n            preSum.add(sum);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577698,
                "title": "java-simple-map-with-prefix-sum-explained-ind-detail-o-n",
                "content": "// TC : O(N); N = nums.length\\n// SC : O(N)\\n```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int res = 0;\\n        int prefixSum = 0;\\n        int nextAvailableIdx = -1; // to make the subarray starting at this index\\n        \\n        Map<Integer, Integer> prefixSumMap = new HashMap<>(); // key -> prefixSum, value -> index upto which this prefix sum happen\\n        prefixSumMap.put(0, nextAvailableIdx);\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            prefixSum += nums[i];\\n            int remaining = prefixSum - target;\\n            // if prefixSum = 8, target = 6 and remaining = 2, and we habe (2, 1) entry in a amp\\n            // This means a prefixSum = 2 was observed UPTIL index 1, and nextAvailableIdx = -1\\n            // prefixSumMap.get(remaining) >= nextAvailableIdx tells that if this is not true, this means we have made a subarray which surpasses the prefixSumMap.get(remaining) which menas the present subarray is an overlap and we should not take it as answer\\n            if(prefixSumMap.containsKey(remaining) && prefixSumMap.get(remaining) >= nextAvailableIdx) {\\n                res++;\\n                nextAvailableIdx = i; // if the current subarray is good, update the nextAvailableIdx to current index and we can look for the next subarray ONLY from or beyond this point\\n            }\\n            prefixSumMap.put(prefixSum, i); // always add the prefix sum and index to map\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int res = 0;\\n        int prefixSum = 0;\\n        int nextAvailableIdx = -1; // to make the subarray starting at this index\\n        \\n        Map<Integer, Integer> prefixSumMap = new HashMap<>(); // key -> prefixSum, value -> index upto which this prefix sum happen\\n        prefixSumMap.put(0, nextAvailableIdx);\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            prefixSum += nums[i];\\n            int remaining = prefixSum - target;\\n            // if prefixSum = 8, target = 6 and remaining = 2, and we habe (2, 1) entry in a amp\\n            // This means a prefixSum = 2 was observed UPTIL index 1, and nextAvailableIdx = -1\\n            // prefixSumMap.get(remaining) >= nextAvailableIdx tells that if this is not true, this means we have made a subarray which surpasses the prefixSumMap.get(remaining) which menas the present subarray is an overlap and we should not take it as answer\\n            if(prefixSumMap.containsKey(remaining) && prefixSumMap.get(remaining) >= nextAvailableIdx) {\\n                res++;\\n                nextAvailableIdx = i; // if the current subarray is good, update the nextAvailableIdx to current index and we can look for the next subarray ONLY from or beyond this point\\n            }\\n            prefixSumMap.put(prefixSum, i); // always add the prefix sum and index to map\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564097,
                "title": "c-prefixsum-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int,int> mp;\\n        int right = -1;\\n        int count = 0;\\n        int sum = 0;\\n        mp[0] = -1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+= nums[i];\\n            int left = sum - target;\\n            if(mp.find(left) != mp.end()){\\n                int l = mp[left];\\n                if(l >= right)\\n                {   \\n                    count++;\\n                    right = i;\\n                }\\n            }\\n            mp[sum] = i;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int,int> mp;\\n        int right = -1;\\n        int count = 0;\\n        int sum = 0;\\n        mp[0] = -1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+= nums[i];\\n            int left = sum - target;\\n            if(mp.find(left) != mp.end()){\\n                int l = mp[left];\\n                if(l >= right)\\n                {   \\n                    count++;\\n                    right = i;\\n                }\\n            }\\n            mp[sum] = i;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553855,
                "title": "c-simple-hashmap-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        mp[0] = -1;\\n        int currsum = 0;\\n        int startidx = -1;\\n        \\n        for(int i =0;i<n;i++){\\n            currsum += nums[i];\\n            if(mp.find(currsum-target)!=mp.end()){\\n                if(mp[currsum-target]>=startidx){\\n                    ans++;\\n                    startidx = i;\\n                }\\n            }\\n            mp[currsum] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        mp[0] = -1;\\n        int currsum = 0;\\n        int startidx = -1;\\n        \\n        for(int i =0;i<n;i++){\\n            currsum += nums[i];\\n            if(mp.find(currsum-target)!=mp.end()){\\n                if(mp[currsum-target]>=startidx){\\n                    ans++;\\n                    startidx = i;\\n                }\\n            }\\n            mp[currsum] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548793,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) \\n    {\\n        unordered_map<int,int> mp;\\n        \\n        int sum = 0, ans = 0;\\n        \\n        for(auto &x: nums)\\n        {\\n            sum += x;\\n           \\n            \\n            if(sum == target)\\n            {\\n                ans++;\\n                sum = 0;\\n                mp.clear();\\n            }\\n             \\n           else if(mp.count(sum-target))\\n            {\\n                ans++;\\n                sum = 0;\\n                mp.clear();\\n            }\\n            \\n            mp[sum]++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) \\n    {\\n        unordered_map<int,int> mp;\\n        \\n        int sum = 0, ans = 0;\\n        \\n        for(auto &x: nums)\\n        {\\n            sum += x;\\n           \\n            \\n            if(sum == target)\\n            {\\n                ans++;\\n                sum = 0;\\n                mp.clear();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2538850,
                "title": "c-hashmap-with-prefix-sum-beats-99-58-in-time",
                "content": "The core idea is: **by storing all prefix sum inside hashmap, we can find whether there exists a subarray till now that sums to target**. \\n\\nFor example, prefix sum for `[2,3,1]` is `[2,5,6]`, and suppose the target is `4` and we are at the third position. Then. **we only need to find whether the hashmap contains `2 = (6 - 4)`**. If so, starting from index `1` till `2`, `[3,1]` is a valid subarray.\\n\\nThus, we can do this greedily starting from beginning to end of the array. Once we find a valid subarray, plus one to the final result, and clear all previous records - since no overlapping is allowed. We continue such process on the following array till the end of the array.\\n\\nEventually, we\\'ll get the final result.\\n\\n**Beats 99.58% int time and 80.08% in space**\\n![image](https://assets.leetcode.com/users/images/b115b316-31ad-41f6-b625-318caa60537b_1662450520.7427568.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int, int> m; // map that stores prefix sums\\n        m[0] = -1;  // 0 for full-length subarray\\n        int currSum = 0, res = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            currSum += nums[i];\\n            if (m.find(currSum - target) != m.end()) { // check if there exists a valid subarray\\n                res++;\\n                m.clear(); // discard all previous info\\n                m[0] = i; // 0 for full-length subarray\\n                currSum = 0; // reset currSum\\n            } else { // if not, keep recording infos\\n                m[currSum] = i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        unordered_map<int, int> m; // map that stores prefix sums\\n        m[0] = -1;  // 0 for full-length subarray\\n        int currSum = 0, res = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            currSum += nums[i];\\n            if (m.find(currSum - target) != m.end()) { // check if there exists a valid subarray\\n                res++;\\n                m.clear(); // discard all previous info\\n                m[0] = i; // 0 for full-length subarray\\n                currSum = 0; // reset currSum\\n            } else { // if not, keep recording infos\\n                m[currSum] = i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505367,
                "title": "simple-c-solution-using-hashmap-and-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int sum=0,ans=0,x=-1;\\n        map<int,int> m;\\n        m[0]=-1;\\n        for (int i=0;i<nums.size();i++) {\\n            sum+=nums[i];\\n            if (m.find(sum-target)!=m.end()) {\\n                if (m[sum-target]>=x) {\\n                    ans++;\\n                    x=i;\\n                }\\n            }\\n            m[sum]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int sum=0,ans=0,x=-1;\\n        map<int,int> m;\\n        m[0]=-1;\\n        for (int i=0;i<nums.size();i++) {\\n            sum+=nums[i];\\n            if (m.find(sum-target)!=m.end()) {\\n                if (m[sum-target]>=x) {\\n                    ans++;\\n                    x=i;\\n                }\\n            }\\n            m[sum]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504754,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int idx=-1,ans=0,sum=0;\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        map.put(0,-1);\\n        for(int j=0;j<nums.length;j++){\\n            sum+=nums[j];\\n            if(map.containsKey(sum-target) && map.get(sum-target)>=idx){\\n                ans++;\\n                idx=j;\\n            }\\n            map.put(sum,j);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxNonOverlapping(int[] nums, int target) {\\n        int idx=-1,ans=0,sum=0;\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        map.put(0,-1);\\n        for(int j=0;j<nums.length;j++){\\n            sum+=nums[j];\\n            if(map.containsKey(sum-target) && map.get(sum-target)>=idx){\\n                ans++;\\n                idx=j;\\n            }\\n            map.put(sum,j);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327012,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand-prefix-sum-dictionary",
                "content": "```C#\\npublic class Solution {\\n    public int MaxOperations(int[] nums, int k) {\\n        Dictionary<int, int> d = new();\\n        \\n        int count = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n            if (d.TryGetValue(k - nums[i], out int frequency) && frequency > 0) {\\n                d[k - nums[i]]--;\\n                count++;\\n            } else {\\n                if (!d.ContainsKey(nums[i])) d[nums[i]] = 0;\\n                d[nums[i]]++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int MaxOperations(int[] nums, int k) {\\n        Dictionary<int, int> d = new();\\n        \\n        int count = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n            if (d.TryGetValue(k - nums[i], out int frequency) && frequency > 0) {\\n                d[k - nums[i]]--;\\n                count++;\\n            } else {\\n                if (!d.ContainsKey(nums[i])) d[nums[i]] = 0;\\n                d[nums[i]]++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326975,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand-prefix-sum-greedy",
                "content": "```C#\\npublic class Solution {\\n    public int MaxNonOverlapping(int[] nums, int target) {\\n        Dictionary<int, int> dp = new ();\\n        dp[0] = -1;\\n        \\n        int sum = 0, lastIndex = -1, count = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n            sum += nums[i];\\n            if (dp.TryGetValue(sum - target, out int index) && index >= lastIndex) {\\n                lastIndex = i;\\n                count++;\\n            }\\n            \\n            dp[sum] = i;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int MaxNonOverlapping(int[] nums, int target) {\\n        Dictionary<int, int> dp = new ();\\n        dp[0] = -1;\\n        \\n        int sum = 0, lastIndex = -1, count = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n            sum += nums[i];\\n            if (dp.TryGetValue(sum - target, out int index) && index >= lastIndex) {\\n                lastIndex = i;\\n                count++;\\n            }\\n            \\n            dp[sum] = i;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322693,
                "title": "python-3-prefix-sum-set",
                "content": "This Problem can be asked as follow up of this Problem-https://leetcode.com/problems/subarray-sum-equals-k/\\n\\nMY solution-https://leetcode.com/problems/subarray-sum-equals-k/discuss/2322633/Python-3-prefix_sum-oror-Map\\n\\t\\n\\tclass Solution:\\n\\t\\tdef maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n\\t\\t\\ta=set()\\n\\t\\t\\tcount=s=0\\n\\t\\t\\tfor x in nums:\\n\\t\\t\\t\\ta.add(s)\\n\\t\\t\\t\\ts+=x\\n\\t\\t\\t\\tif s-target in a:\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\t\\ts=0\\n\\t\\t\\t\\t\\ta=set()\\n\\t\\t\\treturn count",
                "solutionTags": [],
                "code": "This Problem can be asked as follow up of this Problem-https://leetcode.com/problems/subarray-sum-equals-k/\\n\\nMY solution-https://leetcode.com/problems/subarray-sum-equals-k/discuss/2322633/Python-3-prefix_sum-oror-Map\\n\\t\\n\\tclass Solution:\\n\\t\\tdef maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n\\t\\t\\ta=set()\\n\\t\\t\\tcount=s=0\\n\\t\\t\\tfor x in nums:\\n\\t\\t\\t\\ta.add(s)\\n\\t\\t\\t\\ts+=x\\n\\t\\t\\t\\tif s-target in a:\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\t\\ts=0\\n\\t\\t\\t\\t\\ta=set()\\n\\t\\t\\treturn count",
                "codeTag": "Java"
            },
            {
                "id": 2300901,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution(object):\\n    def maxNonOverlapping(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        dict = {0: 0}\\n        dp = [0] * (len(nums) + 1)\\n        sm = 0 \\n        for i in range(1, len(nums) + 1):\\n            sm += nums[i-1]\\n            # if the difference appears before \\n            if sm - target in dict:\\n                # get the dp value \\n                dp[i] = 1 + dp[dict[sm - target]]\\n                \\n            # keep track of the cumulative dp value \\n            dp[i] = max(dp[i-1], dp[i])\\n            \\n            # record/update sm in dictionary \\n            dict[sm] = i \\n        return dp[len(nums)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxNonOverlapping(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        dict = {0: 0}\\n        dp = [0] * (len(nums) + 1)\\n        sm = 0 \\n        for i in range(1, len(nums) + 1):\\n            sm += nums[i-1]\\n            # if the difference appears before \\n            if sm - target in dict:\\n                # get the dp value \\n                dp[i] = 1 + dp[dict[sm - target]]\\n                \\n            # keep track of the cumulative dp value \\n            dp[i] = max(dp[i-1], dp[i])\\n            \\n            # record/update sm in dictionary \\n            dict[sm] = i \\n        return dp[len(nums)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294932,
                "title": "python-simple-prefix-sum",
                "content": "\\n    def maxNonOverlapping(self, nums, target):\\n        running_sum, dict1, prev_idx, count = 0, {0:-1}, float(\"-inf\"), 0\\n        \\n        for i, j in enumerate(nums):\\n            running_sum += j\\n            \\n            if running_sum - target in dict1 and dict1[running_sum - target] >= prev_idx:\\n                prev_idx = i\\n                count += 1\\n                \\n            dict1[running_sum] = i\\n            \\n        return count",
                "solutionTags": [],
                "code": "\\n    def maxNonOverlapping(self, nums, target):\\n        running_sum, dict1, prev_idx, count = 0, {0:-1}, float(\"-inf\"), 0\\n        \\n        for i, j in enumerate(nums):\\n            running_sum += j\\n            \\n            if running_sum - target in dict1 and dict1[running_sum - target] >= prev_idx:\\n                prev_idx = i\\n                count += 1\\n                \\n            dict1[running_sum] = i\\n            \\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 2285257,
                "title": "c-unordered-map",
                "content": "* Idea is almost similar to finding number of subarray having sum as target. But we just need to keep track of starting and ending indices of the subarray we are interested in.\\n\\n * `Prev` keeps track of the ending index of last subarray that had `sum == target`.\\n\\n* If we found a subarray fo `sum == target` we check if the starting index of this subarray is `greater than prev` ,only then they are non overlapping.\\n\\n* Finally we update the index for the particular `sum`.\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mpp ;\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        \\n        int sum = 0 , ways = 0 , prev = INT_MIN ;\\n        mpp[0] = -1 ;\\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            sum += nums[i] ;\\n            if(mpp.find(sum - target) != end(mpp) and mpp[sum-target] >= prev ) ++ways , prev = i ;\\n            mpp[sum] = i ;\\n        }\\n        return ways  ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mpp ;\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        \\n        int sum = 0 , ways = 0 , prev = INT_MIN ;\\n        mpp[0] = -1 ;\\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            sum += nums[i] ;\\n            if(mpp.find(sum - target) != end(mpp) and mpp[sum-target] >= prev ) ++ways , prev = i ;\\n            mpp[sum] = i ;\\n        }\\n        return ways  ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283610,
                "title": "greedy-with-prefix-hash-set",
                "content": "```python\\n\\'\\'\\'\\ngreedy, prefix sum with hashtable\\nO(n), O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        # hash set to record previously encountered prefix sums\\n        prefix_sums = {0}\\n        \\n        res = prefix_sum = 0\\n        for num in nums:\\n            prefix_sum += num\\n            if prefix_sum - target in prefix_sums:\\n                res += 1\\n                # greedily discard prefix sums before num\\n                # thus not considering subarrays that start at before num \\n                prefix_sums = {prefix_sum} \\n            else:\\n                prefix_sums.add(prefix_sum)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\\'\\'\\'\\ngreedy, prefix sum with hashtable\\nO(n), O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\\n        # hash set to record previously encountered prefix sums\\n        prefix_sums = {0}\\n        \\n        res = prefix_sum = 0\\n        for num in nums:\\n            prefix_sum += num\\n            if prefix_sum - target in prefix_sums:\\n                res += 1\\n                # greedily discard prefix sums before num\\n                # thus not considering subarrays that start at before num \\n                prefix_sums = {prefix_sum} \\n            else:\\n                prefix_sums.add(prefix_sum)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254188,
                "title": "c-finding-intervals-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        long sum = 0;\\n        unordered_map<int,int> mp;  //to track prefix-sum\\n        vector<int> dp(n,-2);       //to store index where interval starts\\n        mp[0] = -1;\\n        for(int i = 0;i < n; i++){\\n            sum += nums[i];\\n            if(mp.count(sum - target)){\\n                dp[i] = mp[sum - target];\\n            }\\n            mp[sum] = i;\\n        }\\n        int res = 0,pre = -2;\\n        for(int i = 0;i < n; i++){       //interval is {dp[i] + 1, i}\\n            if(dp[i] != -2 && pre < dp[i] + 1){ //count not overlapping intervals\\n                res++;\\n                pre = i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        long sum = 0;\\n        unordered_map<int,int> mp;  //to track prefix-sum\\n        vector<int> dp(n,-2);       //to store index where interval starts\\n        mp[0] = -1;\\n        for(int i = 0;i < n; i++){\\n            sum += nums[i];\\n            if(mp.count(sum - target)){\\n                dp[i] = mp[sum - target];\\n            }\\n            mp[sum] = i;\\n        }\\n        int res = 0,pre = -2;\\n        for(int i = 0;i < n; i++){       //interval is {dp[i] + 1, i}\\n            if(dp[i] != -2 && pre < dp[i] + 1){ //count not overlapping intervals\\n                res++;\\n                pre = i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2216933,
                "title": "prefix-sum-o-n-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        map<int,vector<int>> mp;\\n        int ans=0;\\n        int sum=0;\\n        int l=-1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(mp[sum-target].size()>0 || sum-target==0){\\n                int k=-1;\\n                if(mp[sum-target].size()>0)\\n                    k=mp[sum-target].back();             \\n                if(k>=l || l==-1){\\n                    ans++;\\n                    l=i;\\n                }\\n            }\\n            mp[sum].push_back(i);            \\n        }\\n               return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target) {\\n        map<int,vector<int>> mp;\\n        int ans=0;\\n        int sum=0;\\n        int l=-1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(mp[sum-target].size()>0 || sum-target==0){\\n                int k=-1;\\n                if(mp[sum-target].size()>0)\\n                    k=mp[sum-target].back();             \\n                if(k>=l || l==-1){\\n                    ans++;\\n                    l=i;\\n                }\\n            }\\n            mp[sum].push_back(i);            \\n        }\\n               return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206248,
                "title": "c-prefix-sum-greedy-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target){\\n        int n = nums.size();\\n        map<int , bool > mp;\\n        vector<int> pre(n) , ans(n);\\n        for(int i = 0 ; i < n  ;i++)ans[i] = 0;\\n        pre[0] = nums[0];\\n        mp[pre[0]] = true;\\n        mp[0]=true;\\n        if(pre[0] == target){ans[0] = 1;pre[0] = 0;mp[0]=true;}\\n        for(int i = 1 ; i < n ; i++)\\n        {\\n            pre[i] = nums[i] + pre[i-1];\\n            if(mp[pre[i] - target] == true)\\n            {\\n                pre[i] = 0;\\n                mp.clear();\\n                mp[0] = true;\\n                ans[i] = 1 + ans[i-1];\\n            }\\n            else{\\n            ans[i] = ans[i-1];\\n            mp[pre[i]] = true;\\n            }\\n        }\\n        return ans[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNonOverlapping(vector<int>& nums, int target){\\n        int n = nums.size();\\n        map<int , bool > mp;\\n        vector<int> pre(n) , ans(n);\\n        for(int i = 0 ; i < n  ;i++)ans[i] = 0;\\n        pre[0] = nums[0];\\n        mp[pre[0]] = true;\\n        mp[0]=true;\\n        if(pre[0] == target){ans[0] = 1;pre[0] = 0;mp[0]=true;}\\n        for(int i = 1 ; i < n ; i++)\\n        {\\n            pre[i] = nums[i] + pre[i-1];\\n            if(mp[pre[i] - target] == true)\\n            {\\n                pre[i] = 0;\\n                mp.clear();\\n                mp[0] = true;\\n                ans[i] = 1 + ans[i-1];\\n            }\\n            else{\\n            ans[i] = ans[i-1];\\n            mp[pre[i]] = true;\\n            }\\n        }\\n        return ans[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566147,
                "content": [
                    {
                        "username": "bboychencan",
                        "content": "I mean, I struggled quite long time with this problem, especially with handling the negative cases, I cannot find a way to avoid scanning the whole array to find out all potential intervals, until I found on geekForgeeks that you can use prefix sum to avoid scaning the array for each index. \\nIt seems many of you can come up with this solution pretty easily, may I ask your thinking process, how do you come up with this idea, or have you confronted very similar problems before, and this problem just become no-brainer?  thanks in advance."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Cost to Cut a Stick",
        "question_content": "<p>Given a wooden stick of length <code>n</code> units. The stick is labelled from <code>0</code> to <code>n</code>. For example, a stick of length <strong>6</strong> is labelled as follows:</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/21/statement.jpg\" style=\"width: 521px; height: 111px;\" />\n<p>Given an integer array <code>cuts</code> where <code>cuts[i]</code> denotes a position you should perform a cut at.</p>\n\n<p>You should perform the cuts in order, you can change the order of the cuts as you wish.</p>\n\n<p>The cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.</p>\n\n<p>Return <em>the minimum total cost</em> of the cuts.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/23/e1.jpg\" style=\"width: 350px; height: 284px;\" />\n<pre>\n<strong>Input:</strong> n = 7, cuts = [1,3,4,5]\n<strong>Output:</strong> 16\n<strong>Explanation:</strong> Using cuts order = [1, 3, 4, 5] as in the input leads to the following scenario:\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/21/e11.jpg\" style=\"width: 350px; height: 284px;\" />\nThe first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.\nRearranging the cuts to be [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 9, cuts = [5,6,1,4,2]\n<strong>Output:</strong> 22\n<strong>Explanation:</strong> If you try the given cuts ordering the cost will be 25.\nThere are much ordering with total cost &lt;= 25, for example, the order [4, 6, 5, 2, 1] has total cost = 22 which is the minimum possible.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= cuts.length &lt;= min(n - 1, 100)</code></li>\n\t<li><code>1 &lt;= cuts[i] &lt;= n - 1</code></li>\n\t<li>All the integers in <code>cuts</code> array are <strong>distinct</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 780880,
                "title": "dp-with-picture-burst-balloons",
                "content": "#### Intuition\\nSimilar problems:\\n- [312. Burst Balloons](https://leetcode.com/problems/burst-balloons/)\\n- [1000. Minimum Cost to Merge Stones](https://leetcode.com/problems/minimum-cost-to-merge-stones/)\\n- [1039. Minimum Score Triangulation of Polygon](https://leetcode.com/problems/minimum-score-triangulation-of-polygon/)\\n\\t- Check out [\"with picture\" solution](https://leetcode.com/problems/minimum-score-triangulation-of-polygon/discuss/286753/C%2B%2B-with-picture), and also - how the heck that problem is \"Medium\"??\\n\\nTo make it simpler, we add two sentinel values to `cuts` - left and right edges of the stick. Then, we sort the cuts so we can easily identify all cuts between two points. DFS can help us find the most efficient sequence of cuts. To avoid recomputation, we memoise the best answer for stick between `cuts[i]` and `cuts[j]` in `dp[i][j]`.\\n\\nIn the following example, you can see the first cut at points `1` (or `4`) results in total cost of `13` (`5 + 0 + 8`). If we first cut at point `2` (or `3`), the cost will be `12` (`5 + 2 + 5`).\\n![image](https://assets.leetcode.com/users/images/d8e82982-420d-4928-8db8-23033718f8f6_1597035318.945624.png)\\n\\n#### Top-Down DP\\n**C++**\\n```cpp\\nint dp[102][102] = {};\\nint dfs(vector<int>& cuts, int i, int j) {\\n    if (j - i <= 1)\\n        return 0;\\n    if (!dp[i][j]) {\\n        dp[i][j] = INT_MAX;\\n        for (auto k = i + 1; k < j; ++k)\\n            dp[i][j] = min(dp[i][j], \\n                cuts[j] - cuts[i] + dfs(cuts, i, k) + dfs(cuts, k, j));\\n    }\\n    return dp[i][j];\\n}\\nint minCost(int n, vector<int>& cuts) {\\n    cuts.push_back(0);\\n    cuts.push_back(n);\\n    sort(begin(cuts), end(cuts));\\n    return dfs(cuts, 0, cuts.size() - 1);\\n}\\n```\\n\\n#### Bottom-Up DP\\nAfter you figure out top-down DP, it\\'s easy to convert it to bottom-up solution.  The only trick here is to move `i` backward. This ensures that smaller cuts are processed before calculating min cost for the larger ones. It happens this way naturally in the recursive solution.\\n\\n**Java**\\n```java\\npublic int minCost(int n, int[] cuts) {\\n    var c = new ArrayList<Integer>();\\n    for (int cut : cuts)\\n        c.add(cut);\\n    c.addAll(Arrays.asList(0, n));\\n    Collections.sort(c);\\n    int[][] dp = new int[c.size()][c.size()];\\n    for (int i = c.size() - 1; i >= 0; --i)\\n        for (int j = i + 1; j < c.size(); ++j) {\\n            for (int k = i + 1; k < j; ++k)\\n                dp[i][j] = Math.min(dp[i][j] == 0 ? Integer.MAX_VALUE : dp[i][j],\\n                    c.get(j) - c.get(i) + dp[i][k] + dp[k][j]);\\n        }\\n    return dp[0][c.size() - 1];    \\n}\\n```\\n\\n**Complexity Analysis**\\n- Time: O(n ^ 3), where n is the number of cuts. It takes O(n) to calculate each case, and we have O(n ^ 2) distinct cases. \\n- Memory: O(n ^ 2) for memoisation/tabulation.",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nint dp[102][102] = {};\\nint dfs(vector<int>& cuts, int i, int j) {\\n    if (j - i <= 1)\\n        return 0;\\n    if (!dp[i][j]) {\\n        dp[i][j] = INT_MAX;\\n        for (auto k = i + 1; k < j; ++k)\\n            dp[i][j] = min(dp[i][j], \\n                cuts[j] - cuts[i] + dfs(cuts, i, k) + dfs(cuts, k, j));\\n    }\\n    return dp[i][j];\\n}\\nint minCost(int n, vector<int>& cuts) {\\n    cuts.push_back(0);\\n    cuts.push_back(n);\\n    sort(begin(cuts), end(cuts));\\n    return dfs(cuts, 0, cuts.size() - 1);\\n}\\n```\n```java\\npublic int minCost(int n, int[] cuts) {\\n    var c = new ArrayList<Integer>();\\n    for (int cut : cuts)\\n        c.add(cut);\\n    c.addAll(Arrays.asList(0, n));\\n    Collections.sort(c);\\n    int[][] dp = new int[c.size()][c.size()];\\n    for (int i = c.size() - 1; i >= 0; --i)\\n        for (int j = i + 1; j < c.size(); ++j) {\\n            for (int k = i + 1; k < j; ++k)\\n                dp[i][j] = Math.min(dp[i][j] == 0 ? Integer.MAX_VALUE : dp[i][j],\\n                    c.get(j) - c.get(i) + dp[i][k] + dp[k][j]);\\n        }\\n    return dp[0][c.size() - 1];    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781074,
                "title": "java-c-python-merge-stones",
                "content": "## **Intuition**\\nSimilar to the problem [1000. Minimum Cost to Merge Stones](https://leetcode.com/problems/minimum-cost-to-merge-stones/discuss/247567/JavaC++Python-DP).\\n\\nInstead of considering the cost to cut,\\nwe can transform the problem to the cost to stick all sticks.\\n\\nThen we have the problem \"merge stones\".\\nThough in the format of dp, they are exatly the same.\\n<br>\\n\\n## **Explanation**\\nAdd the \"cut\" index 0 and n, then sort all stick position.\\n`dp[i][j]` means the minimum cost to stick all sticks between `A[i]` and `A[j]`\\n<br>\\n\\n## **Complexity**\\nTime `O(N^3)`\\nSpace `O(N^2)`, can be imporved to `O(N)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minCost(int n, int[] cuts) {\\n        List<Integer> A = new ArrayList<>();\\n        for (int a : cuts) {\\n            A.add(a);\\n        }\\n        A.add(0);\\n        A.add(n);\\n        Collections.sort(A);\\n        int k = A.size();\\n        int[][] dp = new int[k][k];\\n        for (int d = 2; d < k; ++d) {\\n            for (int i = 0; i < k - d; ++i) {\\n                dp[i][i + d] = 1000000000;\\n                for (int m = i + 1; m < i + d; ++m) {\\n                    dp[i][i + d] = Math.min(dp[i][i + d], dp[i][m] + dp[m][i + d] + A.get(i + d) - A.get(i));\\n                }\\n            }\\n        }\\n        return dp[0][k - 1];\\n    }\\n```\\n**C++**\\n```cpp\\n    int minCost(int n, vector<int>& A) {\\n        A.push_back(0);\\n        A.push_back(n);\\n        sort(A.begin(), A.end());\\n        int k = A.size();\\n        vector<vector<int>> dp(k, vector<int>(k));\\n        for (int d = 2; d < k; ++d) {\\n            for (int i = 0; i < k - d; ++i) {\\n                dp[i][i + d] = 1e9;\\n                for (int m = i + 1; m < i + d; ++m) {\\n                    dp[i][i + d] = min(dp[i][i + d], dp[i][m] + dp[m][i + d] + A[i + d] - A[i]);\\n                }\\n            }\\n        }\\n        return dp[0][k - 1];\\n    }\\n```\\n**Python:**\\n```py\\n    def minCost(self, n, A):\\n        A = sorted(A + [0, n])\\n        k = len(A)\\n        dp = [[0] * k for _ in xrange(k)]\\n        for d in xrange(2, k):\\n            for i in xrange(k - d):\\n                dp[i][i + d] = min(dp[i][m] + dp[m][i + d] for m in xrange(i + 1, i + d)) + A[i + d] - A[i]\\n        return dp[0][k - 1]\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minCost(int n, int[] cuts) {\\n        List<Integer> A = new ArrayList<>();\\n        for (int a : cuts) {\\n            A.add(a);\\n        }\\n        A.add(0);\\n        A.add(n);\\n        Collections.sort(A);\\n        int k = A.size();\\n        int[][] dp = new int[k][k];\\n        for (int d = 2; d < k; ++d) {\\n            for (int i = 0; i < k - d; ++i) {\\n                dp[i][i + d] = 1000000000;\\n                for (int m = i + 1; m < i + d; ++m) {\\n                    dp[i][i + d] = Math.min(dp[i][i + d], dp[i][m] + dp[m][i + d] + A.get(i + d) - A.get(i));\\n                }\\n            }\\n        }\\n        return dp[0][k - 1];\\n    }\\n```\n```cpp\\n    int minCost(int n, vector<int>& A) {\\n        A.push_back(0);\\n        A.push_back(n);\\n        sort(A.begin(), A.end());\\n        int k = A.size();\\n        vector<vector<int>> dp(k, vector<int>(k));\\n        for (int d = 2; d < k; ++d) {\\n            for (int i = 0; i < k - d; ++i) {\\n                dp[i][i + d] = 1e9;\\n                for (int m = i + 1; m < i + d; ++m) {\\n                    dp[i][i + d] = min(dp[i][i + d], dp[i][m] + dp[m][i + d] + A[i + d] - A[i]);\\n                }\\n            }\\n        }\\n        return dp[0][k - 1];\\n    }\\n```\n```py\\n    def minCost(self, n, A):\\n        A = sorted(A + [0, n])\\n        k = len(A)\\n        dp = [[0] * k for _ in xrange(k)]\\n        for d in xrange(2, k):\\n            for i in xrange(k - d):\\n                dp[i][i + d] = min(dp[i][m] + dp[m][i + d] for m in xrange(i + 1, i + d)) + A[i + d] - A[i]\\n        return dp[0][k - 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 780920,
                "title": "java-detailed-explanation-dfs-memo-top-down-dp",
                "content": "**Key Notes:**\\n- DFS+Memo is very good at handling this kind of question\\n- Try **every cuts in every order** and return the min of them\\n- Naive Implementation:\\n\\t- Use a boolean array to indicate used or not\\n\\t- Use **TreeSet to find the left and right of a cut**. (when cut at somewhere, you need to know the cost (length of stick))\\n\\t- Use the boolean array **state** as memo.\\n\\n**It is simple but will TLE, let\\'s improve.**\\n- Use boolean array as state is painful (O(N))\\n- Basically, we want to cache the min cost for **a specific stick [left to right]**\\n- We could use **[left, right] to indicate a stick and cache it** as memo\\n- Every cut, you will \\'create\\' two more sticks: **[left, cuts[i]]** and **[cuts[i], right]**\\n\\n```java\\npublic int minCost(int n, int[] cuts) {\\n\\n    Arrays.sort(cuts);\\n\\treturn helper(cuts, new HashMap<>(), 0, n);\\n}\\n\\nprivate int helper(int[] cuts, Map<String, Integer> memo, int l, int r) {\\n\\n\\tint res = Integer.MAX_VALUE;\\n\\n\\tString key = l + \"-\" + r;\\n\\tif (memo.containsKey(key)) return memo.get(key);\\n\\n\\tfor (int i = 0; i < cuts.length; ++i) {\\n\\t\\tif (cuts[i] <= l || cuts[i] >= r) continue;\\n\\n\\t\\tint cost = r - l;\\n\\t\\tres = Math.min(\\n\\t\\t           // min cost of left stick + cost + min cost of right stick\\n\\t\\t\\t\\t   helper(cuts, memo, l, cuts[i]) + cost + helper(cuts, memo, cuts[i], r), \\n\\t\\t\\t\\t   res);\\n\\t}\\n\\n\\tres = res == Integer.MAX_VALUE ? 0 : res;\\n\\tmemo.put(key, res);\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int minCost(int n, int[] cuts) {\\n\\n    Arrays.sort(cuts);\\n\\treturn helper(cuts, new HashMap<>(), 0, n);\\n}\\n\\nprivate int helper(int[] cuts, Map<String, Integer> memo, int l, int r) {\\n\\n\\tint res = Integer.MAX_VALUE;\\n\\n\\tString key = l + \"-\" + r;\\n\\tif (memo.containsKey(key)) return memo.get(key);\\n\\n\\tfor (int i = 0; i < cuts.length; ++i) {\\n\\t\\tif (cuts[i] <= l || cuts[i] >= r) continue;\\n\\n\\t\\tint cost = r - l;\\n\\t\\tres = Math.min(\\n\\t\\t           // min cost of left stick + cost + min cost of right stick\\n\\t\\t\\t\\t   helper(cuts, memo, l, cuts[i]) + cost + helper(cuts, memo, cuts[i], r), \\n\\t\\t\\t\\t   res);\\n\\t}\\n\\n\\tres = res == Integer.MAX_VALUE ? 0 : res;\\n\\tmemo.put(key, res);\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570562,
                "title": "image-explanation-recursion-memo-4-states-2-states-bottom-up-c-java-python",
                "content": "\\n\\n# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Minimum Cost to Cut a Stick` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/af8c942b-f4c7-4f27-9e95-e4075de806b6_1685249499.1270618.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/218b6ebe-f4fc-4579-88d9-9b568b7cbee3_1685249524.9734313.png)\\n![image.png](https://assets.leetcode.com/users/images/f8e02493-99da-491e-9ba3-0bf4971792c4_1685249534.0134556.png)\\n![image.png](https://assets.leetcode.com/users/images/b35e041e-f3a8-4d03-bbd5-59d1f7234d1f_1685249541.657466.png)\\n![image.png](https://assets.leetcode.com/users/images/cdacd21b-3142-46fa-9411-3160a2ce4d19_1685249554.4035125.png)\\n![image.png](https://assets.leetcode.com/users/images/a438bca8-7912-4a69-bf80-a9f507578a67_1685249569.363905.png)\\n![image.png](https://assets.leetcode.com/users/images/1f3a5ab6-efc5-4b06-b902-a93bba2291a7_1685249580.4884155.png)\\n![image.png](https://assets.leetcode.com/users/images/de253c93-2a70-47a9-afae-f8c984d40405_1685249590.0834622.png)\\n![image.png](https://assets.leetcode.com/users/images/f06928d8-72fb-419e-aaa6-38a974ebcd9a_1685249599.2943306.png)\\n![image.png](https://assets.leetcode.com/users/images/8a172290-8911-40de-aa2c-5769eb034bcf_1685249612.8043947.png)\\n![image.png](https://assets.leetcode.com/users/images/f698ee02-815b-4e54-82e0-69ccb4f0f4b0_1685249622.4683037.png)\\n![image.png](https://assets.leetcode.com/users/images/9addd2b5-e6db-4abf-bd96-2759b71c063b_1685249637.4515831.png)\\n![image.png](https://assets.leetcode.com/users/images/ead69aba-d6d5-46da-9010-37e90e7b3da0_1685249645.570326.png)\\n![image.png](https://assets.leetcode.com/users/images/fbd05d5e-3456-4d63-808d-cbe9b5992189_1685249652.4306672.png)\\n![image.png](https://assets.leetcode.com/users/images/abbcddeb-eb08-4aad-8915-277d4e1a1bec_1685249660.380961.png)\\nHere the above n - represents the cuts.size(), you can also take it as m^3 also for time & m^2 for space.\\n\\n![image.png](https://assets.leetcode.com/users/images/ed1db61b-deed-4fa2-a970-5fc8643179c8_1685249667.5056508.png)\\n![image.png](https://assets.leetcode.com/users/images/d493be3d-7788-4411-b10c-80d83604a4cd_1685249673.580824.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int start_stick, int end_stick, vector<int>& cuts, int left, int right){\\n        if(left > right) return 0;\\n        \\n        if(dp[left][right] != -1) return dp[left][right];\\n        \\n        int cost = 1e9;\\n        \\n        for(int i=left; i<=right; i++){\\n            int left_cost = solve(start_stick, cuts[i], cuts, left, i-1);\\n            int right_cost = solve(cuts[i], end_stick, cuts, i+1, right);\\n            int curr_cost = (end_stick - start_stick) + left_cost + right_cost;\\n            cost = min(cost,curr_cost);\\n        }\\n        \\n        return dp[left][right] = cost;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(cuts.begin(),cuts.end());\\n        return solve(0, n, cuts, 0, cuts.size()-1);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    int[][] dp;\\n    \\n    int solve(int start_stick, int end_stick, int[] cuts, int left, int right) {\\n        if (left > right) return 0;\\n\\n        if (dp[left][right] != -1) return dp[left][right];\\n\\n        int cost = Integer.MAX_VALUE;\\n\\n        for (int i = left; i <= right; i++) {\\n            int left_cost = solve(start_stick, cuts[i], cuts, left, i - 1);\\n            int right_cost = solve(cuts[i], end_stick, cuts, i + 1, right);\\n            int curr_cost = (end_stick - start_stick) + left_cost + right_cost;\\n            cost = Math.min(cost, curr_cost);\\n        }\\n\\n        return dp[left][right] = cost;\\n    }\\n    \\n    int minCost(int n, int[] cuts) {\\n        dp = new int[cuts.length][cuts.length];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        \\n        Arrays.sort(cuts);\\n        return solve(0, n, cuts, 0, cuts.length - 1);\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def solve(self, start_stick, end_stick, cuts, left, right, dp):\\n        if left > right:\\n            return 0\\n\\n        if dp[left][right] != -1:\\n            return dp[left][right]\\n\\n        cost = float(\\'inf\\')\\n\\n        for i in range(left, right + 1):\\n            left_cost = self.solve(start_stick, cuts[i], cuts, left, i - 1, dp)\\n            right_cost = self.solve(cuts[i], end_stick, cuts, i + 1, right, dp)\\n            curr_cost = (end_stick - start_stick) + left_cost + right_cost\\n            cost = min(cost, curr_cost)\\n\\n        dp[left][right] = cost\\n        return cost\\n\\n    def minCost(self, n, cuts):\\n        dp = [[-1] * len(cuts) for _ in range(len(cuts))]\\n        cuts.sort()\\n        return self.solve(0, n, cuts, 0, len(cuts) - 1, dp)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int start_stick, int end_stick, vector<int>& cuts, int left, int right){\\n        if(left > right) return 0;\\n        \\n        if(dp[left][right] != -1) return dp[left][right];\\n        \\n        int cost = 1e9;\\n        \\n        for(int i=left; i<=right; i++){\\n            int left_cost = solve(start_stick, cuts[i], cuts, left, i-1);\\n            int right_cost = solve(cuts[i], end_stick, cuts, i+1, right);\\n            int curr_cost = (end_stick - start_stick) + left_cost + right_cost;\\n            cost = min(cost,curr_cost);\\n        }\\n        \\n        return dp[left][right] = cost;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(cuts.begin(),cuts.end());\\n        return solve(0, n, cuts, 0, cuts.size()-1);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    int[][] dp;\\n    \\n    int solve(int start_stick, int end_stick, int[] cuts, int left, int right) {\\n        if (left > right) return 0;\\n\\n        if (dp[left][right] != -1) return dp[left][right];\\n\\n        int cost = Integer.MAX_VALUE;\\n\\n        for (int i = left; i <= right; i++) {\\n            int left_cost = solve(start_stick, cuts[i], cuts, left, i - 1);\\n            int right_cost = solve(cuts[i], end_stick, cuts, i + 1, right);\\n            int curr_cost = (end_stick - start_stick) + left_cost + right_cost;\\n            cost = Math.min(cost, curr_cost);\\n        }\\n\\n        return dp[left][right] = cost;\\n    }\\n    \\n    int minCost(int n, int[] cuts) {\\n        dp = new int[cuts.length][cuts.length];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        \\n        Arrays.sort(cuts);\\n        return solve(0, n, cuts, 0, cuts.length - 1);\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def solve(self, start_stick, end_stick, cuts, left, right, dp):\\n        if left > right:\\n            return 0\\n\\n        if dp[left][right] != -1:\\n            return dp[left][right]\\n\\n        cost = float(\\'inf\\')\\n\\n        for i in range(left, right + 1):\\n            left_cost = self.solve(start_stick, cuts[i], cuts, left, i - 1, dp)\\n            right_cost = self.solve(cuts[i], end_stick, cuts, i + 1, right, dp)\\n            curr_cost = (end_stick - start_stick) + left_cost + right_cost\\n            cost = min(cost, curr_cost)\\n\\n        dp[left][right] = cost\\n        return cost\\n\\n    def minCost(self, n, cuts):\\n        dp = [[-1] * len(cuts) for _ in range(len(cuts))]\\n        cuts.sort()\\n        return self.solve(0, n, cuts, 0, len(cuts) - 1, dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395121,
                "title": "4-minutes-read-simple-no-brainer-recursion-memoization",
                "content": "The logic is pretty simple, perform brute force recursion, and then memoize the solution. Yes, that\\'s it, nothing more. Just simple memoization.\\n\\n<br>\\n\\n**ALGORITHM** \\uD83D\\uDCD6\\n1. Perform Brute Force Recursion\\n\\t1. At any state of recursion, we would be having a piece of rod (or wood), from index `l` to index `r`.\\n\\t2. Try all the possible cuts on this segment, which splits it into further 2 segments and recurse for the minimum cost in which those 2 segments can be made.\\n\\t4. The minimum cost among all those possible cuts + the cost of making our current cut, would be our best cost for cutting the wood in this segment, i.e. from `l` to `r`.\\n2. Memoize the minimum cost for the current `l` and `r` value in a `memo`.\\n3. If the answer for `l` to `r` was already present in our `memo`, then directly retrun the value stored in the memo corresponding to this `l` and `r` instead of performing from *step 1*.\\n\\n<br>\\n\\n**CONTEXT** \\uD83E\\uDDD0\\nThe algorithm is quite Brute Force, we would try to generate all possible permutations of cuts, and would try to know what permutation would lead to best result, i.e. minimize our cost for cutting.\\n\\nLet us suppose we are currently having a wood piece from index `l` to index `r` (i.e. the length of the wood is `r - l`, indexing is done as illustrated in the problem). Now, we try every possible cut that we could perform in the range from `l` to `r`. \\n\\nSince a cut (let\\'s say, cut is at `i` index) results in our original piece to further split into 2 parts (one from `[l, i]`, and second from `[i, r]`). Also, lets suppose the minimum cost of cutting, the segment `[l, i]` is `minLeft` and similarly for `[i, r]` is `minRight`. Hence the cost to cut the rod segment `[l, r]` would be `cost_i = minLeft + minRight + (r - l)` (`r - l` is the cost to perform the cut at `i`).\\nSimilarly, a cut at `j` index would cost in total, say, `cost_j`, similarly at `k` be `cost_k` and so on...\\n\\nThe minimum cost to cut the rod from index `l` to `r` hence would be `min(cost_i, cost_j, cost_k, ...)`.\\n\\n<br>\\n\\n> **_[BONUS]_ HOW TO MEMOIZE (almost) ANY RECURSIVE SOLUTION** \\uD83D\\uDE09\\n> There is a simple trick to write any DP solution using Recursion + Memoization. It comes very handy specially in the interviews, where we are not able to come up with a DP approach because we only focus on tabular method. So do try out this approach in interviews and you might at least end up with presenting a DP solution which might not be as fast as Tabular (due to recursion overhead), but is way better than normal recursive solution. \\n> \\n> The steps are:\\n> Firstly simply write down the recursive approach.\\n> Secondly, have a carefull look at the parameters of the recursive function, this would give the hint of how you would be memoizing your result. Filter out those parameters, that actually affect the answer for any state of your recursive call (or simply the parameters whose values is changing in each recursive call). Let\\'s call such parameters `special` parameters.\\n> Now make a `dp` (which would be a multidimension array)  whose \\n> - Type would be the return type of your recursive function (i.e., `int`, `double`, etc). \\n> - The dimensions of `dp` would be the number of `special` parameters.\\n> - The size of each dimension of `dp` would be the range of values in which those `special` parameters could be.\\n> \\n> Now simply initialize your `dp` with some value (say `-INF`, which can\\'t be a valid answer in any case), and after each recursion, just before returning the value for current recursion, save the value in `dp`.\\n> Now, whenever while recursing, we first check if `dp` value for current value of `special` parameters is `-INF` or not, if yes, continue with the recursion. If no, directly return the value given by `dp` (indicating, you would have previously computed the value for this state and saved in `dp`, so why to compute again).\\n> \\n> In other cases, when you are not able to determine the `special` parameters, or the range of these `special` parameters, or they are somewhat very large, you may directly use a `map` like data structure, and store the values of your parameter as `key` and the computed value for this recursion as your `value` in that map, which would now act as your DP.\\n\\n<br>\\n\\nBelow is the Java Code for the above discussed approach \\uD83D\\uDC47\\n```java\\nclass Solution {\\n    Map<ArrayList<Integer>, Integer> map;\\n    public int minCost(int n, int[] cuts) {\\n        map = new HashMap<>();\\n        return cost(cuts, 0, n);\\n    }\\n    public int cost(int cuts[], int l, int r) {\\n        ArrayList<Integer> ind = new ArrayList<>();\\n        ind.add(l); ind.add(r);\\n        if(map.containsKey(ind)) return map.get(ind);\\n        int min = Integer.MAX_VALUE;\\n        for(int i : cuts) {\\n            if(i <= l || i >= r) continue;\\n            int temp = cost(cuts, l, i);\\n            temp += cost(cuts, i, r);\\n            min = Math.min(temp + r - l, min);\\n        }\\n        if(min == Integer.MAX_VALUE) {\\n            min = 0;\\n        }\\n        map.put(ind, min);\\n        return min;\\n    }\\n}\\n```\\n\\n<br>\\n\\nPlease do like the post if you feel so \\uD83D\\uDE0A.\\nAlso, do share your valuable suggestions and reviews in the comments \\uD83D\\uDCAC.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```java\\nclass Solution {\\n    Map<ArrayList<Integer>, Integer> map;\\n    public int minCost(int n, int[] cuts) {\\n        map = new HashMap<>();\\n        return cost(cuts, 0, n);\\n    }\\n    public int cost(int cuts[], int l, int r) {\\n        ArrayList<Integer> ind = new ArrayList<>();\\n        ind.add(l); ind.add(r);\\n        if(map.containsKey(ind)) return map.get(ind);\\n        int min = Integer.MAX_VALUE;\\n        for(int i : cuts) {\\n            if(i <= l || i >= r) continue;\\n            int temp = cost(cuts, l, i);\\n            temp += cost(cuts, i, r);\\n            min = Math.min(temp + r - l, min);\\n        }\\n        if(min == Integer.MAX_VALUE) {\\n            min = 0;\\n        }\\n        map.put(ind, min);\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407464,
                "title": "c-recursion-and-memoization-simple-and-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    \\n    int mincost(int start, int end, vector<int>& cuts, int cuts_start, int cuts_end)\\n    {\\n        if(cuts_start>cuts_end)\\n            return 0;\\n        \\n        if(dp[cuts_start][cuts_end]!=-1)\\n            return dp[cuts_start][cuts_end];\\n        \\n        int minimum = INT_MAX;\\n        for(int i=cuts_start; i<=cuts_end; i++)\\n            minimum = min(minimum, (end-start)+mincost(start, cuts[i], cuts, cuts_start, i-1)+mincost(cuts[i], end, cuts, i+1, cuts_end));\\n        \\n        return dp[cuts_start][cuts_end] = minimum;\\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n\\n        memset(dp,-1,sizeof(dp));\\n        sort(cuts.begin(),cuts.end());\\n        return mincost(0, n, cuts, 0, cuts.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    \\n    int mincost(int start, int end, vector<int>& cuts, int cuts_start, int cuts_end)\\n    {\\n        if(cuts_start>cuts_end)\\n            return 0;\\n        \\n        if(dp[cuts_start][cuts_end]!=-1)\\n            return dp[cuts_start][cuts_end];\\n        \\n        int minimum = INT_MAX;\\n        for(int i=cuts_start; i<=cuts_end; i++)\\n            minimum = min(minimum, (end-start)+mincost(start, cuts[i], cuts, cuts_start, i-1)+mincost(cuts[i], end, cuts, i+1, cuts_end));\\n        \\n        return dp[cuts_start][cuts_end] = minimum;\\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n\\n        memset(dp,-1,sizeof(dp));\\n        sort(cuts.begin(),cuts.end());\\n        return mincost(0, n, cuts, 0, cuts.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780901,
                "title": "c-bottom-up-dp-with-explanation",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. DP\\n\\nTo simplify the code, we insert `0` and `n` into the `A`.\\n\\nLet `dp[i][j]` be the minimum cost if we cut on the stick from `A[i]` to `A[j]`.\\n\\n* If `j == i + 1` (`len == 2`), we can\\'t cut on this stick, so `dp[i][j] = 0`.\\n* If `j == i + 2` (`len == 3`), the only choice you have is to cut in the middle, and the cost is the length of this stick, so `dp[i][j] = A[i + 2] - A[i]`.\\n* If `j > i + 2` (`len >= 4`), we can try to cut at `k` where `i < k < j` and use the minimum cost we can get which is the cost of cutting the left part `dp[i][k]` plus the cost of cutting the right part `dp[k][j]` and the cost of the current cut `A[j] - A[i]`, so `dp[i][j] = min( dp[i][k] + dp[k][j] + A[j] - A[i] | i < k < j)`\\n\\nThe answer is `dp[0][N-1]`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-201/problems/minimum-cost-to-cut-a-stick/\\n// Author: github.com/lzl124631x\\n// Time: O(N^3)\\n// Space: O(N^2)\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& A) {\\n        A.push_back(0);\\n        A.push_back(n);\\n        sort(begin(A), end(A));\\n        int N = A.size();\\n        vector<vector<int>> dp(N, vector<int>(N, INT_MAX));\\n        for (int i = 0; i < N - 1; ++i) dp[i][i + 1] = 0;\\n        for (int i = 0; i < N - 2; ++i) dp[i][i + 2] = A[i + 2] - A[i];\\n        for (int len = 4; len <= N; ++len) {\\n            for (int i = 0; i <= N - len; ++i) {\\n                int j = i + len - 1;\\n                for (int k = i + 1; k < j; ++k) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + A[j] - A[i]);\\n            }\\n        }\\n        return dp[0][N - 1];\\n    }\\n};\\n```\\n\\n---\\n\\nupdate 10/30/2020\\n\\nPrevent recomputing `A[j] - A[i]`\\n\\n```\\n// OJ: https://leetcode.com/problems/minimum-cost-to-cut-a-stick/\\n// Author: github.com/lzl124631x\\n// Time: O(N^3)\\n// Space: O(N^2)\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& A) {\\n        A.push_back(0);\\n        A.push_back(n);\\n        sort(begin(A), end(A));\\n        int N = A.size(), inf = INT_MAX;\\n        vector<vector<int>> dp(N, vector<int>(N, inf));\\n        for (int i = 0; i + 1 < N; ++i) dp[i][i + 1] = 0;\\n        for (int i = 0; i + 2 < N; ++i) dp[i][i + 2] = A[i + 2] - A[i];\\n        for (int i = N - 4; i >= 0; --i) {\\n            for (int j = i + 3; j < N; ++j) {\\n                int val = inf;\\n                for (int k = i + 1; k < j; ++k) val = min(val, dp[i][k] + dp[k][j]);\\n                dp[i][j] = val + A[j] - A[i];\\n            }\\n        }\\n        return dp[0][N - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-201/problems/minimum-cost-to-cut-a-stick/\\n// Author: github.com/lzl124631x\\n// Time: O(N^3)\\n// Space: O(N^2)\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& A) {\\n        A.push_back(0);\\n        A.push_back(n);\\n        sort(begin(A), end(A));\\n        int N = A.size();\\n        vector<vector<int>> dp(N, vector<int>(N, INT_MAX));\\n        for (int i = 0; i < N - 1; ++i) dp[i][i + 1] = 0;\\n        for (int i = 0; i < N - 2; ++i) dp[i][i + 2] = A[i + 2] - A[i];\\n        for (int len = 4; len <= N; ++len) {\\n            for (int i = 0; i <= N - len; ++i) {\\n                int j = i + len - 1;\\n                for (int k = i + 1; k < j; ++k) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + A[j] - A[i]);\\n            }\\n        }\\n        return dp[0][N - 1];\\n    }\\n};\\n```\n```\\n// OJ: https://leetcode.com/problems/minimum-cost-to-cut-a-stick/\\n// Author: github.com/lzl124631x\\n// Time: O(N^3)\\n// Space: O(N^2)\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& A) {\\n        A.push_back(0);\\n        A.push_back(n);\\n        sort(begin(A), end(A));\\n        int N = A.size(), inf = INT_MAX;\\n        vector<vector<int>> dp(N, vector<int>(N, inf));\\n        for (int i = 0; i + 1 < N; ++i) dp[i][i + 1] = 0;\\n        for (int i = 0; i + 2 < N; ++i) dp[i][i + 2] = A[i + 2] - A[i];\\n        for (int i = N - 4; i >= 0; --i) {\\n            for (int j = i + 3; j < N; ++j) {\\n                int val = inf;\\n                for (int k = i + 1; k < j; ++k) val = min(val, dp[i][k] + dp[k][j]);\\n                dp[i][j] = val + A[j] - A[i];\\n            }\\n        }\\n        return dp[0][N - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 792451,
                "title": "observation-choose-closest-middle-cut-not-guarantee-optimal-cost",
                "content": "I have the idea to choosing closest middle cut in range, and it fails to guarantee always global optimal result.\\n\\nThe heuristic fails at this test case:\\nn = 30, cuts = [5, 7, 13, 15, 18, 25, 26, 29]\\n\\nAccording to find closest middle cut, it will choose 15 as first cut since it\\'s the the half of 30, and best min cuts under 15 is 94, one of the possible outcome is [15, 7, 5, 13, 25, 26, 29, 18]\\nBut global minimum cost is 92 when 18 is first cut, one of possible outcome is [18, 7, 5, 13, 15, 25, 29, 26]\\n\\nI guess it\\'s somehow related to the nature of this problem, and I have following observations:\\n\\n- for cut count = 2, choose the cut close to middle first\\n\\n  e.g. n = 20, cuts = [5, 13]\\n  cuts: [5, 13], cost = 20 + 15\\n  cuts: [13, 5], cost = 20 + 13\\n  choose 13 first because it\\'s closer to middle (10)\\n\\n  e.g. n = 30, cuts = [5, 10]\\n  cuts: [5, 10], cost = 30 + 25\\n  cuts: [10, 5], cost = 30 + 10\\n  choose 10 first because it\\'s closer to middle (15)\\n\\n  e.g. n = 30, cuts = [18, 25]\\n  cuts: [18, 25], cost = 30 + 12\\n  cuts: [25, 18], cost = 30 + 25\\n  choose 18 first because it\\'s closer to middle (15)\\n\\n- for cuts count = 3, to minimize overall cost is to minimize next cut, choose cut close to middle is still best choice\\n\\n  e.g. n = 30, cuts = [1, 2, 3]\\n  cuts: [1, 2, 3], cost = 30 + 29 + 18   - (1)\\n  cuts: [2, 1, 3], cost = 30 + 2 + 28     - (2)\\n  cuts: [3, 2, 1], cost = 30 + 2 + 1       - (3)\\n\\n  (2) is smaller than (1) is because cost to cut 1 is reduced\\n  (3) is smaller than (2) is because cost to cut 3 is reduced\\n  choose 3 first because it closer to middle (15)\\n\\n  e.g. n = 30, cuts = [16, 24, 7]\\n  cuts: [7, 16, 24], cost = 30 + 23 + 14\\n  cuts: [16, 7, 24], cost = 30 + 16 + 14\\n  cuts: [24, 7, 16], cost = 30 + 24 + 17\\n  choose 16 first because it\\'s closer to middle (15)\\n\\nBut the heuristic to choose cut close to middle doesn\\'t  always guarantee to have global optimal solution in the situation of 4 cuts, take n = 30, cuts = [10, 15, 18, 25] as example\\ncuts: [15, 10, 25, 18], cost = 30 + 15 + 15 + 10  = 60 + 10   - (1)\\ncuts: [18, 10, 25, 15], cost = 30 + 18 + 12 + 8    = 60 + 8     - (2)\\n(2) has smaller cost than (1) because cost of 15 is reduced.\\n\\nI found that if there are 4 cuts, in the situation that first cut separate rest of cuts into 2 groups (in the situation at least one cut exist in these 2 groups), assume c is the first cut in middle:\\n```\\n_  _  ... _ | _  _ ... _  _\\n0         c   c           n\\n```\\n\\nsince at least one cut exist, minimum cost will be determined by the group has 2 cuts because total 4 cuts, first cut is determined, there might be 2 conditions:\\n [x, c, y, z] or [x, y, c, z]\\n \\n - [x, c, y, z] since x & y exist, cost = n + (n/2) + (n/2) + (cost to cut y or z)\\n - [x, y, c, z] since x & z exist, cost = n + (n/2) + (n/2) + (cost to cut x or y)\\n\\nIn this counter example, choosing middle cut doesn\\'t always guarantee the global optimal result, since minimum cost is determined by the last cut (y, z in [x, c, y, z] or x, y in [x, y, c, z]), which is not considered when choosing fist middle cut c",
                "solutionTags": [],
                "code": "```\\n_  _  ... _ | _  _ ... _  _\\n0         c   c           n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781068,
                "title": "recursion-memoization-turned-into-simple-dp-question-c",
                "content": "The only trick in this question was to push 0 and n to the cuts array, then it is just a simple Matrix Chain Multiplication type of question.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int dp[102][102];\\n    \\n    int solve(vector<int> &cuts, int low, int high) {\\n        if(low+1==high) return 0;\\n        else if(dp[low][high]!=-1)\\n            return dp[low][high];\\n        \\n        else {\\n            int ans = INT_MAX;\\n            for(int i=low+1; i<high; i++) {\\n                int curr = cuts[high]-cuts[low] + solve(cuts, low, i) + solve(cuts, i, high);\\n                ans = min(ans, curr);\\n            }\\n            return dp[low][high] = ans;\\n        }\\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        memset(dp, -1, sizeof(dp));\\n        sort(cuts.begin(), cuts.end());\\n        return solve(cuts, 0, cuts.size()-1);\\n    }\\n};\\n\\n```\\n\\nAdding the same explanation i have commented below for others also\\n\\n\\nFirst thing as we are doing it using recursion(DP) so we need to know what is the length at every recursive case.\\nBecause see, here every time we are partitioning a rod length, which is nothing but the differences between leftmost and rightmost indexes(or lengths).\\n\\nIn terms of Code:-\\nLet Rod length  =5\\nArray = 1, 3.\\nSo here by seeing the array you can\\'t tell the length of rod. (adding 0 and n, will help us in that - it is like an optimization as we don\\'t want to waste time and memory in maintaining that in a separate variable (as new dp state will be required).\\n\\nSo the array = [0, 1, 3, 5]\\nNo lets say, we decided to cut it at 3, then for the next recursive case the arrays will be [0, 1, 3] [3, 5]\\nAnd hence so on and so forth....\\n\\nI hope this will help in better understanding of the problem.\\n\\nPS :- Give a upvote if you liked the explanation.",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int dp[102][102];\\n    \\n    int solve(vector<int> &cuts, int low, int high) {\\n        if(low+1==high) return 0;\\n        else if(dp[low][high]!=-1)\\n            return dp[low][high];\\n        \\n        else {\\n            int ans = INT_MAX;\\n            for(int i=low+1; i<high; i++) {\\n                int curr = cuts[high]-cuts[low] + solve(cuts, low, i) + solve(cuts, i, high);\\n                ans = min(ans, curr);\\n            }\\n            return dp[low][high] = ans;\\n        }\\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        memset(dp, -1, sizeof(dp));\\n        sort(cuts.begin(), cuts.end());\\n        return solve(cuts, 0, cuts.size()-1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804270,
                "title": "o-n-2-dp-knuth-s-optimization",
                "content": "Reference: \\n1. https://wiki.algo.is/Knuth%27s%20optimization\\n2. http://maratona.ic.unicamp.br/MaratonaVerao2017/documents/dp.pdf\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n        int m = cuts.length + 2;\\n        int[] pos = new int[m];\\n        for (int i = 1; i < m - 1; ++i) pos[i] = cuts[i - 1];\\n        pos[m - 1] = n;\\n        int[][] dp = new int[m][m], mid = new int[m][m];\\n        for (int l = 0; l < m; ++l) {\\n            for (int i = 0; i + l < m; ++i) {\\n                int j = i + l;\\n                if (2 > l) {\\n                    mid[i][j] = i;\\n                    continue;\\n                }           \\n                dp[i][j] = pos[j] - pos[i];\\n                int min = Integer.MAX_VALUE;\\n                for (int k = mid[i][j - 1]; k <= mid[i + 1][j]; ++k) {\\n                    int next = dp[i][k] + dp[k][j];\\n                    if (next < min) {\\n                        min = next;\\n                        mid[i][j] = k;\\n                    }\\n                }\\n                dp[i][j] += min;\\n            }\\n        }\\n        return dp[0][m - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n        int m = cuts.length + 2;\\n        int[] pos = new int[m];\\n        for (int i = 1; i < m - 1; ++i) pos[i] = cuts[i - 1];\\n        pos[m - 1] = n;\\n        int[][] dp = new int[m][m], mid = new int[m][m];\\n        for (int l = 0; l < m; ++l) {\\n            for (int i = 0; i + l < m; ++i) {\\n                int j = i + l;\\n                if (2 > l) {\\n                    mid[i][j] = i;\\n                    continue;\\n                }           \\n                dp[i][j] = pos[j] - pos[i];\\n                int min = Integer.MAX_VALUE;\\n                for (int k = mid[i][j - 1]; k <= mid[i + 1][j]; ++k) {\\n                    int next = dp[i][k] + dp[k][j];\\n                    if (next < min) {\\n                        min = next;\\n                        mid[i][j] = k;\\n                    }\\n                }\\n                dp[i][j] += min;\\n            }\\n        }\\n        return dp[0][m - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 901997,
                "title": "c-dynamic-programming-intuitive-give-it-a-read",
                "content": "So the Question is asking all about to find the total minimum cost after cutting at all the given cut points on the Stick.\\n\\nA cost is basically the length of the stick at that time when you make a cut at a particular point.\\n\\nIf you look at the question So What you will try to think You will make the first cut at some place and then second and then third cut till all the cuts. Ordering does not matters when you are cutting at any point.\\n\\nBut Try to think it in the the opposite manner.\\nSuppose you  Cut your stick at all the cuts given to you.\\nNow what is left with you just some sticks of different lengths.\\n\\nNow Try to merge these sticks. Instead of cutting, start joinng at given cut points. But you can\\'t merge any two smaller sticks. When you are joining you have two merge so that you get the original stick. Means you cant join the stick in any order.\\n\\nSuppose your stick is like:    |---------|-----------|-----------|---------|          \\nall points in your sticks are  :[0 ,1 ,2 ,3, 4]\\ncut points =[2,3]\\n \\nwhen you cut at 2 and 3 your final sticks will be like:\\n[0,2] ;  [2,3]  ;  [3,4]\\n\\nSo What I was saying is like you cant merge [0,2] and [3,4] first and then merge it with [2,3].\\n\\nNow what you have wtih you is the sticks after you have applied all the cuts.\\nNow If you look at this properly You have to \\nFind the total minimum cost to merge all the sticks into a single stick. But at a time you can mege any two Adjacent Sticks.\\n\\nWhen You will merge you will then compute the cost by taking total length of both the sticks you are merging.\\n\\n\\nNow You have to Start finding the Solution using the answers of the Smaller Sub Problems.\\n\\nTry finding the answer for every i to j.\\n\\nOur dp[i][j] represents the total minimum cost after joining all the cut points between i to j because end points does not signify any thing.\\n\\nFor any rannge [i,j] valid cuts are only between i to j do not include i and j in your cuts.\\nJust At every cut in a range just start joining the sticks and start storing the answer between the range [i,j].\\n\\nHere We will fill our Dp in a diagonal Manner As the Subproblems are in the form of Ranges.\\n\\nIf you have not done this kind of questions before and dont know how it works I would recommed you to solve \\nLongest Palindromic Substring using Dp in a Bottom Up Manner.\\n\\n```\\nclass Solution\\n{  \\npublic:\\n\\n    int minCost(int n, vector<int>& cuts)\\n    {\\n        \\n     //inserting 0 and n as at end points cuts does not signify anything just to \\n     //get the length when we are merging.\\n     cuts.push_back(0); \\n     cuts.push_back(n);\\n        \\n     //sorting is for so that the you cut your stick in the order\\n     sort(cuts.begin(),cuts.end());\\n     \\n     //dp[i][j] stores the minimum cost  after joining at all the the cuts between i to j\\n     vector<vector<int> > dp(cuts.size(),vector<int> (cuts.size(),INT_MAX));\\n    \\n\\t// Your base cases stores the answer between [i.i]  and [i][i+1] subarrays or ranges, of size 2 only\\n     for(int i=0;i<dp.size();i++) dp[i][i]=0;  // base cases as for a point cost is Zero\\n     for(int i=0;i<dp.size()-1;i++)  dp[i][i+1]=0; //for every two points which constitue a stick is also zero\\n\\t \\n       \\n        \\n     for(int j=2;j<dp.size();j++)\\n     {\\n      for(int i=0;i<dp.size()-j;i++)   \\n      {\\n        int col=i+j; // your current column\\n        for(int k=i+1;k<col;k++) //cutting at every k between i to j\\n        {\\n         dp[i][col]=min(dp[i][col],dp[i][k]+dp[k][col]+(cuts[col]-cuts[i]));         //adding the final length after your merge            \\n        }\\n        }\\n     }\\n        \\n      \\n     return dp[0][dp.size()-1];   // final answer after joining all the sticks.\\n        \\n    }\\n    \\n\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution\\n{  \\npublic:\\n\\n    int minCost(int n, vector<int>& cuts)\\n    {\\n        \\n     //inserting 0 and n as at end points cuts does not signify anything just to \\n     //get the length when we are merging.\\n     cuts.push_back(0); \\n     cuts.push_back(n);\\n        \\n     //sorting is for so that the you cut your stick in the order\\n     sort(cuts.begin(),cuts.end());\\n     \\n     //dp[i][j] stores the minimum cost  after joining at all the the cuts between i to j\\n     vector<vector<int> > dp(cuts.size(),vector<int> (cuts.size(),INT_MAX));\\n    \\n\\t// Your base cases stores the answer between [i.i]  and [i][i+1] subarrays or ranges, of size 2 only\\n     for(int i=0;i<dp.size();i++) dp[i][i]=0;  // base cases as for a point cost is Zero\\n     for(int i=0;i<dp.size()-1;i++)  dp[i][i+1]=0; //for every two points which constitue a stick is also zero\\n\\t \\n       \\n        \\n     for(int j=2;j<dp.size();j++)\\n     {\\n      for(int i=0;i<dp.size()-j;i++)   \\n      {\\n        int col=i+j; // your current column\\n        for(int k=i+1;k<col;k++) //cutting at every k between i to j\\n        {\\n         dp[i][col]=min(dp[i][col],dp[i][k]+dp[k][col]+(cuts[col]-cuts[i]));         //adding the final length after your merge            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3569897,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. This is only for first 10,000 Subscribers.  **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n# or\\n\\n\\n# Click the Link in my Profile\\n\\n# Approach:\\n\\n- Sort the cuts in ascending order.\\n- Create a 2D array dp of size (m+2) x (m+2) (where m is the number of cuts) to store the minimum cost for each subinterval.\\n- Iterate over the lengths l from 2 to m+1.\\n- For each length l, iterate over the starting indices i from 0 to m+1-l.\\n- Calculate the ending index j as i + l.\\n- Initialize dp[i][j] with a maximum value.\\n- Iterate over the cutting points k from i+1 to j-1.\\n- Calculate the cost of cutting the interval [cuts[i-1], cuts[j-1]] at point cuts[k-1].\\n- Update dp[i][j] by taking the minimum between the current value and the cost of the new cut.\\n- Calculate the left and right lengths of the interval before and after the cuts using the indices i and j.\\n- Update dp[i][j] by adding the length of the interval [cuts[i-1], cuts[j-1]].\\n- Repeat steps 3-9 until all subintervals of different lengths are processed.\\n- Return dp[0][m+1] as the minimum cost to cut the stick.\\n# Intuition:\\nThe problem can be solved using dynamic programming. We want to find the minimum cost to cut the stick into smaller segments at the given cutting points. By considering subintervals of different lengths, we can break down the problem into smaller subproblems.\\n\\nWe use a bottom-up approach, starting from the smallest subintervals and gradually building up to the larger ones. We maintain a 2D array dp to store the minimum cost for each subinterval. The value at dp[i][j] represents the minimum cost to cut the interval [cuts[i-1], cuts[j-1]] into smaller segments.\\n\\nTo calculate the minimum cost for a subinterval, we iterate over all possible cutting points within that interval. For each cutting point, we calculate the cost of making the cut and update the minimum cost if necessary.\\n\\nWe also keep track of the lengths of the interval before and after the cut. By considering the left and right lengths, we can calculate the cost of cutting the stick at a particular point. We update the dp array by adding the cost of the cut and the lengths of the left and right segments.\\n\\nBy repeating this process for all subintervals of different lengths, we can determine the minimum cost to cut the stick. Finally, the value at dp[0][m+1] represents the minimum cost to cut the entire stick.\\n\\n```Python []\\nclass Solution:\\n    def minCost(self, n, cuts):\\n        cuts.append(0)\\n        cuts.append(n)\\n        cuts.sort()\\n        m = len(cuts)\\n        dp = [[0] * m for _ in range(m)]\\n\\n        for l in range(2, m):\\n            for i in range(m - l):\\n                j = i + l\\n                dp[i][j] = float(\\'inf\\')\\n                for k in range(i + 1, j):\\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i])\\n\\n        return dp[0][m - 1]\\n\\n```\\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n        int m = cuts.length;\\n        int[][] dp = new int[m + 2][m + 2];\\n\\n        for (int l = 2; l <= m + 1; l++) {\\n            for (int i = 0; i + l <= m + 1; i++) {\\n                int j = i + l;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = i + 1; k < j; k++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]);\\n                }\\n                int left = (i == 0) ? 0 : cuts[i - 1];\\n                int right = (j == m + 1) ? n : cuts[j - 1];\\n                dp[i][j] += right - left;\\n            }\\n        }\\n\\n        return dp[0][m + 1];\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minCost(int n, std::vector<int>& cuts) {\\n        std::sort(cuts.begin(), cuts.end());\\n        int m = cuts.size();\\n        std::vector<std::vector<int>> dp(m + 2, std::vector<int>(m + 2, 0));\\n\\n        for (int l = 2; l <= m + 1; l++) {\\n            for (int i = 0; i + l <= m + 1; i++) {\\n                int j = i + l;\\n                dp[i][j] = INT_MAX;\\n                for (int k = i + 1; k < j; k++) {\\n                    dp[i][j] = std::min(dp[i][j], dp[i][k] + dp[k][j]);\\n                }\\n                int left = (i == 0) ? 0 : cuts[i - 1];\\n                int right = (j == m + 1) ? n : cuts[j - 1];\\n                dp[i][j] += right - left;\\n            }\\n        }\\n\\n        return dp[0][m + 1];\\n    }\\n};\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```Python []\\nclass Solution:\\n    def minCost(self, n, cuts):\\n        cuts.append(0)\\n        cuts.append(n)\\n        cuts.sort()\\n        m = len(cuts)\\n        dp = [[0] * m for _ in range(m)]\\n\\n        for l in range(2, m):\\n            for i in range(m - l):\\n                j = i + l\\n                dp[i][j] = float(\\'inf\\')\\n                for k in range(i + 1, j):\\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i])\\n\\n        return dp[0][m - 1]\\n\\n```\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n        int m = cuts.length;\\n        int[][] dp = new int[m + 2][m + 2];\\n\\n        for (int l = 2; l <= m + 1; l++) {\\n            for (int i = 0; i + l <= m + 1; i++) {\\n                int j = i + l;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = i + 1; k < j; k++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]);\\n                }\\n                int left = (i == 0) ? 0 : cuts[i - 1];\\n                int right = (j == m + 1) ? n : cuts[j - 1];\\n                dp[i][j] += right - left;\\n            }\\n        }\\n\\n        return dp[0][m + 1];\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minCost(int n, std::vector<int>& cuts) {\\n        std::sort(cuts.begin(), cuts.end());\\n        int m = cuts.size();\\n        std::vector<std::vector<int>> dp(m + 2, std::vector<int>(m + 2, 0));\\n\\n        for (int l = 2; l <= m + 1; l++) {\\n            for (int i = 0; i + l <= m + 1; i++) {\\n                int j = i + l;\\n                dp[i][j] = INT_MAX;\\n                for (int k = i + 1; k < j; k++) {\\n                    dp[i][j] = std::min(dp[i][j], dp[i][k] + dp[k][j]);\\n                }\\n                int left = (i == 0) ? 0 : cuts[i - 1];\\n                int right = (j == m + 1) ? n : cuts[j - 1];\\n                dp[i][j] += right - left;\\n            }\\n        }\\n\\n        return dp[0][m + 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512842,
                "title": "c-recursion-memoization-tabulation-clean",
                "content": "# Method - 1 [Recusion]\\n![image](https://assets.leetcode.com/users/images/bde38519-fe5c-485d-bcf2-82961fda388f_1662017702.292224.png)\\n\\n**T->O(Expo) && S->O(n) [Recusion Stack Sapce]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int j,vector<int>& cuts){\\n\\t\\t\\tif(i>j) return 0;\\n\\t\\t\\tint mini=1e9;\\n\\t\\t\\tfor(int ind=i;ind<=j;ind++){\\n\\t\\t\\t\\tint cost= cuts[j+1]-cuts[i-1]+f(i,ind-1,cuts)+f(ind+1,j,cuts);\\n\\t\\t\\t\\tmini=min(mini,cost);\\n\\t\\t\\t}\\n\\t\\t\\treturn mini;\\n\\t\\t}\\n\\n\\t\\tint minCost(int n, vector<int>& cuts) {\\n\\t\\t\\tcuts.insert(cuts.begin(),0);\\n\\t\\t\\tcuts.insert(cuts.end(),n);\\n\\t\\t\\tsort(cuts.begin(),cuts.end());\\n\\t\\t\\treturn f(1,cuts.size()-2,cuts);\\n\\t\\t}\\n\\t};\\n\\n# Method -2  [Memoization]\\n![image](https://assets.leetcode.com/users/images/7af4e5fe-7edf-45a5-ac83-a4df62194dbb_1662017409.7729545.png)\\n\\n**T->O(m^3) && S->O(m^2) +O(n) [Recursion Stack Space]**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint f(int i,int j,vector<int>& cuts,vector<vector<int>>& dp){\\n\\t\\t\\t\\tif(i>j) return 0;\\n\\t\\t\\t\\tif(dp[i][j]!=-1) return dp[i][j];\\n\\t\\t\\t\\tint mini=1e9;\\n\\t\\t\\t\\tfor(int ind=i;ind<=j;ind++){\\n\\t\\t\\t\\t\\tint cost= cuts[j+1]-cuts[i-1]+f(i,ind-1,cuts,dp)+f(ind+1,j,cuts,dp);\\n\\t\\t\\t\\t\\tmini=min(mini,cost);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn dp[i][j]=mini;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint minCost(int n, vector<int>& cuts) {\\n\\t\\t\\t\\tcuts.insert(cuts.begin(),0);\\n\\t\\t\\t\\tcuts.insert(cuts.end(),n);\\n\\t\\t\\t\\tsort(cuts.begin(),cuts.end());\\n\\t\\t\\t\\tint m=cuts.size();\\n\\t\\t\\t\\tvector<vector<int>> dp(m+1,vector<int>(m+1,-1));\\n\\t\\t\\t\\treturn f(1,cuts.size()-2,cuts,dp);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\n# Method - 3 [Tabulation]\\t\\n![image](https://assets.leetcode.com/users/images/edab986a-2a1c-4044-a1d5-d3263becc9f0_1662018140.8394032.png)\\n\\n**T->O(m^3) && S->O(m^2)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minCost(int n, vector<int>& cuts) {\\n\\t\\t\\tcuts.insert(cuts.begin(),0);\\n\\t\\t\\tcuts.insert(cuts.end(),n);\\n\\t\\t\\tsort(cuts.begin(),cuts.end());\\n\\t\\t\\tint m=cuts.size();\\n\\t\\t\\tvector<vector<int>> dp(m,vector<int>(m,0));\\n\\t\\t\\tfor(int i=m-1;i>=1;i--){\\n\\t\\t\\t\\tfor(int j=i;j<=m-2;j++){\\n\\t\\t\\t\\t\\tint mini=1e9;\\n\\t\\t\\t\\t\\tfor(int ind=i;ind<=j;ind++){\\n\\t\\t\\t\\t\\t\\tint cost= cuts[j+1]-cuts[i-1]+dp[i][ind-1]+dp[ind+1][j];\\n\\t\\t\\t\\t\\t\\tmini=min(mini,cost);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdp[i][j]=mini;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[1][cuts.size()-2];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int j,vector<int>& cuts){\\n\\t\\t\\tif(i>j) return 0;\\n\\t\\t\\tint mini=1e9;\\n\\t\\t\\tfor(int ind=i;ind<=j;ind++){\\n\\t\\t\\t\\tint cost= cuts[j+1]-cuts[i-1]+f(i,ind-1,cuts)+f(ind+1,j,cuts);\\n\\t\\t\\t\\tmini=min(mini,cost);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 782813,
                "title": "java-top-down-dp",
                "content": "```\\nclass Solution {\\n    Integer[][] dp;\\n    int len, m;\\n    public int minCost(int n, int[] cuts) {\\n        len = n;\\n        m = cuts.length;\\n        Arrays.sort(cuts);\\n        dp = new Integer[m + 1][m + 1];\\n        return dfs(cuts, 0, m);  // whole stick; m means ending at the tail of stick; \\n    }\\n    \\n    private int dfs(int[] cuts, int l, int r) {\\n        if (dp[l][r] != null) return dp[l][r];\\n        if (l >= r) return 0;  // if not need to cut anymore;\\n        int cost = (r == m ? len : cuts[r]) - (l == 0 ? 0 : cuts[l - 1]);\\n        dp[l][r] = Integer.MAX_VALUE;\\n        for(int i = l; i < r; i++) {  // find the best cut, for each at cut point cuts[i];\\n            dp[l][r] = Math.min(dp[l][r], dfs(cuts, l, i) + dfs(cuts, i + 1, r) + cost);\\n        }\\n        return dp[l][r];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Integer[][] dp;\\n    int len, m;\\n    public int minCost(int n, int[] cuts) {\\n        len = n;\\n        m = cuts.length;\\n        Arrays.sort(cuts);\\n        dp = new Integer[m + 1][m + 1];\\n        return dfs(cuts, 0, m);  // whole stick; m means ending at the tail of stick; \\n    }\\n    \\n    private int dfs(int[] cuts, int l, int r) {\\n        if (dp[l][r] != null) return dp[l][r];\\n        if (l >= r) return 0;  // if not need to cut anymore;\\n        int cost = (r == m ? len : cuts[r]) - (l == 0 ? 0 : cuts[l - 1]);\\n        dp[l][r] = Integer.MAX_VALUE;\\n        for(int i = l; i < r; i++) {  // find the best cut, for each at cut point cuts[i];\\n            dp[l][r] = Math.min(dp[l][r], dfs(cuts, l, i) + dfs(cuts, i + 1, r) + cost);\\n        }\\n        return dp[l][r];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222820,
                "title": "c-dp-top-down-approach-idea-similar-to-mcm",
                "content": "the very first thing is to carefully notice the constraints as you need to create dp table with index related to these constrains\\n1. n is 10^6 ,it would be very huge to use for dp table so we wont use it\\n2. value of cuts vector , it is given that they could be at max n-1 ,that is also huge so we wont use them either.\\n3.it is given that the size of vector cuts is at max 100, this seems perfect  like a 100 x 100 table.\\n\\n**The idea i am going to discuss is very similar to Matrix Chain Multiplication problem**\\nconider the given test case\\n```\\nInput: n = 7, cuts = [1,3,4,5]\\nOutput: 16\\n```\\n\\n**note:** i am adding *\\'0\\' at the first* and *\\'n\\' at the last* of cuts vector and sort the vector\\n\\nindex:0 1 2 3 4 5 \\nvalue:0 1 3 4 5 7\\n\\nnow you have to call every partition so the call will be like\\n![image](https://assets.leetcode.com/users/images/1770cb9e-3b34-4043-bf1b-43dfccab87a9_1621662938.7142293.jpeg)\\n(startindex, endindex) ==> this represent stick between cuts[startindex] and cuts[endindex]\\nex:(2,4) == means==> stick starting at 3 and ending at 5\\n\\nnow since i have explained the notation **lets come to the base case**\\n```\\nif(endindex-startindex)==1 then return 0\\nthe idea is if the difference is 1 it means the stick is between the two consecutive cuts which means no more further cutting is possible so return 0\\n```\\n**that was all the major idea**\\nnow you have to try out every cut using the for loop and choose the minimum of all\\n```\\nclass Solution {\\npublic:\\n    \\n    /*time and space complexity\\n    n===>size of cuts array\\n    time:(n^2)\\n    if there are cuts at every unit distance then the depth of recursion is at max n\\n    and the every time n calls are called so (n*n)\\n    \\n    space:(n^2) //because we are maintaining a matrix of nxn\\n    */\\n    \\n     //taking size 103 instead of 100 because i have added two element of my own in the cuts array\\n    int dp[103][103];\\n    \\n    Solution()\\n    {\\n        //initializing dp table with -1\\n        memset(dp,-1,sizeof(dp));\\n    }\\n    \\n    \\n    //do not forget to pass vect as reference(&) if you remove this\\n    //it will result into tle\\n    int solve(int start,int end,vector<int> &vect)\\n    {\\n        // printf(\"%d %d\\\\n\",start,end);\\n        //base case\\n        if(end-start == 1)\\n            return 0;\\n        //if already know the ans return it\\n        if(dp[start][end]!=-1)\\n            return dp[start][end];\\n        \\n        //calculating length of the stick\\n        //it is the stick between two cuts: the starting and the ending cut\\n        int len = vect[end]-vect[start];\\n        int ans = INT_MAX;\\n        \\n        //traversing all the cuts\\n        //it starts from just next to start\\n        //because we cannot cut the cuts smaller than  the starting index\\n        for(int i=start+1;i<end;i++)\\n        {\\n            // recursively solving for  \\n            //left part   +   right part\\n            int temp = solve(start,i,vect) + solve(i,end,vect);\\n            \\n            //maintaining the minimum after every call\\n            ans = min(ans,temp);\\n        }\\n        \\n       return dp[start][end] = len+ans;\\n    }\\n    \\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        //sort the cuts\\n        sort(cuts.begin(),cuts.end());\\n        \\n        //creating new vector\\n        vector<int> vect;\\n        \\n        //pushing 0\\n        vect.push_back(0);\\n        //pushing the cuts vector\\n        for(int a:cuts)\\n        {\\n            vect.push_back(a);\\n        }\\n        //pushing n\\n        vect.push_back(n);\\n        \\n        \\n        return solve(0,vect.size()-1,vect);\\n        \\n        \\n        \\n    }\\n};\\n```\\nif i have made some mistake or some time complexity calculation is wrong do let me know in comments :)\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nInput: n = 7, cuts = [1,3,4,5]\\nOutput: 16\\n```\n```\\nif(endindex-startindex)==1 then return 0\\nthe idea is if the difference is 1 it means the stick is between the two consecutive cuts which means no more further cutting is possible so return 0\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    /*time and space complexity\\n    n===>size of cuts array\\n    time:(n^2)\\n    if there are cuts at every unit distance then the depth of recursion is at max n\\n    and the every time n calls are called so (n*n)\\n    \\n    space:(n^2) //because we are maintaining a matrix of nxn\\n    */\\n    \\n     //taking size 103 instead of 100 because i have added two element of my own in the cuts array\\n    int dp[103][103];\\n    \\n    Solution()\\n    {\\n        //initializing dp table with -1\\n        memset(dp,-1,sizeof(dp));\\n    }\\n    \\n    \\n    //do not forget to pass vect as reference(&) if you remove this\\n    //it will result into tle\\n    int solve(int start,int end,vector<int> &vect)\\n    {\\n        // printf(\"%d %d\\\\n\",start,end);\\n        //base case\\n        if(end-start == 1)\\n            return 0;\\n        //if already know the ans return it\\n        if(dp[start][end]!=-1)\\n            return dp[start][end];\\n        \\n        //calculating length of the stick\\n        //it is the stick between two cuts: the starting and the ending cut\\n        int len = vect[end]-vect[start];\\n        int ans = INT_MAX;\\n        \\n        //traversing all the cuts\\n        //it starts from just next to start\\n        //because we cannot cut the cuts smaller than  the starting index\\n        for(int i=start+1;i<end;i++)\\n        {\\n            // recursively solving for  \\n            //left part   +   right part\\n            int temp = solve(start,i,vect) + solve(i,end,vect);\\n            \\n            //maintaining the minimum after every call\\n            ans = min(ans,temp);\\n        }\\n        \\n       return dp[start][end] = len+ans;\\n    }\\n    \\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        //sort the cuts\\n        sort(cuts.begin(),cuts.end());\\n        \\n        //creating new vector\\n        vector<int> vect;\\n        \\n        //pushing 0\\n        vect.push_back(0);\\n        //pushing the cuts vector\\n        for(int a:cuts)\\n        {\\n            vect.push_back(a);\\n        }\\n        //pushing n\\n        vect.push_back(n);\\n        \\n        \\n        return solve(0,vect.size()-1,vect);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801510,
                "title": "python-thought-process-to-arrive-at-the-optimal-solution",
                "content": "First key insight is say we have a stick that starts at `piece_begin` and ends at `piece_end` and a set of cut locations, all of which are within `[piece_begin, piece_end]`. Then if we cut the piece at one of the cut location `loc` from the set, we will get two shorter pieces `[piece_begin, loc]` and `[loc, piece_end]`, *and* for the piece `[piece_begin, loc]`, we need to only consider cut locations < `loc`, for the piece `[loc, piece_end]`, we need to only consider cut locations > `loc`. But those are the same subproblems! With that intuition in mind, we can come up with a top-down recursive algorithm, albeit a bit clumsy, like so:\\n\\n```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        memo = {}\\n        def f(piece_begin, piece_end, c_i, c_j):\\n            if c_i > c_j or piece_begin + 1 >= piece_end:\\n                return 0\\n            if (piece_begin, piece_end, c_i, c_i) in memo:\\n                return memo[(piece_begin, piece_end, c_i, c_i)]\\n            \\n            min_cost = float(\\'inf\\')\\n            for k in range(c_i, c_j + 1):\\n                loc = cuts[k]\\n                cost = f(piece_begin, loc, c_i, k-1) + f(loc, piece_end, k+1, c_j) + (piece_end - piece_begin)\\n                min_cost = min(min_cost, cost)\\n            memo[(piece_begin, piece_end, c_i, c_i)] = min_cost\\n            return memo[(piece_begin, piece_end, c_i, c_i)]\\n                \\n        cuts.sort()\\n        return f(0, n, 0, len(cuts) - 1)\\n```\\n\\nNot fantastically satisfying, esp with 4 parameters we need to memoize over. Can we do something cleaner? Well, it would appear that `piece_begin` and `piece_end` is kind of redundant because technically, they are also \"cut locations\". It\\'s just they are at the extreme ends of the stick and it doesn\\'t make sense to cut at the two places. However if we simply include them into the cuts array and make sure we never cut at their locations, we can apply the same recursive approach as above, but with the parameters `piece_begin` and `piece_end` dropped. Notice the wonderful thing that happens when we don\\'t cut at the two extreme ends, we only need to range `k` over `[i + 1, j-1]` and cutting at `cuts[k]` results in two nice subproblems `f(i, k)` and `f(k, j)` where again `i`, `k` are extreme ends at which we won\\'t cut, and `k`, `j` at which we won\\'t cut.\\n\\n```\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        memo = {}\\n        def f(i, j):\\n            if i + 1 >= j:\\n                return 0\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            \\n            min_cost = float(\\'inf\\')\\n            for k in range(i + 1, j):\\n                cost = f(i, k) + f(k, j) + (cuts[j] - cuts[i])\\n                min_cost = min(min_cost, cost)\\n            memo[(i, j)] = min_cost\\n            return memo[(i, j)]\\n                \\n        cuts.sort()\\n        cuts = [0] + cuts + [n]\\n        return f(0, len(cuts) - 1)\\n```\\n\\nAnd finally convert mechanically into Dynamic Programming solution:\\n```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:        \\n        cuts.sort()\\n        cuts = [0] + cuts + [n]\\n        \\n        f = [None] * len(cuts)\\n        for i in range(len(f)):\\n            f[i] = [None] * len(cuts)\\n        \\n        for l in range(1, len(cuts) + 1):\\n            for i in range(len(cuts) - l + 1):\\n                j = i + l - 1\\n                if i + 1 >= j:\\n                    f[i][j] = 0\\n                    continue\\n                \\n                min_cost = float(\\'inf\\')\\n                for k in range(i + 1, j):\\n                    cost = f[i][k] + f[k][j] + cuts[j] - cuts[i]\\n                    min_cost = min(min_cost, cost)\\n                f[i][j] = min_cost\\n        \\n        return f[0][len(cuts)-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        memo = {}\\n        def f(piece_begin, piece_end, c_i, c_j):\\n            if c_i > c_j or piece_begin + 1 >= piece_end:\\n                return 0\\n            if (piece_begin, piece_end, c_i, c_i) in memo:\\n                return memo[(piece_begin, piece_end, c_i, c_i)]\\n            \\n            min_cost = float(\\'inf\\')\\n            for k in range(c_i, c_j + 1):\\n                loc = cuts[k]\\n                cost = f(piece_begin, loc, c_i, k-1) + f(loc, piece_end, k+1, c_j) + (piece_end - piece_begin)\\n                min_cost = min(min_cost, cost)\\n            memo[(piece_begin, piece_end, c_i, c_i)] = min_cost\\n            return memo[(piece_begin, piece_end, c_i, c_i)]\\n                \\n        cuts.sort()\\n        return f(0, n, 0, len(cuts) - 1)\\n```\n```\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        memo = {}\\n        def f(i, j):\\n            if i + 1 >= j:\\n                return 0\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            \\n            min_cost = float(\\'inf\\')\\n            for k in range(i + 1, j):\\n                cost = f(i, k) + f(k, j) + (cuts[j] - cuts[i])\\n                min_cost = min(min_cost, cost)\\n            memo[(i, j)] = min_cost\\n            return memo[(i, j)]\\n                \\n        cuts.sort()\\n        cuts = [0] + cuts + [n]\\n        return f(0, len(cuts) - 1)\\n```\n```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:        \\n        cuts.sort()\\n        cuts = [0] + cuts + [n]\\n        \\n        f = [None] * len(cuts)\\n        for i in range(len(f)):\\n            f[i] = [None] * len(cuts)\\n        \\n        for l in range(1, len(cuts) + 1):\\n            for i in range(len(cuts) - l + 1):\\n                j = i + l - 1\\n                if i + 1 >= j:\\n                    f[i][j] = 0\\n                    continue\\n                \\n                min_cost = float(\\'inf\\')\\n                for k in range(i + 1, j):\\n                    cost = f[i][k] + f[k][j] + cuts[j] - cuts[i]\\n                    min_cost = min(min_cost, cost)\\n                f[i][j] = min_cost\\n        \\n        return f[0][len(cuts)-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780889,
                "title": "python-dynamic-programming-o-cuts-length-3",
                "content": "Very similar to [312. Burst Balloons](https://leetcode.com/problems/burst-balloons/).\\n\\nCost of each cut is determined by the closest left and right cut that is done before it. In a given range, the cost of the first cut is certain ---- the length of this range.\\n\\nDefine `dp[i][j]` as the minimum cost of finishing all the cuts between `i`th and `j`th cut exclusively, **while `i`th and `j`th cut is already done**. Then we just loop through each cut as the first cut and find the minimum cost.\\n\\nHere is my python code:\\n```\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.extend([0, n])  # add 2 fake cuts as the boundary of the first cut\\n        cuts.sort()\\n        @functools.lru_cache(None)\\n        def f(i, j):\\n            if i + 1 >= j: return 0\\n            return cuts[j] - cuts[i]  # cost of the first cut between ith and jth cut\\n                + min((f(i, k) + f(k, j) for k in range(i+1, j)), default=0)  # go through all the cuts as the first cut\\n        return f(0, len(cuts)-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.extend([0, n])  # add 2 fake cuts as the boundary of the first cut\\n        cuts.sort()\\n        @functools.lru_cache(None)\\n        def f(i, j):\\n            if i + 1 >= j: return 0\\n            return cuts[j] - cuts[i]  # cost of the first cut between ith and jth cut\\n                + min((f(i, k) + f(k, j) for k in range(i+1, j)), default=0)  # go through all the cuts as the first cut\\n        return f(0, len(cuts)-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3570166,
                "title": "dp-explained",
                "content": "Let $$dp[i][j]$$ be the minimum total cost between cut position $$i$$and $$j$$. First let\\'s add $$0$$ and $$n$$ to the input for further calculation. Then we sort the input in ascending order. We can perform a dfs function $$dfs(cuts, 0, (int) cuts.size() - 1)$$ to get the answer.\\n\\nLet\\'s think of the base case first. Since the minimum length of a rod is $$1$$, we reach the destination when $$j - i <= 1$$ because we cannot make further cuts anymore. If $$dp[i][j]$$ has been calculated before, we can return it immediately.\\n\\nOtherwise, we iterate each position$$k$$ and perform each possible cut. We know that the cost is the length of the rod to be cut, i.e. $$cuts[j]  - cuts[i]$$. In example 1, the first cut costs 7. Since we have added $$0$$ and $$n$$to the input, so we have covered that. Once we cut at a certain point, the rod will be split into two parts. We perform the logic to calculate the costs for these two parts until we perform all the cuts\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // memoization\\n    int dp[105][105];\\n    int dfs(vector<int>& cuts, int i, int j) {\\n        // the smallest rod has length of 1\\n        if (j - i <= 1) return 0;\\n        // if the cost is calculated before, return immediately\\n        if (dp[i][j] != -1) return dp[i][j];\\n        // we initialise a large number since we are looking for the minimum number\\n        int ans = 1e9;\\n        //\\n        for (int k = i + 1; k < j; k++) {\\n            // if this rod is to be cut, the cost is the length, \\n            // i.e. cuts[j] - cuts[i]\\n            // after the cut, it will be split into two parts\\n            // then we calculate the cost for left rod : dfs(cuts, i, k) \\n            // and the cost for the right rod: dfs(cuts, k, j)\\n            ans = min(ans, cuts[j] - cuts[i] + dfs(cuts, i, k) + dfs(cuts, k, j));\\n        }\\n        // memoize the ans \\n        return dp[i][j] = ans;\\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(), cuts.end());\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(cuts, 0, (int) cuts.size() - 1);\\n    }\\n};\\n```\\n\\n**p.s. Join us on the LeetCode The Hard Way Discord Study Group for timely discussion! Link in bio.**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // memoization\\n    int dp[105][105];\\n    int dfs(vector<int>& cuts, int i, int j) {\\n        // the smallest rod has length of 1\\n        if (j - i <= 1) return 0;\\n        // if the cost is calculated before, return immediately\\n        if (dp[i][j] != -1) return dp[i][j];\\n        // we initialise a large number since we are looking for the minimum number\\n        int ans = 1e9;\\n        //\\n        for (int k = i + 1; k < j; k++) {\\n            // if this rod is to be cut, the cost is the length, \\n            // i.e. cuts[j] - cuts[i]\\n            // after the cut, it will be split into two parts\\n            // then we calculate the cost for left rod : dfs(cuts, i, k) \\n            // and the cost for the right rod: dfs(cuts, k, j)\\n            ans = min(ans, cuts[j] - cuts[i] + dfs(cuts, i, k) + dfs(cuts, k, j));\\n        }\\n        // memoize the ans \\n        return dp[i][j] = ans;\\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(), cuts.end());\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(cuts, 0, (int) cuts.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611552,
                "title": "c-clean-code-dp",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> dp;\\n    int recursion(int l, int r, int left, int right, vector<int> &cuts)\\n    {\\n        if (r < l) return 0;\\n        if (dp[l][r] != -1) return dp[l][r];\\n\\n        int answer = INT_MAX;\\n        for (int i = l; i <= r; i++)\\n        {\\n            int length = (right - left) ;\\n            int current = length + recursion(l, i - 1, left, cuts[i], cuts) + recursion(i + 1, r, cuts[i], right, cuts);\\n            answer = min(answer, current);\\n        }\\n\\n        return dp[l][r] = answer;\\n    }\\n    int minCost(int n, vector<int> &cuts)\\n    {\\n        dp = vector<vector<int>>(cuts.size() + 4, vector<int>(cuts.size() + 2, -1));\\n        sort(cuts.begin(), cuts.end());\\n        return recursion(0, cuts.size() - 1, 0, n, cuts);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> dp;\\n    int recursion(int l, int r, int left, int right, vector<int> &cuts)\\n    {\\n        if (r < l) return 0;\\n        if (dp[l][r] != -1) return dp[l][r];\\n\\n        int answer = INT_MAX;\\n        for (int i = l; i <= r; i++)\\n        {\\n            int length = (right - left) ;\\n            int current = length + recursion(l, i - 1, left, cuts[i], cuts) + recursion(i + 1, r, cuts[i], right, cuts);\\n            answer = min(answer, current);\\n        }\\n\\n        return dp[l][r] = answer;\\n    }\\n    int minCost(int n, vector<int> &cuts)\\n    {\\n        dp = vector<vector<int>>(cuts.size() + 4, vector<int>(cuts.size() + 2, -1));\\n        sort(cuts.begin(), cuts.end());\\n        return recursion(0, cuts.size() - 1, 0, n, cuts);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101165,
                "title": "recursion-memoization-bottom-up-dp-table",
                "content": "All the differnet approches from **brute** to **optimal** are discussed. Please **upvote** if you find this useful.\\n\\n### Recursion:\\n\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int temp[] = new int[cuts.length+2];\\n        temp[0] = 0;\\n        \\n        for(int i = 1; i< temp.length-1; i++){\\n            temp[i] = cuts[i-1];\\n        }\\n        \\n        temp[temp.length-1] = n;\\n        Arrays.sort(temp);\\n        \\n        int dp[][] = new int[temp.length+1][temp.length+1];\\n        \\n        for(int a[]: dp)\\n            Arrays.fill(a, -1);\\n        \\n        return func(1, cuts.length, temp, dp);\\n    }\\n\\t\\n    int func(int i, int j, int[] temp, int[][] dp){\\n        if(i > j)\\n            return 0;\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int ind = i; ind <= j; ind++){\\n            int cost = temp[j+1] - temp[i-1] + func(i, ind-1, temp, dp) + func(ind+1, j, temp, dp);\\n            min = Math.min(min, cost);\\n        }\\n        return  min;\\n    }\\n}\\n```\\n\\n**Exponential Time complexity.**\\n\\n### Memoization:\\n\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int temp[] = new int[cuts.length+2];\\n        temp[0] = 0;\\n        \\n        for(int i = 1; i< temp.length-1; i++){\\n            temp[i] = cuts[i-1];\\n        }\\n        \\n        temp[temp.length-1] = n;\\n        Arrays.sort(temp);\\n        \\n        int dp[][] = new int[temp.length+1][temp.length+1];\\n        \\n        for(int a[]: dp)\\n            Arrays.fill(a, -1);\\n        \\n        return func(1, cuts.length, temp, dp);\\n    }\\n    int func(int i, int j, int[] temp, int[][] dp){\\n        if(i > j)\\n            return 0;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int ind = i; ind <= j; ind++){\\n            int cost = temp[j+1] - temp[i-1] + func(i, ind-1, temp, dp) + func(ind+1, j, temp, dp);\\n            min = Math.min(min, cost);\\n        }\\n        return dp[i][j] = min;\\n    }\\n}\\n```\\n\\n### Bottom up DP Table:\\n\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int temp[] = new int[cuts.length+2];\\n        temp[0] = 0;\\n        \\n        for(int i = 1; i< temp.length-1; i++){\\n            temp[i] = cuts[i-1];\\n        }\\n        \\n        temp[temp.length-1] = n;\\n        Arrays.sort(temp);\\n        \\n        int dp[][] = new int[temp.length+2][temp.length+2];\\n        \\n        for(int a[]: dp)\\n            Arrays.fill(a, 0);\\n        \\n        for(int i = cuts.length; i >= 1; i--){\\n            for(int j = 1; j <= cuts.length; j++){\\n                if(i > j)\\n                    continue;\\n                int minCost = Integer.MAX_VALUE;\\n                for(int ind = i; ind <= j; ind++){\\n                    int cost = temp[j+1] - temp[i-1] + dp[i][ind-1] + dp[ind+1][j];\\n                    minCost = Math.min(cost, minCost);\\n                }\\n                dp[i][j] = minCost;\\n            }\\n        }\\n        \\n        return dp[1][cuts.length];\\n    }\\n}\\n```\\n\\nTime Complexity: O(N^3)\\nSpace Complexity: O(N^2)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int temp[] = new int[cuts.length+2];\\n        temp[0] = 0;\\n        \\n        for(int i = 1; i< temp.length-1; i++){\\n            temp[i] = cuts[i-1];\\n        }\\n        \\n        temp[temp.length-1] = n;\\n        Arrays.sort(temp);\\n        \\n        int dp[][] = new int[temp.length+1][temp.length+1];\\n        \\n        for(int a[]: dp)\\n            Arrays.fill(a, -1);\\n        \\n        return func(1, cuts.length, temp, dp);\\n    }\\n\\t\\n    int func(int i, int j, int[] temp, int[][] dp){\\n        if(i > j)\\n            return 0;\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int ind = i; ind <= j; ind++){\\n            int cost = temp[j+1] - temp[i-1] + func(i, ind-1, temp, dp) + func(ind+1, j, temp, dp);\\n            min = Math.min(min, cost);\\n        }\\n        return  min;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int temp[] = new int[cuts.length+2];\\n        temp[0] = 0;\\n        \\n        for(int i = 1; i< temp.length-1; i++){\\n            temp[i] = cuts[i-1];\\n        }\\n        \\n        temp[temp.length-1] = n;\\n        Arrays.sort(temp);\\n        \\n        int dp[][] = new int[temp.length+1][temp.length+1];\\n        \\n        for(int a[]: dp)\\n            Arrays.fill(a, -1);\\n        \\n        return func(1, cuts.length, temp, dp);\\n    }\\n    int func(int i, int j, int[] temp, int[][] dp){\\n        if(i > j)\\n            return 0;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int ind = i; ind <= j; ind++){\\n            int cost = temp[j+1] - temp[i-1] + func(i, ind-1, temp, dp) + func(ind+1, j, temp, dp);\\n            min = Math.min(min, cost);\\n        }\\n        return dp[i][j] = min;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int temp[] = new int[cuts.length+2];\\n        temp[0] = 0;\\n        \\n        for(int i = 1; i< temp.length-1; i++){\\n            temp[i] = cuts[i-1];\\n        }\\n        \\n        temp[temp.length-1] = n;\\n        Arrays.sort(temp);\\n        \\n        int dp[][] = new int[temp.length+2][temp.length+2];\\n        \\n        for(int a[]: dp)\\n            Arrays.fill(a, 0);\\n        \\n        for(int i = cuts.length; i >= 1; i--){\\n            for(int j = 1; j <= cuts.length; j++){\\n                if(i > j)\\n                    continue;\\n                int minCost = Integer.MAX_VALUE;\\n                for(int ind = i; ind <= j; ind++){\\n                    int cost = temp[j+1] - temp[i-1] + dp[i][ind-1] + dp[ind+1][j];\\n                    minCost = Math.min(cost, minCost);\\n                }\\n                dp[i][j] = minCost;\\n            }\\n        }\\n        \\n        return dp[1][cuts.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781182,
                "title": "confusing-setense",
                "content": "am I the only one being confused by:\\n```\\nYou should perform the cuts in order, you can change the order of the cuts as you wish.\\n```\\n??\\n\\n```in order``` vs ```change the order``` seems conflicting to me.\\n\\n",
                "solutionTags": [],
                "code": "```\\nYou should perform the cuts in order, you can change the order of the cuts as you wish.\\n```\n```in order```\n```change the order```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570554,
                "title": "c-dp-recursion-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int c(int i,int j,vector<int>&cuts,vector<vector<int>>&dp){\\n        if(i>j)return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int k=i;k<=j;k++){\\n            int h=cuts[j+1]-cuts[i-1]+c(i,k-1,cuts,dp)+c(k+1,j,cuts,dp);\\n            ans=min(ans,h);\\n        }\\n         return dp[i][j]=ans;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        sort(cuts.begin(),cuts.end());\\n        vector<vector<int>>dp(cuts.size(),vector<int>(cuts.size(),-1));\\n        return c(1,cuts.size()-2,cuts,dp);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/d0ba7010-e614-487f-a2db-ebc1af816e7b_1685249787.1818378.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int c(int i,int j,vector<int>&cuts,vector<vector<int>>&dp){\\n        if(i>j)return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int k=i;k<=j;k++){\\n            int h=cuts[j+1]-cuts[i-1]+c(i,k-1,cuts,dp)+c(k+1,j,cuts,dp);\\n            ans=min(ans,h);\\n        }\\n         return dp[i][j]=ans;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        sort(cuts.begin(),cuts.end());\\n        vector<vector<int>>dp(cuts.size(),vector<int>(cuts.size(),-1));\\n        return c(1,cuts.size()-2,cuts,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742309,
                "title": "easy-solution-by-striver-a-lot-of-mistake-were-done-while-coding-this-problem-c",
                "content": "```\\n// Minimum Cost to Cut a Stick\\n    // brute\\n        class Solution {\\n        public:\\n            int pre(int i,int j,vector<int>& cuts){\\n                if(i > j) return 0;\\n                long mini = 1e9;\\n                for(int ind=i;ind<=j;ind++){\\n                    long cost = cuts[j+1] - cuts[i-1] + pre(i,ind-1,cuts) + pre(ind+1,j,cuts);\\n                    mini = min(mini,cost);\\n                }\\n                return mini;\\n            }\\n            int minCost(int n, vector<int>& cuts) {\\n                cuts.insert(cuts.begin(),0);\\n                cuts.push_back(n);\\n                sort(cuts.begin(),cuts.end());\\n                return pre(1,cuts.size()-2,cuts);\\n            }\\n        };\\n\\n    // memo\\n        class Solution {\\n        public:\\n            int pre(int i,int j,vector<int>& cuts,vector<vector<int>> & dp){\\n                if(i > j) return 0;\\n                if(dp[i][j] != -1) return dp[i][j];\\n                long mini = 1e9;\\n                for(int ind=i;ind<=j;ind++){\\n                    long cost = cuts[j+1] - cuts[i-1] + pre(i,ind-1,cuts,dp) + pre(ind+1,j,cuts,dp);\\n                    mini = min(mini,cost);\\n                }\\n                return dp[i][j] = mini;\\n            }\\n            int minCost(int n, vector<int>& cuts) {\\n                int c = cuts.size();\\n                // cuts size missing  \\u2B50\\n                cuts.insert(cuts.begin(),0);\\n                cuts.push_back(n);\\n                sort(cuts.begin(),cuts.end());\\n                \\n                // vector<vector<int>> dp(n+4,vector<int> (n+4,-1)); \\u2B50\\n                vector<vector<int>> dp(c+1,vector<int> (c+1,-1));\\n                // return pre(1,cuts.size()-2,cuts,dp); \\u2B50    \\n                return pre(1,c,cuts,dp);\\n            }\\n        };\\n    \\n    // tab\\n        class Solution {\\n        public:\\n            int minCost(int n, vector<int>& cuts) {\\n                int c = cuts.size();\\n                cuts.insert(cuts.begin(),0);\\n                cuts.push_back(n);\\n                sort(cuts.begin(),cuts.end());\\n\\n                vector<vector<int>> dp(c+3,vector<int> (c+3,0)); // wrong declare with dp[c + 1][c + 1] \\u2B50\\n                \\n                for(int i=c;i>=1;i--){ // i was putting min a 1 \\u2B50\\n                    for(int j=1;j<=c;j++){ // i was starting from 1 \\u2B50\\n                        if(i > j) continue;\\n                        long mini = 1e9;\\n                        for(int ind=i;ind<=j;ind++){\\n                            long cost = cuts[j+1] - cuts[i-1] + dp[i][ind-1] + dp[ind+1][j];\\n                            mini = min(mini,cost);\\n                        }\\n                        dp[i][j] = mini;\\n                    }\\n                }\\n                return dp[1][c];\\n            }\\n        };\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Minimum Cost to Cut a Stick\\n    // brute\\n        class Solution {\\n        public:\\n            int pre(int i,int j,vector<int>& cuts){\\n                if(i > j) return 0;\\n                long mini = 1e9;\\n                for(int ind=i;ind<=j;ind++){\\n                    long cost = cuts[j+1] - cuts[i-1] + pre(i,ind-1,cuts) + pre(ind+1,j,cuts);\\n                    mini = min(mini,cost);\\n                }\\n                return mini;\\n            }\\n            int minCost(int n, vector<int>& cuts) {\\n                cuts.insert(cuts.begin(),0);\\n                cuts.push_back(n);\\n                sort(cuts.begin(),cuts.end());\\n                return pre(1,cuts.size()-2,cuts);\\n            }\\n        };\\n\\n    // memo\\n        class Solution {\\n        public:\\n            int pre(int i,int j,vector<int>& cuts,vector<vector<int>> & dp){\\n                if(i > j) return 0;\\n                if(dp[i][j] != -1) return dp[i][j];\\n                long mini = 1e9;\\n                for(int ind=i;ind<=j;ind++){\\n                    long cost = cuts[j+1] - cuts[i-1] + pre(i,ind-1,cuts,dp) + pre(ind+1,j,cuts,dp);\\n                    mini = min(mini,cost);\\n                }\\n                return dp[i][j] = mini;\\n            }\\n            int minCost(int n, vector<int>& cuts) {\\n                int c = cuts.size();\\n                // cuts size missing  \\u2B50\\n                cuts.insert(cuts.begin(),0);\\n                cuts.push_back(n);\\n                sort(cuts.begin(),cuts.end());\\n                \\n                // vector<vector<int>> dp(n+4,vector<int> (n+4,-1)); \\u2B50\\n                vector<vector<int>> dp(c+1,vector<int> (c+1,-1));\\n                // return pre(1,cuts.size()-2,cuts,dp); \\u2B50    \\n                return pre(1,c,cuts,dp);\\n            }\\n        };\\n    \\n    // tab\\n        class Solution {\\n        public:\\n            int minCost(int n, vector<int>& cuts) {\\n                int c = cuts.size();\\n                cuts.insert(cuts.begin(),0);\\n                cuts.push_back(n);\\n                sort(cuts.begin(),cuts.end());\\n\\n                vector<vector<int>> dp(c+3,vector<int> (c+3,0)); // wrong declare with dp[c + 1][c + 1] \\u2B50\\n                \\n                for(int i=c;i>=1;i--){ // i was putting min a 1 \\u2B50\\n                    for(int j=1;j<=c;j++){ // i was starting from 1 \\u2B50\\n                        if(i > j) continue;\\n                        long mini = 1e9;\\n                        for(int ind=i;ind<=j;ind++){\\n                            long cost = cuts[j+1] - cuts[i-1] + dp[i][ind-1] + dp[ind+1][j];\\n                            mini = min(mini,cost);\\n                        }\\n                        dp[i][j] = mini;\\n                    }\\n                }\\n                return dp[1][c];\\n            }\\n        };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891338,
                "title": "well-explained-code-minimum-cost-to-cut-a-stick-memoization",
                "content": "First of all, because we need to solve for all possibilities of order, ie., the most optimal, the order in which we explore those cuts won\\'t matter at all. \\nAnd in situations wherein order of the input doesn\\'t matter, the strategy used is to first sort the input in ascending or descending order depending on the particular use case that we are looking for. In this case, I have sorted in ascending order.\\n\\nNow, beware, there are two different things in this problem. \\n\\nThe *first one* is the ***cuts array*** which tells us **the places where we need to do the respective cuts** and, *the second* is the ***entire rod*** on which **the cut operations would be performed**.\\n\\nThe value ***n*** is the length of the rod and ***NOT*** the length of the ***cuts*** array. \\nThis mere observation that I overlooked took me a lot of time to figure out the problem properly.\\n\\n*Rest is pretty easy.*\\n\\n```\\nfor(int i=idx; i<=jdx; i++){\\n            int left = fun(cuts, idx,i-1, l, cuts[i],dp) ;\\n            int right = fun(cuts, i+1,jdx, cuts[i],r,dp);\\n            ans = min(ans,r-l+left+right);\\n        }\\n```\\nSo, the above snippet is the main gist of the entire code. \\nFirst, let\\'s clarify the variables in the **fun** function.\\n\\n* idx is the left index that we need to deal with in the cuts array\\n* jdx is the right index that we need to deal with in the cuts array.\\n* l and r are left end and the right ends of the rods at any given recursive call\\n\\nSimply iterating over the cuts array and making cuts at every instance and correspondingly changing the end position of the cut portion that we have to do depending on the values passed over by previous recursive calls.\\n\\nFor left call at a particular cut ***i***, we need to start the left portion from the ***idx*** (the corresponding beginning part of that cut in that recursive call) to ***i-1*** which is just before the cut. This handles the **cuts** array, \\n\\nTo handle the rod, we need to specify just the remaining part of the array where the starting and ending point of the rod must be.\\n\\nSimilarly for the right part.\\nAnd we need to simply add values we obtain from right and left recursion calls and add the corresponding rod length for that recursive call ie., l-r.\\n\\nThat\\'s it.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<int> &cuts, int idx, int jdx, int l, int r,vector<vector<int>>&dp){\\n        if(idx<0 || jdx>=cuts.size()||idx>jdx){\\n            return 0;\\n        }\\n        if(idx==jdx){\\n            return r-l;\\n        }\\n        if(dp[idx][jdx]!=-1){\\n            return dp[idx][jdx];\\n        }\\n        int ans = 1e9;\\n        for(int i=idx; i<=jdx; i++){\\n            int left = fun(cuts, idx,i-1, l, cuts[i],dp) ;\\n            int right = fun(cuts, i+1,jdx, cuts[i],r,dp);\\n            ans = min(ans,r-l+left+right);\\n        }\\n        return dp[idx][jdx] = ans;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(),cuts.end());\\n        int x = cuts.size();\\n        vector<vector<int>> dp(x,vector<int>(x,-1));\\n        return fun(cuts,0,cuts.size()-1,0,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nfor(int i=idx; i<=jdx; i++){\\n            int left = fun(cuts, idx,i-1, l, cuts[i],dp) ;\\n            int right = fun(cuts, i+1,jdx, cuts[i],r,dp);\\n            ans = min(ans,r-l+left+right);\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n    int fun(vector<int> &cuts, int idx, int jdx, int l, int r,vector<vector<int>>&dp){\\n        if(idx<0 || jdx>=cuts.size()||idx>jdx){\\n            return 0;\\n        }\\n        if(idx==jdx){\\n            return r-l;\\n        }\\n        if(dp[idx][jdx]!=-1){\\n            return dp[idx][jdx];\\n        }\\n        int ans = 1e9;\\n        for(int i=idx; i<=jdx; i++){\\n            int left = fun(cuts, idx,i-1, l, cuts[i],dp) ;\\n            int right = fun(cuts, i+1,jdx, cuts[i],r,dp);\\n            ans = min(ans,r-l+left+right);\\n        }\\n        return dp[idx][jdx] = ans;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(),cuts.end());\\n        int x = cuts.size();\\n        vector<vector<int>> dp(x,vector<int>(x,-1));\\n        return fun(cuts,0,cuts.size()-1,0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781085,
                "title": "python3-top-down-bottom-up-dp",
                "content": "Define `fn(lo, hi)` as the min cost of cutting `lo` to `hi` (both inclusive). Then, \\n1) if there is not cut between `lo` and `hi`, return 0; \\n2) if there are cuts, return the one with the minimum cost, i.e. `fn(lo, hi) = hi - lo + min(fn(lo, mid) + fn(mid, hi))` where `mid` is a plausible cut. \\n\\n```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def fn(lo, hi): \\n            \"\"\"Return cost of cutting [lo, hi].\"\"\"\\n            cc = [c for c in cuts if lo < c < hi] #collect cuts within this region \\n            if not cc: return 0\\n            ans = inf\\n            for mid in cc: ans = min(ans, fn(lo, mid) + fn(mid, hi))\\n            return ans + hi - lo\\n        \\n        return fn(0, n)\\n```\\n\\nEdit: \\nA more efficient implementation is to index `cuts` like below\\n```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.extend([0, n])\\n        cuts.sort()\\n        \\n        @lru_cache(None)\\n        def fn(i, j): \\n            \"\"\"Return cost of cutting from cuts[i] to cuts[j].\"\"\"\\n            if i+1 == j: return 0 #no cut in (i, j)\\n            return cuts[j] - cuts[i] + min(fn(i, k) + fn(k, j) for k in range(i+1, j))\\n        \\n        return fn(0, len(cuts)-1)\\n```\\n\\nbottom-up implementation (476ms, 99.62%)\\n```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.extend([0, n])\\n        cuts.sort()\\n        \\n        dp = [[0]*len(cuts) for _ in cuts] \\n        for i in reversed(range(len(cuts))):\\n            for j in range(i+2, len(cuts)): \\n                dp[i][j] = cuts[j] - cuts[i] + min(dp[i][k] + dp[k][j] for k in range(i+1, j))\\n        return dp[0][-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def fn(lo, hi): \\n            \"\"\"Return cost of cutting [lo, hi].\"\"\"\\n            cc = [c for c in cuts if lo < c < hi] #collect cuts within this region \\n            if not cc: return 0\\n            ans = inf\\n            for mid in cc: ans = min(ans, fn(lo, mid) + fn(mid, hi))\\n            return ans + hi - lo\\n        \\n        return fn(0, n)\\n```\n```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.extend([0, n])\\n        cuts.sort()\\n        \\n        @lru_cache(None)\\n        def fn(i, j): \\n            \"\"\"Return cost of cutting from cuts[i] to cuts[j].\"\"\"\\n            if i+1 == j: return 0 #no cut in (i, j)\\n            return cuts[j] - cuts[i] + min(fn(i, k) + fn(k, j) for k in range(i+1, j))\\n        \\n        return fn(0, len(cuts)-1)\\n```\n```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.extend([0, n])\\n        cuts.sort()\\n        \\n        dp = [[0]*len(cuts) for _ in cuts] \\n        for i in reversed(range(len(cuts))):\\n            for j in range(i+2, len(cuts)): \\n                dp[i][j] = cuts[j] - cuts[i] + min(dp[i][k] + dp[k][j] for k in range(i+1, j))\\n        return dp[0][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724057,
                "title": "c-recursive-memoization-dp-variation-of-mcm",
                "content": "**Time:** ***O(n\\\\*n)*** where `n = size of cuts array`\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(vector<int>& cuts, int l, int r, int ci, int cj){\\n        if(ci>cj) return 0;\\n        if(dp[ci][cj]!=-1) return dp[ci][cj];\\n        int cost = 1e7;\\n        for(int k=ci; k<=cj; ++k){\\n            cost = min(cost, solve(cuts,l,cuts[k],ci,k-1)+solve(cuts,cuts[k],r,k+1,cj));\\n        }\\n        return dp[ci][cj] = cost+r-l;\\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(cuts.begin(),cuts.end());\\n        int ci=0, cj=cuts.size()-1;\\n        return solve(cuts,0,n,ci,cj);\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(vector<int>& cuts, int l, int r, int ci, int cj){\\n        if(ci>cj) return 0;\\n        if(dp[ci][cj]!=-1) return dp[ci][cj];\\n        int cost = 1e7;\\n        for(int k=ci; k<=cj; ++k){\\n            cost = min(cost, solve(cuts,l,cuts[k],ci,k-1)+solve(cuts,cuts[k],r,k+1,cj));\\n        }\\n        return dp[ci][cj] = cost+r-l;\\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(cuts.begin(),cuts.end());\\n        int ci=0, cj=cuts.size()-1;\\n        return solve(cuts,0,n,ci,cj);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111111,
                "title": "python-knuth-optimization-o-n-beat-99",
                "content": "\\n```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        #O(len(cuts)\\xB2) algorithm with Knuth Optimization\\n        cuts.append(0)\\n        cuts.append(n)\\n        cuts.sort()\\n        DP = [[10**10 for _ in range(len(cuts))] for _ in range(len(cuts))]\\n        KNUTH = [[None for _ in range(len(cuts))] for _ in range(len(cuts))]\\n        \\n        # The idea is that sometimes you can optimize a dynamic programming solution of the form DP[i][j] = min(DP[i][k]+DP[k][j]) with  i < k < j\\n        # More precisely, if the property KNUTH[i][j-1] <= KNUTH[i][j] <= KNUTH[i+1][j]  is true\\n        # Then we can reduce the interval of possible k we need to check to  KNUTH[i][j-1] <= k <= KNUTH[i+1][j]\\n        # Where KNUTH[i][j] corresponds to the index k*, the optimal choice for DP[i][j]\\n        # In the case of this problem, the property is obviously true. An easy to way to understand why is  \\n\\t\\t# to consider KNUTH[i][j] as the center of gravity of the segment [i,j]. \\n\\t\\t#Then if we reduce the  segment from the left to [i,j-1], we obviously have the center of gravity of this segment \\n\\t\\t# which is  going to be KNUTH[i][j-1] <= KNUTH[i][j] (the center of gravity of course won\\'t go toward the right)\\n        \\n        for length in range(2, len(cuts)+1):\\n            for i in range(0,len(cuts)+1-length):\\n                j = i + (length -1)\\n                base_cost = cuts[j] - cuts[i]\\n                \\n                if length==2:\\n                    DP[i][j] = 0\\n                    KNUTH[i][j] = None\\n                    continue\\n                if length==3:\\n                    DP[i][j] = base_cost\\n                    KNUTH[i][j] = i+1\\n                    continue\\n                    \\n                additional_cost = 10**10\\n\\t\\t\\t\\t#We take advantage of Knuth Optimization here\\n                for k in range(KNUTH[i][j-1],KNUTH[i+1][j]+1):\\n                    if additional_cost >  DP[i][k] + DP[k][j] :\\n                        additional_cost = DP[i][k] + DP[k][j]\\n                        KNUTH[i][j] = k\\n                DP[i][j] = base_cost + additional_cost\\n        return DP[0][-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        #O(len(cuts)\\xB2) algorithm with Knuth Optimization\\n        cuts.append(0)\\n        cuts.append(n)\\n        cuts.sort()\\n        DP = [[10**10 for _ in range(len(cuts))] for _ in range(len(cuts))]\\n        KNUTH = [[None for _ in range(len(cuts))] for _ in range(len(cuts))]\\n        \\n        # The idea is that sometimes you can optimize a dynamic programming solution of the form DP[i][j] = min(DP[i][k]+DP[k][j]) with  i < k < j\\n        # More precisely, if the property KNUTH[i][j-1] <= KNUTH[i][j] <= KNUTH[i+1][j]  is true\\n        # Then we can reduce the interval of possible k we need to check to  KNUTH[i][j-1] <= k <= KNUTH[i+1][j]\\n        # Where KNUTH[i][j] corresponds to the index k*, the optimal choice for DP[i][j]\\n        # In the case of this problem, the property is obviously true. An easy to way to understand why is  \\n\\t\\t# to consider KNUTH[i][j] as the center of gravity of the segment [i,j]. \\n\\t\\t#Then if we reduce the  segment from the left to [i,j-1], we obviously have the center of gravity of this segment \\n\\t\\t# which is  going to be KNUTH[i][j-1] <= KNUTH[i][j] (the center of gravity of course won\\'t go toward the right)\\n        \\n        for length in range(2, len(cuts)+1):\\n            for i in range(0,len(cuts)+1-length):\\n                j = i + (length -1)\\n                base_cost = cuts[j] - cuts[i]\\n                \\n                if length==2:\\n                    DP[i][j] = 0\\n                    KNUTH[i][j] = None\\n                    continue\\n                if length==3:\\n                    DP[i][j] = base_cost\\n                    KNUTH[i][j] = i+1\\n                    continue\\n                    \\n                additional_cost = 10**10\\n\\t\\t\\t\\t#We take advantage of Knuth Optimization here\\n                for k in range(KNUTH[i][j-1],KNUTH[i+1][j]+1):\\n                    if additional_cost >  DP[i][k] + DP[k][j] :\\n                        additional_cost = DP[i][k] + DP[k][j]\\n                        KNUTH[i][j] = k\\n                DP[i][j] = base_cost + additional_cost\\n        return DP[0][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802225,
                "title": "java-bottom-up-dp-with-video-explanaion",
                "content": "Hi, here\\'s my bottom up dp approach, and a video explanation of the answer.\\n\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int[] c = new int[cuts.length+2];\\n        for (int i = 0; i < cuts.length;i++) c[i+1] = cuts[i];\\n        c[c.length-1] = n;\\n        Arrays.sort(c);\\n        int[][] dp = new int[c.length][c.length];\\n        for (int i = 0; i < c.length; i++) {\\n            for (int j = i-1; j >= 0; j--) {\\n                for (int k = i-1; k > j; k--) {\\n                    int ans = Math.min(dp[j][i] == 0 ? Integer.MAX_VALUE : dp[j][i], dp[j][k]+dp[k][i]+c[i]-c[j]);\\n                    dp[j][i] = ans;\\n                }\\n            }\\n        }\\n        return dp[0][c.length-1];\\n    }\\n}\\n```\\nhttps://www.youtube.com/watch?v=8uvWmiawJ8Q&feature=youtu.be",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int[] c = new int[cuts.length+2];\\n        for (int i = 0; i < cuts.length;i++) c[i+1] = cuts[i];\\n        c[c.length-1] = n;\\n        Arrays.sort(c);\\n        int[][] dp = new int[c.length][c.length];\\n        for (int i = 0; i < c.length; i++) {\\n            for (int j = i-1; j >= 0; j--) {\\n                for (int k = i-1; k > j; k--) {\\n                    int ans = Math.min(dp[j][i] == 0 ? Integer.MAX_VALUE : dp[j][i], dp[j][k]+dp[k][i]+c[i]-c[j]);\\n                    dp[j][i] = ans;\\n                }\\n            }\\n        }\\n        return dp[0][c.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208973,
                "title": "dp-solution-3-solutions",
                "content": "**Recursive:** Time Limit Exceeded\\n\\n\\tTime Complexity: Exponential\\n\\tSpace Complexity: ASC\\n\\t\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int len = cuts.length;\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n        for (int ele: cuts) {\\n            list.add(ele);\\n        }\\n        list.add(n);\\n        list.add(0, 0);\\n        Collections.sort(list);\\n        \\n        return f(1, len, list);\\n    }\\n    \\n    private int f(int i, int j, ArrayList<Integer> cuts) {\\n        \\n        // Base Case\\n        if (i > j) {\\n            return 0;\\n        }\\n        \\n        int mini = Integer.MAX_VALUE;\\n        \\n        for (int ind = i; ind <= j; ind++) {\\n            int cost = cuts.get(j + 1) - cuts.get(i - 1) + f(i, ind - 1, cuts) + f(ind + 1, j, cuts);\\n            mini = Math.min(mini, cost);\\n        }\\n        \\n        return mini;\\n    }\\n}\\n```\\n\\n**Memoization:**\\n*Runtime:* **37 ms**, **faster than 47.73%** of Java online submissions for Minimum Cost to Cut a Stick.\\n\\n*Memory Usage:* 41.2 MB, **less than 99.87%** of Java online submissions for Minimum Cost to Cut a Stick.\\n\\n\\tTime Complexity: O(len x len x len)\\n\\tSpace Complexity: O(len x len) + ASC\\n\\t\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int len = cuts.length;\\n        \\n        int[][] dp = new int[len + 1][len + 1];\\n        for (int[] row: dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        \\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n        for (int ele: cuts) {\\n            list.add(ele);\\n        }\\n        list.add(n);\\n        list.add(0, 0);\\n        Collections.sort(list);\\n        \\n        return f(1, len, list, dp);\\n    }\\n    \\n    private int f(int i, int j, ArrayList<Integer> cuts, int[][] dp) {\\n        \\n        // Base Case\\n        if (i > j) {\\n            return 0;\\n        }\\n        \\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        \\n        int mini = Integer.MAX_VALUE;\\n        \\n        for (int ind = i; ind <= j; ind++) {\\n            int cost = cuts.get(j + 1) - cuts.get(i - 1) + f(i, ind - 1, cuts, dp) + f(ind + 1, j, cuts, dp);\\n            mini = Math.min(mini, cost);\\n        }\\n        \\n        return dp[i][j] = mini;\\n    }\\n}\\n```\\n\\n**Tabulation:**\\n*Runtime:* **24 ms**, **faster than 74.33%** of Java online submissions for Minimum Cost to Cut a Stick.\\n\\n*Memory Usage:* 41.8 MB, **less than 92.91%** of Java online submissions for Minimum Cost to Cut a Stick.\\n\\n\\tTime Complexity: O(len x len x len)\\n\\tSpace Complexity: O(len x len)\\n\\t\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int len = cuts.length;\\n        \\n        int[][] dp = new int[len + 2][len + 2];\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n        for (int ele: cuts) {\\n            list.add(ele);\\n        }\\n        list.add(n);\\n        list.add(0, 0);\\n        Collections.sort(list);\\n        \\n        \\n        for (int i = len; i >= 1; i--) {\\n            for (int j = 1; j <= len; j++) {\\n                if (i > j) continue;\\n                \\n                int mini = Integer.MAX_VALUE;\\n        \\n                for (int ind = i; ind <= j; ind++) {\\n                    int cost = list.get(j + 1) - list.get(i - 1) + dp[i][ind - 1] + dp[ind + 1][j];\\n                    mini = Math.min(mini, cost);\\n                }\\n\\n                dp[i][j] = mini;\\n            }\\n        }\\n        \\n        return dp[1][len];\\n    }\\n}\\n\\n// Please upvote if you find this helpful\\n// Feel free to ask doubt\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int len = cuts.length;\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n        for (int ele: cuts) {\\n            list.add(ele);\\n        }\\n        list.add(n);\\n        list.add(0, 0);\\n        Collections.sort(list);\\n        \\n        return f(1, len, list);\\n    }\\n    \\n    private int f(int i, int j, ArrayList<Integer> cuts) {\\n        \\n        // Base Case\\n        if (i > j) {\\n            return 0;\\n        }\\n        \\n        int mini = Integer.MAX_VALUE;\\n        \\n        for (int ind = i; ind <= j; ind++) {\\n            int cost = cuts.get(j + 1) - cuts.get(i - 1) + f(i, ind - 1, cuts) + f(ind + 1, j, cuts);\\n            mini = Math.min(mini, cost);\\n        }\\n        \\n        return mini;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int len = cuts.length;\\n        \\n        int[][] dp = new int[len + 1][len + 1];\\n        for (int[] row: dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        \\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n        for (int ele: cuts) {\\n            list.add(ele);\\n        }\\n        list.add(n);\\n        list.add(0, 0);\\n        Collections.sort(list);\\n        \\n        return f(1, len, list, dp);\\n    }\\n    \\n    private int f(int i, int j, ArrayList<Integer> cuts, int[][] dp) {\\n        \\n        // Base Case\\n        if (i > j) {\\n            return 0;\\n        }\\n        \\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        \\n        int mini = Integer.MAX_VALUE;\\n        \\n        for (int ind = i; ind <= j; ind++) {\\n            int cost = cuts.get(j + 1) - cuts.get(i - 1) + f(i, ind - 1, cuts, dp) + f(ind + 1, j, cuts, dp);\\n            mini = Math.min(mini, cost);\\n        }\\n        \\n        return dp[i][j] = mini;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int len = cuts.length;\\n        \\n        int[][] dp = new int[len + 2][len + 2];\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n        for (int ele: cuts) {\\n            list.add(ele);\\n        }\\n        list.add(n);\\n        list.add(0, 0);\\n        Collections.sort(list);\\n        \\n        \\n        for (int i = len; i >= 1; i--) {\\n            for (int j = 1; j <= len; j++) {\\n                if (i > j) continue;\\n                \\n                int mini = Integer.MAX_VALUE;\\n        \\n                for (int ind = i; ind <= j; ind++) {\\n                    int cost = list.get(j + 1) - list.get(i - 1) + dp[i][ind - 1] + dp[ind + 1][j];\\n                    mini = Math.min(mini, cost);\\n                }\\n\\n                dp[i][j] = mini;\\n            }\\n        }\\n        \\n        return dp[1][len];\\n    }\\n}\\n\\n// Please upvote if you find this helpful\\n// Feel free to ask doubt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260897,
                "title": "c-rec-memoisation-tabulation-both-approaches",
                "content": "\\t// recursion + memoization \\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint f(int i, int j, vector<int> &cuts, vector<vector<int>>& dp){\\n\\n\\t\\t\\tif(i >= j - 1) return 0;\\n\\n\\t\\t\\tif(dp[i][j] != -1) return dp[i][j];\\n\\n\\t\\t\\tint mini = INT_MAX;\\n\\t\\t\\tfor(int k = i+1; k < j; k++) {\\n\\t\\t\\t\\tint ans = f(i, k, cuts, dp) + f(k, j, cuts, dp) + cuts[j] - cuts[i];\\n\\t\\t\\t\\tmini = min(mini, ans);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[i][j] = mini;\\n\\n\\t\\t}\\n\\n\\t\\tint minCost(int n, vector<int>& cuts) {\\n\\n\\t\\t\\tint c = cuts.size();\\n\\t\\t\\tcuts.push_back(n);\\n\\t\\t\\tcuts.insert(cuts.begin(), 0);\\n\\t\\t\\tsort(cuts.begin(), cuts.end());\\n\\n\\t\\t\\tvector<vector<int>> dp(c+2, vector<int> (c+2, -1));\\n\\n\\t\\t\\treturn f(0, c+1, cuts, dp);\\n\\n\\t\\t}\\n\\t};\\n\\n\\n\\t// tabulation solution\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minCost(int n, vector<int>& cuts) {\\n\\n\\t\\t\\t\\tint c = cuts.size();\\n\\t\\t\\t\\tcuts.push_back(n);\\n\\t\\t\\t\\tcuts.insert(cuts.begin(), 0);\\n\\t\\t\\t\\tsort(cuts.begin(), cuts.end());\\n\\n\\t\\t\\t\\tvector<vector<int>> dp(c+2, vector<int> (c+2, 0));\\n\\n\\t\\t\\t\\tfor(int i = c+1; i >= 0; i--){\\n\\t\\t\\t\\t\\tfor(int j = 0; j <= c+1 ; j++){\\n\\n\\t\\t\\t\\t\\t\\tif(i >= j - 1) dp[i][j] = 0;\\n\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\tint mini = INT_MAX;\\n\\t\\t\\t\\t\\t\\t\\tfor(int k = i+1; k < j; k++) {\\n\\t\\t\\t\\t\\t\\t\\t\\tint ans = dp[i][k] + dp[k][j] + cuts[j] - cuts[i];\\n\\t\\t\\t\\t\\t\\t\\t\\tmini = min(mini, ans);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j] = mini;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn dp[0][c+1];\\n\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n\\t\\t// upvote it it helps.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint f(int i, int j, vector<int> &cuts, vector<vector<int>>& dp){\\n\\n\\t\\t\\tif(i >= j - 1) return 0;\\n\\n\\t\\t\\tif(dp[i][j] != -1) return dp[i][j];\\n\\n\\t\\t\\tint mini = INT_MAX;\\n\\t\\t\\tfor(int k = i+1; k < j; k++) {\\n\\t\\t\\t\\tint ans = f(i, k, cuts, dp) + f(k, j, cuts, dp) + cuts[j] - cuts[i];\\n\\t\\t\\t\\tmini = min(mini, ans);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1627569,
                "title": "python-3-easy-to-understand-memoization-clean",
                "content": "```\\nimport sys\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        d={}\\n        def solve(i,j):\\n            if (i,j) in d:\\n                return d[(i,j)]\\n            ans=sys.maxsize\\n            cost=j-i\\n            for cut in cuts:\\n                if cut<j and cut>i:\\n                    ans=min(ans,solve(i,cut)+solve(cut,j)+cost)\\n            if ans==sys.maxsize:\\n                d[(i,j)]=0\\n            else:\\n                d[(i,j)]=ans\\n            return d[(i,j)]\\n            \\n        return solve(0,n)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nimport sys\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        d={}\\n        def solve(i,j):\\n            if (i,j) in d:\\n                return d[(i,j)]\\n            ans=sys.maxsize\\n            cost=j-i\\n            for cut in cuts:\\n                if cut<j and cut>i:\\n                    ans=min(ans,solve(i,cut)+solve(cut,j)+cost)\\n            if ans==sys.maxsize:\\n                d[(i,j)]=0\\n            else:\\n                d[(i,j)]=ans\\n            return d[(i,j)]\\n            \\n        return solve(0,n)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244008,
                "title": "python-6-line-top-down-solution",
                "content": "```\\ndef minCost(self, n: int, cuts: List[int]) -> int:\\n        memo = {}\\n        def dp(l, r):\\n            if (l, r) not in memo:\\n                memo[l, r] = min([dp(l, cut) + dp(cut, r) + (r - l) for cut in cuts if l < cut < r] or [0])\\n            return memo[l, r]\\n        return dp(0, n)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef minCost(self, n: int, cuts: List[int]) -> int:\\n        memo = {}\\n        def dp(l, r):\\n            if (l, r) not in memo:\\n                memo[l, r] = min([dp(l, cut) + dp(cut, r) + (r - l) for cut in cuts if l < cut < r] or [0])\\n            return memo[l, r]\\n        return dp(0, n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3570127,
                "title": "python-3-6-lines-dfs-t-m-89-10",
                "content": "```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        \\n        cuts = sorted(chain(cuts,[0,n]))\\n        \\n        @lru_cache(None)\\n        def dfs(l, r):\\n            length, M = cuts[r] - cuts[l], range(l+1, r)\\n            return min((dfs(l,i) + dfs(i,r) for i in M),\\n                       default = -length) + length\\n        \\n        return dfs(0, len(cuts)-1)\\n```\\n[https://leetcode.com/problems/minimum-cost-to-cut-a-stick/submissions/958717387/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^3) and space complexity is *O*(*N*^2), in which *N* ~`n`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        \\n        cuts = sorted(chain(cuts,[0,n]))\\n        \\n        @lru_cache(None)\\n        def dfs(l, r):\\n            length, M = cuts[r] - cuts[l], range(l+1, r)\\n            return min((dfs(l,i) + dfs(i,r) for i in M),\\n                       default = -length) + length\\n        \\n        return dfs(0, len(cuts)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569983,
                "title": "with-video-explanation-c-recursion-with-memo-iterate-solution-beats-98-28",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem at hand can be considered difficult because the brute-force solution would have a time complexity of O(m!), where m is the number of cuts. However, we can solve it efficiently using dynamic programming.\\n\\nThe straightforward recursive approach has an exponential time complexity. By incorporating memoization, we can reduce it to O(m^3). The memoization technique helps us store previously computed results, avoiding redundant calculations.\\n\\nIn this code, we use a 2D vector, dp, to store the computed results. The dimensions of dp are m x m, where m is the size of the cuts vector. This matrix allows us to keep track of the minimum cost for cutting the rod between different positions.\\n\\nBy leveraging the memoized recursive function, we can solve the problem iteratively using for loops. This further optimizes the solution by reducing the memory complexity to O(m^2).\\n\\nIn summary, although the problem may initially appear challenging, we can efficiently solve it using dynamic programming. The code provided employs memoization and an iterative approach to achieve a time complexity of O(m^3) and a memory complexity of O(m^2).\\n\\n![\\u52D5\\u614B\\u898F\\u5283cpp\\u89E3\\u96E3\\u984CLeetcode1547. Minimum Cost to Cut a Stick.png](https://assets.leetcode.com/users/images/2327e2d5-11d9-49cd-9c07-6476246c6b75_1685272234.0733173.png)\\n\\nVery similar idea to solve Stone Game III https://leetcode.com/problems/stone-game-iii/solutions/3566335/easy-c-recursive-solutions-with-memoization-iterating-with-video-explanation/\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[Please turn English subtitles if necessary]\\n[https://youtu.be/c6qoRyZWqgA](https://youtu.be/c6qoRyZWqgA)\\n\\nAdd 0, n to cuts & sort\\n\\ndp[i][j]=min(dp[i][k]+dp[k][j])+(cuts[j]-cuts[i]) \\nwhere i<k<j\\n\\n\\nList the dp table for test case n=9, cuts=[5,6,1,4,2]\\n```\\n    0    0    2    6   10   14   22\\n    0    0    0    3    7   10   18\\n    0    0    0    0    3    6   13\\n    0    0    0    0    0    2    7\\n    0    0    0    0    0    0    4\\n    0    0    0    0    0    0    0\\n    0    0    0    0    0    0    0\\n```\\nn =5340\\ncuts =[2062,4550,482,4903,2998,5002,3766,2297]\\n```\\n     0,     0,  2062,  4112,  5996,  8468, 11588, 13583, 14332, 16121,\\n     0,     0,     0,  1815,  3452,  5924,  9044, 10915, 11664, 13431,\\n     0,     0,     0,     0,   936,  2640,  4976,  6618,  7268,  8719,\\n     0,     0,     0,     0,     0,  1469,  3722,  5212,  5862,  7313,\\n     0,     0,     0,     0,     0,     0,  1552,  3042,  3692,  5121,\\n     0,     0,     0,     0,     0,     0,     0,  1137,  1688,  2801,\\n     0,     0,     0,     0,     0,     0,     0,     0,   452,  1227,\\n     0,     0,     0,     0,     0,     0,     0,     0,     0,   437,\\n     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\\n     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m^3)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m^2)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        int m=cuts.size();\\n        sort(cuts.begin(), cuts.end());\\n        vector dp(m, vector<int>(m, -1));\\n        function<int(int, int)>  cost=[&](int i, int j)->int{\\n            if (j-i<=1) return 0;\\n            if (dp[i][j]!=-1) return dp[i][j];\\n            int result=INT_MAX;\\n            for(int k=i+1; k<j; k++){\\n                result=min(result, cost(i, k) +cost(k, j));\\n            }\\n            return dp[i][j] = result+(cuts[j]-cuts[i]);\\n        };\\n        return cost(0, m-1);\\n    }\\n};\\n```\\n# Code with Explanation\\n```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        // Append the starting and ending points to the cuts vector\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        int m = cuts.size();\\n        \\n        // Sort the cuts vector in ascending order\\n        sort(cuts.begin(), cuts.end());\\n        \\n        // Create a 2D vector \\'dp\\' to store computed results, initialized with -1\\n        vector<vector<int>> dp(m, vector<int>(m, -1));\\n        \\n        // Define a lambda function \\'cost\\' to calculate the minimum cost of cutting\\n        function<int(int, int)> cost = [&](int i, int j) -> int {\\n            // Base case: if the distance between i and j is less than or equal to 1, no cuts are needed\\n            if (j - i <= 1)\\n                return 0;\\n            \\n            // Check if the result for current i and j has already been computed\\n            if (dp[i][j] != -1)\\n                return dp[i][j];\\n            \\n            int result = INT_MAX;\\n            \\n            // Iterate over possible cut positions between i+1 and j-1\\n            for (int k = i + 1; k < j; k++) {\\n                // Calculate the cost of cutting from i to k and from k to j recursively\\n                int cutCost = cost(i, k) + cost(k, j);\\n                \\n                // Update the minimum cost\\n                result = min(result, cutCost);\\n            }\\n            \\n            // Store the minimum cost for the current i and j in the \\'dp\\' vector\\n            // Add the length of the current cut (cuts[j] - cuts[i]) to the result\\n            return dp[i][j] = result + (cuts[j] - cuts[i]);\\n        };\\n        \\n        // Start the recursive calculation from position 0 to position m-1\\n        return cost(0, m - 1);\\n    }\\n};\\n\\n```\\n# Iterate solution beats 98.28%\\n```\\nclass Solution {\\npublic:\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        int m=cuts.size();\\n        sort(cuts.begin(), cuts.end());\\n        vector cost(m, vector<int>(m, 0));\\n        for (int step=2; step<m; step++){\\n            for (int i=0; i<m-step; i++){\\n                int result=INT_MAX, j=i+step;\\n                for(int k=i+1; k<j; k++)\\n                    result=min(result, cost[i][k] +cost[k][j]);\\n                cost[i][j] = result+(cuts[j]-cuts[i]);\\n            }\\n        }\\n        return cost[0][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n    0    0    2    6   10   14   22\\n    0    0    0    3    7   10   18\\n    0    0    0    0    3    6   13\\n    0    0    0    0    0    2    7\\n    0    0    0    0    0    0    4\\n    0    0    0    0    0    0    0\\n    0    0    0    0    0    0    0\\n```\n```\\n     0,     0,  2062,  4112,  5996,  8468, 11588, 13583, 14332, 16121,\\n     0,     0,     0,  1815,  3452,  5924,  9044, 10915, 11664, 13431,\\n     0,     0,     0,     0,   936,  2640,  4976,  6618,  7268,  8719,\\n     0,     0,     0,     0,     0,  1469,  3722,  5212,  5862,  7313,\\n     0,     0,     0,     0,     0,     0,  1552,  3042,  3692,  5121,\\n     0,     0,     0,     0,     0,     0,     0,  1137,  1688,  2801,\\n     0,     0,     0,     0,     0,     0,     0,     0,   452,  1227,\\n     0,     0,     0,     0,     0,     0,     0,     0,     0,   437,\\n     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\\n     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        int m=cuts.size();\\n        sort(cuts.begin(), cuts.end());\\n        vector dp(m, vector<int>(m, -1));\\n        function<int(int, int)>  cost=[&](int i, int j)->int{\\n            if (j-i<=1) return 0;\\n            if (dp[i][j]!=-1) return dp[i][j];\\n            int result=INT_MAX;\\n            for(int k=i+1; k<j; k++){\\n                result=min(result, cost(i, k) +cost(k, j));\\n            }\\n            return dp[i][j] = result+(cuts[j]-cuts[i]);\\n        };\\n        return cost(0, m-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        // Append the starting and ending points to the cuts vector\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        int m = cuts.size();\\n        \\n        // Sort the cuts vector in ascending order\\n        sort(cuts.begin(), cuts.end());\\n        \\n        // Create a 2D vector \\'dp\\' to store computed results, initialized with -1\\n        vector<vector<int>> dp(m, vector<int>(m, -1));\\n        \\n        // Define a lambda function \\'cost\\' to calculate the minimum cost of cutting\\n        function<int(int, int)> cost = [&](int i, int j) -> int {\\n            // Base case: if the distance between i and j is less than or equal to 1, no cuts are needed\\n            if (j - i <= 1)\\n                return 0;\\n            \\n            // Check if the result for current i and j has already been computed\\n            if (dp[i][j] != -1)\\n                return dp[i][j];\\n            \\n            int result = INT_MAX;\\n            \\n            // Iterate over possible cut positions between i+1 and j-1\\n            for (int k = i + 1; k < j; k++) {\\n                // Calculate the cost of cutting from i to k and from k to j recursively\\n                int cutCost = cost(i, k) + cost(k, j);\\n                \\n                // Update the minimum cost\\n                result = min(result, cutCost);\\n            }\\n            \\n            // Store the minimum cost for the current i and j in the \\'dp\\' vector\\n            // Add the length of the current cut (cuts[j] - cuts[i]) to the result\\n            return dp[i][j] = result + (cuts[j] - cuts[i]);\\n        };\\n        \\n        // Start the recursive calculation from position 0 to position m-1\\n        return cost(0, m - 1);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        int m=cuts.size();\\n        sort(cuts.begin(), cuts.end());\\n        vector cost(m, vector<int>(m, 0));\\n        for (int step=2; step<m; step++){\\n            for (int i=0; i<m-step; i++){\\n                int result=INT_MAX, j=i+step;\\n                for(int k=i+1; k<j; k++)\\n                    result=min(result, cost[i][k] +cost[k][j]);\\n                cost[i][j] = result+(cuts[j]-cuts[i]);\\n            }\\n        }\\n        return cost[0][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569964,
                "title": "tabulation-bottom-up-python-js-solution",
                "content": "Hello **Tenno Leetcoders**, \\n\\nFor this problem, we a given a wooden stick of length `n` units, where the stick is labelled from `0` to `n` and array `cuts` where `cuts[i]` denotes a position you should perform a cut at. \\n\\nPerforming the cuts in order with the cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut).\\n\\nWe want to return the `minimum total cost` of the cuts\\n\\n### Explanation\\n\\nOur main goal is to determine the minimum total cost to perform a series of cuts on the given wooden stick denoted in the `cuts` array. \\n\\nThe `cuts` array contains positions where the cuts should be made and the order of the cuts can be changed. For each cut, it will have the cost equal to the length of the stick being cut at that current position. The total cost will then be the sum of the cost of all the cuts. \\n\\nSince, we are trying to find the `minimum total cost` to perform a `series` of cuts, we can use `Dynamic Programming Tabulation (Bottom up)` approach to help us simulate the `series` of cuts as we find the `minimum total cost`\\n\\n\\nTo ensure we perform each cut in order, we should `sort` cuts in ascending order. \\n\\nOnce sorted, we can create a new `cuts` array and add a `0` to the beginning and our given `n` to the end. The new `cuts` array will represent the position at which cuts will be made as it will include the starting and ending position of the wooden stick. \\n\\nSince we are using `Tabulation (Bottom up)` approach, we will use a `2D` table represented as `dp` with the dimensions of `length of cuts * length of cuts`.\\n\\nUsing our `2D`table, we will store the minimum cost needed to cut the stick between position `cut[i]` and `cuts[j]` later on\\n\\n### Base case\\n\\nAs the problem using  `Tabulation (Bottom up)` our base case is predefined in ` dp = [[0]* stick_len for _ in range(stick_len)]`, representing as when no cuts are needed the cost of those cuts are `0`\\n\\n### Recurrence relation\\n\\nFor the recurrence relation, when `i < k < j` we will be calculating the cost of cutting the sticks between positions `cuts[i]` and `cuts[j]`, while we also consider the potential cut needed at position `cuts[k]`\\n\\n`cuts[j]` and `cuts[i]` represents the length of the stick being cut at positions `cuts[i]` and `cuts[j]` as we also accounts for the cost of the current cut being considered\\n\\n`dp[i][k]` represents the minimum cost of cutting the stick between positions `cuts[i]` and `cuts[k]`. `dp[i][k]` will be obtained from the previous computed subproblems, which represents the minimum cost for the left wooden stick\\n\\n`dp[k][j]` represents the minimum cost of cutting the stick between positions `cuts[k]` and `cuts[j]`.  `dp[k][j]` will be obtained from the previous computed subproblems, which represents the minimum cost for the right wooden stick\\n\\n`min_cost` is used to keep track of the minimum cost encountered among all potential cuts `k` within the range of `i < k < j` to ensure the minimum cost will be found among all different combinations of cuts being made\\n\\n`dp[i][j]` is then updated with `min_cost` to ensure we properly store the minimum cost needed for the current range of cuts for `i` to `j`\\n\\nPutting it all together, we have a recurrence relation denoted as follows:\\n\\n  `cost = cuts[j] - cuts[i] + dp[i][k] + dp[k][j]\\n  min_cost = min(min_cost, cost)\\n  dp[i][j] = min_cost`\\n  \\nNow, create an outer loop to iterate over cuts array in reverse order starting from the second-to-last cut moving towards the first cut. Instead of `length - 1`, we will perform `length - 2` to ensure we consider all subproblem.\\n\\nInitialize `min_cost`\\n\\nInside the inner loop, we now also iterate cuts array from `k + 1` to the end of the array `j` to find the potential position to make cuts between `cuts[i]` and `cuts[j]`. So, iterate over `i + 1` to `j` to find all possible positions for making cuts between the indices `i` and `j` and perform our recurrence relation of `cost` and `min_cost`\\n\\nUpdate `dp[i][j]` after the inner loop \\n\\nThe minimum total cost of the cuts will then be stored in `dp[0][stick_len - 1]` in the first row last element \\n\\n\\n# Code\\n**Python**\\n```\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.sort()\\n        cuts = [0] + cuts + [n]\\n\\n        stick_len = len(cuts)\\n\\n        dp = [[0]* stick_len for _ in range(stick_len)]\\n\\n        for i in range(stick_len - 2, -1, -1):\\n            for j in range(i + 2, stick_len):\\n                min_cost = float(\"inf\")\\n                for k in range(i + 1, j):\\n                    cost = cuts[j] - cuts[i] + dp[i][k] + dp[k][j]\\n                    min_cost = min(min_cost, cost)\\n                dp[i][j] = min_cost\\n\\n        return dp[0][stick_len - 1]\\n```\\n\\n**JavaScript**\\n```\\n/**\\n * @param {number} n\\n * @param {number[]} cuts\\n * @return {number}\\n */\\nvar minCost = function(n, cuts) {\\n    cuts.sort((a, b) => a - b)\\n    cuts = [0, ...cuts, n]\\n\\n    const stickLen = cuts.length\\n\\n    const dp = Array(stickLen).fill(0).map(() => Array(stickLen).fill(0))\\n\\n    for (let i = stickLen - 2; i >= 0; i--){\\n        for (let j = i + 2; j < stickLen; j++){\\n            let minCost = Infinity\\n            for (let k = i + 1; k < j; k++){\\n                const cost = cuts[j] - cuts[i] + dp[i][k] + dp[k][j]\\n                minCost = Math.min(minCost, cost)\\n            }\\n\\n            dp[i][j] = minCost\\n        }\\n    }\\n    return dp[0][stickLen - 1]\\n};\\n```\\n### Time Complexity: O(n^3 + n logn )\\n### Space Complexity: O(n^2)\\n \\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.sort()\\n        cuts = [0] + cuts + [n]\\n\\n        stick_len = len(cuts)\\n\\n        dp = [[0]* stick_len for _ in range(stick_len)]\\n\\n        for i in range(stick_len - 2, -1, -1):\\n            for j in range(i + 2, stick_len):\\n                min_cost = float(\"inf\")\\n                for k in range(i + 1, j):\\n                    cost = cuts[j] - cuts[i] + dp[i][k] + dp[k][j]\\n                    min_cost = min(min_cost, cost)\\n                dp[i][j] = min_cost\\n\\n        return dp[0][stick_len - 1]\\n```\n```\\n/**\\n * @param {number} n\\n * @param {number[]} cuts\\n * @return {number}\\n */\\nvar minCost = function(n, cuts) {\\n    cuts.sort((a, b) => a - b)\\n    cuts = [0, ...cuts, n]\\n\\n    const stickLen = cuts.length\\n\\n    const dp = Array(stickLen).fill(0).map(() => Array(stickLen).fill(0))\\n\\n    for (let i = stickLen - 2; i >= 0; i--){\\n        for (let j = i + 2; j < stickLen; j++){\\n            let minCost = Infinity\\n            for (let k = i + 1; k < j; k++){\\n                const cost = cuts[j] - cuts[i] + dp[i][k] + dp[k][j]\\n                minCost = Math.min(minCost, cost)\\n            }\\n\\n            dp[i][j] = minCost\\n        }\\n    }\\n    return dp[0][stickLen - 1]\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2602716,
                "title": "why-sorting-is-required-without-adding-0-and-n-to-cuts-detailed-explanation",
                "content": "**Note:** At first, I couldn\\'t understand why everyone is sorting the cuts or adding 0 and n to the cuts array. It took me some time to understand why everyone is doing that actually. \\nPlease go through the entire explanation and codes to understand more clearly \\n\\n**Case 1:** **Implementing without sorting and without adding 0 or n to the cuts** **(TLE)**\\n* This is same as implementing top down approach for any other problem.\\n* We try to peform cut at every possible index, if the cut position is in the starting and ending range of stick.\\n* Sometimes we cannot peform cut because it might be outside of the stick range.\\n\\t* **Ex:** Suppose, for a stick of **length 6** with the starting and ending pos of stick currently being [2,5]. We cannot perform cuts which are <=2 and >=5 as they lies outside of the current stick range.\\n\\t* We skip these cuts and do not peform on the current stick.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// Creating a 2-D array of size 1000001 x c, where c is some random value\\n\\tunordered_map<int, int> dp[1000001];\\n\\t\\n    int topDown(int stickStart, int stickEnd, vector<int> &cuts){\\n\\t\\t// Not possible case\\n        if(stickStart >= stickEnd){\\n            return 0;\\n        }\\n        \\n        if(dp[stickStart].find(stickEnd) != dp[stickStart].end()){\\n\\t\\t\\treturn dp[stickStart][stickEnd];\\n\\t\\t}\\n        \\n        int ans = INT_MAX;\\n\\t\\t\\n\\t\\t// We try to peform cuts at every possible position\\n        for(int k=0; k<cuts.size(); k++){\\n\\t\\t\\t// The cut is not possible, as it is not present in starting and ending range of stick\\n            if(cuts[k] <= stickStart || cuts[k] >= stickEnd){\\n                continue;\\n            }\\n            int l = topDown(stickStart, cuts[k], cuts);\\n            int r = topDown(cuts[k], stickEnd, cuts);\\n\\t\\t\\tint len = stickEnd - stickStart;\\n            ans = min(ans, l+r+len);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? 0 : ans);\\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        return topDown(0, n, 0, size(cuts)-1, cuts);\\n    }\\n};\\n```\\n\\n**Note:** The problem with above approach is we\\'re **iterating the cuts array no matter what the starting and ending ranges of the stick are** and only performing cut in cases where it is possible.\\n\\nThus, we are unnecessarily checking all cuts, which becomes an overhead. So, we sort  the cuts array and pass the cuts which are only possible in that stick range. \\n\\n**Case 2:** **Using sorting:** **(Accepted)**\\n* In this case, we pass the cutsStart and cutsEnd representing starting and ending indices of the cuts that are possible on the current stick starting at **stickStart** and ending at **stickEnd**.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[101][101];\\n    \\n    int topDown(int stickStart, int stickEnd, int cutsStart, int cutsEnd, vector<int> &cuts){\\n        if(cutsStart > cutsEnd){\\n            return 0;\\n        }\\n        \\n        if(dp[cutsStart][cutsEnd] != -1)\\n            return dp[cutsStart][cutsEnd];\\n        \\n        int ans = INT_MAX;\\n\\t\\t\\n\\t\\t// Iterating over only possible cuts\\n        for(int k=cutsStart; k<=cutsEnd; k++){\\n\\t\\t\\n\\t\\t\\t// All the cuts which lies >=k are useless for the left stick subproblem\\n            int l = topDown(stickStart, cuts[k], cutsStart, k-1, cuts);\\n\\t\\t\\t\\n\\t\\t\\t// All the cuts which lies <=k are useless for the right stick subproblem\\n            int r = topDown(cuts[k], stickEnd, k+1, cutsEnd, cuts);\\n\\t\\t\\t\\n            int len = stickEnd - stickStart;\\n            ans = min(ans, l+r+len);\\n        }\\n        \\n        return dp[cutsStart][cutsEnd] = (ans == INT_MAX ? 0 : ans);\\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        memset(dp, -1, sizeof(dp));\\n        sort(begin(cuts), end(cuts));\\n        return topDown(0, n, 0, size(cuts)-1, cuts);\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// Creating a 2-D array of size 1000001 x c, where c is some random value\\n\\tunordered_map<int, int> dp[1000001];\\n\\t\\n    int topDown(int stickStart, int stickEnd, vector<int> &cuts){\\n\\t\\t// Not possible case\\n        if(stickStart >= stickEnd){\\n            return 0;\\n        }\\n        \\n        if(dp[stickStart].find(stickEnd) != dp[stickStart].end()){\\n\\t\\t\\treturn dp[stickStart][stickEnd];\\n\\t\\t}\\n        \\n        int ans = INT_MAX;\\n\\t\\t\\n\\t\\t// We try to peform cuts at every possible position\\n        for(int k=0; k<cuts.size(); k++){\\n\\t\\t\\t// The cut is not possible, as it is not present in starting and ending range of stick\\n            if(cuts[k] <= stickStart || cuts[k] >= stickEnd){\\n                continue;\\n            }\\n            int l = topDown(stickStart, cuts[k], cuts);\\n            int r = topDown(cuts[k], stickEnd, cuts);\\n\\t\\t\\tint len = stickEnd - stickStart;\\n            ans = min(ans, l+r+len);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? 0 : ans);\\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        return topDown(0, n, 0, size(cuts)-1, cuts);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[101][101];\\n    \\n    int topDown(int stickStart, int stickEnd, int cutsStart, int cutsEnd, vector<int> &cuts){\\n        if(cutsStart > cutsEnd){\\n            return 0;\\n        }\\n        \\n        if(dp[cutsStart][cutsEnd] != -1)\\n            return dp[cutsStart][cutsEnd];\\n        \\n        int ans = INT_MAX;\\n\\t\\t\\n\\t\\t// Iterating over only possible cuts\\n        for(int k=cutsStart; k<=cutsEnd; k++){\\n\\t\\t\\n\\t\\t\\t// All the cuts which lies >=k are useless for the left stick subproblem\\n            int l = topDown(stickStart, cuts[k], cutsStart, k-1, cuts);\\n\\t\\t\\t\\n\\t\\t\\t// All the cuts which lies <=k are useless for the right stick subproblem\\n            int r = topDown(cuts[k], stickEnd, k+1, cutsEnd, cuts);\\n\\t\\t\\t\\n            int len = stickEnd - stickStart;\\n            ans = min(ans, l+r+len);\\n        }\\n        \\n        return dp[cutsStart][cutsEnd] = (ans == INT_MAX ? 0 : ans);\\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        memset(dp, -1, sizeof(dp));\\n        sort(begin(cuts), end(cuts));\\n        return topDown(0, n, 0, size(cuts)-1, cuts);\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2584658,
                "title": "java-solution-both-approaches-top-to-bottom-bottom-to-top",
                "content": "Hi Family,\\n\\nI did this question with both the approach , put the comments for easy understanding.\\n\\n**Top To Bottom**\\n```\\n\\n \\n    int dp[][];\\n    public int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n        int c = cuts.length;\\n        List<Integer> cuts_list = new ArrayList<>();\\n        // add 0 in a list\\n        cuts_list.add(0);\\n        // add all the cuts element in list\\n        for (int i=0;i<c;i++) cuts_list.add(cuts[i]);\\n        // add n in a list\\n        cuts_list.add(n);\\n        dp = new int[c+2][c+2];\\n        for (int i=0;i<c+2;i++) Arrays.fill(dp[i],-1);\\n        return helper_mincost_func(1,c,cuts_list);\\n        \\n        \\n    }\\n    \\n    \\n    \\n    private int helper_mincost_func(int i,int j,List<Integer> cuts_list){\\n        if (i>j) return 0;\\n        \\n        if (dp[i][j] != -1) return dp[i][j];\\n        \\n        int mini = Integer.MAX_VALUE;\\n        for (int ind=i;ind<=j;ind++){\\n            int steps = cuts_list.get(j+1) - cuts_list.get(i-1) \\n                + helper_mincost_func(i,ind-1,cuts_list)   // for left side \\n                + helper_mincost_func(ind+1,j,cuts_list);  // for right side\\n            mini = Math.min(steps,mini);\\n        }\\n        return dp[i][j] = mini;\\n    }\\n    \\n\\n```\\n\\n**Bottom To Top**\\n\\n```\\npublic int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n        int c = cuts.length;\\n        List<Integer> cuts_list = new ArrayList<>();\\n        cuts_list.add(0);\\n        for (int i=0;i<c;i++) cuts_list.add(cuts[i]);\\n        cuts_list.add(n);\\n        \\n        int dp[][] = new int[c+2][c+2];\\n        \\n        for (int i=c;i>=1;i--){\\n            for (int j=i;j<=c;j++){\\n                \\n                int mini = Integer.MAX_VALUE;\\n                for(int ind=i;ind<=j;ind++){\\n                    int steps = cuts_list.get(j+1) - cuts_list.get(i-1)\\n                        + dp[i][ind-1]  // for left side;\\n                        + dp[ind+1][j]; // for right side;\\n                    mini = Math.min(mini,steps);\\n                }\\n                dp[i][j] = mini;\\n            }       \\n        }\\n        return dp[1][c];\\n    }\\n```\\n\\nPlease upvote this solution, if you liked\\nThanks!!!\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\n \\n    int dp[][];\\n    public int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n        int c = cuts.length;\\n        List<Integer> cuts_list = new ArrayList<>();\\n        // add 0 in a list\\n        cuts_list.add(0);\\n        // add all the cuts element in list\\n        for (int i=0;i<c;i++) cuts_list.add(cuts[i]);\\n        // add n in a list\\n        cuts_list.add(n);\\n        dp = new int[c+2][c+2];\\n        for (int i=0;i<c+2;i++) Arrays.fill(dp[i],-1);\\n        return helper_mincost_func(1,c,cuts_list);\\n        \\n        \\n    }\\n    \\n    \\n    \\n    private int helper_mincost_func(int i,int j,List<Integer> cuts_list){\\n        if (i>j) return 0;\\n        \\n        if (dp[i][j] != -1) return dp[i][j];\\n        \\n        int mini = Integer.MAX_VALUE;\\n        for (int ind=i;ind<=j;ind++){\\n            int steps = cuts_list.get(j+1) - cuts_list.get(i-1) \\n                + helper_mincost_func(i,ind-1,cuts_list)   // for left side \\n                + helper_mincost_func(ind+1,j,cuts_list);  // for right side\\n            mini = Math.min(steps,mini);\\n        }\\n        return dp[i][j] = mini;\\n    }\\n    \\n\\n```\n```\\npublic int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n        int c = cuts.length;\\n        List<Integer> cuts_list = new ArrayList<>();\\n        cuts_list.add(0);\\n        for (int i=0;i<c;i++) cuts_list.add(cuts[i]);\\n        cuts_list.add(n);\\n        \\n        int dp[][] = new int[c+2][c+2];\\n        \\n        for (int i=c;i>=1;i--){\\n            for (int j=i;j<=c;j++){\\n                \\n                int mini = Integer.MAX_VALUE;\\n                for(int ind=i;ind<=j;ind++){\\n                    int steps = cuts_list.get(j+1) - cuts_list.get(i-1)\\n                        + dp[i][ind-1]  // for left side;\\n                        + dp[ind+1][j]; // for right side;\\n                    mini = Math.min(mini,steps);\\n                }\\n                dp[i][j] = mini;\\n            }       \\n        }\\n        return dp[1][c];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2004497,
                "title": "c-solution-brute-force-to-tabulation-dp-all-covered",
                "content": "**C++ Brute Force Recursion (Gives You TLE)**\\n```class Solution {\\npublic:\\n    int func(vector<int> &cuts,int i,int j){\\n        if(i>j) return 0;\\n        int m=INT_MAX;\\n        for(int k=i;k<=j;k++){\\n            int cost=cuts[j+1]-cuts[i-1]+func(cuts,i,k-1)+func(cuts,k+1,j);\\n            m=min(m,cost);\\n        }\\n        return m;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(),cuts.end());\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        return func(cuts,1,cuts.size()-2);\\n    }\\n};\\n```\\n**C++ Memorization Solution (128 ms) (Accepted)**\\n```\\nclass Solution {\\npublic:\\n    int func(vector<int> &cuts,int i,int j,vector<vector<int>> &dp){\\n        if(i>j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int m=INT_MAX;\\n        for(int k=i;k<=j;k++){\\n            int cost=cuts[j+1]-cuts[i-1]+func(cuts,i,k-1,dp)+func(cuts,k+1,j,dp);\\n            m=min(m,cost);\\n        }\\n        return dp[i][j]=m;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(),cuts.end());\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        int b=cuts.size();\\n        vector<vector<int>> dp(b,vector<int>(b,-1));\\n        return func(cuts,1,b-2,dp);\\n    }\\n};\\n```\\n**C++ Tabulation DP Solution (79 ms) (Accepted)**\\n```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(),cuts.end());\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        int b=cuts.size();\\n        vector<vector<int>> dp(b,vector<int>(b,0));\\n        for(int i=b-2;i>=1;i--){\\n            for(int j=i;j<=b-2;j++){\\n                int m=INT_MAX;\\n                for(int k=i;k<=j;k++){\\n                    int cost=cuts[j+1]-cuts[i-1]+dp[i][k-1]+dp[k+1][j];\\n                    m=min(m,cost);\\n                }\\n                dp[i][j]=m;\\n            }\\n        }\\n        return dp[1][b-2];\\n    }\\n};\\n```\\n**PLease Upvote if You get any help from this post.**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```class Solution {\\npublic:\\n    int func(vector<int> &cuts,int i,int j){\\n        if(i>j) return 0;\\n        int m=INT_MAX;\\n        for(int k=i;k<=j;k++){\\n            int cost=cuts[j+1]-cuts[i-1]+func(cuts,i,k-1)+func(cuts,k+1,j);\\n            m=min(m,cost);\\n        }\\n        return m;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(),cuts.end());\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        return func(cuts,1,cuts.size()-2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int func(vector<int> &cuts,int i,int j,vector<vector<int>> &dp){\\n        if(i>j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int m=INT_MAX;\\n        for(int k=i;k<=j;k++){\\n            int cost=cuts[j+1]-cuts[i-1]+func(cuts,i,k-1,dp)+func(cuts,k+1,j,dp);\\n            m=min(m,cost);\\n        }\\n        return dp[i][j]=m;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(),cuts.end());\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        int b=cuts.size();\\n        vector<vector<int>> dp(b,vector<int>(b,-1));\\n        return func(cuts,1,b-2,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(),cuts.end());\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        int b=cuts.size();\\n        vector<vector<int>> dp(b,vector<int>(b,0));\\n        for(int i=b-2;i>=1;i--){\\n            for(int j=i;j<=b-2;j++){\\n                int m=INT_MAX;\\n                for(int k=i;k<=j;k++){\\n                    int cost=cuts[j+1]-cuts[i-1]+dp[i][k-1]+dp[k+1][j];\\n                    m=min(m,cost);\\n                }\\n                dp[i][j]=m;\\n            }\\n        }\\n        return dp[1][b-2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520578,
                "title": "c-simple-top-down-dp-approach",
                "content": "Instead of cutting the rods we can see the problem to join the pieces of rod to get the minimum value. This will help us to clearly see the Top Down DP approach.(**Also keep in mind that we can only add the rod which are contigous** ).\\nFirst we will sort the array to get the increasing sequence of the cuts in the rod and we will insert 0 and L(length of rod) at the beginning and end of array.\\nNow the cuts array will help us to maintain the starting index of each rods and we can easily find the length of rod .(**the beginning of next rod will be the end of former rod**).\\nNow we will directly jump to TOP DOWN approach-\\nHere dp[i][j] represents the minimum cost of joining the rods whose starting indeces are between i and j.\\nAlso dp[i][j] can be deriveable from other rods present between i and j.\\n\\t\\tdp[i][j]=dp[i][d]+dp[d+1][j]+cuts[j+1]-cuts[i];\\n\\t\\there d will vary from d=i till d<j. \\n\\t\\tdp[i][d] represents cost of joining rods from indices i to d and same is for dp[d+1][j] \\n\\t\\tcuts[j+1]-cuts[i] is also added because we are also adding rod formed from dp[i][d] and dp[d+1][j] to form             a new rod.\\nHere is the implementation of my  code\\n```\\nclass Solution {\\npublic:\\n    int minCost(int l, vector<int>& cuts) {\\n        sort(cuts.begin(),cuts.end());\\n        cuts.insert(cuts.begin(),0);\\n        cuts.push_back(l);int n=cuts.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,9999999));\\n        for(int i=0;i<n-1;i++)\\n        {\\n            dp[i][i]=0;\\n        }\\n        for(int k=2;k<=n;k++)\\n        {\\n            for(int i=0;i<n-k;i++)\\n            {\\n                int j=i+k-1;\\n                for(int d=i;d<j;d++)\\n                {   \\n                    \\n                    dp[i][j]=min(dp[i][j],dp[i][d]+dp[d+1][j]+cuts[j+1]-cuts[i]);\\n                }\\n            }\\n        }\\n        return dp[0][n-2];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minCost(int l, vector<int>& cuts) {\\n        sort(cuts.begin(),cuts.end());\\n        cuts.insert(cuts.begin(),0);\\n        cuts.push_back(l);int n=cuts.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,9999999));\\n        for(int i=0;i<n-1;i++)\\n        {\\n            dp[i][i]=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 810376,
                "title": "java-dp-bottom-up-step-by-step-understanding-from-tle-to-accepted",
                "content": "This is indeed a very challenging question. I will do my best to explain my attempt at solving this. \\n\\nThere are already some great posts on DFS + Memo. Please read up on some if you aren\\'t familiar.\\n\\nBottom Up:\\nTake example n = 7, cuts = [1,3,4,5]\\nBasically, redefining the larger problem **what is the minimum cost of cutting the stick from (0, 6) by applying all cuts** defined as f(0,6)\\nStill confusing... Lets break apart of the problem. \\nWhat is the minimum cost of cutting the stick from (0, 1) by applying all cuts **plus** the minimum cost of cutting the stick from (1, 6) by applying all the cuts. \\n*Basically split the (0,6) into (0,1)+(1,6), (0,3)+(3,6) and so forth.*\\n\\nNow we can break this into a equation:\\n`f(0,6) = min(f(0,1) + f(1,6), f(0,3) + f(3,6), f(0,4) + f(4,6), f(0,5) + f(5,6)) + (6-0)  // add the distance from 0 to 6`\\nTaking the first `f(0,1) + f(1,6)`\\n`f(0,1) = 0, we can\\'t cut from f(0,1)`\\n`f(1,6) = min(f(0,3) + f(3,6), f(0,4) + f(4,6),  f(0,5) + f(5,6)) + (6 - 1)`\\nTaking the first `f(0,3) + f(3,6)`\\n`f(0,3) = 0 we can\\'t cut from f(0,3)`\\n`f(3,6) = min(f(3,4) + f(4,6), f(3,5) + f(5,6)) + (6-3)`\\n`f(3,4) = 0, we can\\'t cut from f(3,4)`\\n`f(4,6) = min(f(4,5) + f(5,6)) + (6 - 4)`\\n`f(4,5), f(5,6) = 0`\\n\\nNotice that since `dp[i][j]` requires `dp[i+1][ j-1]`. We need to loop like \\n```\\nfor (i=n -> 0)\\n\\tfor (j=i+1 -> n)\\n\\tfor (cut : cuts) \\n\\t  if (cut > i && cut < j) // this is necessary so we don\\'t count (0,3) or (3,5) with cut = 3 as cuttable \\n```\\n\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int[][] dp = new int[n+1][n+1];\\n        \\n        for (int i = n; i >= 0; i--) {\\n            for (int j = i+1; j <= n; j++) {\\n                int dist = j-i;\\n                int min = Integer.MAX_VALUE;\\n                for (int cut : cuts) {\\n                    if (cut > i && cut < j) {\\n                        min = Math.min(min, dp[i][cut] + dp[cut][j]);\\n                    }\\n                }\\n                if (min != Integer.MAX_VALUE) {\\n                    dp[i][j] = min + dist;\\n                }\\n            }\\n        }\\n        return dp[0][n];\\n    }\\n}\\n```\\nN = cuts.length\\nM = n\\nTime: **O(M2 * N)**\\nSpace: **O(M2)**\\n\\nThis solution will eventually run into a **TLE** :( because we are looping through **0 to n**\\n\\nTo Optimize,\\nRemember that if n = 100000 and cut is 5. We know that any value from `dp[0][0]` to `dp[0][4]` and `dp[0][6]` to `dp[0][100000]` are going to be the same.\\nThis is great waste of space and time. We can optimze this by only **focusing on the cutting points.** \\nRecall that our dp solutions work by `dp[start][end]` without the leftmost, rightmost bound we will be cutting the board only from 1 to 5 in `cuts=[1,3,4,5]`\\n\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int[][] dp = new int[cuts.length+2][cuts.length+2];\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(cuts);\\n        list.add(0);\\n        for (int i = 0; i < cuts.length; i++) {\\n            list.add(cuts[i]);\\n        }\\n        list.add(n);\\n        \\n        for (int i = list.size()-1; i >= 0; i--) {\\n            for (int j = i+1; j < list.size(); j++) {\\n                int dist = list.get(j) - list.get(i);\\n                int min = Integer.MAX_VALUE;\\n                for (int index = 0; index < list.size(); index++) { \\n                    int cut = list.get(index);\\n                    if (cut > list.get(i) && cut < list.get(j)) {\\n                        min = Math.min(min, dp[i][index] + dp[index][j]);\\n                    }\\n                }\\n                if (min != Integer.MAX_VALUE) {\\n                    dp[i][j] = min + dist;\\n                }\\n            }\\n        }\\n        \\n        return dp[0][cuts.length+1];\\n    }\\n}\\n```\\nN = cuts.length\\nTime: O(N lg N) + O(N3) so **O(N3)**\\nSpace: **O(N2)**\\n\\nFinally, last optimization here\\nNotice that in the third for loop where we scan through the **entire** list to find an index that is great than list.get(i)\\nWe can narrow this search by finding the insertion point by using binary search (notice worst case remains the same but the average case will be better)\\n\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int[][] dp = new int[cuts.length+2][cuts.length+2];\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(cuts);\\n        list.add(0);\\n        for (int i = 0; i < cuts.length; i++) {\\n            list.add(cuts[i]);\\n            \\n        }\\n        list.add(n);\\n        \\n        for (int i = list.size()-1; i >= 0; i--) {\\n            for (int j = i+1; j < list.size(); j++) {\\n                int dist = list.get(j) - list.get(i);\\n                int min = Integer.MAX_VALUE;\\n                // System.out.println(i + \" \" + index);\\n                int lo = 0;\\n                int hi = list.size()-1;\\n                while (lo < hi) {\\n                    int mid = lo + (hi - lo)/2;\\n                    if (list.get(mid) > list.get(i)) {\\n                        hi = mid;\\n                    }\\n                    else {\\n                        lo = mid + 1;\\n                    }\\n                }\\n                while (lo < list.size() && list.get(lo) < list.get(j)) {\\n                    int cut = list.get(lo);\\n                    if (cut > list.get(i) && cut < list.get(j)) {\\n                        min = Math.min(min, dp[i][lo] + dp[lo][j]);\\n                    }\\n                    lo++;\\n                }\\n\\n                if (min != Integer.MAX_VALUE) {\\n                    dp[i][j] = min + dist;\\n                }\\n            }\\n        }\\n        return dp[0][cuts.length+1];\\n    }\\n}\\n```\\nN = cuts.length\\nTime: O(N lg N) + O(N2 * N) so **O(N3)**\\nSpace: **O(N2)**\\n",
                "solutionTags": [],
                "code": "```\\nfor (i=n -> 0)\\n\\tfor (j=i+1 -> n)\\n\\tfor (cut : cuts) \\n\\t  if (cut > i && cut < j) // this is necessary so we don\\'t count (0,3) or (3,5) with cut = 3 as cuttable \\n```\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int[][] dp = new int[n+1][n+1];\\n        \\n        for (int i = n; i >= 0; i--) {\\n            for (int j = i+1; j <= n; j++) {\\n                int dist = j-i;\\n                int min = Integer.MAX_VALUE;\\n                for (int cut : cuts) {\\n                    if (cut > i && cut < j) {\\n                        min = Math.min(min, dp[i][cut] + dp[cut][j]);\\n                    }\\n                }\\n                if (min != Integer.MAX_VALUE) {\\n                    dp[i][j] = min + dist;\\n                }\\n            }\\n        }\\n        return dp[0][n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int[][] dp = new int[cuts.length+2][cuts.length+2];\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(cuts);\\n        list.add(0);\\n        for (int i = 0; i < cuts.length; i++) {\\n            list.add(cuts[i]);\\n        }\\n        list.add(n);\\n        \\n        for (int i = list.size()-1; i >= 0; i--) {\\n            for (int j = i+1; j < list.size(); j++) {\\n                int dist = list.get(j) - list.get(i);\\n                int min = Integer.MAX_VALUE;\\n                for (int index = 0; index < list.size(); index++) { \\n                    int cut = list.get(index);\\n                    if (cut > list.get(i) && cut < list.get(j)) {\\n                        min = Math.min(min, dp[i][index] + dp[index][j]);\\n                    }\\n                }\\n                if (min != Integer.MAX_VALUE) {\\n                    dp[i][j] = min + dist;\\n                }\\n            }\\n        }\\n        \\n        return dp[0][cuts.length+1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int[][] dp = new int[cuts.length+2][cuts.length+2];\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(cuts);\\n        list.add(0);\\n        for (int i = 0; i < cuts.length; i++) {\\n            list.add(cuts[i]);\\n            \\n        }\\n        list.add(n);\\n        \\n        for (int i = list.size()-1; i >= 0; i--) {\\n            for (int j = i+1; j < list.size(); j++) {\\n                int dist = list.get(j) - list.get(i);\\n                int min = Integer.MAX_VALUE;\\n                // System.out.println(i + \" \" + index);\\n                int lo = 0;\\n                int hi = list.size()-1;\\n                while (lo < hi) {\\n                    int mid = lo + (hi - lo)/2;\\n                    if (list.get(mid) > list.get(i)) {\\n                        hi = mid;\\n                    }\\n                    else {\\n                        lo = mid + 1;\\n                    }\\n                }\\n                while (lo < list.size() && list.get(lo) < list.get(j)) {\\n                    int cut = list.get(lo);\\n                    if (cut > list.get(i) && cut < list.get(j)) {\\n                        min = Math.min(min, dp[i][lo] + dp[lo][j]);\\n                    }\\n                    lo++;\\n                }\\n\\n                if (min != Integer.MAX_VALUE) {\\n                    dp[i][j] = min + dist;\\n                }\\n            }\\n        }\\n        return dp[0][cuts.length+1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800254,
                "title": "python3-dfs-memo",
                "content": "```python\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        def dfs(start, end):\\n            if (start, end) in cache:\\n                return cache[(start, end)]\\n            min_val = float(\\'inf\\')\\n            cut_found = False\\n            for c in cuts:\\n                if c > start and c < end: # Important!!! check the boundary condition\\n                    left_val = dfs(start, c)\\n                    right_val = dfs(c, end)\\n                    min_val = min(min_val, left_val + right_val)\\n                    cut_found = True\\n                \\n            if not cut_found: # If no cut is found we know that the stick cannot be split more\\n                cache[(start, end)] = 0\\n            else:\\n                cache[(start, end)] = end - start + min_val\\n            return cache[(start, end)]\\n\\n        cache = defaultdict(int)\\n        return dfs(0, n)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        def dfs(start, end):\\n            if (start, end) in cache:\\n                return cache[(start, end)]\\n            min_val = float(\\'inf\\')\\n            cut_found = False\\n            for c in cuts:\\n                if c > start and c < end: # Important!!! check the boundary condition\\n                    left_val = dfs(start, c)\\n                    right_val = dfs(c, end)\\n                    min_val = min(min_val, left_val + right_val)\\n                    cut_found = True\\n                \\n            if not cut_found: # If no cut is found we know that the stick cannot be split more\\n                cache[(start, end)] = 0\\n            else:\\n                cache[(start, end)] = end - start + min_val\\n            return cache[(start, end)]\\n\\n        cache = defaultdict(int)\\n        return dfs(0, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780900,
                "title": "java-16-lines-straightforward-dfs-memo-with-line-by-line-explanation-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/cf96af45-4f7d-42d3-b7fa-b158be3bbf97_1596945780.606848.png)\\n\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n        return dfs(0, n, cuts, new HashMap<>());\\n    }\\n    public int dfs(int l, int r, int[] cuts, Map<String, Integer> memo){\\n        String sig = l+\" \"+r;\\n        if (memo.containsKey(sig)) return memo.get(sig);\\n\\t\\tif (cuts.length==0) return 0;\\n        if (cuts.length==1) return r-l;\\n        int res=Integer.MAX_VALUE;\\n        for (int i=0; i<cuts.length; i++){\\n            int left = dfs(l, cuts[i], Arrays.copyOfRange(cuts, 0, i), memo);\\n            int right = dfs(cuts[i], r, Arrays.copyOfRange(cuts, i+1, cuts.length), memo);\\n            res=Math.min(res, r-l+left+right);\\n        }\\n        memo.put(sig, res);\\n        return res;\\n    }\\n}\\n```\\nHappy Coding!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n        return dfs(0, n, cuts, new HashMap<>());\\n    }\\n    public int dfs(int l, int r, int[] cuts, Map<String, Integer> memo){\\n        String sig = l+\" \"+r;\\n        if (memo.containsKey(sig)) return memo.get(sig);\\n\\t\\tif (cuts.length==0) return 0;\\n        if (cuts.length==1) return r-l;\\n        int res=Integer.MAX_VALUE;\\n        for (int i=0; i<cuts.length; i++){\\n            int left = dfs(l, cuts[i], Arrays.copyOfRange(cuts, 0, i), memo);\\n            int right = dfs(cuts[i], r, Arrays.copyOfRange(cuts, i+1, cuts.length), memo);\\n            res=Math.min(res, r-l+left+right);\\n        }\\n        memo.put(sig, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572033,
                "title": "c-simple-recursive-dp",
                "content": "# Intuition\\nThe idea is to divide the stick into smaller sub-sticks and recursively calculate the minimum cost for each sub-stick.\\n\\n# Approach\\nUse memoization to store previously computed results and avoid redundant calculations.\\n\\n1. Check if the minimum cost for the range (i, j) is already present in mem. If found, return the stored value.\\n2. Iterate through the cuts.\\n3. If the cut[k] position is less than or equal to the left index i, we can\\'t cut with this so skip to the next iteration.\\n4. If the current cut position is greater than or equal to the ending index j, break out of the loop. Array is sorted therefor next cuts will always be out of range.\\n5. Add current cost that is length of substick j-i and recursively calculate the cost for the left and right sub-ranges from cut.\\n6. Update the minimum cost in mem based on the calculated cost.\\n7. If no cuts have been made in the current range (i, j), return 0, That means all the cuts have been made.\\n8. Return the minimum cost stored in mem for the range (i, j).\\n\\n- sort the cuts array \\n\\n# Code\\n```C++\\nclass Solution {\\npublic:\\n    int n;\\n    map<pair<int, int>, int> mem;\\n\\n    int rec(int i, int j, vector<int> &cuts){\\n        if(mem.find({i, j}) != mem.end()) return mem[{i, j}];\\n        \\n        bool flag = false;\\n        for(int k = 0; k<cuts.size(); k++){\\n            if(cuts[k] <= i) continue;\\n            if(cuts[k] >= j) break;\\n\\n            if(!flag){ // if mem[{i, j}] is not initialized\\n                mem[{i, j}] = j-i + rec(i, cuts[k], cuts)+rec(cuts[k], j, cuts);\\n            } else {\\n                mem[{i, j}] = min(mem[{i, j}], j-i + rec(i, cuts[k], cuts)+rec(cuts[k], j, cuts));\\n            } \\n            flag = true;\\n        }\\n\\n        if(!flag) return 0;\\n        return mem[{i, j}];\\n    }\\n\\n    int minCost(int z, vector<int>& cuts) {\\n        n = z;\\n        sort(cuts.begin(), cuts.end());\\n\\n        return rec(0, n, cuts);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int n;\\n    map<pair<int, int>, int> mem;\\n\\n    int rec(int i, int j, vector<int> &cuts){\\n        if(mem.find({i, j}) != mem.end()) return mem[{i, j}];\\n        \\n        bool flag = false;\\n        for(int k = 0; k<cuts.size(); k++){\\n            if(cuts[k] <= i) continue;\\n            if(cuts[k] >= j) break;\\n\\n            if(!flag){ // if mem[{i, j}] is not initialized\\n                mem[{i, j}] = j-i + rec(i, cuts[k], cuts)+rec(cuts[k], j, cuts);\\n            } else {\\n                mem[{i, j}] = min(mem[{i, j}], j-i + rec(i, cuts[k], cuts)+rec(cuts[k], j, cuts));\\n            } \\n            flag = true;\\n        }\\n\\n        if(!flag) return 0;\\n        return mem[{i, j}];\\n    }\\n\\n    int minCost(int z, vector<int>& cuts) {\\n        n = z;\\n        sort(cuts.begin(), cuts.end());\\n\\n        return rec(0, n, cuts);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2432730,
                "title": "minimum-cost-to-cut-a-stick-c-dp-easy-to-understand-striver",
                "content": "```\\n int knapsack(int i, int j, vector<int>&c, vector<vector<int>>&dp){\\n        if(i>j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        long mini = INT_MAX;;\\n        for(int idx =i;idx<=j;idx++){\\n            long cost = c[j+1]-c[i-1] + knapsack(i,idx-1,c,dp)  + knapsack(idx+1,j,c,dp);\\n            mini = min(mini,cost);\\n        }\\n        return dp[i][j] = mini;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        int c = cuts.size();\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(),cuts.end());\\n        vector<vector<int>>dp(c+1,vector<int>(c+1,-1));\\n        return knapsack(1,c,cuts,dp);\\n    }\\n```\\nIf it Helps, Kindly Do **Upvote**\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n int knapsack(int i, int j, vector<int>&c, vector<vector<int>>&dp){\\n        if(i>j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        long mini = INT_MAX;;\\n        for(int idx =i;idx<=j;idx++){\\n            long cost = c[j+1]-c[i-1] + knapsack(i,idx-1,c,dp)  + knapsack(idx+1,j,c,dp);\\n            mini = min(mini,cost);\\n        }\\n        return dp[i][j] = mini;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        int c = cuts.size();\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(),cuts.end());\\n        vector<vector<int>>dp(c+1,vector<int>(c+1,-1));\\n        return knapsack(1,c,cuts,dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1491200,
                "title": "java-dp-try-my-best-to-explain-codes-line-by-line",
                "content": "This problem should be in the most difficult problem set of the interview :( \\n\\nIf you can be clear of what i, j, k in the for-loop means, then it should not be difficult to understand.\\n\\nTime: O(n^3), Space: O(n^2)\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        // Sort the array so that the cut index is in ascending order\\n        Arrays.sort(cuts);\\n        \\n        // Use an array to represent a wood as the example described,\\n        // input: n = 7, cuts = [1,3,4,5]\\n        // wood: [0, 1, 3, 4, 5, 7]\\n        int length = cuts.length + 2;\\n        int[] wood = new int[length];\\n        wood[length - 1] = n;\\n        \\n        for (int i = 0; i < cuts.length; i++) {\\n            wood[i + 1] = cuts[i];\\n        }\\n        \\n        // This is a 2-D DP problem.\\n        // dp[i][j] represents the minimum cost of cutting the wood from index i to j\\n        int[][] dp = new int[length][length];\\n        \\n        // Approach:\\n        // First is to calculate the min cost of all subwoods with length 1,\\n        // Then calculate all the min cost of all subwoods with length 2, based on length 1;\\n        // Then calculate all the min cost of all subwoods with length 3, based on length 1 and 2;\\n        // ... (leave this work to for-loop ;))\\n        // Until get the min cost of subwood with max length, which is the final solution!\\n        //\\n        // Base case: subwood length 1: such as wood[i] to wood[i + 1].\\n        // Since the subwood with length 1 is individable, so the cost is 0: dp[i][i + 1] = 0.\\n        \\n        // ***Importent***\\n        // i: sub-wood length, stating at length = 2.\\n        for (int i = 2; i < length; i++) {\\n            // ***Important***\\n            // j: begin idx of subwood\\n            for (int j = 0; j < length - i; j++) { \\n                // So for the current subwood, the begin index is i, then the end index is\\n                // i + j: beginIdx + subwoodLength.\\n                \\n                // Init current cost to max int, since it calculates the min cost.\\n                dp[j][j + i] = Integer.MAX_VALUE;\\n                \\n                // Calculate the cost of making ONE cut on the current subwood.\\n                // The cost is the \"length\" or \"weight\" of current subwood,\\n                // calculated by wood[end] - wood[begin].\\n                // This value is fixed on making ONE cut, no matter cutting at which slot.\\n                int currCost = wood[j + i] - wood[j];\\n                \\n                // ***Important***\\n                // k: index of where to make ONE cut on the current subwood.\\n                //\\n                // If we make one cut on the subwood, then it will generate sub-subwoodA\\n                // and sub-subwoodB. So the problem breaks down to:\\n                // Possible min cut on current subwood = current cut cost +\\n                //    cutting sub-subwoodA min cost + cutting sub-subwoodB min cost\\n                //\\n                // How to get cutting sub-subwoodA and sub-subwoodB min cost?\\n                // Read from dp[][] :)\\n                //\\n                // Try all possible ONE cut on the current subwood, then update the min cost of \\n                // current subwood.\\n                //\\n                // We confirm the the current sub wood indexed from j to j + i.\\n                // So the first valid cut is at j + i, and the last valid cut is at j + i - 1.\\n                \\n                for (int k = j + 1; k < j + i; k++) { \\n                    dp[j][j + i] = Math.min(dp[j][j + i],\\n                                           (dp[j][k] + dp[k][j + i] + currCost));\\n                }\\n            }\\n        }\\n        \\n        return dp[0][length - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        // Sort the array so that the cut index is in ascending order\\n        Arrays.sort(cuts);\\n        \\n        // Use an array to represent a wood as the example described,\\n        // input: n = 7, cuts = [1,3,4,5]\\n        // wood: [0, 1, 3, 4, 5, 7]\\n        int length = cuts.length + 2;\\n        int[] wood = new int[length];\\n        wood[length - 1] = n;\\n        \\n        for (int i = 0; i < cuts.length; i++) {\\n            wood[i + 1] = cuts[i];\\n        }\\n        \\n        // This is a 2-D DP problem.\\n        // dp[i][j] represents the minimum cost of cutting the wood from index i to j\\n        int[][] dp = new int[length][length];\\n        \\n        // Approach:\\n        // First is to calculate the min cost of all subwoods with length 1,\\n        // Then calculate all the min cost of all subwoods with length 2, based on length 1;\\n        // Then calculate all the min cost of all subwoods with length 3, based on length 1 and 2;\\n        // ... (leave this work to for-loop ;))\\n        // Until get the min cost of subwood with max length, which is the final solution!\\n        //\\n        // Base case: subwood length 1: such as wood[i] to wood[i + 1].\\n        // Since the subwood with length 1 is individable, so the cost is 0: dp[i][i + 1] = 0.\\n        \\n        // ***Importent***\\n        // i: sub-wood length, stating at length = 2.\\n        for (int i = 2; i < length; i++) {\\n            // ***Important***\\n            // j: begin idx of subwood\\n            for (int j = 0; j < length - i; j++) { \\n                // So for the current subwood, the begin index is i, then the end index is\\n                // i + j: beginIdx + subwoodLength.\\n                \\n                // Init current cost to max int, since it calculates the min cost.\\n                dp[j][j + i] = Integer.MAX_VALUE;\\n                \\n                // Calculate the cost of making ONE cut on the current subwood.\\n                // The cost is the \"length\" or \"weight\" of current subwood,\\n                // calculated by wood[end] - wood[begin].\\n                // This value is fixed on making ONE cut, no matter cutting at which slot.\\n                int currCost = wood[j + i] - wood[j];\\n                \\n                // ***Important***\\n                // k: index of where to make ONE cut on the current subwood.\\n                //\\n                // If we make one cut on the subwood, then it will generate sub-subwoodA\\n                // and sub-subwoodB. So the problem breaks down to:\\n                // Possible min cut on current subwood = current cut cost +\\n                //    cutting sub-subwoodA min cost + cutting sub-subwoodB min cost\\n                //\\n                // How to get cutting sub-subwoodA and sub-subwoodB min cost?\\n                // Read from dp[][] :)\\n                //\\n                // Try all possible ONE cut on the current subwood, then update the min cost of \\n                // current subwood.\\n                //\\n                // We confirm the the current sub wood indexed from j to j + i.\\n                // So the first valid cut is at j + i, and the last valid cut is at j + i - 1.\\n                \\n                for (int k = j + 1; k < j + i; k++) { \\n                    dp[j][j + i] = Math.min(dp[j][j + i],\\n                                           (dp[j][k] + dp[k][j + i] + currCost));\\n                }\\n            }\\n        }\\n        \\n        return dp[0][length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403565,
                "title": "c-mcm-pattern-in-aditya-verma-format-easy-inline-explaination-memo",
                "content": "```\\n    /* \\n        Here i and j are the endpoints of stick (used for calculating cost at every state by computing stick len) \\n        whereas start and end are pointers to mark the boundaries over cuts vector\\n    */\\n    \\n    int solve (vector<int> & cuts, int i, int j, int start, int end, vector<vector<int>> & dp){\\n        \\n        if(start>end) return 0;     // --> Base condition is when no cutpoints left\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k=start; k<=end; k++){\\n            \\n            int temp = solve(cuts, i, cuts[k], start, k-1, dp) + solve(cuts, cuts[k], j, k+1, end, dp) + j-i;\\n            ans = min(ans, temp);\\n        }\\n        \\n        return dp[start][end] = ans;\\n    }\\n    \\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        int len = cuts.size();\\n        \\n        /* We sort the cuts vector so we can easily itearte for cut points for any part of the stick */\\n        \\n        sort(cuts.begin(), cuts.end());   \\n        \\n        vector<vector<int>> dp (len, vector<int> (len, -1));\\n        return solve (cuts, 0, n, 0, len-1, dp);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /* \\n        Here i and j are the endpoints of stick (used for calculating cost at every state by computing stick len) \\n        whereas start and end are pointers to mark the boundaries over cuts vector\\n    */\\n    \\n    int solve (vector<int> & cuts, int i, int j, int start, int end, vector<vector<int>> & dp){\\n        \\n        if(start>end) return 0;     // --> Base condition is when no cutpoints left\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k=start; k<=end; k++){\\n            \\n            int temp = solve(cuts, i, cuts[k], start, k-1, dp) + solve(cuts, cuts[k], j, k+1, end, dp) + j-i;\\n            ans = min(ans, temp);\\n        }\\n        \\n        return dp[start][end] = ans;\\n    }\\n    \\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        int len = cuts.size();\\n        \\n        /* We sort the cuts vector so we can easily itearte for cut points for any part of the stick */\\n        \\n        sort(cuts.begin(), cuts.end());   \\n        \\n        vector<vector<int>> dp (len, vector<int> (len, -1));\\n        return solve (cuts, 0, n, 0, len-1, dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1357746,
                "title": "easy-c-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& c) {\\n        //sort the cut values\\n        sort(c.begin(),c.end());\\n        \\n        int len=c.size();\\n        vector<vector<int>> dp(len,vector<int>(len,-1));\\n        \\n        dfs(c,0,len-1,0,n,dp);\\n        return dp[0][len-1];\\n    }\\n    \\n    //statInd is the starting index value in c\\n    //endInd is the ending index value in c\\n    //startVal is the current starting value in the stick\\n    //endVal is the current ending value in the stick\\n    int dfs(vector<int>& c,int startInd,int endInd,int startVal,int endVal,vector<vector<int>>& dp)\\n    {\\n        if(startInd>endInd)\\n            return 0;\\n        //if the  sub problem is already calculated , return it\\n        if(dp[startInd][endInd]!=-1)\\n            return dp[startInd][endInd];\\n        \\n        int ans=INT_MAX;\\n        //the current len of the stick is the current cost\\n        int currCost=endVal-startVal;\\n        for(int i=startInd;i<=endInd;i++)\\n        {\\n            //perform a cut at c[i] and get the min cost among all those\\n            \\n            ans=min(ans,currLen+dfs(c,startInd,i-1,startVal,c[i],dp) + dfs(c,i+1,endInd,c[i],endVal,dp));\\n        }\\n        dp[startInd][endInd]=ans;\\n        return dp[startInd][endInd];\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& c) {\\n        //sort the cut values\\n        sort(c.begin(),c.end());\\n        \\n        int len=c.size();\\n        vector<vector<int>> dp(len,vector<int>(len,-1));\\n        \\n        dfs(c,0,len-1,0,n,dp);\\n        return dp[0][len-1];\\n    }\\n    \\n    //statInd is the starting index value in c\\n    //endInd is the ending index value in c\\n    //startVal is the current starting value in the stick\\n    //endVal is the current ending value in the stick\\n    int dfs(vector<int>& c,int startInd,int endInd,int startVal,int endVal,vector<vector<int>>& dp)\\n    {\\n        if(startInd>endInd)\\n            return 0;\\n        //if the  sub problem is already calculated , return it\\n        if(dp[startInd][endInd]!=-1)\\n            return dp[startInd][endInd];\\n        \\n        int ans=INT_MAX;\\n        //the current len of the stick is the current cost\\n        int currCost=endVal-startVal;\\n        for(int i=startInd;i<=endInd;i++)\\n        {\\n            //perform a cut at c[i] and get the min cost among all those\\n            \\n            ans=min(ans,currLen+dfs(c,startInd,i-1,startVal,c[i],dp) + dfs(c,i+1,endInd,c[i],endVal,dp));\\n        }\\n        dp[startInd][endInd]=ans;\\n        return dp[startInd][endInd];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572334,
                "title": "java-solution-for-minimum-cost-to-cut-a-stick-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use dynamic programming to find the minimum cost of the cuts.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a new array newCuts with the starting and ending points of the stick, and sort it in ascending order.\\n1. Initialize a 2D array dp to store the minimum costs for different segments of the stick.\\n1. Iterate through different lengths of segments and calculate the minimum cost by considering different cut positions within each segment.\\n1. Return the minimum cost stored in dp[0][newCuts.length - 1].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n^3), where n is the length of the newCuts array. The nested loops contribute to this complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(n^2) because of the dp array, which has dimensions of newCuts.length by newCuts.length.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int[] newCuts = new int[cuts.length + 2];\\n        newCuts[0] = 0;\\n        newCuts[newCuts.length - 1] = n;\\n        System.arraycopy(cuts, 0, newCuts, 1, cuts.length);\\n        Arrays.sort(newCuts);\\n        \\n        int[][] dp = new int[newCuts.length][newCuts.length];\\n        for (int len = 2; len < newCuts.length; len++) {\\n            for (int i = 0; i + len < newCuts.length; i++) {\\n                int j = i + len;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = i + 1; k < j; k++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + newCuts[j] - newCuts[i]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][newCuts.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int[] newCuts = new int[cuts.length + 2];\\n        newCuts[0] = 0;\\n        newCuts[newCuts.length - 1] = n;\\n        System.arraycopy(cuts, 0, newCuts, 1, cuts.length);\\n        Arrays.sort(newCuts);\\n        \\n        int[][] dp = new int[newCuts.length][newCuts.length];\\n        for (int len = 2; len < newCuts.length; len++) {\\n            for (int i = 0; i + len < newCuts.length; i++) {\\n                int j = i + len;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = i + 1; k < j; k++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + newCuts[j] - newCuts[i]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][newCuts.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571552,
                "title": "golang-recursive-memoization-top-down-and-iterative-bottom-up-with-explanation",
                "content": "# Intuition\\n\\nI\\'ll use name $L$ for the length of the original stick.\\n\\nFirstly you could imagine that before start someone already cut stick at the coordinates $0$ and $L$.\\n\\nNow let\\'s think: what will happen if you cut stick at the $x$ coordinate?\\n\\n- you will pay $L - 0$ for this cut;\\n\\n- you need to **independently** cut two sticks:\\n    - from $0$ to $x$;\\n    \\n    - from $x$ to $L$.\\n     \\nDo you see any similarities with the original problem?\\n\\n# Basic approach\\n\\n- Add $0$ and $L$ to the $cuts$ and **sort** it.\\n\\n- Use dynamic programming $dp[S][E]$ - minimal cost of cutting stick, that starts at the $S$-th cut and ends at the $E$-th cut.\\n\\n- Let\\'s $N$ be the amount of cuts (including $0$ and $L$). \\n\\n- Answer: $dp[1][N]$.\\n\\n- Initial state: $dp[S][S + 1] = 0$ for $S = 1 \\\\dots N - 1$.\\n\\n- Formula: $dp[S][E] = (cuts[E] - cuts[S]) + \\\\min_{S < M < E}(dp[S][M] + dp[M][E])$:\\n\\n    - $cuts[E] - cuts[S]$ is the cost of the current split;\\n    - $dp[S][M] + dp[M][E]$ is the cost of cutting two parts after the split;\\n\\n# Recursive approach\\n\\n- Recursion starts at the $(0, N)$.\\n\\n- Recursion stops at the $S + 1 = E$.\\n\\n- Use memoization to calculate each state exactly once (2D array is enough).\\n\\n# Iterative approach\\n\\n- When you calculate $(S, E)$, you need to know all $(S, M)$ and $(M, E)$.\\n\\n- $M - S$ and $E - M$ are smaller than $E - S$.\\n\\nOne way to ensure this condition is:\\n\\n- iterate over $D = E - S$ from $2$ to $N - 1$;\\n\\n- iterate over $E$ from $D$ to $N$ and $S = E - D$.\\n\\n# Complexity\\n- Time complexity: $O(N^3)$:\\n\\n    - There are $O(N^2)$ states $(S, E)$;\\n    \\n    - Each state is calculated in $O(E - S)$ steps.\\n\\n- Space complexity: $O(N^2)$\\n\\n# Recursive code\\n```\\nfunc minCost(size int, cuts []int) int {\\n    sort.Ints(cuts)\\n    cuts = append([]int{0}, cuts...)\\n    cuts = append(cuts, size)\\n\\n    n := len(cuts) - 1\\n\\n    inf := size * (n + 1)\\n\\n    dp := make([][]int, n)\\n    for start := range dp {\\n        dp[start] = make([]int, n + 1)\\n        for end := start; end <= n; end++ {\\n            dp[start][end] = inf\\n        }\\n\\n        dp[start][start + 1] = 0\\n    }\\n\\n    var calculate func(int, int) int\\n    calculate = func(start, end int) int {\\n        if dp[start][end] < inf {\\n            return dp[start][end]\\n        }\\n\\n        length := cuts[end] - cuts[start]\\n        for mid := start + 1; mid < end; mid++ {\\n            cost := calculate(start, mid) + calculate(mid, end) + length\\n            if dp[start][end] > cost {\\n                dp[start][end] = cost\\n            }\\n        }\\n\\n        return dp[start][end]\\n    }\\n\\n    return calculate(0, n)\\n}\\n```\\n\\n# Iterative code\\n```\\nfunc minCost(size int, cuts []int) int {\\n    sort.Ints(cuts)\\n    cuts = append([]int{0}, cuts...)\\n    cuts = append(cuts, size)\\n\\n    n := len(cuts) - 1\\n\\n    inf := size * (n + 1)\\n\\n    dp := make([][]int, n)\\n    for start := range dp {\\n        dp[start] = make([]int, n + 1)\\n        for end := start; end <= n; end++ {\\n            dp[start][end] = inf\\n        }\\n\\n        dp[start][start + 1] = 0\\n    }\\n\\n    for shift := 2; shift <= n; shift++ {\\n        for end := shift; end <= n; end++ {\\n            start := end - shift\\n            length := cuts[end] - cuts[start]\\n            for mid := start + 1; mid < end; mid++ {\\n                cost := dp[start][mid] + dp[mid][end] + length\\n                if dp[start][end] > cost {\\n                    dp[start][end] = cost\\n                }\\n            }\\n        }\\n    }\\n\\n    return dp[0][n]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nfunc minCost(size int, cuts []int) int {\\n    sort.Ints(cuts)\\n    cuts = append([]int{0}, cuts...)\\n    cuts = append(cuts, size)\\n\\n    n := len(cuts) - 1\\n\\n    inf := size * (n + 1)\\n\\n    dp := make([][]int, n)\\n    for start := range dp {\\n        dp[start] = make([]int, n + 1)\\n        for end := start; end <= n; end++ {\\n            dp[start][end] = inf\\n        }\\n\\n        dp[start][start + 1] = 0\\n    }\\n\\n    var calculate func(int, int) int\\n    calculate = func(start, end int) int {\\n        if dp[start][end] < inf {\\n            return dp[start][end]\\n        }\\n\\n        length := cuts[end] - cuts[start]\\n        for mid := start + 1; mid < end; mid++ {\\n            cost := calculate(start, mid) + calculate(mid, end) + length\\n            if dp[start][end] > cost {\\n                dp[start][end] = cost\\n            }\\n        }\\n\\n        return dp[start][end]\\n    }\\n\\n    return calculate(0, n)\\n}\\n```\n```\\nfunc minCost(size int, cuts []int) int {\\n    sort.Ints(cuts)\\n    cuts = append([]int{0}, cuts...)\\n    cuts = append(cuts, size)\\n\\n    n := len(cuts) - 1\\n\\n    inf := size * (n + 1)\\n\\n    dp := make([][]int, n)\\n    for start := range dp {\\n        dp[start] = make([]int, n + 1)\\n        for end := start; end <= n; end++ {\\n            dp[start][end] = inf\\n        }\\n\\n        dp[start][start + 1] = 0\\n    }\\n\\n    for shift := 2; shift <= n; shift++ {\\n        for end := shift; end <= n; end++ {\\n            start := end - shift\\n            length := cuts[end] - cuts[start]\\n            for mid := start + 1; mid < end; mid++ {\\n                cost := dp[start][mid] + dp[mid][end] + length\\n                if dp[start][end] > cost {\\n                    dp[start][end] = cost\\n                }\\n            }\\n        }\\n    }\\n\\n    return dp[0][n]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571302,
                "title": "c-dp-recursion-memoization-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved using a recursive approach with memoization. The idea is to consider each possible cut position and recursively calculate the minimum cost for the remaining subproblems.\\n\\nThe solve function takes the current start position s, end position e, cuts array, and indices l and r denoting the boundaries of the current subproblem.\\n\\nBase Case: If l > r, it means there are no cuts to be made within the current subproblem. In this case, the cost is 0, as no further cuts are needed. So, the function returns 0.\\n\\nMemoization: The next base case if (dp[l][r] != -1) checks if the minimum cost for the current subproblem has already been calculated and stored in the dp array. If the value is already calculated, it directly returns the precalculated value. This avoids redundant calculations and improves the efficiency of the solution.\\n\\nFinding the Minimum Cost: The variable cost is initialized with a large value (1e9) to store the minimum cost for the current subproblem.\\n\\nIterating over Possible Cut Positions: The code uses a loop to iterate over each possible cut position i within the range [l, r]. For each i, it calculates the cost of cutting the stick at position cuts[i].\\n\\nRecursive Calls: The function recursively calls solve to calculate the costs for the left and right subproblems. The left subproblem is defined from position s to cuts[i] and the right subproblem from cuts[i] to e. The recursive calls are made with updated boundaries l and r as well.\\n\\nCalculating Current Cost: The current cost is calculated as the sum of the cost of the current cut (e - s) and the costs of the left and right subproblems. This represents the cost of cutting the stick at position cuts[i] and the subsequent costs of cutting the remaining subproblems.\\n\\nUpdating Minimum Cost: The code compares the current cost with the previous minimum cost and updates cost if the current cost is lower.\\n\\nMemoization: Finally, the minimum cost cost for the current subproblem is stored in the dp array at indices [l][r] for future use.\\n\\nReturning Minimum Cost: After iterating through all possible cut positions, the minimum cost of cutting the stick from s to e is stored in dp[0][cuts.size()-1]. The solve function returns this minimum cost.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given code is O(n^3), where n is the size of the cuts array.\\n\\nThe main factor contributing to the time complexity is the nested loop in the solve function, which iterates over each possible cut position. Since the number of cuts can be at most n-1 (as the stick is cut into n pieces), the loop runs in O(n) time.\\n\\nInside the loop, there are two recursive calls to the solve function, which are performed for each cut position. The number of possible cut positions for each subproblem ranges from 0 to n-1. Therefore, the recursive calls are made a maximum of n times.\\n\\nConsidering the worst-case scenario where each subproblem has n-1 possible cut positions, the overall time complexity of the recursive calls becomes O(n) * O(n) = O(n^2).\\n\\nAdditionally, there is a sorting operation performed on the cuts array, which takes O(n log n) time complexity.\\n\\nTherefore, the total time complexity of the given code is O(n^3) = O(n) * O(n) * O(n log n), dominated by the nested loops and the sorting operation.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the given code is O(n^2),\\n# Recursion Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int s, int e, vector<int>& cuts, int l, int r){\\n        if(l > r) return 0;\\n        \\n        int cost = 1e9;\\n        \\n        for(int i=l; i<=r; i++){\\n            int left_cost = solve(s, cuts[i], cuts, l, i-1);\\n            int right_cost = solve(cuts[i], e, cuts, i+1, r);\\n            int curr_cost = (e - s) + left_cost + right_cost;\\n            cost = min(cost,curr_cost);\\n        }\\n        \\n        return cost;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(),cuts.end());\\n        return solve(0, n, cuts, 0, cuts.size()-1);\\n    }\\n};\\n```\\n\\n# Memoization Code\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int s, int e, vector<int>& cuts, int l, int r){\\n        if(l > r) return 0;\\n        \\n        if(dp[l][r] != -1) return dp[l][r];\\n        \\n        int cost = 1e9;\\n        \\n        for(int i=l; i<=r; i++){\\n            int left_cost = solve(s, cuts[i], cuts, l, i-1);\\n            int right_cost = solve(cuts[i], e, cuts, i+1, r);\\n            int curr_cost = (e - s) + left_cost + right_cost;\\n            cost = min(cost,curr_cost);\\n        }\\n        \\n        return dp[l][r] = cost;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(cuts.begin(),cuts.end());\\n        return solve(0, n, cuts, 0, cuts.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int s, int e, vector<int>& cuts, int l, int r){\\n        if(l > r) return 0;\\n        \\n        int cost = 1e9;\\n        \\n        for(int i=l; i<=r; i++){\\n            int left_cost = solve(s, cuts[i], cuts, l, i-1);\\n            int right_cost = solve(cuts[i], e, cuts, i+1, r);\\n            int curr_cost = (e - s) + left_cost + right_cost;\\n            cost = min(cost,curr_cost);\\n        }\\n        \\n        return cost;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(),cuts.end());\\n        return solve(0, n, cuts, 0, cuts.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int s, int e, vector<int>& cuts, int l, int r){\\n        if(l > r) return 0;\\n        \\n        if(dp[l][r] != -1) return dp[l][r];\\n        \\n        int cost = 1e9;\\n        \\n        for(int i=l; i<=r; i++){\\n            int left_cost = solve(s, cuts[i], cuts, l, i-1);\\n            int right_cost = solve(cuts[i], e, cuts, i+1, r);\\n            int curr_cost = (e - s) + left_cost + right_cost;\\n            cost = min(cost,curr_cost);\\n        }\\n        \\n        return dp[l][r] = cost;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(cuts.begin(),cuts.end());\\n        return solve(0, n, cuts, 0, cuts.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570116,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int recursion(int l, int r, int left, int right, vector<int> &cuts)\\n    {\\n        if (r < l) return 0;\\n        if (dp[l][r] != -1) return dp[l][r];\\n        int answer = INT_MAX;\\n        for (int i = l; i <= r; i++)\\n        {\\n            int length = (right - left) ;\\n            int current = length + recursion(l, i - 1, left, cuts[i], cuts) + recursion(i + 1, r, cuts[i], right, cuts);\\n            answer = min(answer, current);\\n        }\\n        return dp[l][r] = answer;\\n    }\\n    int minCost(int n, vector<int> &cuts)\\n    {\\n        dp = vector<vector<int>>(cuts.size() + 4, vector<int>(cuts.size() + 2, -1));\\n        sort(cuts.begin(), cuts.end());\\n        return recursion(0, cuts.size() - 1, 0, n, cuts);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int recursion(int l, int r, int left, int right, vector<int> &cuts)\\n    {\\n        if (r < l) return 0;\\n        if (dp[l][r] != -1) return dp[l][r];\\n        int answer = INT_MAX;\\n        for (int i = l; i <= r; i++)\\n        {\\n            int length = (right - left) ;\\n            int current = length + recursion(l, i - 1, left, cuts[i], cuts) + recursion(i + 1, r, cuts[i], right, cuts);\\n            answer = min(answer, current);\\n        }\\n        return dp[l][r] = answer;\\n    }\\n    int minCost(int n, vector<int> &cuts)\\n    {\\n        dp = vector<vector<int>>(cuts.size() + 4, vector<int>(cuts.size() + 2, -1));\\n        sort(cuts.begin(), cuts.end());\\n        return recursion(0, cuts.size() - 1, 0, n, cuts);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570052,
                "title": "c-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[109][109];\\n    int solve(int l, int r, int i, int j, vector<int>&cuts) {\\n            if(l>=r) return 0;\\n            if(i>j) return 0;\\n            if(i==j) return r-l;\\n            if(dp[i][j]!=-1) return dp[i][j];\\n            int res = INT_MAX;\\n            for(int k=i; k<=j ;k++) {\\n                long int curr_res = r-l + solve(l, cuts[k], i, k-1, cuts) + solve(cuts[k],r, k+1, j, cuts);\\n                res = min(res, (int)curr_res);\\n            }\\n            return dp[i][j]=res;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(), cuts.end());\\n        memset(dp,-1, sizeof(dp));\\n        return solve(0, n, 0, cuts.size()-1, cuts);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[109][109];\\n    int solve(int l, int r, int i, int j, vector<int>&cuts) {\\n            if(l>=r) return 0;\\n            if(i>j) return 0;\\n            if(i==j) return r-l;\\n            if(dp[i][j]!=-1) return dp[i][j];\\n            int res = INT_MAX;\\n            for(int k=i; k<=j ;k++) {\\n                long int curr_res = r-l + solve(l, cuts[k], i, k-1, cuts) + solve(cuts[k],r, k+1, j, cuts);\\n                res = min(res, (int)curr_res);\\n            }\\n            return dp[i][j]=res;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(), cuts.end());\\n        memset(dp,-1, sizeof(dp));\\n        return solve(0, n, 0, cuts.size()-1, cuts);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618857,
                "title": "memorization-solution-using-python-striver-s-approach",
                "content": "```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        def f(i,j,dp):\\n            if i>j:\\n                return 0\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            mini=float(\\'inf\\')\\n            for ind in range(i,j+1):\\n                cost=cuts[j+1]-cuts[i-1]+f(i,ind-1,dp)+f(ind+1,j,dp)\\n                mini=min(mini,cost)\\n            dp[i][j]=mini\\n            return dp[i][j]\\n               \\n        c=len(cuts)\\n        dp=[[-1 for _ in range(c+1)]for _ in range(c+1)]\\n        cuts.append(n)\\n        cuts.insert(0,0)\\n        cuts.sort()\\n        return f(1,c,dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        def f(i,j,dp):\\n            if i>j:\\n                return 0\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            mini=float(\\'inf\\')\\n            for ind in range(i,j+1):\\n                cost=cuts[j+1]-cuts[i-1]+f(i,ind-1,dp)+f(ind+1,j,dp)\\n                mini=min(mini,cost)\\n            dp[i][j]=mini\\n            return dp[i][j]\\n               \\n        c=len(cuts)\\n        dp=[[-1 for _ in range(c+1)]for _ in range(c+1)]\\n        cuts.append(n)\\n        cuts.insert(0,0)\\n        cuts.sort()\\n        return f(1,c,dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337713,
                "title": "c-memoization-tabulation-time-complexity-notes",
                "content": "**Memoization:**\\n`TC = O(n^3), SC = O(n^2) + stack space`, n = cuts length\\n```\\nint solve(int i, int j, vector<int> &cuts, vector<vector<int>> &dp) {\\n\\tif(i > j) return 0;\\n\\tif(dp[i][j] != -1) return dp[i][j];\\n\\tint result = INT_MAX;\\n\\tfor(int k = i; k <= j; k++) {\\n\\t\\tint temp = cuts[j + 1] - cuts[i - 1] + \\n\\t\\t\\tsolve(i, k - 1, cuts, dp) + solve(k + 1, j, cuts, dp);\\n\\t\\tresult = min(result, temp);\\n\\t}\\n\\treturn dp[i][j] = result;\\n}\\n\\nint minCost(int n, vector<int>& cuts) {\\n\\tcuts.insert(cuts.begin(), 0);\\n\\tcuts.push_back(n);\\n\\tsort(cuts.begin(), cuts.end());\\n\\tvector<vector<int>> dp(cuts.size(), vector<int>(cuts.size(), -1));\\n\\treturn solve(1, cuts.size() - 2, cuts, dp);\\n}\\n```\\n\\n**Tabulation:**\\n`TC = O(n^3), SC = O(n^2)`\\n```\\nint minCost(int n, vector<int>& cuts) {\\n\\tcuts.insert(cuts.begin(), 0);\\n\\tcuts.push_back(n);\\n\\tsort(cuts.begin(), cuts.end());\\n\\tn = cuts.size();\\n\\tvector<vector<int>> dp(cuts.size(), vector<int>(n - 1, 0));\\n\\tfor(int x = 1; x < n - 1; x++) {\\n\\t\\tint i = 1, j = x;\\n\\t\\twhile(j < n - 1) {\\n\\t\\t\\tint result = INT_MAX;\\n\\t\\t\\tfor(int k = i; k <= j; k++) {\\n\\t\\t\\t\\tint temp = cuts[j + 1] - cuts[i - 1] + dp[i][k - 1] + dp[k + 1][j];\\n\\t\\t\\t\\tresult = min(result, temp);\\n\\t\\t\\t}\\n\\t\\t\\tdp[i][j] = result;\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\treturn dp[1][n - 2];\\n}\\n```\\n\\n**Notes:**\\n![image](https://assets.leetcode.com/users/images/bc5706ba-9ab1-4cba-badf-e7e8449bf09d_1658858363.619413.jpeg)\\n![image](https://assets.leetcode.com/users/images/0b12e4ab-eefe-4ccb-9392-750db26a00f7_1658858368.5872157.jpeg)\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint solve(int i, int j, vector<int> &cuts, vector<vector<int>> &dp) {\\n\\tif(i > j) return 0;\\n\\tif(dp[i][j] != -1) return dp[i][j];\\n\\tint result = INT_MAX;\\n\\tfor(int k = i; k <= j; k++) {\\n\\t\\tint temp = cuts[j + 1] - cuts[i - 1] + \\n\\t\\t\\tsolve(i, k - 1, cuts, dp) + solve(k + 1, j, cuts, dp);\\n\\t\\tresult = min(result, temp);\\n\\t}\\n\\treturn dp[i][j] = result;\\n}\\n\\nint minCost(int n, vector<int>& cuts) {\\n\\tcuts.insert(cuts.begin(), 0);\\n\\tcuts.push_back(n);\\n\\tsort(cuts.begin(), cuts.end());\\n\\tvector<vector<int>> dp(cuts.size(), vector<int>(cuts.size(), -1));\\n\\treturn solve(1, cuts.size() - 2, cuts, dp);\\n}\\n```\n```\\nint minCost(int n, vector<int>& cuts) {\\n\\tcuts.insert(cuts.begin(), 0);\\n\\tcuts.push_back(n);\\n\\tsort(cuts.begin(), cuts.end());\\n\\tn = cuts.size();\\n\\tvector<vector<int>> dp(cuts.size(), vector<int>(n - 1, 0));\\n\\tfor(int x = 1; x < n - 1; x++) {\\n\\t\\tint i = 1, j = x;\\n\\t\\twhile(j < n - 1) {\\n\\t\\t\\tint result = INT_MAX;\\n\\t\\t\\tfor(int k = i; k <= j; k++) {\\n\\t\\t\\t\\tint temp = cuts[j + 1] - cuts[i - 1] + dp[i][k - 1] + dp[k + 1][j];\\n\\t\\t\\t\\tresult = min(result, temp);\\n\\t\\t\\t}\\n\\t\\t\\tdp[i][j] = result;\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\treturn dp[1][n - 2];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1284577,
                "title": "sorting-is-the-key-dp-cpp",
                "content": "```\\nclass Solution {\\npublic:int dp[102][102];\\n    int minCost(int n, vector<int>& cuts){\\n        memset(dp,-1,sizeof(dp));\\n        sort(cuts.begin(),cuts.end());\\n        int m=cuts.size();\\n        if(m==1)\\n            return n;\\n        return solve(0,m-1,n,cuts,0,n);\\n    }\\n    int solve(int i,int j,int n,vector<int>& cuts,int x,int y){\\n        if(i==j)\\n            return y-x;\\n        if(i>j)\\n           return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int mn=INT_MAX;\\n            for(int k=i;k<=j;k++){\\n                int temp=y-x+solve(i,k-1,n,cuts,x,cuts[k])+solve(k+1,j,n,cuts,cuts[k],y);\\n        mn=min(temp,mn);\\n            }\\n    return dp[i][j]=mn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:int dp[102][102];\\n    int minCost(int n, vector<int>& cuts){\\n        memset(dp,-1,sizeof(dp));\\n        sort(cuts.begin(),cuts.end());\\n        int m=cuts.size();\\n        if(m==1)\\n            return n;\\n        return solve(0,m-1,n,cuts,0,n);\\n    }\\n    int solve(int i,int j,int n,vector<int>& cuts,int x,int y){\\n        if(i==j)\\n            return y-x;\\n        if(i>j)\\n           return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int mn=INT_MAX;\\n            for(int k=i;k<=j;k++){\\n                int temp=y-x+solve(i,k-1,n,cuts,x,cuts[k])+solve(k+1,j,n,cuts,cuts[k],y);\\n        mn=min(temp,mn);\\n            }\\n    return dp[i][j]=mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266290,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[103][103];\\n    int helper(int i,vector<int>&cuts,int j)\\n    {\\n        if(j-i<=1)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int k = i+1;k<j;k++)\\n        {\\n            int temp = helper(i,cuts,k)+helper(k,cuts,j)+(cuts[j]-cuts[i]);\\n            ans = min(ans,temp);\\n        }\\n        dp[i][j] = ans;\\n        return ans;\\n            \\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        for(int i = 0;i<103;i++)\\n            for(int j = 0;j<103;j++)\\n                dp[i][j] = -1;\\n        cuts.insert(cuts.begin(),0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(),cuts.end());\\n        return helper(0,cuts,cuts.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[103][103];\\n    int helper(int i,vector<int>&cuts,int j)\\n    {\\n        if(j-i<=1)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int k = i+1;k<j;k++)\\n        {\\n            int temp = helper(i,cuts,k)+helper(k,cuts,j)+(cuts[j]-cuts[i]);\\n            ans = min(ans,temp);\\n        }\\n        dp[i][j] = ans;\\n        return ans;\\n            \\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        for(int i = 0;i<103;i++)\\n            for(int j = 0;j<103;j++)\\n                dp[i][j] = -1;\\n        cuts.insert(cuts.begin(),0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(),cuts.end());\\n        return helper(0,cuts,cuts.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791617,
                "title": "error-in-binary-search-logic-need-help",
                "content": "So how i thought of this problem was,\\nwe want to minimize the length of our parts after every cut.\\nTo do that, we should cut the whatever portion of rod we have, as close to the middle as possible.\\nSo i wrote a binary search to find the cut closest to middle of the rod.\\nand then continued this recursively till we cant cut or have done all the cuts.\\n```\\nclass Solution {\\n    public int findClosest(int [] cuts, int start,int end, int k){\\n        if(start<0 || end>=cuts.length || start>end){\\n            return -1;\\n        }\\n        if(start==end){\\n            return start;\\n        }\\n        int diff=Integer.MAX_VALUE;\\n        int currentClosest=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(cuts[mid]==k){\\n                return mid;\\n            }\\n            if(cuts[mid]>k){\\n                if(cuts[mid]-k<diff){\\n                    currentClosest=mid;\\n                    diff=cuts[mid]-k;\\n                }\\n                end=mid-1;\\n            }\\n            else{\\n                if(k-cuts[mid]<diff){\\n                    diff=k-cuts[mid];\\n                    currentClosest=mid;\\n                }\\n                start=mid+1;\\n            }\\n        }\\n        return currentClosest;\\n    }\\n    public int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n\\t\\t// mincost(where the rod starts, where it ends, cuts array, and limits for searching in the cuts array)\\n        return minCost(0,n,cuts,0,cuts.length-1);\\n        \\n    }\\n    public int minCost(int startPoint,int endPoint,int cuts[],int start,int end){\\n        int len=(endPoint-startPoint);\\n        System.out.println(\"Current length=\"+len);\\n        if(len<=0){\\n            return 0;\\n        }\\n        int cost=len;\\n        int index=findClosest(cuts,start,end,startPoint+len/2);\\n        System.out.println(\"found index \"+ index);\\n        \\n        if(index==-1){\\n            System.out.println(\"couldnt find a cut\");\\n            return 0;\\n        }\\n        System.out.println(\"Cutting at \"+cuts[index]);\\n        return cost+minCost(startPoint,cuts[index],cuts,start,index-1)+minCost(cuts[index],endPoint,cuts,index+1,end);\\n    }\\n}\\n```\\nBut then this, was only passing for the given test cases and a few others.\\nIs the logic wrong? Could someone please explain with an example?\\nAnd if the logic is right i could\\'ve actually messed up some implementation.\\nThanks a lot!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findClosest(int [] cuts, int start,int end, int k){\\n        if(start<0 || end>=cuts.length || start>end){\\n            return -1;\\n        }\\n        if(start==end){\\n            return start;\\n        }\\n        int diff=Integer.MAX_VALUE;\\n        int currentClosest=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(cuts[mid]==k){\\n                return mid;\\n            }\\n            if(cuts[mid]>k){\\n                if(cuts[mid]-k<diff){\\n                    currentClosest=mid;\\n                    diff=cuts[mid]-k;\\n                }\\n                end=mid-1;\\n            }\\n            else{\\n                if(k-cuts[mid]<diff){\\n                    diff=k-cuts[mid];\\n                    currentClosest=mid;\\n                }\\n                start=mid+1;\\n            }\\n        }\\n        return currentClosest;\\n    }\\n    public int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n\\t\\t// mincost(where the rod starts, where it ends, cuts array, and limits for searching in the cuts array)\\n        return minCost(0,n,cuts,0,cuts.length-1);\\n        \\n    }\\n    public int minCost(int startPoint,int endPoint,int cuts[],int start,int end){\\n        int len=(endPoint-startPoint);\\n        System.out.println(\"Current length=\"+len);\\n        if(len<=0){\\n            return 0;\\n        }\\n        int cost=len;\\n        int index=findClosest(cuts,start,end,startPoint+len/2);\\n        System.out.println(\"found index \"+ index);\\n        \\n        if(index==-1){\\n            System.out.println(\"couldnt find a cut\");\\n            return 0;\\n        }\\n        System.out.println(\"Cutting at \"+cuts[index]);\\n        return cost+minCost(startPoint,cuts[index],cuts,start,index-1)+minCost(cuts[index],endPoint,cuts,index+1,end);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783577,
                "title": "python-c-o-n-3-dp-w-comment",
                "content": "Top-down DP + memoization\\n\\n[Tutorial video in Chinese \\u4E2D\\u6587\\u89E3\\u984C\\u5F71\\u7247](https://www.youtube.com/watch?v=8eA2vnh7xxw)\\n\\n![image.png](https://assets.leetcode.com/users/images/50016340-d0a2-480c-81d7-dd872497d670_1685260659.5363748.png)\\n\\n---\\n\\n**Implementation** by top-down DP in Python\\n\\n```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        \\n        \\n        # adding ending points, and keep cut point sorted in ascending order\\n        cuts = [0] + sorted(cuts) + [n]\\n        \\n        # ----------------------------------------------------------\\n        \\n\\t\\t#use python native cache as memoization for DP\\n        @cache\\n        def dp(left, right):\\n            \\n            if right - left <= 1:\\n                \\n                ## Base case\\n                # No need to cut when cut points is the same or adjacent\\n                return 0\\n            \\n            \\n            ## General case:\\n            # find and compute the optimal cost with cut point k\\n            \\n            return min( dp(left,k) + dp(k, right) + (cuts[right] - cuts[left]) for k in range(left+1, right) )\\n        \\n        # ----------------------------------------------------------\\n        return dp(0, len(cuts)-1)\\n            \\n```\\n---\\n\\nEquivalent bottom-up DP in Python\\n\\n```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n\\n        # Add virtual point to make it easier to handle boundary\\n        cuts = [0]+sorted(cuts)+[n]\\n\\n        l = len(cuts)\\n\\n        # Base case\\n        dp = {(i,i+1):0 for i in range(l-1)}\\n\\n        # General cases\\n        # DP[left, right] = min( DP[left, k] + DP[k, right] ) + cuts[right]-cuts[left]\\n\\n        # Avoid 0: cutting at the same point\\n        # Avoid 1: cuttint on the same stick\\n        for k in range(2, l):\\n\\n            for left in range(l - k):\\n\\n                right = left+k\\n                dp[(left,right)] = cuts[right]-cuts[left] + min([dp[(left,j)]+dp[(j,right)] for j in range(left+1,right)])     \\n\\n        return dp[(0,l-1)]\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\n    \\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        \\n        \\n        // padding 0 and n as end points to cuts\\n        cuts.emplace_back( 0 );\\n        cuts.emplace_back( n );\\n        sort( cuts.begin(), cuts.end() );\\n        \\n        const int cutSize = cuts.size();\\n        \\n        vector< vector<int> > table(cutSize, vector<int>(cutSize, -1) );\\n        \\n        \\n        function<int(int, int)> dp;\\n        dp = [&](const int left, const int right)->int{\\n            \\n            // look-up dp table\\n            if( table[left][right] != -1 ){\\n                return table[ left ][ right ];\\n            }\\n            \\n            // Base aka stop condition, no need to cut when cut points are adjacent\\n            if( (right - left) <= 1 ){\\n                \\n                table[ left ][ right ] = 0 ;\\n                return 0;                \\n            }\\n            \\n            \\n            // General cases:\\n            int finalCost = INT_MAX;\\n            \\n            // find and compute the minimal cost with cut point k\\n            for( int k = left+1 ; k < right ; k++){\\n                \\n                int curCost = dp(left, k) + dp(k, right) + ( cuts[right] - cuts[left] );\\n                \\n                finalCost = min(finalCost, curCost);\\n            }\\n\\n            table[ left ][ right ] = finalCost;\\n            return finalCost;\\n            \\n        };\\n        \\n                    \\n        return dp(0, cuts.size()-1 );\\n    }\\n\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        \\n        \\n        # adding ending points, and keep cut point sorted in ascending order\\n        cuts = [0] + sorted(cuts) + [n]\\n        \\n        # ----------------------------------------------------------\\n        \\n\\t\\t#use python native cache as memoization for DP\\n        @cache\\n        def dp(left, right):\\n            \\n            if right - left <= 1:\\n                \\n                ## Base case\\n                # No need to cut when cut points is the same or adjacent\\n                return 0\\n            \\n            \\n            ## General case:\\n            # find and compute the optimal cost with cut point k\\n            \\n            return min( dp(left,k) + dp(k, right) + (cuts[right] - cuts[left]) for k in range(left+1, right) )\\n        \\n        # ----------------------------------------------------------\\n        return dp(0, len(cuts)-1)\\n            \\n```\n```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n\\n        # Add virtual point to make it easier to handle boundary\\n        cuts = [0]+sorted(cuts)+[n]\\n\\n        l = len(cuts)\\n\\n        # Base case\\n        dp = {(i,i+1):0 for i in range(l-1)}\\n\\n        # General cases\\n        # DP[left, right] = min( DP[left, k] + DP[k, right] ) + cuts[right]-cuts[left]\\n\\n        # Avoid 0: cutting at the same point\\n        # Avoid 1: cuttint on the same stick\\n        for k in range(2, l):\\n\\n            for left in range(l - k):\\n\\n                right = left+k\\n                dp[(left,right)] = cuts[right]-cuts[left] + min([dp[(left,j)]+dp[(j,right)] for j in range(left+1,right)])     \\n\\n        return dp[(0,l-1)]\\n```\n```\\nclass Solution {\\n    \\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        \\n        \\n        // padding 0 and n as end points to cuts\\n        cuts.emplace_back( 0 );\\n        cuts.emplace_back( n );\\n        sort( cuts.begin(), cuts.end() );\\n        \\n        const int cutSize = cuts.size();\\n        \\n        vector< vector<int> > table(cutSize, vector<int>(cutSize, -1) );\\n        \\n        \\n        function<int(int, int)> dp;\\n        dp = [&](const int left, const int right)->int{\\n            \\n            // look-up dp table\\n            if( table[left][right] != -1 ){\\n                return table[ left ][ right ];\\n            }\\n            \\n            // Base aka stop condition, no need to cut when cut points are adjacent\\n            if( (right - left) <= 1 ){\\n                \\n                table[ left ][ right ] = 0 ;\\n                return 0;                \\n            }\\n            \\n            \\n            // General cases:\\n            int finalCost = INT_MAX;\\n            \\n            // find and compute the minimal cost with cut point k\\n            for( int k = left+1 ; k < right ; k++){\\n                \\n                int curCost = dp(left, k) + dp(k, right) + ( cuts[right] - cuts[left] );\\n                \\n                finalCost = min(finalCost, curCost);\\n            }\\n\\n            table[ left ][ right ] = finalCost;\\n            return finalCost;\\n            \\n        };\\n        \\n                    \\n        return dp(0, cuts.size()-1 );\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782841,
                "title": "javascript-dp-iterative-recursive-explained-comments",
                "content": "\\n\\nLet **dp[i][j]** be the minimum cost if we cut on the stick from **cuts[i] to cuts[j]**.\\nSo here\\'s the thing, the **ONLY** cuts you\\'re allowed to make are any of the cuts[i]. \\n**Optimal Substructure**: dp[i][j]=Min(dp[i][**k**]+dp[**k**][j]+cost[j]-cost[i]) => dp[i][j] depends on the minimum value of subcuts\\n**Overlapping Subproblems**: Consider the recursion tree of dp[0][2] and dp[1][3] => They both consider case dp[1][2]\\n\\n**Iterative**\\n```\\nvar minCost = function(n, cuts) {\\n    cuts.push(0, n); // SENTINELS because I can choose the min and max as is \\n    cuts.sort((a, b) => a - b);\\n    console.log(cuts)\\n    let N=cuts.length\\n    let dp = [...Array(N)].map(d => [...Array(N)].map(d=>Infinity));\\n\\n    // length of my window is 1 \\n    //adjacent cuts on my starting array\\n    for (let i = 0; i <N; i++) {\\n        dp[i][i+1]=0  // cant cut it. As in I m never given the option to perform that cut No matter what the numbers are. \\n    }\\n    // length of my window is 2\\n    for (let i = 0; i <N-1; i++) {\\n        dp[i][i+2]=cuts[i+2]-cuts[i] // Obviously, for every triplet a,b,c in cuts, dp[idx(a)][idx(c)]=c-a because I can only perform the cut at b (the middle element)\\n    }\\n\\n    //for every length\\n    for (let len = 3; len < N; len++) {\\n        //consider each window i,j of my CUTS ARRAY representing the acutual window [cuts[i],cuts[j]]\\n        for (let i = 0; i <=N-len; i++) {\\n            let j=i+len\\n            //consider each possible MIDDLE CUT k \\n            for (let k = i+1; k < j; k++) {\\n                dp[i][j]=Math.min(dp[i][j],cuts[j]-cuts[i]+dp[i][k]+dp[k][j])                \\n            }            \\n        }\\n    }\\n\\n    return dp[0][N-1];\\n};\\n```\\n**Recursive + memo**\\n```\\nvar minCost = function(n, cuts) {\\n    cuts.push(0, n); \\n    cuts.sort((a, b) => a - b);\\n    let N=cuts.length\\n    let dp = [...Array(N)].map(d => [...Array(N)]);\\n\\n    let rec = (i, j) => {\\n        if(j-i== 1) return 0;\\n        if (dp[i][j] !== undefined) return dp[i][j];\\n        for (let k = i + 1; k < j; k++) {\\n            dp[i][j] = Math.min(dp[i][j]||Infinity, rec(i, k) + rec(k, j) + cuts[j] - cuts[i]);\\n        }\\n        return dp[i][j];\\n    };\\n   \\n    return  rec(0, N-1);\\n};\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minCost = function(n, cuts) {\\n    cuts.push(0, n); // SENTINELS because I can choose the min and max as is \\n    cuts.sort((a, b) => a - b);\\n    console.log(cuts)\\n    let N=cuts.length\\n    let dp = [...Array(N)].map(d => [...Array(N)].map(d=>Infinity));\\n\\n    // length of my window is 1 \\n    //adjacent cuts on my starting array\\n    for (let i = 0; i <N; i++) {\\n        dp[i][i+1]=0  // cant cut it. As in I m never given the option to perform that cut No matter what the numbers are. \\n    }\\n    // length of my window is 2\\n    for (let i = 0; i <N-1; i++) {\\n        dp[i][i+2]=cuts[i+2]-cuts[i] // Obviously, for every triplet a,b,c in cuts, dp[idx(a)][idx(c)]=c-a because I can only perform the cut at b (the middle element)\\n    }\\n\\n    //for every length\\n    for (let len = 3; len < N; len++) {\\n        //consider each window i,j of my CUTS ARRAY representing the acutual window [cuts[i],cuts[j]]\\n        for (let i = 0; i <=N-len; i++) {\\n            let j=i+len\\n            //consider each possible MIDDLE CUT k \\n            for (let k = i+1; k < j; k++) {\\n                dp[i][j]=Math.min(dp[i][j],cuts[j]-cuts[i]+dp[i][k]+dp[k][j])                \\n            }            \\n        }\\n    }\\n\\n    return dp[0][N-1];\\n};\\n```\n```\\nvar minCost = function(n, cuts) {\\n    cuts.push(0, n); \\n    cuts.sort((a, b) => a - b);\\n    let N=cuts.length\\n    let dp = [...Array(N)].map(d => [...Array(N)]);\\n\\n    let rec = (i, j) => {\\n        if(j-i== 1) return 0;\\n        if (dp[i][j] !== undefined) return dp[i][j];\\n        for (let k = i + 1; k < j; k++) {\\n            dp[i][j] = Math.min(dp[i][j]||Infinity, rec(i, k) + rec(k, j) + cuts[j] - cuts[i]);\\n        }\\n        return dp[i][j];\\n    };\\n   \\n    return  rec(0, N-1);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3759361,
                "title": "why-not-greedy",
                "content": "Dear Greedy minded folks, \\n\\nThe greedy choice property must always be the safest property to consider at any moment. Greedy choice of a cut even in sorted input must then gaurentee that irrespective of the cuts in the future divided sticks, this cut is optimal. \\nIn this problem, the choice of a cut at any moment depends on **how in future** the further divided sticks will be cut. Hence the choice at any stage builds bottom up fundamentally. And this is what we do in dynamic programming! WE SOLVE SMALLER versions of the same problem FIRST, HERE SMALLER AND RECURSIVELY USE A SERIES OF CHOICE OF THESE SMALLER SUBPROBLEMS TO BUILD A BIGGER SOLUTION. \\nGreedy Techniques vanish away one subproblem(Bigger ones first) and then solves remaining smaller subproblems. ****The choice at this moment is independent of the choices to be made in future.****  \\n\\nHope you to be greedy only when required and think a little more about future choices!\\n\\nRegards,\\nDynamic Programming\\n\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "Dear Greedy minded folks, \\n\\nThe greedy choice property must always be the safest property to consider at any moment. Greedy choice of a cut even in sorted input must then gaurentee that irrespective of the cuts in the future divided sticks, this cut is optimal. \\nIn this problem, the choice of a cut at any moment depends on **how in future** the further divided sticks will be cut. Hence the choice at any stage builds bottom up fundamentally. And this is what we do in dynamic programming! WE SOLVE SMALLER versions of the same problem FIRST, HERE SMALLER AND RECURSIVELY USE A SERIES OF CHOICE OF THESE SMALLER SUBPROBLEMS TO BUILD A BIGGER SOLUTION. \\nGreedy Techniques vanish away one subproblem(Bigger ones first) and then solves remaining smaller subproblems. ****The choice at this moment is independent of the choices to be made in future.****  \\n\\nHope you to be greedy only when required and think a little more about future choices!\\n\\nRegards,\\nDynamic Programming\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3572987,
                "title": "python-short-and-clean-functional-programming",
                "content": "# Complexity\\n- Time complexity: $$O(m ^ 3)$$\\n\\n- Space complexity: $$O(m ^ 2)$$\\n\\nwhere, `m is the number of cuts`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minCost(self, n: int, cuts: list[int]) -> int:\\n        s_cuts = sorted(chain(cuts, (0, n)))\\n\\n        @cache\\n        def min_cost(i: int, j: int) -> int:\\n            return (cost := s_cuts[j] - s_cuts[i]) + min((min_cost(i, k) + min_cost(k, j) for k in range(i + 1, j)), default=-cost)\\n        \\n        return min_cost(0, len(s_cuts) - 1)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def minCost(self, n: int, cuts: list[int]) -> int:\\n        s_cuts = sorted(chain(cuts, (0, n)))\\n\\n        @cache\\n        def min_cost(i: int, j: int) -> int:\\n            return (cost := s_cuts[j] - s_cuts[i]) + min((min_cost(i, k) + min_cost(k, j) for k in range(i + 1, j)), default=-cost)\\n        \\n        return min_cost(0, len(s_cuts) - 1)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572177,
                "title": "java-with-explanation-easy-to-understand-approach-and-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nWe will calculate the cost for all the possibilities and return the minimum of them.\\nWe start with an element `i` of the `cuts[]` array. The cost for current cut will be the current length of the rod. Then we recursively calculate the cost of processing the left part of the `cuts[]` and right part of the `cuts[]`. We also pass parameters to calculate the current length of the rod.\\n\\nOnce we calculate all the possibilities, we return the minimum from them.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFirst we sort the `cuts` array, so that cuts are in order. It will help in processing the cuts in order and make it easy to calculate the current length of the rod after the cut.\\n\\nWe use dp[][] for memoization. So that we can avoid repeated calls of the function.\\n\\nIn parameters we will pass the `cuts[]` array. `start` and `end` to pass the range of the cuts[] indexes to process. \\n`rodStart` and `rodEnd` to calculate the rod length.\\n\\nThen using for loop we process each element of the cuts from `start` to `end`. The cost for current cut `i` will be the current length of the rod ie. `rodEnd-rodStart`. Then we recursively calculate the cost to process the left and right side of the cuts array. \\nReturn min of these costs.\\n\\n# Complexity\\n- Time complexity: O(m^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n //m == cuts.length\\n\\n- Space complexity: O(m^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private int minCost(int start, int end, int rodStart, int rodEnd, int[] cuts, int[][] dp){\\n        \\n        if(end<start){\\n            return 0;\\n        }\\n\\n        if(dp[start][end] != -1){\\n            return dp[start][end];\\n        }\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=start;i<=end;i++){\\n            int cost = rodEnd-rodStart +\\n            minCost(start,i-1,rodStart,cuts[i],cuts,dp)+\\n            minCost(i+1,end,cuts[i],rodEnd,cuts,dp);\\n            \\n            ans = Math.min(cost,ans);\\n        }\\n        \\n        dp[start][end] = ans;\\n        return ans;\\n\\n    }\\n\\n    public int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n        int m = cuts.length;\\n        int[][] dp = new int[m][m];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        return minCost(0,cuts.length-1,0,n,cuts,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    private int minCost(int start, int end, int rodStart, int rodEnd, int[] cuts, int[][] dp){\\n        \\n        if(end<start){\\n            return 0;\\n        }\\n\\n        if(dp[start][end] != -1){\\n            return dp[start][end];\\n        }\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=start;i<=end;i++){\\n            int cost = rodEnd-rodStart +\\n            minCost(start,i-1,rodStart,cuts[i],cuts,dp)+\\n            minCost(i+1,end,cuts[i],rodEnd,cuts,dp);\\n            \\n            ans = Math.min(cost,ans);\\n        }\\n        \\n        dp[start][end] = ans;\\n        return ans;\\n\\n    }\\n\\n    public int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n        int m = cuts.length;\\n        int[][] dp = new int[m][m];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        return minCost(0,cuts.length-1,0,n,cuts,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571626,
                "title": "easy-approach-c-o-n-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the problem is to consider all possible subranges between the cutting positions and calculate the cost of cutting each subrange separately. The final cost is the sum of costs for all subranges.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the cutting positions in ascending order using std::sort to ensure they are in the correct order.\\n- Initialize a 2D dp (dynamic programming) table with dimensions (m+2) x (m+2), where m is the number of cutting positions.\\n- Iterate over the length of subranges (s) from 2 to m+1.\\n- Within each subrange length, iterate over all possible starting positions (i) from 0 to m+1-s.\\n- Calculate the ending position (j) based on the starting position and subrange length.\\n- Initialize the cost for the current subrange (dp[i][j]) as infinity (INT_MAX) to track the minimum cost.\\n- Iterate over all possible cutting positions within the subrange, from i+1 to j-1.\\n- Calculate the cost of cutting at position k and update the minimum cost for the subrange: dp[i][j] = std::min(dp[i][j], dp[i][k] + dp[k][j]).\\n- Calculate the cost of cutting the current subrange from the leftmost position (left) to the rightmost position (right).\\n- The leftmost position (left) is 0 if i is 0, otherwise it is the cutting position at index i-1.\\n- The rightmost position (right) is n (rod length) if j is m+1, otherwise it is the cutting position at index j-1.\\n- Add the cost of this subrange to dp[i][j]: dp[i][j] += right - left.\\n- Repeat steps 3-8 for all subranges of increasing lengths and starting positions.\\n- The minimum cost of cutting the entire rod is stored in dp[0][m+1], which represents the cost of the subrange from the leftmost position to the rightmost position.\\n- Return the minimum cost as the result.\\n\\n# Complexity\\n- Time complexity: O(N^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(int n, std::vector<int>& cuts) {\\n        std::sort(cuts.begin(), cuts.end());\\n        int m = cuts.size();\\n        std::vector<std::vector<int>> dp(m + 2, std::vector<int>(m + 2, 0));\\n\\n        for (int s = 2; s <= m + 1; s++) {\\n            for (int i = 0; i + s <= m + 1; i++) {\\n                int j = i + s;\\n                dp[i][j] = INT_MAX;\\n                for (int k = i + 1; k < j; k++) \\n                    dp[i][j] = std::min(dp[i][j], dp[i][k] + dp[k][j]);\\n                int left, right;\\n                left = (i == 0) ? 0 : cuts[i - 1];\\n                right = (j == m + 1) ? n : cuts[j - 1];\\n                dp[i][j] += right - left;\\n            }\\n        }\\n        return dp[0][m + 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int n, std::vector<int>& cuts) {\\n        std::sort(cuts.begin(), cuts.end());\\n        int m = cuts.size();\\n        std::vector<std::vector<int>> dp(m + 2, std::vector<int>(m + 2, 0));\\n\\n        for (int s = 2; s <= m + 1; s++) {\\n            for (int i = 0; i + s <= m + 1; i++) {\\n                int j = i + s;\\n                dp[i][j] = INT_MAX;\\n                for (int k = i + 1; k < j; k++) \\n                    dp[i][j] = std::min(dp[i][j], dp[i][k] + dp[k][j]);\\n                int left, right;\\n                left = (i == 0) ? 0 : cuts[i - 1];\\n                right = (j == m + 1) ? n : cuts[j - 1];\\n                dp[i][j] += right - left;\\n            }\\n        }\\n        return dp[0][m + 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571413,
                "title": "c-easiest-recursion-memo-video-explanation",
                "content": "YouTube Link : https://www.youtube.com/watch?v=x4cRwVEFwHc\\nMy Github Treasure : [Minimum Cost to Cut a Stick](https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/DP/Minimum%20Cost%20to%20Cut%20a%20Stick.cpp)\\n\\n```\\nclass Solution {\\npublic:\\n    int t[103][103];\\n    int solve(vector<int>& cuts, int left, int right) {\\n        \\n        if(right - left == 1)\\n            return 0;\\n        \\n        if(t[left][right] != -1)\\n            return t[left][right];\\n        \\n        int result = INT_MAX;\\n        \\n        for(int index = left+1; index <= right-1; index++) {\\n            \\n            int cost = solve(cuts, left, index) + solve(cuts, index, right) + (cuts[right] - cuts[left]);\\n            \\n            result = min(result, cost);\\n            \\n        }\\n        \\n        return t[left][right] = result;\\n        \\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        sort(begin(cuts), end(cuts));\\n        \\n        cuts.insert(begin(cuts), 0);\\n        cuts.push_back(n);\\n        memset(t, -1, sizeof(t));\\n        return solve(cuts, 0, cuts.size()-1);\\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[103][103];\\n    int solve(vector<int>& cuts, int left, int right) {\\n        \\n        if(right - left == 1)\\n            return 0;\\n        \\n        if(t[left][right] != -1)\\n            return t[left][right];\\n        \\n        int result = INT_MAX;\\n        \\n        for(int index = left+1; index <= right-1; index++) {\\n            \\n            int cost = solve(cuts, left, index) + solve(cuts, index, right) + (cuts[right] - cuts[left]);\\n            \\n            result = min(result, cost);\\n            \\n        }\\n        \\n        return t[left][right] = result;\\n        \\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        sort(begin(cuts), end(cuts));\\n        \\n        cuts.insert(begin(cuts), 0);\\n        cuts.push_back(n);\\n        memset(t, -1, sizeof(t));\\n        return solve(cuts, 0, cuts.size()-1);\\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571094,
                "title": "easy-2-line-explanation-for-2-liner-code-top-down",
                "content": "```\\n# Intuition\\n1) Find cuts between range by binary search in sorted arr\\n2) Loop k over cuts \\n    take min of (0,k) + (k,0) + length  \\n```\\n\\n\\n\\n\\n# Code\\n```\\n\\ndef minCost(self, n: int, cuts: List[int]) -> int:\\n    cuts.sort()\\n\\n    @cache\\n    def help(i=0,j=n):\\n        x,y = bisect_right(cuts,i), bisect_right(cuts, j-1)\\n        if x==y: return 0\\n        return min( help(i,cuts[k]) + help(cuts[k], j) + (j-i) for k in range(x,y) )\\n\\n    return help()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Intuition\\n1) Find cuts between range by binary search in sorted arr\\n2) Loop k over cuts \\n    take min of (0,k) + (k,0) + length  \\n```\n```\\n\\ndef minCost(self, n: int, cuts: List[int]) -> int:\\n    cuts.sort()\\n\\n    @cache\\n    def help(i=0,j=n):\\n        x,y = bisect_right(cuts,i), bisect_right(cuts, j-1)\\n        if x==y: return 0\\n        return min( help(i,cuts[k]) + help(cuts[k], j) + (j-i) for k in range(x,y) )\\n\\n    return help()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3570700,
                "title": "rust-dp",
                "content": "```\\nimpl Solution {\\n    pub fn min_cost(n: i32, cuts: Vec<i32>) -> i32 {\\n        let mut a = Vec::with_capacity(cuts.len() + 2);\\n        a.push(0);\\n        a.push(n);\\n        a.extend(cuts);\\n        a.sort_unstable();\\n\\n        let mut dp = vec![vec![0; a.len()]; a.len()];\\n\\n        for len in 2..a.len() {\\n            for i in 0..a.len() - len {\\n                let j = i + len;\\n\\n                let mut t = i32::MAX;\\n                for k in i + 1..j {\\n                    t = t.min(dp[i][k] + dp[k][j]);\\n                }\\n                dp[i][j] = t + a[j] - a[i];\\n            }\\n        }\\n\\n        dp[0][a.len() - 1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_cost(n: i32, cuts: Vec<i32>) -> i32 {\\n        let mut a = Vec::with_capacity(cuts.len() + 2);\\n        a.push(0);\\n        a.push(n);\\n        a.extend(cuts);\\n        a.sort_unstable();\\n\\n        let mut dp = vec![vec![0; a.len()]; a.len()];\\n\\n        for len in 2..a.len() {\\n            for i in 0..a.len() - len {\\n                let j = i + len;\\n\\n                let mut t = i32::MAX;\\n                for k in i + 1..j {\\n                    t = t.min(dp[i][k] + dp[k][j]);\\n                }\\n                dp[i][j] = t + a[j] - a[i];\\n            }\\n        }\\n\\n        dp[0][a.len() - 1]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570332,
                "title": "python-bottom-up-dp-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.sort()\\n        cuts = [0] + cuts + [n]\\n        m = len(cuts)\\n        dp = [[0] * m for _ in range(m)]\\n        for i in range(m - 2, -1, -1):\\n            for j in range(i + 2, m):\\n                mini = float(\\'inf\\')\\n                for k in range(i + 1, j):\\n                    cost = cuts[j] - cuts[i] + dp[i][k] + dp[k][j]\\n                    mini = min(mini, cost)\\n                dp[i][j] = mini\\n        return dp[0][m - 1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.sort()\\n        cuts = [0] + cuts + [n]\\n        m = len(cuts)\\n        dp = [[0] * m for _ in range(m)]\\n        for i in range(m - 2, -1, -1):\\n            for j in range(i + 2, m):\\n                mini = float(\\'inf\\')\\n                for k in range(i + 1, j):\\n                    cost = cuts[j] - cuts[i] + dp[i][k] + dp[k][j]\\n                    mini = min(mini, cost)\\n                dp[i][j] = mini\\n        return dp[0][m - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570019,
                "title": "c-dp",
                "content": "# Approach\\n- Build a `dp` array where `dp[i][j]` is the minimum cost to achieve all - the cuts between `i` and `j`.\\n- When you try to get the minimum cost between `i` and `j`, try all possible cuts `k` between them, `dp[i][j] = min(dp[i][k] + dp[k][j]) + (j - i)` for all possible cuts k between them.\\n\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int MinCost(int n, int[] cuts)\\n    {\\n        Array.Sort(cuts);\\n        var m = cuts.Length;\\n        var dp = new int[m + 2, m + 2];\\n\\n        for (var l = 2; l <= m + 1; l++)\\n        {\\n            for (var i = 0; i + l <= m + 1; i++)\\n            {\\n                var j = i + l;\\n                dp[i, j] = int.MaxValue;\\n                for (var k = i + 1; k < j; k++)\\n                {\\n                    dp[i, j] = Math.Min(dp[i, j], dp[i, k] + dp[k, j]);\\n                }\\n\\n                var left = i == 0 ? 0 : cuts[i - 1];\\n                var right = j == m + 1 ? n : cuts[j - 1];\\n                dp[i, j] += right - left;\\n            }\\n        }\\n\\n        return dp[0, m + 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinCost(int n, int[] cuts)\\n    {\\n        Array.Sort(cuts);\\n        var m = cuts.Length;\\n        var dp = new int[m + 2, m + 2];\\n\\n        for (var l = 2; l <= m + 1; l++)\\n        {\\n            for (var i = 0; i + l <= m + 1; i++)\\n            {\\n                var j = i + l;\\n                dp[i, j] = int.MaxValue;\\n                for (var k = i + 1; k < j; k++)\\n                {\\n                    dp[i, j] = Math.Min(dp[i, j], dp[i, k] + dp[k, j]);\\n                }\\n\\n                var left = i == 0 ? 0 : cuts[i - 1];\\n                var right = j == m + 1 ? n : cuts[j - 1];\\n                dp[i, j] += right - left;\\n            }\\n        }\\n\\n        return dp[0, m + 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569946,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.append(0)\\n        cuts.append(n)\\n        cuts.sort()\\n        N=len(cuts)\\n        @lru_cache(None)\\n        def go(left,right):\\n            if left+1==right:\\n                return 0\\n\\n            best=1e100\\n            for cut in range(left+1,right):\\n                cost=cuts[right]-cuts[left]\\n                best=min(best,go(left,cut)+go(cut,right)+cost)\\n\\n            return best\\n\\n        return go(0,N-1)             \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.append(0)\\n        cuts.append(n)\\n        cuts.sort()\\n        N=len(cuts)\\n        @lru_cache(None)\\n        def go(left,right):\\n            if left+1==right:\\n                return 0\\n\\n            best=1e100\\n            for cut in range(left+1,right):\\n                cost=cuts[right]-cuts[left]\\n                best=min(best,go(left,cut)+go(cut,right)+cost)\\n\\n            return best\\n\\n        return go(0,N-1)             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296080,
                "title": "c-matrix-chain-multiplication-partition-dp-memoization-tabulation-striver",
                "content": "# Memoization\\n```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<int>&cuts, int n, vector<vector<int>>& dp) {\\n        if (i > j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int ans = INT_MAX;\\n        for (int k=i; k<=j; k++) {\\n            int curr = cuts[j+1] - cuts[i-1] + dfs(i, k-1, cuts, n, dp) + dfs(k+1, j, cuts, n, dp);\\n            ans = min(ans, curr);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        int c = cuts.size();\\n        cuts.emplace_back(n);\\n        cuts.insert(begin(cuts), 0);\\n        sort(begin(cuts), end(cuts));\\n        vector<vector<int>> dp(c+1, vector<int>(c+1, -1));\\n        return dfs(1, c, cuts, n, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        int c = cuts.size();\\n        cuts.emplace_back(n);\\n        cuts.insert(begin(cuts), 0);\\n        sort(begin(cuts), end(cuts));\\n        vector<vector<int>> dp(c+2, vector<int>(c+2, 0));\\n        for (int i=c; i>=1; i--) {\\n            for (int j=1; j<=c; j++) {\\n                if (i > j) continue;\\n                int ans = INT_MAX;\\n                for (int k=i; k<=j; k++) {\\n                    int curr = cuts[j+1] - cuts[i-1] + dp[i][k-1] + dp[k+1][j];\\n                    ans = min(ans, curr);\\n                }\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[1][c];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<int>&cuts, int n, vector<vector<int>>& dp) {\\n        if (i > j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int ans = INT_MAX;\\n        for (int k=i; k<=j; k++) {\\n            int curr = cuts[j+1] - cuts[i-1] + dfs(i, k-1, cuts, n, dp) + dfs(k+1, j, cuts, n, dp);\\n            ans = min(ans, curr);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        int c = cuts.size();\\n        cuts.emplace_back(n);\\n        cuts.insert(begin(cuts), 0);\\n        sort(begin(cuts), end(cuts));\\n        vector<vector<int>> dp(c+1, vector<int>(c+1, -1));\\n        return dfs(1, c, cuts, n, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        int c = cuts.size();\\n        cuts.emplace_back(n);\\n        cuts.insert(begin(cuts), 0);\\n        sort(begin(cuts), end(cuts));\\n        vector<vector<int>> dp(c+2, vector<int>(c+2, 0));\\n        for (int i=c; i>=1; i--) {\\n            for (int j=1; j<=c; j++) {\\n                if (i > j) continue;\\n                int ans = INT_MAX;\\n                for (int k=i; k<=j; k++) {\\n                    int curr = cuts[j+1] - cuts[i-1] + dp[i][k-1] + dp[k+1][j];\\n                    ans = min(ans, curr);\\n                }\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[1][c];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197236,
                "title": "go-top-down-memoization-clean-and-easy-to-understand-code",
                "content": "# Complexity\\n- Time complexity:\\nO(n^3):\\nNumber of states = O(n x n) and for each state we search cuts array\\nTherefore Final complexity is O(n x n x n)\\n\\n- Space complexity:\\nO(len(cuts)^2)\\n\\n# Code\\n```\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\ntype Key struct {\\n    start int\\n    end int\\n} \\n\\nfunc minCost(n int, cuts []int) int {\\n\\n    dp := make(map[Key]int, 0)\\n\\n    var minCostAt func(start, end int) int\\n    minCostAt = func(start, end int) int {\\n        if (end <= start) {\\n            return 0\\n        }\\n\\n        if _, prs := dp[Key{start, end}]; prs {\\n            return dp[Key{start, end}]\\n        }\\n\\n        // we use this max preset just so we can use the min function without any hassle\\n        minCostCurr := 10000001\\n        for j := 0; j < len(cuts); j += 1 {\\n            if start < cuts[j] && cuts[j] < end {\\n                minCostCurr = min(minCostCurr, end - start + minCostAt(start, cuts[j]) + minCostAt(cuts[j], end))\\n            } \\n        }   \\n        // no cuts exist in this rod section then the cost should be reset to 0\\n        if minCostCurr == 10000001 {\\n            return 0\\n        }\\n\\n        dp[Key{start, end}] = minCostCurr\\n        \\n        return dp[Key{start, end}]\\n    }   \\n\\n    return minCostAt(0, n)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\ntype Key struct {\\n    start int\\n    end int\\n} \\n\\nfunc minCost(n int, cuts []int) int {\\n\\n    dp := make(map[Key]int, 0)\\n\\n    var minCostAt func(start, end int) int\\n    minCostAt = func(start, end int) int {\\n        if (end <= start) {\\n            return 0\\n        }\\n\\n        if _, prs := dp[Key{start, end}]; prs {\\n            return dp[Key{start, end}]\\n        }\\n\\n        // we use this max preset just so we can use the min function without any hassle\\n        minCostCurr := 10000001\\n        for j := 0; j < len(cuts); j += 1 {\\n            if start < cuts[j] && cuts[j] < end {\\n                minCostCurr = min(minCostCurr, end - start + minCostAt(start, cuts[j]) + minCostAt(cuts[j], end))\\n            } \\n        }   \\n        // no cuts exist in this rod section then the cost should be reset to 0\\n        if minCostCurr == 10000001 {\\n            return 0\\n        }\\n\\n        dp[Key{start, end}] = minCostCurr\\n        \\n        return dp[Key{start, end}]\\n    }   \\n\\n    return minCostAt(0, n)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2904415,
                "title": "java-solution-with-comments-leet-code-hard-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int[] c = new int[cuts.length + 2];\\n        for(int i = 0; i < cuts.length; i++){\\n            c[i + 1] = cuts[i];\\n        }\\n        c[c.length - 1] = n;\\n        Arrays.sort(c);\\n        int[][] dp = new int[c.length][c.length];\\n        for(int i = 0; i < dp.length; i++){\\n            for(int j = i - 1; j >= 0; j--){\\n                for(int k = i - 1; k > j; k--){\\n                    int ans = Math.min(dp[j][i] == 0 ? Integer.MAX_VALUE : dp[j][i], c[i] - c[j] + dp[j][k] + dp[k][i]);\\n                    dp[j][i] = ans;\\n\\n                }\\n            }\\n        }\\n        return dp[0][c.length - 1];\\n        \\n    }\\n}\\n/**\\ncuts 1 3 4 5 \\nn = 7 \\n 0 1 2 3 4 5 6 7\\n cut at 1\\n 0 1  1 2 3 4 5 6 7 cost = 7 - 0 = 7\\n cut at 3\\n 0 1  1 2 3   3 4 5 6 7 cost = 7 + 7 - 1 = 13\\n cut at 4\\n 0 1  1 2 3   3 4   4 5 6 7 cost = 13 + 7 - 3 = 17\\n cut at 5\\n 0 1  1 2 3   3 4   4 5   5 6 7 cost = 17 + 7 - 4 = 20\\n // what I want ? I want minimum\\n // min = 16\\n // Try all possible ways\\n 1 3 4 5 \\n 5 3 2 1\\n 1 4 3 5\\n 3 4 1 5\\n upto so on  \\n\\n // Main highlight cuts 1 3 4 5  convert => 0 1 3 4 5 7\\n \\n 0 1 3 4 5 7\\n   j   k   i\\n// IMPORTANT\\n   C(j,i) = (i-j) + min(C(j,k) + C(k,i)) for all k in between i and j\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int[] c = new int[cuts.length + 2];\\n        for(int i = 0; i < cuts.length; i++){\\n            c[i + 1] = cuts[i];\\n        }\\n        c[c.length - 1] = n;\\n        Arrays.sort(c);\\n        int[][] dp = new int[c.length][c.length];\\n        for(int i = 0; i < dp.length; i++){\\n            for(int j = i - 1; j >= 0; j--){\\n                for(int k = i - 1; k > j; k--){\\n                    int ans = Math.min(dp[j][i] == 0 ? Integer.MAX_VALUE : dp[j][i], c[i] - c[j] + dp[j][k] + dp[k][i]);\\n                    dp[j][i] = ans;\\n\\n                }\\n            }\\n        }\\n        return dp[0][c.length - 1];\\n        \\n    }\\n}\\n/**\\ncuts 1 3 4 5 \\nn = 7 \\n 0 1 2 3 4 5 6 7\\n cut at 1\\n 0 1  1 2 3 4 5 6 7 cost = 7 - 0 = 7\\n cut at 3\\n 0 1  1 2 3   3 4 5 6 7 cost = 7 + 7 - 1 = 13\\n cut at 4\\n 0 1  1 2 3   3 4   4 5 6 7 cost = 13 + 7 - 3 = 17\\n cut at 5\\n 0 1  1 2 3   3 4   4 5   5 6 7 cost = 17 + 7 - 4 = 20\\n // what I want ? I want minimum\\n // min = 16\\n // Try all possible ways\\n 1 3 4 5 \\n 5 3 2 1\\n 1 4 3 5\\n 3 4 1 5\\n upto so on  \\n\\n // Main highlight cuts 1 3 4 5  convert => 0 1 3 4 5 7\\n \\n 0 1 3 4 5 7\\n   j   k   i\\n// IMPORTANT\\n   C(j,i) = (i-j) + min(C(j,k) + C(k,i)) for all k in between i and j\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802587,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> dp;\\n    int recursion(int l, int r, int left, int right, vector<int> &cuts)\\n    {\\n        if (r < l) return 0;\\n        if (dp[l][r] != -1) return dp[l][r];\\n\\n        int answer = INT_MAX;\\n        for (int i = l; i <= r; i++)\\n        {\\n            int length = (right - left) ;\\n            int current = length + recursion(l, i - 1, left, cuts[i], cuts) + recursion(i + 1, r, cuts[i], right, cuts);\\n            answer = min(answer, current);\\n        }\\n\\n        return dp[l][r] = answer;\\n    }\\n    int minCost(int n, vector<int> &cuts)\\n    {\\n        dp = vector<vector<int>>(cuts.size() + 4, vector<int>(cuts.size() + 2, -1));\\n        sort(cuts.begin(), cuts.end());\\n        return recursion(0, cuts.size() - 1, 0, n, cuts);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> dp;\\n    int recursion(int l, int r, int left, int right, vector<int> &cuts)\\n    {\\n        if (r < l) return 0;\\n        if (dp[l][r] != -1) return dp[l][r];\\n\\n        int answer = INT_MAX;\\n        for (int i = l; i <= r; i++)\\n        {\\n            int length = (right - left) ;\\n            int current = length + recursion(l, i - 1, left, cuts[i], cuts) + recursion(i + 1, r, cuts[i], right, cuts);\\n            answer = min(answer, current);\\n        }\\n\\n        return dp[l][r] = answer;\\n    }\\n    int minCost(int n, vector<int> &cuts)\\n    {\\n        dp = vector<vector<int>>(cuts.size() + 4, vector<int>(cuts.size() + 2, -1));\\n        sort(cuts.begin(), cuts.end());\\n        return recursion(0, cuts.size() - 1, 0, n, cuts);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356502,
                "title": "c-recursion-dp-partition-dp",
                "content": "Do attempt all the Partition DP questions, here\\'s the [link to the list.](https://leetcode.com/list/e7v74b8t)\\n\\n***1. Recursive Solution*** (TLE for 88 testcases)\\n```\\nclass Solution {\\npublic:\\n    int recur(int i, int j, vector<int>& cuts){\\n        if(i>j) return 0;\\n        int mini=INT_MAX;\\n        for(int ind=i;ind<=j;ind++){\\n            int cost = cuts[j+1] - cuts[i-1] + recur(i, ind-1, cuts) + recur(ind+1, j, cuts);\\n            mini=min(mini, cost);\\n        }\\n        return mini;\\n    }\\n        \\n    int minCost(int n, vector<int>& cuts) {\\n        int size=cuts.size();\\n        cuts.push_back(n);\\n        cuts.push_back(0);\\n        sort(cuts.begin(), cuts.end());\\n        return recur(1, size, cuts);\\n    }\\n};\\n```\\n\\n***2. DP Solution***\\n```\\nclass Solution {\\npublic:\\n    int recur(int i, int j, vector<int>& cuts, vector<vector<int>>& dp){\\n        if(i>j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j]; \\n        int mini=INT_MAX;\\n        for(int ind=i;ind<=j;ind++){\\n            int cost = cuts[j+1] - cuts[i-1] + recur(i, ind-1, cuts, dp) + recur(ind+1, j, cuts, dp);\\n            mini=min(mini, cost);\\n        }\\n        return dp[i][j] = mini;\\n    }\\n        \\n    int minCost(int n, vector<int>& cuts) {\\n        int size=cuts.size();\\n        vector<vector<int>> dp(size+1, vector<int>(size+1, -1));\\n        \\n        cuts.push_back(n);\\n        cuts.push_back(0);\\n        sort(cuts.begin(), cuts.end());\\n        return recur(1, size, cuts, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recur(int i, int j, vector<int>& cuts){\\n        if(i>j) return 0;\\n        int mini=INT_MAX;\\n        for(int ind=i;ind<=j;ind++){\\n            int cost = cuts[j+1] - cuts[i-1] + recur(i, ind-1, cuts) + recur(ind+1, j, cuts);\\n            mini=min(mini, cost);\\n        }\\n        return mini;\\n    }\\n        \\n    int minCost(int n, vector<int>& cuts) {\\n        int size=cuts.size();\\n        cuts.push_back(n);\\n        cuts.push_back(0);\\n        sort(cuts.begin(), cuts.end());\\n        return recur(1, size, cuts);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int recur(int i, int j, vector<int>& cuts, vector<vector<int>>& dp){\\n        if(i>j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j]; \\n        int mini=INT_MAX;\\n        for(int ind=i;ind<=j;ind++){\\n            int cost = cuts[j+1] - cuts[i-1] + recur(i, ind-1, cuts, dp) + recur(ind+1, j, cuts, dp);\\n            mini=min(mini, cost);\\n        }\\n        return dp[i][j] = mini;\\n    }\\n        \\n    int minCost(int n, vector<int>& cuts) {\\n        int size=cuts.size();\\n        vector<vector<int>> dp(size+1, vector<int>(size+1, -1));\\n        \\n        cuts.push_back(n);\\n        cuts.push_back(0);\\n        sort(cuts.begin(), cuts.end());\\n        return recur(1, size, cuts, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303927,
                "title": "java-solution-dp-memoization-tabulation",
                "content": "Here are the two DP Solution based on Memoization and Tabulation Technique.\\nIf you like the solution, then please UPVOTE :)\\n\\nMemoization\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        \\n        int len = cuts.length;\\n        \\n        Arrays.sort(cuts);\\n        \\n        int[] arr = new int[len+2];\\n        for(int i = 1 ; i <= len ; i++)\\n            arr[i] = cuts[i-1];\\n        \\n        arr[0] = 0;\\n        arr[len+1] = n;\\n        int[][] dp = new int[len+1][len+1];\\n        for(int i = 0 ; i <= len ; i++)\\n            for(int j = 0 ; j <= len ; j++)\\n                dp[i][j] = -1;\\n        return cut(arr , 1 , len , dp);\\n    }\\n    \\n    int cut(int[] cuts , int i , int j , int[][] dp){\\n        if(i > j)\\n            return 0;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int mini = Integer.MAX_VALUE;\\n        for(int k = i ; k <= j ; k++){\\n            int cost = cuts[j+1]-cuts[i-1] + cut(cuts , i , k-1 , dp) + cut(cuts , k+1 , j , dp);\\n            mini = Math.min(cost , mini);\\n        }\\n        \\n        return dp[i][j] = mini;\\n    }\\n}\\n```\\n\\nTabulation\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        \\n        int len = cuts.length;\\n        \\n        Arrays.sort(cuts);\\n        \\n        int[] arr = new int[len+2];\\n        for(int i = 1 ; i <= len ; i++)\\n            arr[i] = cuts[i-1];\\n        \\n        arr[0] = 0;\\n        arr[len+1] = n;\\n        int[][] dp = new int[len+2][len+2];\\n        \\n        for(int i = len ; i >= 1 ; i--){\\n            for(int j = 1 ; j <= len ; j++)\\n            {\\n                if(i > j)   continue;\\n                    \\n                int mini = Integer.MAX_VALUE;\\n                for(int k = i ; k <= j ; k++){\\n                    mini = Math.min(arr[j+1]-arr[i-1] + dp[i][k-1] + dp[k+1][j] , mini);\\n                }\\n                dp[i][j] = mini;\\n            }\\n        }\\n        return dp[1][len];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        \\n        int len = cuts.length;\\n        \\n        Arrays.sort(cuts);\\n        \\n        int[] arr = new int[len+2];\\n        for(int i = 1 ; i <= len ; i++)\\n            arr[i] = cuts[i-1];\\n        \\n        arr[0] = 0;\\n        arr[len+1] = n;\\n        int[][] dp = new int[len+1][len+1];\\n        for(int i = 0 ; i <= len ; i++)\\n            for(int j = 0 ; j <= len ; j++)\\n                dp[i][j] = -1;\\n        return cut(arr , 1 , len , dp);\\n    }\\n    \\n    int cut(int[] cuts , int i , int j , int[][] dp){\\n        if(i > j)\\n            return 0;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int mini = Integer.MAX_VALUE;\\n        for(int k = i ; k <= j ; k++){\\n            int cost = cuts[j+1]-cuts[i-1] + cut(cuts , i , k-1 , dp) + cut(cuts , k+1 , j , dp);\\n            mini = Math.min(cost , mini);\\n        }\\n        \\n        return dp[i][j] = mini;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        \\n        int len = cuts.length;\\n        \\n        Arrays.sort(cuts);\\n        \\n        int[] arr = new int[len+2];\\n        for(int i = 1 ; i <= len ; i++)\\n            arr[i] = cuts[i-1];\\n        \\n        arr[0] = 0;\\n        arr[len+1] = n;\\n        int[][] dp = new int[len+2][len+2];\\n        \\n        for(int i = len ; i >= 1 ; i--){\\n            for(int j = 1 ; j <= len ; j++)\\n            {\\n                if(i > j)   continue;\\n                    \\n                int mini = Integer.MAX_VALUE;\\n                for(int k = i ; k <= j ; k++){\\n                    mini = Math.min(arr[j+1]-arr[i-1] + dp[i][k-1] + dp[k+1][j] , mini);\\n                }\\n                dp[i][j] = mini;\\n            }\\n        }\\n        return dp[1][len];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172712,
                "title": "c-dp-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<int> &a, vector<vector<int>> &dp) {\\n        if(i > j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = 1e9;\\n        for(int ind=i; ind<=j; ind++) {\\n            int cost = a[j+1] - a[i-1] + f(i, ind-1, a, dp) + f(ind+1, j, a, dp);\\n            ans = min(ans, cost);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minCost(int n, vector<int>& a) {\\n        int sz = a.size();\\n        a.push_back(n);\\n        a.insert(a.begin(), 0);\\n        vector<vector<int>> dp(sz+1, vector<int> (sz+1, -1));\\n        sort(a.begin(), a.end());\\n        return f(1, sz, a, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<int> &a, vector<vector<int>> &dp) {\\n        if(i > j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = 1e9;\\n        for(int ind=i; ind<=j; ind++) {\\n            int cost = a[j+1] - a[i-1] + f(i, ind-1, a, dp) + f(ind+1, j, a, dp);\\n            ans = min(ans, cost);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minCost(int n, vector<int>& a) {\\n        int sz = a.size();\\n        a.push_back(n);\\n        a.insert(a.begin(), 0);\\n        vector<vector<int>> dp(sz+1, vector<int> (sz+1, -1));\\n        sort(a.begin(), a.end());\\n        return f(1, sz, a, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161741,
                "title": "java-dynamic-programming-recursive-tabulation-striver",
                "content": "\\tclass Solution {\\n\\t\\tpublic int minCost(int n, int[] cuts) {\\n\\t//         int c = cuts.length;\\n\\t//         int[] nCuts = new int[c + 2];\\n\\t//         nCuts[0] = 0;\\n\\t//         nCuts[c + 1] = n;\\n\\t//         System.arraycopy(cuts, 0, nCuts, 1, c);\\n\\t//         Arrays.sort(nCuts);\\n\\n\\t//         int[][] dp = new int[c + 1][c + 1];\\n\\t//         for (int[] d : dp) Arrays.fill(d, -1);\\n\\t//         return solRecursion(1, c, nCuts, dp);\\n\\n\\t\\t\\treturn solTabular(n, cuts);\\n\\t\\t}\\n\\n\\t\\tprivate static int solTabular(int n, int[] cuts) {\\n\\t\\t\\tint c = cuts.length;\\n\\t\\t\\tint[] nCuts = new int[c + 2];\\n\\t\\t\\tnCuts[0] = 0;\\n\\t\\t\\tnCuts[c + 1] = n;\\n\\t\\t\\tSystem.arraycopy(cuts, 0, nCuts, 1, c);\\n\\t\\t\\tArrays.sort(nCuts);\\n\\t\\t\\tint[][] dp = new int[c + 2][c + 2];\\n\\n\\t\\t\\t// Base Case\\n\\t\\t\\t// ------\\n\\n\\t\\t\\t// Simulating The Recursion\\n\\t\\t\\tfor (int i = c; i >= 1; i--) {\\n\\t\\t\\t\\tfor (int j = i; j <= c; j++) {\\n\\t\\t\\t\\t\\tint mini = Integer.MAX_VALUE;\\n\\t\\t\\t\\t\\tfor (int cut = i; cut <= j; cut++) {\\n\\t\\t\\t\\t\\t\\t// Adding The Cost\\n\\t\\t\\t\\t\\t\\tint cost = nCuts[j + 1] - nCuts[i - 1];\\n\\t\\t\\t\\t\\t\\t// Adding The Cost Of The Sub Problems\\n\\t\\t\\t\\t\\t\\tcost += dp[i][cut - 1] + dp[cut + 1][j];\\n\\t\\t\\t\\t\\t\\tmini = Math.min(mini, cost);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdp[i][j] = mini;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[1][c];\\n\\t\\t}\\n\\n\\t\\tprivate static int solRecursion(int i, int j, int[] cuts, int[][] dp) {\\n\\t\\t\\t// Base Case\\n\\t\\t\\tif (i > j) return 0;\\n\\n\\t\\t\\t// Using DP\\n\\t\\t\\tif (dp[i][j] != -1) return dp[i][j];\\n\\n\\t\\t\\tint mini = Integer.MAX_VALUE;\\n\\t\\t\\tfor (int cut = i; cut <= j; cut++) {\\n\\t\\t\\t\\t// Adding The Cost\\n\\t\\t\\t\\tint cost = cuts[j + 1] - cuts[i - 1];\\n\\t\\t\\t\\t// Adding The Cost Of The Sub Problems\\n\\t\\t\\t\\tcost += solRecursion(i, cut - 1, cuts, dp) +\\n\\t\\t\\t\\t\\t\\tsolRecursion(cut + 1, j, cuts, dp);\\n\\t\\t\\t\\tmini = Math.min(mini, cost);\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[i][j] = mini;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic int minCost(int n, int[] cuts) {\\n\\t//         int c = cuts.length;\\n\\t//         int[] nCuts = new int[c + 2];\\n\\t//         nCuts[0] = 0;\\n\\t//         nCuts[c + 1] = n;\\n\\t//         System.arraycopy(cuts, 0, nCuts, 1, c);\\n\\t//         Arrays.sort(nCuts);\\n\\n\\t//         int[][] dp = new int[c + 1][c + 1];\\n\\t//         for (int[] d : dp) Arrays.fill(d, -1);\\n\\t//         return solRecursion(1, c, nCuts, dp);\\n\\n\\t\\t\\treturn solTabular(n, cuts);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2146037,
                "title": "recursion-memoization-tabulation-partition-dp",
                "content": "#### Recursion + Memoization\\nO(m^3) Time and O(m^2) Auxiliary Space where m = cuts.size()\\n```\\nclass Solution\\n{\\n    private:\\n        int helper(int i, int j, vector<int> &cuts, vector<vector< int>> &dp)\\n        {\\n            if (i == j - 1) return 0;\\n            if (dp[i][j] != -1) return dp[i][j];\\n            int ans = 1e9;\\n            for (int k = i + 1; k < j; k++)\\n            {\\n                int currcost = cuts[j] - cuts[i] + helper(i, k, cuts, dp) + helper(k, j, cuts, dp);\\n                ans = min(ans, currcost);\\n            }\\n            return dp[i][j] = ans;\\n        }\\n    public:\\n        int minCost(int n, vector<int> &cuts)\\n        {\\n            cuts.push_back(0);\\n            cuts.push_back(n);\\n            int m = cuts.size();\\n            sort(cuts.begin(), cuts.end());\\n            vector<vector < int>> dp(m, vector<int> (m, -1));\\n            return helper(0, m - 1, cuts, dp);\\n        }\\n};\\n```\\n\\n#### Tabulation\\nO(m^3) Time and O(m^2) Auxiliary Space where m = cuts.size()\\n```\\nint minCost(int n, vector<int> &cuts)\\n{\\n\\tcuts.push_back(0);\\n\\tcuts.push_back(n);\\n\\tint m = cuts.size();\\n\\tsort(cuts.begin(), cuts.end());\\n\\tvector<vector < int>> dp(m, vector<int> (m, 0));\\n\\tfor (int i = m - 1; i >= 0; i--)\\n\\t{\\n\\t\\tfor (int j = i + 1; j <= m - 1; j++)\\n\\t\\t{\\n\\t\\t\\tif (i == j - 1) dp[i][j] = 0;\\t// base case\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint ans = 1e9;\\n\\t\\t\\t\\tfor (int k = i + 1; k < j; k++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint currcost = cuts[j] - cuts[i] + dp[i][k] + dp[k][j];\\n\\t\\t\\t\\t\\tans = min(ans, currcost);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp[i][j] = ans;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][m - 1];\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    private:\\n        int helper(int i, int j, vector<int> &cuts, vector<vector< int>> &dp)\\n        {\\n            if (i == j - 1) return 0;\\n            if (dp[i][j] != -1) return dp[i][j];\\n            int ans = 1e9;\\n            for (int k = i + 1; k < j; k++)\\n            {\\n                int currcost = cuts[j] - cuts[i] + helper(i, k, cuts, dp) + helper(k, j, cuts, dp);\\n                ans = min(ans, currcost);\\n            }\\n            return dp[i][j] = ans;\\n        }\\n    public:\\n        int minCost(int n, vector<int> &cuts)\\n        {\\n            cuts.push_back(0);\\n            cuts.push_back(n);\\n            int m = cuts.size();\\n            sort(cuts.begin(), cuts.end());\\n            vector<vector < int>> dp(m, vector<int> (m, -1));\\n            return helper(0, m - 1, cuts, dp);\\n        }\\n};\\n```\n```\\nint minCost(int n, vector<int> &cuts)\\n{\\n\\tcuts.push_back(0);\\n\\tcuts.push_back(n);\\n\\tint m = cuts.size();\\n\\tsort(cuts.begin(), cuts.end());\\n\\tvector<vector < int>> dp(m, vector<int> (m, 0));\\n\\tfor (int i = m - 1; i >= 0; i--)\\n\\t{\\n\\t\\tfor (int j = i + 1; j <= m - 1; j++)\\n\\t\\t{\\n\\t\\t\\tif (i == j - 1) dp[i][j] = 0;\\t// base case\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint ans = 1e9;\\n\\t\\t\\t\\tfor (int k = i + 1; k < j; k++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint currcost = cuts[j] - cuts[i] + dp[i][k] + dp[k][j];\\n\\t\\t\\t\\t\\tans = min(ans, currcost);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp[i][j] = ans;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][m - 1];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143004,
                "title": "java-2d-dp-mcm",
                "content": "```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) \\n    {\\n        int size=cuts.length;\\n        Arrays.sort(cuts);\\n        int cut[]=new int[size+2];\\n        \\n        for(int i=0;i<size;i++)\\n        {\\n            cut[i+1]=cuts[i];\\n        }\\n        cut[size+1]=n;\\n        \\n        int dp[][]=new int[size+3][size+3];\\n        for(int y[]:dp)\\n        Arrays.fill(y,-1);\\n        \\n        return helper(1,size,cut,dp);\\n    }\\n    \\n    public int helper(int start,int end,int cut[],int dp[][])\\n    {\\n        if(start>end)\\n        return 0;\\n        \\n        if(dp[start][end]!=-1)\\n        return dp[start][end];\\n        \\n        int ans=cut[end+1]-cut[start-1]; \\n        int min=Integer.MAX_VALUE;\\n        \\n        for(int i=start;i<=end;i++)\\n        {\\n            int left=helper(start,i-1,cut,dp);\\n            int right=helper(i+1,end,cut,dp);\\n            \\n            min=Math.min(min,left+right);\\n        }\\n        \\n        ans+=min;\\n        \\n        dp[start][end]=ans;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) \\n    {\\n        int size=cuts.length;\\n        Arrays.sort(cuts);\\n        int cut[]=new int[size+2];\\n        \\n        for(int i=0;i<size;i++)\\n        {\\n            cut[i+1]=cuts[i];\\n        }\\n        cut[size+1]=n;\\n        \\n        int dp[][]=new int[size+3][size+3];\\n        for(int y[]:dp)\\n        Arrays.fill(y,-1);\\n        \\n        return helper(1,size,cut,dp);\\n    }\\n    \\n    public int helper(int start,int end,int cut[],int dp[][])\\n    {\\n        if(start>end)\\n        return 0;\\n        \\n        if(dp[start][end]!=-1)\\n        return dp[start][end];\\n        \\n        int ans=cut[end+1]-cut[start-1]; \\n        int min=Integer.MAX_VALUE;\\n        \\n        for(int i=start;i<=end;i++)\\n        {\\n            int left=helper(start,i-1,cut,dp);\\n            int right=helper(i+1,end,cut,dp);\\n            \\n            min=Math.min(min,left+right);\\n        }\\n        \\n        ans+=min;\\n        \\n        dp[start][end]=ans;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134676,
                "title": "very-easy-understandable-partition-dp-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n     int f(int n, int c,vector<int>& cuts,int i,int j, vector<vector< int>>&dp)\\n    {\\n        if(i>j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int mini=1e7;\\n        \\n    \\n        for(int ind=i;ind<=j;ind++)\\n        {\\n            int steps=cuts[j+1]-cuts[i-1]+f(n,c,cuts,i,ind-1,dp)+f(n,c,cuts,ind+1,j,dp);\\n            mini=min((int)steps,mini);\\n        }\\n        return dp[i][j]=mini;\\n            \\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        //so we will push 0 at begin and n at last so that we are able to get length easily\\n        int c=cuts.size();\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        \\n        //we will sort it down so that when we use recursion/dp cases are alwatys independedntg\\n        \\n        sort(cuts.begin(),cuts.end());\\n        vector<vector< int>>dp(c+1,vector<int>(c+1,-1));\\n        return f(n,c,cuts,1,c,dp);\\n        \\n        //Please upvote if you understood :)\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n     int f(int n, int c,vector<int>& cuts,int i,int j, vector<vector< int>>&dp)\\n    {\\n        if(i>j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int mini=1e7;\\n        \\n    \\n        for(int ind=i;ind<=j;ind++)\\n        {\\n            int steps=cuts[j+1]-cuts[i-1]+f(n,c,cuts,i,ind-1,dp)+f(n,c,cuts,ind+1,j,dp);\\n            mini=min((int)steps,mini);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2089752,
                "title": "cpp-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int f ( int i , int j , vector<int> &cuts , vector<vector<int>> &dp){\\n        // the base case if i > j means there can be no more partition , return 0\\n        if ( i > j ) return 0;\\n        if ( dp[i][j] != -1) return dp[i][j];\\n        int mn = INT_MAX;\\n        for ( int ind = i ; ind <= j ; ind ++){\\n            int cost = ( cuts.at(j + 1) - cuts.at(i - 1)) + f( i , ind - 1 , cuts ,dp ) + f( ind + 1 , j , cuts , dp);\\n            mn = min ( mn , cost );\\n        }\\n        \\n        return dp[i][j] = mn;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n         // this is a nice question \\n        // here we will add 0 and n to cuts\\n        // then we will sort the cuts array \\n        // then we will find the best possibility to have the answer\\n        // we will use dp memoization to solve this\\n        \\n        // this is topic of dp on partition\\n        \\n        // first adding the 0 and n to the cuts array\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin() , 0);\\n        \\n        // now sorting the array \\n        sort( cuts.begin() , cuts.end());\\n        for( auto i : cuts ) cout << i << endl;\\n        // now we will compute using the dp\\n        vector<vector<int >> dp ( cuts.size() + 1 , vector<int> ( cuts.size() + 1 , -1 ));\\n        return f ( 1 , cuts.size()-2 , cuts , dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int f ( int i , int j , vector<int> &cuts , vector<vector<int>> &dp){\\n        // the base case if i > j means there can be no more partition , return 0\\n        if ( i > j ) return 0;\\n        if ( dp[i][j] != -1) return dp[i][j];\\n        int mn = INT_MAX;\\n        for ( int ind = i ; ind <= j ; ind ++){\\n            int cost = ( cuts.at(j + 1) - cuts.at(i - 1)) + f( i , ind - 1 , cuts ,dp ) + f( ind + 1 , j , cuts , dp);\\n            mn = min ( mn , cost );\\n        }\\n        \\n        return dp[i][j] = mn;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n         // this is a nice question \\n        // here we will add 0 and n to cuts\\n        // then we will sort the cuts array \\n        // then we will find the best possibility to have the answer\\n        // we will use dp memoization to solve this\\n        \\n        // this is topic of dp on partition\\n        \\n        // first adding the 0 and n to the cuts array\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin() , 0);\\n        \\n        // now sorting the array \\n        sort( cuts.begin() , cuts.end());\\n        for( auto i : cuts ) cout << i << endl;\\n        // now we will compute using the dp\\n        vector<vector<int >> dp ( cuts.size() + 1 , vector<int> ( cuts.size() + 1 , -1 ));\\n        return f ( 1 , cuts.size()-2 , cuts , dp);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2078957,
                "title": "python3-beats-85-time-95-memory-dp-recursion-memoization-tabulation-explained",
                "content": "This is a partition Dynamic Programming problem where you want to optimize a problem where you can spit an input array into multiple partitions and receive different scores based on the partition you choose. A classic example of this is the Matrix Multiplication Problem.\\n\\neg:\\n`f(x) = f(0, k-1) + f(k+1, j) + C` for some chosen partition k and some constants C\\n\\nYou can work through these problems in 3 phases:\\n\\n1. Find the bruteforce recursive solution\\n2. Implement memoization to decrease the runtime complexity\\n3. Convert from memoization to tabulation for space optimization\\n\\n \\n \\n### Understanding the problem\\nFor each cut we make into the rod, the total cost of that cut will be\\n```cost = (total cost of new left rod) + (total cost of new right rod) + length of rod before cut```\\nso for a rod of length 7, with a cut at k=3\\n```cost = f(rod from 0->3) + f(rod from 3->7) + 7```\\n\\nFor implementation purposes, we can add the bounds of the original rod to the cuts array such that `A = [0] + cuts + [n]`. With this, we can derive our cost relation as\\n```cost = f(i, k-1) + f(k+1, j) + A[j+1]-A[i-1]``` and call our function initially with `i=1, j=len(cuts)`\\n\\nSo for a rod of length 7 with `cuts = [1, 3, 4, 5]`, we would call `f(1, 4)`.\\n\\nIf we wanted to make a cut at k=2, for example\\n```\\n[0, 1, 3, 4, 5, 7]\\n    i  k     j\\n```\\n\\nthe cost of this cut would be `cost = f(1, 1) + f(3, 4) + A[5] - A[0]`, where `A[5]-A[0] = 7`, the length of the rod before the cut.\\n\\nWe want to find the minimum cost, so for our rod, we need to try every cut within the range of the rod, ie, from i -> j in our cuts array. We sort our initial cuts array so that we know we\\'re only trying cuts that are permitted for this size rod. We minimise the cost and return it for each rod, recursively calculating the cost of the previous. larger rod.\\n\\n\\n### Recursive Solution\\n```\\nclass Solution:\\n    def minCostRecursive(self, n: int, cuts: List[int]) -> int:\\n        \\n\\t\\t# make sure we have a sorted array so that we don\\'t try to make an invalid cut\\n        cuts.sort()\\n\\t\\t# add our bounds so we can easily find the length of the rod\\n        A = [0] + cuts + [n]\\n        \\n        def dfs(i, j, A):\\n            if i > j:\\n                return 0\\n            \\n            mini = float(\"inf\")\\n            for k in range(i, j+1):\\n\\t\\t\\t\\t# calculate the cost of the given cut\\n                cost = A[j+1]-A[i-1] + dfs(i, k-1, A, dp) + dfs(k+1, j, A, dp)\\n\\t\\t\\t\\t# minimise the cost\\n                mini = min(cost, mini)\\n            \\n            return mini\\n                \\n        res = dfs(1, len(cuts), A)\\n        return res\\n```\\n\\nThe time complexity of this solution is logarithmic however, which isn\\'t optimal. We can use memoization to improve this.\\n\\n### Memoization / Top Down DP\\nWe know that the bounds for our values i and j are len(cuts) so we can make a 2D array or len(cuts)\\\\*len(cuts) in size to store previously computed values.\\n\\n```\\nclass Solution:\\n\\tdef minCostMemo(self, n: int, cuts: List[int]) -> int:\\n        \\n        cuts.sort()\\n        A = [0] + cuts + [n]\\n        \\n        def dfs(i, j, A, dp):\\n            if i > j:\\n                return 0\\n\\t\\t\\t# check the memoization cache\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            \\n            mini = float(\"inf\")\\n            for k in range(i, j+1):\\n                cost = A[j+1]-A[i-1] + dfs(i, k-1, A, dp) + dfs(k+1, j, A, dp)\\n                mini = min(cost, mini)\\n            \\n\\t\\t\\t# set the computed value so we don\\'t have to recompute\\n            dp[i][j] = mini\\n            return mini\\n                \\n\\t\\t# build our len(cuts)*len(cuts) 2D array cache\\n        dp = [[-1 for j in range(len(cuts)+1)] for i in range(len(cuts)+1)]\\n        \\n        res = dfs(1, len(cuts), A, dp)\\n        return res\\n```\\n\\nThis is a good solution, running in O(N^3) time, however we\\'re using O(len(cuts)^2 + stack space) space.\\nThis can be optimized by using iterative tabulation instead of recursion to remove the stack space.\\n\\n### Tabulation / Bottom-Up DP\\nTo move from a Top Down solution to a Bottom Up Solution, we can follow the following pattern.\\n\\n#### Copy our base-cases and implement in a tabular fashion\\nTo do this, we can see our base case is:\\n```\\nif i > j:\\n\\treturn 0\\n```\\n\\nSince it\\'s 0, we can just implement the default value in our DP table to be 0.\\n\\n```dp = [[0 for j in range(len(cuts)+1)] for i in range(len(cuts)+1)]```\\n\\n#### Implement our nested for loops in the opposite direction from the recursion\\nIn our recursive solutions, i tends to N such that i = (1 -> len(cuts)), and j tends to 0 such that j = (len(cuts) -> 1). Remember, 0 is the base case!\\nWith this, we can flip these for our for loops such that:\\n```\\n        for i in range(len(cuts), 0, -1): # i goes from len(cuts) -> 1\\n            for j in range(1, len(cuts)+1): # j goes from 1 -> len(cuts)\\n```\\n\\n#### Copy the recurrence, and use the DP table instead of recursive calls\\nOur original memoization recurrence was\\n```\\n\\tif i > j:\\n\\t\\treturn 0\\n\\tif dp[i][j] != -1:\\n\\t\\treturn dp[i][j]\\n\\n\\t\\tmini = float(\"inf\")\\n\\t\\tfor k in range(i, j+1):\\n\\t\\t\\tcost = A[j+1]-A[i-1] + dfs(i, k-1, A, dp) + dfs(k+1, j, A, dp)\\n\\t\\t\\tmini = min(cost, mini)\\n\\n\\t\\tdp[i][j] = mini\\n```\\n\\nIf we make our changes we\\'re left with\\n```\\n\\tfor i in range(len(cuts), 0, -1):\\n\\t\\tfor j in range(1, len(cuts)+1):\\n\\t\\t\\tif i > j:\\n\\t\\t\\t\\t# base case is already set to 0, so just skip\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tmini = float(\"inf\")\\n\\t\\t\\tfor k in range(i, j+1):\\n\\t\\t\\t\\t# check our valid cuts\\n\\t\\t\\t\\tcost = A[j+1]-A[i-1] + dp[i][k-1] + dp[k+1][j]\\n\\t\\t\\t\\tmini = min(cost, mini)\\n\\t\\t\\t# update our minimal cost\\n\\t\\t\\tdp[i][j] = mini\\n```\\n\\nThere\\'s one edge case in the recurrence here however. Since j can be len(cuts), and k can be j, and our index for our cut can be `k+1`. Our DP array needs to be adjusted to have some extra space so that we don\\'t go out of bounds.\\n\\nie:\\n`dp = [[0 for j in range(len(cuts)+1)] for i in range(len(cuts)+1)]` becomes `dp = [[0 for j in range(len(cuts)+2)] for i in range(len(cuts)+2)]`\\n\\nFinally if we put this all together we get:\\n\\n```\\nclass Solution:\\n    def minCostTab(self, n: int, cuts: List[int]) -> int:\\n        cuts.sort()\\n        A = [0] + cuts + [n]\\n        dp = [[0 for j in range(len(cuts)+2)] for i in range(len(cuts)+2)]\\n        \\n        for i in range(len(cuts), 0, -1):\\n            for j in range(1, len(cuts)+1):\\n                if i > j:\\n                    continue\\n                mini = float(\"inf\")\\n                for k in range(i, j+1):\\n                    cost = A[j+1]-A[i-1] + dp[i][k-1] + dp[k+1][j]\\n                    mini = min(cost, mini)\\n                dp[i][j] = mini\\n        return dp[1][len(cuts)]\\n```\\n\\nI hope this helps, sorry if anything is unclear, this is my first time trying to write a solution post.\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```cost = (total cost of new left rod) + (total cost of new right rod) + length of rod before cut```\n```cost = f(rod from 0->3) + f(rod from 3->7) + 7```\n```cost = f(i, k-1) + f(k+1, j) + A[j+1]-A[i-1]```\n```\\n[0, 1, 3, 4, 5, 7]\\n    i  k     j\\n```\n```\\nclass Solution:\\n    def minCostRecursive(self, n: int, cuts: List[int]) -> int:\\n        \\n\\t\\t# make sure we have a sorted array so that we don\\'t try to make an invalid cut\\n        cuts.sort()\\n\\t\\t# add our bounds so we can easily find the length of the rod\\n        A = [0] + cuts + [n]\\n        \\n        def dfs(i, j, A):\\n            if i > j:\\n                return 0\\n            \\n            mini = float(\"inf\")\\n            for k in range(i, j+1):\\n\\t\\t\\t\\t# calculate the cost of the given cut\\n                cost = A[j+1]-A[i-1] + dfs(i, k-1, A, dp) + dfs(k+1, j, A, dp)\\n\\t\\t\\t\\t# minimise the cost\\n                mini = min(cost, mini)\\n            \\n            return mini\\n                \\n        res = dfs(1, len(cuts), A)\\n        return res\\n```\n```\\nclass Solution:\\n\\tdef minCostMemo(self, n: int, cuts: List[int]) -> int:\\n        \\n        cuts.sort()\\n        A = [0] + cuts + [n]\\n        \\n        def dfs(i, j, A, dp):\\n            if i > j:\\n                return 0\\n\\t\\t\\t# check the memoization cache\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            \\n            mini = float(\"inf\")\\n            for k in range(i, j+1):\\n                cost = A[j+1]-A[i-1] + dfs(i, k-1, A, dp) + dfs(k+1, j, A, dp)\\n                mini = min(cost, mini)\\n            \\n\\t\\t\\t# set the computed value so we don\\'t have to recompute\\n            dp[i][j] = mini\\n            return mini\\n                \\n\\t\\t# build our len(cuts)*len(cuts) 2D array cache\\n        dp = [[-1 for j in range(len(cuts)+1)] for i in range(len(cuts)+1)]\\n        \\n        res = dfs(1, len(cuts), A, dp)\\n        return res\\n```\n```\\nif i > j:\\n\\treturn 0\\n```\n```dp = [[0 for j in range(len(cuts)+1)] for i in range(len(cuts)+1)]```\n```\\n        for i in range(len(cuts), 0, -1): # i goes from len(cuts) -> 1\\n            for j in range(1, len(cuts)+1): # j goes from 1 -> len(cuts)\\n```\n```\\n\\tif i > j:\\n\\t\\treturn 0\\n\\tif dp[i][j] != -1:\\n\\t\\treturn dp[i][j]\\n\\n\\t\\tmini = float(\"inf\")\\n\\t\\tfor k in range(i, j+1):\\n\\t\\t\\tcost = A[j+1]-A[i-1] + dfs(i, k-1, A, dp) + dfs(k+1, j, A, dp)\\n\\t\\t\\tmini = min(cost, mini)\\n\\n\\t\\tdp[i][j] = mini\\n```\n```\\n\\tfor i in range(len(cuts), 0, -1):\\n\\t\\tfor j in range(1, len(cuts)+1):\\n\\t\\t\\tif i > j:\\n\\t\\t\\t\\t# base case is already set to 0, so just skip\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tmini = float(\"inf\")\\n\\t\\t\\tfor k in range(i, j+1):\\n\\t\\t\\t\\t# check our valid cuts\\n\\t\\t\\t\\tcost = A[j+1]-A[i-1] + dp[i][k-1] + dp[k+1][j]\\n\\t\\t\\t\\tmini = min(cost, mini)\\n\\t\\t\\t# update our minimal cost\\n\\t\\t\\tdp[i][j] = mini\\n```\n```\\nclass Solution:\\n    def minCostTab(self, n: int, cuts: List[int]) -> int:\\n        cuts.sort()\\n        A = [0] + cuts + [n]\\n        dp = [[0 for j in range(len(cuts)+2)] for i in range(len(cuts)+2)]\\n        \\n        for i in range(len(cuts), 0, -1):\\n            for j in range(1, len(cuts)+1):\\n                if i > j:\\n                    continue\\n                mini = float(\"inf\")\\n                for k in range(i, j+1):\\n                    cost = A[j+1]-A[i-1] + dp[i][k-1] + dp[k+1][j]\\n                    mini = min(cost, mini)\\n                dp[i][j] = mini\\n        return dp[1][len(cuts)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058844,
                "title": "c-simple-approach",
                "content": "If you like please upvote :)\\n```\\nclass Solution {\\npublic:\\n    \\n    int find(int i, int j, vector<int>& cuts , vector<vector<int>>& dp){\\n        if(i>j) return 0;\\n        \\n        if(dp[i][j]!=-1)  return dp[i][j];\\n        int mini =INT_MAX;\\n        \\n        for(int idx=i; idx<=j; idx++){\\n            int cost = cuts[j+1]-cuts[i-1]+ find(i,idx-1,cuts, dp)+ find(idx+1,j,cuts,dp);\\n            mini = min(cost,mini);\\n        }\\n        return dp[i][j]=mini;\\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        \\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        \\n        sort(cuts.begin(), cuts.end());\\n        \\n        vector<vector<int>> dp(cuts.size()+1, vector<int>(cuts.size()+1, -1));\\n        \\n        return find(1,cuts.size()-2, cuts, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int find(int i, int j, vector<int>& cuts , vector<vector<int>>& dp){\\n        if(i>j) return 0;\\n        \\n        if(dp[i][j]!=-1)  return dp[i][j];\\n        int mini =INT_MAX;\\n        \\n        for(int idx=i; idx<=j; idx++){\\n            int cost = cuts[j+1]-cuts[i-1]+ find(i,idx-1,cuts, dp)+ find(idx+1,j,cuts,dp);\\n            mini = min(cost,mini);\\n        }\\n        return dp[i][j]=mini;\\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        \\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        \\n        sort(cuts.begin(), cuts.end());\\n        \\n        vector<vector<int>> dp(cuts.size()+1, vector<int>(cuts.size()+1, -1));\\n        \\n        return find(1,cuts.size()-2, cuts, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039266,
                "title": "recurssion-memoization-c-memory-optimised",
                "content": "```\\nclass Solution {\\npublic:\\n    // int ans = INT_MAX;\\n    \\n    int help(int s, int e, vector<int>&cuts, map<pair<int,int>,int>&memo){\\n        if(s>=e) return 0;\\n        if(memo.count({s,e})) return memo[{s,e}];\\n        int ans = INT_MAX;\\n        for(int i =0;i<cuts.size();i++){\\n            if(cuts[i]>s && cuts[i]<e){\\n                int t = e-s + help(s,cuts[i],cuts,memo) + help(cuts[i],e,cuts,memo);\\n                ans = min(t,ans);\\n                // cout<<ans<<\"   \";\\n            }\\n        }\\n        memo[{s,e}] = ans==INT_MAX ? 0:ans;\\n        return ans==INT_MAX ? 0:ans;\\n        \\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n         map<pair<int,int>,int> memo;\\n        return help(0,n,cuts,memo);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // int ans = INT_MAX;\\n    \\n    int help(int s, int e, vector<int>&cuts, map<pair<int,int>,int>&memo){\\n        if(s>=e) return 0;\\n        if(memo.count({s,e})) return memo[{s,e}];\\n        int ans = INT_MAX;\\n        for(int i =0;i<cuts.size();i++){\\n            if(cuts[i]>s && cuts[i]<e){\\n                int t = e-s + help(s,cuts[i],cuts,memo) + help(cuts[i],e,cuts,memo);\\n                ans = min(t,ans);\\n                // cout<<ans<<\"   \";\\n            }\\n        }\\n        memo[{s,e}] = ans==INT_MAX ? 0:ans;\\n        return ans==INT_MAX ? 0:ans;\\n        \\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n         map<pair<int,int>,int> memo;\\n        return help(0,n,cuts,memo);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2030962,
                "title": "4-lines-python-recursion-with-thought-process-when-being-asked-during-interviews",
                "content": "### Recursion + Memoization\\nIt indicates recursion or divide and conquer that each cut splits stick to 2 indenpendent pieces, each of which can be processed separately. However, the cuts is not ordered, but we can reorder it. So we can simply sort `cuts` first to guarantee for each index `k`,  any index `i` that `i < k` is a cut to the left side of `k`, similarily any index `j` that `j > k` is to the right side of `k`.  \\nThen we can run recursion by iterating each `k` between given `i` and `j`. The base case is that `i + 1 == j`, and we return 0. \\nFinally, use memoization to reduce repeated calculation.\\n\\nAlso, the number of `cuts` is up to 100, indicating `size of cuts * size of cuts` is acceptable. \\n\\nFor easy implemenation, we can add the `0` and `n` to both end as boundaries.\\n\\n```python\\ndef minCost(self, n: int, cuts: List[int]) -> int:\\n    cuts = sorted([0] + cuts + [n])\\n\\n\\t@cache \\n    def helper(i, j):\\n\\t\\tif i + 1 == j: return 0\\n\\t\\treturn cuts[j] - cuts[i] + min(helper(i, k) + helper(k, j) for k in range(i + 1, j))\\n\\treturn helper(0, len(cuts) - 1)\\n```\\n\\n*Time Complexity*= **O(M^2)**, where *M* represents the size of `cuts`.\\n*Space Complexity*= **O(M^2)**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```python\\ndef minCost(self, n: int, cuts: List[int]) -> int:\\n    cuts = sorted([0] + cuts + [n])\\n\\n\\t@cache \\n    def helper(i, j):\\n\\t\\tif i + 1 == j: return 0\\n\\t\\treturn cuts[j] - cuts[i] + min(helper(i, k) + helper(k, j) for k in range(i + 1, j))\\n\\treturn helper(0, len(cuts) - 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1984004,
                "title": "c-mcm-brust-ballon-palindromic-partision-variation",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>> &dp,vector<int> &cuts,int i,int j,int left,int right)\\n    {\\n        if(i==j) return right-left;\\n        if(i>j) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=100000007;\\n        \\n        for(int k=i;k<=j;k++)\\n        {\\n           int temp=(right-left)+ helper(dp,cuts,i,k-1,left,cuts[k])+helper(dp,cuts,k+1,j,cuts[k],right);\\n            ans=min(ans,temp);\\n        }\\n        \\n        return dp[i][j]=ans;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(),cuts.end());\\n        vector<vector<int>> dp(cuts.size(),vector<int> (cuts.size(),-1));\\n        \\n        return helper(dp,cuts,0,cuts.size()-1,0,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>> &dp,vector<int> &cuts,int i,int j,int left,int right)\\n    {\\n        if(i==j) return right-left;\\n        if(i>j) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=100000007;\\n        \\n        for(int k=i;k<=j;k++)\\n        {\\n           int temp=(right-left)+ helper(dp,cuts,i,k-1,left,cuts[k])+helper(dp,cuts,k+1,j,cuts[k],right);\\n            ans=min(ans,temp);\\n        }\\n        \\n        return dp[i][j]=ans;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(),cuts.end());\\n        vector<vector<int>> dp(cuts.size(),vector<int> (cuts.size(),-1));\\n        \\n        return helper(dp,cuts,0,cuts.size()-1,0,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573122,
                "title": "python-simple-and-easy-to-understand-solution-recursion-memoization",
                "content": "* We start with entire length of stick (0 to n) and then try cutting at every possible position and keep track of minimum cost\\n* The cost will be length of stick i.e., end - start\\n* When we cut a stick it will be devided into two parts - start to cut (index where we cut) + cur to end\\n\\n```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cache = {}\\n\\t\\t\\n        def helper(start, end):\\n            if (start, end) in cache:\\n                return cache[(start,end)]\\n            res = float(\"Inf\")\\n            for cut in cuts:\\n                if start < cut < end:\\n                    res = min(res, helper(start, cut) + helper(cut, end) + end-start)\\n            \\n            cache[(start, end)] = res if res != float(\"Inf\") else 0\\n            return cache[(start, end)]\\n        \\n        return helper(0, n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cache = {}\\n\\t\\t\\n        def helper(start, end):\\n            if (start, end) in cache:\\n                return cache[(start,end)]\\n            res = float(\"Inf\")\\n            for cut in cuts:\\n                if start < cut < end:\\n                    res = min(res, helper(start, cut) + helper(cut, end) + end-start)\\n            \\n            cache[(start, end)] = res if res != float(\"Inf\") else 0\\n            return cache[(start, end)]\\n        \\n        return helper(0, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437059,
                "title": "c-descriptive-bottom-up-dp-recursive-memoization-top-down",
                "content": "We have a stick of length N and can make cuts only where we are allowed. Now the cost of cutting a stick is equal to its length. \\nex Example 1:\\n\\n![image](https://assets.leetcode.com/users/images/d86ef826-eae3-4acf-ad5c-7b40d55d802f_1630423796.4006917.png)\\n\\nInput: n = 7, cuts = [1,3,4,5]\\nOutput: 16\\nExplanation: Using cuts order = [1, 3, 4, 5] as in the input leads to the following scenario:\\nThe first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.\\nRearranging the cuts to be [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).\\n\\n## Recusive Approach\\n\\n### Base Case\\nIf we a cut the rod and end up with a peice which has a stating index si and ending index ei . Like in our example 1 , when we reach a point at which the startig index =  1 and ending index of rod peice is 3 ,(second peice in the end) , we are not allowed to cut the rod anywhere in this range , hence here our answer should be 0.\\n\\n### Hypothesis \\n\\n**Our Job is to just divide the rod into two peices and let recursion handle the rest.**\\nSo if we have a rod peice with starting index si and index ei , then we try to divide the rod into 2 peice , by cutting it at any of the given points and get the ans , see which is two division , guve the minimun sum of cuts.\\nEx . when we have starting index = and ending index is 7 , we need to check all places where we can it . \\n* Case 1 , cut it at length 1. case1 = minWays(0,1) + minWays(1,7)\\n* Case 2 , cut it at length 3, case2 = minWays(0,3) + minWays (3,7).\\n* Case 3 , cut it at length 4 , case3 = minWays(0,4) + minWays(4,7).\\n* Case 4 , cut it at length 5 , case4 = minWays(0,5) + minWays(5,7).\\n\\n### Induction Step\\n\\nNow we take the minmum of these 4 and add our length to it\\n\\nOur answer = (7-0) + min(case1 , case2 , case3 , case4)\\n\\n### Coding for Recursive Approach + Adding Memoizsation\\n\\nSo , we cant really cut this road at any places instead of the places given , so we add 0 and length of rod to the given cuts array and sort it.\\nAlthough we pass the indexes of the array , these can handle the rod cuts and length .\\nbecause evntually any final rod element left  will have si and ei from the cuts array.\\n\\nWhen we start building the recusion tree we see that there are a lot of overlapping subproblems .\\n\\nEx\\n* in case1 minCost(0,7) if cut at 1 first , will call , minCost(0,1) and minCost(1,7).\\n* mincost(1,7) will difenitely hit minCost(1,3) , minCost(3,7) and these will further call minCost(3,4) , minCost(4,7) ans so on.\\n* When we calculate for case2 a cut at 3 , it will again at some make these calls and there will be subroblems. (Draw recursion tree)\\n\\nHence we create a dp and use a memoization solution to store our answer and reach at the below given Top-Down Approach.\\n\\n\\n```\\n\\n    int minCostMemo(int n , vector<int>& cuts , int dp[103][103] ,int si , int ei ){\\n            \\n        if((ei-si)<=1){\\n            return 0;\\n        }\\n        \\n        if(dp[si][ei]!=-1){\\n            return dp[si][ei];\\n        }\\n        int smallAns =  INT_MAX;\\n        for(int i = si+1 ; i < ei ; i++){\\n            int p1 =  minCostMemo(n,cuts,dp,si,i);\\n            int p2 =  minCostMemo(n,cuts,dp,i,ei);\\n            smallAns = min(p1+p2 , smallAns);\\n        }\\n        int myAns = smallAns +  cuts[ei]-cuts[si];\\n        dp[si][ei] = myAns ;\\n        return myAns;\\n        \\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n                \\n        int minCutIndex = INT_MAX;\\n        int maxCutIndex = INT_MIN;\\n        vector<int> cutsIndex;\\n        for(int i = 0 ; i  < cuts.size() ; i++){\\n            minCutIndex=min(minCutIndex,cuts[i]);\\n            maxCutIndex=max(maxCutIndex,cuts[i]);\\n            cutsIndex.push_back(cuts[i]);\\n        }\\n      \\n        if(minCutIndex != 0){\\n            cutsIndex.push_back(0);\\n        }\\n        if(maxCutIndex != n){\\n            cutsIndex.push_back(n);\\n        }\\n        \\n        sort(cutsIndex.begin(), cutsIndex.end());\\n        int N = cutsIndex.size();\\n        int dp[103][103];\\n        for(int i = 0 ; i<N ; i++ ){\\n            for(int j = 0 ; j <N ; j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        \\n        int ans = minCostMemo(N,  cutsIndex , dp , 0 , N-1);\\n        \\n        \\n        return ans;      \\n    }\\n\\t\\n\\t\\n```\\n\\t\\n## Dynamic Programming (Bottom-Up)\\n\\nNow We see  that at the end , we stop when there are 0 cuts between the starting and ending points  , answer will be 0 . We calculate answers for cases where the the number of cuts between the starting index and eding index of rod peice is 1 , then when we calclate the ans for the cases where gap between startinga and ending peices is 2 , we will depend on precomputed answer and, we fill our DP matrix  diagonally .\\n\\ndp[i][j] stores the min cost of cutting we cut  the rod starting from length cutsIndxes[i] and cutsIndex[j]\\n\\n ```\\nint minCost(int n, vector<int>& cuts) {\\n\\n\\tint minCutIndex = INT_MAX;\\n\\tint maxCutIndex = INT_MIN;\\n\\tvector<int> cutsIndex;\\n\\tfor(int i = 0 ; i  < cuts.size() ; i++){\\n\\t\\tminCutIndex=min(minCutIndex,cuts[i]);\\n\\t\\tmaxCutIndex=max(maxCutIndex,cuts[i]);\\n\\t\\tcutsIndex.push_back(cuts[i]);\\n\\t}\\n\\n\\tif(minCutIndex != 0){\\n\\t\\tcutsIndex.push_back(0);\\n\\t}\\n\\tif(maxCutIndex != n){\\n\\t\\tcutsIndex.push_back(n);\\n\\t}\\n\\n\\tsort(cutsIndex.begin(), cutsIndex.end());\\n\\tint N = cutsIndex.size();\\n\\tint dp[103][103];\\n\\tfor(int i = 0 ; i<N ; i++ ){\\n\\t\\tfor(int j = 0 ; j <N ; j++){\\n\\t\\t\\tdp[i][j] = 0;\\n\\t\\t}\\n\\t}\\n\\n\\tfor(int gap = 2 ;  gap < N ; gap++){\\n\\t\\tfor(int i =0,j=gap ; i <N &&j<N ; i++,j++){\\n\\t\\t\\tint ans =INT_MAX;\\n\\t\\t\\tfor(int k = i+1 ; k<j ;k++){\\n\\t\\t\\t\\tans=min(ans,dp[i][k] + dp[k][j]);\\n\\t\\t\\t}\\n\\t\\t\\tdp[i][j] = ans+cutsIndex[j]-cutsIndex[i] ;\\n\\t\\t}\\n\\t}\\n\\n\\t// int ans = minCostMemo(N,  cutsIndex , dp , 0 , N-1);\\n\\tint ans = dp[0][N-1];\\n\\n\\treturn ans;      \\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\n    int minCostMemo(int n , vector<int>& cuts , int dp[103][103] ,int si , int ei ){\\n            \\n        if((ei-si)<=1){\\n            return 0;\\n        }\\n        \\n        if(dp[si][ei]!=-1){\\n            return dp[si][ei];\\n        }\\n        int smallAns =  INT_MAX;\\n        for(int i = si+1 ; i < ei ; i++){\\n            int p1 =  minCostMemo(n,cuts,dp,si,i);\\n            int p2 =  minCostMemo(n,cuts,dp,i,ei);\\n            smallAns = min(p1+p2 , smallAns);\\n        }\\n        int myAns = smallAns +  cuts[ei]-cuts[si];\\n        dp[si][ei] = myAns ;\\n        return myAns;\\n        \\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n                \\n        int minCutIndex = INT_MAX;\\n        int maxCutIndex = INT_MIN;\\n        vector<int> cutsIndex;\\n        for(int i = 0 ; i  < cuts.size() ; i++){\\n            minCutIndex=min(minCutIndex,cuts[i]);\\n            maxCutIndex=max(maxCutIndex,cuts[i]);\\n            cutsIndex.push_back(cuts[i]);\\n        }\\n      \\n        if(minCutIndex != 0){\\n            cutsIndex.push_back(0);\\n        }\\n        if(maxCutIndex != n){\\n            cutsIndex.push_back(n);\\n        }\\n        \\n        sort(cutsIndex.begin(), cutsIndex.end());\\n        int N = cutsIndex.size();\\n        int dp[103][103];\\n        for(int i = 0 ; i<N ; i++ ){\\n            for(int j = 0 ; j <N ; j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        \\n        int ans = minCostMemo(N,  cutsIndex , dp , 0 , N-1);\\n        \\n        \\n        return ans;      \\n    }\\n\\t\\n\\t\\n```\n```\\nint minCost(int n, vector<int>& cuts) {\\n\\n\\tint minCutIndex = INT_MAX;\\n\\tint maxCutIndex = INT_MIN;\\n\\tvector<int> cutsIndex;\\n\\tfor(int i = 0 ; i  < cuts.size() ; i++){\\n\\t\\tminCutIndex=min(minCutIndex,cuts[i]);\\n\\t\\tmaxCutIndex=max(maxCutIndex,cuts[i]);\\n\\t\\tcutsIndex.push_back(cuts[i]);\\n\\t}\\n\\n\\tif(minCutIndex != 0){\\n\\t\\tcutsIndex.push_back(0);\\n\\t}\\n\\tif(maxCutIndex != n){\\n\\t\\tcutsIndex.push_back(n);\\n\\t}\\n\\n\\tsort(cutsIndex.begin(), cutsIndex.end());\\n\\tint N = cutsIndex.size();\\n\\tint dp[103][103];\\n\\tfor(int i = 0 ; i<N ; i++ ){\\n\\t\\tfor(int j = 0 ; j <N ; j++){\\n\\t\\t\\tdp[i][j] = 0;\\n\\t\\t}\\n\\t}\\n\\n\\tfor(int gap = 2 ;  gap < N ; gap++){\\n\\t\\tfor(int i =0,j=gap ; i <N &&j<N ; i++,j++){\\n\\t\\t\\tint ans =INT_MAX;\\n\\t\\t\\tfor(int k = i+1 ; k<j ;k++){\\n\\t\\t\\t\\tans=min(ans,dp[i][k] + dp[k][j]);\\n\\t\\t\\t}\\n\\t\\t\\tdp[i][j] = ans+cutsIndex[j]-cutsIndex[i] ;\\n\\t\\t}\\n\\t}\\n\\n\\t// int ans = minCostMemo(N,  cutsIndex , dp , 0 , N-1);\\n\\tint ans = dp[0][N-1];\\n\\n\\treturn ans;      \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1278004,
                "title": "simple-just-sort-the-cuts-to-keep-the-track-of-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[100][100];\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(),cuts.end());\\n        memset(dp,-1,sizeof(dp));\\n       return total_cost(0,n,cuts,0,cuts.size()-1);\\n    }\\n    int total_cost(int lb,int ub,vector<int>& cuts,int li,int ui)//where ui and li upper and lower indices\\n\\t\\n    {\\n         if(ui == li)\\n         return ub-lb;\\n         if(ui < li)\\n         return 0;\\n         if(dp[li][ui] != -1)\\n         return dp[li][ui];\\n         int ans = INT_MAX;\\n         for(int i = li;i <= ui;i++) {\\n            int a = ub-lb+total_cost(cuts[i],ub,cuts,i+1,ui)+total_cost(lb,cuts[i],cuts,li,i-1);\\n            ans = min(ans,a);   \\n                    \\n         }\\n         return dp[li][ui] = (ans == INT_MAX ? 0 : ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100][100];\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(),cuts.end());\\n        memset(dp,-1,sizeof(dp));\\n       return total_cost(0,n,cuts,0,cuts.size()-1);\\n    }\\n    int total_cost(int lb,int ub,vector<int>& cuts,int li,int ui)//where ui and li upper and lower indices\\n\\t\\n    {\\n         if(ui == li)\\n         return ub-lb;\\n         if(ui < li)\\n         return 0;\\n         if(dp[li][ui] != -1)\\n         return dp[li][ui];\\n         int ans = INT_MAX;\\n         for(int i = li;i <= ui;i++) {\\n            int a = ub-lb+total_cost(cuts[i],ub,cuts,i+1,ui)+total_cost(lb,cuts[i],cuts,li,i-1);\\n            ans = min(ans,a);   \\n                    \\n         }\\n         return dp[li][ui] = (ans == INT_MAX ? 0 : ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256154,
                "title": "c-soln-mcm",
                "content": "```\\nclass Solution {\\npublic:\\n    //mcm variation\\n    //change idea to use len of cuts as n is large\\n    int dp[103][103];\\n    int sol(vector<int>& cuts, int i, int j){\\n        if(j-i<=1)return 0; //if there is one segment length then we wont be able to make any cut there\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=1e9;\\n        for(int k=i+1;k<j;k++){\\n        int temp=sol(cuts,i,k)+sol(cuts,k,j)+(cuts[j]-cuts[i]);\\n                ans=min(ans,temp);\\n            \\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        memset(dp,-1,sizeof dp);\\n        cuts.insert(cuts.begin(),0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(),cuts.end());\\n        return sol(cuts,0,cuts.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //mcm variation\\n    //change idea to use len of cuts as n is large\\n    int dp[103][103];\\n    int sol(vector<int>& cuts, int i, int j){\\n        if(j-i<=1)return 0; //if there is one segment length then we wont be able to make any cut there\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=1e9;\\n        for(int k=i+1;k<j;k++){\\n        int temp=sol(cuts,i,k)+sol(cuts,k,j)+(cuts[j]-cuts[i]);\\n                ans=min(ans,temp);\\n            \\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        memset(dp,-1,sizeof dp);\\n        cuts.insert(cuts.begin(),0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(),cuts.end());\\n        return sol(cuts,0,cuts.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242108,
                "title": "java-two-clean-o-n-3-solution",
                "content": "These problems are very similar: \\n\\n* [312. Burst Balloons](https://leetcode.com/problems/burst-balloons/discuss/1242141/Java-clean-O(N3)-DP-Solution-oror-with-comments)\\n* [1547. Minimum Cost to Cut a Stick](https://leetcode.com/problems/minimum-cost-to-cut-a-stick/discuss/1242108/Java-Two-Clean-O(N3)-Solution)\\n\\nFor me, Solution 1 is actually more natural. Coming from the brute force way, it just optimized a little bit by storing sub-results to avoid repeated queries. However, Solution 2 with DP in real practice runs faster because of the subseting in Solution 1. \\n\\n**Solution 1:**\\n```\\nclass Solution {\\n    private TreeSet<Integer> set = new TreeSet<>();\\n    private int n;\\n    \\n    private Map<Integer, Integer> memo = new HashMap<>();\\n    \\n    public int minCost(int n, int[] cuts) {\\n        for (int c : cuts) set.add(c);\\n        this.n = n;\\n        \\n        return helper(0, n);\\n    }\\n    \\n    private int helper(int i, int j) {\\n        int key = i * (n+1) + j;\\n        if (memo.containsKey(key)) return memo.get(key);\\n        \\n        int res = Integer.MAX_VALUE;\\n        for (int c : set.subSet(i, false, j, false)) {\\n            res = Math.min(res, (j - i) + helper(i, c) + helper(c, j));\\n        }\\n        \\n        if (res == Integer.MAX_VALUE) res = 0;\\n        memo.put(key, res);\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**Solution 2:**\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int len = cuts.length + 2;\\n        \\n        int[] endpoints = new int[len];\\n        endpoints[0] = 0;\\n        for (int i = 1; i < len - 1; i++) endpoints[i] = cuts[i-1];\\n        endpoints[len - 1] = n;\\n        Arrays.sort(endpoints);\\n        \\n        \\n        int[][] dp = new int[len][len];\\n        \\n        // d : dist between i & j, the starting & ending position of stick \\n        for (int d = 2; d < len; d++) {\\n            for (int i = 0, j = i + d; j < len; i++, j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                \\n                int curr = endpoints[j] - endpoints[i];\\n                for (int k = i + 1; k < j; k++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + curr);\\n                }\\n            }\\n        }\\n        return dp[0][len - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Tree",
                    "Memoization",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    private TreeSet<Integer> set = new TreeSet<>();\\n    private int n;\\n    \\n    private Map<Integer, Integer> memo = new HashMap<>();\\n    \\n    public int minCost(int n, int[] cuts) {\\n        for (int c : cuts) set.add(c);\\n        this.n = n;\\n        \\n        return helper(0, n);\\n    }\\n    \\n    private int helper(int i, int j) {\\n        int key = i * (n+1) + j;\\n        if (memo.containsKey(key)) return memo.get(key);\\n        \\n        int res = Integer.MAX_VALUE;\\n        for (int c : set.subSet(i, false, j, false)) {\\n            res = Math.min(res, (j - i) + helper(i, c) + helper(c, j));\\n        }\\n        \\n        if (res == Integer.MAX_VALUE) res = 0;\\n        memo.put(key, res);\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int len = cuts.length + 2;\\n        \\n        int[] endpoints = new int[len];\\n        endpoints[0] = 0;\\n        for (int i = 1; i < len - 1; i++) endpoints[i] = cuts[i-1];\\n        endpoints[len - 1] = n;\\n        Arrays.sort(endpoints);\\n        \\n        \\n        int[][] dp = new int[len][len];\\n        \\n        // d : dist between i & j, the starting & ending position of stick \\n        for (int d = 2; d < len; d++) {\\n            for (int i = 0, j = i + d; j < len; i++, j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                \\n                int curr = endpoints[j] - endpoints[i];\\n                for (int k = i + 1; k < j; k++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + curr);\\n                }\\n            }\\n        }\\n        return dp[0][len - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931916,
                "title": "java-short-and-crisp-recursion-memoization-dp-beats-95-with-explanation",
                "content": "Here we are breaking a larger stick into smaller sticks at cut_indexes (cut[i]).\\n**Example:** 0-1-2-3-4-5-6-7 , cuts=[1,3,4,5]\\nAtlast after breaking at cut_indexes, stick will be like\\n0-1  1-2-3  3-4  4-5  5-6-7\\nThis result can be acheived in many ways, but we need minimum cost. [cost to cut a stick of length \\'L\\' at any index = L units].\\nSo, we can start to cut from i=0 to 3 at any index and proced further.\\nApplying recursion with parameters -\\nstart,end..to find cost of a cut,  cut_start,cut_end to know range of  available cuts.\\n(I) dfs(0,7,0,3)-\\n\\tres=7-0=7, irrespective of any cut cost will be its length\\n\\tcut_index=0 to 3\\n\\tif cut_index=0, cost=left-sub_part=dfs(0,1,0,-1)+right-sub_part=dfs(1,7,1,3)\\n    if cut_index=1, cost=left-sub_part=dfs(0,3,0,0) + right-sub_part=dfs(3,7,2,3)\\n\\tif cut_index=2,cost= left-sub_part=dfs(0,4,0,1) + right-sub_part=dfs(4,7,3,3)\\n\\tif cut_index=3, cost=left-sub_part=dfs(0,5,0,2) +right-sub_part=dfs(5,7,4,3).\\nIn this further recursions will be applied for all till the sub-problem becomes small until it can be directly solved (i.e.., base condition=if start> end ).\\nSo we will store the minimum cost at all cut_index , add it our result and return.\\nThere will be many repeated recursion calls, so store caluculated result in hashmap.\\n\\n**Recursion+memoization:**\\n```\\nclass Solution {\\n    int[] cuts;\\n    HashMap<String,Integer> memo;\\n    public int minCost(int n, int[] cut_index) {\\n        memo=new HashMap();\\n        Arrays.sort(cut_index);\\n        cuts=cut_index;\\n        return recur(0,n,0,cuts.length-1);\\n    }\\n    private int recur(int start,int end,int cut_start,int cut_end){\\n        if( cut_start>cut_end ) return 0;\\n        String key=start+\" \"+end+\" \"+cut_start+\" \"+cut_end;\\n        if(memo.containsKey(key)) return memo.get(key);\\n        int res=end-start;\\n        int val=Integer.MAX_VALUE;\\n        for(int i=cut_start;i<=cut_end;i++)\\n            val=Math.min(val,recur(start,cuts[i],cut_start,i-1)+recur(cuts[i],end,i+1,cut_end));\\n\\t\\t\\t\\n        res+=val;\\n        memo.put(key,res);\\n        return res;\\n    }\\n}\\n```\\n\\n**DP approach**:\\n\\nIn DP we pre-caluculate results for smaller sub-problem, and then solve larger problems using these. Here we go backwards.\\nFrom 0-1  1-2-3  3-4  4-5  5-6-7 to 0-1-2-3-4-5-6-7.\\nHere 0-1,1-2-3,3-4 ,4-5,5-6-7 are smallest subproblems as they cannot be furthere divided.We will consider them as stick of **size =1**\\nWe will use a 2D matrix of size (2+number of cuts)(2+number of cuts).\\n**(I)** cost for breaking stick of **size =2**,\\n\\t\\t0-1 1-2-3= 3-0 + cost for 0-1 +cost for 1-3=3+0+0=3.\\n\\t\\t1-2-3  3-4 =4-1 + cost for 1-2-3 +cost for 3-4  =3+0+0=3.\\n\\t\\t3-4   4-5 =5-3 +cost for 3-4 +cost for 4-5 =2+0+0=2\\n\\t\\t4-5  5-6-7=7-4 + cost for 4-5 +cost for 5-6-7 = 3+0+0=3.\\n**(II)** cost for breaking stick of **size =3**,\\n      0-1  1-2-3  3-4 =4-0 + min( 0-1+1-4  , 0-3+3-4)=4+min(0+3,3+0) =4+3=7.\\n\\t  1-2-3  3-4  4-5 =5-1 + min(1-3 + 3-5 , 1-4 +4-5) =4+min(0+2,3+0) =4+2=6\\n\\t   3-4  4-5  5-6-7 =7-3+min( 3-4+4-7 , 3-5+5-7)=4+min(0+3,2+0)=4+2=6.\\n**(III)** cost for breaking stick of **size =4**,\\n      0-1  1-2-3  3-4  4-5 = 5-0+ min(0-1+1-5,0-3+3-5,0-4+4-5) = 5+min(0+6,3+2,7+0)=5+5=10.\\n\\t  1-2-3  3-4  4-5  5-6-7=7-1+min(1-3+3-7,1-4+4-7,1-5+5-7)=6+(0+6,3+3,6+0)=6+6=12.\\n**(IV)** cost for breaking stick of **size =5**,\\n0-1 1-2-3  3-4  4-5 5-6-7 =7-0+min(0-1+1-7,0-3+3-7,0-4+4-7,0-5+5-7)=7+min(0+12,3+6,7+3,10+0)\\n .=7+min(12,9,10,10)=7+9=16.\\n This works exactly opposite to recursion, in recusrion we break larger problem into smaller. In DP we find results for smaller problems fisrt and then caluculate solution for larger problem.\\n```\\nclass Solution { \\n    public int minCost(int n, int[] cut){\\n        //Add 0 and n to cut\\n        int[][] memo=new int[2+cut.length][2+cut.length];\\n       \\n        Arrays.sort(cut);\\n        int[] cuts = new int[cut.length + 2];\\n        System.arraycopy(cut, 0, cuts, 1, cut.length);\\n        cuts[cuts.length-1] = n;\\n\\n        //Wood of size 1 cannot be cut\\n        for(int len=2;len<cuts.length;len++){\\n            for(int row=0;row+len<cuts.length;row++){\\n                int col=row+len; \\n                int val=Integer.MAX_VALUE;\\n                for(int k=row+1;k<col;k++) \\n                    val=Math.min(val,memo[row][k]+memo[k][col]);\\n                memo[row][col]=cuts[col]-cuts[row]+val;\\n            }\\n        }\\n        return memo[0][memo[0].length-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] cuts;\\n    HashMap<String,Integer> memo;\\n    public int minCost(int n, int[] cut_index) {\\n        memo=new HashMap();\\n        Arrays.sort(cut_index);\\n        cuts=cut_index;\\n        return recur(0,n,0,cuts.length-1);\\n    }\\n    private int recur(int start,int end,int cut_start,int cut_end){\\n        if( cut_start>cut_end ) return 0;\\n        String key=start+\" \"+end+\" \"+cut_start+\" \"+cut_end;\\n        if(memo.containsKey(key)) return memo.get(key);\\n        int res=end-start;\\n        int val=Integer.MAX_VALUE;\\n        for(int i=cut_start;i<=cut_end;i++)\\n            val=Math.min(val,recur(start,cuts[i],cut_start,i-1)+recur(cuts[i],end,i+1,cut_end));\\n\\t\\t\\t\\n        res+=val;\\n        memo.put(key,res);\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution { \\n    public int minCost(int n, int[] cut){\\n        //Add 0 and n to cut\\n        int[][] memo=new int[2+cut.length][2+cut.length];\\n       \\n        Arrays.sort(cut);\\n        int[] cuts = new int[cut.length + 2];\\n        System.arraycopy(cut, 0, cuts, 1, cut.length);\\n        cuts[cuts.length-1] = n;\\n\\n        //Wood of size 1 cannot be cut\\n        for(int len=2;len<cuts.length;len++){\\n            for(int row=0;row+len<cuts.length;row++){\\n                int col=row+len; \\n                int val=Integer.MAX_VALUE;\\n                for(int k=row+1;k<col;k++) \\n                    val=Math.min(val,memo[row][k]+memo[k][col]);\\n                memo[row][col]=cuts[col]-cuts[row]+val;\\n            }\\n        }\\n        return memo[0][memo[0].length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842135,
                "title": "c-top-down-dp",
                "content": "```\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        //dp[i][j] = min(dp[i][k] + dp[k][j] + len)        \\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(), cuts.end());\\n        const int m = cuts.size();\\n        auto vdp = vector(m, vector(m, INT_MAX));\\n        return dp(vdp, cuts, 0, m-1);\\n    }\\n    \\n    int dp(vector<vector<int>>& vdp, const vector<int>& cuts, int i, int j){\\n        int& res = vdp[i][j];\\n        if(res != INT_MAX) return res;\\n        if(j == i+1) return res = 0;\\n        const int len = cuts[j] - cuts[i];\\n        for(int k=i+1;k<j;k++)\\n            res = min(res, len + dp(vdp, cuts, i, k) + dp(vdp, cuts, k, j));\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        //dp[i][j] = min(dp[i][k] + dp[k][j] + len)        \\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(), cuts.end());\\n        const int m = cuts.size();\\n        auto vdp = vector(m, vector(m, INT_MAX));\\n        return dp(vdp, cuts, 0, m-1);\\n    }\\n    \\n    int dp(vector<vector<int>>& vdp, const vector<int>& cuts, int i, int j){\\n        int& res = vdp[i][j];\\n        if(res != INT_MAX) return res;\\n        if(j == i+1) return res = 0;\\n        const int len = cuts[j] - cuts[i];\\n        for(int k=i+1;k<j;k++)\\n            res = min(res, len + dp(vdp, cuts, i, k) + dp(vdp, cuts, k, j));\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 785421,
                "title": "c-top-down-dp-dfs",
                "content": "```\\n    int memo[101][101];\\n    int dp(int i,int j,vector<int>& cuts,int start,int end)\\n    {\\n        if(i>=j)\\n            return 0;\\n        else if(memo[i][j]!=-1)\\n            return memo[i][j];\\n        else\\n        {\\n            int q=INT_MAX;\\n            for(int k=i;k<j;++k)\\n                q=min(q,end-start+dp(i,k,cuts,start,cuts[k])+dp(k+1,j,cuts,cuts[k],end));\\n            return memo[i][j]=q;\\n        }\\n    }\\n    int minCost(int n, vector<int>& cuts) \\n    {\\n        sort(cuts.begin(),cuts.end());\\n        memset(memo,-1,sizeof(memo));\\n        return dp(0,cuts.size(),cuts,0,n);\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int memo[101][101];\\n    int dp(int i,int j,vector<int>& cuts,int start,int end)\\n    {\\n        if(i>=j)\\n            return 0;\\n        else if(memo[i][j]!=-1)\\n            return memo[i][j];\\n        else\\n        {\\n            int q=INT_MAX;\\n            for(int k=i;k<j;++k)\\n                q=min(q,end-start+dp(i,k,cuts,start,cuts[k])+dp(k+1,j,cuts,cuts[k],end));\\n            return memo[i][j]=q;\\n        }\\n    }\\n    int minCost(int n, vector<int>& cuts) \\n    {\\n        sort(cuts.begin(),cuts.end());\\n        memset(memo,-1,sizeof(memo));\\n        return dp(0,cuts.size(),cuts,0,n);\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 785100,
                "title": "ez-pz-c-matrix-chain-multiplication-concept-this-was-asked-in-google",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        \\n        cuts.insert(cuts.begin(),0); // inserting  index 0 at front\\n        cuts.push_back(n);   // pushing n to the end.. we push these to maintain the boundaries\\n        sort(cuts.begin(),cuts.end());  // order of edges\\n        int m=cuts.size();\\n        vector<vector<int>> dp(m,vector<int>(m,0));\\n        \\n        \\n        for(int sz=2;sz<=m-1;sz++){\\n            for(int i=0;i<m-sz;i++){\\n                int j=i+sz;   // end of current window decided by i and sz\\n                \\n                dp[i][j]=INT_MAX;\\n                for(int k=i+1;k<j;k++){\\n                    dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]+cuts[j]-cuts[i]);  // if   0  2   3 4  is the current window..then first we check the cost of [0,2] then [3,4]  and since we are making the cut on [0,4] we add the current length..which is cuts[j] - cuts[i]..\\n\\t\\t\\t\\t\\t// we have to take the minimum of all these cases ..in the above example we placed the cut at index k=i+1=1(value 2) now we place it at k=i+2(value 3)\\n                }\\n            }\\n        }\\n        return dp[0][m-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        \\n        cuts.insert(cuts.begin(),0); // inserting  index 0 at front\\n        cuts.push_back(n);   // pushing n to the end.. we push these to maintain the boundaries\\n        sort(cuts.begin(),cuts.end());  // order of edges\\n        int m=cuts.size();\\n        vector<vector<int>> dp(m,vector<int>(m,0));\\n        \\n        \\n        for(int sz=2;sz<=m-1;sz++){\\n            for(int i=0;i<m-sz;i++){\\n                int j=i+sz;   // end of current window decided by i and sz\\n                \\n                dp[i][j]=INT_MAX;\\n                for(int k=i+1;k<j;k++){\\n                    dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]+cuts[j]-cuts[i]);  // if   0  2   3 4  is the current window..then first we check the cost of [0,2] then [3,4]  and since we are making the cut on [0,4] we add the current length..which is cuts[j] - cuts[i]..\\n\\t\\t\\t\\t\\t// we have to take the minimum of all these cases ..in the above example we placed the cut at index k=i+1=1(value 2) now we place it at k=i+2(value 3)\\n                }\\n            }\\n        }\\n        return dp[0][m-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781674,
                "title": "i-need-help-with-time-complexity-please",
                "content": "Hey,\\nI feel very stupid, but I really need help analyzing top bottom DP programs, I feel lost whenever I have to analyze them.\\n\\nLet\\'s say M = |cuts|\\nThe way I see it..\\n\\nWe can cut at any point in the first time, so we have M choices.\\nThen we have M-1 choices to cut from.\\nM-2\\n...\\n1\\n\\nI see these as M! complexity.\\nI know I\\'m totally off.. but can you give a tip for a newbie to see time complexity on these kind of algorithms...\\nI\\'ve managed to get a working solution\\n\\nA walkthrough analyze will be lovely.\\n\\n***Thanks a lot for everyone***\\n\\n```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.append(0)\\n        cuts.append(n)\\n        cuts.sort()\\n        memo = {}\\n        def cut(left, right):\\n            if (left, right) in memo:\\n                return memo[(left, right)]\\n            if left + 1 == right:\\n                return 0\\n            most_efficient = float(\\'inf\\')\\n            for i in range(left + 1, right):\\n                most_efficient = min(most_efficient, (cuts[right] - cuts[left]) + cut(left, i) + cut(i, right))\\n            memo[(left, right)] = most_efficient\\n            return most_efficient\\n        return cut(0, len(cuts) - 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.append(0)\\n        cuts.append(n)\\n        cuts.sort()\\n        memo = {}\\n        def cut(left, right):\\n            if (left, right) in memo:\\n                return memo[(left, right)]\\n            if left + 1 == right:\\n                return 0\\n            most_efficient = float(\\'inf\\')\\n            for i in range(left + 1, right):\\n                most_efficient = min(most_efficient, (cuts[right] - cuts[left]) + cut(left, i) + cut(i, right))\\n            memo[(left, right)] = most_efficient\\n            return most_efficient\\n        return cut(0, len(cuts) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781269,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n        int[] A = new int[cuts.length + 2];\\n        A[0] = 0;\\n        A[cuts.length + 1] = n;\\n        int start = 0;\\n        while (start < cuts.length) {\\n            A[start+1] = cuts[start++];\\n        }\\n        int len = A.length;\\n        int[][] dp = new int[len][len];\\n        for (int i = 0; i < len - 1; i++) {\\n            dp[i][i + 1] = 0;\\n        }\\n        for (int size = 2; size < len; size++) {\\n            for (int i = 0; i + size < len; i++) {\\n                int j = i + size;\\n                int min = Integer.MAX_VALUE;\\n                for (int k = i + 1; k < j; k++) {\\n                    min = Math.min(min, dp[i][k] + dp[k][j] + A[j] - A[i]);\\n                }\\n                dp[i][j] = min;\\n            }\\n        }\\n        return dp[0][len - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n        int[] A = new int[cuts.length + 2];\\n        A[0] = 0;\\n        A[cuts.length + 1] = n;\\n        int start = 0;\\n        while (start < cuts.length) {\\n            A[start+1] = cuts[start++];\\n        }\\n        int len = A.length;\\n        int[][] dp = new int[len][len];\\n        for (int i = 0; i < len - 1; i++) {\\n            dp[i][i + 1] = 0;\\n        }\\n        for (int size = 2; size < len; size++) {\\n            for (int i = 0; i + size < len; i++) {\\n                int j = i + size;\\n                int min = Integer.MAX_VALUE;\\n                for (int k = i + 1; k < j; k++) {\\n                    min = Math.min(min, dp[i][k] + dp[k][j] + A[j] - A[i]);\\n                }\\n                dp[i][j] = min;\\n            }\\n        }\\n        return dp[0][len - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781026,
                "title": "c-top-down-solution-o-n-3",
                "content": "dp[i][j] represent the minimum cost from i-th cut to j-th cut.\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(), cuts.end());\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(cuts, 0, cuts.size() - 1, 0, n);\\n    }\\n    \\n    int dfs(vector<int> &cuts, int l, int r, int l1, int r1) {\\n        if(l > r) return 0;\\n        if(l == r) return r1 - l1;\\n        if(dp[l][r]>= 0) return dp[l][r];\\n        int res = INT_MAX;\\n        for(int i = l; i <= r; ++i) {\\n            res = min(res, dfs(cuts, l, i - 1, l1, cuts[i]) + dfs(cuts, i + 1, r, cuts[i], r1) + r1 - l1);\\n        }\\n        return dp[l][r] = res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(), cuts.end());\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(cuts, 0, cuts.size() - 1, 0, n);\\n    }\\n    \\n    int dfs(vector<int> &cuts, int l, int r, int l1, int r1) {\\n        if(l > r) return 0;\\n        if(l == r) return r1 - l1;\\n        if(dp[l][r]>= 0) return dp[l][r];\\n        int res = INT_MAX;\\n        for(int i = l; i <= r; ++i) {\\n            res = min(res, dfs(cuts, l, i - 1, l1, cuts[i]) + dfs(cuts, i + 1, r, cuts[i], r1) + r1 - l1);\\n        }\\n        return dp[l][r] = res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780963,
                "title": "python3-lru-cache-7-lines",
                "content": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.sort()\\n        @lru_cache(maxsize=None)\\n        def helper(n,cuts):\\n            if len(cuts)==0:\\n                return 0\\n            return n+min(helper(c,cuts[:i])+helper(n-c,tuple(map(lambda x:x-c,cuts[i+1:]))) for i,c in enumerate(cuts))\\n        return helper(n,tuple(cuts))\\n```\\n\\n\\n(should\\'ve joined the contest 30 minutes earlier...)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.sort()\\n        @lru_cache(maxsize=None)\\n        def helper(n,cuts):\\n            if len(cuts)==0:\\n                return 0\\n            return n+min(helper(c,cuts[:i])+helper(n-c,tuple(map(lambda x:x-c,cuts[i+1:]))) for i,c in enumerate(cuts))\\n        return helper(n,tuple(cuts))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780935,
                "title": "python3-dp-with-explanation",
                "content": "```python\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.sort()\\n       \\n        # i..j - indexes of available cuts in cuts list\\n        # start, end - start and end of the stick used to find the cost\\n\\t\\t@lru_cache(None)\\n        def dp(i, j, start, end):\\n\\n            # if all cuts used, return 0 cost\\n            if i > j:\\n                return 0\\n            \\n            # iterate through avaliable cuts to find min cost recursively\\n            cost = math.inf\\n\\n            for k in range(i, j + 1):\\n                # cut the stick that results to two smaller sticks\\n                cost = min(p, dp(i, k - 1, start, cuts[k]) + dp(k + 1, j, cuts[k], end))\\n\\n            return cost + end - start\\n        return dp(0, len(cuts) - 1, 0, n)\\n            \\n\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.sort()\\n       \\n        # i..j - indexes of available cuts in cuts list\\n        # start, end - start and end of the stick used to find the cost\\n\\t\\t@lru_cache(None)\\n        def dp(i, j, start, end):\\n\\n            # if all cuts used, return 0 cost\\n            if i > j:\\n                return 0\\n            \\n            # iterate through avaliable cuts to find min cost recursively\\n            cost = math.inf\\n\\n            for k in range(i, j + 1):\\n                # cut the stick that results to two smaller sticks\\n                cost = min(p, dp(i, k - 1, start, cuts[k]) + dp(k + 1, j, cuts[k], end))\\n\\n            return cost + end - start\\n        return dp(0, len(cuts) - 1, 0, n)\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038146,
                "title": "dp-simple",
                "content": "# Complexity\\n- Time complexity: $$O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Integer dp[][]; int n, cuts[];\\n    public int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n        dp = new Integer[cuts.length+2][cuts.length+2];\\n        this.n=n;\\n        this.cuts=cuts;\\n        return f(0, cuts.length+1);\\n    }\\n\\n    int get(int i) { return i==0? 0: (i==cuts.length+1? n: cuts[i-1]); }\\n\\n    int f(int i, int j) {\\n        if(i+1==j) return dp[i][j]=0;\\n        if(dp[i][j]!=null) return dp[i][j];\\n\\n        int min=Integer.MAX_VALUE;\\n        for(int k=i+1; k<j; k++) {\\n            min = Math.min(min, f(i, k) + f(k, j));\\n        }\\n\\n        return dp[i][j] = min+get(j)-get(i);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    Integer dp[][]; int n, cuts[];\\n    public int minCost(int n, int[] cuts) {\\n        Arrays.sort(cuts);\\n        dp = new Integer[cuts.length+2][cuts.length+2];\\n        this.n=n;\\n        this.cuts=cuts;\\n        return f(0, cuts.length+1);\\n    }\\n\\n    int get(int i) { return i==0? 0: (i==cuts.length+1? n: cuts[i-1]); }\\n\\n    int f(int i, int j) {\\n        if(i+1==j) return dp[i][j]=0;\\n        if(dp[i][j]!=null) return dp[i][j];\\n\\n        int min=Integer.MAX_VALUE;\\n        for(int k=i+1; k<j; k++) {\\n            min = Math.min(min, f(i, k) + f(k, j));\\n        }\\n\\n        return dp[i][j] = min+get(j)-get(i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994784,
                "title": "top-down-dynamic-approach-8-lines",
                "content": "# Code\\n```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        @cache\\n        def dp(leftRange, rightRange):\\n            ans = float(\\'inf\\')\\n            for cut in cuts:\\n                if leftRange < cut < rightRange:\\n                    ans = min(ans, rightRange-leftRange + dp(leftRange, cut) + dp(cut, rightRange))\\n            return ans if ans != float(\\'inf\\') else 0\\n        \\n        return dp(0, n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        @cache\\n        def dp(leftRange, rightRange):\\n            ans = float(\\'inf\\')\\n            for cut in cuts:\\n                if leftRange < cut < rightRange:\\n                    ans = min(ans, rightRange-leftRange + dp(leftRange, cut) + dp(cut, rightRange))\\n            return ans if ans != float(\\'inf\\') else 0\\n        \\n        return dp(0, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946765,
                "title": "python-91-36-faster-memoization-tabulation",
                "content": "```\\n#Recursion \\n#Time Complexity: O(Exponential)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        def solve(i,j):\\n            if i>j:\\n                return 0\\n            mini=maxsize\\n            for k in range(i,j+1):\\n                cost=cuts[j+1]-cuts[i-1] + solve(i,k-1) + solve(k+1,j)\\n                mini=min(mini,cost)\\n            return mini\\n        c=len(cuts)\\n        cuts.append(n)\\n        cuts.insert(0,0)\\n        cuts.sort()\\n        return solve(1,c)\\n    \\n#Memoization (Top-Down)\\n#Time Complexity: O(n^3)\\n#Space Complexity: O(n^2) + O(n)\\nclass Solution2:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        def solve(i,j):\\n            if i>j:\\n                return 0\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            mini=maxsize\\n            for k in range(i,j+1):\\n                cost=cuts[j+1]-cuts[i-1] + solve(i,k-1) + solve(k+1,j)\\n                mini=min(mini,cost)\\n            dp[i][j]=mini\\n            return dp[i][j]\\n        c=len(cuts)\\n        cuts.append(n)\\n        cuts.insert(0,0)\\n        cuts.sort()\\n        dp=[[-1 for j in range(c+1)] for i in range(c+1)]\\n        return solve(1,c)\\n    \\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n^3)\\n#Space Complexity: O(n^2)\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        c=len(cuts)\\n        cuts.append(n)\\n        cuts.insert(0,0)\\n        cuts.sort()\\n        dp=[[0 for j in range(c+2)] for i in range(c+2)]\\n        for i in range(c,0,-1):\\n            for j in range(1,c+1):\\n                if i>j:\\n                    continue\\n                mini=maxsize\\n                for k in range(i,j+1):\\n                    cost=cuts[j+1]-cuts[i-1] + dp[i][k-1] + dp[k+1][j]\\n                    mini=min(mini,cost)\\n                dp[i][j]=mini\\n        return dp[1][c]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\n#Recursion \\n#Time Complexity: O(Exponential)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        def solve(i,j):\\n            if i>j:\\n                return 0\\n            mini=maxsize\\n            for k in range(i,j+1):\\n                cost=cuts[j+1]-cuts[i-1] + solve(i,k-1) + solve(k+1,j)\\n                mini=min(mini,cost)\\n            return mini\\n        c=len(cuts)\\n        cuts.append(n)\\n        cuts.insert(0,0)\\n        cuts.sort()\\n        return solve(1,c)\\n    \\n#Memoization (Top-Down)\\n#Time Complexity: O(n^3)\\n#Space Complexity: O(n^2) + O(n)\\nclass Solution2:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        def solve(i,j):\\n            if i>j:\\n                return 0\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            mini=maxsize\\n            for k in range(i,j+1):\\n                cost=cuts[j+1]-cuts[i-1] + solve(i,k-1) + solve(k+1,j)\\n                mini=min(mini,cost)\\n            dp[i][j]=mini\\n            return dp[i][j]\\n        c=len(cuts)\\n        cuts.append(n)\\n        cuts.insert(0,0)\\n        cuts.sort()\\n        dp=[[-1 for j in range(c+1)] for i in range(c+1)]\\n        return solve(1,c)\\n    \\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n^3)\\n#Space Complexity: O(n^2)\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        c=len(cuts)\\n        cuts.append(n)\\n        cuts.insert(0,0)\\n        cuts.sort()\\n        dp=[[0 for j in range(c+2)] for i in range(c+2)]\\n        for i in range(c,0,-1):\\n            for j in range(1,c+1):\\n                if i>j:\\n                    continue\\n                mini=maxsize\\n                for k in range(i,j+1):\\n                    cost=cuts[j+1]-cuts[i-1] + dp[i][k-1] + dp[k+1][j]\\n                    mini=min(mini,cost)\\n                dp[i][j]=mini\\n        return dp[1][c]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888104,
                "title": "using-papas-power-algorithm-jack-to-solve-this-leetcode-hard-problem-please-upvote",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(), cuts.end());\\n        \\n        int m = cuts.size();\\n        vector<vector<int>> dp(m, vector<int>(m, 0));\\n        \\n        for (int len = 2; len < m; ++len) {\\n            for (int i = 0; i + len < m; ++i) {\\n                int j = i + len;\\n                dp[i][j] = INT_MAX;\\n                for (int k = i + 1; k < j; ++k) {\\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][m - 1];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(), cuts.end());\\n        \\n        int m = cuts.size();\\n        vector<vector<int>> dp(m, vector<int>(m, 0));\\n        \\n        for (int len = 2; len < m; ++len) {\\n            for (int i = 0; i + len < m; ++i) {\\n                int j = i + len;\\n                dp[i][j] = INT_MAX;\\n                for (int k = i + 1; k < j; ++k) {\\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][m - 1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676317,
                "title": "c-both-memoization-tabulation-approach-t-c-o-n-3-s-c-o-n-2",
                "content": "```\\n1. Memoization\\n\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(n^3)\\n        Space Complexity : O(n^2)\\n    */\\n    \\n    int c;\\n    \\n    int helper(int i, int j, vector<int> &cuts, vector<vector<int>> &dp){\\n        if(i>j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int res = INT_MAX;\\n        \\n        for(int idx=i; idx<=j; idx++){\\n            int cost = cuts[j+1] - cuts[i-1] + helper(i, idx-1, cuts, dp)\\n                + helper(idx+1, j, cuts, dp);\\n            \\n            res = min(res, cost);\\n        }\\n        \\n        return dp[i][j] = res;\\n    }\\n    \\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        c = cuts.size();\\n        cuts.push_back(n);\\n        cuts.insert(begin(cuts), 0);\\n        sort(begin(cuts), end(cuts));\\n        \\n        vector<vector<int>> dp(c+1, vector<int> (c+1, -1));\\n        \\n        return helper(1, c, cuts, dp);\\n    }\\n};\\n```\\n\\n```\\n2. Tabulation\\n\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(n^3)\\n        Space Complexity : O(n^2)\\n    */\\n    \\n    int c;\\n\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        c = cuts.size();\\n        cuts.push_back(n);\\n        cuts.insert(begin(cuts), 0);\\n        sort(begin(cuts), end(cuts));\\n        \\n        vector<vector<int>> dp(c+2, vector<int> (c+2, 0));\\n        \\n        for(int i=c; i>0; i--){\\n            for(int j=1; j<=c; j++){\\n                if(i>j) continue;\\n                \\n                int res = INT_MAX;\\n        \\n                for(int idx=i; idx<=j; idx++){\\n                    int cost = cuts[j+1] - cuts[i-1] + dp[i][idx-1]\\n                        + dp[idx+1][j];\\n\\n                    res = min(res, cost);\\n                }\\n\\n                dp[i][j] = res;\\n            }\\n        }\\n        \\n        return dp[1][c];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\n1. Memoization\\n\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(n^3)\\n        Space Complexity : O(n^2)\\n    */\\n    \\n    int c;\\n    \\n    int helper(int i, int j, vector<int> &cuts, vector<vector<int>> &dp){\\n        if(i>j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int res = INT_MAX;\\n        \\n        for(int idx=i; idx<=j; idx++){\\n            int cost = cuts[j+1] - cuts[i-1] + helper(i, idx-1, cuts, dp)\\n                + helper(idx+1, j, cuts, dp);\\n            \\n            res = min(res, cost);\\n        }\\n        \\n        return dp[i][j] = res;\\n    }\\n    \\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        c = cuts.size();\\n        cuts.push_back(n);\\n        cuts.insert(begin(cuts), 0);\\n        sort(begin(cuts), end(cuts));\\n        \\n        vector<vector<int>> dp(c+1, vector<int> (c+1, -1));\\n        \\n        return helper(1, c, cuts, dp);\\n    }\\n};\\n```\n```\\n2. Tabulation\\n\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(n^3)\\n        Space Complexity : O(n^2)\\n    */\\n    \\n    int c;\\n\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        c = cuts.size();\\n        cuts.push_back(n);\\n        cuts.insert(begin(cuts), 0);\\n        sort(begin(cuts), end(cuts));\\n        \\n        vector<vector<int>> dp(c+2, vector<int> (c+2, 0));\\n        \\n        for(int i=c; i>0; i--){\\n            for(int j=1; j<=c; j++){\\n                if(i>j) continue;\\n                \\n                int res = INT_MAX;\\n        \\n                for(int idx=i; idx<=j; idx++){\\n                    int cost = cuts[j+1] - cuts[i-1] + dp[i][idx-1]\\n                        + dp[idx+1][j];\\n\\n                    res = min(res, cost);\\n                }\\n\\n                dp[i][j] = res;\\n            }\\n        }\\n        \\n        return dp[1][c];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602471,
                "title": "pretty-beautiful-simple-and-optimal-python3-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n ^ 3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n ^ 2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` python3 []\\nfrom functools import cache\\n\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.sort()\\n\\n        @cache\\n        def dp(a, b, i, j):\\n            if i == j:\\n                return 0\\n\\n            return min(\\n                dp(a, cuts[k], i, k) + dp(cuts[k], b, k + 1, j)\\n                for k in range(i, j)\\n            ) + b - a\\n\\n        return dp(0, n, 0, len(cuts))\\n\\n```\\n\\n## NB\\nThe arguments `i` and `j` of DP are uniquely determined by the arguments `a` and `b`, so the true dynamic programming space is `dp[a][b]`.\\nHowever, I have explicitly passed them on for ease of understanding.",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Sorting"
                ],
                "code": "``` python3 []\\nfrom functools import cache\\n\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        cuts.sort()\\n\\n        @cache\\n        def dp(a, b, i, j):\\n            if i == j:\\n                return 0\\n\\n            return min(\\n                dp(a, cuts[k], i, k) + dp(cuts[k], b, k + 1, j)\\n                for k in range(i, j)\\n            ) + b - a\\n\\n        return dp(0, n, 0, len(cuts))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572997,
                "title": "python-easy-solution",
                "content": "\\n\\n# Code\\n```\\nimport sys\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        d={}\\n        def solve(i,j):\\n            if (i,j) in d:\\n                return d[(i,j)]\\n            ans=sys.maxsize\\n            cost=j-i\\n            for cut in cuts:\\n                if cut<j and cut>i:\\n                    ans=min(ans,solve(i,cut)+solve(cut,j)+cost)\\n            if ans==sys.maxsize:\\n                d[(i,j)]=0\\n            else:\\n                d[(i,j)]=ans\\n            return d[(i,j)]\\n        return solve(0,n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport sys\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        d={}\\n        def solve(i,j):\\n            if (i,j) in d:\\n                return d[(i,j)]\\n            ans=sys.maxsize\\n            cost=j-i\\n            for cut in cuts:\\n                if cut<j and cut>i:\\n                    ans=min(ans,solve(i,cut)+solve(cut,j)+cost)\\n            if ans==sys.maxsize:\\n                d[(i,j)]=0\\n            else:\\n                d[(i,j)]=ans\\n            return d[(i,j)]\\n        return solve(0,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572992,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int[] c = new int[cuts.length + 2];\\n        for(int i = 0; i < cuts.length; i++){\\n            c[i + 1] = cuts[i];\\n        }\\n        c[c.length - 1] = n;\\n        Arrays.sort(c);\\n        int[][] dp = new int[c.length][c.length];\\n        for(int i = 0; i < dp.length; i++){\\n            for(int j = i - 1; j >= 0; j--){\\n                for(int k = i - 1; k > j; k--){\\n                    int ans = Math.min(dp[j][i] == 0 ? Integer.MAX_VALUE : dp[j][i], c[i] - c[j] + dp[j][k] + dp[k][i]);\\n                    dp[j][i] = ans;\\n\\n                }\\n            }\\n        }\\n        return dp[0][c.length - 1];   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCost(int n, int[] cuts) {\\n        int[] c = new int[cuts.length + 2];\\n        for(int i = 0; i < cuts.length; i++){\\n            c[i + 1] = cuts[i];\\n        }\\n        c[c.length - 1] = n;\\n        Arrays.sort(c);\\n        int[][] dp = new int[c.length][c.length];\\n        for(int i = 0; i < dp.length; i++){\\n            for(int j = i - 1; j >= 0; j--){\\n                for(int k = i - 1; k > j; k--){\\n                    int ans = Math.min(dp[j][i] == 0 ? Integer.MAX_VALUE : dp[j][i], c[i] - c[j] + dp[j][k] + dp[k][i]);\\n                    dp[j][i] = ans;\\n\\n                }\\n            }\\n        }\\n        return dp[0][c.length - 1];   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572867,
                "title": "easy-bottom-up-solution-detailed-explanation-for-beginners-to-understand",
                "content": "# About the problem:\\nGiven a wooden stick of length n units. The stick is labelled from 0 to n. For example, a stick of length 6 is labelled as follows:\\n\\n\\nGiven an integer array cuts where cuts[i] denotes a position you should perform a cut at.\\n\\nYou should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\nThe cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.\\n\\nReturn the minimum total cost of the cuts.\\n\\n# Approach\\n- Concept used - Bottom up tabulation using dp\\n- Step by step explaination of the code is done via commented part of code.\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[]} cuts\\n * @return {number}\\n */\\n\\n//concept used - bottom up tabulation using dp\\nvar minCost = function(n, cuts) {\\n    cuts.sort((a, b) => a - b) //this sorts the given array from start to end\\n    cuts = [0, ...cuts, n]//represents the position at which the cut needs to be made between 0 to n\\n    const stickLen = cuts.length //stick\\'s length is assigned as the length of the cuts arr\\n    const dp = Array(stickLen).fill(0).map(() => Array(stickLen).fill(0))//base case is defined\\n    for (let i = stickLen - 2; i >= 0; i--){\\n        for (let j = i + 2; j < stickLen; j++){\\n            let minCost = Infinity;\\n            for (let k = i + 1; k < j; k++){\\n                //recurrence relation\\n                const cost = cuts[j] - cuts[i] + dp[i][k] + dp[k][j]\\n                //cuts[j] - cuts[i] represent length of stick being cut at that position\\n                //dp[i][k] represents the minimum cost of cutting the stick between positions cuts[i] and cuts[k]\\n                //dp[k][j] represents the minimum cost of cutting the stick between positions cuts[k] and cuts[j]\\n                minCost = Math.min(minCost, cost)\\n            }\\n\\n            dp[i][j] = minCost//the dp is updated with the mincost\\n        }\\n    }\\n    return dp[0][stickLen - 1]//stores mincost in first row last element  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} cuts\\n * @return {number}\\n */\\n\\n//concept used - bottom up tabulation using dp\\nvar minCost = function(n, cuts) {\\n    cuts.sort((a, b) => a - b) //this sorts the given array from start to end\\n    cuts = [0, ...cuts, n]//represents the position at which the cut needs to be made between 0 to n\\n    const stickLen = cuts.length //stick\\'s length is assigned as the length of the cuts arr\\n    const dp = Array(stickLen).fill(0).map(() => Array(stickLen).fill(0))//base case is defined\\n    for (let i = stickLen - 2; i >= 0; i--){\\n        for (let j = i + 2; j < stickLen; j++){\\n            let minCost = Infinity;\\n            for (let k = i + 1; k < j; k++){\\n                //recurrence relation\\n                const cost = cuts[j] - cuts[i] + dp[i][k] + dp[k][j]\\n                //cuts[j] - cuts[i] represent length of stick being cut at that position\\n                //dp[i][k] represents the minimum cost of cutting the stick between positions cuts[i] and cuts[k]\\n                //dp[k][j] represents the minimum cost of cutting the stick between positions cuts[k] and cuts[j]\\n                minCost = Math.min(minCost, cost)\\n            }\\n\\n            dp[i][j] = minCost//the dp is updated with the mincost\\n        }\\n    }\\n    return dp[0][stickLen - 1]//stores mincost in first row last element  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572692,
                "title": "cuts-j-cuts-i-subproblem",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    long long int solve(int i,int j, vector<int>& c , vector<vector<int>> &dp)\\n    {\\n        if(i>j)\\n            return 0;\\n        \\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        \\n        long long int res = INT_MAX;\\n        for(int ind=i;ind<=j;ind++)\\n        {\\n            long long int val =  c[j+1]-c[i-1] + solve(i,ind-1,c,dp) + solve(ind+1,j,c,dp);\\n            res = min(res,val);\\n        }\\n        return dp[i][j] = res;\\n    }\\n    int minCost(int n, vector<int>& c) {\\n        int lim = c.size();\\n\\n        c.push_back(0);\\n        c.push_back(n);\\n        \\n        sort(c.begin(),c.end());\\n        \\n        vector<vector<int>> dp(201,vector<int> (201,-1));\\n        \\n        return solve(1,lim,c,dp);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    long long int solve(int i,int j, vector<int>& c , vector<vector<int>> &dp)\\n    {\\n        if(i>j)\\n            return 0;\\n        \\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        \\n        long long int res = INT_MAX;\\n        for(int ind=i;ind<=j;ind++)\\n        {\\n            long long int val =  c[j+1]-c[i-1] + solve(i,ind-1,c,dp) + solve(ind+1,j,c,dp);\\n            res = min(res,val);\\n        }\\n        return dp[i][j] = res;\\n    }\\n    int minCost(int n, vector<int>& c) {\\n        int lim = c.size();\\n\\n        c.push_back(0);\\n        c.push_back(n);\\n        \\n        sort(c.begin(),c.end());\\n        \\n        vector<vector<int>> dp(201,vector<int> (201,-1));\\n        \\n        return solve(1,lim,c,dp);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572564,
                "title": "c-java-easy-and-clean-code-dp-top-down-bottom-up-beats",
                "content": "# Please Upvote if you like my Solution \\uD83E\\uDD17\\uD83E\\uDD17\\n\\n# Complexity \\n- Time complexity: $$O(N^3)$$ where `N` is length of string `s`. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N^2)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++ Code\\n```\\nclass Solution {\\n    int minCostHelp(int i, int j, vector<vector<int>> &dp, vector<int> &cuts) {\\n        if (i > j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int mini = INT_MAX;\\n        for (int k = i; k <= j; k++) {\\n            mini = min(mini,\\n                    cuts[j + 1] - cuts[i - 1] + minCostHelp(i, k - 1, dp, cuts) + minCostHelp(k + 1, j, dp, cuts));\\n        }\\n        return dp[i][j] = mini;\\n    }\\n\\npublic:\\n    // TOP DOWN \\n    int minCost1(int len, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(len);\\n        sort(cuts.begin(), cuts.end());\\n        int n = cuts.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return minCostHelp(1, n - 2, dp, cuts);\\n    }\\n\\n\\n    // BOTTOM UP\\n    int minCost(int len, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(len);\\n        sort(cuts.begin(), cuts.end());\\n        int n = cuts.size();\\n        vector<vector<int>> dp(n+1, vector<int>(n+1));\\n\\n        for (int i = n - 2; i >= 1; i--) {\\n            for (int j = i; j <= n-2 ; j++) {\\n                int mini = INT_MAX;\\n                for (int k = i; k <= j; k++) {\\n                    mini = min(mini, cuts[j + 1] - cuts[i - 1] + dp[i][k - 1] + dp[k + 1][j]);\\n                }\\n                dp[i][j] = mini;\\n            }\\n        }\\n        return dp[1][n - 2];\\n    }\\n};\\n```\\n---\\n\\n# Java Code\\n```\\nclass Solution {\\n    private int minCostHelp(int i, int j, int dp[][], int cuts[]) {\\n        if (i > j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int mini = Integer.MAX_VALUE;\\n        for (int k = i; k <= j; k++) {\\n            mini = Math.min(mini,\\n                    cuts[j + 1] - cuts[i - 1] + minCostHelp(i, k - 1, dp, cuts) + minCostHelp(k + 1, j, dp, cuts));\\n        }\\n        return dp[i][j] = mini;\\n    }\\n\\n\\n    // TOP DOWN \\n    public int minCost1(int len, int[] cuts) {\\n        int n = cuts.length, tmp[] = new int[n + 2];\\n        for (int i = 0; i < n; i++) tmp[i] = cuts[i];\\n        tmp[n] = 0;\\n        tmp[n + 1] = len;\\n        Arrays.sort(tmp);\\n\\n        n = tmp.length;\\n        int dp[][] = new int[n][n];\\n        for (int[] row : dp) Arrays.fill(row, -1);\\n        return minCostHelp(1, n - 2, dp, tmp);\\n    }\\n\\n\\n    // BOTTOM UP\\n    public int minCost(int len, int[] cuts) {\\n        int n = cuts.length, tmp[] = new int[n + 2];\\n        for (int i = 0; i < n; i++) tmp[i] = cuts[i];\\n        tmp[n] = 0;\\n        tmp[n + 1] = len;\\n        Arrays.sort(tmp);\\n\\n        n = tmp.length;\\n        int dp[][] = new int[n + 1][n + 1];\\n\\n        for (int i = n - 2; i >= 1; i--) {\\n            for (int j = i; j <= n-2 ; j++) {\\n                int mini = Integer.MAX_VALUE;\\n                for (int k = i; k <= j; k++) {\\n                    mini = Math.min(mini, tmp[j + 1] - tmp[i - 1] + dp[i][k - 1] + dp[k + 1][j]);\\n                }\\n                dp[i][j] = mini;\\n            }\\n        }\\n        return dp[1][n - 2];\\n    }\\n}\\n```\\n![upvote-img.jpg](https://assets.leetcode.com/users/images/d20562b8-5ddb-40b3-8b8a-5d7a0a6f0b57_1684136359.2221565.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    int minCostHelp(int i, int j, vector<vector<int>> &dp, vector<int> &cuts) {\\n        if (i > j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int mini = INT_MAX;\\n        for (int k = i; k <= j; k++) {\\n            mini = min(mini,\\n                    cuts[j + 1] - cuts[i - 1] + minCostHelp(i, k - 1, dp, cuts) + minCostHelp(k + 1, j, dp, cuts));\\n        }\\n        return dp[i][j] = mini;\\n    }\\n\\npublic:\\n    // TOP DOWN \\n    int minCost1(int len, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(len);\\n        sort(cuts.begin(), cuts.end());\\n        int n = cuts.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return minCostHelp(1, n - 2, dp, cuts);\\n    }\\n\\n\\n    // BOTTOM UP\\n    int minCost(int len, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(len);\\n        sort(cuts.begin(), cuts.end());\\n        int n = cuts.size();\\n        vector<vector<int>> dp(n+1, vector<int>(n+1));\\n\\n        for (int i = n - 2; i >= 1; i--) {\\n            for (int j = i; j <= n-2 ; j++) {\\n                int mini = INT_MAX;\\n                for (int k = i; k <= j; k++) {\\n                    mini = min(mini, cuts[j + 1] - cuts[i - 1] + dp[i][k - 1] + dp[k + 1][j]);\\n                }\\n                dp[i][j] = mini;\\n            }\\n        }\\n        return dp[1][n - 2];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private int minCostHelp(int i, int j, int dp[][], int cuts[]) {\\n        if (i > j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int mini = Integer.MAX_VALUE;\\n        for (int k = i; k <= j; k++) {\\n            mini = Math.min(mini,\\n                    cuts[j + 1] - cuts[i - 1] + minCostHelp(i, k - 1, dp, cuts) + minCostHelp(k + 1, j, dp, cuts));\\n        }\\n        return dp[i][j] = mini;\\n    }\\n\\n\\n    // TOP DOWN \\n    public int minCost1(int len, int[] cuts) {\\n        int n = cuts.length, tmp[] = new int[n + 2];\\n        for (int i = 0; i < n; i++) tmp[i] = cuts[i];\\n        tmp[n] = 0;\\n        tmp[n + 1] = len;\\n        Arrays.sort(tmp);\\n\\n        n = tmp.length;\\n        int dp[][] = new int[n][n];\\n        for (int[] row : dp) Arrays.fill(row, -1);\\n        return minCostHelp(1, n - 2, dp, tmp);\\n    }\\n\\n\\n    // BOTTOM UP\\n    public int minCost(int len, int[] cuts) {\\n        int n = cuts.length, tmp[] = new int[n + 2];\\n        for (int i = 0; i < n; i++) tmp[i] = cuts[i];\\n        tmp[n] = 0;\\n        tmp[n + 1] = len;\\n        Arrays.sort(tmp);\\n\\n        n = tmp.length;\\n        int dp[][] = new int[n + 1][n + 1];\\n\\n        for (int i = n - 2; i >= 1; i--) {\\n            for (int j = i; j <= n-2 ; j++) {\\n                int mini = Integer.MAX_VALUE;\\n                for (int k = i; k <= j; k++) {\\n                    mini = Math.min(mini, tmp[j + 1] - tmp[i - 1] + dp[i][k - 1] + dp[k + 1][j]);\\n                }\\n                dp[i][j] = mini;\\n            }\\n        }\\n        return dp[1][n - 2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572514,
                "title": "c-solution-using-dynamic-programming",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    \\n    int solve(int startstick,int endstick,vector<int>& cuts,int left,int right){\\n\\n        if(left>right) return 0;\\n\\n        if(dp[left][right]!=-1){\\n            return dp[left][right];\\n        }\\n         int cost=INT_MAX;\\n        for(int i=left;i<=right;i++){\\n\\n            int leftCost=solve(startstick,cuts[i],cuts,left,i-1);\\n            int rightCost=solve(cuts[i],endstick,cuts,i+1,right);\\n\\n            int currcost=(endstick-startstick)+leftCost+rightCost;\\n\\n            cost=min(cost,currcost);\\n        }\\n\\n        return dp[left][right]=cost;\\n    }\\n\\n    int minCost(int n, vector<int>& cuts) {\\n\\n        memset(dp,-1,sizeof(dp));\\n        \\n        sort(cuts.begin(),cuts.end());\\n\\n        return solve(0,n,cuts,0,cuts.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    \\n    int solve(int startstick,int endstick,vector<int>& cuts,int left,int right){\\n\\n        if(left>right) return 0;\\n\\n        if(dp[left][right]!=-1){\\n            return dp[left][right];\\n        }\\n         int cost=INT_MAX;\\n        for(int i=left;i<=right;i++){\\n\\n            int leftCost=solve(startstick,cuts[i],cuts,left,i-1);\\n            int rightCost=solve(cuts[i],endstick,cuts,i+1,right);\\n\\n            int currcost=(endstick-startstick)+leftCost+rightCost;\\n\\n            cost=min(cost,currcost);\\n        }\\n\\n        return dp[left][right]=cost;\\n    }\\n\\n    int minCost(int n, vector<int>& cuts) {\\n\\n        memset(dp,-1,sizeof(dp));\\n        \\n        sort(cuts.begin(),cuts.end());\\n\\n        return solve(0,n,cuts,0,cuts.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572409,
                "title": "javascript-with-cache",
                "content": "# Intuition\\nTrying out all possible ways and using cache to find the minimum cost.\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[]} cuts\\n * @return {number}\\n */\\nvar minCost = function(n, cuts) {    \\n    const cache = {};\\n    const fn = (start,end)=>{\\n        let key = `${start}:${end}`;\\n        if(cache[key] != undefined) return cache[key];\\n        if(start>=end) {            \\n            return 0;\\n        };\\n        // let minL = Infinity;\\n        let size = Infinity;                \\n        for(const c of cuts){\\n            if(start<c && c<end){\\n                size = Math.min((end-start) + fn(start,c) + fn(c,end),size)\\n            }\\n        }        \\n        cache[key] = size == Infinity ? 0 : size;\\n        return cache[key];\\n    }\\n    return fn(0,n);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} cuts\\n * @return {number}\\n */\\nvar minCost = function(n, cuts) {    \\n    const cache = {};\\n    const fn = (start,end)=>{\\n        let key = `${start}:${end}`;\\n        if(cache[key] != undefined) return cache[key];\\n        if(start>=end) {            \\n            return 0;\\n        };\\n        // let minL = Infinity;\\n        let size = Infinity;                \\n        for(const c of cuts){\\n            if(start<c && c<end){\\n                size = Math.min((end-start) + fn(start,c) + fn(c,end),size)\\n            }\\n        }        \\n        cache[key] = size == Infinity ? 0 : size;\\n        return cache[key];\\n    }\\n    return fn(0,n);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572226,
                "title": "dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nint solve(int i, int j, vector<int> &cuts, vector<vector<int>> &dp)\\n{\\n\\n    if (i > j)\\n        return 0;\\n\\n    if (dp[i][j] != -1)\\n        return dp[i][j];\\n\\n    int minm = INT_MAX;\\n\\n    for (int ind = i; ind <= j; ind++)\\n    {\\n\\n        int cost = cuts[j + 1] - cuts[i - 1] + solve(i, ind - 1, cuts, dp) + solve(ind + 1, j, cuts, dp);\\n        minm = min(minm, cost);\\n    }\\n\\n    return dp[i][j] = minm;\\n}\\n\\npublic:\\nint minCost(int n, vector<int> &cuts)\\n{\\n\\n    int c = cuts.size();\\n    cuts.insert(cuts.begin(), 0);\\n    cuts.push_back(n);\\n\\n    sort(cuts.begin(), cuts.end());\\n    vector<vector<int>> dp(c + 1, vector<int>(c + 1, -1));\\n\\n    return solve(1, c, cuts, dp);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nint solve(int i, int j, vector<int> &cuts, vector<vector<int>> &dp)\\n{\\n\\n    if (i > j)\\n        return 0;\\n\\n    if (dp[i][j] != -1)\\n        return dp[i][j];\\n\\n    int minm = INT_MAX;\\n\\n    for (int ind = i; ind <= j; ind++)\\n    {\\n\\n        int cost = cuts[j + 1] - cuts[i - 1] + solve(i, ind - 1, cuts, dp) + solve(ind + 1, j, cuts, dp);\\n        minm = min(minm, cost);\\n    }\\n\\n    return dp[i][j] = minm;\\n}\\n\\npublic:\\nint minCost(int n, vector<int> &cuts)\\n{\\n\\n    int c = cuts.size();\\n    cuts.insert(cuts.begin(), 0);\\n    cuts.push_back(n);\\n\\n    sort(cuts.begin(), cuts.end());\\n    vector<vector<int>> dp(c + 1, vector<int>(c + 1, -1));\\n\\n    return solve(1, c, cuts, dp);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572223,
                "title": "golang-dp-top-down-and-bottom-up",
                "content": "# Complexity\\n- Time complexity:\\nO(N^3)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\n/* DP - Top Down */\\nfunc minCost(n int, cuts []int) int {\\n    // Make cuts as [0, cuts..., n]\\n    cuts = append([]int{0}, cuts...)\\n    cuts = append(cuts, n)\\n    sort.Ints(cuts)\\n\\n    cache := make(map[string]int)\\n    return findMinCuts(0, len(cuts)-1, cuts, cache)\\n}\\n\\nfunc findMinCuts(left, right int, cuts []int, cache map[string]int) int {\\n    if right - left == 1 {\\n        return 0 // single cut\\n    }\\n\\n    key := strconv.Itoa(left) + \"-\" + strconv.Itoa(right)\\n    if value, ok := cache[key]; ok {\\n        return value\\n    }\\n\\n    res := math.MaxInt64\\n    for mid := left+1; mid < right; mid++ {\\n        res = min(res, findMinCuts(left, mid, cuts, cache) + findMinCuts(mid, right, cuts, cache) + cuts[right] - cuts[left])\\n    }\\n    cache[key] = res\\n    return res\\n}\\n\\n/* DP -- Bottom Up */\\nfunc minCost(n int, cuts []int) int {\\n    // Make cuts as [0, cuts..., n]\\n    cuts = append([]int{0}, cuts...)\\n    cuts = append(cuts, n)\\n    sort.Ints(cuts)\\n\\n    m := len(cuts) // New length\\n    dp := make([][]int, m)\\n    for i := 0; i < m; i++ {\\n        dp[i] = make([]int, m)\\n    }\\n\\n    for diff := 2; diff < m; diff++ {\\n        for left := 0; left < m - diff; left++ {\\n            right := left + diff\\n            res := math.MaxInt64\\n            for mid := left+1; mid < right; mid++ {\\n                res = min(res, dp[left][mid] + dp[mid][right] + cuts[right] - cuts[left])\\n            }\\n            dp[left][right] = res\\n        }\\n    }\\n\\n    return dp[0][m-1]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/* DP - Top Down */\\nfunc minCost(n int, cuts []int) int {\\n    // Make cuts as [0, cuts..., n]\\n    cuts = append([]int{0}, cuts...)\\n    cuts = append(cuts, n)\\n    sort.Ints(cuts)\\n\\n    cache := make(map[string]int)\\n    return findMinCuts(0, len(cuts)-1, cuts, cache)\\n}\\n\\nfunc findMinCuts(left, right int, cuts []int, cache map[string]int) int {\\n    if right - left == 1 {\\n        return 0 // single cut\\n    }\\n\\n    key := strconv.Itoa(left) + \"-\" + strconv.Itoa(right)\\n    if value, ok := cache[key]; ok {\\n        return value\\n    }\\n\\n    res := math.MaxInt64\\n    for mid := left+1; mid < right; mid++ {\\n        res = min(res, findMinCuts(left, mid, cuts, cache) + findMinCuts(mid, right, cuts, cache) + cuts[right] - cuts[left])\\n    }\\n    cache[key] = res\\n    return res\\n}\\n\\n/* DP -- Bottom Up */\\nfunc minCost(n int, cuts []int) int {\\n    // Make cuts as [0, cuts..., n]\\n    cuts = append([]int{0}, cuts...)\\n    cuts = append(cuts, n)\\n    sort.Ints(cuts)\\n\\n    m := len(cuts) // New length\\n    dp := make([][]int, m)\\n    for i := 0; i < m; i++ {\\n        dp[i] = make([]int, m)\\n    }\\n\\n    for diff := 2; diff < m; diff++ {\\n        for left := 0; left < m - diff; left++ {\\n            right := left + diff\\n            res := math.MaxInt64\\n            for mid := left+1; mid < right; mid++ {\\n                res = min(res, dp[left][mid] + dp[mid][right] + cuts[right] - cuts[left])\\n            }\\n            dp[left][right] = res\\n        }\\n    }\\n\\n    return dp[0][m-1]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572095,
                "title": "swift-recursion",
                "content": "# Code\\n```\\nclass Solution {\\n    \\n    var memo: [Int: Int] = [:]\\n    var cuts: [Int] = []\\n    func minCost(_ n: Int, _ cuts: [Int]) -> Int {\\n        \\n        self.cuts = [0] + cuts.sorted() + [n]\\n        return reverse(0, self.cuts.count - 1)\\n    }\\n\\n    func reverse(_ from: Int, _ to: Int) -> Int {\\n        \\n        let memoKey = from * 100 + to\\n        if let value = memo[memoKey] { return value }\\n\\n        if to - from <= 1 { return 0 }\\n        if to - from == 2 { return cuts[to] - cuts[from] }\\n\\n        memo[memoKey] = (from + 1...to - 1).map { middle in\\n            cuts[to] - cuts[from] + reverse(from, middle) + reverse(middle, to)\\n        }.min() ?? 0\\n\\n        return memo[memoKey]!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    \\n    var memo: [Int: Int] = [:]\\n    var cuts: [Int] = []\\n    func minCost(_ n: Int, _ cuts: [Int]) -> Int {\\n        \\n        self.cuts = [0] + cuts.sorted() + [n]\\n        return reverse(0, self.cuts.count - 1)\\n    }\\n\\n    func reverse(_ from: Int, _ to: Int) -> Int {\\n        \\n        let memoKey = from * 100 + to\\n        if let value = memo[memoKey] { return value }\\n\\n        if to - from <= 1 { return 0 }\\n        if to - from == 2 { return cuts[to] - cuts[from] }\\n\\n        memo[memoKey] = (from + 1...to - 1).map { middle in\\n            cuts[to] - cuts[from] + reverse(from, middle) + reverse(middle, to)\\n        }.min() ?? 0\\n\\n        return memo[memoKey]!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571709,
                "title": "simple-recursion-memorization-python",
                "content": "\\n\\n# Approach - Recursion and Caching \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(K*(N^2))   `K = len(cuts)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nUpvote krdo yrrr \\uD83D\\uDE0A\\uD83D\\uDE0A\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minCost(self, n, cuts):\\n        dp = {}\\n        def recursion(l,r):\\n\\n            if r-l == 1: return 0\\n\\n            if (l,r) in dp: return dp[(l,r)]\\n            \\n            res = float(\"inf\")\\n            for c in cuts:\\n                if l < c < r:\\n                    res = min(res, r-l + recursion(l,c ) + recursion(c,r))\\n            res = 0 if res == float(\"inf\") else res\\n            dp[(l,r)] = res\\n            return res\\n        return recursion(0,n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def minCost(self, n, cuts):\\n        dp = {}\\n        def recursion(l,r):\\n\\n            if r-l == 1: return 0\\n\\n            if (l,r) in dp: return dp[(l,r)]\\n            \\n            res = float(\"inf\")\\n            for c in cuts:\\n                if l < c < r:\\n                    res = min(res, r-l + recursion(l,c ) + recursion(c,r))\\n            res = 0 if res == float(\"inf\") else res\\n            dp[(l,r)] = res\\n            return res\\n        return recursion(0,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571689,
                "title": "python-easy-understandable-program",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        def solve(left, right):\\n            if right-left==1:\\n                return 0\\n\\n            if(left,right) in dp:\\n                return dp[(left,right)]\\n\\n            res =  sys.maxsize\\n            flag = 0\\n\\n            for cut in cuts:\\n                if cut>left and cut<right:\\n                    flag =1\\n\\n                    temp = right-left+solve(left,cut) + solve(cut,right)\\n                    res = min(res,temp)\\n\\n            if not flag:  # if flag is not given the input the  it will become 0 \\n                return 0\\n\\n            dp[(left,right)] = res\\n            return res\\n\\n        dp = dict()\\n        return solve(0,n)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        def solve(left, right):\\n            if right-left==1:\\n                return 0\\n\\n            if(left,right) in dp:\\n                return dp[(left,right)]\\n\\n            res =  sys.maxsize\\n            flag = 0\\n\\n            for cut in cuts:\\n                if cut>left and cut<right:\\n                    flag =1\\n\\n                    temp = right-left+solve(left,cut) + solve(cut,right)\\n                    res = min(res,temp)\\n\\n            if not flag:  # if flag is not given the input the  it will become 0 \\n                return 0\\n\\n            dp[(left,right)] = res\\n            return res\\n\\n        dp = dict()\\n        return solve(0,n)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571491,
                "title": "easy-and-simple-c-explanation-dp-memorization-tabulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCheck the base case: if i > j, return 0 since there are no segments to cut.\\nCheck if the result for the current subproblem is already computed and stored in dp. If so, return the precomputed result.\\nInitialize mini variable to store the minimum cost for the current subproblem. Set it to a maximum value.\\nIterate from i to j to try all possible cut positions within the current subproblem.\\n\\nFor each cut position k, calculate the cost of making the cut at position k. The cost is equal to the length of the segment being cut (cuts[j + 1] - cuts[i - 1]) plus the cost of cutting the left segment recursively (solve(i, k - 1, cuts, dp)) and the cost of cutting the right segment recursively (solve(k + 1, j, cuts, dp)).\\n\\nUpdate mini with the minimum cost calculated in the previous step.\\nStore the minimum cost mini in the dp array for the current subproblem.\\nReturn the minimum cost.\\n\\nThe minCost function initializes the list of cut positions cuts by adding 0 at the beginning and n at the end, representing the start and end positions of the stick. It then sorts the cuts array.\\n\\n# Complexity\\n- Time complexity:\\n O(c^3), where c is the number of cuts.\\n\\n- Space complexity:\\n O(c^2), where c is the number of cuts.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<int>&cuts,vector<vector<int>>&dp){\\n        if(i>j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int mini=INT_MAX;\\n        for(int k=i;k<=j;k++){\\n            int cost=cuts[j+1]-cuts[i-1]+solve(i,k-1,cuts,dp)+solve(k+1,j,cuts,dp);\\n            mini=min(mini,cost);\\n        }\\n        return dp[i][j]= mini;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        int c=cuts.size();\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        sort(cuts.begin(),cuts.end());\\n        // vector<vector<int>>dp(c+1,vector<int>(c+1,-1));\\n        // return solve(1,c,cuts,dp);\\n\\n        vector<vector<int>>dp(c+2,vector<int>(c+2,0));\\n        for(int i=c;i>=1;i--){\\n            for(int j=i;j<=c;j++){\\n                int mini=INT_MAX;\\n                for(int k=i;k<=j;k++){\\n                    int cost=cuts[j+1]-cuts[i-1]+dp[i][k-1]+dp[k+1][j];\\n                    mini=min(mini,cost);\\n                }\\n                dp[i][j]= mini;\\n            }\\n        }\\n        return dp[1][c];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<int>&cuts,vector<vector<int>>&dp){\\n        if(i>j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int mini=INT_MAX;\\n        for(int k=i;k<=j;k++){\\n            int cost=cuts[j+1]-cuts[i-1]+solve(i,k-1,cuts,dp)+solve(k+1,j,cuts,dp);\\n            mini=min(mini,cost);\\n        }\\n        return dp[i][j]= mini;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        int c=cuts.size();\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        sort(cuts.begin(),cuts.end());\\n        // vector<vector<int>>dp(c+1,vector<int>(c+1,-1));\\n        // return solve(1,c,cuts,dp);\\n\\n        vector<vector<int>>dp(c+2,vector<int>(c+2,0));\\n        for(int i=c;i>=1;i--){\\n            for(int j=i;j<=c;j++){\\n                int mini=INT_MAX;\\n                for(int k=i;k<=j;k++){\\n                    int cost=cuts[j+1]-cuts[i-1]+dp[i][k-1]+dp[k+1][j];\\n                    mini=min(mini,cost);\\n                }\\n                dp[i][j]= mini;\\n            }\\n        }\\n        return dp[1][c];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571409,
                "title": "ruby-dp",
                "content": "# Intuition\\nDP\\n\\n# Approach\\nDP\\n\\n# Code\\n```ruby\\nclass Numeric\\n    def min(v)\\n        v < self ? v : self\\n    end\\nend\\n\\nclass Array\\n    def Array.newsqr(sz, dflt = nil)\\n        Array.new(sz) {|_| Array.new(sz, dflt) }\\n    end\\nend\\n\\ndef min_cost(n, cuts)\\n    cs = cuts.sort!.size\\n    cs.times.each_with_object(Array.newsqr(cs + 2, 0)) {|l0, dp|\\n        l = l0 + 2\\n        (cs - l0).times {|i|\\n            j = i + l\\n            dp[i][j] = dp[i][i+1] + dp[i+1][j]\\n            (i+2...j).each {|k|\\n                dp[i][j] = dp[i][j].min(dp[i][k] + dp[k][j])\\n            }\\n            dp[i][j] -= cuts[i - 1] if i > 0\\n            dp[i][j] += (j == cs + 1) ? n : cuts[j - 1]\\n        }\\n    }.first.last\\nend\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass Numeric\\n    def min(v)\\n        v < self ? v : self\\n    end\\nend\\n\\nclass Array\\n    def Array.newsqr(sz, dflt = nil)\\n        Array.new(sz) {|_| Array.new(sz, dflt) }\\n    end\\nend\\n\\ndef min_cost(n, cuts)\\n    cs = cuts.sort!.size\\n    cs.times.each_with_object(Array.newsqr(cs + 2, 0)) {|l0, dp|\\n        l = l0 + 2\\n        (cs - l0).times {|i|\\n            j = i + l\\n            dp[i][j] = dp[i][i+1] + dp[i+1][j]\\n            (i+2...j).each {|k|\\n                dp[i][j] = dp[i][j].min(dp[i][k] + dp[k][j])\\n            }\\n            dp[i][j] -= cuts[i - 1] if i > 0\\n            dp[i][j] += (j == cs + 1) ? n : cuts[j - 1]\\n        }\\n    }.first.last\\nend\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571358,
                "title": "beats-90-cpp-solution",
                "content": "# **Pls Upvote if it help \\uD83E\\uDD79**\\n\\n# Code\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n\\n// ----> SOLUTION 1 : RECURSION APPROACH\\n    int solve(int i, int j, vector<int>&cuts){\\n\\n        if(i > j){\\n            return 0;\\n        }\\n\\n        int mini = 1e9;\\n\\n        for(int k = i; k<=j; k++){\\n            int cost = cuts[j+1]%mod - cuts[i-1]%mod + solve(i, k-1 ,cuts)%mod + solve(k+1, j, cuts)%mod;\\n            mini = min(mini, cost);\\n        }\\n\\n        return mini;\\n    }\\n\\n\\n// ----> SOLUTION 2 : RECURSION + MEMOIZATION APPROACH\\n    int solve2(int i, int j, vector<int>&cuts, vector<vector<int>>&dp){\\n        // base case\\n        if(i > j){\\n            return 0;\\n        }\\n\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n\\n        // recursive calls\\n        int mini = INT_MAX;\\n        for(int k = i; k<=j; k++){\\n            int cost = cuts[j+1] - cuts[i-1] + solve2(i, k-1, cuts, dp)%mod + solve2(k+1, j, cuts, dp)%mod;\\n            mini = min(mini, cost);\\n        }\\n\\n        return dp[i][j] = mini;\\n    }\\n\\n\\n    int minCost(int n, vector<int>& cuts) {\\n\\n        // size of cuts vector\\n        int c = cuts.size();\\n\\n        // pushback the size of stick at the end of cuts array\\n        cuts.push_back(n);\\n\\n        // insert 0 in the begining of the cuts array \\n        cuts.insert(cuts.begin(), 0);\\n\\n        // sort the array in order to not create any discrepancy in the question\\n        sort(cuts.begin(), cuts.end());\\n\\n        // recursive approach\\n        // return solve(1, c, cuts);\\n\\n        // recursion + memoization approach\\n        int m = cuts.size();\\n        vector<vector<int>>dp(m+1, vector<int>(m+1, -1));\\n        return solve2(1, m-2, cuts, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n\\n// ----> SOLUTION 1 : RECURSION APPROACH\\n    int solve(int i, int j, vector<int>&cuts){\\n\\n        if(i > j){\\n            return 0;\\n        }\\n\\n        int mini = 1e9;\\n\\n        for(int k = i; k<=j; k++){\\n            int cost = cuts[j+1]%mod - cuts[i-1]%mod + solve(i, k-1 ,cuts)%mod + solve(k+1, j, cuts)%mod;\\n            mini = min(mini, cost);\\n        }\\n\\n        return mini;\\n    }\\n\\n\\n// ----> SOLUTION 2 : RECURSION + MEMOIZATION APPROACH\\n    int solve2(int i, int j, vector<int>&cuts, vector<vector<int>>&dp){\\n        // base case\\n        if(i > j){\\n            return 0;\\n        }\\n\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n\\n        // recursive calls\\n        int mini = INT_MAX;\\n        for(int k = i; k<=j; k++){\\n            int cost = cuts[j+1] - cuts[i-1] + solve2(i, k-1, cuts, dp)%mod + solve2(k+1, j, cuts, dp)%mod;\\n            mini = min(mini, cost);\\n        }\\n\\n        return dp[i][j] = mini;\\n    }\\n\\n\\n    int minCost(int n, vector<int>& cuts) {\\n\\n        // size of cuts vector\\n        int c = cuts.size();\\n\\n        // pushback the size of stick at the end of cuts array\\n        cuts.push_back(n);\\n\\n        // insert 0 in the begining of the cuts array \\n        cuts.insert(cuts.begin(), 0);\\n\\n        // sort the array in order to not create any discrepancy in the question\\n        sort(cuts.begin(), cuts.end());\\n\\n        // recursive approach\\n        // return solve(1, c, cuts);\\n\\n        // recursion + memoization approach\\n        int m = cuts.size();\\n        vector<vector<int>>dp(m+1, vector<int>(m+1, -1));\\n        return solve2(1, m-2, cuts, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571347,
                "title": "c-easy-to-understand-memoization-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint len;\\n    int solve(int n,int st,int end,vector<int>&cuts,vector<vector<int>>&dp)\\n{   \\n    if(st>=end)return 0;\\n    \\n    if(dp[st][end]!=0)return dp[st][end];\\n    int ans=INT_MAX;\\n\\n    for(int i=st;i<end;i++){\\n\\n        int le= st==0?0:cuts[st-1];\\n        int re= end==cuts.size()?len:cuts[end];\\n\\n        int cost=re-le;\\n        int left=solve(le,st,i,cuts,dp);\\n        int right=solve(re,i+1,end,cuts,dp);\\n\\n        int tempans=left+right+cost;\\n        ans=min(ans,tempans);\\n    }\\n\\n    return dp[st][end]=ans;\\n\\n}\\n    int minCost(int n, vector<int>& cuts) {\\n        int l=cuts.size();\\n        vector<vector<int>>dp(l+1,vector<int>(l+1,0));\\n        len=n;\\n        sort(cuts.begin(),cuts.end());\\n        return solve(n,0,l,cuts,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint len;\\n    int solve(int n,int st,int end,vector<int>&cuts,vector<vector<int>>&dp)\\n{   \\n    if(st>=end)return 0;\\n    \\n    if(dp[st][end]!=0)return dp[st][end];\\n    int ans=INT_MAX;\\n\\n    for(int i=st;i<end;i++){\\n\\n        int le= st==0?0:cuts[st-1];\\n        int re= end==cuts.size()?len:cuts[end];\\n\\n        int cost=re-le;\\n        int left=solve(le,st,i,cuts,dp);\\n        int right=solve(re,i+1,end,cuts,dp);\\n\\n        int tempans=left+right+cost;\\n        ans=min(ans,tempans);\\n    }\\n\\n    return dp[st][end]=ans;\\n\\n}\\n    int minCost(int n, vector<int>& cuts) {\\n        int l=cuts.size();\\n        vector<vector<int>>dp(l+1,vector<int>(l+1,0));\\n        len=n;\\n        sort(cuts.begin(),cuts.end());\\n        return solve(n,0,l,cuts,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570990,
                "title": "java-recursive-memoized",
                "content": "```\\nclass Solution {\\n    \\n    HashMap<String,Integer> dp = new HashMap();\\n    \\n    public int solve(int s , int e, int[] cuts){\\n        int c = cuts.length;\\n        if(e-1 == s)\\n            return 0;\\n    \\n        String key = s +\",\"+e;\\n        if(dp.containsKey(key))\\n            return dp.get(key);\\n        \\n        int i = 0, ret = Integer.MAX_VALUE;\\n        for(i= 0;i<c;i++){\\n            if(cuts[i] > s && cuts[i] < e ){\\n                int inc = (e-s) + solve(s, cuts[i], cuts) + solve(cuts[i], e, cuts);\\n                ret = Math.min(inc, ret);\\n            }\\n        }\\n        ret = ret == Integer.MAX_VALUE ? 0: ret;\\n        dp.put(key,ret);\\n        return ret ;\\n    }\\n    \\n    public int minCost(int n, int[] cuts) {\\n        int ans = solve(0, n, cuts);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    HashMap<String,Integer> dp = new HashMap();\\n    \\n    public int solve(int s , int e, int[] cuts){\\n        int c = cuts.length;\\n        if(e-1 == s)\\n            return 0;\\n    \\n        String key = s +\",\"+e;\\n        if(dp.containsKey(key))\\n            return dp.get(key);\\n        \\n        int i = 0, ret = Integer.MAX_VALUE;\\n        for(i= 0;i<c;i++){\\n            if(cuts[i] > s && cuts[i] < e ){\\n                int inc = (e-s) + solve(s, cuts[i], cuts) + solve(cuts[i], e, cuts);\\n                ret = Math.min(inc, ret);\\n            }\\n        }\\n        ret = ret == Integer.MAX_VALUE ? 0: ret;\\n        dp.put(key,ret);\\n        return ret ;\\n    }\\n    \\n    public int minCost(int n, int[] cuts) {\\n        int ans = solve(0, n, cuts);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570864,
                "title": "easy-to-understand-cpp-100-time-complexity-80-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n###### The problem asks us to find the minimum total cost of making cuts on a wooden stick of length $$n$$ at specific positions given in the $$cuts$$ array. We can change the order of the cuts as we wish.\\n\\n##### To solve this problem, we can utilize the concept of dynamic programming. The intuition behind the dynamic programming approach is as follows: \\n\\n1. We start by sorting the $$cuts$$ array in ascending order because the order of $$cuts$$ does not affect the final result.\\n\\n2. We add $$0 $$ at the beginning of the $$cuts$$ array and $$n$$ at the end to represent the start and end positions of the stick.\\n\\n3. We create a 2D table $$dp$$ of size $$(cuts.size() + 1)$$ x $$(cuts.size() + 1)$$. The $$dp[i][j]$$ represents the minimum cost of making cuts in the subinterval from index $$i$$ to index $$j$$ of the cuts array.\\n\\n4. We iterate over all possible subintervals of the $$cuts$$ array. For each subinterval, we consider all possible cutting points within that subinterval.\\n\\n5. For each subinterval length $$len$$ from $$2$$ to $$cuts.size()$$, we iterate over all starting positions start from $$0$$ to $$cuts.size()$$ - $$len$$. We calculate the ending position $$end$$ as $$start + len$$.\\n\\n6. For each subinterval, we consider all possible cutting points $$k$$ from $$start + 1$$ to $$end - 1$$. We calculate the cost of making the cut at position $$cuts[k]$$ as $$cuts[end] - cuts[start]$$.\\n\\n7. We calculate the total cost of making the cuts by adding the cost of the left subinterval $$(dp[start][k])$$ and the cost of the right subinterval $$(dp[k][end])$$. We take the minimum cost among all possible cutting points k within the subinterval.\\n\\n8. We update $$dp[start][end]$$ with the minimum cost found for the current subinterval.\\n\\n9. Finally, the minimum total cost of making all the cuts is given by $$dp[0][cuts.size()]$$, which represents the minimum cost of making cuts in the entire stick.\\n\\n###### By applying the above dynamic programming approach, we can efficiently compute the minimum total cost of making cuts on the stick.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n###### To solve the problem, we can use dynamic programming. We\\'ll create a 2D table dp to store the minimum cost of making cuts at various positions.\\n\\n##### Here\\'s the step-by-step algorithm:\\n\\n1. Sort the $$cuts$$ array in ascending order.\\n2. Add $$0$$ at the beginning of the $$cuts$$ array and $$n$$ at the end to represent the start and end positions.\\n3. Initialize the $$dp$$ table with $$INT$$_$$MAX$$ values of size $$(cuts.size() + 1)$$ x $$(cuts.size() + 1)$$.\\n4. For each interval length $$len$$ from $$1$$ to $$cuts.size()$$:\\n  - For each starting index start from $$0$$ to $$cuts.size() - len$$:\\n\\n    - Calculate the ending index $$end$$ as $$start + len$$.\\n    - Initialize the minimum cost $$minCost$$ as $$INT$$_$$MAX$$.\\n    - For each cutting point k from $$start + 1$$ to $$end - 1$$:\\n      - Calculate the cost of making the cut at position $$cuts[k]$$ as $$cuts[end] - cuts[start]$$.\\n      - Calculate the total cost as the sum of the cost of the left subinterval $$(dp[start][k])$$ and the cost of the right subinterval $$(dp[k][end])$$.\\n      - Update $$minCost$$ with the minimum of the current minimum cost and the total cost.\\n    - Update $$dp[start][end]$$ with the minimum cost found.\\n5. Return $$dp[0][cuts.size()]$$, which represents the minimum cost of making all the cuts.\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(), cuts.end());\\n\\n        int m = cuts.size();\\n        vector<vector<int>> dp(m, vector<int>(m, 0));\\n\\n        for (int len = 2; len < m; len++) {\\n            for (int start = 0; start < m - len; start++) {\\n                int end = start + len;\\n                int minCost = INT_MAX;\\n\\n                for (int k = start + 1; k < end; k++) {\\n                    int cost = cuts[end] - cuts[start];\\n                    int totalCost = dp[start][k] + dp[k][end];\\n                    minCost = min(minCost, totalCost + cost);\\n                }\\n\\n                dp[start][end] = minCost;\\n            }\\n        }\\n\\n        return dp[0][m - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(), cuts.end());\\n\\n        int m = cuts.size();\\n        vector<vector<int>> dp(m, vector<int>(m, 0));\\n\\n        for (int len = 2; len < m; len++) {\\n            for (int start = 0; start < m - len; start++) {\\n                int end = start + len;\\n                int minCost = INT_MAX;\\n\\n                for (int k = start + 1; k < end; k++) {\\n                    int cost = cuts[end] - cuts[start];\\n                    int totalCost = dp[start][k] + dp[k][end];\\n                    minCost = min(minCost, totalCost + cost);\\n                }\\n\\n                dp[start][end] = minCost;\\n            }\\n        }\\n\\n        return dp[0][m - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570715,
                "title": "js-easy-solution-step-by-step-solution-100",
                "content": "![Screenshot from 2023-05-24 15-04-36.png](https://assets.leetcode.com/users/images/75d2e40a-d6da-4232-b0a6-ac8308c64515_1685252696.5166614.png)\\n\\n# Step By Step Decsription \\n1. The function minCost takes two parameters: n, which represents the total length of the stick, and cuts, which is an array of numbers representing the positions where the stick can be cut.\\n2. The cuts array is sorted in ascending order using the sort method. This is done to ensure that the cuts are processed in the correct order.\\n3. The cuts array is modified by adding two additional elements at the beginning and end: 0 and n respectively. These represent the starting and ending positions of the stick.\\n4. The variable stickLen is assigned the length of the cuts array.\\n5. A 2D array dp is created with dimensions stickLen by stickLen. This array will be used to store the minimum cost values for different subproblems.\\n6. The outer loop runs from stickLen - 2 to 0. This loop iterates over different possible starting positions for the cuts.\\n7. The inner loop runs from i + 2 to stickLen. This loop iterates over different possible ending positions for the cuts\\n8. Inside the inner loop, a variable minCost is initialized to Infinity. This variable will be used to find the minimum cost for the current subproblem.\\n9. Another loop runs from i + 1 to j - 1. This loop iterates over different possible positions for making cuts between the starting and ending positions.\\n10. Inside this loop, the cost for the current position k is calculated. It is obtained by adding the length of the stick between cuts[i] and cuts[j] with the minimum costs for the subproblems on the left and right sides of the current cut position.\\n11. The minimum cost between the current minCost and the calculated cost is taken using Math.min function. This ensures that minCost always stores the minimum cost for the current subproblem.\\n12. Finally, the minimum cost for the current subproblem is assigned to dp[i][j].\\n13. After the loops complete execution, the minimum cost for the entire stick is stored in dp[0][stickLen - 1].\\n14. The function returns the minimum cost as the result.\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[]} cuts\\n * @return {number}\\n */\\nvar minCost = function(n, cuts) {\\n    cuts.sort((a, b) => a - b)\\n    cuts = [0, ...cuts, n]\\n\\n    const stickLen = cuts.length\\n\\n    const dp = Array(stickLen).fill(0).map(() => Array(stickLen).fill(0))\\n\\n    for (let i = stickLen - 2; i >= 0; i--){\\n        for (let j = i + 2; j < stickLen; j++){\\n            let minCost = Infinity\\n            for (let k = i + 1; k < j; k++){\\n                const cost = cuts[j] - cuts[i] + dp[i][k] + dp[k][j]\\n                minCost = Math.min(minCost, cost)\\n            }\\n\\n            dp[i][j] = minCost\\n        }\\n    }\\n    return dp[0][stickLen - 1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} cuts\\n * @return {number}\\n */\\nvar minCost = function(n, cuts) {\\n    cuts.sort((a, b) => a - b)\\n    cuts = [0, ...cuts, n]\\n\\n    const stickLen = cuts.length\\n\\n    const dp = Array(stickLen).fill(0).map(() => Array(stickLen).fill(0))\\n\\n    for (let i = stickLen - 2; i >= 0; i--){\\n        for (let j = i + 2; j < stickLen; j++){\\n            let minCost = Infinity\\n            for (let k = i + 1; k < j; k++){\\n                const cost = cuts[j] - cuts[i] + dp[i][k] + dp[k][j]\\n                minCost = Math.min(minCost, cost)\\n            }\\n\\n            dp[i][j] = minCost\\n        }\\n    }\\n    return dp[0][stickLen - 1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570168,
                "title": "c-easy-dp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> dp;\\n    int recursion(int l, int r, int left, int right, vector<int> &cuts)\\n    {\\n        if (r < l) return 0;\\n        if (dp[l][r] != -1) return dp[l][r];\\n\\n        int answer = INT_MAX;\\n        for (int i = l; i <= r; i++)\\n        {\\n            int length = (right - left) ;\\n            int current = length + recursion(l, i - 1, left, cuts[i], cuts) + recursion(i + 1, r, cuts[i], right, cuts);\\n            answer = min(answer, current);\\n        }\\n\\n        return dp[l][r] = answer;\\n    }\\n    int minCost(int n, vector<int> &cuts)\\n    {\\n        dp = vector<vector<int>>(cuts.size() + 4, vector<int>(cuts.size() + 2, -1));\\n        sort(cuts.begin(), cuts.end());\\n        return recursion(0, cuts.size() - 1, 0, n, cuts);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> dp;\\n    int recursion(int l, int r, int left, int right, vector<int> &cuts)\\n    {\\n        if (r < l) return 0;\\n        if (dp[l][r] != -1) return dp[l][r];\\n\\n        int answer = INT_MAX;\\n        for (int i = l; i <= r; i++)\\n        {\\n            int length = (right - left) ;\\n            int current = length + recursion(l, i - 1, left, cuts[i], cuts) + recursion(i + 1, r, cuts[i], right, cuts);\\n            answer = min(answer, current);\\n        }\\n\\n        return dp[l][r] = answer;\\n    }\\n    int minCost(int n, vector<int> &cuts)\\n    {\\n        dp = vector<vector<int>>(cuts.size() + 4, vector<int>(cuts.size() + 2, -1));\\n        sort(cuts.begin(), cuts.end());\\n        return recursion(0, cuts.size() - 1, 0, n, cuts);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570093,
                "title": "minimum-cost-to-cut-a-stick",
                "content": "# Intuition\\nTo find the minimum total cost of the cuts, we can use dynamic programming. We can start by sorting the cuts in ascending order and then consider all possible subproblems.\\n\\n# Approach\\n1. Sort the cuts array in ascending order.\\n2. Create a new array called `cuts_arr` by adding 0 at the beginning and `n` at the end, and then appending the sorted cuts array.\\n3. Create a 2D array called `dp` with dimensions `(length of cuts_arr) x (length of cuts_arr)`, filled with infinity values.\\n4. Initialize the diagonal elements of `dp` with 0, as the cost of cutting a stick of length 0 is 0.\\n5. Iterate over the lengths of the stick ranges (starting from 2 up to the length of `cuts_arr`).\\n6. Iterate over the start positions of the stick ranges (from 0 to the length of `cuts_arr` minus the current length).\\n7. Calculate the end position of the stick range based on the start position and length.\\n8. Find the minimum cost by considering each possible cut position within the stick range.\\n   - Iterate over the cut positions (from the start position plus 1 to the end position minus 1).\\n   - Calculate the cost of cutting the stick at the current position (equal to the length of the stick range plus the difference between the positions in `cuts_arr`).\\n   - Update the minimum cost by considering the cost of the left part of the stick range (from the start position to the cut position) and the cost of the right part of the stick range (from the cut position to the end position).\\n9. Store the minimum cost in the corresponding position of `dp`.\\n10. The minimum total cost of the cuts is stored in `dp[0][-1]`.\\n\\n# Complexity Analysis\\nThe time complexity of this approach is O(n^3), where n is the length of the cuts array. This is because we iterate over all possible stick ranges and for each stick range, we iterate over all possible cut positions within that range.\\n\\nThe space complexity is O(n^2) to store the `dp` array.\\n# Code\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        # Add the start and end positions to the cuts array\\n        cuts = [0] + sorted(cuts) + [n]\\n        m = len(cuts)\\n        \\n        # Initialize the dp table with maximum values\\n        dp = [[float(\\'inf\\')] * m for _ in range(m)]\\n        \\n        # Base case: dp(i, i+1) = 0 since no cuts are made between consecutive positions\\n        for i in range(m - 1):\\n            dp[i][i + 1] = 0\\n        \\n        # Iterate over the lengths of the cut ranges\\n        for length in range(2, m):\\n            # Iterate over the start positions of the cut ranges\\n            for i in range(m - length):\\n                # Calculate the end position of the cut range\\n                j = i + length\\n                # Find the minimum cost by considering each possible cut position within the range\\n                for k in range(i + 1, j):\\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i])\\n        \\n        # The minimum cost to cut the entire stick is stored at dp(0, m-1)\\n        return dp[0][m - 1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        # Add the start and end positions to the cuts array\\n        cuts = [0] + sorted(cuts) + [n]\\n        m = len(cuts)\\n        \\n        # Initialize the dp table with maximum values\\n        dp = [[float(\\'inf\\')] * m for _ in range(m)]\\n        \\n        # Base case: dp(i, i+1) = 0 since no cuts are made between consecutive positions\\n        for i in range(m - 1):\\n            dp[i][i + 1] = 0\\n        \\n        # Iterate over the lengths of the cut ranges\\n        for length in range(2, m):\\n            # Iterate over the start positions of the cut ranges\\n            for i in range(m - length):\\n                # Calculate the end position of the cut range\\n                j = i + length\\n                # Find the minimum cost by considering each possible cut position within the range\\n                for k in range(i + 1, j):\\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i])\\n        \\n        # The minimum cost to cut the entire stick is stored at dp(0, m-1)\\n        return dp[0][m - 1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569182,
                "title": "dynamic-programming-rust",
                "content": "# Complexity\\n- Time complexity:\\n$$O((\\\\text{cuts.len()})^2)$$\\n\\n- Space complexity:\\n$$O((\\\\text{cuts.len()})^2)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_cost(n: i32, mut cuts: Vec<i32>) -> i32 {\\n        //add \"cuts\" at positions 0 and n (required for dp approach)\\n        cuts.push(0);\\n        cuts.push(n);\\n\\n        //sort, so that neighboring positions in this list require no cuts between them\\n        cuts.sort();\\n\\n        let mut dp_data = vec![vec![0; cuts.len()]; cuts.len()];\\n\\n        Solution::dp(0, cuts.len() - 1, &cuts, &mut dp_data)\\n    }\\n\\n    //Dynamic programming with memoization\\n    //returns the cost to add all required cuts to \\n    //the (sub)bar that starts at cuts[idx1] and ends at cuts[idx2]\\n    fn dp(idx1: usize, idx2: usize, cuts: &Vec<i32>, dp_data: &mut Vec<Vec<i32>>) -> i32 {\\n        if idx2 - idx1 == 1 || dp_data[idx1][idx2] > 0 {\\n            //solution is 0 or we already have a solution\\n            return dp_data[idx1][idx2];\\n        }\\n        let mut ans = 2000000000; //some large value\\n        for cut_idx in (idx1 + 1)..idx2 {\\n            //find the lowest cost cut in all cuts to be placed on the (sub)bar\\n            ans = std::cmp::min(ans, Solution::dp(idx1, cut_idx, cuts, dp_data) \\n                                    + Solution::dp(cut_idx, idx2, cuts, dp_data));\\n        }\\n        dp_data[idx1][idx2] = ans + cuts[idx2] - cuts[idx1];\\n        dp_data[idx1][idx2]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_cost(n: i32, mut cuts: Vec<i32>) -> i32 {\\n        //add \"cuts\" at positions 0 and n (required for dp approach)\\n        cuts.push(0);\\n        cuts.push(n);\\n\\n        //sort, so that neighboring positions in this list require no cuts between them\\n        cuts.sort();\\n\\n        let mut dp_data = vec![vec![0; cuts.len()]; cuts.len()];\\n\\n        Solution::dp(0, cuts.len() - 1, &cuts, &mut dp_data)\\n    }\\n\\n    //Dynamic programming with memoization\\n    //returns the cost to add all required cuts to \\n    //the (sub)bar that starts at cuts[idx1] and ends at cuts[idx2]\\n    fn dp(idx1: usize, idx2: usize, cuts: &Vec<i32>, dp_data: &mut Vec<Vec<i32>>) -> i32 {\\n        if idx2 - idx1 == 1 || dp_data[idx1][idx2] > 0 {\\n            //solution is 0 or we already have a solution\\n            return dp_data[idx1][idx2];\\n        }\\n        let mut ans = 2000000000; //some large value\\n        for cut_idx in (idx1 + 1)..idx2 {\\n            //find the lowest cost cut in all cuts to be placed on the (sub)bar\\n            ans = std::cmp::min(ans, Solution::dp(idx1, cut_idx, cuts, dp_data) \\n                                    + Solution::dp(cut_idx, idx2, cuts, dp_data));\\n        }\\n        dp_data[idx1][idx2] = ans + cuts[idx2] - cuts[idx1];\\n        dp_data[idx1][idx2]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3504981,
                "title": "1547-minimum-cost-to-cut-a-stick-java",
                "content": "```\\nclass Solution {\\n    \\n    public int min(int sta, int end, int dp[][],int []cut ,int l,int h)\\n    {\\n        if(l>h)\\n            return 0;\\n        \\n        if(dp[l][h]!=-1)\\n            return dp[l][h];\\n        int cost=Integer.MAX_VALUE;\\n        for(int i=l;i<=h;i++)\\n        {\\n            int leftcost=min(sta,cut[i],dp,cut,l,i-1);\\n            int rightcost=min(cut[i],end,dp,cut,i+1,h);\\n            int cur=(end-sta)+leftcost+rightcost;\\n            cost=Math.min(cost,cur);\\n        }\\n      return  dp[l][h]=cost;  \\n    }\\n    public int minCost(int n, int[] cuts) {\\n        int [][]dp=new int[cuts.length][cuts.length];\\n        for(int ar[]:dp)\\n            Arrays.fill(ar,-1);\\n        Arrays.sort(cuts);\\n        return min(0,n,dp,cuts,0,cuts.length-1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int min(int sta, int end, int dp[][],int []cut ,int l,int h)\\n    {\\n        if(l>h)\\n            return 0;\\n        \\n        if(dp[l][h]!=-1)\\n            return dp[l][h];\\n        int cost=Integer.MAX_VALUE;\\n        for(int i=l;i<=h;i++)\\n        {\\n            int leftcost=min(sta,cut[i],dp,cut,l,i-1);\\n            int rightcost=min(cut[i],end,dp,cut,i+1,h);\\n            int cur=(end-sta)+leftcost+rightcost;\\n            cost=Math.min(cost,cur);\\n        }\\n      return  dp[l][h]=cost;  \\n    }\\n    public int minCost(int n, int[] cuts) {\\n        int [][]dp=new int[cuts.length][cuts.length];\\n        for(int ar[]:dp)\\n            Arrays.fill(ar,-1);\\n        Arrays.sort(cuts);\\n        return min(0,n,dp,cuts,0,cuts.length-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463938,
                "title": "java-solution",
                "content": "# Code\n```\nclass Solution {\n    public int minCost(int n, int[] cuts) {\n        List<Integer>ct=new ArrayList<>();\n        for(int i=0;i<cuts.length;i++)ct.add(cuts[i]);\n        int c=ct.size();\n        return cost(n,c,ct);\n    }\n    public int f(int i, int j, List<Integer>cuts, int dp[][])\n    {\n        if(i>j) return 0;\n        if(dp[i][j]!=-1)\n            return dp[i][j];\n        int mini = Integer.MAX_VALUE;\n        for(int ind=i; ind<=j; ind++)\n        {\n            int ans = cuts.get(j+1) - cuts.get(i-1) + f(i,ind-1,cuts,dp) + f(ind+1,j,cuts,dp);\n            mini = (int)Math.min(mini, ans);\n        }\n        return dp[i][j] = mini;\n    }\n    public int cost(int n, int c, List<Integer>cuts)\n    {\n        cuts.add(n);\n        cuts.add(0,0);\n        Collections.sort(cuts);\n        int dp[][]=new int[c+1][c+1];\n        for(int r[]:dp)Arrays.fill(r,-1);\n        return f(1,c,cuts,dp);\n    }\n}\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\nclass Solution {\n    public int minCost(int n, int[] cuts) {\n        List<Integer>ct=new ArrayList<>();\n        for(int i=0;i<cuts.length;i++)ct.add(cuts[i]);\n        int c=ct.size();\n        return cost(n,c,ct);\n    }\n    public int f(int i, int j, List<Integer>cuts, int dp[][])\n    {\n        if(i>j) return 0;\n        if(dp[i][j]!=-1)\n            return dp[i][j];\n        int mini = Integer.MAX_VALUE;\n        for(int ind=i; ind<=j; ind++)\n        {\n            int ans = cuts.get(j+1) - cuts.get(i-1) + f(i,ind-1,cuts,dp) + f(ind+1,j,cuts,dp);\n            mini = (int)Math.min(mini, ans);\n        }\n        return dp[i][j] = mini;\n    }\n    public int cost(int n, int c, List<Integer>cuts)\n    {\n        cuts.add(n);\n        cuts.add(0,0);\n        Collections.sort(cuts);\n        int dp[][]=new int[c+1][c+1];\n        for(int r[]:dp)Arrays.fill(r,-1);\n        return f(1,c,cuts,dp);\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317395,
                "title": "c-fast-dp-memoization-tabulation",
                "content": "**Recursion & Memoization**\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int i,int j,vector<int>& cuts,vector<vector<int>>& dp){\\n        if(i>j) return 0;\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int mini = 1e9;\\n        for(int index =i; index<=j;index++){\\n            int cost = cuts[j+1]-cuts[i-1] + solve(i,index-1,cuts,dp) + solve(index+1,j,cuts,dp);\\n            mini=min(mini,cost);\\n        }\\n        return dp[i][j] = mini;\\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.insert(cuts.begin(),0);\\n        cuts.insert(cuts.end(),n);        \\n        sort(cuts.begin(),cuts.end());\\n        \\n        int m = cuts.size();\\n        vector<vector<int>> dp(m+1,vector<int>(m+1,-1));\\n        return solve(1,cuts.size()-2,cuts,dp);\\n    }\\n};\\n\\n\\n\\n\\n**DP Tabulation**\\n\\nclass Solution {\\npublic:\\n     \\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.insert(cuts.begin(),0);\\n        cuts.insert(cuts.end(),n);        \\n        sort(cuts.begin(),cuts.end());\\n        \\n        int m = cuts.size();\\n        vector<vector<int>> dp(m+1,vector<int>(m+1,0));\\n        \\n        for(int i=m-2;i>=1;i--){\\n            for(int j=i;j<=m-2;j++){                \\n                int mini = 1e9;\\n                for(int index =i; index<=j;index++){\\n                       int cost = cuts[j+1]-cuts[i-1] + dp[i][index-1] + dp[index+1][j];\\n                      mini=min(mini,cost);\\n                 }\\n                dp[i][j] = mini;\\n            }\\n        }\\n        \\n        return dp[1][cuts.size()-2];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int solve(int i,int j,vector<int>& cuts,vector<vector<int>>& dp){\\n        if(i>j) return 0;\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int mini = 1e9;\\n        for(int index =i; index<=j;index++){\\n            int cost = cuts[j+1]-cuts[i-1] + solve(i,index-1,cuts,dp) + solve(index+1,j,cuts,dp);\\n            mini=min(mini,cost);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3316479,
                "title": "c-dp-memoization-tabulation",
                "content": "Here is my c++ code for this problem.\\n\\n# Memoization\\n# Complexity\\n- Time complexity:$$O(n*n*n)$$\\n\\n- Space complexity:$$O(n*n)+O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& dp, vector<int>&cuts){\\n        if(i>j){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int mini=INT_MAX;\\n        for(int k=i; k<=j; k++){\\n            int ans=cuts[j+1]-cuts[i-1]+f(i, k-1, dp, cuts)+f(k+1, j, dp, cuts);\\n            mini=min(mini, ans);\\n        }\\n        return dp[i][j]=mini;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        int m=cuts.size();\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(), cuts.end());\\n        vector<vector<int>>dp(m+1, vector<int>(m+1, -1));\\n        return f(1, m, dp, cuts);\\n    }\\n};\\n```\\n# Memoization\\n# Complexity\\n- Time complexity:$$O(n*n*n)$$\\n\\n- Space complexity:$$O(n*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        int m=cuts.size();\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(), cuts.end());\\n        vector<vector<int>>dp(m+2, vector<int>(m+2, 0));\\n        for(int i=m; i>=1; i--){\\n            for(int j=1; j<=m; j++){\\n                if(i>j){continue;}\\n                int mini=INT_MAX;\\n                for(int k=i; k<=j; k++){\\n                    int ans=cuts[j+1]-cuts[i-1]+dp[i][k-1]+dp[k+1][j];\\n                    mini=min(mini, ans);\\n                }\\n                dp[i][j]=mini;\\n            }\\n        }\\n        return dp[1][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& dp, vector<int>&cuts){\\n        if(i>j){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int mini=INT_MAX;\\n        for(int k=i; k<=j; k++){\\n            int ans=cuts[j+1]-cuts[i-1]+f(i, k-1, dp, cuts)+f(k+1, j, dp, cuts);\\n            mini=min(mini, ans);\\n        }\\n        return dp[i][j]=mini;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        int m=cuts.size();\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(), cuts.end());\\n        vector<vector<int>>dp(m+1, vector<int>(m+1, -1));\\n        return f(1, m, dp, cuts);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        int m=cuts.size();\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(), cuts.end());\\n        vector<vector<int>>dp(m+2, vector<int>(m+2, 0));\\n        for(int i=m; i>=1; i--){\\n            for(int j=1; j<=m; j++){\\n                if(i>j){continue;}\\n                int mini=INT_MAX;\\n                for(int k=i; k<=j; k++){\\n                    int ans=cuts[j+1]-cuts[i-1]+dp[i][k-1]+dp[k+1][j];\\n                    mini=min(mini, ans);\\n                }\\n                dp[i][j]=mini;\\n            }\\n        }\\n        return dp[1][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272185,
                "title": "can-you-solve-it-in-this-much-easier-way-100-accepted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int start_stick, int end_stick, vector<int>& cuts, int left, int right){\\n        if(left > right) return 0;\\n        \\n        if(dp[left][right] != -1) return dp[left][right];\\n        \\n        int cost = 1e9;\\n        \\n        for(int i=left; i<=right; i++){\\n            int left_cost = solve(start_stick, cuts[i], cuts, left, i-1);\\n            int right_cost = solve(cuts[i], end_stick, cuts, i+1, right);\\n            int curr_cost = (end_stick - start_stick) + left_cost + right_cost;\\n            cost = min(cost,curr_cost);\\n        }\\n        \\n        return dp[left][right] = cost;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(cuts.begin(),cuts.end());\\n        return solve(0, n, cuts, 0, cuts.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int start_stick, int end_stick, vector<int>& cuts, int left, int right){\\n        if(left > right) return 0;\\n        \\n        if(dp[left][right] != -1) return dp[left][right];\\n        \\n        int cost = 1e9;\\n        \\n        for(int i=left; i<=right; i++){\\n            int left_cost = solve(start_stick, cuts[i], cuts, left, i-1);\\n            int right_cost = solve(cuts[i], end_stick, cuts, i+1, right);\\n            int curr_cost = (end_stick - start_stick) + left_cost + right_cost;\\n            cost = min(cost,curr_cost);\\n        }\\n        \\n        return dp[left][right] = cost;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(cuts.begin(),cuts.end());\\n        return solve(0, n, cuts, 0, cuts.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247343,
                "title": "c-dp-top-down-and-bottom-up",
                "content": "# Code [Recursive - TLE]\\n```\\nclass Solution {\\npublic:\\n    int m;\\n    int cut(int i,int j, vector<int>& cuts){\\n        int curr_cost = INT_MAX;\\n        for(int k=i+1;k<=j-1;k++){\\n            int total = cut(i,k,cuts,dp) + cut(k,j,cuts,dp) + (cuts[j]-cuts[i]);\\n            curr_cost = min(curr_cost,total);\\n        }\\n        return (curr_cost==INT_MAX) ? 0: curr_cost ;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(n);\\n        cuts.push_back(0);\\n        m = cuts.size();\\n        sort(cuts.begin(),cuts.end());\\n        return cut(0,m-1,cuts);\\n    }\\n};\\n```\\n___________________________________\\n# Code [Top-Down]\\n```\\nclass Solution {\\npublic:\\n    int m;\\n    int cut(int i,int j, vector<int>& cuts,vector<vector<int>>&dp){\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int curr_cost = INT_MAX;\\n        for(int k=i+1;k<=j-1;k++){\\n            int total = cut(i,k,cuts,dp) + cut(k,j,cuts,dp) + (cuts[j]-cuts[i]);\\n            curr_cost = min(curr_cost,total);\\n        }\\n        return dp[i][j] = (curr_cost==INT_MAX) ? 0: curr_cost ;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(n);\\n        cuts.push_back(0);\\n        m = cuts.size();\\n        vector<vector<int>> dp(m,vector<int>(m,-1));\\n        sort(cuts.begin(),cuts.end());\\n        return cut(0,m-1,cuts,dp);\\n    }\\n};\\n```\\n___________________________________\\n# Code [Bottom-Up]\\n```\\nclass Solution {\\npublic:\\n    int m;\\n    int cutBU(vector<int>& cuts){\\n        vector<vector<int>> dp(m,vector<int>(m));\\n        for(int i = m-1; i>=0 ;i--){\\n            for(int j = i+1;j<m;j++){\\n                int curr = INT_MAX;\\n                for(int k = i+1;k<=j-1;k++){\\n                    int total = dp[i][k] + dp[k][j] + cuts[j] - cuts[i];\\n                    curr = min(curr,total);\\n                }\\n                dp[i][j] = (curr == INT_MAX)? 0 : curr;\\n            }\\n        }\\n        return dp[0][m-1];\\n        \\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(n);\\n        cuts.push_back(0);\\n        m = cuts.size();\\n        sort(cuts.begin(),cuts.end());\\n        return cutBU(cuts);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m;\\n    int cut(int i,int j, vector<int>& cuts){\\n        int curr_cost = INT_MAX;\\n        for(int k=i+1;k<=j-1;k++){\\n            int total = cut(i,k,cuts,dp) + cut(k,j,cuts,dp) + (cuts[j]-cuts[i]);\\n            curr_cost = min(curr_cost,total);\\n        }\\n        return (curr_cost==INT_MAX) ? 0: curr_cost ;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(n);\\n        cuts.push_back(0);\\n        m = cuts.size();\\n        sort(cuts.begin(),cuts.end());\\n        return cut(0,m-1,cuts);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int m;\\n    int cut(int i,int j, vector<int>& cuts,vector<vector<int>>&dp){\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int curr_cost = INT_MAX;\\n        for(int k=i+1;k<=j-1;k++){\\n            int total = cut(i,k,cuts,dp) + cut(k,j,cuts,dp) + (cuts[j]-cuts[i]);\\n            curr_cost = min(curr_cost,total);\\n        }\\n        return dp[i][j] = (curr_cost==INT_MAX) ? 0: curr_cost ;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(n);\\n        cuts.push_back(0);\\n        m = cuts.size();\\n        vector<vector<int>> dp(m,vector<int>(m,-1));\\n        sort(cuts.begin(),cuts.end());\\n        return cut(0,m-1,cuts,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int m;\\n    int cutBU(vector<int>& cuts){\\n        vector<vector<int>> dp(m,vector<int>(m));\\n        for(int i = m-1; i>=0 ;i--){\\n            for(int j = i+1;j<m;j++){\\n                int curr = INT_MAX;\\n                for(int k = i+1;k<=j-1;k++){\\n                    int total = dp[i][k] + dp[k][j] + cuts[j] - cuts[i];\\n                    curr = min(curr,total);\\n                }\\n                dp[i][j] = (curr == INT_MAX)? 0 : curr;\\n            }\\n        }\\n        return dp[0][m-1];\\n        \\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(n);\\n        cuts.push_back(0);\\n        m = cuts.size();\\n        sort(cuts.begin(),cuts.end());\\n        return cutBU(cuts);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140754,
                "title": "memoization-tabulation-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int dfs(int i, int j, vector<int> &cuts, vector<vector<int>> &dp) {\\n        if(i > j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = 1e9;\\n        for(int k=i; k<=j; k++) {\\n            ans = min(ans, cuts[j + 1] - cuts[i - 1] + dfs(i, k - 1, cuts, dp) + dfs(k + 1, j, cuts, dp));\\n        }\\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        int m = cuts.size();\\n        cuts.insert(cuts.begin(), 0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(), cuts.end());\\n\\n        vector<vector<int>> dp(m + 1, vector<int>(m + 1, -1));\\n        return dfs(1, m, cuts, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        int m = cuts.size();\\n        cuts.insert(cuts.begin(), 0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(), cuts.end());\\n\\n        vector<vector<int>> dp(m + 2, vector<int>(m + 2));\\n\\n        for(int i=m; i>=1; i--) {\\n            for(int j=1; j<=m; j++) {\\n                if(i > j) continue;\\n                int ans = 1e9;\\n                for(int k=i; k<=j; k++) {\\n                    ans = min(ans, cuts[j + 1] - cuts[i - 1] + dp[i][k - 1] + dp[k + 1][j]);\\n                }\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[1][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int j, vector<int> &cuts, vector<vector<int>> &dp) {\\n        if(i > j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = 1e9;\\n        for(int k=i; k<=j; k++) {\\n            ans = min(ans, cuts[j + 1] - cuts[i - 1] + dfs(i, k - 1, cuts, dp) + dfs(k + 1, j, cuts, dp));\\n        }\\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        int m = cuts.size();\\n        cuts.insert(cuts.begin(), 0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(), cuts.end());\\n\\n        vector<vector<int>> dp(m + 1, vector<int>(m + 1, -1));\\n        return dfs(1, m, cuts, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        int m = cuts.size();\\n        cuts.insert(cuts.begin(), 0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(), cuts.end());\\n\\n        vector<vector<int>> dp(m + 2, vector<int>(m + 2));\\n\\n        for(int i=m; i>=1; i--) {\\n            for(int j=1; j<=m; j++) {\\n                if(i > j) continue;\\n                int ans = 1e9;\\n                for(int k=i; k<=j; k++) {\\n                    ans = min(ans, cuts[j + 1] - cuts[i - 1] + dp[i][k - 1] + dp[k + 1][j]);\\n                }\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[1][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125506,
                "title": "knuth-s-optimization-explanation-best-solution-o-n",
                "content": "# Intuition\\nGiven the stick of size N and the cuts array representing the markings at which cuts need to be made. Assume the current range of stick we have is $$[stick\\\\_start, stick\\\\_end]$$. \\nNow if we make a cut at a point \"$$cur\\\\_cut$$\", then then stick is divided further into two ranges $$[stick\\\\_start, cur\\\\_cut]$$ and $$[cur\\\\_cut, stick\\\\_end]$$. \\n\\nThe point to note is that the first all the cut $$markings < cur\\\\_cut$$ will lie in the first range and the cut $$markings > cur\\\\_cut$$ will lie in the second range. \\n\\nThus the first step to solve the problem is to sort the cuts so that we can recursively solve the sub-problems to arrive at the optimal solution.\\n\\nWe\\'ll be apppending 0 and N in the cuts array just to ease out the sub-problem formulation because when a cut is made lets say at point $$x$$ then we arrive at two nice sub-problems of ranges$$ [0, x]$$ and $$[x, N]$$\\n\\n# Approach\\n\\nSort the cuts array and apply standard range DP technique to solve the problem which will result in $$O(N^3)$$ time complexity solution which can get accepted considering the constraints given in the question.\\n\\nHowever there exists a DP optimization technique called the Knuth\\'s Optimization. This is a special case of dynamic programming on ranges that can optimize the time complexity of solutions by a linear factor, from $$O(N^3)$$ for standard range DP to $$O(N^2)$$.\\n\\nKnuth\\'s optimization is applied on DP problems with a transition of the following form:\\n\\n$$dp[i][j] = cost[i][j] + min(dp[i][k] + dp[k+1][j])\\\\ for\\\\ all\\\\ k\\\\ in\\\\ the\\\\ range[i, j)$$\\n\\nAdditionally, the cost function must satisfy the following 2 conditions for \\n$$(a<=b<=c<=d)$$:\\n\\n* It is monotonic on the lattice of intervals i.e \\n$$cost[b][c] <= cost[a][d]$$\\n* It satisfies the quadrangle inequality viz. \\n$$cost[a][c]+cost[b][d] <= cost[b][c]+cost[a][d]$$\\n\\nFor an $$O(N^3)$$ solution we would iterate from i to j-1, but we can optimize this iteration by storing the best value of k on  different ranges in another array lets say $$knuth$$ as per the code provided below.\\n\\n$$knuth[i][j] = Value\\\\ of\\\\ k\\\\ that\\\\ minimizes\\\\ the\\\\ expression\\\\ in\\\\ the\\\\ transition$$\\n\\nThe key to this optimization is the following inequality: \\n\\n$$knuth[i][j-1] <= knuth[i][j] <= knuth[i+1][j]$$\\n\\nThe proof of this inequality is out of scope of this article but should be understood as a source of truth to solve problems through this technique. \\n\\n# Complexity\\n\\nComplexity of the algorithm can be estimated as the following sum:\\n\\n$$For\\\\ all\\\\ i, j\\\\ from\\\\ 1\\\\ to\\\\ N$$\\n$$\\u03A3 \\u03A3\\\\ (knuth[i+1][j] - knuth[i][j-1])\\n$$ = $$\\u03A3 \\u03A3\\\\ (knuth[i+1][j+1] - knuth[i][j])$$\\n\\nMost of the terms in this expression cancel each other out, except for positive terms with j=N and negitive terms with i=1. Thus the whole sum can be estimated as \\n\\n$$\\u03A3\\\\ (knuth[k][N] - knuth[1][k])\\\\ for\\\\ all\\\\ k\\\\ from\\\\ 1\\\\ to\\\\ N$$ which is $$O(N^2)\\n$$\\n\\n- Time complexity: $$O(N^2)$$\\n\\n- Space complexity: $$O(N^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(), cuts.end());\\n        n = cuts.size();\\n        vector<vector<int>> dp(n, vector<int>(n));\\n        vector<vector<int>> knuth(n, vector<int>(n));\\n        for(int i=n-1; i>=0; i--){\\n            for(int j=i; j<n; j++){\\n                if (j-i+1<=2) {\\n                    knuth[i][j] = i;\\n                    continue;\\n                }           \\n                dp[i][j] = cuts[j] - cuts[i];\\n                int min = INT_MAX;\\n                for (int k = knuth[i][j - 1]; k <= knuth[i + 1][j]; k++){\\n                    int next = dp[i][k] + dp[k][j];\\n                    if (next < min) {\\n                        min = next;\\n                        knuth[i][j] = k;\\n                    }\\n                }\\n                dp[i][j] += min;\\n            }\\n        }\\n        return dp[0][n - 1];\\n    }\\n};\\n```\\nDo Upvote, If found helpful \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(), cuts.end());\\n        n = cuts.size();\\n        vector<vector<int>> dp(n, vector<int>(n));\\n        vector<vector<int>> knuth(n, vector<int>(n));\\n        for(int i=n-1; i>=0; i--){\\n            for(int j=i; j<n; j++){\\n                if (j-i+1<=2) {\\n                    knuth[i][j] = i;\\n                    continue;\\n                }           \\n                dp[i][j] = cuts[j] - cuts[i];\\n                int min = INT_MAX;\\n                for (int k = knuth[i][j - 1]; k <= knuth[i + 1][j]; k++){\\n                    int next = dp[i][k] + dp[k][j];\\n                    if (next < min) {\\n                        min = next;\\n                        knuth[i][j] = k;\\n                    }\\n                }\\n                dp[i][j] += min;\\n            }\\n        }\\n        return dp[0][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003121,
                "title": "easy-tabulation-dp-solution-short-code-beats-90",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThanks to striver for this wonderful approach <3\\n\\n1. Sort the CUTS array.\\n2. Append 0  and N at both ends of the CUTS array.\\n3. Convert the problem to a recursive function marked by two pointers i and j.\\n4. Use a partitioning loop to try all partitions.\\n5. Return the answer in which the partition gives the minimum cost.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n       O(N*N*N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n       O(N*N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        int c = cuts.size();\\n        cuts.insert(cuts.begin(),0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(),cuts.end());\\n\\n        vector<vector<int>> dp(c+2,vector<int> (c+2,0));\\n        for(int i=c;i>=1;i--){ \\n            for(int j=1;j<=c;j++){ \\n                if(i > j) continue;\\n                long mini = 1e9;\\n                for(int ind=i;ind<=j;ind++){\\n                    long cost = cuts[j+1] - cuts[i-1] + dp[i][ind-1] + dp[ind+1][j];\\n                    mini = min(mini,cost);\\n                }\\n                dp[i][j] = mini;\\n            }\\n        }\\n        return dp[1][c];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        int c = cuts.size();\\n        cuts.insert(cuts.begin(),0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(),cuts.end());\\n\\n        vector<vector<int>> dp(c+2,vector<int> (c+2,0));\\n        for(int i=c;i>=1;i--){ \\n            for(int j=1;j<=c;j++){ \\n                if(i > j) continue;\\n                long mini = 1e9;\\n                for(int ind=i;ind<=j;ind++){\\n                    long cost = cuts[j+1] - cuts[i-1] + dp[i][ind-1] + dp[ind+1][j];\\n                    mini = min(mini,cost);\\n                }\\n                dp[i][j] = mini;\\n            }\\n        }\\n        return dp[1][c];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800565,
                "title": "c-solution",
                "content": "```\\n int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(),cuts.end());\\n        int m=cuts.size();\\n        vector<vector<int>>dp(m,vector<int>(m,INT_MAX));\\n        for(int i=0;i<m-1;i++)\\n            dp[i][i+1]=0;\\n        for(int i=0;i<m-2;i++)\\n            dp[i][i+2]=cuts[i+2]-cuts[i];\\n        for(int i=1;i<m;i++)\\n        {\\n            int k=0;\\n            for(int j=i+1;j<m;j++,k++)\\n            {\\n                int cost=INT_MAX;\\n                for(int u=k+1;u<j;u++)\\n                {\\n                     //cout<<k<<\" \"<<j<<\" \"<<u<<endl;\\n                    cost=min(cost,cuts[j]-cuts[k]+dp[k][u]+dp[u][j]);\\n                }\\n                dp[k][j]=min(dp[k][j],cost);\\n            }\\n        }\\n        \\n        return dp[0][m-1];\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int minCost(int n, vector<int>& cuts) {\\n        cuts.push_back(0);\\n        cuts.push_back(n);\\n        sort(cuts.begin(),cuts.end());\\n        int m=cuts.size();\\n        vector<vector<int>>dp(m,vector<int>(m,INT_MAX));\\n        for(int i=0;i<m-1;i++)\\n            dp[i][i+1]=0;\\n        for(int i=0;i<m-2;i++)\\n            dp[i][i+2]=cuts[i+2]-cuts[i];\\n        for(int i=1;i<m;i++)\\n        {\\n            int k=0;\\n            for(int j=i+1;j<m;j++,k++)\\n            {\\n                int cost=INT_MAX;\\n                for(int u=k+1;u<j;u++)\\n                {\\n                     //cout<<k<<\" \"<<j<<\" \"<<u<<endl;\\n                    cost=min(cost,cuts[j]-cuts[k]+dp[k][u]+dp[u][j]);\\n                }\\n                dp[k][j]=min(dp[k][j],cost);\\n            }\\n        }\\n        \\n        return dp[0][m-1];\\n        \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2730178,
                "title": "easy-mcm-variation-rec-memo-tabulation-comments-merge-stones",
                "content": "**Approach** : MCM : Matrix Chain Multiplication : Because at every index we can make a partition over there.\\n\\n**Similar Question:** <a href=\"https://leetcode.com/problems/minimum-cost-to-merge-stones/discuss/2332155/easy-mcm-variation-rec-memo-tabulation-comments\">1000. Minimum cost to merge stones</a>\\n\\n**Question Breakdown and thought process:**\\n\\nHere we are given n sticks and we are given partitition areas where we can make partition. At every partition the cost is the length on which partition is occuring...\\n\\n**Crux** : The minimum length is 0 and maximum length is n. [0, elements, n]\\nWe will sort the cuts array first and then... we will do insertion.\\nSo, we will insert minimum at first and maximum at last in cuts vector.\\n\\nThen we can make partition after 1st index to second_last index. as first and last are the heights....\\n\\nLet\\'s talk about some base cases:\\n```\\n1. if(i > j) return 0;  // if we are at invalid index  \\n```\\nIn the start as we sort the array, so our all cuts are independent of each other...\\nValid Range: Here i is at 1st index and j is at second last index.\\n```\\n    i        j   \\n{0, 1, 3, 4, 5, 7}\\n```\\nAfter 1st partition cost : will be arr[j + 1] - arr[i - 1] = 7 - 0 = 7 : which is true.\\n\\nif we make cut at 3 length stick, then 4, 5, 1 aren\\'t affected from it, they all are independent because of sorting....\\n```\\n   ij    i  j \\n0 {1} 3 {4, 5} 7\\n```\\nif we make cut at 5 length stick, then cost will be = arr[j + 1] - arr[i - 1] = 7 - 3 = 4;\\n```\\n   ij   ij\\n0 {1} 3 {4} 5 7\\n```\\nif we make cut at 1 length stick, then cost will be = arr[j + 1] - arr[i - 1] = 3 - 0 = 3;\\n```\\n      ij  \\n0 1 3 {4} 5 7\\n```\\nif we make cut at 4 length stick, then cost will be = arr[j + 1] - arr[i - 1] = 5 - 3 = 2;\\n\\nTotal cost = 7 + 4 + 3 + 2 = 16 : which is minimum cost we can obtain from this array.\\n\\n**Base Case:** Index out of range.\\nSo, if(i > j) return 0;\\n\\n**Driver Function  :**\\nas we know : valid partition range from 1st to second last_index : that\\'s why we call rec : \\nrec(1, cuts.size()-2);\\n\\nIn Induction Step : \\nwe have to run for loop from i to j.. : including j : as cuts.size()-2 is last_valid_partition...\\n\\nfor(int k = i; k <= j; k++){\\n\\n}\\n\\nFor every call : Cost : will be cost[j+1] - cost[i-1];\\n\\nIf we make cut at kth index : then we need to get sum of rec(i, k-1) + rec(k+1, j) + cost;\\n\\nand in the end we get minimum one...\\n**Recursion:**\\n```\\n// TC: O(N*(2^N))\\n// SC: O(N*(2^N)) + O(N) auxilary space\\nclass Solution {\\npublic:\\n    int rec(int i, int j, vector<int> &cuts){\\n        if(i > j) return 0;\\n        \\n        int mini = INT_MAX;\\n        for(int k = i; k <= j; k++){\\n            int cost = rec(i, k-1, cuts) + rec(k+1, j, cuts) + (cuts[j+1] - cuts[i-1]);\\n            mini = min(mini, cost);\\n        }\\n        return mini;\\n    }\\n    int minCost(int n, vector<int>& cuts){\\n        // cuts.insert(cuts.begin(), 0); // here we can insert 0 by emplace_back : as they are going to be sorted...\\n        cuts.emplace_back(0);\\n        cuts.emplace_back(n);\\n        \\n        sort(cuts.begin(), cuts.end());\\n        \\n        return rec(1, cuts.size()-2, cuts);\\n    }\\n};\\n```\\n**Memoization:**\\n```\\n// TC: O(N*N*N) = O(N^3)\\n// SC: O(N^2) + O(N) Auxilary Stack Space\\nclass Solution {\\npublic:\\n    int memo[101][101];\\n    int rec(int i, int j, vector<int> &cuts){\\n        if(i > j) return 0;\\n        if(memo[i][j] != -1) return memo[i][j];\\n        int mini = INT_MAX;\\n        for(int k = i; k <= j; k++){\\n            int cost = rec(i, k-1, cuts) + rec(k+1, j, cuts) + (cuts[j+1] - cuts[i-1]);\\n            mini = min(mini, cost);\\n        }\\n        return memo[i][j] = mini;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(), cuts.end());\\n        \\n        cuts.emplace_back(n);\\n        cuts.insert(cuts.begin(), 0);\\n        \\n        memset(memo, -1, sizeof(memo));\\n        return rec(1, cuts.size()-2, cuts);\\n    }\\n};\\n```\\n**Memoization to Tabulation :**\\n```\\nTop Down --> Bottom Up :\\n1. Fill the base cases.\\n2. Convert : rec(i, j) -> dp[i][j];\\n3. Set valid ranges in for loop.\\n4. Copy recurrence from Recursion : )\\n```\\n\\nIn Memo Base Call : rec(1, cuts.size()-2, memo);\\n\\nMeans we will get our answer at dp[1][cuts.size()-2];\\n\\nAlso, in recursion for i : we will go like 1st to second_last_index..\\n\\nSo, in bottom up we will go like second_last_index to 1.\\nfor(int i = cuts.size()-2; i > 0; i--){\\n\\n}\\n\\nAlso, in recurison our dp[1][cuts.size()-2] : means for jth index we get ans in second last_index : means we have to fill the 1 to second_last_index : to get answer..\\n\\nSo, our dp second loop will go from 1 to second_last_index:\\n\\nCatch : Our valid index range is of (i < j) and if(i > j) occur it\\'s invalid and answer is 0;\\n\\nSo, our j loop will start from ith index to Second_last_index instead of 1...\\n\\nfor(int j = i; j < cuts.size()-1; i++)\\n\\nand we will store minimum answer and then return it..\\n```\\n// TC: O(N^3) & SC: O(N^2)\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        // cuts.insert(cuts.begin(), 0); // here we can insert 0 by emplace_back : as they are going to be sorted...\\n        cuts.emplace_back(0);\\n        cuts.emplace_back(n);\\n        \\n        sort(cuts.begin(), cuts.end());\\n        \\n        // vector<vector<int>> dp (cuts.size(), vector<int> (cuts.size(), 0));\\n        n = cuts.size();\\n        \\n        int dp[n][n];\\n        \\n        // Filling the first base case : if(i > j) return 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++) dp[i][j] = 0;\\n        }\\n        \\n        // Filling the rest...\\n        for(int i = cuts.size()-2; i > 0; i--){\\n            for(int j = i; j < cuts.size()-1; j++){\\n                int mini = INT_MAX;\\n        \\n                for(int k = i; k <= j; k++){\\n                    int cost = dp[i][k-1] + dp[k+1][j] + (cuts[j+1] - cuts[i-1]);\\n                    mini = min(mini, cost);\\n                }\\n                dp[i][j] = mini;\\n            }\\n        }\\n        \\n        return dp[1][cuts.size()-2];\\n    }\\n};\\n/*\\nNested loop condition : )\\n    either we can start loop at j = i to cut.size() - 2\\n    or \\n    we can start j = 0; and then we can add if else to handle out of range...\\n    if(i > j){\\n        dp[i][j] = 0;\\n        continue;\\n    }\\n*/\\n```\\n**Concise Version:**\\n```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.emplace_back(0);\\n        cuts.emplace_back(n);\\n        \\n        sort(cuts.begin(), cuts.end());\\n        \\n        n = cuts.size();\\n        \\n        int dp[n][n];\\n        \\n        // Filling the first base case : if(i > j) return 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++) dp[i][j] = 0;\\n        }\\n        \\n        // Filling the rest...\\n        for(int i = cuts.size()-2; i > 0; i--){\\n            for(int j = i; j < cuts.size()-1; j++){\\n                int mini = INT_MAX;\\n        \\n                for(int k = i; k <= j; k++){\\n                    int cost = dp[i][k-1] + dp[k+1][j] + (cuts[j+1] - cuts[i-1]);\\n                    mini = min(mini, cost);\\n                }\\n                dp[i][j] = mini;\\n            }\\n        }\\n        \\n        return dp[1][cuts.size()-2];\\n    }\\n};\\n```\\nDoubts, Queries & Better Approaches are most Welcome : )\\nHave a nice day \\uD83C\\uDF3B",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n1. if(i > j) return 0;  // if we are at invalid index  \\n```\n```\\n    i        j   \\n{0, 1, 3, 4, 5, 7}\\n```\n```\\n   ij    i  j \\n0 {1} 3 {4, 5} 7\\n```\n```\\n   ij   ij\\n0 {1} 3 {4} 5 7\\n```\n```\\n      ij  \\n0 1 3 {4} 5 7\\n```\n```\\n// TC: O(N*(2^N))\\n// SC: O(N*(2^N)) + O(N) auxilary space\\nclass Solution {\\npublic:\\n    int rec(int i, int j, vector<int> &cuts){\\n        if(i > j) return 0;\\n        \\n        int mini = INT_MAX;\\n        for(int k = i; k <= j; k++){\\n            int cost = rec(i, k-1, cuts) + rec(k+1, j, cuts) + (cuts[j+1] - cuts[i-1]);\\n            mini = min(mini, cost);\\n        }\\n        return mini;\\n    }\\n    int minCost(int n, vector<int>& cuts){\\n        // cuts.insert(cuts.begin(), 0); // here we can insert 0 by emplace_back : as they are going to be sorted...\\n        cuts.emplace_back(0);\\n        cuts.emplace_back(n);\\n        \\n        sort(cuts.begin(), cuts.end());\\n        \\n        return rec(1, cuts.size()-2, cuts);\\n    }\\n};\\n```\n```\\n// TC: O(N*N*N) = O(N^3)\\n// SC: O(N^2) + O(N) Auxilary Stack Space\\nclass Solution {\\npublic:\\n    int memo[101][101];\\n    int rec(int i, int j, vector<int> &cuts){\\n        if(i > j) return 0;\\n        if(memo[i][j] != -1) return memo[i][j];\\n        int mini = INT_MAX;\\n        for(int k = i; k <= j; k++){\\n            int cost = rec(i, k-1, cuts) + rec(k+1, j, cuts) + (cuts[j+1] - cuts[i-1]);\\n            mini = min(mini, cost);\\n        }\\n        return memo[i][j] = mini;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(), cuts.end());\\n        \\n        cuts.emplace_back(n);\\n        cuts.insert(cuts.begin(), 0);\\n        \\n        memset(memo, -1, sizeof(memo));\\n        return rec(1, cuts.size()-2, cuts);\\n    }\\n};\\n```\n```\\nTop Down --> Bottom Up :\\n1. Fill the base cases.\\n2. Convert : rec(i, j) -> dp[i][j];\\n3. Set valid ranges in for loop.\\n4. Copy recurrence from Recursion : )\\n```\n```\\n// TC: O(N^3) & SC: O(N^2)\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        // cuts.insert(cuts.begin(), 0); // here we can insert 0 by emplace_back : as they are going to be sorted...\\n        cuts.emplace_back(0);\\n        cuts.emplace_back(n);\\n        \\n        sort(cuts.begin(), cuts.end());\\n        \\n        // vector<vector<int>> dp (cuts.size(), vector<int> (cuts.size(), 0));\\n        n = cuts.size();\\n        \\n        int dp[n][n];\\n        \\n        // Filling the first base case : if(i > j) return 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++) dp[i][j] = 0;\\n        }\\n        \\n        // Filling the rest...\\n        for(int i = cuts.size()-2; i > 0; i--){\\n            for(int j = i; j < cuts.size()-1; j++){\\n                int mini = INT_MAX;\\n        \\n                for(int k = i; k <= j; k++){\\n                    int cost = dp[i][k-1] + dp[k+1][j] + (cuts[j+1] - cuts[i-1]);\\n                    mini = min(mini, cost);\\n                }\\n                dp[i][j] = mini;\\n            }\\n        }\\n        \\n        return dp[1][cuts.size()-2];\\n    }\\n};\\n/*\\nNested loop condition : )\\n    either we can start loop at j = i to cut.size() - 2\\n    or \\n    we can start j = 0; and then we can add if else to handle out of range...\\n    if(i > j){\\n        dp[i][j] = 0;\\n        continue;\\n    }\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        cuts.emplace_back(0);\\n        cuts.emplace_back(n);\\n        \\n        sort(cuts.begin(), cuts.end());\\n        \\n        n = cuts.size();\\n        \\n        int dp[n][n];\\n        \\n        // Filling the first base case : if(i > j) return 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++) dp[i][j] = 0;\\n        }\\n        \\n        // Filling the rest...\\n        for(int i = cuts.size()-2; i > 0; i--){\\n            for(int j = i; j < cuts.size()-1; j++){\\n                int mini = INT_MAX;\\n        \\n                for(int k = i; k <= j; k++){\\n                    int cost = dp[i][k-1] + dp[k+1][j] + (cuts[j+1] - cuts[i-1]);\\n                    mini = min(mini, cost);\\n                }\\n                dp[i][j] = mini;\\n            }\\n        }\\n        \\n        return dp[1][cuts.size()-2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627497,
                "title": "mcm-logic-c",
                "content": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int>mp;\\n    int solve(vector<int>&cuts, int start,int end,int i, int j){\\n        if(i>j or end-start==0)\\n            return 0;\\n        if(mp.find({i,j})!=mp.end()){\\n            return mp[{i,j}];\\n        }\\n        if(i==j )\\n            return mp[{i,j}]= end-start;\\n        // cout<<start<<\" \"<<end<<\" \"<<cuts[i]<<\" \"<<cuts[j]<<\" \"<<i<<\" \"<<j<<endl;\\n        int ans=INT_MAX;\\n        for(int cut=i;cut<j+1;cut++){\\n            int val = (end-start)+solve(cuts,start,cuts[cut],i,cut-1)+solve(cuts,cuts[cut],end,cut+1,j);\\n            ans =min(ans,val);\\n        }\\n        return mp[{i,j}]= ans;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        int len =cuts.size();\\n        sort(cuts.begin(),cuts.end());\\n        mp.clear();\\n        return solve(cuts,0,n,0,len-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int>mp;\\n    int solve(vector<int>&cuts, int start,int end,int i, int j){\\n        if(i>j or end-start==0)\\n            return 0;\\n        if(mp.find({i,j})!=mp.end()){\\n            return mp[{i,j}];\\n        }\\n        if(i==j )\\n            return mp[{i,j}]= end-start;\\n        // cout<<start<<\" \"<<end<<\" \"<<cuts[i]<<\" \"<<cuts[j]<<\" \"<<i<<\" \"<<j<<endl;\\n        int ans=INT_MAX;\\n        for(int cut=i;cut<j+1;cut++){\\n            int val = (end-start)+solve(cuts,start,cuts[cut],i,cut-1)+solve(cuts,cuts[cut],end,cut+1,j);\\n            ans =min(ans,val);\\n        }\\n        return mp[{i,j}]= ans;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        int len =cuts.size();\\n        sort(cuts.begin(),cuts.end());\\n        mp.clear();\\n        return solve(cuts,0,n,0,len-1);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2619583,
                "title": "c-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        memset(dp, -1, sizeof(dp));\\n        sort(cuts.begin(), cuts.end());\\n       \\n        return find(cuts, 0, cuts.size()-1, n, 0);\\n    }\\n    \\n    int find(vector<int>& v, int i, int j, int high, int low) {\\n        if(i>j) {\\n            return 0;\\n        }\\n        if(dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        int val = INT_MAX;\\n        for(int k = i; k<=j; k++) {\\n            val = min(val, high-low+find(v, i, k-1, v[k], low)+find(v,k+1,j,high, v[k]));\\n        }\\n        return dp[i][j]=val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        memset(dp, -1, sizeof(dp));\\n        sort(cuts.begin(), cuts.end());\\n       \\n        return find(cuts, 0, cuts.size()-1, n, 0);\\n    }\\n    \\n    int find(vector<int>& v, int i, int j, int high, int low) {\\n        if(i>j) {\\n            return 0;\\n        }\\n        if(dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        int val = INT_MAX;\\n        for(int k = i; k<=j; k++) {\\n            val = min(val, high-low+find(v, i, k-1, v[k], low)+find(v,k+1,j,high, v[k]));\\n        }\\n        return dp[i][j]=val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618917,
                "title": "tabulation-solution-in-python",
                "content": "```\\n#tabulation\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        c=len(cuts)\\n        cuts.insert(0,0)\\n        cuts.append(n)\\n        cuts.sort()\\n        dp=[[0 for _ in range(c+2)]for _ in range(c+2)]\\n        for i in range(c,0,-1):\\n            for j in range(1,c+1):\\n                if i>j:\\n                    continue\\n                mini=float(\\'inf\\')\\n                for ind in range(i,j+1):\\n                    cost=cuts[j+1]-cuts[i-1]+dp[i][ind-1]+dp[ind+1][j]\\n                    mini=min(mini,cost)\\n                dp[i][j]=mini\\n        return dp[1][c]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n#tabulation\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        c=len(cuts)\\n        cuts.insert(0,0)\\n        cuts.append(n)\\n        cuts.sort()\\n        dp=[[0 for _ in range(c+2)]for _ in range(c+2)]\\n        for i in range(c,0,-1):\\n            for j in range(1,c+1):\\n                if i>j:\\n                    continue\\n                mini=float(\\'inf\\')\\n                for ind in range(i,j+1):\\n                    cost=cuts[j+1]-cuts[i-1]+dp[i][ind-1]+dp[ind+1][j]\\n                    mini=min(mini,cost)\\n                dp[i][j]=mini\\n        return dp[1][c]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534350,
                "title": "c-easy-to-understand-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(vector<int>&cuts,int n,int s,int e,int si,int ei)\\n    {\\n        if(s+1==e || si>ei) // if stick length is 1 OR starting cut index is greater than ending cut index\\n        {\\n            return 0;\\n        }\\n        if(dp[si][ei]!=-1)\\n        {\\n            return dp[si][ei];\\n        }\\n        int ans=INT_MAX;\\n        for(int i=si;i<=ei;++i)\\n        {\\n            ans=min(ans,solve(cuts,n,s,cuts[i],si,i-1)+solve(cuts,n,cuts[i],e,i+1,ei)+(e-s));\\n        }\\n        return dp[si][ei]=ans;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(cuts.begin(),cuts.end());\\n        return solve(cuts,n,0,n,0,cuts.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(vector<int>&cuts,int n,int s,int e,int si,int ei)\\n    {\\n        if(s+1==e || si>ei) // if stick length is 1 OR starting cut index is greater than ending cut index\\n        {\\n            return 0;\\n        }\\n        if(dp[si][ei]!=-1)\\n        {\\n            return dp[si][ei];\\n        }\\n        int ans=INT_MAX;\\n        for(int i=si;i<=ei;++i)\\n        {\\n            ans=min(ans,solve(cuts,n,s,cuts[i],si,i-1)+solve(cuts,n,cuts[i],e,i+1,ei)+(e-s));\\n        }\\n        return dp[si][ei]=ans;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(cuts.begin(),cuts.end());\\n        return solve(cuts,n,0,n,0,cuts.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510891,
                "title": "python-easy-solution-best-approch",
                "content": "# Memoisation : TLE\\n```\\nclass Solution:\\n    def f(self,i,j,cuts,dp):\\n        if i>j:\\n            return 0\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        mini=float(\"inf\")\\n        for ind in range(i,j+1):\\n            cost=(cuts[j+1]-cuts[i-1]) +self.f(i,ind-1,cuts,dp) + self.f(ind+1,j,cuts,dp)\\n            mini=min(mini,cost)\\n            dp[i][j]=mini\\n        return dp[i][j]\\n\\n        \\n    def minCost(self, N: int, cuts: List[int]) -> int:\\n        c=len(cuts)\\n        cuts.append(0)\\n        cuts.append(N)\\n        cuts.sort()\\n        dp=[[-1 for i in range(c+1)]for j in range(c+1)]  \\n\\t\\treturn self.f(1,c,cuts,dp)\\n```\\n# Tabulation : Accepted \\n```\\n    def minCost(self, N: int, cuts: List[int]) -> int:\\n        c=len(cuts)\\n        cuts.append(0)\\n        cuts.append(N)\\n        cuts.sort()\\n        dp=[[0 for i in range(c+2)]for j in range(c+2)]  \\n        for i in range(c,0,-1):\\n            for j in range(1,c+1):\\n                if i>j:\\n                    continue\\n                mini=float(\"inf\")\\n                for ind in range(i,j+1):\\n                    cost=cuts[j+1]-cuts[i-1] +dp[i][ind-1] + dp[ind+1][j]\\n                    mini=min(mini,cost)\\n                dp[i][j]=mini\\n        return dp[1][c]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def f(self,i,j,cuts,dp):\\n        if i>j:\\n            return 0\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        mini=float(\"inf\")\\n        for ind in range(i,j+1):\\n            cost=(cuts[j+1]-cuts[i-1]) +self.f(i,ind-1,cuts,dp) + self.f(ind+1,j,cuts,dp)\\n            mini=min(mini,cost)\\n            dp[i][j]=mini\\n        return dp[i][j]\\n\\n        \\n    def minCost(self, N: int, cuts: List[int]) -> int:\\n        c=len(cuts)\\n        cuts.append(0)\\n        cuts.append(N)\\n        cuts.sort()\\n        dp=[[-1 for i in range(c+1)]for j in range(c+1)]  \\n\\t\\treturn self.f(1,c,cuts,dp)\\n```\n```\\n    def minCost(self, N: int, cuts: List[int]) -> int:\\n        c=len(cuts)\\n        cuts.append(0)\\n        cuts.append(N)\\n        cuts.sort()\\n        dp=[[0 for i in range(c+2)]for j in range(c+2)]  \\n        for i in range(c,0,-1):\\n            for j in range(1,c+1):\\n                if i>j:\\n                    continue\\n                mini=float(\"inf\")\\n                for ind in range(i,j+1):\\n                    cost=cuts[j+1]-cuts[i-1] +dp[i][ind-1] + dp[ind+1][j]\\n                    mini=min(mini,cost)\\n                dp[i][j]=mini\\n        return dp[1][c]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508565,
                "title": "java-one-of-the-easiest-solution-recursion-memo-dp",
                "content": "**Recursion**\\n```\\nprivate static int solve(ArrayList<Integer> arr, int i, int j){\\n        if(i > j) return 0;\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j;k++){\\n            int temp = solve(arr, i, k-1) + solve(arr, k+1, j) + arr.get(j+1) - arr.get(i-1);\\n            ans = Math.min(ans, temp);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n```\\n**Memoization**\\n```\\nprivate static int solve(ArrayList<Integer> arr, int i, int j, Integer[][] dp){\\n        if(i > j) return 0;\\n        if(dp[i][j] != null) return dp[i][j];\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j;k++){\\n            int temp = solve(arr, i, k-1, dp) + solve(arr, k+1, j, dp) + arr.get(j+1) - arr.get(i-1);\\n            ans = Math.min(ans, temp);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n```\\n\\n**Dynamic Programming**\\n```\\npublic int minCost(int n, int[] cuts) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        arr.add(0);\\n        for(int i : cuts){\\n            arr.add(i);\\n        }\\n        arr.add(n);\\n        Collections.sort(arr);\\n        int m = cuts.length;\\n        //Integer[][] dp = new Integer[m+1][m+1];\\n        //return solve(arr,1, cuts.length, dp);\\n        return solveTab(arr, m);\\n    }\\n    \\n    private static int solveTab(ArrayList<Integer> arr, int m){\\n        int[][] dp = new int[m+2][m+2];\\n\\n        for (int i = m; i >= 1; i--) {\\n            for (int j = 1; j <= m; j++) {\\n                if(i > j) continue;\\n                int ans = Integer.MAX_VALUE;\\n                for(int k=i;k<=j;k++){\\n                    int temp = dp[i][k-1] + dp[k+1][j] + arr.get(j+1) - arr.get(i-1);\\n                    ans = Math.min(ans, temp);\\n                }\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[1][m];\\n    }\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate static int solve(ArrayList<Integer> arr, int i, int j){\\n        if(i > j) return 0;\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j;k++){\\n            int temp = solve(arr, i, k-1) + solve(arr, k+1, j) + arr.get(j+1) - arr.get(i-1);\\n            ans = Math.min(ans, temp);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n```\n```\\nprivate static int solve(ArrayList<Integer> arr, int i, int j, Integer[][] dp){\\n        if(i > j) return 0;\\n        if(dp[i][j] != null) return dp[i][j];\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=i;k<=j;k++){\\n            int temp = solve(arr, i, k-1, dp) + solve(arr, k+1, j, dp) + arr.get(j+1) - arr.get(i-1);\\n            ans = Math.min(ans, temp);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n```\n```\\npublic int minCost(int n, int[] cuts) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        arr.add(0);\\n        for(int i : cuts){\\n            arr.add(i);\\n        }\\n        arr.add(n);\\n        Collections.sort(arr);\\n        int m = cuts.length;\\n        //Integer[][] dp = new Integer[m+1][m+1];\\n        //return solve(arr,1, cuts.length, dp);\\n        return solveTab(arr, m);\\n    }\\n    \\n    private static int solveTab(ArrayList<Integer> arr, int m){\\n        int[][] dp = new int[m+2][m+2];\\n\\n        for (int i = m; i >= 1; i--) {\\n            for (int j = 1; j <= m; j++) {\\n                if(i > j) continue;\\n                int ans = Integer.MAX_VALUE;\\n                for(int k=i;k<=j;k++){\\n                    int temp = dp[i][k-1] + dp[k+1][j] + arr.get(j+1) - arr.get(i-1);\\n                    ans = Math.min(ans, temp);\\n                }\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[1][m];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2495360,
                "title": "c-dp-all-solution",
                "content": "//Recursion\\n```\\nclass Solution {\\npublic:\\n     int solve(int i,int j,vector<int>& cuts){\\n        if(i>j) return 0;\\n        int mini=INT_MAX;\\n        for(int ind=i;ind<=j;ind++){\\n            int cost = cuts[j+1] - cuts[i-1] + solve(i, ind-1, cuts) + solve(ind+1, j, cuts);\\n            mini=min(mini, cost);\\n        }\\n        return mini;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        \\n        int c=cuts.size();\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        sort(cuts.begin(),cuts.end());\\n        \\n        return solve(1,c,cuts);\\n    }\\n};\\n```\\n//Memoization\\n```\\nclass Solution {\\npublic:\\n     int solve(int i,int j,vector<int>& cuts,vector<vector<int>> &dp){\\n        if(i>j) return 0;\\n        int mini=INT_MAX;\\n         if(dp[i][j]!=-1)\\n             return dp[i][j];\\n        for(int ind=i;ind<=j;ind++){\\n            int cost = cuts[j+1] - cuts[i-1] + solve(i, ind-1, cuts,dp) + solve(ind+1, j, cuts,dp);\\n            mini=min(mini, cost);\\n        }\\n        return dp[i][j]=mini;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        \\n        int c=cuts.size();\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        sort(cuts.begin(),cuts.end());\\n        vector<vector<int>> dp(c+1,vector<int>(c+1,-1));\\n        \\n        return solve(1,c,cuts,dp);\\n    }\\n};\\n```\\n// Tabulation \\n```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        \\n        int c=cuts.size();\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        sort(cuts.begin(),cuts.end());\\n        vector<vector<int>> dp(c+2,vector<int>(c+2,0));\\n        for(int i=c;i>=1;i--){\\n            for(int j=1;j<=c;j++){\\n                if(i>j)\\n                    continue;\\n                int mini=INT_MAX;\\n         \\n                for(int ind=i;ind<=j;ind++){\\n                    int cost = cuts[j+1] - cuts[i-1] + dp[i][ind-1] + dp[ind+1][j];\\n                    mini=min(mini, cost);\\n                }\\n                 dp[i][j]=mini;\\n            }\\n        }\\n        \\n        return dp[1][c];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int solve(int i,int j,vector<int>& cuts){\\n        if(i>j) return 0;\\n        int mini=INT_MAX;\\n        for(int ind=i;ind<=j;ind++){\\n            int cost = cuts[j+1] - cuts[i-1] + solve(i, ind-1, cuts) + solve(ind+1, j, cuts);\\n            mini=min(mini, cost);\\n        }\\n        return mini;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        \\n        int c=cuts.size();\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        sort(cuts.begin(),cuts.end());\\n        \\n        return solve(1,c,cuts);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     int solve(int i,int j,vector<int>& cuts,vector<vector<int>> &dp){\\n        if(i>j) return 0;\\n        int mini=INT_MAX;\\n         if(dp[i][j]!=-1)\\n             return dp[i][j];\\n        for(int ind=i;ind<=j;ind++){\\n            int cost = cuts[j+1] - cuts[i-1] + solve(i, ind-1, cuts,dp) + solve(ind+1, j, cuts,dp);\\n            mini=min(mini, cost);\\n        }\\n        return dp[i][j]=mini;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        \\n        int c=cuts.size();\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        sort(cuts.begin(),cuts.end());\\n        vector<vector<int>> dp(c+1,vector<int>(c+1,-1));\\n        \\n        return solve(1,c,cuts,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minCost(int n, vector<int>& cuts) {\\n        \\n        int c=cuts.size();\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(),0);\\n        sort(cuts.begin(),cuts.end());\\n        vector<vector<int>> dp(c+2,vector<int>(c+2,0));\\n        for(int i=c;i>=1;i--){\\n            for(int j=1;j<=c;j++){\\n                if(i>j)\\n                    continue;\\n                int mini=INT_MAX;\\n         \\n                for(int ind=i;ind<=j;ind++){\\n                    int cost = cuts[j+1] - cuts[i-1] + dp[i][ind-1] + dp[ind+1][j];\\n                    mini=min(mini, cost);\\n                }\\n                 dp[i][j]=mini;\\n            }\\n        }\\n        \\n        return dp[1][c];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458793,
                "title": "dp-most-simple-recursive-approach-c",
                "content": "class Solution {\\npublic:\\n    \\n    int find(int s,int e,vector<int>& cuts,vector<vector<int>>& dp){\\n        if(dp[s][e]!=-1) return dp[s][e];\\n        \\n        int temp=INT_MAX;\\n        for(int i=s+1;i<e;i++){\\n            temp=min(temp,cuts[e]-cuts[s]+find(s,i,cuts,dp)+find(i,e,cuts,dp));\\n        }\\n        dp[s][e]=temp;\\n        return temp;\\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) {\\n        vector<int> cut(1,0);\\n        sort(cuts.begin(),cuts.end());\\n        for(int i=0;i<cuts.size();i++){\\n            cut.push_back(cuts[i]);\\n        }\\n        cut.push_back(n);\\n        int n2=cut.size();\\n        vector<vector<int>> dp(cut.size(),vector<int> (cut.size(),-1));\\n        for(int i=0;i+1<n2;i++) dp[i][i+1]=0;\\n        return find(0,n2-1,cut,dp);\\n    }\\n};\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int find(int s,int e,vector<int>& cuts,vector<vector<int>>& dp){\\n        if(dp[s][e]!=-1) return dp[s][e];\\n        \\n        int temp=INT_MAX;\\n        for(int i=s+1;i<e;i++){\\n            temp=min(temp,cuts[e]-cuts[s]+find(s,i,cuts,dp)+find(i,e,cuts,dp));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2448511,
                "title": "c-dp-memoization-tabulation-easy-explanation",
                "content": "/*\\n    Intuition:\\n    \\n    Memoisation:\\n    \\n    Step 1:\\n    Let us consider that the partition array is our cuts array\\n    \\n    Step 2:\\n    We insert first index (0) and last index (n) to this array so that \\n    we shall be able to find the lengths of the current state of the stick at any given left and right ends \\n    \\n    Step 3:\\n    Now, we represent it in terms of indexes, as left and right most ends of stick\\n    \\n    Base Case: if left end goes beyond right ends (Return 0 in this case)\\n    \\n    Step 4: \\n    Now, to explore all possibilities:\\n\\n    All possible partitions in sorted order can be made through a loop of possibilities \\n    to consider all possible partitions at any given stage\\n    \\n    Here, we need to calculate the lengths of both the partitions in summation with current length\\n    i.e. previous cut from right end - previous cut from left end\\n    \\n    Step 5:\\n    Find the minimum of all this\\n    and store in our dp array for current combination of i, j\\n    and return it\\n    \\n    \\n    Tabulation:\\n    \\n    We simply use the memoization to write tabulation\\n    \\n    Step 1:\\n    Copy the base case (Basically initialise the dp array of size (m+2, m+2) with all 0s)\\n    because we added two values, i.e. 0 and n to our partition array\\n    \\n    Step 2:\\n    Move from bottom to up, i.e. consider that we reached the last case, i.e. i = m\\n    and j is at 1 and traverse for each possible combination\\n    \\n    Step 3:\\n    Now, from i to j (inclusive) put partition and calculate the cost for each side followed by considering the minimum cost\\n    \\n    Step 4: \\n    Return your answer stored at 1, m because cuts actual size was m and 0th index doesn\\'t belong to the cuts vector\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    int memSoln(int i, int j, vector<int> &cuts, vector<vector<int>> &dp)\\n    {\\n        if(i > j)\\n            return 0;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int ans = 1e9;\\n        for(int k = i; k <= j; k++)\\n            ans = min(ans,  memSoln(i, k-1, cuts, dp) + memSoln(k+1, j, cuts, dp) + cuts[j+1] - cuts[i-1]);         \\n\\n        return dp[i][j] = ans;\\n    }\\n    \\n    int tabulation(int n, int m, vector<int> &cuts)\\n    {\\n        vector<vector<int>> dp(m+2, vector<int>(m+2, 0));\\n        \\n        for(int i = m; i >= 1; i--)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                if(i <= j) \\n                {\\n                    int ans = 1e9;\\n                    for(int k = i; k <= j; k++)\\n                        ans = min(ans,  dp[i][k-1] + dp[k+1][j] + cuts[j+1] - cuts[i-1]);         \\n\\n                    dp[i][j] = ans;\\n                }\\n            }\\n        }\\n        \\n        // for(int i = 0; i < m+2; i++)\\n        // {\\n        //     for(int j = 0; j < m+2; j++)\\n        //         cout<<dp[i][j]<<\" \";\\n        //     cout<<endl;\\n        // }\\n        \\n        return dp[1][m];\\n    }\\n    \\n    int minCost(int n, vector<int>& cuts) \\n    {\\n        int m = cuts.size();\\n        cuts.push_back(n);\\n        cuts.insert(cuts.begin(), 0);\\n        sort(cuts.begin(), cuts.end());\\n        \\n        // vector<vector<int>> dp(101, vector<int>(101, -1));\\n        // return memSoln(1, m, cuts, dp);\\n        \\n        return tabulation(n, m, cuts);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int memSoln(int i, int j, vector<int> &cuts, vector<vector<int>> &dp)\\n    {\\n        if(i > j)\\n            return 0;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int ans = 1e9;\\n        for(int k = i; k <= j; k++)\\n            ans = min(ans,  memSoln(i, k-1, cuts, dp) + memSoln(k+1, j, cuts, dp) + cuts[j+1] - cuts[i-1]);         \\n\\n        return dp[i][j] = ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2418743,
                "title": "simple-code-c-recurssion-with-memorization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int>mp;\\n    int minCost(int n, vector<int>& cuts) {\\n        \\n        int start=0;\\n        int end=n;\\n        \\n        int left=0;\\n        int right=cuts.size()-1;\\n        \\n        sort(cuts.begin(),cuts.end());   \\n        \\n        return fun(cuts,start,end,left,right);\\n    }\\n    int fun(vector<int>&cuts,int start,int end,int left,int right)\\n    {\\n        if(left>right)  \\n        {\\n            return 0;\\n        }\\n        if(mp.find(make_pair(start,end))!=mp.end())   \\n        {\\n            return mp[make_pair(start,end)];\\n        }\\n        int ans=INT_MAX;\\n        \\n        for(int i=left;i<=right;i++)\\n        {\\n            \\n           ans=min(ans,(end-start)+fun(cuts,start,cuts[i],left,i-1)+fun(cuts,cuts[i],end,i+1,right));    \\n        }\\n        return mp[make_pair(start,end)]= ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int>mp;\\n    int minCost(int n, vector<int>& cuts) {\\n        \\n        int start=0;\\n        int end=n;\\n        \\n        int left=0;\\n        int right=cuts.size()-1;\\n        \\n        sort(cuts.begin(),cuts.end());   \\n        \\n        return fun(cuts,start,end,left,right);\\n    }\\n    int fun(vector<int>&cuts,int start,int end,int left,int right)\\n    {\\n        if(left>right)  \\n        {\\n            return 0;\\n        }\\n        if(mp.find(make_pair(start,end))!=mp.end())   \\n        {\\n            return mp[make_pair(start,end)];\\n        }\\n        int ans=INT_MAX;\\n        \\n        for(int i=left;i<=right;i++)\\n        {\\n            \\n           ans=min(ans,(end-start)+fun(cuts,start,cuts[i],left,i-1)+fun(cuts,cuts[i],end,i+1,right));    \\n        }\\n        return mp[make_pair(start,end)]= ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415524,
                "title": "simple-code-c-recurssion-with-memorization-dp",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int cal(vector<vector<int>> &dp,vector<int> &cuts, int st, int en, int left, int right)\\n    {\\n        int mn=INT_MAX;\\n        if(st>en)\\n            return 0;\\n        if(dp[st][en]!=-1)\\n            return dp[st][en];\\n        \\n        for(int i=st;i<=en;i++)\\n        {\\n            mn=min(mn, right-left+cal(dp,cuts, i+1, en, cuts[i], right)+cal(dp,cuts, st, i-1, left, cuts[i]));\\n        }\\n        \\n        return dp[st][en] = mn;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(), cuts.end());\\n        vector<vector<int>> dp(cuts.size(), vector<int> (cuts.size(), -1));\\n        return cal(dp,cuts,0,cuts.size()-1,0,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int cal(vector<vector<int>> &dp,vector<int> &cuts, int st, int en, int left, int right)\\n    {\\n        int mn=INT_MAX;\\n        if(st>en)\\n            return 0;\\n        if(dp[st][en]!=-1)\\n            return dp[st][en];\\n        \\n        for(int i=st;i<=en;i++)\\n        {\\n            mn=min(mn, right-left+cal(dp,cuts, i+1, en, cuts[i], right)+cal(dp,cuts, st, i-1, left, cuts[i]));\\n        }\\n        \\n        return dp[st][en] = mn;\\n    }\\n    int minCost(int n, vector<int>& cuts) {\\n        sort(cuts.begin(), cuts.end());\\n        vector<vector<int>> dp(cuts.size(), vector<int> (cuts.size(), -1));\\n        return cal(dp,cuts,0,cuts.size()-1,0,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1908031,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1908450,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1908570,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1908123,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1908346,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1908937,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1570109,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1570814,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1568415,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1574207,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1908031,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1908450,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1908570,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1908123,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1908346,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1908937,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1570109,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1570814,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1568415,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1574207,
                "content": [
                    {
                        "username": "khe1154",
                        "content": "> You should perform the cuts in order, you can change the order of the cuts as you wish.\\n\\uD83E\\uDD26\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "![I am the order.jpg](https://assets.leetcode.com/users/images/1a3f8333-5c11-42e9-84c3-50f01602e6c8_1685278936.843218.jpeg)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "\"You should perform the cuts in order, you can change the order of the cuts as you wish.\"\\n Did the guy took weeds before writing this problem statement?"
                    },
                    {
                        "username": "mashkoor_123",
                        "content": "epic\\n"
                    },
                    {
                        "username": "venkim",
                        "content": "Those two statements - how did all these people reconcile the two and go on. Will the problem formulator change the text after all these comments??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nWe need to reorder the cuts in such a way that total cost is minimum. If we have to make a total of $cn$ ($cn = cuts.length$) cuts, then we need to decide which is the first cut out of those $cn$. Brute force can be to make every cut as the first cut and go further.\n\n# Hint 2\nSo, for every $0 \\le i < cn$, make $cuts[i]$ as the first cut. Cost for this will be $n$ (stick length).\n![image.png](https://assets.leetcode.com/users/images/b98e652e-fa23-4f6d-b166-371c298b883a_1685256963.0648935.png)\nNow we will have two sticks of lengths $(cuts[i] - 0)$ and $(n - cuts[i])$.\n\n# Hint 3\nNow, to make the second cut, we can choose any one of the two sticks because their cost will be dependent on only their length. It is the same problem but with smaller stick length. And we have to reorder all the cuts that are to be made on first smaller stick ($0 ... cuts[i]$). And similarly reorder the cuts for the second smaller stick ($cuts[i]...n$).\nTherefore, sorting the $cuts$ might be better so that we can get all the cuts of first smaller stick on the left of $cuts[i]$ and all the cuts of second smaller stick on the right of $cuts[i]$.\n\n# Hint 4\nLet's say we made two cuts as $cuts[i]$ and $cuts[j]$, and now left with the stick in between them ($cuts[i]...cuts[j]$). Let's denote the cost of this stick as $f(i, j)$.\n![image.png](https://assets.leetcode.com/users/images/69fe281f-f237-4706-af30-57b1f489b7e3_1685258382.4234831.png)\nInitially, there were no cuts so we can assume two boundaries as two cuts, $i=0$ and $j=n$. Add these two cuts in $cuts$ array, sort them and call $f(0, cuts.length - 1)$.\n\n# Hint 5\nFor every cut $cuts[x]$ ($i < x < j$) that is present in the stick $cuts[i]...cuts[j]$, make it the first cut with cost as current length $cuts[j] - cuts[i]$. \n![image.png](https://assets.leetcode.com/users/images/d7e0bd2a-5f7f-47ea-b1b3-4c262c429149_1685259059.9072826.png)\nWe will be left with two smaller sticks $(cuts[i]...cuts[x])$ and $(cuts[x]...cuts[j])$. Calculate cost of these two sticks by calling $f(i, x)$ and $f(x, j)$. The final cost will be the cost of the first cut plus cost of two smaller sticks. $f(i, j) = (cuts[j] - cuts[i]) + f(i, x) + f(x, j)$.\nDo this for every $x$, making it the first cut and take minimum of them.\n$f(i, j) = (cuts[j] - cuts[i]) + \\displaystyle\\min_{i < x < j} f(i, x) + f(x, j)$\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "dark_ethics",
                        "content": "[@tonybuidn](/tonybuidn) @tonybuidn Sorry to say but , the \"first of all \" prefix in you reply seems you are very unthankful and egoist ."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@tonybuidn](/tonybuidn) We don\\'t have to choose the next second cut, we can get it via recursion. The second cut of current stick (current problem) is same as the first cut of smaller stick (subproblem). Therefore choose for only first cut and call for recursion on smaller sticks for further cuts."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "First of all, your hints are helpful when we want to figure out the way to solve this problem. However, there is one important point in your way that need to be added that is when we split the length by deciding which point that to be cut, how can we choose the next second cut with the rest of cuts that are provided for us."
                    },
                    {
                        "username": "wf5432",
                        "content": "Greedy algorithm _just won't cut it_."
                    },
                    {
                        "username": "saurabh09700",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\n\\nWhat does this even mean?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Same thoughts...I also thought wth is even that. A better sentence would be just \"you can cut the sticks in whatever order but the points on which the stick is cut should be those given in cuts array \""
                    },
                    {
                        "username": "tonybuidn",
                        "content": "it means that, when providing to you order [1,2] you can cut first point , then second point or you are able to cut second point first then first point. The description in this problem makes confused when describing that."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s just badly written. It basically means we can perform cuts in any order."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "I am also trying to figure this out. I think it means that we can rearrange the cuts array and do the cuts in any order we want to minimize the cost."
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "ferdinand069",
                        "content": "Can anyone explain why greedy would not work for this problem ?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@prathmesh_24](/prathmesh_24) redpilled"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@prathmesh_24](/prathmesh_24) You deffo do not get chicks bro. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "[@prathmesh_24](/prathmesh_24) you cringe af bro"
                    },
                    {
                        "username": "Arshy_2807",
                        "content": "I was also thinking about a greedy approach. I thought of making the cut on the rod which is closest to the center of remaining rod and the rod on the left and right to the cut will be a subproblem to the same problem. Why can\\'t this be a solution?"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "[@prathmesh_24](/prathmesh_24) apart from that anecdote ... isnt that the whole premise of a greedy algorithm? you arent guaranteed to find the optimally best solution, but often end up with one that is good enough  "
                    },
                    {
                        "username": "gabrielss",
                        "content": "[@prathmesh_24](/prathmesh_24) that\\'s cringe bro"
                    },
                    {
                        "username": "SyntaxError4050",
                        "content": "Greedy doesn\\'t guarantee Optimized Solution"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "If we starting selection based upon greedy approach we might miss out the best scenario in future. Think of it as an analogy with our lives, if we prefer Movies/holidays/class bunks over stuudy we might miss out good things which were we supposed to get in future. Do you agree?"
                    },
                    {
                        "username": "Blatogh",
                        "content": "![image](https://assets.leetcode.com/users/images/fb7e015e-e822-44e0-9052-7fae62fd3300_1646640898.965486.jpeg)\\n"
                    },
                    {
                        "username": "ms232gg",
                        "content": "great explanation, thanks"
                    },
                    {
                        "username": "hqztrue",
                        "content": "...which has an O(m log m) solution. See [Garsia\\u2013Wachs algorithm](https://en.wikipedia.org/wiki/Garsia%E2%80%93Wachs_algorithm). Here m is the number of cuts."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How?"
                    },
                    {
                        "username": "user37011",
                        "content": "Is it true that by finding middle element(or nearest to middle using a set) we can partition our stick efficiently?\\nFor ex for n=7\\ncuts[1,3,4,5]\\nmiddle is 3 so we make a cut\\nnow we have two sub-problems n=3[0 to 3] and n=4[3 to 7]\\nsimilarily we make cut on 1 for left half and first on 5 for right half followed by 4.\\n[3,1,5,4]=16$"
                    },
                    {
                        "username": "Jameszc",
                        "content": "[@udhy](/udhy) Isn\\'t the optimal cut 5 though?"
                    },
                    {
                        "username": "muRn_",
                        "content": "This was my first strategy but unfortunately it doesn't hold well. In general yes, you may aim for the middle, but there are cases when the cutpoint closest to the middle gives you pretty low score but then it's neighbor that is a little further from the middle gives even lower score. In one of test cases cutpoint with the lowest score is 12th (sic!) counting from the middle"
                    },
                    {
                        "username": "asmund20",
                        "content": "[@udhy](/udhy) Pretty sure user37011 meant cutting at the cut location closest to the middle of the stick, which would be 5 in your example. I was also considering this. Seems unlikely given the question is hard and it is dp week and all. Edited to clarify which case I was talking about and fix a typo."
                    },
                    {
                        "username": "udhy",
                        "content": "Not really, try considering an infinitely long array. The middle partition won\\'t work:\\n\\nIf n = 10^6 [1,3,4,5] means optimal cut should be at 5."
                    }
                ]
            },
            {
                "id": 1908771,
                "content": [
                    {
                        "username": "IgorPykhtin",
                        "content": "The week of hard problems marked as Medium and medium problems marked as Hard."
                    },
                    {
                        "username": "jschroe212",
                        "content": "I came here looking for this comment 😂"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "who the hell would calculate that as cost in real life?"
                    },
                    {
                        "username": "tushar_mse",
                        "content": "/* why this code is giving MLE */ \\nclass  Solution {\\npublic:\\n\\nint recur(vector<int> &A, int start, int end, vector<vector<int>>&dp)\\n{\\n    \\n     if(start>=end)\\n    {return 0;}\\n    \\n    if(start>=A[A.size()-1])\\n    {return 0;}\\n    if(end<=A[0])\\n    {return 0;}\\n    if(dp[start][end]!=-1)\\n    {return dp[start][end];}\\n\\n    int ans=INT_MAX;\\n    for(int i=0;i<A.size();i++)\\n    {\\n        \\n        if(A[i]>start and A[i]<end)\\n        ans=min(ans,end-start+recur(A,start,A[i],dp)+recur(A,A[i],end,dp));\\n        \\n    }\\n    int fin=0;\\n    if(ans!=INT_MAX)\\n     fin=ans;\\n\\nreturn dp[start][end]=fin;\\n}\\n\\n\\n    int minCost(int n, vector<int>& cuts) \\n    {\\n        sort(cuts.begin(),cuts.end());\\n    vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n    return recur(cuts,0,n,dp);    \\n    }\\n};"
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will  need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the same issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "lixuanji",
                        "content": "https://github.com/stevenhalim/cpbook-code/blob/master/ch3/dp/UVa10003_knuth_td.cpp"
                    },
                    {
                        "username": "aniket_4971",
                        "content": "Memory Limit Exceeded :(\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In the 100/100 test case i am getting memory limit exceeded and in the input it is showing blank like n= .\\nwhat can be the issue "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I had this with TLE a couple days ago, and I have seen a couple other people report this as well. Generally LC responds that the error is correct, the output given is just not user friendly, so I\\'d assume the memory exception is valid and you need to rewrite your code to use less memory. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tough weekend. Again**"
                    },
                    {
                        "username": "timothygao8710",
                        "content": "N is 10^6 so how does a N^3 solution not time out? During the contest I thought you had to use an O(N) greedy solution."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "Because the N that we are considering in N^3 is the length of the cuts array, which has a maximum value of 100, and not the n passed in the function"
                    },
                    {
                        "username": "sk4142",
                        "content": "Very similar to 312. Burst Balloons"
                    },
                    {
                        "username": "srinath-ns",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\nBruh."
                    }
                ]
            },
            {
                "id": 1908453,
                "content": [
                    {
                        "username": "IgorPykhtin",
                        "content": "The week of hard problems marked as Medium and medium problems marked as Hard."
                    },
                    {
                        "username": "jschroe212",
                        "content": "I came here looking for this comment 😂"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "who the hell would calculate that as cost in real life?"
                    },
                    {
                        "username": "tushar_mse",
                        "content": "/* why this code is giving MLE */ \\nclass  Solution {\\npublic:\\n\\nint recur(vector<int> &A, int start, int end, vector<vector<int>>&dp)\\n{\\n    \\n     if(start>=end)\\n    {return 0;}\\n    \\n    if(start>=A[A.size()-1])\\n    {return 0;}\\n    if(end<=A[0])\\n    {return 0;}\\n    if(dp[start][end]!=-1)\\n    {return dp[start][end];}\\n\\n    int ans=INT_MAX;\\n    for(int i=0;i<A.size();i++)\\n    {\\n        \\n        if(A[i]>start and A[i]<end)\\n        ans=min(ans,end-start+recur(A,start,A[i],dp)+recur(A,A[i],end,dp));\\n        \\n    }\\n    int fin=0;\\n    if(ans!=INT_MAX)\\n     fin=ans;\\n\\nreturn dp[start][end]=fin;\\n}\\n\\n\\n    int minCost(int n, vector<int>& cuts) \\n    {\\n        sort(cuts.begin(),cuts.end());\\n    vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n    return recur(cuts,0,n,dp);    \\n    }\\n};"
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will  need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the same issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "lixuanji",
                        "content": "https://github.com/stevenhalim/cpbook-code/blob/master/ch3/dp/UVa10003_knuth_td.cpp"
                    },
                    {
                        "username": "aniket_4971",
                        "content": "Memory Limit Exceeded :(\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In the 100/100 test case i am getting memory limit exceeded and in the input it is showing blank like n= .\\nwhat can be the issue "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I had this with TLE a couple days ago, and I have seen a couple other people report this as well. Generally LC responds that the error is correct, the output given is just not user friendly, so I\\'d assume the memory exception is valid and you need to rewrite your code to use less memory. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tough weekend. Again**"
                    },
                    {
                        "username": "timothygao8710",
                        "content": "N is 10^6 so how does a N^3 solution not time out? During the contest I thought you had to use an O(N) greedy solution."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "Because the N that we are considering in N^3 is the length of the cuts array, which has a maximum value of 100, and not the n passed in the function"
                    },
                    {
                        "username": "sk4142",
                        "content": "Very similar to 312. Burst Balloons"
                    },
                    {
                        "username": "srinath-ns",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\nBruh."
                    }
                ]
            },
            {
                "id": 1681476,
                "content": [
                    {
                        "username": "IgorPykhtin",
                        "content": "The week of hard problems marked as Medium and medium problems marked as Hard."
                    },
                    {
                        "username": "jschroe212",
                        "content": "I came here looking for this comment 😂"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "who the hell would calculate that as cost in real life?"
                    },
                    {
                        "username": "tushar_mse",
                        "content": "/* why this code is giving MLE */ \\nclass  Solution {\\npublic:\\n\\nint recur(vector<int> &A, int start, int end, vector<vector<int>>&dp)\\n{\\n    \\n     if(start>=end)\\n    {return 0;}\\n    \\n    if(start>=A[A.size()-1])\\n    {return 0;}\\n    if(end<=A[0])\\n    {return 0;}\\n    if(dp[start][end]!=-1)\\n    {return dp[start][end];}\\n\\n    int ans=INT_MAX;\\n    for(int i=0;i<A.size();i++)\\n    {\\n        \\n        if(A[i]>start and A[i]<end)\\n        ans=min(ans,end-start+recur(A,start,A[i],dp)+recur(A,A[i],end,dp));\\n        \\n    }\\n    int fin=0;\\n    if(ans!=INT_MAX)\\n     fin=ans;\\n\\nreturn dp[start][end]=fin;\\n}\\n\\n\\n    int minCost(int n, vector<int>& cuts) \\n    {\\n        sort(cuts.begin(),cuts.end());\\n    vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n    return recur(cuts,0,n,dp);    \\n    }\\n};"
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will  need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the same issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "lixuanji",
                        "content": "https://github.com/stevenhalim/cpbook-code/blob/master/ch3/dp/UVa10003_knuth_td.cpp"
                    },
                    {
                        "username": "aniket_4971",
                        "content": "Memory Limit Exceeded :(\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In the 100/100 test case i am getting memory limit exceeded and in the input it is showing blank like n= .\\nwhat can be the issue "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I had this with TLE a couple days ago, and I have seen a couple other people report this as well. Generally LC responds that the error is correct, the output given is just not user friendly, so I\\'d assume the memory exception is valid and you need to rewrite your code to use less memory. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tough weekend. Again**"
                    },
                    {
                        "username": "timothygao8710",
                        "content": "N is 10^6 so how does a N^3 solution not time out? During the contest I thought you had to use an O(N) greedy solution."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "Because the N that we are considering in N^3 is the length of the cuts array, which has a maximum value of 100, and not the n passed in the function"
                    },
                    {
                        "username": "sk4142",
                        "content": "Very similar to 312. Burst Balloons"
                    },
                    {
                        "username": "srinath-ns",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\nBruh."
                    }
                ]
            },
            {
                "id": 1568414,
                "content": [
                    {
                        "username": "IgorPykhtin",
                        "content": "The week of hard problems marked as Medium and medium problems marked as Hard."
                    },
                    {
                        "username": "jschroe212",
                        "content": "I came here looking for this comment 😂"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "who the hell would calculate that as cost in real life?"
                    },
                    {
                        "username": "tushar_mse",
                        "content": "/* why this code is giving MLE */ \\nclass  Solution {\\npublic:\\n\\nint recur(vector<int> &A, int start, int end, vector<vector<int>>&dp)\\n{\\n    \\n     if(start>=end)\\n    {return 0;}\\n    \\n    if(start>=A[A.size()-1])\\n    {return 0;}\\n    if(end<=A[0])\\n    {return 0;}\\n    if(dp[start][end]!=-1)\\n    {return dp[start][end];}\\n\\n    int ans=INT_MAX;\\n    for(int i=0;i<A.size();i++)\\n    {\\n        \\n        if(A[i]>start and A[i]<end)\\n        ans=min(ans,end-start+recur(A,start,A[i],dp)+recur(A,A[i],end,dp));\\n        \\n    }\\n    int fin=0;\\n    if(ans!=INT_MAX)\\n     fin=ans;\\n\\nreturn dp[start][end]=fin;\\n}\\n\\n\\n    int minCost(int n, vector<int>& cuts) \\n    {\\n        sort(cuts.begin(),cuts.end());\\n    vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n    return recur(cuts,0,n,dp);    \\n    }\\n};"
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will  need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the same issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "lixuanji",
                        "content": "https://github.com/stevenhalim/cpbook-code/blob/master/ch3/dp/UVa10003_knuth_td.cpp"
                    },
                    {
                        "username": "aniket_4971",
                        "content": "Memory Limit Exceeded :(\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In the 100/100 test case i am getting memory limit exceeded and in the input it is showing blank like n= .\\nwhat can be the issue "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I had this with TLE a couple days ago, and I have seen a couple other people report this as well. Generally LC responds that the error is correct, the output given is just not user friendly, so I\\'d assume the memory exception is valid and you need to rewrite your code to use less memory. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tough weekend. Again**"
                    },
                    {
                        "username": "timothygao8710",
                        "content": "N is 10^6 so how does a N^3 solution not time out? During the contest I thought you had to use an O(N) greedy solution."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "Because the N that we are considering in N^3 is the length of the cuts array, which has a maximum value of 100, and not the n passed in the function"
                    },
                    {
                        "username": "sk4142",
                        "content": "Very similar to 312. Burst Balloons"
                    },
                    {
                        "username": "srinath-ns",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\nBruh."
                    }
                ]
            },
            {
                "id": 1956652,
                "content": [
                    {
                        "username": "IgorPykhtin",
                        "content": "The week of hard problems marked as Medium and medium problems marked as Hard."
                    },
                    {
                        "username": "jschroe212",
                        "content": "I came here looking for this comment 😂"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "who the hell would calculate that as cost in real life?"
                    },
                    {
                        "username": "tushar_mse",
                        "content": "/* why this code is giving MLE */ \\nclass  Solution {\\npublic:\\n\\nint recur(vector<int> &A, int start, int end, vector<vector<int>>&dp)\\n{\\n    \\n     if(start>=end)\\n    {return 0;}\\n    \\n    if(start>=A[A.size()-1])\\n    {return 0;}\\n    if(end<=A[0])\\n    {return 0;}\\n    if(dp[start][end]!=-1)\\n    {return dp[start][end];}\\n\\n    int ans=INT_MAX;\\n    for(int i=0;i<A.size();i++)\\n    {\\n        \\n        if(A[i]>start and A[i]<end)\\n        ans=min(ans,end-start+recur(A,start,A[i],dp)+recur(A,A[i],end,dp));\\n        \\n    }\\n    int fin=0;\\n    if(ans!=INT_MAX)\\n     fin=ans;\\n\\nreturn dp[start][end]=fin;\\n}\\n\\n\\n    int minCost(int n, vector<int>& cuts) \\n    {\\n        sort(cuts.begin(),cuts.end());\\n    vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n    return recur(cuts,0,n,dp);    \\n    }\\n};"
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will  need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the same issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "lixuanji",
                        "content": "https://github.com/stevenhalim/cpbook-code/blob/master/ch3/dp/UVa10003_knuth_td.cpp"
                    },
                    {
                        "username": "aniket_4971",
                        "content": "Memory Limit Exceeded :(\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In the 100/100 test case i am getting memory limit exceeded and in the input it is showing blank like n= .\\nwhat can be the issue "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I had this with TLE a couple days ago, and I have seen a couple other people report this as well. Generally LC responds that the error is correct, the output given is just not user friendly, so I\\'d assume the memory exception is valid and you need to rewrite your code to use less memory. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tough weekend. Again**"
                    },
                    {
                        "username": "timothygao8710",
                        "content": "N is 10^6 so how does a N^3 solution not time out? During the contest I thought you had to use an O(N) greedy solution."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "Because the N that we are considering in N^3 is the length of the cuts array, which has a maximum value of 100, and not the n passed in the function"
                    },
                    {
                        "username": "sk4142",
                        "content": "Very similar to 312. Burst Balloons"
                    },
                    {
                        "username": "srinath-ns",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\nBruh."
                    }
                ]
            },
            {
                "id": 1908983,
                "content": [
                    {
                        "username": "IgorPykhtin",
                        "content": "The week of hard problems marked as Medium and medium problems marked as Hard."
                    },
                    {
                        "username": "jschroe212",
                        "content": "I came here looking for this comment 😂"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "who the hell would calculate that as cost in real life?"
                    },
                    {
                        "username": "tushar_mse",
                        "content": "/* why this code is giving MLE */ \\nclass  Solution {\\npublic:\\n\\nint recur(vector<int> &A, int start, int end, vector<vector<int>>&dp)\\n{\\n    \\n     if(start>=end)\\n    {return 0;}\\n    \\n    if(start>=A[A.size()-1])\\n    {return 0;}\\n    if(end<=A[0])\\n    {return 0;}\\n    if(dp[start][end]!=-1)\\n    {return dp[start][end];}\\n\\n    int ans=INT_MAX;\\n    for(int i=0;i<A.size();i++)\\n    {\\n        \\n        if(A[i]>start and A[i]<end)\\n        ans=min(ans,end-start+recur(A,start,A[i],dp)+recur(A,A[i],end,dp));\\n        \\n    }\\n    int fin=0;\\n    if(ans!=INT_MAX)\\n     fin=ans;\\n\\nreturn dp[start][end]=fin;\\n}\\n\\n\\n    int minCost(int n, vector<int>& cuts) \\n    {\\n        sort(cuts.begin(),cuts.end());\\n    vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n    return recur(cuts,0,n,dp);    \\n    }\\n};"
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will  need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the same issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "lixuanji",
                        "content": "https://github.com/stevenhalim/cpbook-code/blob/master/ch3/dp/UVa10003_knuth_td.cpp"
                    },
                    {
                        "username": "aniket_4971",
                        "content": "Memory Limit Exceeded :(\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In the 100/100 test case i am getting memory limit exceeded and in the input it is showing blank like n= .\\nwhat can be the issue "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I had this with TLE a couple days ago, and I have seen a couple other people report this as well. Generally LC responds that the error is correct, the output given is just not user friendly, so I\\'d assume the memory exception is valid and you need to rewrite your code to use less memory. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tough weekend. Again**"
                    },
                    {
                        "username": "timothygao8710",
                        "content": "N is 10^6 so how does a N^3 solution not time out? During the contest I thought you had to use an O(N) greedy solution."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "Because the N that we are considering in N^3 is the length of the cuts array, which has a maximum value of 100, and not the n passed in the function"
                    },
                    {
                        "username": "sk4142",
                        "content": "Very similar to 312. Burst Balloons"
                    },
                    {
                        "username": "srinath-ns",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\nBruh."
                    }
                ]
            },
            {
                "id": 1908675,
                "content": [
                    {
                        "username": "IgorPykhtin",
                        "content": "The week of hard problems marked as Medium and medium problems marked as Hard."
                    },
                    {
                        "username": "jschroe212",
                        "content": "I came here looking for this comment 😂"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "who the hell would calculate that as cost in real life?"
                    },
                    {
                        "username": "tushar_mse",
                        "content": "/* why this code is giving MLE */ \\nclass  Solution {\\npublic:\\n\\nint recur(vector<int> &A, int start, int end, vector<vector<int>>&dp)\\n{\\n    \\n     if(start>=end)\\n    {return 0;}\\n    \\n    if(start>=A[A.size()-1])\\n    {return 0;}\\n    if(end<=A[0])\\n    {return 0;}\\n    if(dp[start][end]!=-1)\\n    {return dp[start][end];}\\n\\n    int ans=INT_MAX;\\n    for(int i=0;i<A.size();i++)\\n    {\\n        \\n        if(A[i]>start and A[i]<end)\\n        ans=min(ans,end-start+recur(A,start,A[i],dp)+recur(A,A[i],end,dp));\\n        \\n    }\\n    int fin=0;\\n    if(ans!=INT_MAX)\\n     fin=ans;\\n\\nreturn dp[start][end]=fin;\\n}\\n\\n\\n    int minCost(int n, vector<int>& cuts) \\n    {\\n        sort(cuts.begin(),cuts.end());\\n    vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n    return recur(cuts,0,n,dp);    \\n    }\\n};"
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will  need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the same issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "lixuanji",
                        "content": "https://github.com/stevenhalim/cpbook-code/blob/master/ch3/dp/UVa10003_knuth_td.cpp"
                    },
                    {
                        "username": "aniket_4971",
                        "content": "Memory Limit Exceeded :(\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In the 100/100 test case i am getting memory limit exceeded and in the input it is showing blank like n= .\\nwhat can be the issue "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I had this with TLE a couple days ago, and I have seen a couple other people report this as well. Generally LC responds that the error is correct, the output given is just not user friendly, so I\\'d assume the memory exception is valid and you need to rewrite your code to use less memory. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tough weekend. Again**"
                    },
                    {
                        "username": "timothygao8710",
                        "content": "N is 10^6 so how does a N^3 solution not time out? During the contest I thought you had to use an O(N) greedy solution."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "Because the N that we are considering in N^3 is the length of the cuts array, which has a maximum value of 100, and not the n passed in the function"
                    },
                    {
                        "username": "sk4142",
                        "content": "Very similar to 312. Burst Balloons"
                    },
                    {
                        "username": "srinath-ns",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\nBruh."
                    }
                ]
            },
            {
                "id": 1574186,
                "content": [
                    {
                        "username": "IgorPykhtin",
                        "content": "The week of hard problems marked as Medium and medium problems marked as Hard."
                    },
                    {
                        "username": "jschroe212",
                        "content": "I came here looking for this comment 😂"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "who the hell would calculate that as cost in real life?"
                    },
                    {
                        "username": "tushar_mse",
                        "content": "/* why this code is giving MLE */ \\nclass  Solution {\\npublic:\\n\\nint recur(vector<int> &A, int start, int end, vector<vector<int>>&dp)\\n{\\n    \\n     if(start>=end)\\n    {return 0;}\\n    \\n    if(start>=A[A.size()-1])\\n    {return 0;}\\n    if(end<=A[0])\\n    {return 0;}\\n    if(dp[start][end]!=-1)\\n    {return dp[start][end];}\\n\\n    int ans=INT_MAX;\\n    for(int i=0;i<A.size();i++)\\n    {\\n        \\n        if(A[i]>start and A[i]<end)\\n        ans=min(ans,end-start+recur(A,start,A[i],dp)+recur(A,A[i],end,dp));\\n        \\n    }\\n    int fin=0;\\n    if(ans!=INT_MAX)\\n     fin=ans;\\n\\nreturn dp[start][end]=fin;\\n}\\n\\n\\n    int minCost(int n, vector<int>& cuts) \\n    {\\n        sort(cuts.begin(),cuts.end());\\n    vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n    return recur(cuts,0,n,dp);    \\n    }\\n};"
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will  need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the same issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "lixuanji",
                        "content": "https://github.com/stevenhalim/cpbook-code/blob/master/ch3/dp/UVa10003_knuth_td.cpp"
                    },
                    {
                        "username": "aniket_4971",
                        "content": "Memory Limit Exceeded :(\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In the 100/100 test case i am getting memory limit exceeded and in the input it is showing blank like n= .\\nwhat can be the issue "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I had this with TLE a couple days ago, and I have seen a couple other people report this as well. Generally LC responds that the error is correct, the output given is just not user friendly, so I\\'d assume the memory exception is valid and you need to rewrite your code to use less memory. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tough weekend. Again**"
                    },
                    {
                        "username": "timothygao8710",
                        "content": "N is 10^6 so how does a N^3 solution not time out? During the contest I thought you had to use an O(N) greedy solution."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "Because the N that we are considering in N^3 is the length of the cuts array, which has a maximum value of 100, and not the n passed in the function"
                    },
                    {
                        "username": "sk4142",
                        "content": "Very similar to 312. Burst Balloons"
                    },
                    {
                        "username": "srinath-ns",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\nBruh."
                    }
                ]
            },
            {
                "id": 2030295,
                "content": [
                    {
                        "username": "IgorPykhtin",
                        "content": "The week of hard problems marked as Medium and medium problems marked as Hard."
                    },
                    {
                        "username": "jschroe212",
                        "content": "I came here looking for this comment 😂"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "who the hell would calculate that as cost in real life?"
                    },
                    {
                        "username": "tushar_mse",
                        "content": "/* why this code is giving MLE */ \\nclass  Solution {\\npublic:\\n\\nint recur(vector<int> &A, int start, int end, vector<vector<int>>&dp)\\n{\\n    \\n     if(start>=end)\\n    {return 0;}\\n    \\n    if(start>=A[A.size()-1])\\n    {return 0;}\\n    if(end<=A[0])\\n    {return 0;}\\n    if(dp[start][end]!=-1)\\n    {return dp[start][end];}\\n\\n    int ans=INT_MAX;\\n    for(int i=0;i<A.size();i++)\\n    {\\n        \\n        if(A[i]>start and A[i]<end)\\n        ans=min(ans,end-start+recur(A,start,A[i],dp)+recur(A,A[i],end,dp));\\n        \\n    }\\n    int fin=0;\\n    if(ans!=INT_MAX)\\n     fin=ans;\\n\\nreturn dp[start][end]=fin;\\n}\\n\\n\\n    int minCost(int n, vector<int>& cuts) \\n    {\\n        sort(cuts.begin(),cuts.end());\\n    vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n    return recur(cuts,0,n,dp);    \\n    }\\n};"
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will  need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the same issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "lixuanji",
                        "content": "https://github.com/stevenhalim/cpbook-code/blob/master/ch3/dp/UVa10003_knuth_td.cpp"
                    },
                    {
                        "username": "aniket_4971",
                        "content": "Memory Limit Exceeded :(\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In the 100/100 test case i am getting memory limit exceeded and in the input it is showing blank like n= .\\nwhat can be the issue "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I had this with TLE a couple days ago, and I have seen a couple other people report this as well. Generally LC responds that the error is correct, the output given is just not user friendly, so I\\'d assume the memory exception is valid and you need to rewrite your code to use less memory. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tough weekend. Again**"
                    },
                    {
                        "username": "timothygao8710",
                        "content": "N is 10^6 so how does a N^3 solution not time out? During the contest I thought you had to use an O(N) greedy solution."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "Because the N that we are considering in N^3 is the length of the cuts array, which has a maximum value of 100, and not the n passed in the function"
                    },
                    {
                        "username": "sk4142",
                        "content": "Very similar to 312. Burst Balloons"
                    },
                    {
                        "username": "srinath-ns",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\nBruh."
                    }
                ]
            },
            {
                "id": 2023828,
                "content": [
                    {
                        "username": "IgorPykhtin",
                        "content": "The week of hard problems marked as Medium and medium problems marked as Hard."
                    },
                    {
                        "username": "jschroe212",
                        "content": "I came here looking for this comment 😂"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "who the hell would calculate that as cost in real life?"
                    },
                    {
                        "username": "tushar_mse",
                        "content": "/* why this code is giving MLE */ \\nclass  Solution {\\npublic:\\n\\nint recur(vector<int> &A, int start, int end, vector<vector<int>>&dp)\\n{\\n    \\n     if(start>=end)\\n    {return 0;}\\n    \\n    if(start>=A[A.size()-1])\\n    {return 0;}\\n    if(end<=A[0])\\n    {return 0;}\\n    if(dp[start][end]!=-1)\\n    {return dp[start][end];}\\n\\n    int ans=INT_MAX;\\n    for(int i=0;i<A.size();i++)\\n    {\\n        \\n        if(A[i]>start and A[i]<end)\\n        ans=min(ans,end-start+recur(A,start,A[i],dp)+recur(A,A[i],end,dp));\\n        \\n    }\\n    int fin=0;\\n    if(ans!=INT_MAX)\\n     fin=ans;\\n\\nreturn dp[start][end]=fin;\\n}\\n\\n\\n    int minCost(int n, vector<int>& cuts) \\n    {\\n        sort(cuts.begin(),cuts.end());\\n    vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n    return recur(cuts,0,n,dp);    \\n    }\\n};"
                    },
                    {
                        "username": "Aswin-Sk",
                        "content": "when n is huge the vector dp will  need so much space, but most of it is wasted as the cuts can only come in each of element of cuts and not in every n. I had the same issue of memory limit exceeded and I fixed it by changing dp from a vector to a map"
                    },
                    {
                        "username": "lixuanji",
                        "content": "https://github.com/stevenhalim/cpbook-code/blob/master/ch3/dp/UVa10003_knuth_td.cpp"
                    },
                    {
                        "username": "aniket_4971",
                        "content": "Memory Limit Exceeded :(\\n"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "In the 100/100 test case i am getting memory limit exceeded and in the input it is showing blank like n= .\\nwhat can be the issue "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I had this with TLE a couple days ago, and I have seen a couple other people report this as well. Generally LC responds that the error is correct, the output given is just not user friendly, so I\\'d assume the memory exception is valid and you need to rewrite your code to use less memory. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Tough weekend. Again**"
                    },
                    {
                        "username": "timothygao8710",
                        "content": "N is 10^6 so how does a N^3 solution not time out? During the contest I thought you had to use an O(N) greedy solution."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "Because the N that we are considering in N^3 is the length of the cuts array, which has a maximum value of 100, and not the n passed in the function"
                    },
                    {
                        "username": "sk4142",
                        "content": "Very similar to 312. Burst Balloons"
                    },
                    {
                        "username": "srinath-ns",
                        "content": "`You should perform the cuts in order, you can change the order of the cuts as you wish.`\\nBruh."
                    }
                ]
            },
            {
                "id": 1991216,
                "content": [
                    {
                        "username": "yash121001",
                        "content": "Why can\\'t we in test case 1 we cut it like [5,4,3,1]?? We can get minimum answer by this??Correct me if I am wrong"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Partition DP"
                    },
                    {
                        "username": "Msey",
                        "content": "so, should we do cuts in any order? :D"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "well, this is not hard. We\\'ve had mediums twice more difficult just about 10 days ago"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "I have a question but it isn\\'t related to the problem.\\nI solved all the problems of May till today, but when I check the badges I don\\'t see May badge loading. is it okay or there is a problem?"
                    },
                    {
                        "username": "namandt",
                        "content": "let May month complete"
                    },
                    {
                        "username": "Youlian",
                        "content": "where stones"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Somehow I\\'m getting Memory Limit Exceeded for this test case. Can someone please help.\\n```\\n8100\\n[2101,3454,6088,5298,4727,6791,5538,305,3628,841,6007,7913,1621,1436,4022,908,7217,1099,1169,1787,383,7367,8046,2888,5465,6669,1660,2856,6771,4263,1782,6833,448,2792,1104,2342,1100,4378,252,2806,5104,1513,6115,388,4555,276,5214,5934,5749,7660,4590,3885,1052,4876,4144,4489,3945,2823,364,1324,4227,3764]\\n```\\n\\nCode\\n```\\nclass Solution {\\n\\n    private int util(int i, int j, int[] cuts, int[][] dp) {\\n        if (i>=j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int min = Integer.MAX_VALUE;\\n        for (int k=0; k<cuts.length; k++) {\\n            if (cuts[k]>=i && cuts[k]<j) {\\n                int value = util(i, cuts[k], cuts, dp);\\n                value += util(cuts[k]+1, j, cuts, dp);\\n                min = Math.min(min, value);\\n            }\\n        }\\n        return dp[i][j] = min == Integer.MAX_VALUE ? 0 : min + (j-i+1);\\n    }\\n\\n    public int minCost(int n, int[] cuts) {\\n        int[][] dp = new int[n+1][n+1];\\n        for (int i=0; i<=n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return util(1, n, cuts, dp);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "[@Hritik__k](/Hritik__k) sure will check thanks"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try using map as dp instead of dp matrix or bottom up method .i.e non recurcsive one i also had the same problem or if you  want take u forward(youtube) have given very good explanation for this problem "
                    },
                    {
                        "username": "purvi_jha",
                        "content": "class Solution {\\npublic:\\n    int rec(vector<int>& cuts, vector<int>&part){\\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<cuts.size();i++){\\n            if(cuts[i]!=-1){\\n                int an=0;\\n                int temp=cuts[i];\\n                vector<int>inpar=part;\\n\\n                for(int j=0;j<part.size();j++){\\n                    int end=part[j];\\n\\n                    if(end>temp){\\n                        an+=end-j;\\n\\n                        part[j]=temp;\\n                        part[temp]=end;\\n\\n                        break;\\n                    }\\n                }\\n                \\n                cuts[i]=-1;\\n\\n                an+=rec(cuts,part);\\n\\n                ans=min(ans,an);\\n                cuts[i]=temp;\\n                part=inpar;\\n            }\\n        }\\n\\n        return ans==INT_MAX ? 0 : ans;\\n    }\\n\\n    int minCost(int n, vector<int>& cuts){\\n        vector<int>part(n+1,-1);\\n        part[0]=n;\\n\\n        return rec(cuts,part);\\n    }\\n};\\n\\nCan anyone help me in memoizing it\\n"
                    },
                    {
                        "username": "NOT_SOL",
                        "content": "can we do it with a greedy approach ??\\n( not a solution )  just an approach, if some one could come up with it lemme know.\\nclass Solution {\\npublic:\\n    // int dp[1e6+5][1e6+5];\\n    int minCost(int n, vector<int>& cuts,int ans=0) {\\n        // if(n-mid<0) return 0;\\n        if(cuts.size()==0){\\n            return 0;\\n        }\\n        if(cuts.size()==1){\\n            return n;\\n        }\\n        sort(cuts.begin(),cuts.end());\\n        int mid=n+1;\\n        int lol=n/2;\\n        int ii=cuts[0];\\n        cout<<cuts.size()<<n<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            cout<<\"->\"<<cuts[i];\\n            if(mid>=abs(n/2-cuts[i]) && (cuts.size()<=4 ||(cuts.size()-i-1)>=1 && i>1)){\\n                // lol=abs(cuts.size());\\n                mid=abs(n/2-cuts[i]);\\n                ii=cuts[i];\\n            }\\n\\n            // mid=min(mid,abs(n/2-cuts[i]));\\n        }\\n        cout<<endl;\\n        mid=ii;\\n        ans+=n;\\n        cout<<\"lolololololololololo\"<<endl<<mid<<endl;\\n        vector<int> n1,n2;\\n        cout<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            \\n            if(cuts[i]<mid){\\n                n1.push_back(cuts[i]);\\n                continue;\\n            }\\n            else if(cuts[i]>mid){\\n                n2.push_back(cuts[i]-mid);\\n                continue;\\n            }\\n            cout<<cuts[i];\\n        }\\n        cout<<endl<<endl<<endl<<mid;;\\n        for(auto c:n1){\\n            cout<<c;\\n        }\\n        cout<<endl<<n-mid;;\\n        for(auto c:n2){\\n            cout<<c;\\n        }\\n        if(n1.size()!=0)\\n        ans+=minCost(mid,n1);\\n        if(n2.size()!=0)\\n        ans+=minCost(n-mid,n2);\\n        cout<<\"ans\"<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bejinipramod",
                        "content": "i guess we can use binary search? right?"
                    }
                ]
            },
            {
                "id": 1926187,
                "content": [
                    {
                        "username": "yash121001",
                        "content": "Why can\\'t we in test case 1 we cut it like [5,4,3,1]?? We can get minimum answer by this??Correct me if I am wrong"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Partition DP"
                    },
                    {
                        "username": "Msey",
                        "content": "so, should we do cuts in any order? :D"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "well, this is not hard. We\\'ve had mediums twice more difficult just about 10 days ago"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "I have a question but it isn\\'t related to the problem.\\nI solved all the problems of May till today, but when I check the badges I don\\'t see May badge loading. is it okay or there is a problem?"
                    },
                    {
                        "username": "namandt",
                        "content": "let May month complete"
                    },
                    {
                        "username": "Youlian",
                        "content": "where stones"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Somehow I\\'m getting Memory Limit Exceeded for this test case. Can someone please help.\\n```\\n8100\\n[2101,3454,6088,5298,4727,6791,5538,305,3628,841,6007,7913,1621,1436,4022,908,7217,1099,1169,1787,383,7367,8046,2888,5465,6669,1660,2856,6771,4263,1782,6833,448,2792,1104,2342,1100,4378,252,2806,5104,1513,6115,388,4555,276,5214,5934,5749,7660,4590,3885,1052,4876,4144,4489,3945,2823,364,1324,4227,3764]\\n```\\n\\nCode\\n```\\nclass Solution {\\n\\n    private int util(int i, int j, int[] cuts, int[][] dp) {\\n        if (i>=j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int min = Integer.MAX_VALUE;\\n        for (int k=0; k<cuts.length; k++) {\\n            if (cuts[k]>=i && cuts[k]<j) {\\n                int value = util(i, cuts[k], cuts, dp);\\n                value += util(cuts[k]+1, j, cuts, dp);\\n                min = Math.min(min, value);\\n            }\\n        }\\n        return dp[i][j] = min == Integer.MAX_VALUE ? 0 : min + (j-i+1);\\n    }\\n\\n    public int minCost(int n, int[] cuts) {\\n        int[][] dp = new int[n+1][n+1];\\n        for (int i=0; i<=n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return util(1, n, cuts, dp);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "[@Hritik__k](/Hritik__k) sure will check thanks"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try using map as dp instead of dp matrix or bottom up method .i.e non recurcsive one i also had the same problem or if you  want take u forward(youtube) have given very good explanation for this problem "
                    },
                    {
                        "username": "purvi_jha",
                        "content": "class Solution {\\npublic:\\n    int rec(vector<int>& cuts, vector<int>&part){\\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<cuts.size();i++){\\n            if(cuts[i]!=-1){\\n                int an=0;\\n                int temp=cuts[i];\\n                vector<int>inpar=part;\\n\\n                for(int j=0;j<part.size();j++){\\n                    int end=part[j];\\n\\n                    if(end>temp){\\n                        an+=end-j;\\n\\n                        part[j]=temp;\\n                        part[temp]=end;\\n\\n                        break;\\n                    }\\n                }\\n                \\n                cuts[i]=-1;\\n\\n                an+=rec(cuts,part);\\n\\n                ans=min(ans,an);\\n                cuts[i]=temp;\\n                part=inpar;\\n            }\\n        }\\n\\n        return ans==INT_MAX ? 0 : ans;\\n    }\\n\\n    int minCost(int n, vector<int>& cuts){\\n        vector<int>part(n+1,-1);\\n        part[0]=n;\\n\\n        return rec(cuts,part);\\n    }\\n};\\n\\nCan anyone help me in memoizing it\\n"
                    },
                    {
                        "username": "NOT_SOL",
                        "content": "can we do it with a greedy approach ??\\n( not a solution )  just an approach, if some one could come up with it lemme know.\\nclass Solution {\\npublic:\\n    // int dp[1e6+5][1e6+5];\\n    int minCost(int n, vector<int>& cuts,int ans=0) {\\n        // if(n-mid<0) return 0;\\n        if(cuts.size()==0){\\n            return 0;\\n        }\\n        if(cuts.size()==1){\\n            return n;\\n        }\\n        sort(cuts.begin(),cuts.end());\\n        int mid=n+1;\\n        int lol=n/2;\\n        int ii=cuts[0];\\n        cout<<cuts.size()<<n<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            cout<<\"->\"<<cuts[i];\\n            if(mid>=abs(n/2-cuts[i]) && (cuts.size()<=4 ||(cuts.size()-i-1)>=1 && i>1)){\\n                // lol=abs(cuts.size());\\n                mid=abs(n/2-cuts[i]);\\n                ii=cuts[i];\\n            }\\n\\n            // mid=min(mid,abs(n/2-cuts[i]));\\n        }\\n        cout<<endl;\\n        mid=ii;\\n        ans+=n;\\n        cout<<\"lolololololololololo\"<<endl<<mid<<endl;\\n        vector<int> n1,n2;\\n        cout<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            \\n            if(cuts[i]<mid){\\n                n1.push_back(cuts[i]);\\n                continue;\\n            }\\n            else if(cuts[i]>mid){\\n                n2.push_back(cuts[i]-mid);\\n                continue;\\n            }\\n            cout<<cuts[i];\\n        }\\n        cout<<endl<<endl<<endl<<mid;;\\n        for(auto c:n1){\\n            cout<<c;\\n        }\\n        cout<<endl<<n-mid;;\\n        for(auto c:n2){\\n            cout<<c;\\n        }\\n        if(n1.size()!=0)\\n        ans+=minCost(mid,n1);\\n        if(n2.size()!=0)\\n        ans+=minCost(n-mid,n2);\\n        cout<<\"ans\"<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bejinipramod",
                        "content": "i guess we can use binary search? right?"
                    }
                ]
            },
            {
                "id": 1921596,
                "content": [
                    {
                        "username": "yash121001",
                        "content": "Why can\\'t we in test case 1 we cut it like [5,4,3,1]?? We can get minimum answer by this??Correct me if I am wrong"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Partition DP"
                    },
                    {
                        "username": "Msey",
                        "content": "so, should we do cuts in any order? :D"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "well, this is not hard. We\\'ve had mediums twice more difficult just about 10 days ago"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "I have a question but it isn\\'t related to the problem.\\nI solved all the problems of May till today, but when I check the badges I don\\'t see May badge loading. is it okay or there is a problem?"
                    },
                    {
                        "username": "namandt",
                        "content": "let May month complete"
                    },
                    {
                        "username": "Youlian",
                        "content": "where stones"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Somehow I\\'m getting Memory Limit Exceeded for this test case. Can someone please help.\\n```\\n8100\\n[2101,3454,6088,5298,4727,6791,5538,305,3628,841,6007,7913,1621,1436,4022,908,7217,1099,1169,1787,383,7367,8046,2888,5465,6669,1660,2856,6771,4263,1782,6833,448,2792,1104,2342,1100,4378,252,2806,5104,1513,6115,388,4555,276,5214,5934,5749,7660,4590,3885,1052,4876,4144,4489,3945,2823,364,1324,4227,3764]\\n```\\n\\nCode\\n```\\nclass Solution {\\n\\n    private int util(int i, int j, int[] cuts, int[][] dp) {\\n        if (i>=j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int min = Integer.MAX_VALUE;\\n        for (int k=0; k<cuts.length; k++) {\\n            if (cuts[k]>=i && cuts[k]<j) {\\n                int value = util(i, cuts[k], cuts, dp);\\n                value += util(cuts[k]+1, j, cuts, dp);\\n                min = Math.min(min, value);\\n            }\\n        }\\n        return dp[i][j] = min == Integer.MAX_VALUE ? 0 : min + (j-i+1);\\n    }\\n\\n    public int minCost(int n, int[] cuts) {\\n        int[][] dp = new int[n+1][n+1];\\n        for (int i=0; i<=n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return util(1, n, cuts, dp);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "[@Hritik__k](/Hritik__k) sure will check thanks"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try using map as dp instead of dp matrix or bottom up method .i.e non recurcsive one i also had the same problem or if you  want take u forward(youtube) have given very good explanation for this problem "
                    },
                    {
                        "username": "purvi_jha",
                        "content": "class Solution {\\npublic:\\n    int rec(vector<int>& cuts, vector<int>&part){\\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<cuts.size();i++){\\n            if(cuts[i]!=-1){\\n                int an=0;\\n                int temp=cuts[i];\\n                vector<int>inpar=part;\\n\\n                for(int j=0;j<part.size();j++){\\n                    int end=part[j];\\n\\n                    if(end>temp){\\n                        an+=end-j;\\n\\n                        part[j]=temp;\\n                        part[temp]=end;\\n\\n                        break;\\n                    }\\n                }\\n                \\n                cuts[i]=-1;\\n\\n                an+=rec(cuts,part);\\n\\n                ans=min(ans,an);\\n                cuts[i]=temp;\\n                part=inpar;\\n            }\\n        }\\n\\n        return ans==INT_MAX ? 0 : ans;\\n    }\\n\\n    int minCost(int n, vector<int>& cuts){\\n        vector<int>part(n+1,-1);\\n        part[0]=n;\\n\\n        return rec(cuts,part);\\n    }\\n};\\n\\nCan anyone help me in memoizing it\\n"
                    },
                    {
                        "username": "NOT_SOL",
                        "content": "can we do it with a greedy approach ??\\n( not a solution )  just an approach, if some one could come up with it lemme know.\\nclass Solution {\\npublic:\\n    // int dp[1e6+5][1e6+5];\\n    int minCost(int n, vector<int>& cuts,int ans=0) {\\n        // if(n-mid<0) return 0;\\n        if(cuts.size()==0){\\n            return 0;\\n        }\\n        if(cuts.size()==1){\\n            return n;\\n        }\\n        sort(cuts.begin(),cuts.end());\\n        int mid=n+1;\\n        int lol=n/2;\\n        int ii=cuts[0];\\n        cout<<cuts.size()<<n<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            cout<<\"->\"<<cuts[i];\\n            if(mid>=abs(n/2-cuts[i]) && (cuts.size()<=4 ||(cuts.size()-i-1)>=1 && i>1)){\\n                // lol=abs(cuts.size());\\n                mid=abs(n/2-cuts[i]);\\n                ii=cuts[i];\\n            }\\n\\n            // mid=min(mid,abs(n/2-cuts[i]));\\n        }\\n        cout<<endl;\\n        mid=ii;\\n        ans+=n;\\n        cout<<\"lolololololololololo\"<<endl<<mid<<endl;\\n        vector<int> n1,n2;\\n        cout<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            \\n            if(cuts[i]<mid){\\n                n1.push_back(cuts[i]);\\n                continue;\\n            }\\n            else if(cuts[i]>mid){\\n                n2.push_back(cuts[i]-mid);\\n                continue;\\n            }\\n            cout<<cuts[i];\\n        }\\n        cout<<endl<<endl<<endl<<mid;;\\n        for(auto c:n1){\\n            cout<<c;\\n        }\\n        cout<<endl<<n-mid;;\\n        for(auto c:n2){\\n            cout<<c;\\n        }\\n        if(n1.size()!=0)\\n        ans+=minCost(mid,n1);\\n        if(n2.size()!=0)\\n        ans+=minCost(n-mid,n2);\\n        cout<<\"ans\"<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bejinipramod",
                        "content": "i guess we can use binary search? right?"
                    }
                ]
            },
            {
                "id": 1909225,
                "content": [
                    {
                        "username": "yash121001",
                        "content": "Why can\\'t we in test case 1 we cut it like [5,4,3,1]?? We can get minimum answer by this??Correct me if I am wrong"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Partition DP"
                    },
                    {
                        "username": "Msey",
                        "content": "so, should we do cuts in any order? :D"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "well, this is not hard. We\\'ve had mediums twice more difficult just about 10 days ago"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "I have a question but it isn\\'t related to the problem.\\nI solved all the problems of May till today, but when I check the badges I don\\'t see May badge loading. is it okay or there is a problem?"
                    },
                    {
                        "username": "namandt",
                        "content": "let May month complete"
                    },
                    {
                        "username": "Youlian",
                        "content": "where stones"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Somehow I\\'m getting Memory Limit Exceeded for this test case. Can someone please help.\\n```\\n8100\\n[2101,3454,6088,5298,4727,6791,5538,305,3628,841,6007,7913,1621,1436,4022,908,7217,1099,1169,1787,383,7367,8046,2888,5465,6669,1660,2856,6771,4263,1782,6833,448,2792,1104,2342,1100,4378,252,2806,5104,1513,6115,388,4555,276,5214,5934,5749,7660,4590,3885,1052,4876,4144,4489,3945,2823,364,1324,4227,3764]\\n```\\n\\nCode\\n```\\nclass Solution {\\n\\n    private int util(int i, int j, int[] cuts, int[][] dp) {\\n        if (i>=j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int min = Integer.MAX_VALUE;\\n        for (int k=0; k<cuts.length; k++) {\\n            if (cuts[k]>=i && cuts[k]<j) {\\n                int value = util(i, cuts[k], cuts, dp);\\n                value += util(cuts[k]+1, j, cuts, dp);\\n                min = Math.min(min, value);\\n            }\\n        }\\n        return dp[i][j] = min == Integer.MAX_VALUE ? 0 : min + (j-i+1);\\n    }\\n\\n    public int minCost(int n, int[] cuts) {\\n        int[][] dp = new int[n+1][n+1];\\n        for (int i=0; i<=n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return util(1, n, cuts, dp);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "[@Hritik__k](/Hritik__k) sure will check thanks"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try using map as dp instead of dp matrix or bottom up method .i.e non recurcsive one i also had the same problem or if you  want take u forward(youtube) have given very good explanation for this problem "
                    },
                    {
                        "username": "purvi_jha",
                        "content": "class Solution {\\npublic:\\n    int rec(vector<int>& cuts, vector<int>&part){\\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<cuts.size();i++){\\n            if(cuts[i]!=-1){\\n                int an=0;\\n                int temp=cuts[i];\\n                vector<int>inpar=part;\\n\\n                for(int j=0;j<part.size();j++){\\n                    int end=part[j];\\n\\n                    if(end>temp){\\n                        an+=end-j;\\n\\n                        part[j]=temp;\\n                        part[temp]=end;\\n\\n                        break;\\n                    }\\n                }\\n                \\n                cuts[i]=-1;\\n\\n                an+=rec(cuts,part);\\n\\n                ans=min(ans,an);\\n                cuts[i]=temp;\\n                part=inpar;\\n            }\\n        }\\n\\n        return ans==INT_MAX ? 0 : ans;\\n    }\\n\\n    int minCost(int n, vector<int>& cuts){\\n        vector<int>part(n+1,-1);\\n        part[0]=n;\\n\\n        return rec(cuts,part);\\n    }\\n};\\n\\nCan anyone help me in memoizing it\\n"
                    },
                    {
                        "username": "NOT_SOL",
                        "content": "can we do it with a greedy approach ??\\n( not a solution )  just an approach, if some one could come up with it lemme know.\\nclass Solution {\\npublic:\\n    // int dp[1e6+5][1e6+5];\\n    int minCost(int n, vector<int>& cuts,int ans=0) {\\n        // if(n-mid<0) return 0;\\n        if(cuts.size()==0){\\n            return 0;\\n        }\\n        if(cuts.size()==1){\\n            return n;\\n        }\\n        sort(cuts.begin(),cuts.end());\\n        int mid=n+1;\\n        int lol=n/2;\\n        int ii=cuts[0];\\n        cout<<cuts.size()<<n<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            cout<<\"->\"<<cuts[i];\\n            if(mid>=abs(n/2-cuts[i]) && (cuts.size()<=4 ||(cuts.size()-i-1)>=1 && i>1)){\\n                // lol=abs(cuts.size());\\n                mid=abs(n/2-cuts[i]);\\n                ii=cuts[i];\\n            }\\n\\n            // mid=min(mid,abs(n/2-cuts[i]));\\n        }\\n        cout<<endl;\\n        mid=ii;\\n        ans+=n;\\n        cout<<\"lolololololololololo\"<<endl<<mid<<endl;\\n        vector<int> n1,n2;\\n        cout<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            \\n            if(cuts[i]<mid){\\n                n1.push_back(cuts[i]);\\n                continue;\\n            }\\n            else if(cuts[i]>mid){\\n                n2.push_back(cuts[i]-mid);\\n                continue;\\n            }\\n            cout<<cuts[i];\\n        }\\n        cout<<endl<<endl<<endl<<mid;;\\n        for(auto c:n1){\\n            cout<<c;\\n        }\\n        cout<<endl<<n-mid;;\\n        for(auto c:n2){\\n            cout<<c;\\n        }\\n        if(n1.size()!=0)\\n        ans+=minCost(mid,n1);\\n        if(n2.size()!=0)\\n        ans+=minCost(n-mid,n2);\\n        cout<<\"ans\"<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bejinipramod",
                        "content": "i guess we can use binary search? right?"
                    }
                ]
            },
            {
                "id": 1909124,
                "content": [
                    {
                        "username": "yash121001",
                        "content": "Why can\\'t we in test case 1 we cut it like [5,4,3,1]?? We can get minimum answer by this??Correct me if I am wrong"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Partition DP"
                    },
                    {
                        "username": "Msey",
                        "content": "so, should we do cuts in any order? :D"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "well, this is not hard. We\\'ve had mediums twice more difficult just about 10 days ago"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "I have a question but it isn\\'t related to the problem.\\nI solved all the problems of May till today, but when I check the badges I don\\'t see May badge loading. is it okay or there is a problem?"
                    },
                    {
                        "username": "namandt",
                        "content": "let May month complete"
                    },
                    {
                        "username": "Youlian",
                        "content": "where stones"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Somehow I\\'m getting Memory Limit Exceeded for this test case. Can someone please help.\\n```\\n8100\\n[2101,3454,6088,5298,4727,6791,5538,305,3628,841,6007,7913,1621,1436,4022,908,7217,1099,1169,1787,383,7367,8046,2888,5465,6669,1660,2856,6771,4263,1782,6833,448,2792,1104,2342,1100,4378,252,2806,5104,1513,6115,388,4555,276,5214,5934,5749,7660,4590,3885,1052,4876,4144,4489,3945,2823,364,1324,4227,3764]\\n```\\n\\nCode\\n```\\nclass Solution {\\n\\n    private int util(int i, int j, int[] cuts, int[][] dp) {\\n        if (i>=j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int min = Integer.MAX_VALUE;\\n        for (int k=0; k<cuts.length; k++) {\\n            if (cuts[k]>=i && cuts[k]<j) {\\n                int value = util(i, cuts[k], cuts, dp);\\n                value += util(cuts[k]+1, j, cuts, dp);\\n                min = Math.min(min, value);\\n            }\\n        }\\n        return dp[i][j] = min == Integer.MAX_VALUE ? 0 : min + (j-i+1);\\n    }\\n\\n    public int minCost(int n, int[] cuts) {\\n        int[][] dp = new int[n+1][n+1];\\n        for (int i=0; i<=n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return util(1, n, cuts, dp);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "[@Hritik__k](/Hritik__k) sure will check thanks"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try using map as dp instead of dp matrix or bottom up method .i.e non recurcsive one i also had the same problem or if you  want take u forward(youtube) have given very good explanation for this problem "
                    },
                    {
                        "username": "purvi_jha",
                        "content": "class Solution {\\npublic:\\n    int rec(vector<int>& cuts, vector<int>&part){\\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<cuts.size();i++){\\n            if(cuts[i]!=-1){\\n                int an=0;\\n                int temp=cuts[i];\\n                vector<int>inpar=part;\\n\\n                for(int j=0;j<part.size();j++){\\n                    int end=part[j];\\n\\n                    if(end>temp){\\n                        an+=end-j;\\n\\n                        part[j]=temp;\\n                        part[temp]=end;\\n\\n                        break;\\n                    }\\n                }\\n                \\n                cuts[i]=-1;\\n\\n                an+=rec(cuts,part);\\n\\n                ans=min(ans,an);\\n                cuts[i]=temp;\\n                part=inpar;\\n            }\\n        }\\n\\n        return ans==INT_MAX ? 0 : ans;\\n    }\\n\\n    int minCost(int n, vector<int>& cuts){\\n        vector<int>part(n+1,-1);\\n        part[0]=n;\\n\\n        return rec(cuts,part);\\n    }\\n};\\n\\nCan anyone help me in memoizing it\\n"
                    },
                    {
                        "username": "NOT_SOL",
                        "content": "can we do it with a greedy approach ??\\n( not a solution )  just an approach, if some one could come up with it lemme know.\\nclass Solution {\\npublic:\\n    // int dp[1e6+5][1e6+5];\\n    int minCost(int n, vector<int>& cuts,int ans=0) {\\n        // if(n-mid<0) return 0;\\n        if(cuts.size()==0){\\n            return 0;\\n        }\\n        if(cuts.size()==1){\\n            return n;\\n        }\\n        sort(cuts.begin(),cuts.end());\\n        int mid=n+1;\\n        int lol=n/2;\\n        int ii=cuts[0];\\n        cout<<cuts.size()<<n<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            cout<<\"->\"<<cuts[i];\\n            if(mid>=abs(n/2-cuts[i]) && (cuts.size()<=4 ||(cuts.size()-i-1)>=1 && i>1)){\\n                // lol=abs(cuts.size());\\n                mid=abs(n/2-cuts[i]);\\n                ii=cuts[i];\\n            }\\n\\n            // mid=min(mid,abs(n/2-cuts[i]));\\n        }\\n        cout<<endl;\\n        mid=ii;\\n        ans+=n;\\n        cout<<\"lolololololololololo\"<<endl<<mid<<endl;\\n        vector<int> n1,n2;\\n        cout<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            \\n            if(cuts[i]<mid){\\n                n1.push_back(cuts[i]);\\n                continue;\\n            }\\n            else if(cuts[i]>mid){\\n                n2.push_back(cuts[i]-mid);\\n                continue;\\n            }\\n            cout<<cuts[i];\\n        }\\n        cout<<endl<<endl<<endl<<mid;;\\n        for(auto c:n1){\\n            cout<<c;\\n        }\\n        cout<<endl<<n-mid;;\\n        for(auto c:n2){\\n            cout<<c;\\n        }\\n        if(n1.size()!=0)\\n        ans+=minCost(mid,n1);\\n        if(n2.size()!=0)\\n        ans+=minCost(n-mid,n2);\\n        cout<<\"ans\"<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bejinipramod",
                        "content": "i guess we can use binary search? right?"
                    }
                ]
            },
            {
                "id": 1908939,
                "content": [
                    {
                        "username": "yash121001",
                        "content": "Why can\\'t we in test case 1 we cut it like [5,4,3,1]?? We can get minimum answer by this??Correct me if I am wrong"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Partition DP"
                    },
                    {
                        "username": "Msey",
                        "content": "so, should we do cuts in any order? :D"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "well, this is not hard. We\\'ve had mediums twice more difficult just about 10 days ago"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "I have a question but it isn\\'t related to the problem.\\nI solved all the problems of May till today, but when I check the badges I don\\'t see May badge loading. is it okay or there is a problem?"
                    },
                    {
                        "username": "namandt",
                        "content": "let May month complete"
                    },
                    {
                        "username": "Youlian",
                        "content": "where stones"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Somehow I\\'m getting Memory Limit Exceeded for this test case. Can someone please help.\\n```\\n8100\\n[2101,3454,6088,5298,4727,6791,5538,305,3628,841,6007,7913,1621,1436,4022,908,7217,1099,1169,1787,383,7367,8046,2888,5465,6669,1660,2856,6771,4263,1782,6833,448,2792,1104,2342,1100,4378,252,2806,5104,1513,6115,388,4555,276,5214,5934,5749,7660,4590,3885,1052,4876,4144,4489,3945,2823,364,1324,4227,3764]\\n```\\n\\nCode\\n```\\nclass Solution {\\n\\n    private int util(int i, int j, int[] cuts, int[][] dp) {\\n        if (i>=j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int min = Integer.MAX_VALUE;\\n        for (int k=0; k<cuts.length; k++) {\\n            if (cuts[k]>=i && cuts[k]<j) {\\n                int value = util(i, cuts[k], cuts, dp);\\n                value += util(cuts[k]+1, j, cuts, dp);\\n                min = Math.min(min, value);\\n            }\\n        }\\n        return dp[i][j] = min == Integer.MAX_VALUE ? 0 : min + (j-i+1);\\n    }\\n\\n    public int minCost(int n, int[] cuts) {\\n        int[][] dp = new int[n+1][n+1];\\n        for (int i=0; i<=n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return util(1, n, cuts, dp);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "[@Hritik__k](/Hritik__k) sure will check thanks"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try using map as dp instead of dp matrix or bottom up method .i.e non recurcsive one i also had the same problem or if you  want take u forward(youtube) have given very good explanation for this problem "
                    },
                    {
                        "username": "purvi_jha",
                        "content": "class Solution {\\npublic:\\n    int rec(vector<int>& cuts, vector<int>&part){\\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<cuts.size();i++){\\n            if(cuts[i]!=-1){\\n                int an=0;\\n                int temp=cuts[i];\\n                vector<int>inpar=part;\\n\\n                for(int j=0;j<part.size();j++){\\n                    int end=part[j];\\n\\n                    if(end>temp){\\n                        an+=end-j;\\n\\n                        part[j]=temp;\\n                        part[temp]=end;\\n\\n                        break;\\n                    }\\n                }\\n                \\n                cuts[i]=-1;\\n\\n                an+=rec(cuts,part);\\n\\n                ans=min(ans,an);\\n                cuts[i]=temp;\\n                part=inpar;\\n            }\\n        }\\n\\n        return ans==INT_MAX ? 0 : ans;\\n    }\\n\\n    int minCost(int n, vector<int>& cuts){\\n        vector<int>part(n+1,-1);\\n        part[0]=n;\\n\\n        return rec(cuts,part);\\n    }\\n};\\n\\nCan anyone help me in memoizing it\\n"
                    },
                    {
                        "username": "NOT_SOL",
                        "content": "can we do it with a greedy approach ??\\n( not a solution )  just an approach, if some one could come up with it lemme know.\\nclass Solution {\\npublic:\\n    // int dp[1e6+5][1e6+5];\\n    int minCost(int n, vector<int>& cuts,int ans=0) {\\n        // if(n-mid<0) return 0;\\n        if(cuts.size()==0){\\n            return 0;\\n        }\\n        if(cuts.size()==1){\\n            return n;\\n        }\\n        sort(cuts.begin(),cuts.end());\\n        int mid=n+1;\\n        int lol=n/2;\\n        int ii=cuts[0];\\n        cout<<cuts.size()<<n<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            cout<<\"->\"<<cuts[i];\\n            if(mid>=abs(n/2-cuts[i]) && (cuts.size()<=4 ||(cuts.size()-i-1)>=1 && i>1)){\\n                // lol=abs(cuts.size());\\n                mid=abs(n/2-cuts[i]);\\n                ii=cuts[i];\\n            }\\n\\n            // mid=min(mid,abs(n/2-cuts[i]));\\n        }\\n        cout<<endl;\\n        mid=ii;\\n        ans+=n;\\n        cout<<\"lolololololololololo\"<<endl<<mid<<endl;\\n        vector<int> n1,n2;\\n        cout<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            \\n            if(cuts[i]<mid){\\n                n1.push_back(cuts[i]);\\n                continue;\\n            }\\n            else if(cuts[i]>mid){\\n                n2.push_back(cuts[i]-mid);\\n                continue;\\n            }\\n            cout<<cuts[i];\\n        }\\n        cout<<endl<<endl<<endl<<mid;;\\n        for(auto c:n1){\\n            cout<<c;\\n        }\\n        cout<<endl<<n-mid;;\\n        for(auto c:n2){\\n            cout<<c;\\n        }\\n        if(n1.size()!=0)\\n        ans+=minCost(mid,n1);\\n        if(n2.size()!=0)\\n        ans+=minCost(n-mid,n2);\\n        cout<<\"ans\"<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bejinipramod",
                        "content": "i guess we can use binary search? right?"
                    }
                ]
            },
            {
                "id": 1908809,
                "content": [
                    {
                        "username": "yash121001",
                        "content": "Why can\\'t we in test case 1 we cut it like [5,4,3,1]?? We can get minimum answer by this??Correct me if I am wrong"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Partition DP"
                    },
                    {
                        "username": "Msey",
                        "content": "so, should we do cuts in any order? :D"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "well, this is not hard. We\\'ve had mediums twice more difficult just about 10 days ago"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "I have a question but it isn\\'t related to the problem.\\nI solved all the problems of May till today, but when I check the badges I don\\'t see May badge loading. is it okay or there is a problem?"
                    },
                    {
                        "username": "namandt",
                        "content": "let May month complete"
                    },
                    {
                        "username": "Youlian",
                        "content": "where stones"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Somehow I\\'m getting Memory Limit Exceeded for this test case. Can someone please help.\\n```\\n8100\\n[2101,3454,6088,5298,4727,6791,5538,305,3628,841,6007,7913,1621,1436,4022,908,7217,1099,1169,1787,383,7367,8046,2888,5465,6669,1660,2856,6771,4263,1782,6833,448,2792,1104,2342,1100,4378,252,2806,5104,1513,6115,388,4555,276,5214,5934,5749,7660,4590,3885,1052,4876,4144,4489,3945,2823,364,1324,4227,3764]\\n```\\n\\nCode\\n```\\nclass Solution {\\n\\n    private int util(int i, int j, int[] cuts, int[][] dp) {\\n        if (i>=j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int min = Integer.MAX_VALUE;\\n        for (int k=0; k<cuts.length; k++) {\\n            if (cuts[k]>=i && cuts[k]<j) {\\n                int value = util(i, cuts[k], cuts, dp);\\n                value += util(cuts[k]+1, j, cuts, dp);\\n                min = Math.min(min, value);\\n            }\\n        }\\n        return dp[i][j] = min == Integer.MAX_VALUE ? 0 : min + (j-i+1);\\n    }\\n\\n    public int minCost(int n, int[] cuts) {\\n        int[][] dp = new int[n+1][n+1];\\n        for (int i=0; i<=n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return util(1, n, cuts, dp);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "[@Hritik__k](/Hritik__k) sure will check thanks"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try using map as dp instead of dp matrix or bottom up method .i.e non recurcsive one i also had the same problem or if you  want take u forward(youtube) have given very good explanation for this problem "
                    },
                    {
                        "username": "purvi_jha",
                        "content": "class Solution {\\npublic:\\n    int rec(vector<int>& cuts, vector<int>&part){\\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<cuts.size();i++){\\n            if(cuts[i]!=-1){\\n                int an=0;\\n                int temp=cuts[i];\\n                vector<int>inpar=part;\\n\\n                for(int j=0;j<part.size();j++){\\n                    int end=part[j];\\n\\n                    if(end>temp){\\n                        an+=end-j;\\n\\n                        part[j]=temp;\\n                        part[temp]=end;\\n\\n                        break;\\n                    }\\n                }\\n                \\n                cuts[i]=-1;\\n\\n                an+=rec(cuts,part);\\n\\n                ans=min(ans,an);\\n                cuts[i]=temp;\\n                part=inpar;\\n            }\\n        }\\n\\n        return ans==INT_MAX ? 0 : ans;\\n    }\\n\\n    int minCost(int n, vector<int>& cuts){\\n        vector<int>part(n+1,-1);\\n        part[0]=n;\\n\\n        return rec(cuts,part);\\n    }\\n};\\n\\nCan anyone help me in memoizing it\\n"
                    },
                    {
                        "username": "NOT_SOL",
                        "content": "can we do it with a greedy approach ??\\n( not a solution )  just an approach, if some one could come up with it lemme know.\\nclass Solution {\\npublic:\\n    // int dp[1e6+5][1e6+5];\\n    int minCost(int n, vector<int>& cuts,int ans=0) {\\n        // if(n-mid<0) return 0;\\n        if(cuts.size()==0){\\n            return 0;\\n        }\\n        if(cuts.size()==1){\\n            return n;\\n        }\\n        sort(cuts.begin(),cuts.end());\\n        int mid=n+1;\\n        int lol=n/2;\\n        int ii=cuts[0];\\n        cout<<cuts.size()<<n<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            cout<<\"->\"<<cuts[i];\\n            if(mid>=abs(n/2-cuts[i]) && (cuts.size()<=4 ||(cuts.size()-i-1)>=1 && i>1)){\\n                // lol=abs(cuts.size());\\n                mid=abs(n/2-cuts[i]);\\n                ii=cuts[i];\\n            }\\n\\n            // mid=min(mid,abs(n/2-cuts[i]));\\n        }\\n        cout<<endl;\\n        mid=ii;\\n        ans+=n;\\n        cout<<\"lolololololololololo\"<<endl<<mid<<endl;\\n        vector<int> n1,n2;\\n        cout<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            \\n            if(cuts[i]<mid){\\n                n1.push_back(cuts[i]);\\n                continue;\\n            }\\n            else if(cuts[i]>mid){\\n                n2.push_back(cuts[i]-mid);\\n                continue;\\n            }\\n            cout<<cuts[i];\\n        }\\n        cout<<endl<<endl<<endl<<mid;;\\n        for(auto c:n1){\\n            cout<<c;\\n        }\\n        cout<<endl<<n-mid;;\\n        for(auto c:n2){\\n            cout<<c;\\n        }\\n        if(n1.size()!=0)\\n        ans+=minCost(mid,n1);\\n        if(n2.size()!=0)\\n        ans+=minCost(n-mid,n2);\\n        cout<<\"ans\"<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bejinipramod",
                        "content": "i guess we can use binary search? right?"
                    }
                ]
            },
            {
                "id": 1908589,
                "content": [
                    {
                        "username": "yash121001",
                        "content": "Why can\\'t we in test case 1 we cut it like [5,4,3,1]?? We can get minimum answer by this??Correct me if I am wrong"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Partition DP"
                    },
                    {
                        "username": "Msey",
                        "content": "so, should we do cuts in any order? :D"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "well, this is not hard. We\\'ve had mediums twice more difficult just about 10 days ago"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "I have a question but it isn\\'t related to the problem.\\nI solved all the problems of May till today, but when I check the badges I don\\'t see May badge loading. is it okay or there is a problem?"
                    },
                    {
                        "username": "namandt",
                        "content": "let May month complete"
                    },
                    {
                        "username": "Youlian",
                        "content": "where stones"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Somehow I\\'m getting Memory Limit Exceeded for this test case. Can someone please help.\\n```\\n8100\\n[2101,3454,6088,5298,4727,6791,5538,305,3628,841,6007,7913,1621,1436,4022,908,7217,1099,1169,1787,383,7367,8046,2888,5465,6669,1660,2856,6771,4263,1782,6833,448,2792,1104,2342,1100,4378,252,2806,5104,1513,6115,388,4555,276,5214,5934,5749,7660,4590,3885,1052,4876,4144,4489,3945,2823,364,1324,4227,3764]\\n```\\n\\nCode\\n```\\nclass Solution {\\n\\n    private int util(int i, int j, int[] cuts, int[][] dp) {\\n        if (i>=j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int min = Integer.MAX_VALUE;\\n        for (int k=0; k<cuts.length; k++) {\\n            if (cuts[k]>=i && cuts[k]<j) {\\n                int value = util(i, cuts[k], cuts, dp);\\n                value += util(cuts[k]+1, j, cuts, dp);\\n                min = Math.min(min, value);\\n            }\\n        }\\n        return dp[i][j] = min == Integer.MAX_VALUE ? 0 : min + (j-i+1);\\n    }\\n\\n    public int minCost(int n, int[] cuts) {\\n        int[][] dp = new int[n+1][n+1];\\n        for (int i=0; i<=n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return util(1, n, cuts, dp);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "[@Hritik__k](/Hritik__k) sure will check thanks"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try using map as dp instead of dp matrix or bottom up method .i.e non recurcsive one i also had the same problem or if you  want take u forward(youtube) have given very good explanation for this problem "
                    },
                    {
                        "username": "purvi_jha",
                        "content": "class Solution {\\npublic:\\n    int rec(vector<int>& cuts, vector<int>&part){\\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<cuts.size();i++){\\n            if(cuts[i]!=-1){\\n                int an=0;\\n                int temp=cuts[i];\\n                vector<int>inpar=part;\\n\\n                for(int j=0;j<part.size();j++){\\n                    int end=part[j];\\n\\n                    if(end>temp){\\n                        an+=end-j;\\n\\n                        part[j]=temp;\\n                        part[temp]=end;\\n\\n                        break;\\n                    }\\n                }\\n                \\n                cuts[i]=-1;\\n\\n                an+=rec(cuts,part);\\n\\n                ans=min(ans,an);\\n                cuts[i]=temp;\\n                part=inpar;\\n            }\\n        }\\n\\n        return ans==INT_MAX ? 0 : ans;\\n    }\\n\\n    int minCost(int n, vector<int>& cuts){\\n        vector<int>part(n+1,-1);\\n        part[0]=n;\\n\\n        return rec(cuts,part);\\n    }\\n};\\n\\nCan anyone help me in memoizing it\\n"
                    },
                    {
                        "username": "NOT_SOL",
                        "content": "can we do it with a greedy approach ??\\n( not a solution )  just an approach, if some one could come up with it lemme know.\\nclass Solution {\\npublic:\\n    // int dp[1e6+5][1e6+5];\\n    int minCost(int n, vector<int>& cuts,int ans=0) {\\n        // if(n-mid<0) return 0;\\n        if(cuts.size()==0){\\n            return 0;\\n        }\\n        if(cuts.size()==1){\\n            return n;\\n        }\\n        sort(cuts.begin(),cuts.end());\\n        int mid=n+1;\\n        int lol=n/2;\\n        int ii=cuts[0];\\n        cout<<cuts.size()<<n<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            cout<<\"->\"<<cuts[i];\\n            if(mid>=abs(n/2-cuts[i]) && (cuts.size()<=4 ||(cuts.size()-i-1)>=1 && i>1)){\\n                // lol=abs(cuts.size());\\n                mid=abs(n/2-cuts[i]);\\n                ii=cuts[i];\\n            }\\n\\n            // mid=min(mid,abs(n/2-cuts[i]));\\n        }\\n        cout<<endl;\\n        mid=ii;\\n        ans+=n;\\n        cout<<\"lolololololololololo\"<<endl<<mid<<endl;\\n        vector<int> n1,n2;\\n        cout<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            \\n            if(cuts[i]<mid){\\n                n1.push_back(cuts[i]);\\n                continue;\\n            }\\n            else if(cuts[i]>mid){\\n                n2.push_back(cuts[i]-mid);\\n                continue;\\n            }\\n            cout<<cuts[i];\\n        }\\n        cout<<endl<<endl<<endl<<mid;;\\n        for(auto c:n1){\\n            cout<<c;\\n        }\\n        cout<<endl<<n-mid;;\\n        for(auto c:n2){\\n            cout<<c;\\n        }\\n        if(n1.size()!=0)\\n        ans+=minCost(mid,n1);\\n        if(n2.size()!=0)\\n        ans+=minCost(n-mid,n2);\\n        cout<<\"ans\"<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bejinipramod",
                        "content": "i guess we can use binary search? right?"
                    }
                ]
            },
            {
                "id": 1908533,
                "content": [
                    {
                        "username": "yash121001",
                        "content": "Why can\\'t we in test case 1 we cut it like [5,4,3,1]?? We can get minimum answer by this??Correct me if I am wrong"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Partition DP"
                    },
                    {
                        "username": "Msey",
                        "content": "so, should we do cuts in any order? :D"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "well, this is not hard. We\\'ve had mediums twice more difficult just about 10 days ago"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "I have a question but it isn\\'t related to the problem.\\nI solved all the problems of May till today, but when I check the badges I don\\'t see May badge loading. is it okay or there is a problem?"
                    },
                    {
                        "username": "namandt",
                        "content": "let May month complete"
                    },
                    {
                        "username": "Youlian",
                        "content": "where stones"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Somehow I\\'m getting Memory Limit Exceeded for this test case. Can someone please help.\\n```\\n8100\\n[2101,3454,6088,5298,4727,6791,5538,305,3628,841,6007,7913,1621,1436,4022,908,7217,1099,1169,1787,383,7367,8046,2888,5465,6669,1660,2856,6771,4263,1782,6833,448,2792,1104,2342,1100,4378,252,2806,5104,1513,6115,388,4555,276,5214,5934,5749,7660,4590,3885,1052,4876,4144,4489,3945,2823,364,1324,4227,3764]\\n```\\n\\nCode\\n```\\nclass Solution {\\n\\n    private int util(int i, int j, int[] cuts, int[][] dp) {\\n        if (i>=j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int min = Integer.MAX_VALUE;\\n        for (int k=0; k<cuts.length; k++) {\\n            if (cuts[k]>=i && cuts[k]<j) {\\n                int value = util(i, cuts[k], cuts, dp);\\n                value += util(cuts[k]+1, j, cuts, dp);\\n                min = Math.min(min, value);\\n            }\\n        }\\n        return dp[i][j] = min == Integer.MAX_VALUE ? 0 : min + (j-i+1);\\n    }\\n\\n    public int minCost(int n, int[] cuts) {\\n        int[][] dp = new int[n+1][n+1];\\n        for (int i=0; i<=n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return util(1, n, cuts, dp);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "[@Hritik__k](/Hritik__k) sure will check thanks"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try using map as dp instead of dp matrix or bottom up method .i.e non recurcsive one i also had the same problem or if you  want take u forward(youtube) have given very good explanation for this problem "
                    },
                    {
                        "username": "purvi_jha",
                        "content": "class Solution {\\npublic:\\n    int rec(vector<int>& cuts, vector<int>&part){\\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<cuts.size();i++){\\n            if(cuts[i]!=-1){\\n                int an=0;\\n                int temp=cuts[i];\\n                vector<int>inpar=part;\\n\\n                for(int j=0;j<part.size();j++){\\n                    int end=part[j];\\n\\n                    if(end>temp){\\n                        an+=end-j;\\n\\n                        part[j]=temp;\\n                        part[temp]=end;\\n\\n                        break;\\n                    }\\n                }\\n                \\n                cuts[i]=-1;\\n\\n                an+=rec(cuts,part);\\n\\n                ans=min(ans,an);\\n                cuts[i]=temp;\\n                part=inpar;\\n            }\\n        }\\n\\n        return ans==INT_MAX ? 0 : ans;\\n    }\\n\\n    int minCost(int n, vector<int>& cuts){\\n        vector<int>part(n+1,-1);\\n        part[0]=n;\\n\\n        return rec(cuts,part);\\n    }\\n};\\n\\nCan anyone help me in memoizing it\\n"
                    },
                    {
                        "username": "NOT_SOL",
                        "content": "can we do it with a greedy approach ??\\n( not a solution )  just an approach, if some one could come up with it lemme know.\\nclass Solution {\\npublic:\\n    // int dp[1e6+5][1e6+5];\\n    int minCost(int n, vector<int>& cuts,int ans=0) {\\n        // if(n-mid<0) return 0;\\n        if(cuts.size()==0){\\n            return 0;\\n        }\\n        if(cuts.size()==1){\\n            return n;\\n        }\\n        sort(cuts.begin(),cuts.end());\\n        int mid=n+1;\\n        int lol=n/2;\\n        int ii=cuts[0];\\n        cout<<cuts.size()<<n<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            cout<<\"->\"<<cuts[i];\\n            if(mid>=abs(n/2-cuts[i]) && (cuts.size()<=4 ||(cuts.size()-i-1)>=1 && i>1)){\\n                // lol=abs(cuts.size());\\n                mid=abs(n/2-cuts[i]);\\n                ii=cuts[i];\\n            }\\n\\n            // mid=min(mid,abs(n/2-cuts[i]));\\n        }\\n        cout<<endl;\\n        mid=ii;\\n        ans+=n;\\n        cout<<\"lolololololololololo\"<<endl<<mid<<endl;\\n        vector<int> n1,n2;\\n        cout<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            \\n            if(cuts[i]<mid){\\n                n1.push_back(cuts[i]);\\n                continue;\\n            }\\n            else if(cuts[i]>mid){\\n                n2.push_back(cuts[i]-mid);\\n                continue;\\n            }\\n            cout<<cuts[i];\\n        }\\n        cout<<endl<<endl<<endl<<mid;;\\n        for(auto c:n1){\\n            cout<<c;\\n        }\\n        cout<<endl<<n-mid;;\\n        for(auto c:n2){\\n            cout<<c;\\n        }\\n        if(n1.size()!=0)\\n        ans+=minCost(mid,n1);\\n        if(n2.size()!=0)\\n        ans+=minCost(n-mid,n2);\\n        cout<<\"ans\"<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bejinipramod",
                        "content": "i guess we can use binary search? right?"
                    }
                ]
            },
            {
                "id": 1908475,
                "content": [
                    {
                        "username": "yash121001",
                        "content": "Why can\\'t we in test case 1 we cut it like [5,4,3,1]?? We can get minimum answer by this??Correct me if I am wrong"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Partition DP"
                    },
                    {
                        "username": "Msey",
                        "content": "so, should we do cuts in any order? :D"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "well, this is not hard. We\\'ve had mediums twice more difficult just about 10 days ago"
                    },
                    {
                        "username": "mohamed_ahmed123",
                        "content": "I have a question but it isn\\'t related to the problem.\\nI solved all the problems of May till today, but when I check the badges I don\\'t see May badge loading. is it okay or there is a problem?"
                    },
                    {
                        "username": "namandt",
                        "content": "let May month complete"
                    },
                    {
                        "username": "Youlian",
                        "content": "where stones"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "Somehow I\\'m getting Memory Limit Exceeded for this test case. Can someone please help.\\n```\\n8100\\n[2101,3454,6088,5298,4727,6791,5538,305,3628,841,6007,7913,1621,1436,4022,908,7217,1099,1169,1787,383,7367,8046,2888,5465,6669,1660,2856,6771,4263,1782,6833,448,2792,1104,2342,1100,4378,252,2806,5104,1513,6115,388,4555,276,5214,5934,5749,7660,4590,3885,1052,4876,4144,4489,3945,2823,364,1324,4227,3764]\\n```\\n\\nCode\\n```\\nclass Solution {\\n\\n    private int util(int i, int j, int[] cuts, int[][] dp) {\\n        if (i>=j) return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int min = Integer.MAX_VALUE;\\n        for (int k=0; k<cuts.length; k++) {\\n            if (cuts[k]>=i && cuts[k]<j) {\\n                int value = util(i, cuts[k], cuts, dp);\\n                value += util(cuts[k]+1, j, cuts, dp);\\n                min = Math.min(min, value);\\n            }\\n        }\\n        return dp[i][j] = min == Integer.MAX_VALUE ? 0 : min + (j-i+1);\\n    }\\n\\n    public int minCost(int n, int[] cuts) {\\n        int[][] dp = new int[n+1][n+1];\\n        for (int i=0; i<=n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return util(1, n, cuts, dp);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "consistent_Learner",
                        "content": "[@Hritik__k](/Hritik__k) sure will check thanks"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try using map as dp instead of dp matrix or bottom up method .i.e non recurcsive one i also had the same problem or if you  want take u forward(youtube) have given very good explanation for this problem "
                    },
                    {
                        "username": "purvi_jha",
                        "content": "class Solution {\\npublic:\\n    int rec(vector<int>& cuts, vector<int>&part){\\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<cuts.size();i++){\\n            if(cuts[i]!=-1){\\n                int an=0;\\n                int temp=cuts[i];\\n                vector<int>inpar=part;\\n\\n                for(int j=0;j<part.size();j++){\\n                    int end=part[j];\\n\\n                    if(end>temp){\\n                        an+=end-j;\\n\\n                        part[j]=temp;\\n                        part[temp]=end;\\n\\n                        break;\\n                    }\\n                }\\n                \\n                cuts[i]=-1;\\n\\n                an+=rec(cuts,part);\\n\\n                ans=min(ans,an);\\n                cuts[i]=temp;\\n                part=inpar;\\n            }\\n        }\\n\\n        return ans==INT_MAX ? 0 : ans;\\n    }\\n\\n    int minCost(int n, vector<int>& cuts){\\n        vector<int>part(n+1,-1);\\n        part[0]=n;\\n\\n        return rec(cuts,part);\\n    }\\n};\\n\\nCan anyone help me in memoizing it\\n"
                    },
                    {
                        "username": "NOT_SOL",
                        "content": "can we do it with a greedy approach ??\\n( not a solution )  just an approach, if some one could come up with it lemme know.\\nclass Solution {\\npublic:\\n    // int dp[1e6+5][1e6+5];\\n    int minCost(int n, vector<int>& cuts,int ans=0) {\\n        // if(n-mid<0) return 0;\\n        if(cuts.size()==0){\\n            return 0;\\n        }\\n        if(cuts.size()==1){\\n            return n;\\n        }\\n        sort(cuts.begin(),cuts.end());\\n        int mid=n+1;\\n        int lol=n/2;\\n        int ii=cuts[0];\\n        cout<<cuts.size()<<n<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            cout<<\"->\"<<cuts[i];\\n            if(mid>=abs(n/2-cuts[i]) && (cuts.size()<=4 ||(cuts.size()-i-1)>=1 && i>1)){\\n                // lol=abs(cuts.size());\\n                mid=abs(n/2-cuts[i]);\\n                ii=cuts[i];\\n            }\\n\\n            // mid=min(mid,abs(n/2-cuts[i]));\\n        }\\n        cout<<endl;\\n        mid=ii;\\n        ans+=n;\\n        cout<<\"lolololololololololo\"<<endl<<mid<<endl;\\n        vector<int> n1,n2;\\n        cout<<endl;\\n        for(int i=0;i<cuts.size();i++){\\n            \\n            if(cuts[i]<mid){\\n                n1.push_back(cuts[i]);\\n                continue;\\n            }\\n            else if(cuts[i]>mid){\\n                n2.push_back(cuts[i]-mid);\\n                continue;\\n            }\\n            cout<<cuts[i];\\n        }\\n        cout<<endl<<endl<<endl<<mid;;\\n        for(auto c:n1){\\n            cout<<c;\\n        }\\n        cout<<endl<<n-mid;;\\n        for(auto c:n2){\\n            cout<<c;\\n        }\\n        if(n1.size()!=0)\\n        ans+=minCost(mid,n1);\\n        if(n2.size()!=0)\\n        ans+=minCost(n-mid,n2);\\n        cout<<\"ans\"<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bejinipramod",
                        "content": "i guess we can use binary search? right?"
                    }
                ]
            },
            {
                "id": 1908231,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "stone, stick, staff next?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Or even as far as return to monke\\n875. Koko Eating Bananas"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Mind are exhausted after  two consecutive contest within 12Hour and this HARD again. why?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Memoized solution => only beat 5.7% in both time and memory :("
                    },
                    {
                        "username": "Panda_2397",
                        "content": "It can also be a stone problem when asking us to combine stone lol"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP Everywhere"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Why it\\'s always HARD on sunday \\uD83D\\uDE25"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@zenfred](/zenfred) And you could have a life on the weekends"
                    },
                    {
                        "username": "zenfred",
                        "content": "Because you may have classes/work on weekdays"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "this week shoould be labelled as DP week."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it is, they post the themes for the questions beforehand in discussion section."
                    },
                    {
                        "username": "khe1154",
                        "content": "hard problem for the weekend. lets go!!!"
                    },
                    {
                        "username": "anuragdw0710",
                        "content": "\n[863878133](https://leetcode.com/problems/minimum-cost-to-cut-a-stick/submissions/863878133/)\nTLE on:\nn =\n5340\ncuts =\n[2062,4550,482,4903,2998,5002,3766,2297]\nAny Hepl !!"
                    },
                    {
                        "username": "pratyakshsinha1234",
                        "content": "Try tabulated solution not the recursive memoized"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "why the same logic giving tle in c++ but not in java\n\nbut then i submitted same soln about 5 times and it got accepted ."
                    },
                    {
                        "username": "zenfred",
                        "content": "C++ STL is not optimized on LeetCode. Try using an array instead."
                    }
                ]
            },
            {
                "id": 1908213,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "stone, stick, staff next?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Or even as far as return to monke\\n875. Koko Eating Bananas"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Mind are exhausted after  two consecutive contest within 12Hour and this HARD again. why?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Memoized solution => only beat 5.7% in both time and memory :("
                    },
                    {
                        "username": "Panda_2397",
                        "content": "It can also be a stone problem when asking us to combine stone lol"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP Everywhere"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Why it\\'s always HARD on sunday \\uD83D\\uDE25"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@zenfred](/zenfred) And you could have a life on the weekends"
                    },
                    {
                        "username": "zenfred",
                        "content": "Because you may have classes/work on weekdays"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "this week shoould be labelled as DP week."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it is, they post the themes for the questions beforehand in discussion section."
                    },
                    {
                        "username": "khe1154",
                        "content": "hard problem for the weekend. lets go!!!"
                    },
                    {
                        "username": "anuragdw0710",
                        "content": "\n[863878133](https://leetcode.com/problems/minimum-cost-to-cut-a-stick/submissions/863878133/)\nTLE on:\nn =\n5340\ncuts =\n[2062,4550,482,4903,2998,5002,3766,2297]\nAny Hepl !!"
                    },
                    {
                        "username": "pratyakshsinha1234",
                        "content": "Try tabulated solution not the recursive memoized"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "why the same logic giving tle in c++ but not in java\n\nbut then i submitted same soln about 5 times and it got accepted ."
                    },
                    {
                        "username": "zenfred",
                        "content": "C++ STL is not optimized on LeetCode. Try using an array instead."
                    }
                ]
            },
            {
                "id": 1908145,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "stone, stick, staff next?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Or even as far as return to monke\\n875. Koko Eating Bananas"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Mind are exhausted after  two consecutive contest within 12Hour and this HARD again. why?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Memoized solution => only beat 5.7% in both time and memory :("
                    },
                    {
                        "username": "Panda_2397",
                        "content": "It can also be a stone problem when asking us to combine stone lol"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP Everywhere"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Why it\\'s always HARD on sunday \\uD83D\\uDE25"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@zenfred](/zenfred) And you could have a life on the weekends"
                    },
                    {
                        "username": "zenfred",
                        "content": "Because you may have classes/work on weekdays"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "this week shoould be labelled as DP week."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it is, they post the themes for the questions beforehand in discussion section."
                    },
                    {
                        "username": "khe1154",
                        "content": "hard problem for the weekend. lets go!!!"
                    },
                    {
                        "username": "anuragdw0710",
                        "content": "\n[863878133](https://leetcode.com/problems/minimum-cost-to-cut-a-stick/submissions/863878133/)\nTLE on:\nn =\n5340\ncuts =\n[2062,4550,482,4903,2998,5002,3766,2297]\nAny Hepl !!"
                    },
                    {
                        "username": "pratyakshsinha1234",
                        "content": "Try tabulated solution not the recursive memoized"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "why the same logic giving tle in c++ but not in java\n\nbut then i submitted same soln about 5 times and it got accepted ."
                    },
                    {
                        "username": "zenfred",
                        "content": "C++ STL is not optimized on LeetCode. Try using an array instead."
                    }
                ]
            },
            {
                "id": 1908135,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "stone, stick, staff next?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Or even as far as return to monke\\n875. Koko Eating Bananas"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Mind are exhausted after  two consecutive contest within 12Hour and this HARD again. why?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Memoized solution => only beat 5.7% in both time and memory :("
                    },
                    {
                        "username": "Panda_2397",
                        "content": "It can also be a stone problem when asking us to combine stone lol"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP Everywhere"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Why it\\'s always HARD on sunday \\uD83D\\uDE25"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@zenfred](/zenfred) And you could have a life on the weekends"
                    },
                    {
                        "username": "zenfred",
                        "content": "Because you may have classes/work on weekdays"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "this week shoould be labelled as DP week."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it is, they post the themes for the questions beforehand in discussion section."
                    },
                    {
                        "username": "khe1154",
                        "content": "hard problem for the weekend. lets go!!!"
                    },
                    {
                        "username": "anuragdw0710",
                        "content": "\n[863878133](https://leetcode.com/problems/minimum-cost-to-cut-a-stick/submissions/863878133/)\nTLE on:\nn =\n5340\ncuts =\n[2062,4550,482,4903,2998,5002,3766,2297]\nAny Hepl !!"
                    },
                    {
                        "username": "pratyakshsinha1234",
                        "content": "Try tabulated solution not the recursive memoized"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "why the same logic giving tle in c++ but not in java\n\nbut then i submitted same soln about 5 times and it got accepted ."
                    },
                    {
                        "username": "zenfred",
                        "content": "C++ STL is not optimized on LeetCode. Try using an array instead."
                    }
                ]
            },
            {
                "id": 1908116,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "stone, stick, staff next?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Or even as far as return to monke\\n875. Koko Eating Bananas"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Mind are exhausted after  two consecutive contest within 12Hour and this HARD again. why?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Memoized solution => only beat 5.7% in both time and memory :("
                    },
                    {
                        "username": "Panda_2397",
                        "content": "It can also be a stone problem when asking us to combine stone lol"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP Everywhere"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Why it\\'s always HARD on sunday \\uD83D\\uDE25"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@zenfred](/zenfred) And you could have a life on the weekends"
                    },
                    {
                        "username": "zenfred",
                        "content": "Because you may have classes/work on weekdays"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "this week shoould be labelled as DP week."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it is, they post the themes for the questions beforehand in discussion section."
                    },
                    {
                        "username": "khe1154",
                        "content": "hard problem for the weekend. lets go!!!"
                    },
                    {
                        "username": "anuragdw0710",
                        "content": "\n[863878133](https://leetcode.com/problems/minimum-cost-to-cut-a-stick/submissions/863878133/)\nTLE on:\nn =\n5340\ncuts =\n[2062,4550,482,4903,2998,5002,3766,2297]\nAny Hepl !!"
                    },
                    {
                        "username": "pratyakshsinha1234",
                        "content": "Try tabulated solution not the recursive memoized"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "why the same logic giving tle in c++ but not in java\n\nbut then i submitted same soln about 5 times and it got accepted ."
                    },
                    {
                        "username": "zenfred",
                        "content": "C++ STL is not optimized on LeetCode. Try using an array instead."
                    }
                ]
            },
            {
                "id": 1908110,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "stone, stick, staff next?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Or even as far as return to monke\\n875. Koko Eating Bananas"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Mind are exhausted after  two consecutive contest within 12Hour and this HARD again. why?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Memoized solution => only beat 5.7% in both time and memory :("
                    },
                    {
                        "username": "Panda_2397",
                        "content": "It can also be a stone problem when asking us to combine stone lol"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP Everywhere"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Why it\\'s always HARD on sunday \\uD83D\\uDE25"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@zenfred](/zenfred) And you could have a life on the weekends"
                    },
                    {
                        "username": "zenfred",
                        "content": "Because you may have classes/work on weekdays"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "this week shoould be labelled as DP week."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it is, they post the themes for the questions beforehand in discussion section."
                    },
                    {
                        "username": "khe1154",
                        "content": "hard problem for the weekend. lets go!!!"
                    },
                    {
                        "username": "anuragdw0710",
                        "content": "\n[863878133](https://leetcode.com/problems/minimum-cost-to-cut-a-stick/submissions/863878133/)\nTLE on:\nn =\n5340\ncuts =\n[2062,4550,482,4903,2998,5002,3766,2297]\nAny Hepl !!"
                    },
                    {
                        "username": "pratyakshsinha1234",
                        "content": "Try tabulated solution not the recursive memoized"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "why the same logic giving tle in c++ but not in java\n\nbut then i submitted same soln about 5 times and it got accepted ."
                    },
                    {
                        "username": "zenfred",
                        "content": "C++ STL is not optimized on LeetCode. Try using an array instead."
                    }
                ]
            },
            {
                "id": 1908098,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "stone, stick, staff next?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Or even as far as return to monke\\n875. Koko Eating Bananas"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Mind are exhausted after  two consecutive contest within 12Hour and this HARD again. why?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Memoized solution => only beat 5.7% in both time and memory :("
                    },
                    {
                        "username": "Panda_2397",
                        "content": "It can also be a stone problem when asking us to combine stone lol"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP Everywhere"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Why it\\'s always HARD on sunday \\uD83D\\uDE25"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@zenfred](/zenfred) And you could have a life on the weekends"
                    },
                    {
                        "username": "zenfred",
                        "content": "Because you may have classes/work on weekdays"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "this week shoould be labelled as DP week."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it is, they post the themes for the questions beforehand in discussion section."
                    },
                    {
                        "username": "khe1154",
                        "content": "hard problem for the weekend. lets go!!!"
                    },
                    {
                        "username": "anuragdw0710",
                        "content": "\n[863878133](https://leetcode.com/problems/minimum-cost-to-cut-a-stick/submissions/863878133/)\nTLE on:\nn =\n5340\ncuts =\n[2062,4550,482,4903,2998,5002,3766,2297]\nAny Hepl !!"
                    },
                    {
                        "username": "pratyakshsinha1234",
                        "content": "Try tabulated solution not the recursive memoized"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "why the same logic giving tle in c++ but not in java\n\nbut then i submitted same soln about 5 times and it got accepted ."
                    },
                    {
                        "username": "zenfred",
                        "content": "C++ STL is not optimized on LeetCode. Try using an array instead."
                    }
                ]
            },
            {
                "id": 1908030,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "stone, stick, staff next?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Or even as far as return to monke\\n875. Koko Eating Bananas"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Mind are exhausted after  two consecutive contest within 12Hour and this HARD again. why?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Memoized solution => only beat 5.7% in both time and memory :("
                    },
                    {
                        "username": "Panda_2397",
                        "content": "It can also be a stone problem when asking us to combine stone lol"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP Everywhere"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Why it\\'s always HARD on sunday \\uD83D\\uDE25"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@zenfred](/zenfred) And you could have a life on the weekends"
                    },
                    {
                        "username": "zenfred",
                        "content": "Because you may have classes/work on weekdays"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "this week shoould be labelled as DP week."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it is, they post the themes for the questions beforehand in discussion section."
                    },
                    {
                        "username": "khe1154",
                        "content": "hard problem for the weekend. lets go!!!"
                    },
                    {
                        "username": "anuragdw0710",
                        "content": "\n[863878133](https://leetcode.com/problems/minimum-cost-to-cut-a-stick/submissions/863878133/)\nTLE on:\nn =\n5340\ncuts =\n[2062,4550,482,4903,2998,5002,3766,2297]\nAny Hepl !!"
                    },
                    {
                        "username": "pratyakshsinha1234",
                        "content": "Try tabulated solution not the recursive memoized"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "why the same logic giving tle in c++ but not in java\n\nbut then i submitted same soln about 5 times and it got accepted ."
                    },
                    {
                        "username": "zenfred",
                        "content": "C++ STL is not optimized on LeetCode. Try using an array instead."
                    }
                ]
            },
            {
                "id": 1724748,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "stone, stick, staff next?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Or even as far as return to monke\\n875. Koko Eating Bananas"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Mind are exhausted after  two consecutive contest within 12Hour and this HARD again. why?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Memoized solution => only beat 5.7% in both time and memory :("
                    },
                    {
                        "username": "Panda_2397",
                        "content": "It can also be a stone problem when asking us to combine stone lol"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP Everywhere"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Why it\\'s always HARD on sunday \\uD83D\\uDE25"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@zenfred](/zenfred) And you could have a life on the weekends"
                    },
                    {
                        "username": "zenfred",
                        "content": "Because you may have classes/work on weekdays"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "this week shoould be labelled as DP week."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it is, they post the themes for the questions beforehand in discussion section."
                    },
                    {
                        "username": "khe1154",
                        "content": "hard problem for the weekend. lets go!!!"
                    },
                    {
                        "username": "anuragdw0710",
                        "content": "\n[863878133](https://leetcode.com/problems/minimum-cost-to-cut-a-stick/submissions/863878133/)\nTLE on:\nn =\n5340\ncuts =\n[2062,4550,482,4903,2998,5002,3766,2297]\nAny Hepl !!"
                    },
                    {
                        "username": "pratyakshsinha1234",
                        "content": "Try tabulated solution not the recursive memoized"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "why the same logic giving tle in c++ but not in java\n\nbut then i submitted same soln about 5 times and it got accepted ."
                    },
                    {
                        "username": "zenfred",
                        "content": "C++ STL is not optimized on LeetCode. Try using an array instead."
                    }
                ]
            },
            {
                "id": 1724021,
                "content": [
                    {
                        "username": "vnk01",
                        "content": "stone, stick, staff next?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Or even as far as return to monke\\n875. Koko Eating Bananas"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Mind are exhausted after  two consecutive contest within 12Hour and this HARD again. why?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Memoized solution => only beat 5.7% in both time and memory :("
                    },
                    {
                        "username": "Panda_2397",
                        "content": "It can also be a stone problem when asking us to combine stone lol"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP Everywhere"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Why it\\'s always HARD on sunday \\uD83D\\uDE25"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@zenfred](/zenfred) And you could have a life on the weekends"
                    },
                    {
                        "username": "zenfred",
                        "content": "Because you may have classes/work on weekdays"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "this week shoould be labelled as DP week."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it is, they post the themes for the questions beforehand in discussion section."
                    },
                    {
                        "username": "khe1154",
                        "content": "hard problem for the weekend. lets go!!!"
                    },
                    {
                        "username": "anuragdw0710",
                        "content": "\n[863878133](https://leetcode.com/problems/minimum-cost-to-cut-a-stick/submissions/863878133/)\nTLE on:\nn =\n5340\ncuts =\n[2062,4550,482,4903,2998,5002,3766,2297]\nAny Hepl !!"
                    },
                    {
                        "username": "pratyakshsinha1234",
                        "content": "Try tabulated solution not the recursive memoized"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "why the same logic giving tle in c++ but not in java\n\nbut then i submitted same soln about 5 times and it got accepted ."
                    },
                    {
                        "username": "zenfred",
                        "content": "C++ STL is not optimized on LeetCode. Try using an array instead."
                    }
                ]
            }
        ]
    },
    {
        "title": "The Most Similar Path in a Graph",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565508,
                "content": [
                    {
                        "username": "blackspinner",
                        "content": "What if in addition to replacement, you are allowed to add/delete nodes? Original post taken from here: https://leetcode.com/discuss/interview-question/751787/google-on-site-smallest-edit-distance-to-convert-path"
                    },
                    {
                        "username": "fzss",
                        "content": "### Intuition for both dp and Dijkstra\\'s\\n\\nWe need to find a path, the most naive way is to come up with all possible combinations of paths, and return a path with the smallest distance.\\n\\nIf the `targetPath` is of length `t`, we build a graph and traverse it with BFS (going back to the same node is okay) until we build a path of length `t`. Then we compare the edit distances of these paths against the `targetPath`, and return the shortest one.\\n\\nHowever, that\\'s not very smart. Why? Because we will end up with a huge amount paths, especially if `t` is large. \\n\\nIf on average a node has `x` neighbors, the amount of paths we end up having will be `x ^ t`. And the last part requires a traversal of all of these paths, the overall time is `O(x ^ t)`. This number easily get out of hand.\\n\\n#### Reduce the problem space\\nIf we can reach a `city[i]` at length `k`, we do not care how we got here, because we only need to know one solution. In other words, the paths `[1, 2, 3, i]` or `[3, 0, 1, i]` will be the same.\\n\\nUnless one path has a shorter edit distance because we need to find the one with minimum edit distance.\\n\\nSo all we have to track is the minimum `i, k`.\\n\\n### DP\\n\\n#### Subproblem \\n`dp(k, i)` = The minimum edit distance of a path with `k` cities that ends at `city[i]`. \\n\\n#### Recurrence relations\\n`dp(k, i)` = min { `dp(k - 1, j)`, `diff(target[k - 1], j)` } for all `j` that is a neighbor to `i`\\n\\n#### Base case\\n`dp(0, i) = 0`\\n\\nIn addition, we need to record which city `j` will be the optimal one to reconstruct the path.\\n\\n### Dijkstra\\'s \\n\\n`BFS` with a priority queue containing `[city, distance, path, depth]` and sorts by `distance`.\\n\\n`depth` is equivalent to `k` and city is equivalent to `i` in dp.\\n\\nIn addition the same principle to reduce the queue size should be used:\\n\\nA `visited` set will be used to track `city` `depth`, i.e. `i & k`. If we have already added a `city` with a specific `depth` to the queue, we should not add further nodes to the queue. \\n\\nIn addition, dijkstra\\'s ensures that the first such encounter is the shortest in distance.\\n"
                    },
                    {
                        "username": "returncode",
                        "content": "A simple modified-BFS can also solve this question: https://leetcode.com/problems/the-most-similar-path-in-a-graph/submissions/871304477/"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "The definition of targetPath is not given clearly. Like how exactly do we interpret it?"
                    },
                    {
                        "username": "DreamyCrab",
                        "content": "Duplicate city names got me :("
                    },
                    {
                        "username": "joyifei",
                        "content": "for example 3,  why [0,4,5,4,0,2,1] is wrong?  since index 3 and 0 pointing to the same city,  [3,4,5,4,3,2,1] should be acceptable "
                    },
                    {
                        "username": "ursat",
                        "content": "There\\'s no link between 0 and 4"
                    }
                ]
            },
            {
                "id": 1568515,
                "content": [
                    {
                        "username": "blackspinner",
                        "content": "What if in addition to replacement, you are allowed to add/delete nodes? Original post taken from here: https://leetcode.com/discuss/interview-question/751787/google-on-site-smallest-edit-distance-to-convert-path"
                    },
                    {
                        "username": "fzss",
                        "content": "### Intuition for both dp and Dijkstra\\'s\\n\\nWe need to find a path, the most naive way is to come up with all possible combinations of paths, and return a path with the smallest distance.\\n\\nIf the `targetPath` is of length `t`, we build a graph and traverse it with BFS (going back to the same node is okay) until we build a path of length `t`. Then we compare the edit distances of these paths against the `targetPath`, and return the shortest one.\\n\\nHowever, that\\'s not very smart. Why? Because we will end up with a huge amount paths, especially if `t` is large. \\n\\nIf on average a node has `x` neighbors, the amount of paths we end up having will be `x ^ t`. And the last part requires a traversal of all of these paths, the overall time is `O(x ^ t)`. This number easily get out of hand.\\n\\n#### Reduce the problem space\\nIf we can reach a `city[i]` at length `k`, we do not care how we got here, because we only need to know one solution. In other words, the paths `[1, 2, 3, i]` or `[3, 0, 1, i]` will be the same.\\n\\nUnless one path has a shorter edit distance because we need to find the one with minimum edit distance.\\n\\nSo all we have to track is the minimum `i, k`.\\n\\n### DP\\n\\n#### Subproblem \\n`dp(k, i)` = The minimum edit distance of a path with `k` cities that ends at `city[i]`. \\n\\n#### Recurrence relations\\n`dp(k, i)` = min { `dp(k - 1, j)`, `diff(target[k - 1], j)` } for all `j` that is a neighbor to `i`\\n\\n#### Base case\\n`dp(0, i) = 0`\\n\\nIn addition, we need to record which city `j` will be the optimal one to reconstruct the path.\\n\\n### Dijkstra\\'s \\n\\n`BFS` with a priority queue containing `[city, distance, path, depth]` and sorts by `distance`.\\n\\n`depth` is equivalent to `k` and city is equivalent to `i` in dp.\\n\\nIn addition the same principle to reduce the queue size should be used:\\n\\nA `visited` set will be used to track `city` `depth`, i.e. `i & k`. If we have already added a `city` with a specific `depth` to the queue, we should not add further nodes to the queue. \\n\\nIn addition, dijkstra\\'s ensures that the first such encounter is the shortest in distance.\\n"
                    },
                    {
                        "username": "returncode",
                        "content": "A simple modified-BFS can also solve this question: https://leetcode.com/problems/the-most-similar-path-in-a-graph/submissions/871304477/"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "The definition of targetPath is not given clearly. Like how exactly do we interpret it?"
                    },
                    {
                        "username": "DreamyCrab",
                        "content": "Duplicate city names got me :("
                    },
                    {
                        "username": "joyifei",
                        "content": "for example 3,  why [0,4,5,4,0,2,1] is wrong?  since index 3 and 0 pointing to the same city,  [3,4,5,4,3,2,1] should be acceptable "
                    },
                    {
                        "username": "ursat",
                        "content": "There\\'s no link between 0 and 4"
                    }
                ]
            },
            {
                "id": 1868345,
                "content": [
                    {
                        "username": "blackspinner",
                        "content": "What if in addition to replacement, you are allowed to add/delete nodes? Original post taken from here: https://leetcode.com/discuss/interview-question/751787/google-on-site-smallest-edit-distance-to-convert-path"
                    },
                    {
                        "username": "fzss",
                        "content": "### Intuition for both dp and Dijkstra\\'s\\n\\nWe need to find a path, the most naive way is to come up with all possible combinations of paths, and return a path with the smallest distance.\\n\\nIf the `targetPath` is of length `t`, we build a graph and traverse it with BFS (going back to the same node is okay) until we build a path of length `t`. Then we compare the edit distances of these paths against the `targetPath`, and return the shortest one.\\n\\nHowever, that\\'s not very smart. Why? Because we will end up with a huge amount paths, especially if `t` is large. \\n\\nIf on average a node has `x` neighbors, the amount of paths we end up having will be `x ^ t`. And the last part requires a traversal of all of these paths, the overall time is `O(x ^ t)`. This number easily get out of hand.\\n\\n#### Reduce the problem space\\nIf we can reach a `city[i]` at length `k`, we do not care how we got here, because we only need to know one solution. In other words, the paths `[1, 2, 3, i]` or `[3, 0, 1, i]` will be the same.\\n\\nUnless one path has a shorter edit distance because we need to find the one with minimum edit distance.\\n\\nSo all we have to track is the minimum `i, k`.\\n\\n### DP\\n\\n#### Subproblem \\n`dp(k, i)` = The minimum edit distance of a path with `k` cities that ends at `city[i]`. \\n\\n#### Recurrence relations\\n`dp(k, i)` = min { `dp(k - 1, j)`, `diff(target[k - 1], j)` } for all `j` that is a neighbor to `i`\\n\\n#### Base case\\n`dp(0, i) = 0`\\n\\nIn addition, we need to record which city `j` will be the optimal one to reconstruct the path.\\n\\n### Dijkstra\\'s \\n\\n`BFS` with a priority queue containing `[city, distance, path, depth]` and sorts by `distance`.\\n\\n`depth` is equivalent to `k` and city is equivalent to `i` in dp.\\n\\nIn addition the same principle to reduce the queue size should be used:\\n\\nA `visited` set will be used to track `city` `depth`, i.e. `i & k`. If we have already added a `city` with a specific `depth` to the queue, we should not add further nodes to the queue. \\n\\nIn addition, dijkstra\\'s ensures that the first such encounter is the shortest in distance.\\n"
                    },
                    {
                        "username": "returncode",
                        "content": "A simple modified-BFS can also solve this question: https://leetcode.com/problems/the-most-similar-path-in-a-graph/submissions/871304477/"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "The definition of targetPath is not given clearly. Like how exactly do we interpret it?"
                    },
                    {
                        "username": "DreamyCrab",
                        "content": "Duplicate city names got me :("
                    },
                    {
                        "username": "joyifei",
                        "content": "for example 3,  why [0,4,5,4,0,2,1] is wrong?  since index 3 and 0 pointing to the same city,  [3,4,5,4,3,2,1] should be acceptable "
                    },
                    {
                        "username": "ursat",
                        "content": "There\\'s no link between 0 and 4"
                    }
                ]
            },
            {
                "id": 1864544,
                "content": [
                    {
                        "username": "blackspinner",
                        "content": "What if in addition to replacement, you are allowed to add/delete nodes? Original post taken from here: https://leetcode.com/discuss/interview-question/751787/google-on-site-smallest-edit-distance-to-convert-path"
                    },
                    {
                        "username": "fzss",
                        "content": "### Intuition for both dp and Dijkstra\\'s\\n\\nWe need to find a path, the most naive way is to come up with all possible combinations of paths, and return a path with the smallest distance.\\n\\nIf the `targetPath` is of length `t`, we build a graph and traverse it with BFS (going back to the same node is okay) until we build a path of length `t`. Then we compare the edit distances of these paths against the `targetPath`, and return the shortest one.\\n\\nHowever, that\\'s not very smart. Why? Because we will end up with a huge amount paths, especially if `t` is large. \\n\\nIf on average a node has `x` neighbors, the amount of paths we end up having will be `x ^ t`. And the last part requires a traversal of all of these paths, the overall time is `O(x ^ t)`. This number easily get out of hand.\\n\\n#### Reduce the problem space\\nIf we can reach a `city[i]` at length `k`, we do not care how we got here, because we only need to know one solution. In other words, the paths `[1, 2, 3, i]` or `[3, 0, 1, i]` will be the same.\\n\\nUnless one path has a shorter edit distance because we need to find the one with minimum edit distance.\\n\\nSo all we have to track is the minimum `i, k`.\\n\\n### DP\\n\\n#### Subproblem \\n`dp(k, i)` = The minimum edit distance of a path with `k` cities that ends at `city[i]`. \\n\\n#### Recurrence relations\\n`dp(k, i)` = min { `dp(k - 1, j)`, `diff(target[k - 1], j)` } for all `j` that is a neighbor to `i`\\n\\n#### Base case\\n`dp(0, i) = 0`\\n\\nIn addition, we need to record which city `j` will be the optimal one to reconstruct the path.\\n\\n### Dijkstra\\'s \\n\\n`BFS` with a priority queue containing `[city, distance, path, depth]` and sorts by `distance`.\\n\\n`depth` is equivalent to `k` and city is equivalent to `i` in dp.\\n\\nIn addition the same principle to reduce the queue size should be used:\\n\\nA `visited` set will be used to track `city` `depth`, i.e. `i & k`. If we have already added a `city` with a specific `depth` to the queue, we should not add further nodes to the queue. \\n\\nIn addition, dijkstra\\'s ensures that the first such encounter is the shortest in distance.\\n"
                    },
                    {
                        "username": "returncode",
                        "content": "A simple modified-BFS can also solve this question: https://leetcode.com/problems/the-most-similar-path-in-a-graph/submissions/871304477/"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "The definition of targetPath is not given clearly. Like how exactly do we interpret it?"
                    },
                    {
                        "username": "DreamyCrab",
                        "content": "Duplicate city names got me :("
                    },
                    {
                        "username": "joyifei",
                        "content": "for example 3,  why [0,4,5,4,0,2,1] is wrong?  since index 3 and 0 pointing to the same city,  [3,4,5,4,3,2,1] should be acceptable "
                    },
                    {
                        "username": "ursat",
                        "content": "There\\'s no link between 0 and 4"
                    }
                ]
            },
            {
                "id": 1791104,
                "content": [
                    {
                        "username": "blackspinner",
                        "content": "What if in addition to replacement, you are allowed to add/delete nodes? Original post taken from here: https://leetcode.com/discuss/interview-question/751787/google-on-site-smallest-edit-distance-to-convert-path"
                    },
                    {
                        "username": "fzss",
                        "content": "### Intuition for both dp and Dijkstra\\'s\\n\\nWe need to find a path, the most naive way is to come up with all possible combinations of paths, and return a path with the smallest distance.\\n\\nIf the `targetPath` is of length `t`, we build a graph and traverse it with BFS (going back to the same node is okay) until we build a path of length `t`. Then we compare the edit distances of these paths against the `targetPath`, and return the shortest one.\\n\\nHowever, that\\'s not very smart. Why? Because we will end up with a huge amount paths, especially if `t` is large. \\n\\nIf on average a node has `x` neighbors, the amount of paths we end up having will be `x ^ t`. And the last part requires a traversal of all of these paths, the overall time is `O(x ^ t)`. This number easily get out of hand.\\n\\n#### Reduce the problem space\\nIf we can reach a `city[i]` at length `k`, we do not care how we got here, because we only need to know one solution. In other words, the paths `[1, 2, 3, i]` or `[3, 0, 1, i]` will be the same.\\n\\nUnless one path has a shorter edit distance because we need to find the one with minimum edit distance.\\n\\nSo all we have to track is the minimum `i, k`.\\n\\n### DP\\n\\n#### Subproblem \\n`dp(k, i)` = The minimum edit distance of a path with `k` cities that ends at `city[i]`. \\n\\n#### Recurrence relations\\n`dp(k, i)` = min { `dp(k - 1, j)`, `diff(target[k - 1], j)` } for all `j` that is a neighbor to `i`\\n\\n#### Base case\\n`dp(0, i) = 0`\\n\\nIn addition, we need to record which city `j` will be the optimal one to reconstruct the path.\\n\\n### Dijkstra\\'s \\n\\n`BFS` with a priority queue containing `[city, distance, path, depth]` and sorts by `distance`.\\n\\n`depth` is equivalent to `k` and city is equivalent to `i` in dp.\\n\\nIn addition the same principle to reduce the queue size should be used:\\n\\nA `visited` set will be used to track `city` `depth`, i.e. `i & k`. If we have already added a `city` with a specific `depth` to the queue, we should not add further nodes to the queue. \\n\\nIn addition, dijkstra\\'s ensures that the first such encounter is the shortest in distance.\\n"
                    },
                    {
                        "username": "returncode",
                        "content": "A simple modified-BFS can also solve this question: https://leetcode.com/problems/the-most-similar-path-in-a-graph/submissions/871304477/"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "The definition of targetPath is not given clearly. Like how exactly do we interpret it?"
                    },
                    {
                        "username": "DreamyCrab",
                        "content": "Duplicate city names got me :("
                    },
                    {
                        "username": "joyifei",
                        "content": "for example 3,  why [0,4,5,4,0,2,1] is wrong?  since index 3 and 0 pointing to the same city,  [3,4,5,4,3,2,1] should be acceptable "
                    },
                    {
                        "username": "ursat",
                        "content": "There\\'s no link between 0 and 4"
                    }
                ]
            }
        ]
    }
]