[
    {
        "title": "Count Ways to Group Overlapping Ranges",
        "question_content": "You are given a 2D integer array ranges where ranges[i] = [starti, endi] denotes that all integers between starti and endi (both inclusive) are contained in the ith range.\nYou are to split ranges into two (possibly empty) groups such that:\n\n\tEach range belongs to exactly one group.\n\tAny two overlapping ranges must belong to the same group.\n\nTwo ranges are said to be overlapping&nbsp;if there exists at least one integer that is present in both ranges.\n\n\tFor example, [1, 3] and [2, 5] are overlapping because 2 and 3 occur in both ranges.\n\nReturn the total number of ways to split ranges into two groups. Since the answer may be very large, return it modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: ranges = [[6,10],[5,15]]\nOutput: 2\nExplanation: \nThe two ranges are overlapping, so they must be in the same group.\nThus, there are two possible ways:\n- Put both the ranges together in group 1.\n- Put both the ranges together in group 2.\n\nExample 2:\n\nInput: ranges = [[1,3],[10,20],[2,5],[4,8]]\nOutput: 4\nExplanation: \nRanges [1,3], and [2,5] are overlapping. So, they must be in the same group.\nAgain, ranges [2,5] and [4,8] are also overlapping. So, they must also be in the same group. \nThus, there are four possible ways to group them:\n- All the ranges in group 1.\n- All the ranges in group 2.\n- Ranges [1,3], [2,5], and [4,8] in group 1 and [10,20] in group 2.\n- Ranges [1,3], [2,5], and [4,8] in group 2 and [10,20] in group 1.\n\n&nbsp;\nConstraints:\n\n\t1 <= ranges.length <= 105\n\tranges[i].length == 2\n\t0 <= starti <= endi <= 109",
        "solutions": [
            {
                "id": 3256371,
                "title": "java-c-python-sort-solution",
                "content": "# **Intuition**\\nSort the input.\\n<br>\\n\\n# **Explanation**\\n`last` is the right most end of the current group.\\nFor each `r` in `ranges`,\\nif `last < r[0]`, `r[0]` starts a new group,\\ncan be either the first or the second group,\\nso `res` should be doubled.\\nAlso we need to update `last = max(last, r[1])`.\\n\\nFinally we return resulst `res`.\\n<br>\\n\\n# **Complexity**\\nTime `O(sort)`\\nSpace `O(sort)`\\n<br>\\n\\n**Java**\\n```java\\n    public int countWays(int[][] ranges) {\\n        int res = 1, last = -1, mod = (int)1e9 + 7;\\n        Arrays.sort(ranges, (a, b) -> a[0] - b[0]);\\n        for (int[] r: ranges) {   \\n            if (last < r[0])\\n                res = res * 2 % mod;\\n            last = Math.max(last, r[1]);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int countWays(vector<vector<int>>& ranges) {\\n        int res = 1, last = -1, mod = 1e9 + 7;\\n        sort(ranges.begin(), ranges.end());\\n        for (auto r: ranges) {   \\n            if (last < r[0])\\n                res = res * 2 % mod;\\n            last = max(last, r[1]);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def countWays(self, A: List[List[int]]) -> int:\\n        pre = -1\\n        res = 0\\n        for a,b in sorted(A):\\n            res += pre < a\\n            pre = max(pre, b)\\n        return pow(2, res, 10**9+7)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int countWays(int[][] ranges) {\\n        int res = 1, last = -1, mod = (int)1e9 + 7;\\n        Arrays.sort(ranges, (a, b) -> a[0] - b[0]);\\n        for (int[] r: ranges) {   \\n            if (last < r[0])\\n                res = res * 2 % mod;\\n            last = Math.max(last, r[1]);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int countWays(vector<vector<int>>& ranges) {\\n        int res = 1, last = -1, mod = 1e9 + 7;\\n        sort(ranges.begin(), ranges.end());\\n        for (auto r: ranges) {   \\n            if (last < r[0])\\n                res = res * 2 % mod;\\n            last = max(last, r[1]);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def countWays(self, A: List[List[int]]) -> int:\\n        pre = -1\\n        res = 0\\n        for a,b in sorted(A):\\n            res += pre < a\\n            pre = max(pre, b)\\n        return pow(2, res, 10**9+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3256408,
                "title": "explained-sorting-power-2-very-simple-easy-to-understand-solution",
                "content": "\\n```\\n/*\\n\\n1. Count number of separate range groups (say n)\\n    - To do this we can simply sort the array \\n    - travese the array tracking end of a reange\\n    \\n2. return answer as the 2 power n\\n    - as it can be large, need to use standard power technique to calculate.\\n\\nFAQ: why power of 2?\\nans. if we have n groups, tgen to dived them into two groups,\\nwe need to think like we need to have 1group  where the question becomes if we have n number then how many ways they can be grouped together  lead to summation of all coefficients of a binomial expansion, which in turn results in power of two. \\n*/\\n\\nclass Solution {\\npublic:\\n    int mod= 1000000007;\\n    int power(int n){\\n        if(n == 1) return 2;\\n        long long t = power(n/2);\\n        t = (t * t)%mod;\\n        if(n%2) { return (t*2)%mod; }\\n        return t;\\n    }\\n    int countWays(vector<vector<int>>& ranges) {\\n        auto comp = [](vector<int>& a, vector<int>& b){\\n            if(a[0] == b[0]) return a[1] <= b[1];\\n            return a[0] < b[0];\\n        };\\n        sort(ranges.begin(), ranges.end(), comp);\\n        int n = 1, end = ranges[0][1];\\n        for(auto r: ranges){\\n            if(r[0] <= end){\\n                end = max(end, r[1]);\\n            }else{\\n                n++;\\n                end = r[1];\\n            }\\n        }\\n        return power(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n\\n1. Count number of separate range groups (say n)\\n    - To do this we can simply sort the array \\n    - travese the array tracking end of a reange\\n    \\n2. return answer as the 2 power n\\n    - as it can be large, need to use standard power technique to calculate.\\n\\nFAQ: why power of 2?\\nans. if we have n groups, tgen to dived them into two groups,\\nwe need to think like we need to have 1group  where the question becomes if we have n number then how many ways they can be grouped together  lead to summation of all coefficients of a binomial expansion, which in turn results in power of two. \\n*/\\n\\nclass Solution {\\npublic:\\n    int mod= 1000000007;\\n    int power(int n){\\n        if(n == 1) return 2;\\n        long long t = power(n/2);\\n        t = (t * t)%mod;\\n        if(n%2) { return (t*2)%mod; }\\n        return t;\\n    }\\n    int countWays(vector<vector<int>>& ranges) {\\n        auto comp = [](vector<int>& a, vector<int>& b){\\n            if(a[0] == b[0]) return a[1] <= b[1];\\n            return a[0] < b[0];\\n        };\\n        sort(ranges.begin(), ranges.end(), comp);\\n        int n = 1, end = ranges[0][1];\\n        for(auto r: ranges){\\n            if(r[0] <= end){\\n                end = max(end, r[1]);\\n            }else{\\n                n++;\\n                end = r[1];\\n            }\\n        }\\n        return power(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256565,
                "title": "merge-overlapping-intervals-and-count-easy-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere, firstly we will sort the given vector of intervals.\\nThen we will merge the overlapping intervals and will count the total number of intervals (mergesize) that will remain after merging.\\n\\nNow, we have to distribute every unoverlapped interval in 2 groups i.e. either in group 1 or in group 2 and we can do that by multiplying the answer with 2 every single we get an unoverlapped interval.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int countWays(vector<vector<int>>&v) {\\n        long long i=0,n=v.size(),mod=1e9+7;\\n        sort(v.begin(),v.end());\\n        int mergesize=1; // size=1 because we started to iterate from i=1 i.e. second interval.\\n        long long ans=2; // distributing the first interval in 2 ways\\n        //int first = v[0][0];\\n        int second = v[0][1];\\n        for(i=1;i<n;i++){\\n            if(v[i][0]<=second)second = max(second,v[i][1]);\\n            else{\\n                mergesize++;\\n                //first=v[i][0]; (incase,if u want to store the merged intervals)\\n                second=v[i][1];\\n                ans=(ans*2)%mod;  // distributing the current unoverlapped interval we got either in group 1 or in group 2.\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int countWays(vector<vector<int>>&v) {\\n        long long i=0,n=v.size(),mod=1e9+7;\\n        sort(v.begin(),v.end());\\n        int mergesize=1; // size=1 because we started to iterate from i=1 i.e. second interval.\\n        long long ans=2; // distributing the first interval in 2 ways\\n        //int first = v[0][0];\\n        int second = v[0][1];\\n        for(i=1;i<n;i++){\\n            if(v[i][0]<=second)second = max(second,v[i][1]);\\n            else{\\n                mergesize++;\\n                //first=v[i][0]; (incase,if u want to store the merged intervals)\\n                second=v[i][1];\\n                ans=(ans*2)%mod;  // distributing the current unoverlapped interval we got either in group 1 or in group 2.\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256156,
                "title": "simple-merge-interval-easy-to-understand",
                "content": "**THE ONLY NEW THING IN THIS QUESTION**\\n To group \\'n\\' items into 2 groups, there are (2 ^ n) possible ways \\n \\n ```\\n  class Solution {\\npublic:\\n   int MOD = 1000000007;\\n   int calcPower(int base, int power)  //modulo exponentation\\n   {\\n       long long ans = 1;\\n       while(power > 0)\\n       {\\n           if (power % 2 != 0) \\n           {\\n               ans = (ans * (long long)base) % MOD; \\n               power--; \\n           }\\n           else \\n           {\\n               power = power / 2;\\n               base = (base * (long long)base) % MOD;\\n           }\\n       }\\n       return (int)ans;\\n   }\\n   int countWays(vector<vector<int>>& ranges) \\n   {\\n       int n = ranges.size();\\n       sort(ranges.begin(), ranges.end());\\n       //===================================================================================\\n       //SAME PROCESS AS MERGE INTERVALS QUESTION\\n       int prevLow = ranges[0][0], prevHigh = ranges[0][1];\\n       int count = 1;  //count of non overlapping ranges \\n       for (int i = 1; i < n; i++)\\n       {\\n           if (ranges[i][0] >= prevLow && ranges[i][0] <= prevHigh)  \\n           {\\n               //This means that the current interval overlaps with the previous interval \\n               //so just merge it then .... update the new interval\\n               prevHigh = max(prevHigh, ranges[i][1]);\\n           }\\n           else\\n           {\\n               prevLow = ranges[i][0];\\n               prevHigh = ranges[i][1];\\n               count++;\\n           }\\n       }\\n       //==========================================================================================\\n       return calcPower(2, count);\\n   }\\n};\\n ```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  class Solution {\\npublic:\\n   int MOD = 1000000007;\\n   int calcPower(int base, int power)  //modulo exponentation\\n   {\\n       long long ans = 1;\\n       while(power > 0)\\n       {\\n           if (power % 2 != 0) \\n           {\\n               ans = (ans * (long long)base) % MOD; \\n               power--; \\n           }\\n           else \\n           {\\n               power = power / 2;\\n               base = (base * (long long)base) % MOD;\\n           }\\n       }\\n       return (int)ans;\\n   }\\n   int countWays(vector<vector<int>>& ranges) \\n   {\\n       int n = ranges.size();\\n       sort(ranges.begin(), ranges.end());\\n       //===================================================================================\\n       //SAME PROCESS AS MERGE INTERVALS QUESTION\\n       int prevLow = ranges[0][0], prevHigh = ranges[0][1];\\n       int count = 1;  //count of non overlapping ranges \\n       for (int i = 1; i < n; i++)\\n       {\\n           if (ranges[i][0] >= prevLow && ranges[i][0] <= prevHigh)  \\n           {\\n               //This means that the current interval overlaps with the previous interval \\n               //so just merge it then .... update the new interval\\n               prevHigh = max(prevHigh, ranges[i][1]);\\n           }\\n           else\\n           {\\n               prevLow = ranges[i][0];\\n               prevHigh = ranges[i][1];\\n               count++;\\n           }\\n       }\\n       //==========================================================================================\\n       return calcPower(2, count);\\n   }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3256146,
                "title": "java-python-3-count-non-overlapping-components-and-double-accordingly",
                "content": "Sort the `ranges` to find the number of non-overlapping components, and for each component, we have 2 options: put it into group `1` or `2`.\\n\\nTherefore, the answer is `2 ^ (# of componenets)`.\\n\\n```java\\n    public int countWays(int[][] ranges) {\\n        Arrays.sort(ranges, Comparator.comparingInt(r -> r[0]));\\n        int cnt = 1, hi = -1;\\n        for (int[] r : ranges) {\\n            if (hi < r[0]) {\\n                cnt <<= 1;\\n                cnt %= 1_000_000_007;\\n            }\\n            hi = Math.max(hi, r[1]);\\n        }\\n        return cnt;\\n    }\\n```\\n\\n```python\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        cnt, hi = 1, -1\\n        for a, b in sorted(ranges):\\n            if hi < a:\\n                cnt <<= 1\\n                cnt %= 10 ** 9 + 7\\n            hi = max(hi, b)\\n        return cnt\\n```\\n**Analysis:**\\n\\nTime: `O(nlogn)`, space: `O(n)` - including sorting space.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int countWays(int[][] ranges) {\\n        Arrays.sort(ranges, Comparator.comparingInt(r -> r[0]));\\n        int cnt = 1, hi = -1;\\n        for (int[] r : ranges) {\\n            if (hi < r[0]) {\\n                cnt <<= 1;\\n                cnt %= 1_000_000_007;\\n            }\\n            hi = Math.max(hi, r[1]);\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        cnt, hi = 1, -1\\n        for a, b in sorted(ranges):\\n            if hi < a:\\n                cnt <<= 1\\n                cnt %= 10 ** 9 + 7\\n            hi = max(hi, b)\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3256870,
                "title": "white-board-solution-sorting-power-of-2-merge-intervals-also-explained",
                "content": "# Video Solution\\nhttps://www.youtube.com/watch?v=-3QJGBmbK5w\\n\\n# Intuition & Explanation\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/92de9083-2d0b-4291-a0ac-ac3ec7bc3fcb_1677951210.7596238.png)\\n![image.png](https://assets.leetcode.com/users/images/51c67aaa-b1f5-4509-b0c2-ed546347b2b1_1677951223.4262962.png)\\n![image.png](https://assets.leetcode.com/users/images/49aeb49c-e8d6-40a4-be7c-570602be29a5_1677951231.362553.png)\\n![image.png](https://assets.leetcode.com/users/images/b7f9976a-4d75-4d09-849c-4f536b027ac9_1677951239.6584918.png)\\n![image.png](https://assets.leetcode.com/users/images/0cec5394-8018-4da1-ad77-0697af1569c2_1677951251.026729.png)\\n![image.png](https://assets.leetcode.com/users/images/02531841-2738-41ab-bcaa-8ae75dfc3c21_1677951258.8241725.png)\\n\\n\\n\\n# Code\\n```\\n#define mod 1000000007\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    \\n    // It means a^n % p\\n    ll power(ll a, ll n, ll p){\\n       ll res = 1;\\n        while(n){\\n            if(n%2 == 1){\\n                res = (res * a)%p;\\n                n--;\\n            }else{\\n                a = (a * a)%p;\\n                n = n/2;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int countWays(vector<vector<int>>& ranges) {\\n        ll ans = 0;\\n        \\n        sort(ranges.begin(), ranges.end());\\n        \\n        vector<vector<int>> temp;\\n        temp.push_back({ranges[0]});\\n        for(int i=1;i<ranges.size();i++){\\n            int last_fir = temp[temp.size()-1][0];\\n            int last_val = temp[temp.size()-1][1];\\n            \\n            if(ranges[i][0] > last_val){\\n                temp.push_back(ranges[i]);\\n            }else{\\n                temp.pop_back();\\n                int final_last = max(last_val, ranges[i][1]);\\n                temp.push_back({last_fir, final_last});\\n            }\\n        }\\n        ans = power(2, temp.size(), mod);\\n        \\n        return (int)ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define mod 1000000007\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    \\n    // It means a^n % p\\n    ll power(ll a, ll n, ll p){\\n       ll res = 1;\\n        while(n){\\n            if(n%2 == 1){\\n                res = (res * a)%p;\\n                n--;\\n            }else{\\n                a = (a * a)%p;\\n                n = n/2;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int countWays(vector<vector<int>>& ranges) {\\n        ll ans = 0;\\n        \\n        sort(ranges.begin(), ranges.end());\\n        \\n        vector<vector<int>> temp;\\n        temp.push_back({ranges[0]});\\n        for(int i=1;i<ranges.size();i++){\\n            int last_fir = temp[temp.size()-1][0];\\n            int last_val = temp[temp.size()-1][1];\\n            \\n            if(ranges[i][0] > last_val){\\n                temp.push_back(ranges[i]);\\n            }else{\\n                temp.pop_back();\\n                int final_last = max(last_val, ranges[i][1]);\\n                temp.push_back({last_fir, final_last});\\n            }\\n        }\\n        ans = power(2, temp.size(), mod);\\n        \\n        return (int)ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256406,
                "title": "solution-based-on-counting-overlap-not-overlap-intervals",
                "content": "Firstly, the ranges array should be sorted so that we can easily compare each interval with the others. Then, we can start counting the number of overlapping and non-overlapping intervals in the range.\\n\\nFor overlapping intervals, we can group them together and keep them in either Group 1 or Group 2. It doesn\\'t matter which group they are in, as long as they are in one of them. Therefore, we only need to count the number of overlapping intervals and multiply it by 2 to get the total contribution to the answer.\\n\\nFor non-overlapping intervals, we can split them into two groups as they can be placed in either Group 1 or Group 2. Therefore, for each non-overlapping interval, we need to multiply the answer by 2 twice (once for each group) to get the total contribution to the answer.\\n\\nPosting the solution in cpp as well as java. \\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    const long long int MOD = 1e9 + 7;\\n\\n    int countWays(vector<vector<int>>& ranges) \\n    {\\n        long long int ans = 1;\\n        int size = ranges.size();\\n        \\n        if (size == 1) return 2;\\n        \\n        sort(ranges.begin(), ranges.end());\\n        \\n        int overlap = 0, notOverlap = 0;\\n        int tillMax = INT_MIN;\\n        \\n        for (int idx = 1; idx < ranges.size(); idx++)\\n        {\\n            tillMax = max(tillMax, ranges[idx - 1][1]);\\n            \\n            if (ranges[idx][0] <= ranges[idx - 1][1] or ranges[idx][0] <= tillMax) overlap++;\\n            else notOverlap++; \\n        }\\n        \\n        if (overlap) ans *= 2;\\n        else notOverlap++; // for 0 based indexing as we know all pairs are non overlapping\\n        \\n        for (int idx = 1; idx <= notOverlap; idx++) {\\n            ans = ((ans * 2) % (long)MOD);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n```java\\nclass Solution {\\n    public int countWays(int[][] ranges) \\n    {\\n        final long MOD = 1000000007;\\n        long ans = 1, size = ranges.length;\\n        \\n        if (size == 1) return 2;\\n        \\n        Arrays.sort(ranges,(int[] o1, int[] o2) -> o1[0] - o2[0]);\\n\\n        int overlap = 0, notOverlap = 0;\\n        int tillMax = Integer.MIN_VALUE;\\n        \\n        for (int idx = 1; idx < size; idx++)\\n        {\\n            tillMax = Math.max(tillMax , ranges[idx-1][1]);\\n            \\n            if (ranges[idx][0] <=ranges[idx-1][1] || ranges[idx][0] <= tillMax) overlap++;\\n            else notOverlap++;\\n        }\\n        \\n        if (overlap > 0) ans *= 2;\\n        else notOverlap++;\\n        \\n        for (int idx = 1; idx <= notOverlap; idx++) {\\n            ans = ((ans * 2) % (long)MOD);\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n```\\n\\nTime Complexity: O(N * log N)\\nSpace Complexity : O(1)\\n\\nFeel free to ask your queries. Do upvote, it motivates me to write more.",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    const long long int MOD = 1e9 + 7;\\n\\n    int countWays(vector<vector<int>>& ranges) \\n    {\\n        long long int ans = 1;\\n        int size = ranges.size();\\n        \\n        if (size == 1) return 2;\\n        \\n        sort(ranges.begin(), ranges.end());\\n        \\n        int overlap = 0, notOverlap = 0;\\n        int tillMax = INT_MIN;\\n        \\n        for (int idx = 1; idx < ranges.size(); idx++)\\n        {\\n            tillMax = max(tillMax, ranges[idx - 1][1]);\\n            \\n            if (ranges[idx][0] <= ranges[idx - 1][1] or ranges[idx][0] <= tillMax) overlap++;\\n            else notOverlap++; \\n        }\\n        \\n        if (overlap) ans *= 2;\\n        else notOverlap++; // for 0 based indexing as we know all pairs are non overlapping\\n        \\n        for (int idx = 1; idx <= notOverlap; idx++) {\\n            ans = ((ans * 2) % (long)MOD);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public int countWays(int[][] ranges) \\n    {\\n        final long MOD = 1000000007;\\n        long ans = 1, size = ranges.length;\\n        \\n        if (size == 1) return 2;\\n        \\n        Arrays.sort(ranges,(int[] o1, int[] o2) -> o1[0] - o2[0]);\\n\\n        int overlap = 0, notOverlap = 0;\\n        int tillMax = Integer.MIN_VALUE;\\n        \\n        for (int idx = 1; idx < size; idx++)\\n        {\\n            tillMax = Math.max(tillMax , ranges[idx-1][1]);\\n            \\n            if (ranges[idx][0] <=ranges[idx-1][1] || ranges[idx][0] <= tillMax) overlap++;\\n            else notOverlap++;\\n        }\\n        \\n        if (overlap > 0) ans *= 2;\\n        else notOverlap++;\\n        \\n        for (int idx = 1; idx <= notOverlap; idx++) {\\n            ans = ((ans * 2) % (long)MOD);\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256203,
                "title": "fully-explained-code-c",
                "content": "# Intuition\\nThe ranges are merging into each other so sorting will give the required solution\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n     vector<pair<int,int>>v;\\n        // creating a vector pair in order to sort the range groups\\n        for(auto& i:ranges){\\n            v.push_back({i[0],i[1]});\\n        }\\n        sort(v.begin(),v.end());\\n        int la=-1,ans=0;\\n        // maintaing the upper bound so that we can check whether this range \\n        // is independent or inclusive of some previous range\\n        // here we are creating sets of ranges which will be together\\n        for(auto& i:v){\\n            if(i.first>la){\\n                ans++;\\n                la=i.second;\\n            }\\n            else la=max(la,i.second);\\n        }\\n        // calculating power via loop to avoid any overflows\\n        // calculating 2 to the power ans as and every set will have two options to go in either group one or two hence every set will have two choices so total ways equals 2 to the power no of sets\\n        int a=1;\\n        for(int i=0;i<ans;i++){\\n            a=(a*2)%1000000007;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n     vector<pair<int,int>>v;\\n        // creating a vector pair in order to sort the range groups\\n        for(auto& i:ranges){\\n            v.push_back({i[0],i[1]});\\n        }\\n        sort(v.begin(),v.end());\\n        int la=-1,ans=0;\\n        // maintaing the upper bound so that we can check whether this range \\n        // is independent or inclusive of some previous range\\n        // here we are creating sets of ranges which will be together\\n        for(auto& i:v){\\n            if(i.first>la){\\n                ans++;\\n                la=i.second;\\n            }\\n            else la=max(la,i.second);\\n        }\\n        // calculating power via loop to avoid any overflows\\n        // calculating 2 to the power ans as and every set will have two options to go in either group one or two hence every set will have two choices so total ways equals 2 to the power no of sets\\n        int a=1;\\n        for(int i=0;i<ans;i++){\\n            a=(a*2)%1000000007;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256101,
                "title": "simple-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n logn)$$\\n\\n- Space complexity: $$O(n)$$ where n is the size of the range array\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        Arrays.sort(ranges, new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b) {\\n                return a[0] - b[0];\\n            }\\n        });\\n        List<int[]> nm = new ArrayList<>();\\n        for (int[] i : ranges)\\n        {\\n            if(nm.isEmpty() || nm.get(nm.size()-1)[1] < i[0])\\n            {\\n                nm.add(i);\\n            }\\n            else\\n            {\\n                nm.get(nm.size()-1)[1] = Math.max(nm.get(nm.size()-1)[1], i[1]);\\n            }\\n        }\\n        long m=1000000007;\\n        return (int)task(2,nm.size(),m);\\n    }\\n    public long task(long i, long j, long p) {\\n        if(j==0)\\n        {\\n            return 1;\\n        }\\n        if(j==1)\\n        {\\n            return i;\\n        }\\n        long result=task(i,j/2,p);\\n        result=(result*result)%p;\\n        if (j % 2 == 1) {\\n            result=(result*i)%p;\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        Arrays.sort(ranges, new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b) {\\n                return a[0] - b[0];\\n            }\\n        });\\n        List<int[]> nm = new ArrayList<>();\\n        for (int[] i : ranges)\\n        {\\n            if(nm.isEmpty() || nm.get(nm.size()-1)[1] < i[0])\\n            {\\n                nm.add(i);\\n            }\\n            else\\n            {\\n                nm.get(nm.size()-1)[1] = Math.max(nm.get(nm.size()-1)[1], i[1]);\\n            }\\n        }\\n        long m=1000000007;\\n        return (int)task(2,nm.size(),m);\\n    }\\n    public long task(long i, long j, long p) {\\n        if(j==0)\\n        {\\n            return 1;\\n        }\\n        if(j==1)\\n        {\\n            return i;\\n        }\\n        long result=task(i,j/2,p);\\n        result=(result*result)%p;\\n        if (j % 2 == 1) {\\n            result=(result*i)%p;\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256252,
                "title": "sorting-solution",
                "content": "# Intuition\\nIt quite obvious that this problem could be divided into two separate problems:\\n\\n1. Find the number of non overlapping ranges\\n2. Find number of possible splits for known number of non overlapping ranges.\\n\\n\\n# Approach\\n**Find number of overlapping ranges**\\nLet\\u2019s sort array of ranges by their start and consider intervals one by one. Let compare next interval with previously considered. We can face two situations:\\n1. **start[next] \\u2264 end[previous]**\\n![image.png](https://assets.leetcode.com/users/images/f89bbf03-0d93-47d8-87bb-55da6185517b_1678046102.2397377.png)\\nNext interval overlap previous \\u2014 we need merge intervals.How can we merge overlapping intervals? There could be two possible cases:\\n1.1. **end[next] \\u2265 end[previous]**\\n![image.png](https://assets.leetcode.com/users/images/af53537e-c59a-4fad-8104-60bb6082fc3a_1678046200.0705585.png)\\n1.2. **end[next]<end[previous]**\\n![image.png](https://assets.leetcode.com/users/images/8823d2ce-b7c9-446f-b670-c2cefd91228c_1678046243.058007.png)\\nTo get merged interval boundaries we can use the following formula: **start [merged]=start[previous]** intervals are sorted so start[previous] is always lower, **end[merged] = max(end[next], end[previous])** \\u2014 we get the biggest of two ends for new interval. After merging we start compare next interval with merged one.\\n2. **start[next] > end[previous]** next interval does not overlap previous one we just start using next interval as is to compare with next intervals.\\n![image.png](https://assets.leetcode.com/users/images/8e904a8b-19dd-40f6-8f5d-b26cc0215196_1678046375.7832742.png)\\n\\n**Calculate number of ways to split ranges**\\nWe calculated the number of not overlapping intervals but now we need calculate the number of possible splits. In fact we need to calculate the number of possible subsequences for merged array. The number of possible subsequences for an array of length N will be equal to 2^N.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N*Log(N))\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} ranges\\n * @return {number}\\n */\\nvar countWays = function(ranges) {\\n    let mod = Math.pow(10, 9) + 7\\n    ranges.sort((r1, r2) => r1[0] - r2[0])\\n    \\n    let res = [ranges[0]]\\n    for(let next of ranges){\\n        let prev = res[res.length-1]\\n        // Compare end of previous with start of next interval\\n        if(prev[1] >= next[0]){\\n            // Intervals overlap\\n            prev[1] = Math.max(prev[1], next[1])\\n        }else{\\n            // Intervals not overlap\\n            res.push(next)\\n        }\\n    }\\n    \\n    let n = res.length\\n    \\n    let sum = 1\\n    for(let i = 1; i <= n; i++){\\n        sum = (sum * 2) % mod\\n    }\\n    \\n    return sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} ranges\\n * @return {number}\\n */\\nvar countWays = function(ranges) {\\n    let mod = Math.pow(10, 9) + 7\\n    ranges.sort((r1, r2) => r1[0] - r2[0])\\n    \\n    let res = [ranges[0]]\\n    for(let next of ranges){\\n        let prev = res[res.length-1]\\n        // Compare end of previous with start of next interval\\n        if(prev[1] >= next[0]){\\n            // Intervals overlap\\n            prev[1] = Math.max(prev[1], next[1])\\n        }else{\\n            // Intervals not overlap\\n            res.push(next)\\n        }\\n    }\\n    \\n    let n = res.length\\n    \\n    let sum = 1\\n    for(let i = 1; i <= n; i++){\\n        sum = (sum * 2) % mod\\n    }\\n    \\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3256552,
                "title": "simple-approach-with-intuition",
                "content": "# Intuition\\nIt is a simple observation that one interval have 2 option either it can become part of first group or second group and if all the intervals are independent of each other i.e non overlapping then it will lead to  2^n possible ways of grouping the intervals but intervals can be overlaping and two overlapping intervals should remain in same group then it will decrease the possiblity by some factor.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLet say we have x intervals which are non - overlaping then these intervals can become part of first group or second group which will lead to 2 possiblities for each interval\\n\\n1 2 3 ..... x \\n2 2 2 ..... 2 ( x times )\\n\\nwhich results in 2^x possiblities\\n\\n\\nBut if there are x intervals which are overlaping then these intervals collectively can become part of either first group or second group hence the contribution of these x intervals will be only 2 .\\n\\n1 2 3 .... x -- > belong to Group 1\\n1 2 3 .... x -- > belong to Group 2\\n\\nHence will contribute only 2 possibilites\\n\\n\\nHence our approach will be simple . Sort the intervals in increasing order ( non - decreasing order ) and make a variable end . Intially our end will have value of first interval\\'s end .\\n\\nNow there are two options \\n\\n1 ) If the ith interval have value less than end then it will be considered as overlapping to previous interval and thus don\\'t contribute in answer .\\n\\n2 ) If the ith internal have value greater than end then it will not be overlapping with previous interval hence considered as independent interval so it will contribute to answer by a factor of 2 .\\n\\n\\nIn both the cases we need to update the end to the maximum of previous or current interval\\'s end .\\n\\nIn last we will multiply by 2 so that we can consider the last set of intervals . This will eventually gives us the answer.\\n\\n\\n# Please upvote if you like this approach :)\\n\\n# Complexity\\n- Time complexity\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n       \\n        long long ans = 1;\\n        \\n        sort( ranges.begin() , ranges.end());\\n    \\n        int end   = ranges[0][1];\\n        \\n        int mod = 1e9 + 7 ;\\n        \\n        \\n        for( int i = 1 ; i < ranges.size() ; i++)\\n        {\\n            if( ranges[i][0] <= end)\\n            {\\n                 end = max( end , ranges[i][1] );\\n            }\\n            else\\n            {\\n                ans= (( ans%mod )*( 2 % mod )) %mod;\\n                end = max( end , ranges[i][1]);\\n            }\\n        }\\n\\n        ans= (( ans%mod )*( 2 % mod )) %mod;\\n        \\n        return ans;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n       \\n        long long ans = 1;\\n        \\n        sort( ranges.begin() , ranges.end());\\n    \\n        int end   = ranges[0][1];\\n        \\n        int mod = 1e9 + 7 ;\\n        \\n        \\n        for( int i = 1 ; i < ranges.size() ; i++)\\n        {\\n            if( ranges[i][0] <= end)\\n            {\\n                 end = max( end , ranges[i][1] );\\n            }\\n            else\\n            {\\n                ans= (( ans%mod )*( 2 % mod )) %mod;\\n                end = max( end , ranges[i][1]);\\n            }\\n        }\\n\\n        ans= (( ans%mod )*( 2 % mod )) %mod;\\n        \\n        return ans;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256345,
                "title": "count-non-overlapping-groups-of-intervals-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* group all the overlapping intervals and count them as 1 as 1 group.\\n* to do this sort the array on the bases of start and end of intervals.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* If we have n groups of intervals and we want to categorise them in either of a group. therefore for each group of intervals we have 2 cases.\\n* => that we have $${2^n}$$ ways of arranging these groups.\\n# Complexity\\n- Time complexity: O(n +log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    const int M = 1e9 + 7;\\n    long long int powxy(long long int x, long long int y) {\\n        if (y == 0) return 1;\\n        if (y%2 == 1) return (x*powxy(x, y-1))%M;\\n        long long int t = powxy(x, y/2);\\n        return (t*t)%M;\\n    }\\n    \\n    int countWays(vector<vector<int>>& ranges) \\n    {\\n        int n=ranges.size();\\n        auto mycmp=[&]( vector<int>&a,  vector<int>&b){\\n           if(a[0]!=b[0])\\n               return a[0]<b[0];\\n            return a[1]<b[1];\\n        };\\n        sort(begin(ranges),end(ranges),mycmp);  \\n        \\n        int groups=0,maxi=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(maxi<ranges[i][0])\\n            {\\n                groups++;\\n            }\\n            maxi=max(maxi,ranges[i][1]);\\n        }\\n        \\n        return powxy(1LL*2,1LL*groups);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    const int M = 1e9 + 7;\\n    long long int powxy(long long int x, long long int y) {\\n        if (y == 0) return 1;\\n        if (y%2 == 1) return (x*powxy(x, y-1))%M;\\n        long long int t = powxy(x, y/2);\\n        return (t*t)%M;\\n    }\\n    \\n    int countWays(vector<vector<int>>& ranges) \\n    {\\n        int n=ranges.size();\\n        auto mycmp=[&]( vector<int>&a,  vector<int>&b){\\n           if(a[0]!=b[0])\\n               return a[0]<b[0];\\n            return a[1]<b[1];\\n        };\\n        sort(begin(ranges),end(ranges),mycmp);  \\n        \\n        int groups=0,maxi=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(maxi<ranges[i][0])\\n            {\\n                groups++;\\n            }\\n            maxi=max(maxi,ranges[i][1]);\\n        }\\n        \\n        return powxy(1LL*2,1LL*groups);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256178,
                "title": "java",
                "content": "```\\nclass Pair{\\n    int arrive;\\n    int depart;\\n    Pair(int arrive,int depart){\\n        this.arrive=arrive;\\n        this.depart=depart;\\n    }\\n}\\nclass Solution {\\n    public int pow(int a, int b, int m){\\n        if(b==0)\\n            return 1;\\n        if(b==1)\\n            return a;\\n        Long res=new Long(pow(a,b/2,m));\\n        res=(res*res)%m;\\n        if(b%2==1){\\n            res=(res*a)%m;\\n        }\\n        return res.intValue();\\n    }\\n    public int countWays(int[][] ranges) {\\n        List<Pair> store=new ArrayList<>();\\n        for(int i=0;i<ranges.length;i++){\\n            store.add(new Pair(ranges[i][0],ranges[i][1]));\\n        }\\n        Collections.sort(store,(a,b)->a.arrive-b.arrive);\\n        List<Pair> ans=new ArrayList<>();\\n        int arrived=store.get(0).arrive;\\n        int departed=store.get(0).depart;\\n        for(Pair p:store){\\n            if(departed>=p.arrive){\\n                arrived=Math.min(arrived,p.arrive);\\n                departed=Math.max(departed,p.depart);\\n            }\\n            else{\\n                ans.add(new Pair(arrived,departed));\\n                arrived=p.arrive;\\n                departed=p.depart;\\n            }\\n        }\\n        ans.add(new Pair(arrived,departed));\\n        int arr[][]=new int[ans.size()][2];\\n        int k=0;\\n        for(Pair x: ans){\\n            arr[k][0]=x.arrive;\\n            arr[k][1]=x.depart;\\n            k++;\\n        }\\n        return pow(2,arr.length,(int)(1e9+7));\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/62416d0f-a315-4371-ae96-0cee5c2d3812_1677945830.9658315.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    int arrive;\\n    int depart;\\n    Pair(int arrive,int depart){\\n        this.arrive=arrive;\\n        this.depart=depart;\\n    }\\n}\\nclass Solution {\\n    public int pow(int a, int b, int m){\\n        if(b==0)\\n            return 1;\\n        if(b==1)\\n            return a;\\n        Long res=new Long(pow(a,b/2,m));\\n        res=(res*res)%m;\\n        if(b%2==1){\\n            res=(res*a)%m;\\n        }\\n        return res.intValue();\\n    }\\n    public int countWays(int[][] ranges) {\\n        List<Pair> store=new ArrayList<>();\\n        for(int i=0;i<ranges.length;i++){\\n            store.add(new Pair(ranges[i][0],ranges[i][1]));\\n        }\\n        Collections.sort(store,(a,b)->a.arrive-b.arrive);\\n        List<Pair> ans=new ArrayList<>();\\n        int arrived=store.get(0).arrive;\\n        int departed=store.get(0).depart;\\n        for(Pair p:store){\\n            if(departed>=p.arrive){\\n                arrived=Math.min(arrived,p.arrive);\\n                departed=Math.max(departed,p.depart);\\n            }\\n            else{\\n                ans.add(new Pair(arrived,departed));\\n                arrived=p.arrive;\\n                departed=p.depart;\\n            }\\n        }\\n        ans.add(new Pair(arrived,departed));\\n        int arr[][]=new int[ans.size()][2];\\n        int k=0;\\n        for(Pair x: ans){\\n            arr[k][0]=x.arrive;\\n            arr[k][1]=x.depart;\\n            k++;\\n        }\\n        return pow(2,arr.length,(int)(1e9+7));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261792,
                "title": "merge-and-power",
                "content": "First, we need to \"merge\" overlapping intervals, so that we have `m` non-overlapping intervals.\\n\\nWe can put each interval in any of two groups, so the total number of splits is `2 ^ m`.\\n\\nSo, we sort `ranges`, and multiply the result by 2 when we detect a new non-overlapping interval.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        end_max, res = -1, 1\\n        for start_i, end_i in sorted(ranges):\\n            res = res * (2 if end_max < start_i else 1) % 1000000007\\n            end_max = max(end_max, end_i)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        end_max, res = -1, 1\\n        for start_i, end_i in sorted(ranges):\\n            res = res * (2 if end_max < start_i else 1) % 1000000007\\n            end_max = max(end_max, end_i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256088,
                "title": "c-o-nlogn-dp-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        vector<ll> dp(ranges.size(),0);\\n        dp[0]=2;  //we can place the first interval in any group\\n        int maxi=ranges[0][1];\\n        for(int i=1;i<ranges.size();i++)\\n        {\\n            //if it overlaps with any of previous intervals then we have same ways\\n            if(ranges[i][0]<=maxi)\\n                dp[i]=dp[i-1];\\n            else\\n                dp[i]=2*dp[i-1];  //we can place current range in any group (2 ways)\\n            maxi=max(maxi,ranges[i][1]);\\n            dp[i]%=1000000007;\\n        }\\n        return dp[ranges.size()-1];\\n    }\\n};\\n```\\n\\n**please upvote if this found helpful**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        vector<ll> dp(ranges.size(),0);\\n        dp[0]=2;  //we can place the first interval in any group\\n        int maxi=ranges[0][1];\\n        for(int i=1;i<ranges.size();i++)\\n        {\\n            //if it overlaps with any of previous intervals then we have same ways\\n            if(ranges[i][0]<=maxi)\\n                dp[i]=dp[i-1];\\n            else\\n                dp[i]=2*dp[i-1];  //we can place current range in any group (2 ways)\\n            maxi=max(maxi,ranges[i][1]);\\n            dp[i]%=1000000007;\\n        }\\n        return dp[ranges.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261738,
                "title": "python-3-6-lines-w-example-t-m-1197-ms-64-mb",
                "content": "```\\nclass Solution:\\n    def countWays(self, ranges:List[List[int]])-> int:  #  Example: [[11,11],[3,9],[12,13],[1,8]]\\n                                                        #\\n        cnt, ans = 0, 1                                 #   _, idx = zip(*sorted(zip(11,11,8,9,12,13,1,3), [-1,1]*4)\\n                                                        #          = zip(*sorted((11,-1),(11,1),(3,-1),(9,1),(12,-1),(13,1)),(1,-1),(8,1))))\\n         _, idx = zip(*sorted(zip(chain(*ranges),       #          = zip(*(1,-1),(3,-1),(8,1),(9,1),(11,-1),(11,1),(12,-1),(13,1))\\n                      [-1,1]*len(ranges))))             #      idx = (-1,-1,1,1,-1,1,-1,1)\\n                                                \\n                                                        #      i    cnt   ans\\n                                                        #     \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\n        for i in idx:                                   #            0     1 \\n            cnt+= i                                     #     -1    -1     \\n            if cnt == 0: ans*= 2                        #     -1    -2     \\n                                                        #      1    -1     \\n        return ans                                      #      1     0 -\\u2013> 2\\n                                                        #     -1    -1     \\n                                                        #      1     0 -\\u2013> 4\\n                                                        #     -1    -1     \\n                                                        #      1     0 -\\u2013> 8  <\\u2013\\u2013\\u2013 return\\n\\n\\n\\n```\\n[https://leetcode.com/problems/count-ways-to-group-overlapping-ranges/submissions/909737649/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*NlogN*) and space complexity is *O*(*N*).\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges:List[List[int]])-> int:  #  Example: [[11,11],[3,9],[12,13],[1,8]]\\n                                                        #\\n        cnt, ans = 0, 1                                 #   _, idx = zip(*sorted(zip(11,11,8,9,12,13,1,3), [-1,1]*4)\\n                                                        #          = zip(*sorted((11,-1),(11,1),(3,-1),(9,1),(12,-1),(13,1)),(1,-1),(8,1))))\\n         _, idx = zip(*sorted(zip(chain(*ranges),       #          = zip(*(1,-1),(3,-1),(8,1),(9,1),(11,-1),(11,1),(12,-1),(13,1))\\n                      [-1,1]*len(ranges))))             #      idx = (-1,-1,1,1,-1,1,-1,1)\\n                                                \\n                                                        #      i    cnt   ans\\n                                                        #     \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\n        for i in idx:                                   #            0     1 \\n            cnt+= i                                     #     -1    -1     \\n            if cnt == 0: ans*= 2                        #     -1    -2     \\n                                                        #      1    -1     \\n        return ans                                      #      1     0 -\\u2013> 2\\n                                                        #     -1    -1     \\n                                                        #      1     0 -\\u2013> 4\\n                                                        #     -1    -1     \\n                                                        #      1     0 -\\u2013> 8  <\\u2013\\u2013\\u2013 return\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257396,
                "title": "c-most-easy-solution-using-concept-of-merge-intervals",
                "content": "**Basically we have to return pow(2,n) where n is size of final array containg all the merged intervals**\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n ll power(int x, unsigned int y)\\n{\\n    ll temp;\\n    if (y == 0)\\n        return 1;\\n    temp = power(x, y / 2)%mod;\\n    if (y % 2 == 0)\\n        return ((temp%mod) * (temp%mod))%mod;\\n    else\\n        return ((x%mod) *(temp%mod) * (temp%mod))%mod;\\n}\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        vector<vector<int>> ans;\\n        int n=ranges.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ans.size()==0)\\n            {\\n                ans.push_back(ranges[i]);\\n            }\\n            else\\n            {\\n                vector<int> &v=ans.back();\\n                int s=v[0],e=v[1];\\n                if(ranges[i][0]<=v[1])\\n                {\\n                    v[1]=max(e,ranges[i][1]);\\n                }\\n                else\\n                    ans.push_back(ranges[i]);\\n            }\\n        }\\n        int n1=ans.size();\\n        return power(2,n1)%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n ll power(int x, unsigned int y)\\n{\\n    ll temp;\\n    if (y == 0)\\n        return 1;\\n    temp = power(x, y / 2)%mod;\\n    if (y % 2 == 0)\\n        return ((temp%mod) * (temp%mod))%mod;\\n    else\\n        return ((x%mod) *(temp%mod) * (temp%mod))%mod;\\n}\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        vector<vector<int>> ans;\\n        int n=ranges.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ans.size()==0)\\n            {\\n                ans.push_back(ranges[i]);\\n            }\\n            else\\n            {\\n                vector<int> &v=ans.back();\\n                int s=v[0],e=v[1];\\n                if(ranges[i][0]<=v[1])\\n                {\\n                    v[1]=max(e,ranges[i][1]);\\n                }\\n                else\\n                    ans.push_back(ranges[i]);\\n            }\\n        }\\n        int n1=ans.size();\\n        return power(2,n1)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256086,
                "title": "c-merging-counting-efficient-approach",
                "content": "# Intuition\\nWe need to find total number of non-overlapping range i.e. total and possible ways will be 2^(total).\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int countWays(vector<vector<int>>& ranges) \\n    {\\n        sort(ranges.begin(), ranges.end());\\n        int total = 1, maxi_range=ranges[0][1];\\n        for(int i=1; i<ranges.size(); i++)\\n        {\\n            if(ranges[i][0] > maxi_range) total++;\\n            maxi_range = max(maxi_range, ranges[i][1]);\\n        }\\n        \\n        int ways=1, mod=1e9+7;\\n        while(total--)\\n        {\\n            ways = (ways*2)%mod;\\n        }\\n        return ways;\\n    }\\n};\\n```\\n# Please upvote if you like this approach :)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort",
                    "Counting"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countWays(vector<vector<int>>& ranges) \\n    {\\n        sort(ranges.begin(), ranges.end());\\n        int total = 1, maxi_range=ranges[0][1];\\n        for(int i=1; i<ranges.size(); i++)\\n        {\\n            if(ranges[i][0] > maxi_range) total++;\\n            maxi_range = max(maxi_range, ranges[i][1]);\\n        }\\n        \\n        int ways=1, mod=1e9+7;\\n        while(total--)\\n        {\\n            ways = (ways*2)%mod;\\n        }\\n        return ways;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268833,
                "title": "intuition-explained-with-example-merging-intervals-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question is similar to the [merge intervals](https://leetcode.com/problems/merge-intervals/) problem so it would be great if you solve that one first. \\n\\nNow, we are given a vector of intervals and the intervals can be overlapping. We need to count the ways in which they can be grouped so that overlapping ranges belong to same group and each range is in only one group at a time. To make the overlapping ranges belong to same group, we can combine the overlapping ranges. \\n\\nAfter combining overlapping ranges, only the non overlapping ranges would be remaining. Now to count the ways, one range can belong to either group 1 or group 2. To group \\'n\\' items into 2 groups, there are (2 ^ n) possible ways. So, there are **2^(number of non overlapping ranges)** way of grouping the elements\\n\\n### Example\\n```[1,5], [9,10], [2,3], [6,8]```\\n1. Sorting in increasing order of first element:\\n```[1,5], [2,3], [6,8], [9,10]```\\n2. Combining overlapping ranges: \\n```5<2 hence [1,5], [2,3] becomes [1,5].```\\n```[1,5], [6,8], [9,10]``` is the final range array\\n3. Now, we have non-overlapping invervals which can be grouped in the following ways:\\n```\\ngroup 1: [1,5], [6,8], [9,10] and group 2 empty\\ngroup 1: empty and group 2:[1,5], [6,8], [9,10]\\ngroup 1: [1,5], [6,8] and group 2: [9,10]\\ngroup 1: [1,5] and group 2: [6,8], [9,10]\\ngroup 1: [6,8] and group 2: [1,5], [9,10]\\ngroup 1: [9,10] and group 2:[1,5], [6,8]\\ngroup 1: [1,5], [9,10] and group 2: [6,8]\\ngroup 1: [6,8], [9,10] and group 2: [1,5]\\n\\n```\\n=> count= 2^(number of non overlapping intervals)= 2^3= 8\\n\\n# Complexity\\n- Time complexity: **O(n(logn)**) for sorting, as other time complexities involved are less than or equal to O(n) only\\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end()); //sorting so that we can find overlapping intervals\\n        vector<int>nonoverlap=ranges[0]; // stores the [start,end] of last non-overlapping interval\\n        int k=1,mod = 1e9 + 7; // k counts how many non overlapping intervals we have \\n\\n        for(int i=1;i<ranges.size();i++){\\n            if(ranges[i][0]<=nonoverlap[1]){ // if there\\'s overlapping, replace the end value\\n                nonoverlap[1]=max(nonoverlap[1],ranges[i][1]);\\n            }\\n            else {\\n                nonoverlap=ranges[i]; // in case of no overlapping with last interval, update the latest interval\\n                k++; // increase the count of non overlapping intervals\\n            }\\n        }\\n        int ans=1;\\n        while(k--){\\n            ans=ans*2%mod; //this can be done in the loop, i\\'m doing it outside for better understanding\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```[1,5], [9,10], [2,3], [6,8]```\n```[1,5], [2,3], [6,8], [9,10]```\n```5<2 hence [1,5], [2,3] becomes [1,5].```\n```[1,5], [6,8], [9,10]```\n```\\ngroup 1: [1,5], [6,8], [9,10] and group 2 empty\\ngroup 1: empty and group 2:[1,5], [6,8], [9,10]\\ngroup 1: [1,5], [6,8] and group 2: [9,10]\\ngroup 1: [1,5] and group 2: [6,8], [9,10]\\ngroup 1: [6,8] and group 2: [1,5], [9,10]\\ngroup 1: [9,10] and group 2:[1,5], [6,8]\\ngroup 1: [1,5], [9,10] and group 2: [6,8]\\ngroup 1: [6,8], [9,10] and group 2: [1,5]\\n\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end()); //sorting so that we can find overlapping intervals\\n        vector<int>nonoverlap=ranges[0]; // stores the [start,end] of last non-overlapping interval\\n        int k=1,mod = 1e9 + 7; // k counts how many non overlapping intervals we have \\n\\n        for(int i=1;i<ranges.size();i++){\\n            if(ranges[i][0]<=nonoverlap[1]){ // if there\\'s overlapping, replace the end value\\n                nonoverlap[1]=max(nonoverlap[1],ranges[i][1]);\\n            }\\n            else {\\n                nonoverlap=ranges[i]; // in case of no overlapping with last interval, update the latest interval\\n                k++; // increase the count of non overlapping intervals\\n            }\\n        }\\n        int ans=1;\\n        while(k--){\\n            ans=ans*2%mod; //this can be done in the loop, i\\'m doing it outside for better understanding\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258053,
                "title": "stack-merge-interval-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int> &a,vector<int> &b){\\n        if(a[1]==b[1])return a[0]<b[0];\\n        return a[1]<b[1];\\n    }\\n    int countWays(vector<vector<int>>& v) {\\n        sort(v.begin(),v.end(),cmp);\\n        stack<vector<int>> s;\\n        // int mn;\\n        s.push(v[0]);\\n        for(int i = 1; i < v.size(); i++){\\n            while(!s.empty()&&s.top()[1]>=v[i][0]){\\n                s.pop();\\n            }\\n            if(s.empty()){\\n                s.push(v[i]);\\n            }else if(s.top()[1]<v[i][0]){\\n                s.push(v[i]);\\n            }else{\\n                s.top()[1] = v[i][1];\\n            }\\n            \\n        }\\n        int mod = 1e9+7;\\n        int ans = 1;\\n        while(s.size()){\\n            ans = (ans*2)%mod;\\n            s.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int> &a,vector<int> &b){\\n        if(a[1]==b[1])return a[0]<b[0];\\n        return a[1]<b[1];\\n    }\\n    int countWays(vector<vector<int>>& v) {\\n        sort(v.begin(),v.end(),cmp);\\n        stack<vector<int>> s;\\n        // int mn;\\n        s.push(v[0]);\\n        for(int i = 1; i < v.size(); i++){\\n            while(!s.empty()&&s.top()[1]>=v[i][0]){\\n                s.pop();\\n            }\\n            if(s.empty()){\\n                s.push(v[i]);\\n            }else if(s.top()[1]<v[i][0]){\\n                s.push(v[i]);\\n            }else{\\n                s.top()[1] = v[i][1];\\n            }\\n            \\n        }\\n        int mod = 1e9+7;\\n        int ans = 1;\\n        while(s.size()){\\n            ans = (ans*2)%mod;\\n            s.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257499,
                "title": "javascript-2580-count-ways-to-group-overlapping-ranges",
                "content": "---\\n\\n# Intuition\\n- Do merge interval algorithm, since overlapping should be merged\\n- Do something with length of merged interval\\n  - May be powerset size, due to two groups\\n- Add BigInt & do MOD as needed in problem description\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\nvar merge = (intervals) => {\\n    intervals.sort((a, b) => a[0] - b[0]);\\n\\n    const ans = [[...intervals[0]]];\\n    for (let [start, end] of intervals) {\\n        const prevEnd = ans[ans.length - 1][1];\\n        if (prevEnd >= start) {\\n            ans[ans.length - 1][1] = Math.max(prevEnd, end);\\n        } else {\\n            ans.push([start, end]);\\n        }\\n    }\\n\\n    return ans;\\n};\\n\\nvar countWays = function (intervals) {\\n    intervals = merge(intervals);\\n\\n    let two = BigInt(2);\\n    let n = BigInt(intervals.length);\\n    let MOD = BigInt(10 ** 9 + 7);\\n\\n    return two ** n % MOD;\\n};\\n```\\n\\n---\\n\\n- Above code is from my contest submission\\nLink - https://leetcode.com/contest/biweekly-contest-99/ranking/53/\\n\\n![image.png](https://assets.leetcode.com/users/images/cf69d900-93d0-4edb-b639-086a9906e2d4_1677964098.6619318.png)\\n\\n\\n- Rating change:\\nLink - https://lccn.lbao.site/predicted/biweekly-contest-99\\n\\n![image.png](https://assets.leetcode.com/users/images/9852a5eb-62df-42cc-969d-403d99c3e5db_1677965024.9956195.png)\\n\\n---\\n\\n## Biweekly Contest 99 answers\\n\\n- Q1 - https://leetcode.com/problems/split-with-minimum-sum/solutions/3257467/javascript-2578-split-with-minimum-sum/?orderBy=most_votes\\n- Q2 - https://leetcode.com/problems/count-total-number-of-colored-cells/solutions/3257488/javascript-2579-count-total-number-of-colored-cells/?orderBy=most_votes\\n- Q3 - https://leetcode.com/problems/count-ways-to-group-overlapping-ranges/solutions/3257499/javascript-2580-count-ways-to-group-overlapping-ranges/?orderBy=most_votes\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar merge = (intervals) => {\\n    intervals.sort((a, b) => a[0] - b[0]);\\n\\n    const ans = [[...intervals[0]]];\\n    for (let [start, end] of intervals) {\\n        const prevEnd = ans[ans.length - 1][1];\\n        if (prevEnd >= start) {\\n            ans[ans.length - 1][1] = Math.max(prevEnd, end);\\n        } else {\\n            ans.push([start, end]);\\n        }\\n    }\\n\\n    return ans;\\n};\\n\\nvar countWays = function (intervals) {\\n    intervals = merge(intervals);\\n\\n    let two = BigInt(2);\\n    let n = BigInt(intervals.length);\\n    let MOD = BigInt(10 ** 9 + 7);\\n\\n    return two ** n % MOD;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3257114,
                "title": "merge-intervals-modular-exponentiation-c",
                "content": "```\\nclass Solution {\\n    int power(int x, int n, int mod) {\\n        long long ans = 1;\\n        while(n) {\\n            if(n % 2) ans = (ans * x) % mod;\\n            x = (x * x) % mod;\\n            n /= 2;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        vector<vector<int>> merged;\\n        sort(ranges.begin(), ranges.end());\\n        merged.push_back(ranges[0]);\\n        \\n        for(int i=1; i<ranges.size(); i++) {\\n            if(merged.back()[1] >= ranges[i][0]){\\n                merged.back()[1] = max(merged.back()[1], ranges[i][1]);\\n            }\\n            else merged.push_back(ranges[i]);\\n        }\\n        return power(2, merged.size(), 1e9 + 7);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    int power(int x, int n, int mod) {\\n        long long ans = 1;\\n        while(n) {\\n            if(n % 2) ans = (ans * x) % mod;\\n            x = (x * x) % mod;\\n            n /= 2;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        vector<vector<int>> merged;\\n        sort(ranges.begin(), ranges.end());\\n        merged.push_back(ranges[0]);\\n        \\n        for(int i=1; i<ranges.size(); i++) {\\n            if(merged.back()[1] >= ranges[i][0]){\\n                merged.back()[1] = max(merged.back()[1], ranges[i][1]);\\n            }\\n            else merged.push_back(ranges[i]);\\n        }\\n        return power(2, merged.size(), 1e9 + 7);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256270,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimilar to leecode problem [Merge Intervals](https://leetcode.com/problems/merge-intervals/)\\nstep 1: count the number of intervals which are overlapping and count all of them as a single interval\\nstep 2: if there are n distinct intervals and we have to divide it into two boxes and each box has 2 possibilities whether to take an element or not take\\nso no. of ways=2^n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        // for(auto i:ranges)cout<<i[0]<<\" \"<<i[1]<<endl;\\n        vector<int>prev=ranges[0];\\n        int cnt=1;\\n        for(auto i:ranges){\\n            if(prev[1]>=i[0]){\\n                prev[0]=min(prev[0],i[0]);\\n                prev[1]=max(prev[1],i[1]);\\n            }else {\\n                cnt++;\\n                prev[0]=min(prev[0],i[0]);\\n                prev[1]=max(prev[1],i[1]);\\n            }\\n        }\\n        // cout<<cnt;\\n        int ans=1;\\n        int mod=1e9+7;\\n        for(int i=0;i<cnt;i++){\\n            ans=(ans*2)%mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        // for(auto i:ranges)cout<<i[0]<<\" \"<<i[1]<<endl;\\n        vector<int>prev=ranges[0];\\n        int cnt=1;\\n        for(auto i:ranges){\\n            if(prev[1]>=i[0]){\\n                prev[0]=min(prev[0],i[0]);\\n                prev[1]=max(prev[1],i[1]);\\n            }else {\\n                cnt++;\\n                prev[0]=min(prev[0],i[0]);\\n                prev[1]=max(prev[1],i[1]);\\n            }\\n        }\\n        // cout<<cnt;\\n        int ans=1;\\n        int mod=1e9+7;\\n        for(int i=0;i<cnt;i++){\\n            ans=(ans*2)%mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3788606,
                "title": "sorting-easy-c-beats-95",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Sort** the given intervals and calculate the **number non-overlaping Intervals**.\\n```\\nif number of non overlaping intervals  =  n\\nnumber of possible groups = pow(2,n)\\n```\\n**Note:- Calculate the power of 2 manually instead of Pow() function.**\\n# Complexity\\n- Time complexity:O(N* log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& r) {\\n        sort(r.begin(),r.end());\\n        int end = r[0][1],mod = 1e9+7;\\n        long long ans = 1,count = 1;\\n        for(int i = 0;i<r.size();i++)\\n        {\\n            if(end<r[i][0])\\n            {\\n                count++;\\n                end = r[i][1];\\n            }\\n            else\\n            end = max(end,r[i][1]);\\n        }\\n        for(int i = 0;i<count;i++)\\n        ans = ((ans%mod)*2)%mod;\\n        return ans%mod;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/f9821fe1-e06c-4877-add8-99173de7da68_1689783328.0557287.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nif number of non overlaping intervals  =  n\\nnumber of possible groups = pow(2,n)\\n```\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& r) {\\n        sort(r.begin(),r.end());\\n        int end = r[0][1],mod = 1e9+7;\\n        long long ans = 1,count = 1;\\n        for(int i = 0;i<r.size();i++)\\n        {\\n            if(end<r[i][0])\\n            {\\n                count++;\\n                end = r[i][1];\\n            }\\n            else\\n            end = max(end,r[i][1]);\\n        }\\n        for(int i = 0;i<count;i++)\\n        ans = ((ans%mod)*2)%mod;\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262048,
                "title": "golang-148-ms-17-5-mb",
                "content": "# Complexity\\n- Time complexity: $$O(n * logn)$$\\n- Space complexity: $$O(1)$$\\n# Code\\n```\\nfunc countWays(ranges [][]int) int {\\n\\tsort.Slice(ranges, func(i, j int) bool {\\n\\t\\treturn ranges[i][0] < ranges[j][0]\\n\\t})\\n\\tresult := 2\\n\\tfor i, end := 1, ranges[0][1]; i < len(ranges); i++ {\\n\\t\\tif ranges[i][0] > end {\\n\\t\\t\\tend = ranges[i][1]\\n\\t\\t\\tresult = (result << 1) % 1000000007\\n\\t\\t} else if ranges[i][1] > end {\\n\\t\\t\\tend = ranges[i][1]\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countWays(ranges [][]int) int {\\n\\tsort.Slice(ranges, func(i, j int) bool {\\n\\t\\treturn ranges[i][0] < ranges[j][0]\\n\\t})\\n\\tresult := 2\\n\\tfor i, end := 1, ranges[0][1]; i < len(ranges); i++ {\\n\\t\\tif ranges[i][0] > end {\\n\\t\\t\\tend = ranges[i][1]\\n\\t\\t\\tresult = (result << 1) % 1000000007\\n\\t\\t} else if ranges[i][1] > end {\\n\\t\\t\\tend = ranges[i][1]\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3257383,
                "title": "very-easy-approach-beats-100-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ni) Find the all Non overlapping intervals\\nii) Then the total no. of ways to divide given intervals in two groups is equal to 2^(no. of Non overlapping intervals)\\niii) We count all the overlapping intervals as one as we have to group them in a single group\\n\\n\\n\\n\\nEX- [1,3] , [2,4], [5,7], [6,8]\\n=> \\xA0[1,3] , [2,4] is considered as a Single Interval or single Class which contains two overlapping intervals.\\nsame goes for [5,7], [6,8] - considered as a Single Interval or single Class.\\n=> total count = 1+1 = 2 (non overlapping intervals)\\n=> Ans = 2^2 = 4\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ni) Sort the given vector and then compare the pair of intervals from left to right using a loop. maintain a rem variable (remaining non overlapping intervals) intialize with 0.\\n\\n\\nii) Maintain a temp variable and initialise it with !st interval end point - It should always save the maximum value of the previous and current interval end point.\\n\\n\\niii)\\xA0If there is is a interval that is Non Overlapping then the curr interval start will surely be > prev interval end(temp) => increment the rem in this case\\n\\n\\niv) Do rem++ after the loop ends, as it has not counted the last non overlapping interval. \\xA0\\n\\n\\nv) now finally return the 2^(ans);\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/*\\n\\n\\nclass Solution {\\npublic:\\n\\xA0 \\xA0 int mod = 1e9+7;\\n\\xA0 \\xA0 int countWays(vector<vector<int>>& ran) {\\n\\xA0 \\xA0 \\xA0 \\xA0 sort(ran.begin(), ran.end());\\n\\xA0 \\xA0 \\xA0 \\xA0 int c = 0;\\n\\xA0 \\xA0 \\xA0 \\xA0 int temp = ran[0][1], rem = 0;\\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i=1; i<ran.size(); i++){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(temp < ran[i][0]) rem++;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 temp = max(temp, ran[i][1]);\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 rem++;//for last non overlapping intervals\\n\\xA0 \\xA0 \\xA0 \\xA0 int i=0, ans = 1;\\n\\xA0 \\xA0 \\xA0 \\xA0 while(i<rem){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 ans = 2*ans;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 ans = ans % mod;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 i++;\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 return ans;\\n\\xA0 \\xA0 }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n\\n\\nclass Solution {\\npublic:\\n\\xA0 \\xA0 int mod = 1e9+7;\\n\\xA0 \\xA0 int countWays(vector<vector<int>>& ran) {\\n\\xA0 \\xA0 \\xA0 \\xA0 sort(ran.begin(), ran.end());\\n\\xA0 \\xA0 \\xA0 \\xA0 int c = 0;\\n\\xA0 \\xA0 \\xA0 \\xA0 int temp = ran[0][1], rem = 0;\\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i=1; i<ran.size(); i++){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(temp < ran[i][0]) rem++;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 temp = max(temp, ran[i][1]);\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 rem++;//for last non overlapping intervals\\n\\xA0 \\xA0 \\xA0 \\xA0 int i=0, ans = 1;\\n\\xA0 \\xA0 \\xA0 \\xA0 while(i<rem){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 ans = 2*ans;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 ans = ans % mod;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 i++;\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 return ans;\\n\\xA0 \\xA0 }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257347,
                "title": "beats-100-easy-sorting-binary-exponentiation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf there are n distinct pairs then the no of ways they can be arranged in the required way is 2^n. When say x pairs are overlapping , all of them need to be in the same group . Therefore, x pairs are equivalent to 1 pair. Thus we find the no of those extra pairs and then calculate the effective no of distinct pairs by subtracting from n. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe *find()* function is used to count the number of overlapping ranges in the given set of ranges. It does so by first sorting the ranges in ascending order based on their start values. It then iterates over the sorted ranges, keeping track of the last value seen. If the current range\\'s start value is less than or equal to the previous range\\'s end value or if it is equal to the last value seen, it means that the current range overlaps with the previous range and thus belongs to the same group. In this case, the function increments a counter. Otherwise, it updates the last value seen to the current range\\'s end value. At the end of the loop, the function returns the counter value which represents the number of overlapping ranges.\\n\\nThe *countWays()* function uses the result of the find() function to compute the number of ways in which the ranges can be split into two groups. It subtracts the number of overlapping ranges from the total number of ranges to get the number of non-overlapping ranges. It then uses exponentiation by squaring to compute 2 raised to the power of the number of non-overlapping ranges. This gives the total number of ways to split the ranges into two groups such that no two overlapping ranges belong to different groups.\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(vector<vector<int>>& ranges){\\n        int c=0;\\n        int last=-1;\\n        sort(ranges.begin(),ranges.end());\\n        for(int i=0;i<ranges.size();i++){\\n            if(i!=0&&(ranges[i][0]<=ranges[i-1][1]||last>=ranges[i][0])){\\n                c++;\\n            }\\n            last=max(last,ranges[i][1]);\\n        }\\n        return c;\\n    }\\n    int countWays(vector<vector<int>>& ranges) {\\n        int overlapping=find(ranges);\\n        cout <<overlapping;\\n        long long int x=2;\\n        int y=ranges.size()-overlapping;\\n        long long int ans =1;\\n        while(y>0){\\n            if(y&1){\\n                ans=(ans*x)%1000000007;\\n            }\\n            x=(x*x)%1000000007;\\n            y=y>>1;\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<vector<int>>& ranges){\\n        int c=0;\\n        int last=-1;\\n        sort(ranges.begin(),ranges.end());\\n        for(int i=0;i<ranges.size();i++){\\n            if(i!=0&&(ranges[i][0]<=ranges[i-1][1]||last>=ranges[i][0])){\\n                c++;\\n            }\\n            last=max(last,ranges[i][1]);\\n        }\\n        return c;\\n    }\\n    int countWays(vector<vector<int>>& ranges) {\\n        int overlapping=find(ranges);\\n        cout <<overlapping;\\n        long long int x=2;\\n        int y=ranges.size()-overlapping;\\n        long long int ans =1;\\n        while(y>0){\\n            if(y&1){\\n                ans=(ans*x)%1000000007;\\n            }\\n            x=(x*x)%1000000007;\\n            y=y>>1;\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3257331,
                "title": "kotlin-beats-100-o-n-log-n-with-sorting",
                "content": "# Approach\\nSort ranges by start, then keep track of the max range end up to index i. If the range at index i overlaps the max, then we\\'ll just update the max. Else there is another range which means we must increase count of different range groups.\\n\\nThe answer is multiplied by 2 because every time we find a non overlapping range, we foud a new group of independent ranges.\\n\\nWe can create 2 groups of n different ranges 2^n different ways.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nimport kotlin.math.pow\\nclass Solution {\\n    fun countWays(ranges: Array<IntArray>): Int {\\n        ranges.sortBy { it[0] }\\n        var rangesCount = 1\\n        var lastRange = ranges[0][1]\\n        var ans = 2\\n\\n        for (i in 1 until ranges.size) {\\n            if (lastRange < ranges[i][0]) {\\n                ans = (ans * 2) % 1000000007    \\n            }\\n            \\n            lastRange = maxOf(lastRange, ranges[i][1])\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Sorting"
                ],
                "code": "```\\nimport kotlin.math.pow\\nclass Solution {\\n    fun countWays(ranges: Array<IntArray>): Int {\\n        ranges.sortBy { it[0] }\\n        var rangesCount = 1\\n        var lastRange = ranges[0][1]\\n        var ans = 2\\n\\n        for (i in 1 until ranges.size) {\\n            if (lastRange < ranges[i][0]) {\\n                ans = (ans * 2) % 1000000007    \\n            }\\n            \\n            lastRange = maxOf(lastRange, ranges[i][1])\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256728,
                "title": "c-easy-to-understand-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int power(int n){\\n        int ans=1;\\n        while(n--){\\n            ans=(ans*2)%1000000007;\\n        }\\n        return ans;\\n    }\\n    \\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(), ranges.end());\\n        vector<vector<int>>ans;\\n        for(int i=0; i<ranges.size(); i++){\\n            if(ans.empty()){\\n                ans.push_back(ranges[i]);\\n            }\\n            else{\\n                vector<int> &v=ans.back();\\n                if(ranges[i][0]<=v[1]){\\n                    v[1]=max(v[1],ranges[i][1]);\\n                }\\n                else{\\n                    ans.push_back(ranges[i]);\\n                }\\n            }\\n        }\\n        return power(ans.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int power(int n){\\n        int ans=1;\\n        while(n--){\\n            ans=(ans*2)%1000000007;\\n        }\\n        return ans;\\n    }\\n    \\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(), ranges.end());\\n        vector<vector<int>>ans;\\n        for(int i=0; i<ranges.size(); i++){\\n            if(ans.empty()){\\n                ans.push_back(ranges[i]);\\n            }\\n            else{\\n                vector<int> &v=ans.back();\\n                if(ranges[i][0]<=v[1]){\\n                    v[1]=max(v[1],ranges[i][1]);\\n                }\\n                else{\\n                    ans.push_back(ranges[i]);\\n                }\\n            }\\n        }\\n        return power(ans.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256402,
                "title": "easy-c-solution-o-n-time-complexity-11-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mod=1000000000+7;\\n    \\n    int countWays(vector<vector<int>>& ranges) {\\n        int cnt=1;\\n        sort(ranges.begin(),ranges.end());\\n        int mx=ranges[0][1];\\n        for(int i=1;i<ranges.size();i++)\\n        {\\n            if(ranges[i][0]>mx)\\n                cnt++;\\n            mx=max(mx,ranges[i][1]);\\n            // cout<<ranges[i][0]<<\" \"<<ranges[i][1]<<endl;\\n        }\\n        long long ans=1;\\n        while(cnt--)\\n            ans=(ans*2)%mod;\\n        // cout<<cnt<<endl;\\n        // long long k=pow(2,cnt);\\n        return (ans%mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod=1000000000+7;\\n    \\n    int countWays(vector<vector<int>>& ranges) {\\n        int cnt=1;\\n        sort(ranges.begin(),ranges.end());\\n        int mx=ranges[0][1];\\n        for(int i=1;i<ranges.size();i++)\\n        {\\n            if(ranges[i][0]>mx)\\n                cnt++;\\n            mx=max(mx,ranges[i][1]);\\n            // cout<<ranges[i][0]<<\" \"<<ranges[i][1]<<endl;\\n        }\\n        long long ans=1;\\n        while(cnt--)\\n            ans=(ans*2)%mod;\\n        // cout<<cnt<<endl;\\n        // long long k=pow(2,cnt);\\n        return (ans%mod);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3256324,
                "title": "merge-intervals-power-in-modulo",
                "content": "**QUICK HINTS**:\\n1. Try thinking after merging the overlapping ranges\\n2. Try to think of choices you have\\n4. Make sure to take into consideration Modulo\\n\\n**STEPS:**\\n1. We first merge the intervals OR count number of disjoint intervals (say n).\\n2. Now for each disjoint interval we have 2 choices (EACH). \\n3. Hence, Possible ways = 2^n\\n\\n\\n [**HOW TO MERGE INTERVALS**](https://leetcode.com/problems/merge-intervals/)\\n\\n**CODE:**\\n**Function to calculate power with modulo**\\n```\\nint power(long long x, int y, int p){\\n        int res = 1;\\n        x = x % p; \\n        if (x == 0) return 0;\\n        while (y > 0){\\n            if (y & 1)res = (res*x) % p;\\n            \\n            y = y>>1; // y = y/2\\n            x = (x*x) % p;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Function to merge intervals**\\n\\n```\\nvector<vector<int>> merge(vector<vector<int>>& interval) {\\n        sort(interval.begin(),interval.end());\\n        vector<vector<int>> re;\\n        if(interval.size()==0)\\n            return re;\\n        vector<int> temp=interval[0];\\n        \\n        for(auto it: interval){\\n            if(it[0]<=temp[1]){\\n                temp[1]=max(temp[1],it[1]);\\n                \\n            }\\n            else{\\n                re.push_back(temp);\\n                temp=it;\\n            }\\n        }\\n        re.push_back(temp);\\n        return re;\\n    }\\n```\\n\\n**Count Ways function**\\n\\n```\\nint countWays(vector<vector<int>>& ranges) {\\n        ranges=merge(ranges);\\n        int n=ranges.size();\\n        return power(2,n,1000000007);\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint power(long long x, int y, int p){\\n        int res = 1;\\n        x = x % p; \\n        if (x == 0) return 0;\\n        while (y > 0){\\n            if (y & 1)res = (res*x) % p;\\n            \\n            y = y>>1; // y = y/2\\n            x = (x*x) % p;\\n        }\\n        return res;\\n    }\\n```\n```\\nvector<vector<int>> merge(vector<vector<int>>& interval) {\\n        sort(interval.begin(),interval.end());\\n        vector<vector<int>> re;\\n        if(interval.size()==0)\\n            return re;\\n        vector<int> temp=interval[0];\\n        \\n        for(auto it: interval){\\n            if(it[0]<=temp[1]){\\n                temp[1]=max(temp[1],it[1]);\\n                \\n            }\\n            else{\\n                re.push_back(temp);\\n                temp=it;\\n            }\\n        }\\n        re.push_back(temp);\\n        return re;\\n    }\\n```\n```\\nint countWays(vector<vector<int>>& ranges) {\\n        ranges=merge(ranges);\\n        int n=ranges.size();\\n        return power(2,n,1000000007);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3256323,
                "title": "python-solution-easy-to-understand-very-easy-with-explianation",
                "content": "```\\nclass Solution:\\n    def countWays(self, intervals: List[List[int]]) -> int:\\n\\t\\t\\n\\t\\t# we can move a interval to either grp 1 or grp  2 so  ans will be multiple of two\\n        ans=2\\n\\t\\t\\n\\t\\t# sort the intervals based on first element\\n        intervals.sort(key=lambda x: x[0])\\n\\t\\t\\n\\t\\t# stores the merged intervals\\n        mer = []\\n\\t\\t\\n\\t\\t# traverse intervals one by one and merging them\\n        for interval in intervals:\\n            if not mer or mer[-1][1] < interval[0]:\\n                mer.append(interval)\\n            else:\\n                mer[-1][1] = max(mer[-1][1], interval[1])\\n\\t\\t\\t\\t\\n\\t\\t# finally our ans will be 2**total_merge_intervals because ans may be large it\\'ll take time to\\n\\t\\t# compute modulo so for avoid it pass it to pow and return the ans\\n        return pow(ans,len(mer),1000_000_007)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, intervals: List[List[int]]) -> int:\\n\\t\\t\\n\\t\\t# we can move a interval to either grp 1 or grp  2 so  ans will be multiple of two\\n        ans=2\\n\\t\\t\\n\\t\\t# sort the intervals based on first element\\n        intervals.sort(key=lambda x: x[0])\\n\\t\\t\\n\\t\\t# stores the merged intervals\\n        mer = []\\n\\t\\t\\n\\t\\t# traverse intervals one by one and merging them\\n        for interval in intervals:\\n            if not mer or mer[-1][1] < interval[0]:\\n                mer.append(interval)\\n            else:\\n                mer[-1][1] = max(mer[-1][1], interval[1])\\n\\t\\t\\t\\t\\n\\t\\t# finally our ans will be 2**total_merge_intervals because ans may be large it\\'ll take time to\\n\\t\\t# compute modulo so for avoid it pass it to pow and return the ans\\n        return pow(ans,len(mer),1000_000_007)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256304,
                "title": "simple-solution-of-grouping-together-python",
                "content": "\\n\\n# Approach\\nA question for great revision of using combinations. Treat this question as putting n distinct balls into k different boxes (2 here).\\nIts k ** n\\nWe know there are 2 possible groups only so k = 2.\\nNow if the ranges overlap u dont need to classify them into unique balls but if they donot overlap consider them as unique ball.\\nNow with above method find the number of ways they can be groupped.\\n\\n# Code\\n```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        balls = 1\\n        sortedRange = sorted(ranges, key=lambda x: (x[0], x[1]))\\n        lastSeenRange = sortedRange[0][1]\\n        MOD = 10 ** 9 + 7\\n        for i in range(1, len(sortedRange)):\\n            if sortedRange[i][0] <= lastSeenRange:\\n                lastSeenRange = max(lastSeenRange, sortedRange[i][1])\\n            else:\\n                balls += 1\\n                lastSeenRange = sortedRange[i][1]\\n        return (2 ** balls) % MOD\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        balls = 1\\n        sortedRange = sorted(ranges, key=lambda x: (x[0], x[1]))\\n        lastSeenRange = sortedRange[0][1]\\n        MOD = 10 ** 9 + 7\\n        for i in range(1, len(sortedRange)):\\n            if sortedRange[i][0] <= lastSeenRange:\\n                lastSeenRange = max(lastSeenRange, sortedRange[i][1])\\n            else:\\n                balls += 1\\n                lastSeenRange = sortedRange[i][1]\\n        return (2 ** balls) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256279,
                "title": "9-line-answer-easy-to-understand-c-solution",
                "content": "\\n# Code\\n```\\n\\nconst int MOD = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& a) {\\n        int n = a.size();\\n        sort(a.begin(), a.end());\\n        \\n        int ret = 1;\\n        for (int i = 0, j; i < n; i = j) {\\n            int R = a[i][1];\\n            for (j = i + 1; j < n && a[j][0] <= R; ++j) R = max(R, a[j][1]);\\n            ret = ret * 2LL % MOD;\\n        }\\n        return ret;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\n\\nconst int MOD = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& a) {\\n        int n = a.size();\\n        sort(a.begin(), a.end());\\n        \\n        int ret = 1;\\n        for (int i = 0, j; i < n; i = j) {\\n            int R = a[i][1];\\n            for (j = i + 1; j < n && a[j][0] <= R; ++j) R = max(R, a[j][1]);\\n            ret = ret * 2LL % MOD;\\n        }\\n        return ret;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256245,
                "title": "python3-sort-merge-pow",
                "content": "# Intuition\\nFirst we sort ranges\\nThen we are counting numberOfGroups by merging ranges.\\n\\nFinally we count answer\\nIf group is going into FIRST -> assign 0\\nIf group is going into SECOND -> assign 1\\n\\nThis means that the answer is power of 2.\\n\\n# Code\\n```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort()\\n        A,B=-1,-1 # Artificial first Range, smallest non-Overlapping\\n        numberOfGroups=0\\n        for a,b in ranges:\\n            if B<a:\\n                # starting New Group\\n                numberOfGroups+=1\\n                A,B=a,b\\n            else:\\n                # same Group\\n                B=max(B,b)\\n        return pow(2,numberOfGroups,10**9+7)      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort()\\n        A,B=-1,-1 # Artificial first Range, smallest non-Overlapping\\n        numberOfGroups=0\\n        for a,b in ranges:\\n            if B<a:\\n                # starting New Group\\n                numberOfGroups+=1\\n                A,B=a,b\\n            else:\\n                # same Group\\n                B=max(B,b)\\n        return pow(2,numberOfGroups,10**9+7)      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256132,
                "title": "2-merged-groups",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int fastExpo(int x,int y){\\n        if(y<=1)return y?x:1;\\n        long long  ans=fastExpo(x,y/2);\\n        ans=(ans*ans)%mod;\\n        if(y&1)ans=(ans*x)%mod;\\n        return ans;\\n    }\\n    int countWays(vector<vector<int>>& ranges) {\\n         sort(ranges.begin(),ranges.end());\\n         vector<vector<int>> ans;\\n         for(auto ele:ranges){\\n             if(ans.empty() or ans.back().back() < ele[0])ans.push_back(ele);\\n             else ans.back().back() = max(ans.back().back(), ele[1]);\\n         } \\n        return fastExpo(2,(int)size(ans));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int fastExpo(int x,int y){\\n        if(y<=1)return y?x:1;\\n        long long  ans=fastExpo(x,y/2);\\n        ans=(ans*ans)%mod;\\n        if(y&1)ans=(ans*x)%mod;\\n        return ans;\\n    }\\n    int countWays(vector<vector<int>>& ranges) {\\n         sort(ranges.begin(),ranges.end());\\n         vector<vector<int>> ans;\\n         for(auto ele:ranges){\\n             if(ans.empty() or ans.back().back() < ele[0])ans.push_back(ele);\\n             else ans.back().back() = max(ans.back().back(), ele[1]);\\n         } \\n        return fastExpo(2,(int)size(ans));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256129,
                "title": "python-3-merge-intervals-math",
                "content": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort()\\n        res = [ranges[0]]\\n        \\n        for s1, e1 in ranges[1 : ]:\\n            s2, e2 = res[-1]\\n            \\n            if max(s1, s2) <= min(e1, e2):\\n                res[-1] = [min(s1, s2), max(e1, e2)]\\n            else:\\n                res.append([s1, e1])\\n        \\n        return pow(2, len(res), pow(10, 9) + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort()\\n        res = [ranges[0]]\\n        \\n        for s1, e1 in ranges[1 : ]:\\n            s2, e2 = res[-1]\\n            \\n            if max(s1, s2) <= min(e1, e2):\\n                res[-1] = [min(s1, s2), max(e1, e2)]\\n            else:\\n                res.append([s1, e1])\\n        \\n        return pow(2, len(res), pow(10, 9) + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256104,
                "title": "c-2-merged-intervals-o-n-log-n",
                "content": "**Intuition: Merging** According to the problem statement, all overlapping intervals must be in the same partition. Therefore, we can consider the merged interval of all overlapping intervals as a single interval.\\n**Intuition: 2^N** For each merged interval now, we can make a choice: put it in group 1 or group 2. Thus, we will have 2 choices for each interval. As we continue to make choices, we will have had 2 * 2 * 2 * 2... choices.\\nWe will merge all intervals then compute 2^n modulo 1e9+7 to return the final answer. Merging intervals is a classic problem, so you can use a snippet from [here](https://leetcode.com/problems/merge-intervals/discuss/?currentPage=1&orderBy=most_votes&query=) to save time.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < intervals.size(); i++){\\n            vector<int> current = intervals[i];\\n            while(i+1 < intervals.size() && (intervals[i+1][0] <= current[1])){\\n                current = {min(current[0], intervals[i+1][0]), max(current[1], intervals[i+1][1])};\\n                i++;\\n            }\\n            ans.push_back(current);\\n        }        \\n        return ans;\\n    }\\n    const int MOD = 1e9+7;\\n    int countWays(vector<vector<int>>& ranges) {\\n        auto v = merge(ranges);\\n        long long ans = 1;\\n        for(int i = 0; i < v.size(); i++){\\n            ans*=2;\\n            ans %= MOD;\\n        }\\n        return ans;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < intervals.size(); i++){\\n            vector<int> current = intervals[i];\\n            while(i+1 < intervals.size() && (intervals[i+1][0] <= current[1])){\\n                current = {min(current[0], intervals[i+1][0]), max(current[1], intervals[i+1][1])}",
                "codeTag": "Java"
            },
            {
                "id": 3986319,
                "title": "scanline-o-nlogn",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        new = []\\n        for start, end in ranges:\\n            new.append((start, -1))\\n            new.append((end, 1))\\n        new = sorted(new)\\n\\n        s = 0\\n        groups = 0\\n        for d, t in new:\\n            if t == -1:\\n                s += 1\\n            else:\\n                s -= 1\\n            \\n            if s == 0:\\n                groups += 1\\n        \\n        return (2 ** groups) % (int(1e9+7))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        new = []\\n        for start, end in ranges:\\n            new.append((start, -1))\\n            new.append((end, 1))\\n        new = sorted(new)\\n\\n        s = 0\\n        groups = 0\\n        for d, t in new:\\n            if t == -1:\\n                s += 1\\n            else:\\n                s -= 1\\n            \\n            if s == 0:\\n                groups += 1\\n        \\n        return (2 ** groups) % (int(1e9+7))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985134,
                "title": "golang-100-solution",
                "content": "# Code\\n```go\\nfunc countWays(ranges [][]int) int {\\n\\tsort.Slice(ranges, func(i, j int) bool {\\n\\t\\tif ranges[i][0] == ranges[j][0] {\\n\\t\\t\\treturn ranges[i][1] < ranges[j][1]\\n\\t\\t}\\n\\t\\treturn ranges[i][0] < ranges[j][0]\\n\\t})\\n\\tprevEnd := -1\\n\\tdistinct := 0\\n\\tfor _, v := range ranges {\\n\\t\\tif v[0] > prevEnd {\\n\\t\\t\\tdistinct++\\n\\t\\t\\tprevEnd = v[1]\\n\\t\\t} else {\\n\\t\\t\\tif v[1] > prevEnd {\\n\\t\\t\\t\\tprevEnd = v[1]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tways := 1\\n\\tfor i := 0; i < distinct; i++ {\\n\\t\\tways *= 2\\n\\t\\tways %= 1000000007\\n\\t}\\n\\treturn ways\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc countWays(ranges [][]int) int {\\n\\tsort.Slice(ranges, func(i, j int) bool {\\n\\t\\tif ranges[i][0] == ranges[j][0] {\\n\\t\\t\\treturn ranges[i][1] < ranges[j][1]\\n\\t\\t}\\n\\t\\treturn ranges[i][0] < ranges[j][0]\\n\\t})\\n\\tprevEnd := -1\\n\\tdistinct := 0\\n\\tfor _, v := range ranges {\\n\\t\\tif v[0] > prevEnd {\\n\\t\\t\\tdistinct++\\n\\t\\t\\tprevEnd = v[1]\\n\\t\\t} else {\\n\\t\\t\\tif v[1] > prevEnd {\\n\\t\\t\\t\\tprevEnd = v[1]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tways := 1\\n\\tfor i := 0; i < distinct; i++ {\\n\\t\\tways *= 2\\n\\t\\tways %= 1000000007\\n\\t}\\n\\treturn ways\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3933445,
                "title": "merge-intervals-to-find-non-overlapping-intervals-2-non-overlapping-ranges",
                "content": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        \"\"\"\\n        identify the number of non overlapping intervals\\n        let non overlapping intervals be x\\n        total ways = 2^x\\n        we can find non overlapping intervals by using the \\n        logic of merge intervals\\n        \"\"\"\\n        ranges = sorted(ranges, key=lambda x: x[0])\\n        result = [ranges[0]]\\n        for i in range(1, len(ranges)):\\n            c, d = ranges[i][:]\\n            a, b = result[-1][:]\\n            if a<=d and b>=c:\\n                # points overlap\\n                result.pop()\\n                result.append((min(a,c), max(b,d)))\\n            else:\\n                result.append((c,d))\\n        # print(result)\\n        return pow(2, len(result)) % (pow(10,9) + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        \"\"\"\\n        identify the number of non overlapping intervals\\n        let non overlapping intervals be x\\n        total ways = 2^x\\n        we can find non overlapping intervals by using the \\n        logic of merge intervals\\n        \"\"\"\\n        ranges = sorted(ranges, key=lambda x: x[0])\\n        result = [ranges[0]]\\n        for i in range(1, len(ranges)):\\n            c, d = ranges[i][:]\\n            a, b = result[-1][:]\\n            if a<=d and b>=c:\\n                # points overlap\\n                result.pop()\\n                result.append((min(a,c), max(b,d)))\\n            else:\\n                result.append((c,d))\\n        # print(result)\\n        return pow(2, len(result)) % (pow(10,9) + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928864,
                "title": "ruby-o-nlogn",
                "content": "```ruby\\n# @param {Integer[][]} ranges\\n# @return {Integer}\\ndef count_ways(ranges)\\n  sorted_ranges = ranges.sort\\n  window_right, res = -1, 1\\n  sorted_ranges.each { | left, right |\\n    res = res * (window_right < left ? 2 : 1) % 1000000007\\n    window_right = [window_right, right].max\\n  }\\n  res\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {Integer[][]} ranges\\n# @return {Integer}\\ndef count_ways(ranges)\\n  sorted_ranges = ranges.sort\\n  window_right, res = -1, 1\\n  sorted_ranges.each { | left, right |\\n    res = res * (window_right < left ? 2 : 1) % 1000000007\\n    window_right = [window_right, right].max\\n  }\\n  res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3839343,
                "title": "c-solution-using-sorting-and-power-of-2",
                "content": "# Complexity\\n- Time complexity:\\n$$O(nlogn) + O(n) + O(mergedRanges.size())$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    #define ll long long\\n\\n    ll dp[100001];\\n    ll twoPowerN(int n){\\n        if(n == 0)\\n            return 1;\\n        if(n == 1)\\n            return 2;\\n\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        \\n        if(n%2==0){\\n            return dp[n] = (twoPowerN(n/2)%mod * twoPowerN(n/2)%mod)%mod;\\n        }\\n        return dp[n] = ((twoPowerN(n/2)%mod * twoPowerN(n/2)%mod)%mod * 2)%mod;\\n    }\\n\\n\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(), ranges.end());\\n        vector<vector<int>>mergedRanges;\\n        vector<int>temp = ranges[0];\\n\\n        for(int i=1;i<ranges.size();i++){\\n            if(max(ranges[i][0], temp[0]) <= min(ranges[i][1], temp[1])){\\n                temp[1] = max(temp[1], ranges[i][1]);\\n            }\\n            else{\\n                mergedRanges.push_back(temp);\\n                temp = ranges[i];\\n            }\\n        }\\n\\n        mergedRanges.push_back(temp);\\n        int n = mergedRanges.size();\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return (int)twoPowerN(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    #define ll long long\\n\\n    ll dp[100001];\\n    ll twoPowerN(int n){\\n        if(n == 0)\\n            return 1;\\n        if(n == 1)\\n            return 2;\\n\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        \\n        if(n%2==0){\\n            return dp[n] = (twoPowerN(n/2)%mod * twoPowerN(n/2)%mod)%mod;\\n        }\\n        return dp[n] = ((twoPowerN(n/2)%mod * twoPowerN(n/2)%mod)%mod * 2)%mod;\\n    }\\n\\n\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(), ranges.end());\\n        vector<vector<int>>mergedRanges;\\n        vector<int>temp = ranges[0];\\n\\n        for(int i=1;i<ranges.size();i++){\\n            if(max(ranges[i][0], temp[0]) <= min(ranges[i][1], temp[1])){\\n                temp[1] = max(temp[1], ranges[i][1]);\\n            }\\n            else{\\n                mergedRanges.push_back(temp);\\n                temp = ranges[i];\\n            }\\n        }\\n\\n        mergedRanges.push_back(temp);\\n        int n = mergedRanges.size();\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return (int)twoPowerN(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822766,
                "title": "simple-c-solution-100-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- It is given that all overlapping ranges should belong to same group, so we can treat the overlapping ranges as one big range.\\n- We need to find ways to put X items into two groups, which can be found by Math calculation 2^X\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n*Sort the range-array and iterate over the array to find the number of non-overlapping/independent ranges available if we had merged all overlapping ranges into one large range*. This gives us \\'X\\'.\\nReturn 2^X.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NLogN) - as we are sorting the range array\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)  - as we are not using any extra memory space for computation.\\n\\n\\n---\\n\\n\\n## Please upvote if you like the approach\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountWays(int[][] ranges) {\\n        int n = ranges.Length;\\n        Array.Sort(ranges, (a, b) => a[0] - b[0]);\\n        int groupCount = 0;\\n        long end = ranges[0][1];\\n\\n        for (int i = 0; i < n - 1; i++)\\n        {\\n            if (ranges[i + 1][0] > end)\\n            {\\n                groupCount++;\\n            }\\n            end = Math.Max(end, ranges[i + 1][1]);\\n        }\\n        groupCount++;\\n\\n        return PowerOfTwo(groupCount);\\n    }\\n\\n    //Since 2^X can be a very large value we can use this method to calculate the Pow(x,n)\\n    //[OR] we can use built-in BigInteger ModPow function to do the same\\n    private int PowerOfTwo(int n)\\n    {\\n        int mod = 1_000_000_007;\\n        long result = 1;\\n        long x = 2;\\n\\n        while (n > 0)\\n        {\\n            if (n % 2 == 1)\\n            {\\n                result = (result * x) % mod;\\n            }\\n\\n            x = (x * x) % mod;\\n            n /= 2;\\n        }\\n\\n        return (int)result;\\n    }\\n}\\n```\\n\\n---\\n\\n\\n\\n## Please upvote if you like the approach\\n![Upvote please - Cat.jpg](https://assets.leetcode.com/users/images/40bd4d6d-bd38-42b7-8239-459c805f672f_1690447325.3225265.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountWays(int[][] ranges) {\\n        int n = ranges.Length;\\n        Array.Sort(ranges, (a, b) => a[0] - b[0]);\\n        int groupCount = 0;\\n        long end = ranges[0][1];\\n\\n        for (int i = 0; i < n - 1; i++)\\n        {\\n            if (ranges[i + 1][0] > end)\\n            {\\n                groupCount++;\\n            }\\n            end = Math.Max(end, ranges[i + 1][1]);\\n        }\\n        groupCount++;\\n\\n        return PowerOfTwo(groupCount);\\n    }\\n\\n    //Since 2^X can be a very large value we can use this method to calculate the Pow(x,n)\\n    //[OR] we can use built-in BigInteger ModPow function to do the same\\n    private int PowerOfTwo(int n)\\n    {\\n        int mod = 1_000_000_007;\\n        long result = 1;\\n        long x = 2;\\n\\n        while (n > 0)\\n        {\\n            if (n % 2 == 1)\\n            {\\n                result = (result * x) % mod;\\n            }\\n\\n            x = (x * x) % mod;\\n            n /= 2;\\n        }\\n\\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819581,
                "title": "c-concise-o-nlogn-time-o-1-space-mult-by-2-for-evry-group",
                "content": "# Intuition\\nSplit ranges into groups of intervals, each interval group can go into either 1 or 2 final group => number of ways to split groups is 2 ^ number of range groups\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) \\n    {\\n        sort(ranges.begin(), ranges.end());\\n\\n        uint64_t res{ 1 };\\n        int intervalsGroupEnd{ -1 };\\n        for (auto& r : ranges)\\n        {\\n            if (intervalsGroupEnd < r[0])\\n                res = (res * 2) % 1000000007;\\n\\n            intervalsGroupEnd = max(intervalsGroupEnd, r[1]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) \\n    {\\n        sort(ranges.begin(), ranges.end());\\n\\n        uint64_t res{ 1 };\\n        int intervalsGroupEnd{ -1 };\\n        for (auto& r : ranges)\\n        {\\n            if (intervalsGroupEnd < r[0])\\n                res = (res * 2) % 1000000007;\\n\\n            intervalsGroupEnd = max(intervalsGroupEnd, r[1]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765241,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly I sort the 2d vector and made a new 2d vector which stored the interval in such a way that the 2 interval having common elements ,combine that both interval and store that new interval in it.\\n\\nAnd the size of that 2d vector would be the orginal count of intervals that I had to split into 2 groups.\\n\\nFor spliting ways ans would be power(2,size);\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\ndouble MOD = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n\\n        vector<vector<int>> ans;\\n\\n        ans.push_back(ranges[0]);\\n\\n        for(int i =1;i < ranges.size();i++){\\n\\n            if(ans[ans.size() -1][1] >= ranges[i][0]){\\n\\n                ans[ans.size() -1][1] = max(ranges[i][1],ans[ans.size() -1][1]);\\n\\n            }\\n            else{\\n                ans.push_back(ranges[i]);\\n            }\\n        }\\n\\n        for(auto it : ans){\\n            cout<<it[0]<<\" \"<<it[1]<<\"\\\\n\";\\n        }\\n\\n        int count = ans.size();\\n\\n        long long anss = 1;\\n\\n        while(count--){\\n            anss = (int)(anss*2)%(int)MOD;\\n        }\\n\\n        return anss;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\n\\ndouble MOD = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n\\n        vector<vector<int>> ans;\\n\\n        ans.push_back(ranges[0]);\\n\\n        for(int i =1;i < ranges.size();i++){\\n\\n            if(ans[ans.size() -1][1] >= ranges[i][0]){\\n\\n                ans[ans.size() -1][1] = max(ranges[i][1],ans[ans.size() -1][1]);\\n\\n            }\\n            else{\\n                ans.push_back(ranges[i]);\\n            }\\n        }\\n\\n        for(auto it : ans){\\n            cout<<it[0]<<\" \"<<it[1]<<\"\\\\n\";\\n        }\\n\\n        int count = ans.size();\\n\\n        long long anss = 1;\\n\\n        while(count--){\\n            anss = (int)(anss*2)%(int)MOD;\\n        }\\n\\n        return anss;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3746548,
                "title": "python-easy-solution-95-percent-beats",
                "content": "# Intuition\\nFind number of overlapping ranges or distinct objects available. Return 2 to the power of number of distinct objects\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort()\\n        objects = 1\\n        x, y = ranges[0][0], ranges[0][1]\\n        for i in range(1, len(ranges)):\\n            curr_x, curr_y = ranges[i]\\n            if y >= curr_x:\\n                y = max(y, curr_y)\\n            else:\\n                objects += 1\\n                x, y = curr_x, curr_y\\n        return (2 ** objects) % (10**9 + 7)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort()\\n        objects = 1\\n        x, y = ranges[0][0], ranges[0][1]\\n        for i in range(1, len(ranges)):\\n            curr_x, curr_y = ranges[i]\\n            if y >= curr_x:\\n                y = max(y, curr_y)\\n            else:\\n                objects += 1\\n                x, y = curr_x, curr_y\\n        return (2 ** objects) % (10**9 + 7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721252,
                "title": "c-sweep-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can split all the ranges into as much parts as possible where no two parts intersect with one another. Having this done we can put these parts inpendently ino either left or right group and get $2^n$ possibilities: from `000..0` - all parts are in the 1st group up to `111..1` - all parts are in the 2nd group.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n*Sweep line* to `count` number of independent parts, then fast power algorithm  to compute $2^n mod (1000000007)$.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * log(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountWays(int[][] ranges) {\\n        Array.Sort(ranges, (a, b) => a[0].CompareTo(b[0]));    \\n\\n        int count = 0; \\n        int last = int.MinValue;\\n\\n        foreach (int[] range in ranges) {\\n            if (range[0] > last) \\n                count += 1;\\n\\n            last = Math.Max(last, range[1]);\\n        }\\n\\n        return (int) (BigInteger.ModPow(2, count, 1_000_000_007));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountWays(int[][] ranges) {\\n        Array.Sort(ranges, (a, b) => a[0].CompareTo(b[0]));    \\n\\n        int count = 0; \\n        int last = int.MinValue;\\n\\n        foreach (int[] range in ranges) {\\n            if (range[0] > last) \\n                count += 1;\\n\\n            last = Math.Max(last, range[1]);\\n        }\\n\\n        return (int) (BigInteger.ModPow(2, count, 1_000_000_007));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719008,
                "title": "o-nlogn-time-o-1-space-python3-solution",
                "content": "```\\nclass Solution:\\n    \\n    # O(nlogn) time,\\n    # O(1) space,\\n    # Approach: math, sorting, \\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort()\\n        groups = 1\\n        prev_max = ranges[0][1]\\n        \\n        for i in range(1, len(ranges)):\\n            curr_range = ranges[i]\\n            \\n            if prev_max < curr_range[0]:\\n                groups += 1\\n            prev_max = max(prev_max, curr_range[1])\\n        \\n        ans = 2**groups\\n        ans %= 10**9 + 7\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # O(nlogn) time,\\n    # O(1) space,\\n    # Approach: math, sorting, \\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort()\\n        groups = 1\\n        prev_max = ranges[0][1]\\n        \\n        for i in range(1, len(ranges)):\\n            curr_range = ranges[i]\\n            \\n            if prev_max < curr_range[0]:\\n                groups += 1\\n            prev_max = max(prev_max, curr_range[1])\\n        \\n        ans = 2**groups\\n        ans %= 10**9 + 7\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704881,
                "title": "simple-o-n-python-solution-with-intuition-beats-96",
                "content": "# Intuition\\nFind the number of non-overlapping ranges, which we will call n. Since each of these ranges will go in group 1 or group 2, there are 2^n possibilities. Return 2^n % (10^9 + 7).\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        \\n        non_overlapping_ranges = 1\\n        ranges.sort()\\n        curr_end = ranges[0][1]\\n\\n        for r_start, r_end in ranges:\\n            #overlap\\n            if r_start <= curr_end:\\n                curr_end = max(curr_end, r_end)\\n                \\n            #non overlap    \\n            else:\\n                non_overlapping_ranges += 1\\n                curr_end = r_end\\n\\n        return 2 ** non_overlapping_ranges % (10**9 +7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        \\n        non_overlapping_ranges = 1\\n        ranges.sort()\\n        curr_end = ranges[0][1]\\n\\n        for r_start, r_end in ranges:\\n            #overlap\\n            if r_start <= curr_end:\\n                curr_end = max(curr_end, r_end)\\n                \\n            #non overlap    \\n            else:\\n                non_overlapping_ranges += 1\\n                curr_end = r_end\\n\\n        return 2 ** non_overlapping_ranges % (10**9 +7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643877,
                "title": "rust-functional-using-fold",
                "content": "# Intuition\\nSort by array start range and then fold an accumulator that contains the result\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst MOD: i32 = 1_000_000_000 + 7;\\nimpl Solution {\\n    pub fn count_ways(mut ranges: Vec<Vec<i32>>) -> i32 {\\n        // Assuming that sorting by start is enough to get overlaping together\\n        ranges.sort_by_key(|r| *r.get(0).unwrap());\\n\\n        ranges.into_iter().fold(\\n            (1, (i32::MIN, i32::MIN)), \\n            |(mut combinations, mut group), range| {\\n                let start = *range.get(0).unwrap();\\n                let end = *range.get(1).unwrap();\\n                \\n                if group.0 <= start && start <= group.1 {\\n                    group.1 = end.max(group.1);\\n                } else {\\n                    group = (start, end);\\n                    combinations = (2 * combinations) % MOD;\\n                }\\n                return (combinations, group)\\n        }).0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nconst MOD: i32 = 1_000_000_000 + 7;\\nimpl Solution {\\n    pub fn count_ways(mut ranges: Vec<Vec<i32>>) -> i32 {\\n        // Assuming that sorting by start is enough to get overlaping together\\n        ranges.sort_by_key(|r| *r.get(0).unwrap());\\n\\n        ranges.into_iter().fold(\\n            (1, (i32::MIN, i32::MIN)), \\n            |(mut combinations, mut group), range| {\\n                let start = *range.get(0).unwrap();\\n                let end = *range.get(1).unwrap();\\n                \\n                if group.0 <= start && start <= group.1 {\\n                    group.1 = end.max(group.1);\\n                } else {\\n                    group = (start, end);\\n                    combinations = (2 * combinations) % MOD;\\n                }\\n                return (combinations, group)\\n        }).0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592884,
                "title": "understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        \\n        long mod = (long)Math.pow(10,9) + (long)7 ; \\n        \\n        Arrays.sort(ranges , (a,b) -> a[0] - b[0]) ; \\n        \\n        // for( int i = 0 ; i < ranges.length; i++)\\n        //  {\\n              \\n        //       System.out.println( ranges[i][0] + \" \" + ranges[i][1]) ; \\n        //  }\\n        \\n         long count = (long)1 ;\\n         \\n         int min = ranges[0][0] ; \\n         \\n         int max = ranges[0][1] ; \\n        \\n          for( int i = 1 ; i< ranges.length; i++)\\n         {\\n              int temp[] = ranges[i] ; \\n               \\n              \\n              if( temp[0] >= min && temp[0] <= max) \\n              {\\n                  if(temp[1] > max)\\n                  max = temp[1]  ; \\n                  \\n                  \\n                 continue ;\\n              }\\n              else \\n              {\\n\\n                 min = temp[0] ; \\n                  max = temp[1]  ; \\n                  \\n                  count++ ; \\n\\n                  count = count % mod ; \\n\\n                  \\n              }\\n         }\\n         \\n        //  System.out.println(count) ; \\n         \\n         \\n         \\n         \\n         \\n          \\n          \\n        //  long answer = (long)Math.pow(2,count) ; \\n        // jab ye formula laga re the tab bhi answer long se bhaar ja ra tha isliye overflow ki wajah se\\n        // wrong answer aa ra tha ; therefore humein ek ek karke multiply karna padhega \\n\\n        long answer = 1 ; \\n\\n        for( int i = 0 ; i < count ; i++)\\n        {\\n            answer = answer * 2 ; \\n\\n            answer = answer % mod ; \\n        }\\n\\n         answer =  answer % mod ; \\n\\n        \\n         return (int)answer ; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        \\n        long mod = (long)Math.pow(10,9) + (long)7 ; \\n        \\n        Arrays.sort(ranges , (a,b) -> a[0] - b[0]) ; \\n        \\n        // for( int i = 0 ; i < ranges.length; i++)\\n        //  {\\n              \\n        //       System.out.println( ranges[i][0] + \" \" + ranges[i][1]) ; \\n        //  }\\n        \\n         long count = (long)1 ;\\n         \\n         int min = ranges[0][0] ; \\n         \\n         int max = ranges[0][1] ; \\n        \\n          for( int i = 1 ; i< ranges.length; i++)\\n         {\\n              int temp[] = ranges[i] ; \\n               \\n              \\n              if( temp[0] >= min && temp[0] <= max) \\n              {\\n                  if(temp[1] > max)\\n                  max = temp[1]  ; \\n                  \\n                  \\n                 continue ;\\n              }\\n              else \\n              {\\n\\n                 min = temp[0] ; \\n                  max = temp[1]  ; \\n                  \\n                  count++ ; \\n\\n                  count = count % mod ; \\n\\n                  \\n              }\\n         }\\n         \\n        //  System.out.println(count) ; \\n         \\n         \\n         \\n         \\n         \\n          \\n          \\n        //  long answer = (long)Math.pow(2,count) ; \\n        // jab ye formula laga re the tab bhi answer long se bhaar ja ra tha isliye overflow ki wajah se\\n        // wrong answer aa ra tha ; therefore humein ek ek karke multiply karna padhega \\n\\n        long answer = 1 ; \\n\\n        for( int i = 0 ; i < count ; i++)\\n        {\\n            answer = answer * 2 ; \\n\\n            answer = answer % mod ; \\n        }\\n\\n         answer =  answer % mod ; \\n\\n        \\n         return (int)answer ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552023,
                "title": "sweep-line-variation",
                "content": "# Approach\\nUsual sweep line would merge [a, b] and [b+1, c].\\nSince integral intervals are given, shrink 0.5 doesn\\'t affect the elements interval contains, it resolves the merge issue.\\n\\n# Complexity\\n- Time complexity: O(N), N: range.length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        D = defaultdict(int)\\n        \\n        for s, e in ranges:\\n            D[s] += 1\\n            D[e+0.5] -= 1\\n        \\n        n = 0\\n        ret = 0\\n        #print(sorted(D.items()))\\n        \\n        for k, v in sorted(D.items()):\\n            n += v\\n            \\n            if n == 0:\\n                ret += 1\\n\\n        return 2 ** ret % 1000000007\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Line Sweep"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        D = defaultdict(int)\\n        \\n        for s, e in ranges:\\n            D[s] += 1\\n            D[e+0.5] -= 1\\n        \\n        n = 0\\n        ret = 0\\n        #print(sorted(D.items()))\\n        \\n        for k, v in sorted(D.items()):\\n            n += v\\n            \\n            if n == 0:\\n                ret += 1\\n\\n        return 2 ** ret % 1000000007\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502501,
                "title": "rust-python-explanation",
                "content": "# Intuition\\nTo be able to combine overlapping intervals in efficient manner you need to sort an array. Then you can in constant time check if the next interval overlaps with the current one.\\n\\nNow when an intervals is joined with already existed intervals, there can be 2 ways to divide them, so we multiply by 2.\\n\\n# Complexity\\n- Time complexity: $O(n \\\\log n)$\\n- Space complexity: $O(1)$\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n  pub fn count_ways(mut arr: Vec<Vec<i32>>) -> i32 {\\n    arr.sort_unstable();\\n    const m: u64 = 1000000007;\\n    let mut res: u64 = 1;\\n    let mut last_r = -1;\\n\\n    for int in arr {\\n      if int[0] > last_r {\\n        last_r = int[1];\\n        res = (res * 2) % m;\\n      } else {\\n        last_r = last_r.max(int[1]);\\n      }\\n    }\\n\\n    return res as i32;\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n  def countWays(self, arr: List[List[int]]) -> int:\\n    res, last_r, mod = 1, -1, 10**9 + 7\\n    arr.sort()\\n\\n    for v in arr:\\n      if v[0] > last_r:\\n        res = (res * 2) % mod\\n        last_r = v[1]\\n      else:\\n        last_r = max(last_r, v[1])\\n\\n    return res\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Rust"
                ],
                "code": "```Rust []\\nimpl Solution {\\n  pub fn count_ways(mut arr: Vec<Vec<i32>>) -> i32 {\\n    arr.sort_unstable();\\n    const m: u64 = 1000000007;\\n    let mut res: u64 = 1;\\n    let mut last_r = -1;\\n\\n    for int in arr {\\n      if int[0] > last_r {\\n        last_r = int[1];\\n        res = (res * 2) % m;\\n      } else {\\n        last_r = last_r.max(int[1]);\\n      }\\n    }\\n\\n    return res as i32;\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n  def countWays(self, arr: List[List[int]]) -> int:\\n    res, last_r, mod = 1, -1, 10**9 + 7\\n    arr.sort()\\n\\n    for v in arr:\\n      if v[0] > last_r:\\n        res = (res * 2) % mod\\n        last_r = v[1]\\n      else:\\n        last_r = max(last_r, v[1])\\n\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440935,
                "title": "c-simple-sorting-o-nlog-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        long long ans=1;\\n        int mod=1e9+7;\\n        sort(ranges.begin(),ranges.end());\\n        for(int i=0;i<ranges.size();i++){\\n            int end=ranges[i][1];\\n            while(i<ranges.size() && ranges[i][0]<=end){\\n                end=max(end,ranges[i][1]);\\n                i++;\\n            }\\n            if(i<ranges.size()) i--; \\n            ans*=2;\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        long long ans=1;\\n        int mod=1e9+7;\\n        sort(ranges.begin(),ranges.end());\\n        for(int i=0;i<ranges.size();i++){\\n            int end=ranges[i][1];\\n            while(i<ranges.size() && ranges[i][0]<=end){\\n                end=max(end,ranges[i][1]);\\n                i++;\\n            }\\n            if(i<ranges.size()) i--; \\n            ans*=2;\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383600,
                "title": "easy-c-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n    long long mod =1e9+7;\\n     vector<pair<int,int>>v;\\n        for(auto it:ranges){\\n            v.push_back({it[0],it[1]});\\n        }\\n        sort(v.begin(),v.end());\\n        stack<pair<int,int>>q;\\n        int ans=1;\\n        q.push({v[0].first,v[0].second});\\n        for(int i =1;i<v.size();i++){\\n            auto it=q.top();\\n            q.pop();\\n            int start =it.first;\\n            int end   =it.second;\\n            if(v[i].first>=start&&v[i].first<=end){\\n                q.push({min(start,v[i].first),max(end,v[i].second)});\\n            }\\n            else {\\n                ans++;\\n                q.push({v[i].first,v[i].second});\\n            }\\n        }\\n        long long res=1;\\n        for(int i =0;i<ans;i++){\\n           res= (2*res)%mod;\\n        }\\n       int resf=res%mod;\\n        return resf;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n    long long mod =1e9+7;\\n     vector<pair<int,int>>v;\\n        for(auto it:ranges){\\n            v.push_back({it[0],it[1]});\\n        }\\n        sort(v.begin(),v.end());\\n        stack<pair<int,int>>q;\\n        int ans=1;\\n        q.push({v[0].first,v[0].second});\\n        for(int i =1;i<v.size();i++){\\n            auto it=q.top();\\n            q.pop();\\n            int start =it.first;\\n            int end   =it.second;\\n            if(v[i].first>=start&&v[i].first<=end){\\n                q.push({min(start,v[i].first),max(end,v[i].second)});\\n            }\\n            else {\\n                ans++;\\n                q.push({v[i].first,v[i].second});\\n            }\\n        }\\n        long long res=1;\\n        for(int i =0;i<ans;i++){\\n           res= (2*res)%mod;\\n        }\\n       int resf=res%mod;\\n        return resf;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333536,
                "title": "count-ways-to-group-overlapping-ranges-c-solution",
                "content": "C++  Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        \\n        int m=1e9+7;\\n        sort(ranges.begin(),ranges.end());\\n        int ans=1;\\n        \\n        int mx=0;\\n        for(int i=0;i<ranges.size()-1;i++)\\n        {\\n            mx=max(mx,ranges[i][1]);\\n            if(ranges[i][1]<ranges[i+1][0]&&mx<ranges[i+1][0])\\n            {\\n               ans=(ans*2)%m; \\n            }\\n        }\\n        \\n        return (2*ans)%m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        \\n        int m=1e9+7;\\n        sort(ranges.begin(),ranges.end());\\n        int ans=1;\\n        \\n        int mx=0;\\n        for(int i=0;i<ranges.size()-1;i++)\\n        {\\n            mx=max(mx,ranges[i][1]);\\n            if(ranges[i][1]<ranges[i+1][0]&&mx<ranges[i+1][0])\\n            {\\n               ans=(ans*2)%m; \\n            }\\n        }\\n        \\n        return (2*ans)%m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331263,
                "title": "c-sorting-math-faster-easy-to-understand",
                "content": "* ***Sorting***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        \\n        int n = ranges.size();\\n        \\n        long long mod = 1e9 + 7;\\n        \\n        // sort the ranges such that starts in ascending order\\n        \\n        sort(ranges.begin(), ranges.end());\\n        \\n        // find the no. of different groups\\n        \\n        vector<vector<int>> intervals;\\n        \\n        intervals.push_back(ranges[0]);\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            // merge the intervals\\n            \\n            if(ranges[i][0] <= intervals.back()[1])\\n            {\\n                int start = intervals.back()[0];\\n                \\n                int end = max(intervals.back()[1], ranges[i][1]);\\n                \\n                intervals.pop_back();\\n                \\n                intervals.push_back({start, end});\\n            }\\n            else\\n            {\\n                intervals.push_back(ranges[i]);\\n            }\\n        }\\n        \\n        int groups = intervals.size();\\n        \\n        // every group has 2 ways\\n        \\n        int ans = 1;\\n        \\n        for(int i = 1; i <= groups; i++)\\n        {\\n            ans = (ans % mod * 2 % mod) % mod;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        \\n        int n = ranges.size();\\n        \\n        long long mod = 1e9 + 7;\\n        \\n        // sort the ranges such that starts in ascending order\\n        \\n        sort(ranges.begin(), ranges.end());\\n        \\n        // find the no. of different groups\\n        \\n        vector<vector<int>> intervals;\\n        \\n        intervals.push_back(ranges[0]);\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            // merge the intervals\\n            \\n            if(ranges[i][0] <= intervals.back()[1])\\n            {\\n                int start = intervals.back()[0];\\n                \\n                int end = max(intervals.back()[1], ranges[i][1]);\\n                \\n                intervals.pop_back();\\n                \\n                intervals.push_back({start, end});\\n            }\\n            else\\n            {\\n                intervals.push_back(ranges[i]);\\n            }\\n        }\\n        \\n        int groups = intervals.size();\\n        \\n        // every group has 2 ways\\n        \\n        int ans = 1;\\n        \\n        for(int i = 1; i <= groups; i++)\\n        {\\n            ans = (ans % mod * 2 % mod) % mod;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326145,
                "title": "simple-merge-intervals-nothing-else",
                "content": "# Intuition\\nSimple merge Intervals\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n   \\n   class Pair{\\n\\n       int start;int end=0;\\n\\n       Pair(int start,int end){\\n           this.start=start;\\n           this.end=end;\\n       }\\n   }\\n\\n\\n    public int countWays(int[][] ranges) {\\n        Stack<Pair>st=new Stack<>();\\n        Arrays.sort(ranges,Comparator.comparingInt(r -> r[0]));\\n           st.add(new Pair(ranges[0][0],ranges[0][1]));\\n\\n           for(int i=1;i<ranges.length;i++){\\n\\n               if(ranges[i][0]<=st.peek().end){\\n                st.peek().end=Math.max(ranges[i][1],st.peek().end);\\n               }\\n               else{\\n                 st.push(new Pair(ranges[i][0],ranges[i][1]));\\n               }\\n           }\\n\\n       \\n         int mod = (int)1e9+7;\\n        int ans = 1;\\n        while(st.size()>0){\\n            ans = (ans*2)%mod;\\n            st.pop();\\n        }\\n        return ans;\\n        \\n\\n    }\\n \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n   \\n   class Pair{\\n\\n       int start;int end=0;\\n\\n       Pair(int start,int end){\\n           this.start=start;\\n           this.end=end;\\n       }\\n   }\\n\\n\\n    public int countWays(int[][] ranges) {\\n        Stack<Pair>st=new Stack<>();\\n        Arrays.sort(ranges,Comparator.comparingInt(r -> r[0]));\\n           st.add(new Pair(ranges[0][0],ranges[0][1]));\\n\\n           for(int i=1;i<ranges.length;i++){\\n\\n               if(ranges[i][0]<=st.peek().end){\\n                st.peek().end=Math.max(ranges[i][1],st.peek().end);\\n               }\\n               else{\\n                 st.push(new Pair(ranges[i][0],ranges[i][1]));\\n               }\\n           }\\n\\n       \\n         int mod = (int)1e9+7;\\n        int ans = 1;\\n        while(st.size()>0){\\n            ans = (ans*2)%mod;\\n            st.pop();\\n        }\\n        return ans;\\n        \\n\\n    }\\n \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311082,
                "title": "easy-understandable-c-solution-simple-approch",
                "content": "```\\nclass Solution {\\n    int mod = 1e9+7;\\n    long long int power(long long int x,long long int y)\\n    {\\n       if(y == 0) return 1;\\n        \\n       if(y%x == 1) return(x*power(x,y-1))%mod;\\n       \\n        long long int res = power(x,y/2);\\n        \\n        return (res*res)%mod;\\n    }\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int count = 1;\\n        int end = ranges[0][1];\\n        for(auto it : ranges)\\n        {\\n            if(it[0]>end)\\n            {\\n                count++;\\n                end = it[1];\\n            }else{\\n                end = max(end,it[1]);\\n            }\\n        }\\n        return power(1LL*2,1LL*count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1e9+7;\\n    long long int power(long long int x,long long int y)\\n    {\\n       if(y == 0) return 1;\\n        \\n       if(y%x == 1) return(x*power(x,y-1))%mod;\\n       \\n        long long int res = power(x,y/2);\\n        \\n        return (res*res)%mod;\\n    }\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int count = 1;\\n        int end = ranges[0][1];\\n        for(auto it : ranges)\\n        {\\n            if(it[0]>end)\\n            {\\n                count++;\\n                end = it[1];\\n            }else{\\n                end = max(end,it[1]);\\n            }\\n        }\\n        return power(1LL*2,1LL*count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308047,
                "title": "sorting-approach-java-simple-solution-clean-code",
                "content": "# Complexity\\nLet $n = ranges.length$\\n- Time complexity:$O(nlogn)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    static int MOD = (int)1e9 + 7;\\n    static long powMod(long b,long e){\\n        long ans = 1;\\n        for(;e != 0;){\\n            if((e & 1) == 1){\\n                ans *= b;\\n                ans %= MOD;\\n            }\\n            b *= b;\\n            b %= MOD;\\n            e >>= 1;\\n        }\\n        return ans;\\n    }\\n    public int countWays(int[][] ranges) {\\n        int cnt = 1;\\n        Arrays.sort(ranges,(a,b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\\n        int curr[] = ranges[0];\\n        for(int i = 1;i < ranges.length;i++){\\n            if(ranges[i][1] < curr[0] || ranges[i][0] > curr[1]){\\n                ++cnt;\\n                curr = ranges[i];\\n            }\\n            else{\\n                curr[1] = Math.max(curr[1],ranges[i][1]); \\n            }\\n        }\\n        return (int)powMod(2,cnt);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```java\\nclass Solution {\\n    static int MOD = (int)1e9 + 7;\\n    static long powMod(long b,long e){\\n        long ans = 1;\\n        for(;e != 0;){\\n            if((e & 1) == 1){\\n                ans *= b;\\n                ans %= MOD;\\n            }\\n            b *= b;\\n            b %= MOD;\\n            e >>= 1;\\n        }\\n        return ans;\\n    }\\n    public int countWays(int[][] ranges) {\\n        int cnt = 1;\\n        Arrays.sort(ranges,(a,b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\\n        int curr[] = ranges[0];\\n        for(int i = 1;i < ranges.length;i++){\\n            if(ranges[i][1] < curr[0] || ranges[i][0] > curr[1]){\\n                ++cnt;\\n                curr = ranges[i];\\n            }\\n            else{\\n                curr[1] = Math.max(curr[1],ranges[i][1]); \\n            }\\n        }\\n        return (int)powMod(2,cnt);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307312,
                "title": "c-sorting-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges)\\n    {\\n        sort(ranges.begin(),ranges.end());\\n        int ans=1,mod=1e9+7;\\n        int mx=-1;\\n        for(int i=0;i<ranges.size();i++)\\n        {\\n            if(mx<ranges[i][0])\\n            {\\n                ans*=2;\\n                ans%=mod;\\n                mx=ranges[i][1];\\n            }\\n            mx=max(mx,ranges[i][1]);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nIf you like the solution plz upvote.\\n=",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges)\\n    {\\n        sort(ranges.begin(),ranges.end());\\n        int ans=1,mod=1e9+7;\\n        int mx=-1;\\n        for(int i=0;i<ranges.size();i++)\\n        {\\n            if(mx<ranges[i][0])\\n            {\\n                ans*=2;\\n                ans%=mod;\\n                mx=ranges[i][1];\\n            }\\n            mx=max(mx,ranges[i][1]);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301899,
                "title": "find-number-of-groups-and-power-of-2",
                "content": "# Intuition\\nSimply find number of groups and then ans is 2 to the power of num of groups.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n       \\n       sort(begin(ranges), end(ranges));\\n        int groups=1, maxi=ranges[0][1];\\n       for(int i=1; i<ranges.size(); i++)\\n       {\\n           if(ranges[i][0] <= maxi)\\n                {\\n                    maxi = max(maxi, ranges[i][1]);\\n                    continue;\\n                }\\n            else\\n                {\\n                    groups++;\\n                    maxi = max(maxi, ranges[i][1]);\\n                }\\n       }\\n       int M = 1e9+7, x=1;\\n       for(int i=1; i<=groups; i++)\\n       {\\n           x = (x*1LL*2)%M;\\n       }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n       \\n       sort(begin(ranges), end(ranges));\\n        int groups=1, maxi=ranges[0][1];\\n       for(int i=1; i<ranges.size(); i++)\\n       {\\n           if(ranges[i][0] <= maxi)\\n                {\\n                    maxi = max(maxi, ranges[i][1]);\\n                    continue;\\n                }\\n            else\\n                {\\n                    groups++;\\n                    maxi = max(maxi, ranges[i][1]);\\n                }\\n       }\\n       int M = 1e9+7, x=1;\\n       for(int i=1; i<=groups; i++)\\n       {\\n           x = (x*1LL*2)%M;\\n       }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285369,
                "title": "c-sort-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int n=ranges.size();\\n        int c=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(ranges[i][0]<=ranges[i-1][1])\\n            {\\n                ranges[i][1]=max(ranges[i][1],ranges[i-1][1]);\\n            }\\n            else\\n            {\\n                c++;\\n            }\\n        }\\n        int mod=1000000007;\\n        int ans=1;\\n        for(int i=0;i<c;i++)\\n        {\\n            ans=((ans%mod)*2)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int n=ranges.size();\\n        int c=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(ranges[i][0]<=ranges[i-1][1])\\n            {\\n                ranges[i][1]=max(ranges[i][1],ranges[i-1][1]);\\n            }\\n            else\\n            {\\n                c++;\\n            }\\n        }\\n        int mod=1000000007;\\n        int ans=1;\\n        for(int i=0;i<c;i++)\\n        {\\n            ans=((ans%mod)*2)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284457,
                "title": "swift-solution",
                "content": "# Explanation (detailed)\\n\\n1. Sort the ranges by start time\\n2. Iterate over the sorted ranges\\n3. If the current range overlaps with the previous range, update the end time of the current range to the max of the current end time and the previous end time\\n4. If the current range does not overlap with the previous range, increment the total count of ranges by 1\\n5. After iterating over all the ranges, calculate the total number of ways by multiplying 2 by the total count of ranges\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func countWays(_ ranges: [[Int]]) -> Int {\\n        let mod = Int(10e8 + 7)\\n        let sortedRanges = ranges.sorted(by: { (a, b) -> Bool in\\n            if a[0] == b[0] {\\n                return a[1] < b[1]\\n            }\\n            return a[0] < b[0]\\n        })\\n        var tc = 1\\n        var currStart = sortedRanges[0][0]\\n        var currEnd = sortedRanges[0][1]\\n        for i in 1..<sortedRanges.count {\\n            let start = sortedRanges[i][0]\\n            let end = sortedRanges[i][1]\\n            let prevEnd = sortedRanges[i-1][1]\\n            if currEnd >= start {\\n                currEnd = max(currEnd, end)\\n            } else {\\n                tc += 1\\n                currEnd = end\\n            }\\n        }\\n        var ans = 1\\n        for _ in 0..<tc {\\n            ans *= 2\\n            ans = ans % mod\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countWays(_ ranges: [[Int]]) -> Int {\\n        let mod = Int(10e8 + 7)\\n        let sortedRanges = ranges.sorted(by: { (a, b) -> Bool in\\n            if a[0] == b[0] {\\n                return a[1] < b[1]\\n            }\\n            return a[0] < b[0]\\n        })\\n        var tc = 1\\n        var currStart = sortedRanges[0][0]\\n        var currEnd = sortedRanges[0][1]\\n        for i in 1..<sortedRanges.count {\\n            let start = sortedRanges[i][0]\\n            let end = sortedRanges[i][1]\\n            let prevEnd = sortedRanges[i-1][1]\\n            if currEnd >= start {\\n                currEnd = max(currEnd, end)\\n            } else {\\n                tc += 1\\n                currEnd = end\\n            }\\n        }\\n        var ans = 1\\n        for _ in 0..<tc {\\n            ans *= 2\\n            ans = ans % mod\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281041,
                "title": "sort-and-count-number-of-subgroups",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we know the number of subgroups, we can just return 2 ** N.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nbecause of sorting\\nO(n log (n)), O(1) \\n\\n# Code\\n```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        MOD = 10**9 + 7\\n        ranges.sort()\\n        last_time = -1\\n        group_count = 0\\n        for start, end in ranges:\\n            if start <= last_time:\\n                last_time = max(last_time, end)\\n            else:\\n                group_count += 1\\n                last_time = end\\n        # print(group_count)\\n        return 2 ** group_count % MOD\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        MOD = 10**9 + 7\\n        ranges.sort()\\n        last_time = -1\\n        group_count = 0\\n        for start, end in ranges:\\n            if start <= last_time:\\n                last_time = max(last_time, end)\\n            else:\\n                group_count += 1\\n                last_time = end\\n        # print(group_count)\\n        return 2 ** group_count % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272802,
                "title": "sorting-and-power-of-two-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        long mod = (long)10e8 + 7;\\n        Arrays.sort(ranges,(a,b)->{\\n           return a[0] - b[0]==0?a[1] - b[1]:a[0] - b[0]; \\n        });\\n        int tc = 1;\\n        int currStart = ranges[0][0], currEnd = ranges[0][1];\\n        for(int i = 1;i<ranges.length;i++){\\n            int start = ranges[i][0];\\n            int end = ranges[i][1];\\n            int prevEnd = ranges[i-1][1];\\n            if(currEnd>=start)currEnd = Math.max(currEnd,end);\\n            else {\\n                tc++;\\n                currEnd = end;\\n            }\\n        }\\n        long ans = 1;\\n        for(int i = 0;i<tc;i++){\\n            ans*=2 % mod;\\n            ans = ans % mod;\\n        }\\n        return (int)(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        long mod = (long)10e8 + 7;\\n        Arrays.sort(ranges,(a,b)->{\\n           return a[0] - b[0]==0?a[1] - b[1]:a[0] - b[0]; \\n        });\\n        int tc = 1;\\n        int currStart = ranges[0][0], currEnd = ranges[0][1];\\n        for(int i = 1;i<ranges.length;i++){\\n            int start = ranges[i][0];\\n            int end = ranges[i][1];\\n            int prevEnd = ranges[i-1][1];\\n            if(currEnd>=start)currEnd = Math.max(currEnd,end);\\n            else {\\n                tc++;\\n                currEnd = end;\\n            }\\n        }\\n        long ans = 1;\\n        for(int i = 0;i<tc;i++){\\n            ans*=2 % mod;\\n            ans = ans % mod;\\n        }\\n        return (int)(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271372,
                "title": "c-golang-sorting",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        const int mod = 1e9 + 7; \\n        sort(ranges.begin(), ranges.end());\\n        int last = -1, count = 0;\\n        for(vector<int> range: ranges) {\\n            if(range[0] > last) count++;\\n            last = max(last, range[1]);\\n        }\\n        int ans = 1;\\n        for(int i = 0; i < count; i++) {\\n            ans = (ans << 1) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc countWays(ranges [][]int) int {\\n    const mod int = 1e9 + 7 \\n    sort.Slice(ranges, func(i, j int) bool {\\n        return ranges[i][0] < ranges[j][0]\\n    })\\n    var last, count int = -1, 0\\n    for _, r := range ranges {\\n        if r[0] > last {count++}\\n        if r[1] > last {\\n            last = r[1]\\n        }\\n    }\\n    var ans int = 1\\n    for i := 0; i < count; i++ {\\n        ans = (ans << 1) % mod\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        const int mod = 1e9 + 7; \\n        sort(ranges.begin(), ranges.end());\\n        int last = -1, count = 0;\\n        for(vector<int> range: ranges) {\\n            if(range[0] > last) count++;\\n            last = max(last, range[1]);\\n        }\\n        int ans = 1;\\n        for(int i = 0; i < count; i++) {\\n            ans = (ans << 1) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc countWays(ranges [][]int) int {\\n    const mod int = 1e9 + 7 \\n    sort.Slice(ranges, func(i, j int) bool {\\n        return ranges[i][0] < ranges[j][0]\\n    })\\n    var last, count int = -1, 0\\n    for _, r := range ranges {\\n        if r[0] > last {count++}\\n        if r[1] > last {\\n            last = r[1]\\n        }\\n    }\\n    var ans int = 1\\n    for i := 0; i < count; i++ {\\n        ans = (ans << 1) % mod\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269930,
                "title": "c-easy-solution-greedy-approach-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &v1, vector<int> &v2)\\n    {\\n        if(v1[0] == v2[0])return v1[1] > v2[1];\\n        return v1[0] < v2[0];\\n    }\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(), ranges.end(), comp);\\n        int cnt = 0, ans = 1, mod = 1e9+7, curr_max=-1;\\n        for(int i=0;i<ranges.size();i++)\\n        {\\n            if(curr_max >= ranges[i][0])curr_max = max(curr_max, ranges[i][1]);\\n            else {ans = (ans*2)%mod;curr_max = ranges[i][1];}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &v1, vector<int> &v2)\\n    {\\n        if(v1[0] == v2[0])return v1[1] > v2[1];\\n        return v1[0] < v2[0];\\n    }\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(), ranges.end(), comp);\\n        int cnt = 0, ans = 1, mod = 1e9+7, curr_max=-1;\\n        for(int i=0;i<ranges.size();i++)\\n        {\\n            if(curr_max >= ranges[i][0])curr_max = max(curr_max, ranges[i][1]);\\n            else {ans = (ans*2)%mod;curr_max = ranges[i][1];}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268290,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn count_ways(mut ranges: Vec<Vec<i32>>) -> i32 {\\n        ranges.sort();\\n        const MOD: i32 = 1000000007;\\n        let mut total = 1;\\n        let mut end = ranges[0][1];\\n        for i in 1..ranges.len() {\\n            if ranges[i][0] > end {\\n                total += 1;\\n            }\\n            end = end.max(ranges[i][1]);\\n        }\\n\\n        let mut ans = 1;\\n        while total > 0 {\\n            ans = (ans * 2) % MOD;\\n            total -= 1;\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_ways(mut ranges: Vec<Vec<i32>>) -> i32 {\\n        ranges.sort();\\n        const MOD: i32 = 1000000007;\\n        let mut total = 1;\\n        let mut end = ranges[0][1];\\n        for i in 1..ranges.len() {\\n            if ranges[i][0] > end {\\n                total += 1;\\n            }\\n            end = end.max(ranges[i][1]);\\n        }\\n\\n        let mut ans = 1;\\n        while total > 0 {\\n            ans = (ans * 2) % MOD;\\n            total -= 1;\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3265546,
                "title": "java-using-custom-sort-time-100",
                "content": "```\\nclass Solution {\\n    public int countWays(int[][] a) {\\n        Arrays.sort(a,(b,c)->b[0]-c[0]);\\n        int left=a[0][0];int right=a[0][1];\\n        int ans=2;\\n        for(int i=0;i<a.length;i++){\\n            int x=a[i][0];int y=a[i][1];\\n            if(x>right){\\n                ans=(ans*2)%(int)(1e9+7);\\n            }\\n             right=Math.max(right,y);\\n        }\\n        return ans;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int countWays(int[][] a) {\\n        Arrays.sort(a,(b,c)->b[0]-c[0]);\\n        int left=a[0][0];int right=a[0][1];\\n        int ans=2;\\n        for(int i=0;i<a.length;i++){\\n            int x=a[i][0];int y=a[i][1];\\n            if(x>right){\\n                ans=(ans*2)%(int)(1e9+7);\\n            }\\n             right=Math.max(right,y);\\n        }\\n        return ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3264875,
                "title": "simple-solution-using-stack",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n int power(int i,int j,int mod)\\n    {\\n        if(j==0){\\n        return 1;\\n        }\\n        if(j==1){\\n            return i;\\n        }\\n        long a=power(i,j/2,mod);\\n        a=(a*a)%mod;\\n        if(j%2==1)\\n            a=(a*i)%mod;\\n        return (int)a;\\n    }\\n    int countWays(vector<vector<int>>& ranges) {\\n       sort(ranges.begin(),ranges.end());\\n       stack<pair<int,int>>s;\\n       s.push({ranges[0][0],ranges[0][1]});\\n        \\n        int n=ranges.size();\\n        for(int i=1;i<ranges.size();i++)\\n        {\\n            int k=s.top().first;\\n            if(ranges[i][0]<=s.top().second)\\n            {\\n                if(ranges[i][1]>s.top().second)\\n                {\\n                    \\n                    s.pop();\\n                    s.push({k,ranges[i][1]});\\n                }\\n            }\\n            else s.push({ranges[i][0],ranges[i][1]});\\n        }\\n        // while(!s.empty())\\n        // {\\n        //     cout<<s.top().first<<\" \"<<s.top().second;\\n        //     cout<<endl;\\n        //     s.pop();\\n        // }\\n        return power(2,s.size(),1e9+7);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int power(int i,int j,int mod)\\n    {\\n        if(j==0){\\n        return 1;\\n        }\\n        if(j==1){\\n            return i;\\n        }\\n        long a=power(i,j/2,mod);\\n        a=(a*a)%mod;\\n        if(j%2==1)\\n            a=(a*i)%mod;\\n        return (int)a;\\n    }\\n    int countWays(vector<vector<int>>& ranges) {\\n       sort(ranges.begin(),ranges.end());\\n       stack<pair<int,int>>s;\\n       s.push({ranges[0][0],ranges[0][1]});\\n        \\n        int n=ranges.size();\\n        for(int i=1;i<ranges.size();i++)\\n        {\\n            int k=s.top().first;\\n            if(ranges[i][0]<=s.top().second)\\n            {\\n                if(ranges[i][1]>s.top().second)\\n                {\\n                    \\n                    s.pop();\\n                    s.push({k,ranges[i][1]});\\n                }\\n            }\\n            else s.push({ranges[i][0],ranges[i][1]});\\n        }\\n        // while(!s.empty())\\n        // {\\n        //     cout<<s.top().first<<\" \"<<s.top().second;\\n        //     cout<<endl;\\n        //     s.pop();\\n        // }\\n        return power(2,s.size(),1e9+7);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3264201,
                "title": "easy-best-solution-in-c-o-1-sc",
                "content": "# Complexity\\n- Time complexity:\\n***O(nlogn) where n is the size of ranges array***\\n\\n- Space complexity:\\n***O(1)***\\n\\n# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int mod=1e9+7,last_value=ranges[0][1],count=1;\\n        for(int i=1;i<ranges.size();i++){\\n            int x=ranges[i][0];\\n            if(x>last_value){\\n                count++;\\n                last_value=ranges[i][1];\\n            }\\n            else\\n                last_value=max(last_value,ranges[i][1]);\\n        }\\n        int ans=1;\\n        for(int i=0;i<count;i++)\\n            ans=(ans*2)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int mod=1e9+7,last_value=ranges[0][1],count=1;\\n        for(int i=1;i<ranges.size();i++){\\n            int x=ranges[i][0];\\n            if(x>last_value){\\n                count++;\\n                last_value=ranges[i][1];\\n            }\\n            else\\n                last_value=max(last_value,ranges[i][1]);\\n        }\\n        int ans=1;\\n        for(int i=0;i<count;i++)\\n            ans=(ans*2)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264106,
                "title": "python-solution-count-non-overlapping-intervals-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount non-overlapping intervals by the same technique that we use to merge intervals. The answer is `2 ^ nonOverlappingIntervals`\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for Tim Sort\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        def countNonOverlappingIntervals(ranges: List[List[int]]) -> int:\\n            ranges.sort()\\n            countOfNonOverlapping = left = 0\\n            while left < len(ranges):\\n                right, end = left + 1, ranges[left][1]\\n                while right < len(ranges) and ranges[right][0] <= end:\\n                    end = max(end, ranges[right][1])\\n                    right += 1\\n                left = right\\n                countOfNonOverlapping += 1\\n            return countOfNonOverlapping\\n\\n        effectiveRanges = countNonOverlappingIntervals(ranges)\\n        return pow(2, effectiveRanges, 1000000007)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Sorting",
                    "Counting"
                ],
                "code": "```python []\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        def countNonOverlappingIntervals(ranges: List[List[int]]) -> int:\\n            ranges.sort()\\n            countOfNonOverlapping = left = 0\\n            while left < len(ranges):\\n                right, end = left + 1, ranges[left][1]\\n                while right < len(ranges) and ranges[right][0] <= end:\\n                    end = max(end, ranges[right][1])\\n                    right += 1\\n                left = right\\n                countOfNonOverlapping += 1\\n            return countOfNonOverlapping\\n\\n        effectiveRanges = countNonOverlappingIntervals(ranges)\\n        return pow(2, effectiveRanges, 1000000007)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263682,
                "title": "python3-o-nlogn-sort-and-count",
                "content": "# Code\\n```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort()\\n        cnt, idx = 0, 0\\n        while idx < len(ranges):\\n            beg, end = ranges[idx]\\n            cnt += 1\\n            idx += 1\\n            while idx < len(ranges) and beg <= ranges[idx][0] <= end:\\n                end = max(end, ranges[idx][1])\\n                idx += 1\\n        return pow(2, cnt, 10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort()\\n        cnt, idx = 0, 0\\n        while idx < len(ranges):\\n            beg, end = ranges[idx]\\n            cnt += 1\\n            idx += 1\\n            while idx < len(ranges) and beg <= ranges[idx][0] <= end:\\n                end = max(end, ranges[idx][1])\\n                idx += 1\\n        return pow(2, cnt, 10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263549,
                "title": "c-simple-merge-logic",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end()); \\n        vector<pair<int,int>>v; \\n        \\n        int index = 0 , l = ranges[0][0] , r = ranges[0][1] ;\\n        while(index < ranges.size()){\\n            l = ranges[index][0] , r = ranges[index][1] ;\\n            int f = 0 ;\\n            while(index < ranges.size() && ranges[index][0] <= r){\\n                r = max(r,ranges[index][1]) ; \\n                index += 1 ; \\n                f = 1 ;\\n            }\\n            v.push_back({l,r}); \\n            if(!f){index += 1;}\\n            \\n            \\n        } \\n        // for(int i = 0 ; i < v.size(); i++){\\n        //     cout << v[i].first << \" \" << v[i].second << endl ; \\n        // }\\n\\n        int x = v.size() ; \\n        long long int ans = 1 ; \\n        const int M = 1e9 + 7 ; \\n        for(int i = 0 ; i < x ; i++){\\n            ans = (ans * 2) % M ; \\n        }\\n\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end()); \\n        vector<pair<int,int>>v; \\n        \\n        int index = 0 , l = ranges[0][0] , r = ranges[0][1] ;\\n        while(index < ranges.size()){\\n            l = ranges[index][0] , r = ranges[index][1] ;\\n            int f = 0 ;\\n            while(index < ranges.size() && ranges[index][0] <= r){\\n                r = max(r,ranges[index][1]) ; \\n                index += 1 ; \\n                f = 1 ;\\n            }\\n            v.push_back({l,r}); \\n            if(!f){index += 1;}\\n            \\n            \\n        } \\n        // for(int i = 0 ; i < v.size(); i++){\\n        //     cout << v[i].first << \" \" << v[i].second << endl ; \\n        // }\\n\\n        int x = v.size() ; \\n        long long int ans = 1 ; \\n        const int M = 1e9 + 7 ; \\n        for(int i = 0 ; i < x ; i++){\\n            ans = (ans * 2) % M ; \\n        }\\n\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3263435,
                "title": "merging-intervals-bigint-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can split problem into 2 problems: merging intervals and counting ways. For counting ways i used BigInt values and simulated Math.pow in for loop.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*logn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nconst merge = (ranges) => {\\n    ranges.sort((a, b) => a[0] - b[0]);\\n    \\n    const res = [ranges[0]];\\n    \\n    for (let i = 1; i < ranges.length; i++) {\\n        const last = res.at(-1);\\n        \\n        const curr = ranges[i];\\n        \\n        if (last[1] >= curr[0]) {\\n            last[0] = Math.min(last[0], curr[0]);\\n            last[1] = Math.max(last[1], curr[1]);\\n        } else {\\n            res.push(curr);\\n        }\\n    }\\n    \\n    return res;\\n}\\n\\n/**\\n * @param {number[][]} ranges\\n * @return {number}\\n */\\nvar countWays = function(ranges) {\\n    const mergedRanges = merge(ranges);\\n    const m = BigInt(Math.pow(10, 9) + 7);\\n\\n    let result = 2n;\\n\\n    for (let i = 1; i < mergedRanges.length; i++) {\\n        result *= 2n;\\n    }\\n\\n    return result % m;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst merge = (ranges) => {\\n    ranges.sort((a, b) => a[0] - b[0]);\\n    \\n    const res = [ranges[0]];\\n    \\n    for (let i = 1; i < ranges.length; i++) {\\n        const last = res.at(-1);\\n        \\n        const curr = ranges[i];\\n        \\n        if (last[1] >= curr[0]) {\\n            last[0] = Math.min(last[0], curr[0]);\\n            last[1] = Math.max(last[1], curr[1]);\\n        } else {\\n            res.push(curr);\\n        }\\n    }\\n    \\n    return res;\\n}\\n\\n/**\\n * @param {number[][]} ranges\\n * @return {number}\\n */\\nvar countWays = function(ranges) {\\n    const mergedRanges = merge(ranges);\\n    const m = BigInt(Math.pow(10, 9) + 7);\\n\\n    let result = 2n;\\n\\n    for (let i = 1; i < mergedRanges.length; i++) {\\n        result *= 2n;\\n    }\\n\\n    return result % m;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3263211,
                "title": "disjoint-set-interval-merging",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int parent[100005];\\n    long long M = 1e9+7;\\n    int countWays(vector<vector<int>>& ranges) {\\n        n = ranges.size();\\n        init();\\n        sort(ranges.begin(), ranges.end());\\n        int end = ranges[0][1];\\n        int pre = -1;\\n        for(int i = 0; i < n; ++i){\\n            int curS = ranges[i][0];\\n            int curE = ranges[i][1];\\n            if(curS <= end){ \\n                if(pre != -1){\\n                    Union(i, pre);\\n                }\\n                else pre = i;\\n            }\\n            else{\\n                pre = i;\\n            }\\n            end = max(end, curE);\\n        }\\n        int cnt = 0;\\n        for(int i = 0; i < n; ++i){\\n            if(parent[i] == i) cnt++;\\n        }\\n        long long exp = 2;\\n        long long res = 1;\\n        while(cnt > 0){\\n            if(cnt&1) res = res*exp%M;\\n            cnt = cnt/2;\\n            exp = exp*exp%M;\\n        }\\n        return res;\\n    }\\n    void init(){\\n        for(int i = 0; i < 100005; ++i){\\n            parent[i] = i;\\n        }\\n    }\\n    int find(int x){\\n        if(parent[x] == x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    void Union(int x, int y){\\n        int px = find(x);\\n        int py = find(y);\\n        if(px != py){\\n            parent[px] = py;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int parent[100005];\\n    long long M = 1e9+7;\\n    int countWays(vector<vector<int>>& ranges) {\\n        n = ranges.size();\\n        init();\\n        sort(ranges.begin(), ranges.end());\\n        int end = ranges[0][1];\\n        int pre = -1;\\n        for(int i = 0; i < n; ++i){\\n            int curS = ranges[i][0];\\n            int curE = ranges[i][1];\\n            if(curS <= end){ \\n                if(pre != -1){\\n                    Union(i, pre);\\n                }\\n                else pre = i;\\n            }\\n            else{\\n                pre = i;\\n            }\\n            end = max(end, curE);\\n        }\\n        int cnt = 0;\\n        for(int i = 0; i < n; ++i){\\n            if(parent[i] == i) cnt++;\\n        }\\n        long long exp = 2;\\n        long long res = 1;\\n        while(cnt > 0){\\n            if(cnt&1) res = res*exp%M;\\n            cnt = cnt/2;\\n            exp = exp*exp%M;\\n        }\\n        return res;\\n    }\\n    void init(){\\n        for(int i = 0; i < 100005; ++i){\\n            parent[i] = i;\\n        }\\n    }\\n    int find(int x){\\n        if(parent[x] == x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    void Union(int x, int y){\\n        int px = find(x);\\n        int py = find(y);\\n        if(px != py){\\n            parent[px] = py;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263090,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int mod=1e9+7;\\n   int power(int n){\\n       if(n==1)return 2;\\n       long long t=power(n/2);\\n       t=(t*t)%mod;\\n       if(n%2)return (t*2)%mod;\\n       return t;\\n       \\n   }\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int cnt=1;\\n        int maxi=ranges[0][1];\\n        for(int i=1;i<ranges.size();i++){\\n            if(ranges[i][0]<=maxi ){\\n                //cnt++;\\n                maxi=max(maxi,ranges[i][1]);\\n                \\n            }\\n            else{\\n                cnt++;\\n                maxi=max(maxi,ranges[i][1]);\\n                \\n            }\\n\\n        }\\n        return power(cnt);\\n        \\n    };\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int mod=1e9+7;\\n   int power(int n){\\n       if(n==1)return 2;\\n       long long t=power(n/2);\\n       t=(t*t)%mod;\\n       if(n%2)return (t*2)%mod;\\n       return t;\\n       \\n   }\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int cnt=1;\\n        int maxi=ranges[0][1];\\n        for(int i=1;i<ranges.size();i++){\\n            if(ranges[i][0]<=maxi ){\\n                //cnt++;\\n                maxi=max(maxi,ranges[i][1]);\\n                \\n            }\\n            else{\\n                cnt++;\\n                maxi=max(maxi,ranges[i][1]);\\n                \\n            }\\n\\n        }\\n        return power(cnt);\\n        \\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262979,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(int n)\\n    {\\n        int ans=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=(ans*2)%mod;\\n        }\\n        return  ans;\\n    }\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int n=ranges.size();\\n        \\n        if(n==1)\\n            return 2;\\n        int cnt=1;\\n        int temp=ranges[0][1];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(ranges[i][0]>temp)\\n            {\\n                cnt++;\\n            }\\n            temp=max(temp,ranges[i][1]);\\n        }\\n        int ans=solve(cnt);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(int n)\\n    {\\n        int ans=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=(ans*2)%mod;\\n        }\\n        return  ans;\\n    }\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int n=ranges.size();\\n        \\n        if(n==1)\\n            return 2;\\n        int cnt=1;\\n        int temp=ranges[0][1];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(ranges[i][0]>temp)\\n            {\\n                cnt++;\\n            }\\n            temp=max(temp,ranges[i][1]);\\n        }\\n        int ans=solve(cnt);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262670,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy examining the test cases, we get the idea that the solution is a power of two, what power of 2?\\n`2 ^ (the count of non overlapping ranges)`\\nwhich can be easily calculated using a while loop.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwith a nested while loop we can find all non overlapping ranges, but we need to sort the ranges first.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        def count_nonoverlapping(ranges):\\n            ranges.sort()\\n            non_overlapping = i = 0\\n            while i < len(ranges):\\n                j = i + 1\\n                r = ranges[i][1]\\n                while j < len(ranges) and ranges[j][0] <= r:\\n                    r = max(r, ranges[j][1])\\n                    j += 1\\n                i = j\\n                non_overlapping += 1\\n            return non_overlapping\\n\\n        count = count_nonoverlapping(ranges)\\n        return pow(2, count, 1_000_000_007)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        def count_nonoverlapping(ranges):\\n            ranges.sort()\\n            non_overlapping = i = 0\\n            while i < len(ranges):\\n                j = i + 1\\n                r = ranges[i][1]\\n                while j < len(ranges) and ranges[j][0] <= r:\\n                    r = max(r, ranges[j][1])\\n                    j += 1\\n                i = j\\n                non_overlapping += 1\\n            return non_overlapping\\n\\n        count = count_nonoverlapping(ranges)\\n        return pow(2, count, 1_000_000_007)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262605,
                "title": "c-100-fast-100-space-efficient",
                "content": "***seen algorithms are sweet, unseen ones are sweet***\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());long long int mod=1e9+7;\\n        long long int count=0;int ext=ranges[0][1];int curr=0;\\n        for(int i=0;i<ranges.size();i++){\\n            if(ext>=ranges[i][0]){ext=max(ext,ranges[i][1]);curr++;}\\n            else {count++;ext=ranges[i][1];curr=1;}\\n        }if(curr)count++;\\n        long long int ans=1;while(count--)ans*=2,ans%=mod;return ans;\\n    }\\n};\\n```\\n**logik**\\n1.sort the ranges \\n2.make a variable ext to check the length of the range , now if next range starting point is less than this then ext will be maximum of ext and end point of next range\\n3.count++ otherwise\\n4.2 to power count is answer\\n5.take modulo appropriately\\n![image](https://assets.leetcode.com/users/images/d1cf7d28-e9ed-49ea-92b8-7c7a3ad069cd_1678076815.9288635.png)\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());long long int mod=1e9+7;\\n        long long int count=0;int ext=ranges[0][1];int curr=0;\\n        for(int i=0;i<ranges.size();i++){\\n            if(ext>=ranges[i][0]){ext=max(ext,ranges[i][1]);curr++;}\\n            else {count++;ext=ranges[i][1];curr=1;}\\n        }if(curr)count++;\\n        long long int ans=1;while(count--)ans*=2,ans%=mod;return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261484,
                "title": "python-o-n-single-pass-reset-ranges-permutation-math",
                "content": "# Intuition\\nMy gut reaction is in the comment block above my code. \\n\\n# Approach\\nBasically we can think of the overlapping ranges as elements to be reduced down to a single range element. Then we can just return 2 to the length of our compressed ranges modded.\\n\\n# Complexity\\n- Time complexity:\\nSingle Pass $$O(n)$$\\n\\n- Space complexity:\\n$$O(non-overlapping - ranges)$$\\n\\n# Code\\n```\\n\\'\\'\\'\\nIf we think of overlapping groups as \"unique\" characters in a string or array\\nThen I believe we are effectively returning the number of possible permutations * 2\\nso then the question becomes how do we manage to get the overlapping groups?\\nif we sort our input by first element in the collection then perhaps we could construct a new list of ranges\\nWhere overlappers are collected together\\n\\n[1,10],[2,20] -> 1,20\\n\\'\\'\\'\\n\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort()\\n        newr = [ranges[0]] # lol get it?\\n        for r in ranges[1::]:\\n            l = newr[-1]\\n            if r[0] <= l[1]:\\n                newr[-1] = [l[0], max(r[1], l[1])]\\n            else: newr.append(r)\\n        return 2**len(newr) % (10**9+7)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\'\\'\\'\\nIf we think of overlapping groups as \"unique\" characters in a string or array\\nThen I believe we are effectively returning the number of possible permutations * 2\\nso then the question becomes how do we manage to get the overlapping groups?\\nif we sort our input by first element in the collection then perhaps we could construct a new list of ranges\\nWhere overlappers are collected together\\n\\n[1,10],[2,20] -> 1,20\\n\\'\\'\\'\\n\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort()\\n        newr = [ranges[0]] # lol get it?\\n        for r in ranges[1::]:\\n            l = newr[-1]\\n            if r[0] <= l[1]:\\n                newr[-1] = [l[0], max(r[1], l[1])]\\n            else: newr.append(r)\\n        return 2**len(newr) % (10**9+7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260732,
                "title": "c-sorting-merge-intervals-count-number-of-subsequences-explained",
                "content": "# Intuition\\nAs we have to keep the record that all the overlapping intervals should be in one group. As the number of overlapping pairs does not affect the answer becuase the only condition is that they all should be in one group. So, why not to make those overlapping pairs as one by merging them.\\n\\nso, merge the overlapping intervals and then find the number of different ways to group them. The different number of ways to group them is to find the number of subsequences. As we have to find the subsequences of a large array so we used the powfunc which uses logn time complexity to find the power of a number;\\n\\n# Complexity\\n\\n- Time complexity:\\n$$O(n log n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mod = 1000000007;\\n    vector<vector<int>> mergeIntervals(vector<vector<int>>& ranges){\\n        vector<vector<int>>ans;\\n        sort(ranges.begin(), ranges.end());\\n        vector<int>temp = ranges[0];\\n\\n        for(int i = 1; i<ranges.size(); i++){\\n            if(temp[1]>=ranges[i][0]){\\n                temp[1] = max(temp[1], ranges[i][1]);\\n            }\\n\\n            else{\\n                ans.push_back(temp);\\n                temp = ranges[i];\\n            }\\n        }\\n\\n        ans.push_back(temp);\\n\\n        return ans;\\n    }\\n\\n    long long powfunc(long long a, long long val){\\n        if(val == 0)return (double)(1);\\n\\n        if(val == 1){\\n            return a;\\n        }\\n\\n        if(val%2 == 0){\\n            long long currans = powfunc(a, val/2)%mod;\\n            return ((currans%mod)*(currans%mod))%mod;\\n        }\\n\\n        return (a*(powfunc(a, val-1)%mod))%mod;\\n    }\\n\\n    int countWays(vector<vector<int>>& ranges) {\\n        ranges = mergeIntervals(ranges);\\n        return powfunc(2, ranges.size())%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod = 1000000007;\\n    vector<vector<int>> mergeIntervals(vector<vector<int>>& ranges){\\n        vector<vector<int>>ans;\\n        sort(ranges.begin(), ranges.end());\\n        vector<int>temp = ranges[0];\\n\\n        for(int i = 1; i<ranges.size(); i++){\\n            if(temp[1]>=ranges[i][0]){\\n                temp[1] = max(temp[1], ranges[i][1]);\\n            }\\n\\n            else{\\n                ans.push_back(temp);\\n                temp = ranges[i];\\n            }\\n        }\\n\\n        ans.push_back(temp);\\n\\n        return ans;\\n    }\\n\\n    long long powfunc(long long a, long long val){\\n        if(val == 0)return (double)(1);\\n\\n        if(val == 1){\\n            return a;\\n        }\\n\\n        if(val%2 == 0){\\n            long long currans = powfunc(a, val/2)%mod;\\n            return ((currans%mod)*(currans%mod))%mod;\\n        }\\n\\n        return (a*(powfunc(a, val-1)%mod))%mod;\\n    }\\n\\n    int countWays(vector<vector<int>>& ranges) {\\n        ranges = mergeIntervals(ranges);\\n        return powfunc(2, ranges.size())%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260530,
                "title": "math",
                "content": "Solve this problem first \\nhttps://leetcode.com/problems/merge-intervals/\\nif a can be permutated in x ways and b in y ways\\nthen total number of ways is x*y\\n\\n```\\nclass Solution {\\npublic:\\n    long long binary_exponentiation(long long x, long long n, long long mod = 1e9+7){   // x^n\\n\\n     if(n==0){\\n         return 1;\\n     }\\n\\n     long long square = (binary_exponentiation(x,n/2))%mod;\\n     square = (square*square)%mod;\\n     if(n&1){\\n        // odd number\\n         return (x*square)%mod;\\n     }\\n\\n     return square;\\n\\n}\\n    \\n  bool check(const vector<int>&first, const vector<int>&second){\\n        \\n           if(second[0] >=first[0] && second[0] <=first[1]){\\n                return true;\\n           }\\n        \\n        return false;\\n        \\n    }\\n    \\n    vector<int> merge(const vector<int>&first, const vector<int>&second){\\n        \\n           return {min(first[0],second[0]), max(second[1],first[1])};\\n        \\n    }\\n    \\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        int size = intervals.size();\\n        \\n        sort(intervals.begin(), intervals.end());\\n        \\n        vector<vector<int>>answer;\\n        int pointer = 0;\\n        \\n        for(int i = 0; i < size; i++){\\n            \\n              vector<int>curr = intervals[i];\\n            \\n              while(i < size && check(curr, intervals[i])){\\n                   curr = merge(curr, intervals[i]);\\n                   i++;\\n              }\\n            \\n              answer.push_back(curr);\\n              i--;\\n        }\\n        \\n        return answer;\\n        \\n    }\\n    \\n    int countWays(vector<vector<int>>& ranges) {\\n        vector<vector<int>>answer = merge(ranges);  // this is from the inital prerequisite problem\\n        int power = answer.size();\\n        return (int)binary_exponentiation(2*1ll,power*1ll, (1e9+7*1ll));\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long binary_exponentiation(long long x, long long n, long long mod = 1e9+7){   // x^n\\n\\n     if(n==0){\\n         return 1;\\n     }\\n\\n     long long square = (binary_exponentiation(x,n/2))%mod;\\n     square = (square*square)%mod;\\n     if(n&1){\\n        // odd number\\n         return (x*square)%mod;\\n     }\\n\\n     return square;\\n\\n}\\n    \\n  bool check(const vector<int>&first, const vector<int>&second){\\n        \\n           if(second[0] >=first[0] && second[0] <=first[1]){\\n                return true;\\n           }\\n        \\n        return false;\\n        \\n    }\\n    \\n    vector<int> merge(const vector<int>&first, const vector<int>&second){\\n        \\n           return {min(first[0],second[0]), max(second[1],first[1])};\\n        \\n    }\\n    \\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        int size = intervals.size();\\n        \\n        sort(intervals.begin(), intervals.end());\\n        \\n        vector<vector<int>>answer;\\n        int pointer = 0;\\n        \\n        for(int i = 0; i < size; i++){\\n            \\n              vector<int>curr = intervals[i];\\n            \\n              while(i < size && check(curr, intervals[i])){\\n                   curr = merge(curr, intervals[i]);\\n                   i++;\\n              }\\n            \\n              answer.push_back(curr);\\n              i--;\\n        }\\n        \\n        return answer;\\n        \\n    }\\n    \\n    int countWays(vector<vector<int>>& ranges) {\\n        vector<vector<int>>answer = merge(ranges);  // this is from the inital prerequisite problem\\n        int power = answer.size();\\n        return (int)binary_exponentiation(2*1ll,power*1ll, (1e9+7*1ll));\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260394,
                "title": "c-merge-intervals-with-explanation",
                "content": "# Intuition\\n1. Overlapped intervals can be treated as a single big interval, because they are always in the same group.\\n2. If two intervals are sorted by their `start` in ascending order, then they are overlapped if and only if `left[end] >= right[start]`\\n3. Suppose we group every overlapped intervals into a single big interval. Every single big interval has two choices (group 1 or 2).\\n   So if there\\'re `number` of such single big intervals, then the total number of ways is `2 ^ number`.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Sort the intervals\\n2. Count the number of the groups of overlapped intervals.\\n    - Traverse the intervals from left to right\\n    - Use variable `last` to track `left[end]`. On the other hand, the current interval stands for `right`.\\n    - Apply the check `last >= right[start]` to determine whether the current interval is overlapped with the previous interval.\\n    - Update `last` and count the number of groups based on the check.\\n3. Calculate `(2 ^ number) % (10 ^ 9 + 7)`\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(NlogN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(), ranges.end(), [](const vector<int> &a, const vector<int> &b) {\\n            return a[0] < b[0];\\n        });\\n        \\n        int number = 1;\\n        int last = ranges[0][1];\\n        for (int i = 1; i != ranges.size(); ++i) {\\n            if (ranges[i][0] <= last) { // merge the ranges\\n                last = max(last, ranges[i][1]);\\n            } else {\\n                ++number;\\n                last = ranges[i][1];\\n            }\\n        }\\n        \\n        int answer = 1;\\n        const int mod = 1E9 + 7;\\n        while (number--)\\n            answer = (answer * 2) % mod;\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(), ranges.end(), [](const vector<int> &a, const vector<int> &b) {\\n            return a[0] < b[0];\\n        });\\n        \\n        int number = 1;\\n        int last = ranges[0][1];\\n        for (int i = 1; i != ranges.size(); ++i) {\\n            if (ranges[i][0] <= last) { // merge the ranges\\n                last = max(last, ranges[i][1]);\\n            } else {\\n                ++number;\\n                last = ranges[i][1];\\n            }\\n        }\\n        \\n        int answer = 1;\\n        const int mod = 1E9 + 7;\\n        while (number--)\\n            answer = (answer * 2) % mod;\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260377,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort and save the rightmost so far.\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        n = len(ranges)\\n        ranges.sort()\\n        last_far = -1\\n        count = 0\\n        for i in range(n):\\n            if ranges[i][0] > last_far:\\n                count += 1\\n                last_far = ranges[i][1]\\n            else:\\n                last_far = max(last_far, ranges[i][1])\\n        return (2**count) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        n = len(ranges)\\n        ranges.sort()\\n        last_far = -1\\n        count = 0\\n        for i in range(n):\\n            if ranges[i][0] > last_far:\\n                count += 1\\n                last_far = ranges[i][1]\\n            else:\\n                last_far = max(last_far, ranges[i][1])\\n        return (2**count) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260083,
                "title": "c-easy-to-understand-beats-100-space-and-time",
                "content": "# Intuition\\nN Non-overlapping Intervals will lead to 2^N as the total ways.\\nSince The Two Groups can remain Empty.\\nso each group will either take or not take the interval i.e two ways -\\n$$2*2*2...N   = 2^N ways$$.\\n\\n# Approach\\njust find the merging intervals and consider them altogether as 1 single interval.\\n# Complexity\\n- Time complexity:\\n- M size of matrix\\n$$O(M)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        //if you have n non-overlapping groups your answer will be 2^n.\\n        //find overlapping groups and consider them altogether as 1\\n        int dGroups = 1,m = ranges.size();\\n        long long z = 1e9+7;\\n        sort(ranges.begin(),ranges.end()); //that way we only need to care about the second \\n        //index-->viz \\'e\\' in my code.\\n        int e = ranges[0][1];\\n        for (int i = 1; i < m; i++) {\\n            if(ranges[i][0] > e) dGroups++;\\n            e = max(e,ranges[i][1]);\\n        }\\n        dGroups = dGroups % z;\\n        long long x = 1;\\n        for(int i = 1;i<= dGroups;i++) {\\n            x = x % z;\\n            x *= 2;\\n        }\\n        return x % z;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        //if you have n non-overlapping groups your answer will be 2^n.\\n        //find overlapping groups and consider them altogether as 1\\n        int dGroups = 1,m = ranges.size();\\n        long long z = 1e9+7;\\n        sort(ranges.begin(),ranges.end()); //that way we only need to care about the second \\n        //index-->viz \\'e\\' in my code.\\n        int e = ranges[0][1];\\n        for (int i = 1; i < m; i++) {\\n            if(ranges[i][0] > e) dGroups++;\\n            e = max(e,ranges[i][1]);\\n        }\\n        dGroups = dGroups % z;\\n        long long x = 1;\\n        for(int i = 1;i<= dGroups;i++) {\\n            x = x % z;\\n            x *= 2;\\n        }\\n        return x % z;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260077,
                "title": "100-fast-count-ranges-all-possible-arrangements-are-2-number-of-distinct-ranges-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe just need to find total number of ranges .\\nnumber of arrangement of ranges into two groups is **2^(no. of ranges)**  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwhy is it **2^(no. of ranges)** ?\\n\\nbecause lets say we have 3 ranges a , b , c\\n\\nthe arrangements can be -\\n * | abc\\n a |bc\\n b |ac\\n c |ab\\n ab|c\\n ac|b\\n bc|a\\n abc|*\\n\\nwhere * represents empty set\\n\\n\\nwe can observe that the arrangements are just the subsets of abc,\\nfor a set of n elements , we have a total of 2^n subsets.\\nhence the answer is  **2^(no. of ranges)** \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) -> sorting the range 2d array\\n- Space complexity:\\n- O(n)-> making new merged range array (trange)\\n \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long binpow(long long a, long long b, long long m) {\\n    a %= m;\\n    long long res = 1;\\n    while (b > 0) {\\n        if (b & 1)\\n            res = res * a % m;\\n        a = a * a % m;\\n        b >>= 1;\\n    }\\n    return res;\\n}\\n\\n\\n    int countWays(vector<vector<int>>& range) {\\n        // count ranges\\n        // ans-> 2^(ranges) %mod\\n\\n        vector<pair<int,int> >trange;\\n        sort(range.begin(),range.end());\\n\\n        trange.push_back({range[0][0],range[0][1]});\\n\\n        int i=1;\\n        int j=0;\\n        while(i<range.size()){\\n          if(      range[i][0] >= trange[j].first && range[i][0]<=trange[j].second ){\\n              trange[j].second=max(trange[j].second,range[i][1]);\\n          }\\n       else{\\n\\n  trange.push_back({range[i][0],range[i][1]});\\n  j++;     \\n\\n        }\\n\\ni++;\\n        }\\nint count=trange.size();\\nlong long mod=1e9 +7;\\nreturn binpow(2,count,mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long binpow(long long a, long long b, long long m) {\\n    a %= m;\\n    long long res = 1;\\n    while (b > 0) {\\n        if (b & 1)\\n            res = res * a % m;\\n        a = a * a % m;\\n        b >>= 1;\\n    }\\n    return res;\\n}\\n\\n\\n    int countWays(vector<vector<int>>& range) {\\n        // count ranges\\n        // ans-> 2^(ranges) %mod\\n\\n        vector<pair<int,int> >trange;\\n        sort(range.begin(),range.end());\\n\\n        trange.push_back({range[0][0],range[0][1]});\\n\\n        int i=1;\\n        int j=0;\\n        while(i<range.size()){\\n          if(      range[i][0] >= trange[j].first && range[i][0]<=trange[j].second ){\\n              trange[j].second=max(trange[j].second,range[i][1]);\\n          }\\n       else{\\n\\n  trange.push_back({range[i][0],range[i][1]});\\n  j++;     \\n\\n        }\\n\\ni++;\\n        }\\nint count=trange.size();\\nlong long mod=1e9 +7;\\nreturn binpow(2,count,mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260075,
                "title": "simple-java-solution-merge-interval-2-length-of-number-of-intervals-after-merging",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        ArrayList<ArrayList<Integer>> mergeInterval=new ArrayList<>();\\n        int numWays=1;\\n        Arrays.sort(ranges,(a,b)->a[0]-b[0]);\\n        //[1,3],[2,5],[4,8],[10,20]\\n        int len=ranges.length;\\n        int i=1;\\n        int currStart=ranges[0][0]; //1\\n        int currEnd=ranges[0][1];   //3\\n        while(i<len){\\n            if(ranges[i][0]<=currEnd){\\n                currEnd=Math.max(ranges[i][1],currEnd);\\n            }\\n            else{\\n                ArrayList<Integer> sublst=new ArrayList<>();\\n                sublst.add(currStart);\\n                sublst.add(currEnd);\\n                mergeInterval.add(sublst);\\n                currStart=ranges[i][0];\\n                currEnd=ranges[i][1];\\n            }\\n            i++;\\n        }\\n        ArrayList<Integer> sublst=new ArrayList<>();\\n        sublst.add(currStart);\\n        sublst.add(currEnd);\\n        mergeInterval.add(sublst);\\n        // System.out.println(mergeInterval);\\n        int mod=1000000007;\\n        for(int j=1;j<=mergeInterval.size();j++){\\n            numWays=(numWays%mod *2%mod)%mod;\\n        }\\n        return numWays;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        ArrayList<ArrayList<Integer>> mergeInterval=new ArrayList<>();\\n        int numWays=1;\\n        Arrays.sort(ranges,(a,b)->a[0]-b[0]);\\n        //[1,3],[2,5],[4,8],[10,20]\\n        int len=ranges.length;\\n        int i=1;\\n        int currStart=ranges[0][0]; //1\\n        int currEnd=ranges[0][1];   //3\\n        while(i<len){\\n            if(ranges[i][0]<=currEnd){\\n                currEnd=Math.max(ranges[i][1],currEnd);\\n            }\\n            else{\\n                ArrayList<Integer> sublst=new ArrayList<>();\\n                sublst.add(currStart);\\n                sublst.add(currEnd);\\n                mergeInterval.add(sublst);\\n                currStart=ranges[i][0];\\n                currEnd=ranges[i][1];\\n            }\\n            i++;\\n        }\\n        ArrayList<Integer> sublst=new ArrayList<>();\\n        sublst.add(currStart);\\n        sublst.add(currEnd);\\n        mergeInterval.add(sublst);\\n        // System.out.println(mergeInterval);\\n        int mod=1000000007;\\n        for(int j=1;j<=mergeInterval.size();j++){\\n            numWays=(numWays%mod *2%mod)%mod;\\n        }\\n        return numWays;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259889,
                "title": "python-simple-solution-sort",
                "content": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        \\n        counter = 1\\n        ranges.sort()\\n        end = ranges[0][1]\\n        for i in range(1, len(ranges)):\\n            start_new, end_new = ranges[i]\\n            if start_new <= end:\\n                end = max(end, end_new)\\n            else:\\n                end = end_new\\n                counter += 1\\n        return (2**counter) % (10**9 + 7)\\n       \\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        \\n        counter = 1\\n        ranges.sort()\\n        end = ranges[0][1]\\n        for i in range(1, len(ranges)):\\n            start_new, end_new = ranges[i]\\n            if start_new <= end:\\n                end = max(end, end_new)\\n            else:\\n                end = end_new\\n                counter += 1\\n        return (2**counter) % (10**9 + 7)\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259728,
                "title": "c-exponentiation-by-squaring",
                "content": "```\\n\\tpublic int CountWays(int[][] ranges) {\\n        ranges = ranges.OrderBy(x => x[0]).ToArray();\\n        long li = ranges[0][0], hi = ranges[0][1], n = 1, mod = 1_000_000_000 + 7;\\n        for (int i = 1; i < ranges.Length; i++) {\\n            if (li <= ranges[i][0] && ranges[i][0] <= hi)\\n                hi = Math.Max(hi, ranges[i][1]);\\n            else {\\n                n++;\\n                li = ranges[i][0];\\n                hi = ranges[i][1];\\n            }\\n        }\\n        var pow = Power(n, mod);\\n        return (int)(pow % mod);\\n    }\\n\\n    private long Power(long n, long mod) {\\n        if (n == 0) return 1;\\n        var pow = Power(n / 2, mod) % mod;\\n        return n % 2 == 0 ? pow * pow : pow * pow * 2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int CountWays(int[][] ranges) {\\n        ranges = ranges.OrderBy(x => x[0]).ToArray();\\n        long li = ranges[0][0], hi = ranges[0][1], n = 1, mod = 1_000_000_000 + 7;\\n        for (int i = 1; i < ranges.Length; i++) {\\n            if (li <= ranges[i][0] && ranges[i][0] <= hi)\\n                hi = Math.Max(hi, ranges[i][1]);\\n            else {\\n                n++;\\n                li = ranges[i][0];\\n                hi = ranges[i][1];\\n            }\\n        }\\n        var pow = Power(n, mod);\\n        return (int)(pow % mod);\\n    }\\n\\n    private long Power(long n, long mod) {\\n        if (n == 0) return 1;\\n        var pow = Power(n / 2, mod) % mod;\\n        return n % 2 == 0 ? pow * pow : pow * pow * 2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259658,
                "title": "merge-intervals-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we need to divide non-overlapping ranges , so we need to merge the overlapping ranges . And with the number of non overlapping ranges , we can find the ways to divide them into 2 groups .\\n\\n# Approach\\n1st Step :-  Merge Intervals :- https://leetcode.com/problems/merge-intervals/\\n2nd Step :- Need to divide n ranges in 2 groups . So 1 range can be either of the 2 groups ( 2 ways ) . So for n ranges = 2 * 2 * 2 ..... n times = 2^n  (Answer)\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        mod = 1000000007\\n        ranges.sort(key = lambda x : x[0])\\n        ans = [ranges[0]]\\n        # print(ranges , ans)\\n\\n        #merge intervals\\n        for i in range(1 ,len(ranges)) :\\n            if(ans[-1][1] >= ranges[i][1] or ans[-1][1] >= ranges[i][0]) :\\n                ans[-1][1] = max(ans[-1][1] , ranges[i][1])\\n            else:\\n                ans.append(ranges[i])\\n        n = len(ans)\\n\\n        # ways to distribute n numbers in 2 groups = 2^n  \\n        # as you can divide a number into 2 groups , so 2 possible ways to pick every number, so for n numbers = 2 * 2 * 2 * 2 ............... n times\\n        return 2**n % mod\\n\\n\\n\\n    \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        mod = 1000000007\\n        ranges.sort(key = lambda x : x[0])\\n        ans = [ranges[0]]\\n        # print(ranges , ans)\\n\\n        #merge intervals\\n        for i in range(1 ,len(ranges)) :\\n            if(ans[-1][1] >= ranges[i][1] or ans[-1][1] >= ranges[i][0]) :\\n                ans[-1][1] = max(ans[-1][1] , ranges[i][1])\\n            else:\\n                ans.append(ranges[i])\\n        n = len(ans)\\n\\n        # ways to distribute n numbers in 2 groups = 2^n  \\n        # as you can divide a number into 2 groups , so 2 possible ways to pick every number, so for n numbers = 2 * 2 * 2 * 2 ............... n times\\n        return 2**n % mod\\n\\n\\n\\n    \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259506,
                "title": "c-merge-interval-extended-version-que-contest-99",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n            const unsigned int M = 1000000007;\\n             int cnt = 1;\\n\\n        sort(ranges.begin(),ranges.end());\\n        int chk=ranges[0][1];\\n        for(int i=1;i<ranges.size();i++){\\n            if(chk>=ranges[i][0]) {\\n                chk=max(chk,ranges[i][1]);\\n            }\\n            else{\\n                cnt++;\\n                chk=ranges[i][1];\\n            }\\n        }\\n         long long ans=1;\\n        for(int i=1;i<=cnt;i++){\\n            (ans*=2)%=M;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n            const unsigned int M = 1000000007;\\n             int cnt = 1;\\n\\n        sort(ranges.begin(),ranges.end());\\n        int chk=ranges[0][1];\\n        for(int i=1;i<ranges.size();i++){\\n            if(chk>=ranges[i][0]) {\\n                chk=max(chk,ranges[i][1]);\\n            }\\n            else{\\n                cnt++;\\n                chk=ranges[i][1];\\n            }\\n        }\\n         long long ans=1;\\n        for(int i=1;i<=cnt;i++){\\n            (ans*=2)%=M;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259320,
                "title": "merge-intervals-power-of-two",
                "content": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        // merge intervals plus power of two code is to be used in this question\\n        sort(ranges.begin() , ranges.end());\\n        vector<vector<int>> ans;\\n        for(auto it : ranges)\\n        {\\n            if(ans.size()==0) ans.push_back(it);\\n            else\\n            {\\n                vector<int> prev = ans[ans.size()-1];\\n                if(prev[1] >= it[0])\\n                {\\n                    ans[ans.size()-1][1] = max(it[1] , prev[1]);\\n                }\\n                else\\n                {\\n                    ans.push_back(it);\\n                }\\n            }\\n        }\\n        \\n        \\n        int an = 1;\\n        int mod = 1e9+7;\\n        \\n        for(int i = 1 ; i <= ans.size() ; i++)\\n        {\\n            an = (an*2)%mod;\\n        }\\n        return an;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        // merge intervals plus power of two code is to be used in this question\\n        sort(ranges.begin() , ranges.end());\\n        vector<vector<int>> ans;\\n        for(auto it : ranges)\\n        {\\n            if(ans.size()==0) ans.push_back(it);\\n            else\\n            {\\n                vector<int> prev = ans[ans.size()-1];\\n                if(prev[1] >= it[0])\\n                {\\n                    ans[ans.size()-1][1] = max(it[1] , prev[1]);\\n                }\\n                else\\n                {\\n                    ans.push_back(it);\\n                }\\n            }\\n        }\\n        \\n        \\n        int an = 1;\\n        int mod = 1e9+7;\\n        \\n        for(int i = 1 ; i <= ans.size() ; i++)\\n        {\\n            an = (an*2)%mod;\\n        }\\n        return an;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259298,
                "title": "java-merge-intervals-sorting-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        \\n        Interval arr[] = new Interval[ranges.length];\\n        \\n        for(int i = 0;i < ranges.length;i++) {\\n            arr[i] = new Interval(ranges[i][0], ranges[i][1]);\\n        }\\n        \\n        Arrays.sort(arr,new Comparator<Interval>(){\\n            public int compare(Interval i1,Interval i2)\\n            {\\n                return i1.start - i2.start;\\n            }\\n        });\\n        \\n        int index = 0;\\n   \\n        for(int i = 1;i < arr.length;i++) {\\n            if(arr[index].end >=  arr[i].start) {\\n                arr[index].end = Math.max(arr[index].end, arr[i].end);\\n            } else {\\n                index++;\\n                arr[index] = arr[i];\\n            }   \\n        }\\n        \\n        long res = 2;\\n        int mod = 1000000007;\\n        \\n        for(int i = 0;i < index;i++) {\\n            res *= 2;\\n            res %= mod;\\n        }\\n        \\n        return (int)res;\\n    }\\n    \\n    class Interval {\\n        \\n        int start;\\n        int end;\\n        \\n        Interval(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n        }\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        \\n        Interval arr[] = new Interval[ranges.length];\\n        \\n        for(int i = 0;i < ranges.length;i++) {\\n            arr[i] = new Interval(ranges[i][0], ranges[i][1]);\\n        }\\n        \\n        Arrays.sort(arr,new Comparator<Interval>(){\\n            public int compare(Interval i1,Interval i2)\\n            {\\n                return i1.start - i2.start;\\n            }\\n        });\\n        \\n        int index = 0;\\n   \\n        for(int i = 1;i < arr.length;i++) {\\n            if(arr[index].end >=  arr[i].start) {\\n                arr[index].end = Math.max(arr[index].end, arr[i].end);\\n            } else {\\n                index++;\\n                arr[index] = arr[i];\\n            }   \\n        }\\n        \\n        long res = 2;\\n        int mod = 1000000007;\\n        \\n        for(int i = 0;i < index;i++) {\\n            res *= 2;\\n            res %= mod;\\n        }\\n        \\n        return (int)res;\\n    }\\n    \\n    class Interval {\\n        \\n        int start;\\n        int end;\\n        \\n        Interval(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n        }\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259248,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int countWays(vector<vector<int>>& ranges) \\n    {\\n        int mod=1e9+7;\\n        int n=ranges.size();\\n        sort(ranges.begin(),ranges.end());\\n        vector<vector<int>> v;\\n        for(int x=1; x<n; x++)\\n        {\\n            if(ranges[x][0]<=ranges[x-1][1])\\n            {\\n                ranges[x][0]=min(ranges[x-1][0],ranges[x][0]);\\n                ranges[x][1]=max(ranges[x-1][1],ranges[x][1]);\\n            }\\n            else v.push_back(ranges[x-1]);\\n        }\\n        v.push_back(ranges[n-1]);\\n        int sz=v.size();\\n        int ans=1;\\n        while(sz--)\\n        {\\n            ans*=2;\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countWays(vector<vector<int>>& ranges) \\n    {\\n        int mod=1e9+7;\\n        int n=ranges.size();\\n        sort(ranges.begin(),ranges.end());\\n        vector<vector<int>> v;\\n        for(int x=1; x<n; x++)\\n        {\\n            if(ranges[x][0]<=ranges[x-1][1])\\n            {\\n                ranges[x][0]=min(ranges[x-1][0],ranges[x][0]);\\n                ranges[x][1]=max(ranges[x-1][1],ranges[x][1]);\\n            }\\n            else v.push_back(ranges[x-1]);\\n        }\\n        v.push_back(ranges[n-1]);\\n        int sz=v.size();\\n        int ans=1;\\n        while(sz--)\\n        {\\n            ans*=2;\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259121,
                "title": "golang-sort-merge-and-compute",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is simple:\\n\\n1. We will split all `ranges` into **subgroups**. All `ranges` in the same subgroup are overlapped, thus can form a larger range.\\n2. We will use the **subgroups** to compute the answer. We will just have to consider how many ways are there to **put `m` subgroups into `2` groups**\\n\\n# Code\\n```\\nfunc countWays(ranges [][]int) int {\\n    // sort the ranges to help merge ranges into subgroups\\n    sort.Slice(ranges, func(i, j int) bool {\\n        if ranges[i][0] < ranges[j][0] {\\n            return true\\n        } else if ranges[i][0] == ranges[j][0] {\\n            return ranges[i][1] <= ranges[j][1]\\n        } else {\\n            return false\\n        }\\n    })\\n    \\n    cnt := 1\\n    curEnd := ranges[0][1]\\n    // we count the numbers of subgroups\\n    for i := 1; i < len(ranges); i++ {\\n        if ranges[i][0] <= curEnd {\\n            if curEnd < ranges[i][1] {\\n                curEnd = ranges[i][1]\\n            }\\n        } else {\\n            cnt++\\n            curEnd = ranges[i][1]\\n        }\\n    }\\n    ans := 1\\n\\n    // simple math to compute the answer: ans = 2 ^ cnt\\n    for cnt != 0 {\\n        ans = (ans * 2) % (1e9 + 7)\\n        cnt--\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countWays(ranges [][]int) int {\\n    // sort the ranges to help merge ranges into subgroups\\n    sort.Slice(ranges, func(i, j int) bool {\\n        if ranges[i][0] < ranges[j][0] {\\n            return true\\n        } else if ranges[i][0] == ranges[j][0] {\\n            return ranges[i][1] <= ranges[j][1]\\n        } else {\\n            return false\\n        }\\n    })\\n    \\n    cnt := 1\\n    curEnd := ranges[0][1]\\n    // we count the numbers of subgroups\\n    for i := 1; i < len(ranges); i++ {\\n        if ranges[i][0] <= curEnd {\\n            if curEnd < ranges[i][1] {\\n                curEnd = ranges[i][1]\\n            }\\n        } else {\\n            cnt++\\n            curEnd = ranges[i][1]\\n        }\\n    }\\n    ans := 1\\n\\n    // simple math to compute the answer: ans = 2 ^ cnt\\n    for cnt != 0 {\\n        ans = (ans * 2) % (1e9 + 7)\\n        cnt--\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259042,
                "title": "two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstep 1: Sort the vector.\\nstep 2: Keep track of the minimum and maximum range in the vector using two pointer approach if the current maximum is greater than the starting of the current range then update the curr maximum.Not need to update the current minimum because vector is already in sorted order.\\nstep 3: if the current maximum is strictly smaller than the starting of the current range than update the current maximum and minimum. and increase the count of distinctranges.\\nstep 4: call the power function. And return the value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n), where n is the size of the 2D vector.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int power(long long a, long long distinctRanges, long long mod){\\n      long long val=1;\\n        a%=mod;\\n        while(distinctRanges>0){\\n            if(distinctRanges&1){\\n                val*=a;\\n                val%=mod;\\n            }\\n            distinctRanges>>=1;\\n            a*=a;\\n            a%=mod;\\n        }\\n        return val;\\n    }\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int mn=ranges[0][0];\\n        int mx=ranges[0][1];\\n        \\n        long long distinctRanges=0;\\n        for(int i=1; i<ranges.size(); i++){\\n            if(ranges[i][0]<=mx){\\n                mx=max(mx,ranges[i][1]);\\n            }\\n            else{\\n                distinctRanges++;\\n                // update to new ranges\\n                mn=ranges[i][0];\\n                mx=ranges[i][1];\\n            }\\n        }\\n        distinctRanges++;\\n        long long mod=1e9+7;\\n        int totalWays=power(2,distinctRanges,mod);\\n        return totalWays;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int power(long long a, long long distinctRanges, long long mod){\\n      long long val=1;\\n        a%=mod;\\n        while(distinctRanges>0){\\n            if(distinctRanges&1){\\n                val*=a;\\n                val%=mod;\\n            }\\n            distinctRanges>>=1;\\n            a*=a;\\n            a%=mod;\\n        }\\n        return val;\\n    }\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int mn=ranges[0][0];\\n        int mx=ranges[0][1];\\n        \\n        long long distinctRanges=0;\\n        for(int i=1; i<ranges.size(); i++){\\n            if(ranges[i][0]<=mx){\\n                mx=max(mx,ranges[i][1]);\\n            }\\n            else{\\n                distinctRanges++;\\n                // update to new ranges\\n                mn=ranges[i][0];\\n                mx=ranges[i][1];\\n            }\\n        }\\n        distinctRanges++;\\n        long long mod=1e9+7;\\n        int totalWays=power(2,distinctRanges,mod);\\n        return totalWays;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258766,
                "title": "java-solution-with-inline-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        \\n\\n        final long MOD = 1000000007;\\n        long ans = 1;\\n        \\n        if (ranges.length == 1) return 2;\\n        \\n        //sorting the arrays by first index or minimun range value\\n        Arrays.sort(ranges,(int[] o1, int[] o2) -> o1[0] - o2[0]);\\n\\n        //or using comparator\\n        /**\\n        Arrays.sort(ranges, new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b) {\\n                return a[0] - b[0];\\n            }\\n        });\\n         */\\n        List<int[]> list = new ArrayList<>();\\n        //the list contains all possible ranges that can be placed into groups\\n        int count=0;\\n        for (int[] i : ranges)\\n        {\\n            if(list.isEmpty() || list.get(list.size()-1)[1] < i[0])\\n            {\\n                list.add(i);\\n                ++count;\\n            }\\n            else\\n            {\\n                //setting new max of range here \\n                list.get(list.size()-1)[1] = Math.max(list.get(list.size()-1)[1], i[1]);\\n            }\\n        }\\n\\n        //since each range can be placed in 2 groups that means for every range we will \\n        //have to multiply it by 2\\n        //for ex if we have 3 ranges then = 2*2*2\\n        //if we have 4 then = 2*2*2*2 and so on\\n\\n\\n        //keep multiplying ans by 2 till we get the answer\\n        //remember Math.pow will return double\\n        for(int i=0;i<count;i++)\\n        {\\n             ans = ((ans * 2) % (long)MOD);\\n        }\\n\\n\\n        \\n        \\n        return (int)ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        \\n\\n        final long MOD = 1000000007;\\n        long ans = 1;\\n        \\n        if (ranges.length == 1) return 2;\\n        \\n        //sorting the arrays by first index or minimun range value\\n        Arrays.sort(ranges,(int[] o1, int[] o2) -> o1[0] - o2[0]);\\n\\n        //or using comparator\\n        /**\\n        Arrays.sort(ranges, new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b) {\\n                return a[0] - b[0];\\n            }\\n        });\\n         */\\n        List<int[]> list = new ArrayList<>();\\n        //the list contains all possible ranges that can be placed into groups\\n        int count=0;\\n        for (int[] i : ranges)\\n        {\\n            if(list.isEmpty() || list.get(list.size()-1)[1] < i[0])\\n            {\\n                list.add(i);\\n                ++count;\\n            }\\n            else\\n            {\\n                //setting new max of range here \\n                list.get(list.size()-1)[1] = Math.max(list.get(list.size()-1)[1], i[1]);\\n            }\\n        }\\n\\n        //since each range can be placed in 2 groups that means for every range we will \\n        //have to multiply it by 2\\n        //for ex if we have 3 ranges then = 2*2*2\\n        //if we have 4 then = 2*2*2*2 and so on\\n\\n\\n        //keep multiplying ans by 2 till we get the answer\\n        //remember Math.pow will return double\\n        for(int i=0;i<count;i++)\\n        {\\n             ans = ((ans * 2) % (long)MOD);\\n        }\\n\\n\\n        \\n        \\n        return (int)ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258645,
                "title": "intuition-easy-sorting-and-math",
                "content": "**INTUITION**\\n* Sort the ranges with respect to first index.\\n* calculate the count of all the overlapping components.\\n* Now, each componet have 2 choices of groups, so our answer would be 2^(count of components).\\n\\n**PLS UPVOTE IF UNDERSTOOD**\\n![image](https://assets.leetcode.com/users/images/e3c969ab-ecba-4438-a572-09a3880d2537_1677993581.1846795.jpeg)\\n\\n***C++ CODE***\\n\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        vector<int>r={ranges[0][0],ranges[0][1]};\\n        int cnt=1;\\n        for(int i=1;i<ranges.size();i++)\\n        {\\n            if(r[1]>=ranges[i][0])\\n            {\\n                r[1]=max(r[1],ranges[i][1]);\\n            }\\n            else\\n            {\\n                cnt++;\\n                r[0]=ranges[i][0];\\n                r[1]=ranges[i][1];\\n            }\\n        }\\n        long long ans=1;\\n        for(int i=1;i<=cnt;i++)\\n        {\\n            ans = ans%1000000007 * 2;\\n            ans=ans%1000000007;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```\\n\\n**U\\nP\\nV\\nO\\nT\\nE**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        vector<int>r={ranges[0][0],ranges[0][1]};\\n        int cnt=1;\\n        for(int i=1;i<ranges.size();i++)\\n        {\\n            if(r[1]>=ranges[i][0])\\n            {\\n                r[1]=max(r[1],ranges[i][1]);\\n            }\\n            else\\n            {\\n                cnt++;\\n                r[0]=ranges[i][0];\\n                r[1]=ranges[i][1];\\n            }\\n        }\\n        long long ans=1;\\n        for(int i=1;i<=cnt;i++)\\n        {\\n            ans = ans%1000000007 * 2;\\n            ans=ans%1000000007;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258584,
                "title": "c-detailed-explanation-with-examples-merging-intervals-and-bitwise-power-modulo-254ms-71mb",
                "content": "This problem can be split into three parts easier to tackle:\\n* merging/clustering overlapping intervals, as mandated;\\n* figure out how many permutations we can get from all the clusters we found;\\n* some extra math to compute the result for much larger values.\\n\\nNow, how will tackle them:\\n* sorting all the intervals by increasing starting time first and decreasing ending time next, we will be able to quickly count all the overlapping clusters in a single pass (as explained more in details in the implementation);\\n* given the amount of clusters, since we have two possible groups in which to fit each element, we will come up with $2^{clusters}$ different permutations;\\n* the last bit can be quickly obtained with a bit of bitwise magic, computing the power operation in logarithic time as explained in a more diffused way [here](https://leetcode.com/problems/powx-n/solutions/739646/) (spoilers alert: solution of another challenge).\\n\\nNow, to start coding this solution, we will declare a support `clusters` initialised to `1` (we will always have at least one cluster), then sort `ranges` so that we will have all the intervals ordered by whichever starts first; if two or more intervals start at the same time, we will have the longest ones first (ie: sorted by decreasing ending time).\\n\\nThis will allow us to easily spot overlappings; going with `1` through all the elements in the newly sorted `ranges` and using `last` initialised with the value of where the first element ends, we will:\\n* create `el` as a reference to `ranges[i]`;\\n* deal with two cases - if the current starting time (`el[0]`) is smaller than or equal to where our interval ends, we will just update `last` to be the greater between its current value and where the new interval ends (ie: `e[1]`);\\n* otherwise, it means we found a new cluster and then we will:\\n    * increase the `cluster` counter by `1`;\\n    * update `last` to be the value at which the current interval `el` ends (ie: `el[1]`).\\n\\nTo clarify this bit with an example, let\\'s assume that we have `ranges` (already sorted) as `{{1, 7}, {1, 5}, {2, 8}, {10, 20}, {18, 24}}`.\\n\\nWe will start with `clusters` initialised to `1` and an initial value of `last` equal to `7` (ending time of the first value) and then:\\n* parse `{1, 5}` and find that it is in the same interval, since it starts with a value `<= last`; `last` is now still `7`;\\n* parse `{2, 8}` and find that it is in the same interval, since it starts with a value `<= last`; `last` is now `8`;\\n* parse `{10, 20}` and find that it is NOT in the same interval, since it does NOT with a value `<= last`; `last` is now `20`, `clusters` is increased by `1` (for a total of `2`);\\n* parse `{18, 24}` and find that it is in the same interval, since it starts with a value `<= last`; `last` is now still `20`.\\n\\nSo, in total, we found that we have `2` clusters, which is correct!\\n\\nFor the second part, since it is allowed to leave either group empty, it means that each cluster can be put in either the first or the second group or, in other words, we have $2^{clusters}$ different ways (permutations) to shuffle our `clusters`.\\n\\nFinally, we will pass the number of `clusters` to our helper `powerMod`, that is just a curried version of [my `pow(x, y)` solution](https://leetcode.com/problems/powx-n/solutions/739646/) computing modulo at each step and `return` the resulting value :)\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nconstexpr long long modVal = 1000000007;\\n\\nclass Solution {\\n    long long powerMod(long long n) {\\n        // support variables\\n        long long res = 1, multi = 2;\\n        // getting res\\n        while (n) {\\n            if (n & 1) res = res * multi % modVal;\\n            multi = multi * multi % modVal;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        // support variables\\n        int clusters = 1;\\n        // getting all the early starts, longest ones first\\n        sort(begin(ranges), end(ranges), [](auto &a, auto &b){\\n            return a[0] != b[0] ? a[0] < b[0] : a[1] > b[1];\\n        });\\n        for (int i = 1, lmt = ranges.size(), last = ranges[0][1]; i < lmt; i++) {\\n            auto &el = ranges[i];\\n            // first case: still part of the current interval\\n            if (el[0] <= last) last = max(last, el[1]);\\n            // second case: new interval\\n            else clusters++, last = el[1];\\n        }\\n        return powerMod(clusters);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation",
                    "Combinatorics"
                ],
                "code": "```cpp\\nconstexpr long long modVal = 1000000007;\\n\\nclass Solution {\\n    long long powerMod(long long n) {\\n        // support variables\\n        long long res = 1, multi = 2;\\n        // getting res\\n        while (n) {\\n            if (n & 1) res = res * multi % modVal;\\n            multi = multi * multi % modVal;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        // support variables\\n        int clusters = 1;\\n        // getting all the early starts, longest ones first\\n        sort(begin(ranges), end(ranges), [](auto &a, auto &b){\\n            return a[0] != b[0] ? a[0] < b[0] : a[1] > b[1];\\n        });\\n        for (int i = 1, lmt = ranges.size(), last = ranges[0][1]; i < lmt; i++) {\\n            auto &el = ranges[i];\\n            // first case: still part of the current interval\\n            if (el[0] <= last) last = max(last, el[1]);\\n            // second case: new interval\\n            else clusters++, last = el[1];\\n        }\\n        return powerMod(clusters);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258010,
                "title": "c-easy-solution",
                "content": "\\n# Approach\\nFirst count total number of groups are there in total, by combining the groups into one group.\\nAnd Second simple Combination of the formed groups into two groups.\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int power(long long x, int y, int p) {\\n    int res = 1; \\n    x = x % p;\\n    if (x == 0) return 0;\\n    while (y > 0)\\n    {\\n        if (y & 1)\\n            res = (res*x) % p;\\n        y = y>>1;\\n        x = (x*x) % p;\\n    }\\n    return res;\\n}\\n \\n\\n    int countWays(vector<vector<int>>& ranges) {\\n        const int mod = 1e9 + 7;\\n        sort(ranges.begin(), ranges.end());\\n        long long total = 0, last = -1;\\n        for(int i = 0; i < ranges.size(); i++){\\n            if(ranges[i][0] > last){\\n                last = ranges[i][1];\\n                total++;\\n            }\\n            else last = max(last,(long long)ranges[i][1]);\\n        }\\n        return power(2, total, mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Sort",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int power(long long x, int y, int p) {\\n    int res = 1; \\n    x = x % p;\\n    if (x == 0) return 0;\\n    while (y > 0)\\n    {\\n        if (y & 1)\\n            res = (res*x) % p;\\n        y = y>>1;\\n        x = (x*x) % p;\\n    }\\n    return res;\\n}\\n \\n\\n    int countWays(vector<vector<int>>& ranges) {\\n        const int mod = 1e9 + 7;\\n        sort(ranges.begin(), ranges.end());\\n        long long total = 0, last = -1;\\n        for(int i = 0; i < ranges.size(); i++){\\n            if(ranges[i][0] > last){\\n                last = ranges[i][1];\\n                total++;\\n            }\\n            else last = max(last,(long long)ranges[i][1]);\\n        }\\n        return power(2, total, mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257934,
                "title": "python3-sort-solution-merge-intervals",
                "content": "Whole solution, except return is a task [Merge intervals](https://leetcode.com/problems/merge-intervals/)\\n```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        mod = 10 ** 9 + 7\\n        ranges.sort()\\n        ans = [ranges[0]]\\n        \\n        for interval in ranges:\\n            if interval[0] <= ans[-1][1]:\\n                ans[-1][1] = max(ans[-1][1], interval[1])\\n            else:\\n                ans.append(interval)\\n                \\n        return pow(2, len(ans)) % mod\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        mod = 10 ** 9 + 7\\n        ranges.sort()\\n        ans = [ranges[0]]\\n        \\n        for interval in ranges:\\n            if interval[0] <= ans[-1][1]:\\n                ans[-1][1] = max(ans[-1][1], interval[1])\\n            else:\\n                ans.append(interval)\\n                \\n        return pow(2, len(ans)) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257916,
                "title": "c-easy-100-beats-with-prove-simple-approach-with-full-explanation",
                "content": "![Screenshot 2023-03-05 075800.png](https://assets.leetcode.com/users/images/55aec413-1586-446f-8ee0-bc115765e16a_1677983295.711912.png)\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int mod=1e9+7;\\n    \\n    int countWays(vector<vector<int>>& r) {\\n        sort(r.begin(),r.end());\\n        \\n        int str=r[0][0];  //store start value its not work nly for understand\\n\\n        int end=r[0][1];  // store end value\\n        int cnt=2;\\n        for(int i=1;i<r.size();i++){\\n            \\n            //merging all intervals to find how many different interval created \\n            //which can\\'t be merge\\n            if(r[i][0] > end){\\n                cnt=(cnt*2)%mod; // each group makes two groups either 1 or 2\\n                end=r[i][1];\\n            }else{\\n                if(r[i][1] > end)end=r[i][1];\\n            }\\n        }\\n\\n        return cnt % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mod=1e9+7;\\n    \\n    int countWays(vector<vector<int>>& r) {\\n        sort(r.begin(),r.end());\\n        \\n        int str=r[0][0];  //store start value its not work nly for understand\\n\\n        int end=r[0][1];  // store end value\\n        int cnt=2;\\n        for(int i=1;i<r.size();i++){\\n            \\n            //merging all intervals to find how many different interval created \\n            //which can\\'t be merge\\n            if(r[i][0] > end){\\n                cnt=(cnt*2)%mod; // each group makes two groups either 1 or 2\\n                end=r[i][1];\\n            }else{\\n                if(r[i][1] > end)end=r[i][1];\\n            }\\n        }\\n\\n        return cnt % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257856,
                "title": "very-easy-java-soln-i-am-doing-silly-mistake-not-able-to-solve-during-contest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBy first sorting on the basis of starting ranges and then simply applying greedy\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        long r = (long)(1e9+7) ;\\n        int count =  1;\\n        if(ranges.length ==1)\\n            return 2 ;\\n        Arrays.sort(ranges ,(nums1 ,nums2)->\\n                    nums1[0]-nums2[0]);\\n       \\n        int max = ranges[0][1];\\n        for(int i = 1 ;i<ranges.length ;i++){\\n            if(max>=ranges[i][0]){\\n                count++;\\n               \\n            }\\n             max = Math.max(max,ranges[i][1]);\\n                \\n        }\\n        int n = (ranges.length -count)+1;\\n        long res = 1 ;\\n        for(int i = 0 ;i<n;i++){\\n        res = res *2 ;\\n        res = res % r;\\n        }\\n        return (int )res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        long r = (long)(1e9+7) ;\\n        int count =  1;\\n        if(ranges.length ==1)\\n            return 2 ;\\n        Arrays.sort(ranges ,(nums1 ,nums2)->\\n                    nums1[0]-nums2[0]);\\n       \\n        int max = ranges[0][1];\\n        for(int i = 1 ;i<ranges.length ;i++){\\n            if(max>=ranges[i][0]){\\n                count++;\\n               \\n            }\\n             max = Math.max(max,ranges[i][1]);\\n                \\n        }\\n        int n = (ranges.length -count)+1;\\n        long res = 1 ;\\n        for(int i = 0 ;i<n;i++){\\n        res = res *2 ;\\n        res = res % r;\\n        }\\n        return (int )res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257849,
                "title": "python-merge-interval",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMerge interval.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort()\\n        q = [ranges[0]]\\n        for s, e in ranges[1:]:\\n            tail = q[-1]\\n            if s <= tail[-1]:\\n                q[-1] = [tail[0], max(tail[1], e)]\\n            else:\\n                q.append([s, e])\\n        return (1 << len(q)) % 1000000007\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort()\\n        q = [ranges[0]]\\n        for s, e in ranges[1:]:\\n            tail = q[-1]\\n            if s <= tail[-1]:\\n                q[-1] = [tail[0], max(tail[1], e)]\\n            else:\\n                q.append([s, e])\\n        return (1 << len(q)) % 1000000007\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257770,
                "title": "c-merge-interval",
                "content": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(), ranges.end());\\n        int n = 0, r = -1;\\n        for(auto& v:ranges){\\n            if(v[0] > r)  n++;\\n            r = max(r, v[1]);\\n        }\\n        long long res = 1, mod = 1e9+7;\\n        while(n--) res = 2*res%mod;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(), ranges.end());\\n        int n = 0, r = -1;\\n        for(auto& v:ranges){\\n            if(v[0] > r)  n++;\\n            r = max(r, v[1]);\\n        }\\n        long long res = 1, mod = 1e9+7;\\n        while(n--) res = 2*res%mod;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257758,
                "title": "c",
                "content": "```\\nclass Solution {\\n    int M = 1e9 + 7 ;\\nlong long POW( long long a, long long b){\\n    a %= M ;\\n    if(b == 0)\\n        return 1 ;\\n    if(b == 1)\\n        return a ;\\n    if(b%2)\\n        return a*POW(a, b-1) % M ;\\n    \\n    return POW(a*a, b/2) % M ;\\n}\\n\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(), ranges.end(),[](vector<int>&a, vector<int>&b){\\n        return a[0] < b[0]; \\n    });\\n        int g = 1 ;\\n        int end = ranges[0][1] ;\\n        for(int i = 1 ; i < ranges.size(); i++){\\n            if(ranges[i][0] <= end)\\n                end = max(end, ranges[i][1]) ;\\n            else{\\n                g++ ;\\n                end = ranges[i][1] ;\\n            }\\n        }\\n        long long ret = POW(2, g) ;\\n        return ret % M;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int M = 1e9 + 7 ;\\nlong long POW( long long a, long long b){\\n    a %= M ;\\n    if(b == 0)\\n        return 1 ;\\n    if(b == 1)\\n        return a ;\\n    if(b%2)\\n        return a*POW(a, b-1) % M ;\\n    \\n    return POW(a*a, b/2) % M ;\\n}\\n\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(), ranges.end(),[](vector<int>&a, vector<int>&b){\\n        return a[0] < b[0]; \\n    });\\n        int g = 1 ;\\n        int end = ranges[0][1] ;\\n        for(int i = 1 ; i < ranges.size(); i++){\\n            if(ranges[i][0] <= end)\\n                end = max(end, ranges[i][1]) ;\\n            else{\\n                g++ ;\\n                end = ranges[i][1] ;\\n            }\\n        }\\n        long long ret = POW(2, g) ;\\n        return ret % M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257745,
                "title": "java-solution",
                "content": "# Intuition\\n\\n1. Using merge intervals problem, merged all the overlapping intervals and then calculate the count ways using dp. \\n    dp[i] = dp[i-1] * 2;\\n\\n# Code\\n```\\nclass Solution {\\n    public int countWays(int[][] intervals) {\\n        if(intervals.length == 1) return 2;\\n        List<int[]> list = new ArrayList<>();\\n        \\n        Arrays.sort(intervals, (a,b) -> (a[0]-b[0]));\\n        \\n        int[] start = intervals[0];\\n        list.add(start);\\n        \\n        for(int i = 1; i<intervals.length; i++) {\\n            if(start[1] >= intervals[i][0]) {\\n                start[1] = Math.max(start[1], intervals[i][1]);\\n            }else {\\n                list.add(intervals[i]);\\n                start = intervals[i];\\n            }\\n        }\\n        return count(list.size());\\n    }\\n\\n    int count(int n) {\\n        int[] dp = new int[n+1];\\n        dp[0] = 0;\\n        dp[1] = 2;\\n\\n        for(int i = 2; i<=n; i++) {\\n            dp[i] = (dp[i-1] * 2)%(int)(Math.pow(10,9) + 7);\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countWays(int[][] intervals) {\\n        if(intervals.length == 1) return 2;\\n        List<int[]> list = new ArrayList<>();\\n        \\n        Arrays.sort(intervals, (a,b) -> (a[0]-b[0]));\\n        \\n        int[] start = intervals[0];\\n        list.add(start);\\n        \\n        for(int i = 1; i<intervals.length; i++) {\\n            if(start[1] >= intervals[i][0]) {\\n                start[1] = Math.max(start[1], intervals[i][1]);\\n            }else {\\n                list.add(intervals[i]);\\n                start = intervals[i];\\n            }\\n        }\\n        return count(list.size());\\n    }\\n\\n    int count(int n) {\\n        int[] dp = new int[n+1];\\n        dp[0] = 0;\\n        dp[1] = 2;\\n\\n        for(int i = 2; i<=n; i++) {\\n            dp[i] = (dp[i-1] * 2)%(int)(Math.pow(10,9) + 7);\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257717,
                "title": "c-solution-merging-overlapping-intervals-optimised-beat-100",
                "content": "# Intuition\\nMerging all overlapping intervals, then counting all intervals.\\n\\n# Approach\\n1. Sorting the vector based on opening interval\\n2. Storing the first interval\\'s starting and ending\\n3. Traversing and merging overlaping interval by comparing if current interval opening is less than last interval or not;\\n4. if it is less than merge them and update closing interval by storing max of both.\\n5. Else increase the group count and update the starting and closing interval to current interval; \\n\\n# Complexity\\n- Time complexity:\\nO(nlogn+n) where n=size of vector\\nnlogn for sorting the vector\\nn for traversing\\n\\n- Space complexity:\\nConstant Space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        \\n        int count=0;\\n        sort(ranges.begin(),ranges.end());\\n        \\n        int first=ranges[0][0];\\n        int last=ranges[0][1];\\n        \\n        //cout<<first<<\"--\"<<last<<\"-p-\";\\n        \\n        for(int i=1;i<ranges.size();i++){\\n            \\n            if(ranges[i][0]<=last){\\n                last=max(last,ranges[i][1]);\\n            }\\n            else{\\n                count++;\\n                first=ranges[i][0];\\n                last=ranges[i][1];\\n            }\\n\\n        }\\n        count++;\\n        long long m=1000000007;\\n        \\n        long long ans=1;\\n        for(int i=0;i<count;i++){\\n            ans=(ans*2)%m;\\n        }\\n        return (int)ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        \\n        int count=0;\\n        sort(ranges.begin(),ranges.end());\\n        \\n        int first=ranges[0][0];\\n        int last=ranges[0][1];\\n        \\n        //cout<<first<<\"--\"<<last<<\"-p-\";\\n        \\n        for(int i=1;i<ranges.size();i++){\\n            \\n            if(ranges[i][0]<=last){\\n                last=max(last,ranges[i][1]);\\n            }\\n            else{\\n                count++;\\n                first=ranges[i][0];\\n                last=ranges[i][1];\\n            }\\n\\n        }\\n        count++;\\n        long long m=1000000007;\\n        \\n        long long ans=1;\\n        for(int i=0;i<count;i++){\\n            ans=(ans*2)%m;\\n        }\\n        return (int)ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3257715,
                "title": "python-count-the-number-of-overlapping-ranges-explained",
                "content": "The key to this problem is to find out the number non-overlapping groups. If we know the total number of non-overlapping group is N, the final answer is (2 ** N) % (1000000007)\\n\\nWe can use a priority queue sort the start and end each range. When we see a start, we can increase a counter, and when we see a end we can decrease the counter. Whenever the counter becomes 0, we do not have any overlapping ranges. \\n\\nTherefore, we just need to count the number of the counter becomes 0 during the process and we know the total number of non-overlapping groups.\\n\\n\\n```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        # get the number of groups\\n        START, END = 0, 1\\n        range_list = []\\n        for s, e in ranges:\\n            heapq.heappush(range_list, (s, START))\\n            heapq.heappush(range_list, (e, END))\\n        \\n        num_groups, range_cnt, cur_boundary = 0, 0, range_list[0][0]\\n        \\n        while range_list:\\n            while range_list and range_list[0][0] == cur_boundary:\\n                _, se = heapq.heappop(range_list)\\n                if se == START:\\n                    range_cnt += 1\\n                else:\\n                    range_cnt -= 1\\n            if range_cnt == 0:\\n                # we found 1 group\\n                num_groups += 1\\n            \\n            if range_list:\\n                cur_boundary = range_list[0][0]\\n        \\n        return (2 ** num_groups) % (1000000007)\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        # get the number of groups\\n        START, END = 0, 1\\n        range_list = []\\n        for s, e in ranges:\\n            heapq.heappush(range_list, (s, START))\\n            heapq.heappush(range_list, (e, END))\\n        \\n        num_groups, range_cnt, cur_boundary = 0, 0, range_list[0][0]\\n        \\n        while range_list:\\n            while range_list and range_list[0][0] == cur_boundary:\\n                _, se = heapq.heappop(range_list)\\n                if se == START:\\n                    range_cnt += 1\\n                else:\\n                    range_cnt -= 1\\n            if range_cnt == 0:\\n                # we found 1 group\\n                num_groups += 1\\n            \\n            if range_list:\\n                cur_boundary = range_list[0][0]\\n        \\n        return (2 ** num_groups) % (1000000007)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257630,
                "title": "c-easy-to-understand-disjoint-set-data-structure-used",
                "content": "# Code\\n```\\n#define ll long long int\\nll mod=1e9+7;\\nll findParent(ll node,vector<ll>& par)\\n{\\n    if(par[node]==node)return node;\\n    return par[node]=findParent(par[node],par);\\n}\\nvoid Union(ll u,ll v,vector<ll> &size,vector<ll> &par)\\n{\\n    ll pu=findParent(u,par);\\n    ll pv=findParent(v,par);\\n    if(pu==pv)return;\\n    if(size[pu]<=size[pv])\\n    {\\n        par[pu]=pv;\\n        size[pv]++;\\n    }\\n    else\\n    {\\n        par[pv]=pu;\\n        size[pu]++;\\n    }\\n}\\nll modexp(ll a,ll b,ll m) {a %= m;ll res = 1LL;while (b > 0) {if (b & 1)res = (res%m *1LL* a%m) % m;a = (a%m *1LL* a%m) % m;b >>= 1;}return res%m;}\\nclass Solution {\\npublic:\\n    bool static comp(vector<int> &v1,vector<int> &v2)\\n    {\\n        return v1[0]<v2[0];\\n    }\\n    int countWays(vector<vector<int>>& ranges) {\\n        \\n        sort(ranges.begin(),ranges.end(),comp);\\n        ll n=ranges.size();\\n        if(n==1)\\n        {\\n            return 2;\\n        }\\n        vector<ll> par(n),size(n);\\n        for(ll i=0;i<n;i++)\\n        {\\n            par[i]=i;\\n        }\\n        // map<ll,ll> last;\\n        ll maxx=-1;\\n        ll idx;\\n        for(ll i=0;i<n;i++)\\n        {\\n            if(ranges[i][0]<=maxx)\\n            {\\n                \\n                Union(i,idx,size,par);\\n                if(ranges[i][1]>maxx)\\n                {\\n                    maxx=ranges[i][1];\\n                    idx=i;\\n                }\\n            }\\n            else\\n            {\\n                 if(ranges[i][1]>maxx)\\n                {\\n                    maxx=ranges[i][1];\\n                    idx=i;\\n                }\\n            }\\n        }\\n \\n        map<ll,ll> mp;\\n        for(ll i=0;i<n;i++)\\n        {\\n            mp[findParent(i,par)]++;\\n        }\\n        ll z=mp.size();\\n        return modexp(2,z,mod);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nll mod=1e9+7;\\nll findParent(ll node,vector<ll>& par)\\n{\\n    if(par[node]==node)return node;\\n    return par[node]=findParent(par[node],par);\\n}\\nvoid Union(ll u,ll v,vector<ll> &size,vector<ll> &par)\\n{\\n    ll pu=findParent(u,par);\\n    ll pv=findParent(v,par);\\n    if(pu==pv)return;\\n    if(size[pu]<=size[pv])\\n    {\\n        par[pu]=pv;\\n        size[pv]++;\\n    }\\n    else\\n    {\\n        par[pv]=pu;\\n        size[pu]++;\\n    }\\n}\\nll modexp(ll a,ll b,ll m) {a %= m;ll res = 1LL;while (b > 0) {if (b & 1)res = (res%m *1LL* a%m) % m;a = (a%m *1LL* a%m) % m;b >>= 1;}return res%m;}\\nclass Solution {\\npublic:\\n    bool static comp(vector<int> &v1,vector<int> &v2)\\n    {\\n        return v1[0]<v2[0];\\n    }\\n    int countWays(vector<vector<int>>& ranges) {\\n        \\n        sort(ranges.begin(),ranges.end(),comp);\\n        ll n=ranges.size();\\n        if(n==1)\\n        {\\n            return 2;\\n        }\\n        vector<ll> par(n),size(n);\\n        for(ll i=0;i<n;i++)\\n        {\\n            par[i]=i;\\n        }\\n        // map<ll,ll> last;\\n        ll maxx=-1;\\n        ll idx;\\n        for(ll i=0;i<n;i++)\\n        {\\n            if(ranges[i][0]<=maxx)\\n            {\\n                \\n                Union(i,idx,size,par);\\n                if(ranges[i][1]>maxx)\\n                {\\n                    maxx=ranges[i][1];\\n                    idx=i;\\n                }\\n            }\\n            else\\n            {\\n                 if(ranges[i][1]>maxx)\\n                {\\n                    maxx=ranges[i][1];\\n                    idx=i;\\n                }\\n            }\\n        }\\n \\n        map<ll,ll> mp;\\n        for(ll i=0;i<n;i++)\\n        {\\n            mp[findParent(i,par)]++;\\n        }\\n        ll z=mp.size();\\n        return modexp(2,z,mod);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257566,
                "title": "sorting-ranges",
                "content": "# Approach\\nSort ranges by first coordinate. Overlapping ranges form group that should be placed together. So calculate all groups - n. The result is 2^n modulo 1e9+7\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountWays(int[][] ranges)\\n    {\\n        Array.Sort(ranges, (r1, r2) => r1[0] - r2[0]);\\n\\n        int n = ranges.Length;\\n        int right = ranges[0][1];\\n        for (int i = 1; i < ranges.Length; i++)\\n        {\\n            if (ranges[i][0] <= right)\\n            {\\n                n--;\\n            }\\n\\n            right = Math.Max(right, ranges[i][1]);\\n        }\\n\\n        long pow2 = 2;\\n        long result = 1;\\n        long modulo = 1000000007;\\n\\n        while (n > 0)\\n        {\\n            if (n % 2 == 1)\\n            {\\n                result = (result * pow2) % modulo;\\n            }\\n\\n            pow2 = (pow2 * pow2) % modulo;\\n            n = n / 2;\\n        }\\n\\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountWays(int[][] ranges)\\n    {\\n        Array.Sort(ranges, (r1, r2) => r1[0] - r2[0]);\\n\\n        int n = ranges.Length;\\n        int right = ranges[0][1];\\n        for (int i = 1; i < ranges.Length; i++)\\n        {\\n            if (ranges[i][0] <= right)\\n            {\\n                n--;\\n            }\\n\\n            right = Math.Max(right, ranges[i][1]);\\n        }\\n\\n        long pow2 = 2;\\n        long result = 1;\\n        long modulo = 1000000007;\\n\\n        while (n > 0)\\n        {\\n            if (n % 2 == 1)\\n            {\\n                result = (result * pow2) % modulo;\\n            }\\n\\n            pow2 = (pow2 * pow2) % modulo;\\n            n = n / 2;\\n        }\\n\\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257545,
                "title": "sort-python",
                "content": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        \\n        merged_interval = []\\n        ranges.sort()\\n        \\n        merged_interval.append(ranges[0])\\n        for i in range(1,len(ranges)):\\n            x,y = merged_interval[-1]\\n            curr_x,curr_y = ranges[i]\\n            if y >= curr_x:\\n                merged_interval[-1] = [x,max(curr_y,y)]\\n            else:\\n                merged_interval.append([curr_x,curr_y])\\n        \\n        n = len(merged_interval)\\n       \\n        return (2**n)%(10**9+7)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        \\n        merged_interval = []\\n        ranges.sort()\\n        \\n        merged_interval.append(ranges[0])\\n        for i in range(1,len(ranges)):\\n            x,y = merged_interval[-1]\\n            curr_x,curr_y = ranges[i]\\n            if y >= curr_x:\\n                merged_interval[-1] = [x,max(curr_y,y)]\\n            else:\\n                merged_interval.append([curr_x,curr_y])\\n        \\n        n = len(merged_interval)\\n       \\n        return (2**n)%(10**9+7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257541,
                "title": "c-o-n-solution-beats-100-time-intuitive-approach",
                "content": "## Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe\\'ve two groups to split ranges into. So for each of the ranges, we have 2 options, either put it in group 1 or group 2. So this basically is asking for the answer as (2^n) % 1e9+7. where \\'n\\' is the number of exclusively non-overlaping ranges. \\n\\n1. We can sort the given ranges array so that we can compare and merge the overlaping ranges into a single range.\\n2. Sorting makes it easier to compare as it brings start of each range together. \\n3. Whenever we find two consecutive range satisfying ```(ranges[i][1] >= ranges[i+1][0])``` ,we will merge this two ranges into a single range with ```max_range = max(ranges[i][1], ranges[i+1][1])```.\\n\\n## Complexity\\n- Time complexity: $$O(nlogn) + O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\uD83D\\uDE01\\uD83D\\uDE01***Talk is cheap, let\\'s check out the code***\\uD83D\\uDE01\\uD83D\\uDE01\\n\\n## \\uD83D\\uDE80Code :\\n```\\nclass Solution {\\nconst unsigned int mod = 1e9+7;\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n\\n        sort(ranges.begin(), ranges.end());\\n\\n        int x=1, max_range = ranges[0][1];\\n        for(int i=0; i<ranges.size()-1; i++) {\\n            if(max_range < ranges[i+1][0]) {\\n                max_range = ranges[i+1][1];\\n                x = ((x % mod) * 2) % mod;\\n            } else \\n                max_range = max({max_range, ranges[i][1], ranges[i+1][1]});\\n        }\\n\\n        return x = ((x % mod) * 2) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```(ranges[i][1] >= ranges[i+1][0])```\n```max_range = max(ranges[i][1], ranges[i+1][1])```\n```\\nclass Solution {\\nconst unsigned int mod = 1e9+7;\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n\\n        sort(ranges.begin(), ranges.end());\\n\\n        int x=1, max_range = ranges[0][1];\\n        for(int i=0; i<ranges.size()-1; i++) {\\n            if(max_range < ranges[i+1][0]) {\\n                max_range = ranges[i+1][1];\\n                x = ((x % mod) * 2) % mod;\\n            } else \\n                max_range = max({max_range, ranges[i][1], ranges[i+1][1]});\\n        }\\n\\n        return x = ((x % mod) * 2) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257479,
                "title": "simple-c-solution-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        \\n        int n = ranges.size();\\n        int mod = 1000000007;\\n        \\n        //Sort the given array.\\n        sort(ranges.begin(), ranges.end());\\n        \\n        //Maintain a count variable to keep track of total no. of overlapping intervals\\n        int cnt = 0; \\n        int i=0, j=i+1;\\n\\n        //We traverse the array and check for merging intervals.\\n        while(j<n){\\n            if(ranges[i][1] >= ranges[j][0]){\\n                j++;\\n                cnt++;\\n            }\\n            else{\\n                i++;\\n                if(i == j){\\n                    j++;\\n                }\\n            }\\n            \\n        }\\n        \\n        //At last, calculate 2^(n-cnt)%mod.\\n        //We do (n-cnt) as we consider all merging intervals as one group.\\n        int res = 1;\\n        for(int i=0;i<n-cnt;i++){\\n            res = (res*2)%mod;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        \\n        int n = ranges.size();\\n        int mod = 1000000007;\\n        \\n        //Sort the given array.\\n        sort(ranges.begin(), ranges.end());\\n        \\n        //Maintain a count variable to keep track of total no. of overlapping intervals\\n        int cnt = 0; \\n        int i=0, j=i+1;\\n\\n        //We traverse the array and check for merging intervals.\\n        while(j<n){\\n            if(ranges[i][1] >= ranges[j][0]){\\n                j++;\\n                cnt++;\\n            }\\n            else{\\n                i++;\\n                if(i == j){\\n                    j++;\\n                }\\n            }\\n            \\n        }\\n        \\n        //At last, calculate 2^(n-cnt)%mod.\\n        //We do (n-cnt) as we consider all merging intervals as one group.\\n        int res = 1;\\n        for(int i=0;i<n-cnt;i++){\\n            res = (res*2)%mod;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257435,
                "title": "c-solution-t-c-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort the ranges then count the number of ranges that lie in one group.\\nthen we have to pick 0,1,2,...n sets from that set of ranges to divide into 2 groups.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor e.g - \\n[[0,0],[8,9],[12,13],[1,3]]\\nThere are 4 set of ranges [0,0],[1,3],[8,9] and [12,13].Now we have to pick 0,1,2..n set of ranges to divide into two groups.(n = number of sets).\\n\\nBasically we have to find out 4C0 + 4C1 + 4C2 + 4C3 + 4C4, which is equal to 2^4. \\n\\n[[1,3],[10,20],[2,5],[4,8]]\\nIn this example, there are 2 set of ranges [[1,3],[2,5],[4,8]] and [10,20]. **(Overlapping ranges should lie in one group).**\\nSimilarly as example 1, we will find out 2^2\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int s = ranges[0][0],e = ranges[0][1],cnt = 1;\\n        // loop to count number of set of ranges\\n        for(int i = 1;i < ranges.size();i++){\\n            if(ranges[i][0] >= s && ranges[i][0] <= e){\\n                e = max(ranges[i][1],e);\\n            }\\n            else{\\n                cnt++;\\n                s = ranges[i][0];\\n                e = ranges[i][1];\\n            }\\n        }\\n        int ans = 1,m = 1e9 + 7;\\n        // loop to find 2^n\\n        for(int i = 1;i <= cnt;i++){\\n            ans = ((ans%m)*(2))%m;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int s = ranges[0][0],e = ranges[0][1],cnt = 1;\\n        // loop to count number of set of ranges\\n        for(int i = 1;i < ranges.size();i++){\\n            if(ranges[i][0] >= s && ranges[i][0] <= e){\\n                e = max(ranges[i][1],e);\\n            }\\n            else{\\n                cnt++;\\n                s = ranges[i][0];\\n                e = ranges[i][1];\\n            }\\n        }\\n        int ans = 1,m = 1e9 + 7;\\n        // loop to find 2^n\\n        for(int i = 1;i <= cnt;i++){\\n            ans = ((ans%m)*(2))%m;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257158,
                "title": "runtime-beats-100-c-code",
                "content": "/*\\nRuntime beats 100%| C++ code\\n\\nIdea: \\nSort intervals and merge if ranges overlap. \\nThis will give you count of distinct ranges. \\nThen we need to count all permutations of putting these ranges in 2 groups. \\nSince each group can be kept in both of the groups, the result will be pow(2, count_distinct).\\nThe result could be very large,so we need to return result%(10^9 + 7). We can\\'t really store result anywhere. So we need to do modulus while calculating the power of 2 itself. Check mymod method.\\n*/\\n\\n> /*Code*/\\n\\nclass Solution {\\npublic:\\n\\n    int mymod(int count, int mod)\\n    {\\n        int res = 1;\\n        for (int i = 1; i < count; i++) {\\n            res = (res * 2) % mod;\\n        }\\n        return res;\\n    }\\n\\n    int countWays(vector<vector<int>>& ranges) {\\n\\n        int mod = pow(10,9)+7;\\n        int sz = ranges.size();\\n        sort(ranges.begin(),ranges.end());\\n        int count = 1;\\n        int last = ranges[0][1];\\n        for(int i=1;i<sz;i++) {\\n            if(ranges[i][0] > last){\\n                count++;\\n            }\\n            last=max(last,ranges[i][1]);\\n        }\\n        return mymod(count+1, mod);\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int mymod(int count, int mod)\\n    {\\n        int res = 1;\\n        for (int i = 1; i < count; i++) {\\n            res = (res * 2) % mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3257151,
                "title": "beats-by-100-nlogn-solution",
                "content": "# Intuition\\nsince we need to put the overlapping intervals together why not merge the over lapping intervals\\n\\n# Approach\\nmerge the overlapping intervals and count the number of intervals remaining then we need 2^count as the answer and since we have to mod (2^n) with 1e9+7 therefore make a fast power calculating function\\n\\n# Complexity\\n- Time complexity:\\no(nlogn)\\n\\n- Space complexity:\\nreccursion stack space only \\no(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        Arrays.sort(ranges,new compy());\\n        int min=ranges[0][0];\\n        int max=ranges[0][1];\\n        int count=0;\\n        for(int i =1;i<ranges.length;i++){\\n            if(ranges[i][0]>=min && ranges[i][0]<=max){\\n                max=Math.max(max,ranges[i][1]);\\n            }else{\\n                count++;\\n                min = ranges[i][0];\\n                max=ranges[i][1];\\n            }\\n        }\\n        count++;\\n        return (int)fast_pow(2,count,1000000007);\\n        \\n    }\\n    class compy implements Comparator<int[]>{\\n        public int compare(int[] a , int[] b){\\n            return a[0]==b[0]?a[1]-b[1]:a[0]-b[0];\\n        }\\n    }\\n    public long fast_pow(long base, long  n,long M) \\n    {\\n        if(n==0)\\n           return 1;\\n        if(n==1)\\n        return base;\\n        long halfn=fast_pow(base,n/2,M);\\n        if(n%2==0)\\n            return ( halfn * halfn ) % M;\\n        else\\n            return ( ( ( halfn * halfn ) % M ) * base ) % M;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        Arrays.sort(ranges,new compy());\\n        int min=ranges[0][0];\\n        int max=ranges[0][1];\\n        int count=0;\\n        for(int i =1;i<ranges.length;i++){\\n            if(ranges[i][0]>=min && ranges[i][0]<=max){\\n                max=Math.max(max,ranges[i][1]);\\n            }else{\\n                count++;\\n                min = ranges[i][0];\\n                max=ranges[i][1];\\n            }\\n        }\\n        count++;\\n        return (int)fast_pow(2,count,1000000007);\\n        \\n    }\\n    class compy implements Comparator<int[]>{\\n        public int compare(int[] a , int[] b){\\n            return a[0]==b[0]?a[1]-b[1]:a[0]-b[0];\\n        }\\n    }\\n    public long fast_pow(long base, long  n,long M) \\n    {\\n        if(n==0)\\n           return 1;\\n        if(n==1)\\n        return base;\\n        long halfn=fast_pow(base,n/2,M);\\n        if(n%2==0)\\n            return ( halfn * halfn ) % M;\\n        else\\n            return ( ( ( halfn * halfn ) % M ) * base ) % M;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257140,
                "title": "lil-tricky",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    int mod=1e9+7;\\n    int countWays(vector<vector<int>>& range) {\\n        sort(range.begin(),range.end());\\n        int count=0;\\n        int n=range.size();\\n        int i=0;\\n        while(i<n){\\n            int j=i+1;\\n            int maxi=range[i][1];\\n            while(j<n and range[j][0]<=maxi){\\n                if(j<n)\\n                maxi=max(maxi,range[j][1]);\\n                i++;\\n                j++;\\n            }\\n            i++;\\n            if(j<n)\\n                maxi=range[j][1];\\n            count++;\\n        }\\n        // cout<<count<<\" \";\\n        int ans=1;\\n        for(int i=1;i<=count;i++){\\n            ans*=2;\\n            ans=ans%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int mod=1e9+7;\\n    int countWays(vector<vector<int>>& range) {\\n        sort(range.begin(),range.end());\\n        int count=0;\\n        int n=range.size();\\n        int i=0;\\n        while(i<n){\\n            int j=i+1;\\n            int maxi=range[i][1];\\n            while(j<n and range[j][0]<=maxi){\\n                if(j<n)\\n                maxi=max(maxi,range[j][1]);\\n                i++;\\n                j++;\\n            }\\n            i++;\\n            if(j<n)\\n                maxi=range[j][1];\\n            count++;\\n        }\\n        // cout<<count<<\" \";\\n        int ans=1;\\n        for(int i=1;i<=count;i++){\\n            ans*=2;\\n            ans=ans%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3257135,
                "title": "easy-to-understand-c-solution-o-n-time-complexity-step-by-step-solution",
                "content": "# Intuition\\nTry to find the distinct overlapping groups. And we know that each groups have two possible options to select.\\nSo, Total no.of ways = 2^(no. of distinct overlapping groups).\\n\\n# Approach\\n1. Sort the ranges in ascending order.\\n2. Take two pointers mn=ranges[0][0] and mx=ranges[0][1] and count=0.\\n3. Now traverse the array ranges and check if ranges[i][0]>=mn && ranges[i][1]<=mx then update mn=min(ranges[i][0],mn) and mx=max(ranges[i][1],mx) else count++ and mn=ranges[i][0] & mx=ranges[i][1].\\n4. Since each group has two possible options. So, No. of ways = 2^count.(Considering the mod 10^9+7).\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int mod=1e9+7;\\n        int mn=ranges[0][0],mx=ranges[0][1];\\n        int count=1;\\n        for(int i=1;i<ranges.size();i++){\\n            if(ranges[i][0]>=mn && ranges[i][0]<=mx){\\n                mn=min(ranges[i][0],mn);\\n                mx=max(ranges[i][1],mx);\\n            }else{\\n                count++;\\n                mn=ranges[i][0];\\n                mx=ranges[i][1];\\n            }\\n        }\\n        int ans=1;\\n        for(int i=1;i<=count;i++){\\n            ans=((ans%mod)*2)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int mod=1e9+7;\\n        int mn=ranges[0][0],mx=ranges[0][1];\\n        int count=1;\\n        for(int i=1;i<ranges.size();i++){\\n            if(ranges[i][0]>=mn && ranges[i][0]<=mx){\\n                mn=min(ranges[i][0],mn);\\n                mx=max(ranges[i][1],mx);\\n            }else{\\n                count++;\\n                mn=ranges[i][0];\\n                mx=ranges[i][1];\\n            }\\n        }\\n        int ans=1;\\n        for(int i=1;i<=count;i++){\\n            ans=((ans%mod)*2)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257103,
                "title": "c-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int MOD = 1e9+7;\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(), ranges.end());\\n        \\n        vector<int>nonOverlap{ranges[0][1]};\\n        \\n        for(int i = 1; i < ranges.size(); i++){\\n            if(nonOverlap.back() >= ranges[i][0])\\n                nonOverlap.back() = max(nonOverlap.back(), ranges[i][1]);\\n            else nonOverlap.push_back(ranges[i][1]);\\n        }\\n        \\n        int ans{1}, len = nonOverlap.size();\\n        \\n        while(len--)ans = (ans * 2) % MOD;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9+7;\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(), ranges.end());\\n        \\n        vector<int>nonOverlap{ranges[0][1]};\\n        \\n        for(int i = 1; i < ranges.size(); i++){\\n            if(nonOverlap.back() >= ranges[i][0])\\n                nonOverlap.back() = max(nonOverlap.back(), ranges[i][1]);\\n            else nonOverlap.push_back(ranges[i][1]);\\n        }\\n        \\n        int ans{1}, len = nonOverlap.size();\\n        \\n        while(len--)ans = (ans * 2) % MOD;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257088,
                "title": "swift-merge-power-easy-solution-beats-100",
                "content": "We need merge all intervals, and calculate number of possible options divide them into two groups. Each merged interval can be placed in one of two group. (2^n)\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    func power(_ base: Int, _ power: Int) -> Int {\\n        let modulo: Int = 1000000007\\n\\n        var power = power, base = base\\n        var ans = 1\\n        while power > 0 {\\n            if (power % 2 != 0) {\\n                ans = (ans * base) % modulo; \\n                power -= 1; \\n            } else {\\n                power = power / 2;\\n                base = (base * base) % modulo;\\n            }\\n        }\\n        return ans\\n    }\\n\\n    func merged(_ ranges: [[Int]]) -> [[Int]] {\\n        var ranges = ranges.sorted { $0[0] < $1[0] }\\n        var merged = [[Int]]()\\n        var start = ranges[0][0]\\n        var end = ranges[0][1]\\n        for range in ranges.dropFirst() {\\n            if range[0] <= end {\\n                end = max(end, range[1])\\n            } else {\\n                merged.append([start, end])\\n                start = range[0]\\n                end = range[1]\\n            }\\n        }\\n        merged.append([start, end])\\n        return merged\\n    }\\n\\n    func countWays(_ ranges: [[Int]]) -> Int {\\n        return power(2, merged(ranges).count)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    func power(_ base: Int, _ power: Int) -> Int {\\n        let modulo: Int = 1000000007\\n\\n        var power = power, base = base\\n        var ans = 1\\n        while power > 0 {\\n            if (power % 2 != 0) {\\n                ans = (ans * base) % modulo; \\n                power -= 1; \\n            } else {\\n                power = power / 2;\\n                base = (base * base) % modulo;\\n            }\\n        }\\n        return ans\\n    }\\n\\n    func merged(_ ranges: [[Int]]) -> [[Int]] {\\n        var ranges = ranges.sorted { $0[0] < $1[0] }\\n        var merged = [[Int]]()\\n        var start = ranges[0][0]\\n        var end = ranges[0][1]\\n        for range in ranges.dropFirst() {\\n            if range[0] <= end {\\n                end = max(end, range[1])\\n            } else {\\n                merged.append([start, end])\\n                start = range[0]\\n                end = range[1]\\n            }\\n        }\\n        merged.append([start, end])\\n        return merged\\n    }\\n\\n    func countWays(_ ranges: [[Int]]) -> Int {\\n        return power(2, merged(ranges).count)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257057,
                "title": "easy-to-understand-python-solution",
                "content": "# Intuition\\nLets supporse their are n distinct intervals.\\nNumber of ways for n distinct intervals = 2**n \\n\\n# Approach\\n1. Sort based of ranges based on intervals\\n2. Merge common intervals\\n3. Length of modified ranges arr is distinct intervals\\n4. Return (2**n)mod 1000000007\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges = sorted(ranges, key = lambda x:x[1])\\n        ranges = sorted(ranges, key = lambda x:x[0])\\n        i = 0\\n        while i < len(ranges)-1:\\n            \\n            if ranges[i][0] == ranges[i+1][0]:\\n                ranges[i+1][1] = max(ranges[i+1][1], ranges[i][1])\\n                ranges.pop(i)\\n                i-=1\\n                \\n            elif ranges[i+1][0] <= ranges[i][1]:\\n                ranges[i][1] = max(ranges[i][1], ranges[i+1][1])\\n                ranges.pop(i+1)\\n                i-=1\\n            \\n            i+=1\\n                \\n        return (2**len(ranges))%1000000007\\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges = sorted(ranges, key = lambda x:x[1])\\n        ranges = sorted(ranges, key = lambda x:x[0])\\n        i = 0\\n        while i < len(ranges)-1:\\n            \\n            if ranges[i][0] == ranges[i+1][0]:\\n                ranges[i+1][1] = max(ranges[i+1][1], ranges[i][1])\\n                ranges.pop(i)\\n                i-=1\\n                \\n            elif ranges[i+1][0] <= ranges[i][1]:\\n                ranges[i][1] = max(ranges[i][1], ranges[i+1][1])\\n                ranges.pop(i+1)\\n                i-=1\\n            \\n            i+=1\\n                \\n        return (2**len(ranges))%1000000007\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257027,
                "title": "c-sorting-and-power-of-2-easy-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll mod = 1e9+7;\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        \\n        int c=0,p=-1;\\n        for(auto r:ranges){\\n            if(p<r[0]) c++;\\n            p=max(r[1],p);\\n        }\\n        ll ans=1;\\n        for(ll i=0;i<c;i++){\\n            ans*=2;\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll mod = 1e9+7;\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        \\n        int c=0,p=-1;\\n        for(auto r:ranges){\\n            if(p<r[0]) c++;\\n            p=max(r[1],p);\\n        }\\n        ll ans=1;\\n        for(ll i=0;i<c;i++){\\n            ans*=2;\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257007,
                "title": "java-easy-sorting-solution-with-modpow2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int countWays(int[][] ranges) {\\n    Arrays.sort(ranges, (int[]a, int[]b) ->{\\n      if(a[0] == b[0]) return a[1] - b[1];\\n      return a[0] - b[0];\\n    });\\n\\n    int n = 1, end = ranges[0][1];\\n    for(int i = 1; i != ranges.length; i++)\\n      if(end >= ranges[i][0]) end = Math.max(end, ranges[i][1]);\\n      else {n++; end = ranges[i][1];}\\n    \\n    return modPow2(n);      \\n  }\\n\\n  private int modPow2(int n){\\n    if(n == 0) return 1;\\n    if(n == 1) return 2;\\n\\n    long ans = modPow2(n>>1);\\n    ans = ans*ans*( (n&1) == 0 ? 1 : 2);\\n    return (int)(ans % 1000000007);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int countWays(int[][] ranges) {\\n    Arrays.sort(ranges, (int[]a, int[]b) ->{\\n      if(a[0] == b[0]) return a[1] - b[1];\\n      return a[0] - b[0];\\n    });\\n\\n    int n = 1, end = ranges[0][1];\\n    for(int i = 1; i != ranges.length; i++)\\n      if(end >= ranges[i][0]) end = Math.max(end, ranges[i][1]);\\n      else {n++; end = ranges[i][1];}\\n    \\n    return modPow2(n);      \\n  }\\n\\n  private int modPow2(int n){\\n    if(n == 0) return 1;\\n    if(n == 1) return 2;\\n\\n    long ans = modPow2(n>>1);\\n    ans = ans*ans*( (n&1) == 0 ? 1 : 2);\\n    return (int)(ans % 1000000007);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256981,
                "title": "c-find-non-overlapping-and-pow-2-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int N = 1e9+7;\\n    long exponentiation(long base, long exp)\\n{\\n    long t = 1L;\\n    while (exp > 0)\\n    {\\n        if (exp % 2 != 0)\\n            t = (t * base) % N;\\n \\n        base = (base * base) % N;\\n        exp /= 2;\\n    }\\n    return t % N;\\n}\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int n=1;\\n        int high = ranges[0][1];\\n        for(int i=1;i<ranges.size();i++){\\n            if(ranges[i][0]>high){\\n                n++;\\n            }\\n             high = max(high,ranges[i][1]);\\n        }\\n        cout<<n;\\n        return exponentiation(2,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int N = 1e9+7;\\n    long exponentiation(long base, long exp)\\n{\\n    long t = 1L;\\n    while (exp > 0)\\n    {\\n        if (exp % 2 != 0)\\n            t = (t * base) % N;\\n \\n        base = (base * base) % N;\\n        exp /= 2;\\n    }\\n    return t % N;\\n}\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int n=1;\\n        int high = ranges[0][1];\\n        for(int i=1;i<ranges.size();i++){\\n            if(ranges[i][0]>high){\\n                n++;\\n            }\\n             high = max(high,ranges[i][1]);\\n        }\\n        cout<<n;\\n        return exponentiation(2,n);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3256975,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort()\\n        last = -1\\n        n = 0\\n        for start, end in ranges:\\n            if start > last:\\n                n += 1\\n            last = max(last, end)\\n        return 2 ** n % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort()\\n        last = -1\\n        n = 0\\n        for start, end in ranges:\\n            if start > last:\\n                n += 1\\n            last = max(last, end)\\n        return 2 ** n % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256957,
                "title": "simple-c-code-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are 2 groups in which we have to spilt all the ranges. They have said that all overlapping ranges must united. So first of all we will calculate all overlaping ranges. Then calculate unique ranges considering all overlapping ranges as one range in vector. As there are 2 groups simply we will do 2 to the power number of unique ranges.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long binpow(long long a, long long b, long long m) {\\n    a %= m;\\n    long long res = 1;\\n    while (b > 0) {\\n        if (b & 1)\\n            res = res * a % m;\\n        a = a * a % m;\\n        b >>= 1;\\n    }\\n    return res;\\n}\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int cnt = 0;\\n        for(auto it:ranges){\\n            for(auto i:it)cout<<i<<\" \";\\n            cout<<endl;\\n        }\\n        int last = ranges[0][1];\\n        for(int i=1;i<ranges.size();i++){\\n            if(last>=ranges[i][0])cnt++;\\n            last = max(last,ranges[i][1]);\\n        }\\n        int n = ranges.size();\\n        int rem = n - (cnt+1);\\n        rem += 1;\\n        cout<<cnt<<\" \"<<rem;\\n        long long m = 1000000007;\\n        return binpow(2,rem,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long binpow(long long a, long long b, long long m) {\\n    a %= m;\\n    long long res = 1;\\n    while (b > 0) {\\n        if (b & 1)\\n            res = res * a % m;\\n        a = a * a % m;\\n        b >>= 1;\\n    }\\n    return res;\\n}\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        int cnt = 0;\\n        for(auto it:ranges){\\n            for(auto i:it)cout<<i<<\" \";\\n            cout<<endl;\\n        }\\n        int last = ranges[0][1];\\n        for(int i=1;i<ranges.size();i++){\\n            if(last>=ranges[i][0])cnt++;\\n            last = max(last,ranges[i][1]);\\n        }\\n        int n = ranges.size();\\n        int rem = n - (cnt+1);\\n        rem += 1;\\n        cout<<cnt<<\" \"<<rem;\\n        long long m = 1000000007;\\n        return binpow(2,rem,m);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3256934,
                "title": "very-simple-easy-to-understand-solution-comments-step-by-step-functional-approach-sort-reduce",
                "content": "# Intuition\\n1. Sort array by range start.\\n2. Calculate result by multiplying each new overlap by 2. Because each new overlap means that we can have 1 more result at the left group and at the right group.\\n\\n# Code\\n```\\nclass Solution {\\n    func countWays(_ ranges: [[Int]]) -> Int {\\n        // 1: Task requirement to use mod.\\n        let modulo = NSDecimalNumber(decimal: pow(10, 9) + 7).intValue\\n\\n        return ranges\\n\\n            // 2. Sort by range start.\\n            .sorted(by: { $0[0] < $1[0] })\\n\\n            // 3. Update result only when current range is included is overlap the previous. [\\'$0.last < $1[0]\\']\\n            // To calculate this use \\'last\\' - end of the previous range.\\n            // Multiply res because each new case means that we can have combinations from the previous result for the left and for the right array.\\n            .reduce(into: (res: 1, last: -1)) {\\n                $0 = (res: $0.last < $1[0] ? $0.res * 2 % modulo : $0.res,\\n                      last: max($0.last, $1[1]))\\n            }.res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countWays(_ ranges: [[Int]]) -> Int {\\n        // 1: Task requirement to use mod.\\n        let modulo = NSDecimalNumber(decimal: pow(10, 9) + 7).intValue\\n\\n        return ranges\\n\\n            // 2. Sort by range start.\\n            .sorted(by: { $0[0] < $1[0] })\\n\\n            // 3. Update result only when current range is included is overlap the previous. [\\'$0.last < $1[0]\\']\\n            // To calculate this use \\'last\\' - end of the previous range.\\n            // Multiply res because each new case means that we can have combinations from the previous result for the left and for the right array.\\n            .reduce(into: (res: 1, last: -1)) {\\n                $0 = (res: $0.last < $1[0] ? $0.res * 2 % modulo : $0.res,\\n                      last: max($0.last, $1[1]))\\n            }.res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256888,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countWays(self, ranges):\\n        n = len(ranges)\\n\\n        ranges.sort()\\n\\n        stack = [ranges[0]]\\n\\n        for i in range(1,n):\\n            if ranges[i][0] > stack[-1][1]:\\n                stack.append(ranges[i])\\n            else:\\n                stack[-1][1] = max(stack[-1][1],ranges[i][1])\\n\\n        return pow(2,len(stack),10**9+7)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges):\\n        n = len(ranges)\\n\\n        ranges.sort()\\n\\n        stack = [ranges[0]]\\n\\n        for i in range(1,n):\\n            if ranges[i][0] > stack[-1][1]:\\n                stack.append(ranges[i])\\n            else:\\n                stack[-1][1] = max(stack[-1][1],ranges[i][1])\\n\\n        return pow(2,len(stack),10**9+7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256868,
                "title": "easy-c-solution-merge-ranges",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int MOD = 1000000007;\\n\\n    int calcPower(int base, int power){\\n        long long ans = 1;\\n        long long mul = base;\\n        while(power--) ans = (ans * mul) % MOD;\\n        return (int)ans;\\n    }\\n    \\n    int countWays(vector<vector<int>>& ranges) {\\n        int n = ranges.size();\\n        sort(ranges.begin(), ranges.end());\\n        int l = ranges[0][0], r = ranges[0][1], i = 0;\\n        vector<pair<long long,long long>> v;\\n        while(i < n) {\\n            if(ranges[i][0] <= r) r = max(ranges[i][1], r);\\n            else{\\n                v.push_back({l,r});\\n                l = ranges[i][0]; r = ranges[i][1];\\n            }\\n            i++;\\n        }v.push_back({l,r}); \\n        int k = v.size();\\n        return calcPower(2,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = 1000000007;\\n\\n    int calcPower(int base, int power){\\n        long long ans = 1;\\n        long long mul = base;\\n        while(power--) ans = (ans * mul) % MOD;\\n        return (int)ans;\\n    }\\n    \\n    int countWays(vector<vector<int>>& ranges) {\\n        int n = ranges.size();\\n        sort(ranges.begin(), ranges.end());\\n        int l = ranges[0][0], r = ranges[0][1], i = 0;\\n        vector<pair<long long,long long>> v;\\n        while(i < n) {\\n            if(ranges[i][0] <= r) r = max(ranges[i][1], r);\\n            else{\\n                v.push_back({l,r});\\n                l = ranges[i][0]; r = ranges[i][1];\\n            }\\n            i++;\\n        }v.push_back({l,r}); \\n        int k = v.size();\\n        return calcPower(2,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256860,
                "title": "cpp-simple-clean-code-java-python-logic",
                "content": "# First merge the intervals then count the number of distinct intervals \\n# You can place them in two groups by 2^n methods because every interval has 2 choices.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    const int MOD = 1e9 + 7;\\n    \\n    int powerOfTwo(int n) {\\n        int ans = 1;\\n        int base = 2;\\n        while(n) {\\n            if(n&1) ans = (1LL * ans * base) % MOD;\\n            base = (1LL * base * base) % MOD;\\n            n >>= 1;\\n        }\\n        return ans;\\n    }\\n\\n    \\n    int countWays(vector<vector<int>>& intervals) {\\n        \\n        //merge intervals code\\n        \\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>>ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(ans.back()[1]>=intervals[i][0]) ans.back()[1]=max(intervals[i][1],ans.back()[1]);\\n            else ans.push_back(intervals[i]);\\n        }\\n        \\n        // total distinct ranges\\n        \\n        int n = ans.size();\\n        \\n        return powerOfTwo(n);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    const int MOD = 1e9 + 7;\\n    \\n    int powerOfTwo(int n) {\\n        int ans = 1;\\n        int base = 2;\\n        while(n) {\\n            if(n&1) ans = (1LL * ans * base) % MOD;\\n            base = (1LL * base * base) % MOD;\\n            n >>= 1;\\n        }\\n        return ans;\\n    }\\n\\n    \\n    int countWays(vector<vector<int>>& intervals) {\\n        \\n        //merge intervals code\\n        \\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>>ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(ans.back()[1]>=intervals[i][0]) ans.back()[1]=max(intervals[i][1],ans.back()[1]);\\n            else ans.push_back(intervals[i]);\\n        }\\n        \\n        // total distinct ranges\\n        \\n        int n = ans.size();\\n        \\n        return powerOfTwo(n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256848,
                "title": "java-using-priority-queue-easy-to-under-stand",
                "content": "```\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        \\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        \\n        for(int ele[]:ranges){\\n            pq.add(ele);\\n        }\\n        \\n        long mod=(long)(1e9)+7;\\n        \\n        int count=1;\\n        \\n        int prev[]=pq.poll();\\n        \\n        while(!pq.isEmpty()){\\n            \\n            int curr[]=pq.poll();\\n            \\n            if(prev[1]>=curr[0]) {\\n                \\n                prev=new int[]{prev[0],Math.max(curr[1],prev[1])};\\n                \\n            }else {\\n                count++;\\n                prev=curr;\\n            }\\n            \\n        }\\n\\n        long ans=1;\\n        \\n        for(int i=1;i<=count;++i){\\n            ans*=2;\\n            ans%=mod;\\n        }\\n        \\n        return (int)(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        \\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        \\n        for(int ele[]:ranges){\\n            pq.add(ele);\\n        }\\n        \\n        long mod=(long)(1e9)+7;\\n        \\n        int count=1;\\n        \\n        int prev[]=pq.poll();\\n        \\n        while(!pq.isEmpty()){\\n            \\n            int curr[]=pq.poll();\\n            \\n            if(prev[1]>=curr[0]) {\\n                \\n                prev=new int[]{prev[0],Math.max(curr[1],prev[1])};\\n                \\n            }else {\\n                count++;\\n                prev=curr;\\n            }\\n            \\n        }\\n\\n        long ans=1;\\n        \\n        for(int i=1;i<=count;++i){\\n            ans*=2;\\n            ans%=mod;\\n        }\\n        \\n        return (int)(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256820,
                "title": "c-sorting-and-modulus-math",
                "content": "# Intuition\\nThe problem isn\\'t really explained well, but at its core we need to find the ranges that have to be in the same group. To achieve this we sort based on each range\\'s lower bound. If the ranges intersect then we update the upper bound. Once we know the amount of merged ranges then it simply becomes a math problem over the modulus. Since we have two groups and `n` merged ranges, the amount of different combinations becomes $$2^n$$ over the modulus.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        // Sort the ranges based first element\\n        std::sort(ranges.begin(), ranges.end());\\n\\n        // Used to store the merged ranges\\n        std::vector<std::vector<int>> mergedRanges{ranges[0]};\\n        \\n        // Iterate over each of the ranges. If the upper bound of the\\n        // previous range includes the lowerBound of the current range, then\\n        // we can merge these two ranges with the upperBound being the max\\n        // of the current range and the previous range\\n        for (const auto& range : ranges) {\\n            int& currentUpperBound = mergedRanges.back()[1];\\n            \\n            if (range[0] <= currentUpperBound) {\\n                currentUpperBound = std::max(currentUpperBound, range[1]);\\n            } else {\\n                mergedRanges.push_back(range);\\n            }\\n        }\\n        \\n        // Now we have a list of merge ranges, we can either include then in\\n        // group1 or group2, meaning that the number of options we have is\\n        // 2^n where n is the number of merged ranges. Since this number can\\n        // exceed MOD, we have to do each multiplication of the exponential\\n        // over MOD.\\n        constexpr long long MOD = 1000000007;\\n        long long rangeSize = mergedRanges.size() % MOD;\\n        long long exp = 1;\\n        \\n        while (rangeSize > 0) {\\n            exp = (2 * exp) % MOD;\\n            \\n            rangeSize -= 1;\\n        }\\n        \\n        return exp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        // Sort the ranges based first element\\n        std::sort(ranges.begin(), ranges.end());\\n\\n        // Used to store the merged ranges\\n        std::vector<std::vector<int>> mergedRanges{ranges[0]};\\n        \\n        // Iterate over each of the ranges. If the upper bound of the\\n        // previous range includes the lowerBound of the current range, then\\n        // we can merge these two ranges with the upperBound being the max\\n        // of the current range and the previous range\\n        for (const auto& range : ranges) {\\n            int& currentUpperBound = mergedRanges.back()[1];\\n            \\n            if (range[0] <= currentUpperBound) {\\n                currentUpperBound = std::max(currentUpperBound, range[1]);\\n            } else {\\n                mergedRanges.push_back(range);\\n            }\\n        }\\n        \\n        // Now we have a list of merge ranges, we can either include then in\\n        // group1 or group2, meaning that the number of options we have is\\n        // 2^n where n is the number of merged ranges. Since this number can\\n        // exceed MOD, we have to do each multiplication of the exponential\\n        // over MOD.\\n        constexpr long long MOD = 1000000007;\\n        long long rangeSize = mergedRanges.size() % MOD;\\n        long long exp = 1;\\n        \\n        while (rangeSize > 0) {\\n            exp = (2 * exp) % MOD;\\n            \\n            rangeSize -= 1;\\n        }\\n        \\n        return exp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256785,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `ranges`\\n */\\nclass Solution {\\n public:\\n  int countWays(vector<vector<int>> &ranges) {\\n    sort(ranges.begin(),\\n         ranges.end(),\\n         [](const vector<int> &lhs, const vector<int> &rhs) -> bool {\\n      return lhs[0] < rhs[0];\\n    });\\n    \\n    const int n = static_cast<int>(ranges.size());\\n    int count = 1;\\n    int right = ranges.front()[1];\\n    for (int i = 1; i < n; ++i) {\\n      if (ranges[i][0] <= right) {\\n        right = max(right, ranges[i][1]);\\n      } else {\\n        ++count;\\n        right = ranges[i][1];\\n      }\\n    }\\n    \\n    return power2(count);\\n  }\\n  \\n private:\\n  int power2(const int count) {\\n    constexpr int mod = 1000000007;\\n    int base = 2;\\n    int ret = 1;\\n    for (int p = count; p > 0; p >>= 1) {\\n      if ((p & 0b1) == 0b1) {\\n        ret = static_cast<int>(static_cast<long long>(ret) * base % mod);\\n      }\\n      base = static_cast<int>(static_cast<long long>(base) * base % mod);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `ranges`\\n */\\nclass Solution {\\n public:\\n  int countWays(vector<vector<int>> &ranges) {\\n    sort(ranges.begin(),\\n         ranges.end(),\\n         [](const vector<int> &lhs, const vector<int> &rhs) -> bool {\\n      return lhs[0] < rhs[0];\\n    });\\n    \\n    const int n = static_cast<int>(ranges.size());\\n    int count = 1;\\n    int right = ranges.front()[1];\\n    for (int i = 1; i < n; ++i) {\\n      if (ranges[i][0] <= right) {\\n        right = max(right, ranges[i][1]);\\n      } else {\\n        ++count;\\n        right = ranges[i][1];\\n      }\\n    }\\n    \\n    return power2(count);\\n  }\\n  \\n private:\\n  int power2(const int count) {\\n    constexpr int mod = 1000000007;\\n    int base = 2;\\n    int ret = 1;\\n    for (int p = count; p > 0; p >>= 1) {\\n      if ((p & 0b1) == 0b1) {\\n        ret = static_cast<int>(static_cast<long long>(ret) * base % mod);\\n      }\\n      base = static_cast<int>(static_cast<long long>(base) * base % mod);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256764,
                "title": "java-solution-merge-ranges-21ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array first.\\nMerge the range in the array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        Arrays.sort(ranges, (a, b) -> a[0] - b[0]);\\n        List<int[]> list = new ArrayList<>();\\n        int left = ranges[0][0];\\n        int right = ranges[0][1];\\n        for (int[] range : ranges) {\\n            if (range[0] > right) {\\n                list.add(new int[]{left, right});\\n                left = range[0];\\n                right = range[1];\\n            } else {\\n                right = Math.max(right, range[1]);\\n            }\\n        }\\n        list.add(new int[]{left, right});\\n        int MOD = (int) 1e9 + 7;\\n        int res = 1;\\n        for (int i = 0; i < list.size(); i++) {\\n            res = 2 * res % MOD;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        Arrays.sort(ranges, (a, b) -> a[0] - b[0]);\\n        List<int[]> list = new ArrayList<>();\\n        int left = ranges[0][0];\\n        int right = ranges[0][1];\\n        for (int[] range : ranges) {\\n            if (range[0] > right) {\\n                list.add(new int[]{left, right});\\n                left = range[0];\\n                right = range[1];\\n            } else {\\n                right = Math.max(right, range[1]);\\n            }\\n        }\\n        list.add(new int[]{left, right});\\n        int MOD = (int) 1e9 + 7;\\n        int res = 1;\\n        for (int i = 0; i < list.size(); i++) {\\n            res = 2 * res % MOD;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256761,
                "title": "rust-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N Log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn count_ways(ranges: Vec<Vec<i32>>) -> i32 {\\n        let (mut count, n) = (0, ranges.len());\\n        let mut ranges = ranges;\\n        let (mut right, mut ret) = (i32::MIN, 1);\\n        \\n        ranges.sort();\\n        for v in ranges {\\n            if v[0] > right { ret = (2 * ret) % 1_000_000_007; }\\n            right = right.max(v[1]);\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_ways(ranges: Vec<Vec<i32>>) -> i32 {\\n        let (mut count, n) = (0, ranges.len());\\n        let mut ranges = ranges;\\n        let (mut right, mut ret) = (i32::MIN, 1);\\n        \\n        ranges.sort();\\n        for v in ranges {\\n            if v[0] > right { ret = (2 * ret) % 1_000_000_007; }\\n            right = right.max(v[1]);\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3256736,
                "title": "easiest-solution-in-python-using-merge-intervals",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort(key=lambda x:x[0])\\n        temp=ranges[0]\\n        c=10**9+7\\n        count1,count2=0,0\\n        merged=[]\\n        for i in ranges:\\n            if(i[0]<=temp[1]):\\n                count1+=1\\n                temp[1]=max(temp[1],i[1])\\n                \\n            else:\\n                merged.append(temp)\\n                temp=i\\n            \\n        merged.append(temp)\\n        print(merged)\\n        n=len(merged)\\n        if(n==1):\\n            return 2\\n        else:\\n            return pow(2,n)%c\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort(key=lambda x:x[0])\\n        temp=ranges[0]\\n        c=10**9+7\\n        count1,count2=0,0\\n        merged=[]\\n        for i in ranges:\\n            if(i[0]<=temp[1]):\\n                count1+=1\\n                temp[1]=max(temp[1],i[1])\\n                \\n            else:\\n                merged.append(temp)\\n                temp=i\\n            \\n        merged.append(temp)\\n        print(merged)\\n        n=len(merged)\\n        if(n==1):\\n            return 2\\n        else:\\n            return pow(2,n)%c\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256695,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod=(int)(1e9+7);\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        stack<pair<int,int>>st;\\n        st.push({ranges[0][0],ranges[0][1]});\\n        for(int i=1;i<ranges.size();i++){\\n            auto it=st.top();\\n            if(it.first<=ranges[i][0] && it.second>=ranges[i][0]){\\n                st.pop();\\n                st.push({it.first,max(it.second,ranges[i][1])});\\n            }\\n            else{\\n                st.push({ranges[i][0],ranges[i][1]});\\n            }\\n        }\\n        int ans=1;\\n        int n=st.size();\\n        while(n--){\\n            ans=(ans*2)%mod;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int mod=(int)(1e9+7);\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(),ranges.end());\\n        stack<pair<int,int>>st;\\n        st.push({ranges[0][0],ranges[0][1]});\\n        for(int i=1;i<ranges.size();i++){\\n            auto it=st.top();\\n            if(it.first<=ranges[i][0] && it.second>=ranges[i][0]){\\n                st.pop();\\n                st.push({it.first,max(it.second,ranges[i][1])});\\n            }\\n            else{\\n                st.push({ranges[i][0],ranges[i][1]});\\n            }\\n        }\\n        int ans=1;\\n        int n=st.size();\\n        while(n--){\\n            ans=(ans*2)%mod;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256667,
                "title": "explanation-and-c-solution-using-binary-exponentiation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAll the overlapping ranges should belong to same group. So, we can combine overlapping ranges into single set, and this set can belong to either of the group. So, we just need to find the number of sets such that no set has overlapping ranges.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n## Steps\\n- Sort the ranges\\n- If the current range overlaps with previous range, combine them.\\n- Else increase count by `1` and start a new range.\\n- Once we have the no of sets, answer will siply be `pow(2, count`.\\n- function `binpow` calculate `pow(a, p) % mod`, read more about it [Binary Exponentiation](https://cp-algorithms.com/algebra/binary-exp.html#applications)\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long binpow(long long a, long long p, long long mod) {\\n        a %= mod;\\n        long long res = 1;\\n        while (p > 0) {\\n            if (p & 1)\\n                res = res * a % mod;\\n            a = a * a % mod;\\n            p >>= 1;\\n        }\\n        return res;\\n    }\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(), ranges.end());\\n        int count = 0;\\n        int st = -1;\\n        int ed = -1;\\n        for (auto range: ranges) {\\n            if (range[0] <= ed) {\\n                st = min(st, range[0]);\\n                ed = max(ed, range[1]);\\n            } else {\\n                count++;\\n                st = range[0];\\n                ed = range[1];\\n            }\\n        }\\n        return binpow(2, count, 1e9+7);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long binpow(long long a, long long p, long long mod) {\\n        a %= mod;\\n        long long res = 1;\\n        while (p > 0) {\\n            if (p & 1)\\n                res = res * a % mod;\\n            a = a * a % mod;\\n            p >>= 1;\\n        }\\n        return res;\\n    }\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(), ranges.end());\\n        int count = 0;\\n        int st = -1;\\n        int ed = -1;\\n        for (auto range: ranges) {\\n            if (range[0] <= ed) {\\n                st = min(st, range[0]);\\n                ed = max(ed, range[1]);\\n            } else {\\n                count++;\\n                st = range[0];\\n                ed = range[1];\\n            }\\n        }\\n        return binpow(2, count, 1e9+7);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256641,
                "title": "simple-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int pow(int a, int b, int m){\\n        if(b==0)\\n            return 1;\\n        if(b==1)\\n            return a;\\n        Long res=new Long(pow(a,b/2,m));\\n        res=(res*res)%m;\\n        if(b%2==1){\\n            res=(res*a)%m;\\n        }\\n        return res.intValue();\\n    }\\n    private static int[][] merge(int[][] inter){\\n        if(inter.length<2)\\n            return inter;\\n        Arrays.sort(inter,(a,b)-> Integer.compare(a[0],b[0]));\\n        List<int[]> m=new ArrayList<>();\\n        int[] pinter=inter[0];\\n        int i=0;\\n        while(i<inter.length){\\n            int[] in=inter[i];\\n            if(in[0]<=pinter[1])\\n                pinter[1]=Math.max(in[1],pinter[1]);\\n            else\\n            {\\n                m.add(pinter);\\n                pinter=in;\\n            }\\n            i+=1;\\n        }\\n        m.add(pinter);\\n        return m.toArray(new int[m.size()][]);\\n    }\\n    public int countWays(int[][] ranges) {\\n        int[][] inter=merge(ranges);\\n        \\n        return pow(2,inter.length,(int)(1e9+7));\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int pow(int a, int b, int m){\\n        if(b==0)\\n            return 1;\\n        if(b==1)\\n            return a;\\n        Long res=new Long(pow(a,b/2,m));\\n        res=(res*res)%m;\\n        if(b%2==1){\\n            res=(res*a)%m;\\n        }\\n        return res.intValue();\\n    }\\n    private static int[][] merge(int[][] inter){\\n        if(inter.length<2)\\n            return inter;\\n        Arrays.sort(inter,(a,b)-> Integer.compare(a[0],b[0]));\\n        List<int[]> m=new ArrayList<>();\\n        int[] pinter=inter[0];\\n        int i=0;\\n        while(i<inter.length){\\n            int[] in=inter[i];\\n            if(in[0]<=pinter[1])\\n                pinter[1]=Math.max(in[1],pinter[1]);\\n            else\\n            {\\n                m.add(pinter);\\n                pinter=in;\\n            }\\n            i+=1;\\n        }\\n        m.add(pinter);\\n        return m.toArray(new int[m.size()][]);\\n    }\\n    public int countWays(int[][] ranges) {\\n        int[][] inter=merge(ranges);\\n        \\n        return pow(2,inter.length,(int)(1e9+7));\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256633,
                "title": "c-sort",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int CountWays(int[][] ranges)\\n    {\\n        Array.Sort(ranges, (a, b) => a[0] != b[0] ? a[0].CompareTo(b[0]) : b[1].CompareTo(a[1]));\\n\\n        int countNonoverlaps = 0;\\n        int end = -1;\\n        foreach (int[] range in ranges)\\n        {\\n            if (range[0] > end)\\n            {\\n                countNonoverlaps ++;\\n            }\\n            end = Math.Max(end, range[1]);\\n        }\\n\\n        return (int)BigInteger.ModPow(2, countNonoverlaps, 1_000_000_007);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int CountWays(int[][] ranges)\\n    {\\n        Array.Sort(ranges, (a, b) => a[0] != b[0] ? a[0].CompareTo(b[0]) : b[1].CompareTo(a[1]));\\n\\n        int countNonoverlaps = 0;\\n        int end = -1;\\n        foreach (int[] range in ranges)\\n        {\\n            if (range[0] > end)\\n            {\\n                countNonoverlaps ++;\\n            }\\n            end = Math.Max(end, range[1]);\\n        }\\n\\n        return (int)BigInteger.ModPow(2, countNonoverlaps, 1_000_000_007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256627,
                "title": "simple-python-solution-using-combinatorics-beats-100-solutions",
                "content": "# Approach\\nFor the given `ranges`, we calculate the number of non-overlapping ranges. (As the overlapping ranges, need to be put into the same group, we can consider them as the same range essentially.)\\nNow, we have `N` ranges, and `K` groups to put these into. (K = 2 in our case)\\nIf the groups are indistinguishable, and if they can\\'t be empty, the answer would be the Stirling numbers of the 2nd kind, `Stirling2(N, K)`\\nBut, in our case, the groups are distinguishable, so we multiply the value we get from `stirling2()` by `2`. And empty groups are also allowed, so we add `2` to the answer. (1st case where all ranges are in group A, and the 2nd case where all are in group B)\\nThis is our final answer.\\n\\nRef : https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind\\nhttps://docs.sympy.org/latest/modules/functions/combinatorial.html#stirling\\nhttps://people.math.sc.edu/Burkardt/py_src/polpak/stirling2.py\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nimport numpy as np\\n\\n\\nclass Solution:\\n    @staticmethod\\n    def stirling(n, m):\\n        \"\"\"\\n        Computes the Stirling numbers of the second kind.\\n        The value % mod is being stored, due to our requirement.\\n        \"\"\"\\n        mod = 10**9 + 7\\n\\n        s2 = np.zeros((n, m))\\n        if n <= 0:\\n            return s2\\n        if m <= 0:\\n            return s2\\n        s2[0, 0] = 1\\n        for j in range(1, m):\\n            s2[0, j] = 0\\n        for i in range(1, n):\\n            s2[i, 0] = 1\\n            for j in range(1, m):\\n                s2[i, j] = ((j + 1) * s2[i - 1, j] + s2[i - 1, j - 1]) % mod\\n\\n        return s2\\n\\n    def countWays(self, ranges: list[list[int]]) -> int:\\n        mod = 10**9 + 7\\n        # Sort by start times.\\n        ranges.sort(key=lambda item: item[0])\\n\\n        # Find out the number of non overlapping regions. (N)\\n        non_overlapping_ranges = 0\\n        overlaps = 1\\n        prev_end = float(\"-inf\")\\n        for start, end in ranges:\\n            if start <= prev_end:\\n                overlaps += 1\\n            else:\\n                non_overlapping_ranges += 1\\n                overlaps = 1\\n            prev_end = max(prev_end, end)\\n\\n        K = 2  # groups\\n        N = non_overlapping_ranges\\n        ways = int(Solution.stirling(N, K)[-1][-1])\\n        ways = ways * 2  # The groups are distinguishable.\\n        # So, putting \"1\" in A, \"2\" in B is not the same as \"1\" in B, \"2\" in A.\\n        # Where A, B are the groups, and \"1\", \"2\" are the values.\\n        # Hence, we multiply the number of ways, by the number of groups.\\n        ways += 2\\n        # 2 extra ways, of putting all ranges in group A, and all ranges in group B.\\n        return ways % mod\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nimport numpy as np\\n\\n\\nclass Solution:\\n    @staticmethod\\n    def stirling(n, m):\\n        \"\"\"\\n        Computes the Stirling numbers of the second kind.\\n        The value % mod is being stored, due to our requirement.\\n        \"\"\"\\n        mod = 10**9 + 7\\n\\n        s2 = np.zeros((n, m))\\n        if n <= 0:\\n            return s2\\n        if m <= 0:\\n            return s2\\n        s2[0, 0] = 1\\n        for j in range(1, m):\\n            s2[0, j] = 0\\n        for i in range(1, n):\\n            s2[i, 0] = 1\\n            for j in range(1, m):\\n                s2[i, j] = ((j + 1) * s2[i - 1, j] + s2[i - 1, j - 1]) % mod\\n\\n        return s2\\n\\n    def countWays(self, ranges: list[list[int]]) -> int:\\n        mod = 10**9 + 7\\n        # Sort by start times.\\n        ranges.sort(key=lambda item: item[0])\\n\\n        # Find out the number of non overlapping regions. (N)\\n        non_overlapping_ranges = 0\\n        overlaps = 1\\n        prev_end = float(\"-inf\")\\n        for start, end in ranges:\\n            if start <= prev_end:\\n                overlaps += 1\\n            else:\\n                non_overlapping_ranges += 1\\n                overlaps = 1\\n            prev_end = max(prev_end, end)\\n\\n        K = 2  # groups\\n        N = non_overlapping_ranges\\n        ways = int(Solution.stirling(N, K)[-1][-1])\\n        ways = ways * 2  # The groups are distinguishable.\\n        # So, putting \"1\" in A, \"2\" in B is not the same as \"1\" in B, \"2\" in A.\\n        # Where A, B are the groups, and \"1\", \"2\" are the values.\\n        # Hence, we multiply the number of ways, by the number of groups.\\n        ways += 2\\n        # 2 extra ways, of putting all ranges in group A, and all ranges in group B.\\n        return ways % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256600,
                "title": "simple-sorting",
                "content": "# Intuition\\nFind how many groups are there, and just find 2 to the power of founded groups\\n\\n# Approach\\nLet\\'s say, there are 2 groups(a,b), then we can split 2 groups in such ways(- means no group):\\n\"ab\" \"\"\\n\"a\" \"b\"\\n\"b\" \"a\"\\n\"-\" \"ab\"\\n\\nLooks familiar, huh? as you can see, just count how many group of ranges are there, and find power of 2 of that. \\nNext step, is finding no. of ranges. First of all sort ranges according to its start time. And iterate through ranges, if you find out that starting time of your range is bigger than end time of all the previous ranges, then this range is the start of new group of ranges.\\nAt the end, just return 2 to the power of founded gr of ranges(dont forget mod)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn), we sorting(O(nlogn)) time and we iterating(O(n)) time\\n\\n- Space complexity:\\nO(1) or O(n), depending on sorting algorithm your language uses\\n\\n# Code\\n```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort()\\n        groupOfRanges = 1\\n        biggest = ranges[0][1]\\n        mod = 10**9+7\\n        for i in range(1,len(ranges)):\\n          if ranges[i][0] > biggest:\\n            groupOfRanges +=1\\n          biggest = max(biggest,ranges[i][1])  \\n        return pow(2,groupOfRanges,mod)\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def countWays(self, ranges: List[List[int]]) -> int:\\n        ranges.sort()\\n        groupOfRanges = 1\\n        biggest = ranges[0][1]\\n        mod = 10**9+7\\n        for i in range(1,len(ranges)):\\n          if ranges[i][0] > biggest:\\n            groupOfRanges +=1\\n          biggest = max(biggest,ranges[i][1])  \\n        return pow(2,groupOfRanges,mod)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256573,
                "title": "c-solution-using-sort-and-power-modulation",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    long powmod(long a,long b,long d)\\n    {\\n        long result=1,base=a;\\n        while(b)\\n        {\\n            if(b&1) result=(result*base)%d;\\n            base=(base*base)%d;\\n            b>>=1;\\n        }\\n        return result;\\n    }\\n    int countWays(vector<vector<int>>& ranges) \\n    {\\n        sort(ranges.begin(),ranges.end());\\n        long d=1000000007,n=ranges.size(),last=ranges[0][1],c=1;\\n        for(int i=0;i<n;i++)\\n            if(ranges[i][0]<=last) last=max(last,1l*ranges[i][1]);\\n            else c++,last=ranges[i][1];\\n\\n        return powmod(2,c,d);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    long powmod(long a,long b,long d)\\n    {\\n        long result=1,base=a;\\n        while(b)\\n        {\\n            if(b&1) result=(result*base)%d;\\n            base=(base*base)%d;\\n            b>>=1;\\n        }\\n        return result;\\n    }\\n    int countWays(vector<vector<int>>& ranges) \\n    {\\n        sort(ranges.begin(),ranges.end());\\n        long d=1000000007,n=ranges.size(),last=ranges[0][1],c=1;\\n        for(int i=0;i<n;i++)\\n            if(ranges[i][0]<=last) last=max(last,1l*ranges[i][1]);\\n            else c++,last=ranges[i][1];\\n\\n        return powmod(2,c,d);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256562,
                "title": "c-greedy-solution-simple-explanation",
                "content": "# Recommend reading\\nThis question is a classic interval scheduling. If anyone not familiar with it, it is highly recommend to read about this classic question.\\n\\nIn this question, we have to do several things: \\n1. Grouping (group the overlap intervals)\\n2. Find number of ways to split these group\\n\\n### Step 1\\nFor the first thing, we could simply use interval scheduling greedy algorithm to finish the task. \\n```\\n[aaaaa]\\n [bbbbbb]\\n   [ccccc]\\n[dd]\\n            [eeeee]\\n             [ff]\\n                    [ggggg]\\n```\\nAssume we get such input intervals, we should group abcd, ef and g in seperate group. The algorithm goes like this, we first sort it with the left number.\\n```\\n[aaaaa]\\n[dd]\\n [bbbbbb]\\n    [ccccc]\\n            [eeeee]\\n             [ff]\\n                    [ggggg]\\n```\\nThen, for each group, we use a ptr variable to check the rightmost number. If the new interval\\'s left smaller than the ptr, it is the same interval. Else it is a new interval.\\n\\n### Step 2 \\nAfter we find all the group, we need to split them into two. Rather than split into two, we could think it as picking how many elements into the first group (since the remaining must be in the second group). For example, we get two groups of interval.\\nIf want to put 0 group into the first group, it would be 2C0 = 1\\nIf want to put 1 group into the first group, it would be 2C1 = 2\\nIf want to put 2 group into the first group, it would be 2C2 = 1\\nThus, the sum is 4.\\n\\nIt is easy to show that the ans for this question is sum(nC0, nC1, nC2, ... , nCn) where n is the groups of interval.\\nTo further simplify this, the sum(nC0, nC1, nC2, ... , nCn) = 2^n. We could use fast power to get the answer in O(log n) time for step 2.\\n\\n# Time Complexity\\nStep 1: Sorting => O(nlogn)\\nStep 2: Fast power => O(log n)\\n\\n\\n### If you find this useful, please feel free to drop an upvote and comment. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(), ranges.end());\\n        int ptr(-1), group(0);\\n        for (auto &pr: ranges){\\n            if (ptr < pr[0]){\\n                group++;\\n                ptr = pr[1];\\n            }else{\\n                ptr = max(ptr, pr[1]);\\n            }\\n        }\\n        return pow(2LL, group);\\n    }\\n    \\n    long long pow(long long base,long long power){\\n        long long result = 1;\\n        while (power > 0){\\n            if (power % 2 == 1)\\n                result = (result * base) % int(1e9+7);\\n            power /= 2;\\n            base = (base * base) % int(1e9+7);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\n[aaaaa]\\n [bbbbbb]\\n   [ccccc]\\n[dd]\\n            [eeeee]\\n             [ff]\\n                    [ggggg]\\n```\n```\\n[aaaaa]\\n[dd]\\n [bbbbbb]\\n    [ccccc]\\n            [eeeee]\\n             [ff]\\n                    [ggggg]\\n```\n```\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        sort(ranges.begin(), ranges.end());\\n        int ptr(-1), group(0);\\n        for (auto &pr: ranges){\\n            if (ptr < pr[0]){\\n                group++;\\n                ptr = pr[1];\\n            }else{\\n                ptr = max(ptr, pr[1]);\\n            }\\n        }\\n        return pow(2LL, group);\\n    }\\n    \\n    long long pow(long long base,long long power){\\n        long long result = 1;\\n        while (power > 0){\\n            if (power % 2 == 1)\\n                result = (result * base) % int(1e9+7);\\n            power /= 2;\\n            base = (base * base) % int(1e9+7);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256555,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nconst int mod=1e9+7; \\nint poo(int i, int j){\\n    if(j==1) return i;\\n    if(j==0) return 1;\\n    long long ans=poo(i, j/2);\\n    ans=(ans*ans)%mod;\\n    if(j%2) ans=(ans*i)%mod;\\n    return ans; \\n}\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        if(ranges.size()==1) return 2;\\n        sort(ranges.begin(), ranges.end());\\n        vector<int> prev=ranges[0];\\n        int ct=1;\\n        for (int i = 1; i < ranges.size(); i++){\\n           if (prev[1]<ranges[i][0]){\\n               prev=ranges[i];\\n               ct++;\\n           }\\n           else prev[1]=max(prev[1], ranges[i][1]);\\n        }\\n        return poo(2, ct);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int mod=1e9+7; \\nint poo(int i, int j){\\n    if(j==1) return i;\\n    if(j==0) return 1;\\n    long long ans=poo(i, j/2);\\n    ans=(ans*ans)%mod;\\n    if(j%2) ans=(ans*i)%mod;\\n    return ans; \\n}\\nclass Solution {\\npublic:\\n    int countWays(vector<vector<int>>& ranges) {\\n        if(ranges.size()==1) return 2;\\n        sort(ranges.begin(), ranges.end());\\n        vector<int> prev=ranges[0];\\n        int ct=1;\\n        for (int i = 1; i < ranges.size(); i++){\\n           if (prev[1]<ranges[i][0]){\\n               prev=ranges[i];\\n               ct++;\\n           }\\n           else prev[1]=max(prev[1], ranges[i][1]);\\n        }\\n        return poo(2, ct);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256554,
                "title": "java-merge-intervals-and-use-biginteger-to-prevent-overflow",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially, it seems like a UnionFind problem, to merge the overlapping intervals, then to calculate the result of 2^(how many intervals are merge together). But it does not need to do this, just sort the intervals and merge them. Here I use BigInteger to prevent from implementing a method of exp calculation. \\nUse python If you find it hard to deal with the overflow. <*_*> \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        int n = ranges.length;\\n        int count = 1;\\n        Arrays.sort(ranges,(a,b)->(a[0] - b[0]));\\n        int start = ranges[0][0];\\n        int end = ranges[0][1];\\n        for (int i=1;i<n;i++) {\\n            int st = ranges[i][0], en = ranges[i][1];\\n            if (end < st) {\\n                start = st;\\n                end = en;\\n                count++;\\n            } else {\\n                start = Math.min(start,st);\\n                end = Math.max(end,en);\\n            }\\n        }\\n        var mod = new BigInteger(String.valueOf(1_000_000_007));\\n        var exp = new BigInteger(String.valueOf(count));\\n        return new BigInteger(\"2\").modPow(exp,mod).intValue();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public int countWays(int[][] ranges) {\\n        int n = ranges.length;\\n        int count = 1;\\n        Arrays.sort(ranges,(a,b)->(a[0] - b[0]));\\n        int start = ranges[0][0];\\n        int end = ranges[0][1];\\n        for (int i=1;i<n;i++) {\\n            int st = ranges[i][0], en = ranges[i][1];\\n            if (end < st) {\\n                start = st;\\n                end = en;\\n                count++;\\n            } else {\\n                start = Math.min(start,st);\\n                end = Math.max(end,en);\\n            }\\n        }\\n        var mod = new BigInteger(String.valueOf(1_000_000_007));\\n        var exp = new BigInteger(String.valueOf(count));\\n        return new BigInteger(\"2\").modPow(exp,mod).intValue();\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1830542,
                "content": [
                    {
                        "username": "DeepikaSaraswat",
                        "content": "not understand question"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "First , One Must try 56 MERGE INTERVALS  [leetcode](https://leetcode.com)\\nAnd then the only catch is that , the number of ways for n intervals is 2^n.   ; ) "
                    },
                    {
                        "username": "DeepikaSaraswat",
                        "content": "not understand question"
                    },
                    {
                        "username": "sahil2311sharma",
                        "content": "Pre-requisite: [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)\\n\\nHow to proceed further? \\nTry using Binary Exponentiation using mod while returning the ans."
                    }
                ]
            },
            {
                "id": 1822095,
                "content": [
                    {
                        "username": "DeepikaSaraswat",
                        "content": "not understand question"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "First , One Must try 56 MERGE INTERVALS  [leetcode](https://leetcode.com)\\nAnd then the only catch is that , the number of ways for n intervals is 2^n.   ; ) "
                    },
                    {
                        "username": "DeepikaSaraswat",
                        "content": "not understand question"
                    },
                    {
                        "username": "sahil2311sharma",
                        "content": "Pre-requisite: [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)\\n\\nHow to proceed further? \\nTry using Binary Exponentiation using mod while returning the ans."
                    }
                ]
            },
            {
                "id": 1830543,
                "content": [
                    {
                        "username": "DeepikaSaraswat",
                        "content": "not understand question"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "First , One Must try 56 MERGE INTERVALS  [leetcode](https://leetcode.com)\\nAnd then the only catch is that , the number of ways for n intervals is 2^n.   ; ) "
                    },
                    {
                        "username": "DeepikaSaraswat",
                        "content": "not understand question"
                    },
                    {
                        "username": "sahil2311sharma",
                        "content": "Pre-requisite: [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)\\n\\nHow to proceed further? \\nTry using Binary Exponentiation using mod while returning the ans."
                    }
                ]
            },
            {
                "id": 1824665,
                "content": [
                    {
                        "username": "DeepikaSaraswat",
                        "content": "not understand question"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "First , One Must try 56 MERGE INTERVALS  [leetcode](https://leetcode.com)\\nAnd then the only catch is that , the number of ways for n intervals is 2^n.   ; ) "
                    },
                    {
                        "username": "DeepikaSaraswat",
                        "content": "not understand question"
                    },
                    {
                        "username": "sahil2311sharma",
                        "content": "Pre-requisite: [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)\\n\\nHow to proceed further? \\nTry using Binary Exponentiation using mod while returning the ans."
                    }
                ]
            }
        ]
    }
]