[
    {
        "title": "Mini Parser",
        "question_content": "Given a string s represents the serialization of a nested list, implement a parser to deserialize it and return the deserialized NestedInteger.\nEach element is either an integer or a list whose elements may also be integers or other lists.\n&nbsp;\nExample 1:\n\nInput: s = \"324\"\nOutput: 324\nExplanation: You should return a NestedInteger object which contains a single integer 324.\n\nExample 2:\n\nInput: s = \"[123,[456,[789]]]\"\nOutput: [123,[456,[789]]]\nExplanation: Return a NestedInteger object containing a nested list with 2 elements:\n1. An integer containing value 123.\n2. A nested list containing two elements:\n    i.  An integer containing value 456.\n    ii. A nested list with one element:\n         a. An integer containing value 789\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 5 * 104\n\ts consists of digits, square brackets \"[]\", negative sign '-', and commas ','.\n\ts is the serialization of valid NestedInteger.\n\tAll the values in the input are in the range [-106, 106].",
        "solutions": [
            {
                "id": 86066,
                "title": "an-java-iterative-solution",
                "content": "This approach will just iterate through every char in the string (no recursion).\\n* If encounters '[', push current NestedInteger to stack and start a new one.\\n* If encounters ']', end current NestedInteger and pop a NestedInteger from stack to continue.\\n* If encounters ',', append a new number to curr NestedInteger, if this comma is not right after a brackets.\\n* Update index l and r, where l shall point to the start of a integer substring, while r shall points to the end+1 of substring.\\n\\n\\nJava Code:\\n\\n    public NestedInteger deserialize(String s) {\\n        if (s.isEmpty())\\n            return null;\\n        if (s.charAt(0) != '[') // ERROR: special case\\n            return new NestedInteger(Integer.valueOf(s));\\n            \\n        Stack<NestedInteger> stack = new Stack<>();\\n        NestedInteger curr = null;\\n        int l = 0; // l shall point to the start of a number substring; \\n                   // r shall point to the end+1 of a number substring\\n        for (int r = 0; r < s.length(); r++) {\\n            char ch = s.charAt(r);\\n            if (ch == '[') {\\n                if (curr != null) {\\n                    stack.push(curr);\\n                }\\n                curr = new NestedInteger();\\n                l = r+1;\\n            } else if (ch == ']') {\\n                String num = s.substring(l, r);\\n                if (!num.isEmpty())\\n                    curr.add(new NestedInteger(Integer.valueOf(num)));\\n                if (!stack.isEmpty()) {\\n                    NestedInteger pop = stack.pop();\\n                    pop.add(curr);\\n                    curr = pop;\\n                }\\n                l = r+1;\\n            } else if (ch == ',') {\\n                if (s.charAt(r-1) != ']') {\\n                    String num = s.substring(l, r);\\n                    curr.add(new NestedInteger(Integer.valueOf(num)));\\n                }\\n                l = r+1;\\n            }\\n        }\\n        \\n        return curr;\\n    }",
                "solutionTags": [],
                "code": "This approach will just iterate through every char in the string (no recursion).\\n* If encounters '[', push current NestedInteger to stack and start a new one.\\n* If encounters ']', end current NestedInteger and pop a NestedInteger from stack to continue.\\n* If encounters ',', append a new number to curr NestedInteger, if this comma is not right after a brackets.\\n* Update index l and r, where l shall point to the start of a integer substring, while r shall points to the end+1 of substring.\\n\\n\\nJava Code:\\n\\n    public NestedInteger deserialize(String s) {\\n        if (s.isEmpty())\\n            return null;\\n        if (s.charAt(0) != '[') // ERROR: special case\\n            return new NestedInteger(Integer.valueOf(s));\\n            \\n        Stack<NestedInteger> stack = new Stack<>();\\n        NestedInteger curr = null;\\n        int l = 0; // l shall point to the start of a number substring; \\n                   // r shall point to the end+1 of a number substring\\n        for (int r = 0; r < s.length(); r++) {\\n            char ch = s.charAt(r);\\n            if (ch == '[') {\\n                if (curr != null) {\\n                    stack.push(curr);\\n                }\\n                curr = new NestedInteger();\\n                l = r+1;\\n            } else if (ch == ']') {\\n                String num = s.substring(l, r);\\n                if (!num.isEmpty())\\n                    curr.add(new NestedInteger(Integer.valueOf(num)));\\n                if (!stack.isEmpty()) {\\n                    NestedInteger pop = stack.pop();\\n                    pop.add(curr);\\n                    curr = pop;\\n                }\\n                l = r+1;\\n            } else if (ch == ',') {\\n                if (s.charAt(r-1) != ']') {\\n                    String num = s.substring(l, r);\\n                    curr.add(new NestedInteger(Integer.valueOf(num)));\\n                }\\n                l = r+1;\\n            }\\n        }\\n        \\n        return curr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 86060,
                "title": "python-c-solutions",
                "content": "## Python using `eval`:\\n\\n    def deserialize(self, s):\\n        def nestedInteger(x):\\n            if isinstance(x, int):\\n                return NestedInteger(x)\\n            lst = NestedInteger()\\n            for y in x:\\n                lst.add(nestedInteger(y))\\n            return lst\\n        return nestedInteger(eval(s))\\n\\n## Python one-liner\\n\\n    def deserialize(self, s):\\n        return NestedInteger(s) if isinstance(s, int) else reduce(lambda a, x: a.add(self.deserialize(x)) or a, s, NestedInteger()) if isinstance(s, list) else self.deserialize(eval(s))\\n\\n## Python Golf (136 bytes or 31 bytes)\\n```\\nclass Solution:deserialize=d=lambda S,s,N=NestedInteger:s<[]and N(s)or s<''and reduce(lambda a,x:a.add(S.d(x))or a,s,N())or S.d(eval(s))\\n```\\nOr abusing how the judge judges (yes, this gets accepted):\\n```\\nclass Solution:deserialize=eval\\n```\\n\\n## Python parsing char by char\\n\\nHere I turned the input string into a list with sentinel for convenience.\\n\\n    def deserialize(self, s):\\n        def nestedInteger():\\n            num = ''\\n            while s[-1] in '1234567890-':\\n                num += s.pop()\\n            if num:\\n                return NestedInteger(int(num))\\n            s.pop()\\n            lst = NestedInteger()\\n            while s[-1] != ']':\\n                lst.add(nestedInteger())\\n                if s[-1] == ',':\\n                    s.pop()\\n            s.pop()\\n            return lst\\n        s = list(' ' + s[::-1])\\n        return nestedInteger()\\n\\n## C++ using `istringstream`\\n```\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        istringstream in(s);\\n        return deserialize(in);\\n    }\\nprivate:\\n    NestedInteger deserialize(istringstream &in) {\\n        int number;\\n        if (in >> number)\\n            return NestedInteger(number);\\n        in.clear();\\n        in.get();\\n        NestedInteger list;\\n        while (in.peek() != ']') {\\n            list.add(deserialize(in));\\n            if (in.peek() == ',')\\n                in.get();\\n        }\\n        in.get();\\n        return list;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:deserialize=d=lambda S,s,N=NestedInteger:s<[]and N(s)or s<''and reduce(lambda a,x:a.add(S.d(x))or a,s,N())or S.d(eval(s))\\n```\n```\\nclass Solution:deserialize=eval\\n```\n```\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        istringstream in(s);\\n        return deserialize(in);\\n    }\\nprivate:\\n    NestedInteger deserialize(istringstream &in) {\\n        int number;\\n        if (in >> number)\\n            return NestedInteger(number);\\n        in.clear();\\n        in.get();\\n        NestedInteger list;\\n        while (in.peek() != ']') {\\n            list.add(deserialize(in));\\n            if (in.peek() == ',')\\n                in.get();\\n        }\\n        in.get();\\n        return list;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86074,
                "title": "c-non-recursive-one-pass-solution-using-stack-a-possible-implementation-of-nestedinteger",
                "content": "**Solution in a Glance:**\\nThis solution uses a stack to record the NestedInteger's.\\nAt the very beginning, an empty NestedInteger is placed in the stack. This NestedInteger will be regarded as a list that holds one but only one NestedInteger, which will be returned in the end.\\n*Logic:* When encountering '[', the stack has one more element. When encountering ']', the stack has one less element.\\n\\n**Complexities:**\\n* Time: *O*(n)     \\n* Space: worse-case *O*(n) (worse case: [1,[2,[3,[....[n-1,[n]]]....])\\n\\n**C++ Accepted Code:** \\n(A possible implementation of **NestedInteger** is also provided in the first reply.)\\n\\n    class Solution {\\n    public:\\n        NestedInteger deserialize(string s) {\\n            function<bool(char)> isnumber = [](char c){ return (c == '-') || isdigit(c); };\\n            \\n            stack<NestedInteger> stk;\\n            stk.push(NestedInteger());\\n            \\n            for (auto it = s.begin(); it != s.end();) {\\n                const char & c = (*it);\\n                if (isnumber(c)) {\\n                    auto it2 = find_if_not(it, s.end(), isnumber);\\n                    int val = stoi(string(it, it2));\\n                    stk.top().add(NestedInteger(val));\\n                    it = it2;\\n                }\\n                else {\\n                    if (c == '[') {\\n                        stk.push(NestedInteger());\\n                    }\\n                    else if (c == ']') {\\n                        NestedInteger ni = stk.top();\\n                        stk.pop();\\n                        stk.top().add(ni);\\n                    }\\n                    ++it;\\n                }\\n            }\\n            \\n            NestedInteger result = stk.top().getList().front();\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n        NestedInteger deserialize(string s) {\\n            function<bool(char)> isnumber = [](char c){ return (c == '-') || isdigit(c); }",
                "codeTag": "Java"
            },
            {
                "id": 156318,
                "title": "python-o-n-one-pass-iterative-solution",
                "content": "```\\nclass Solution:\\n    def deserialize(self, s):\\n        stack, num, last = [], \"\", None\\n        for c in s:\\n            if c.isdigit() or c == \"-\": num += c\\n            elif c == \",\" and num:\\n                stack[-1].add(NestedInteger(int(num)))\\n                num = \"\"\\n            elif c == \"[\":\\n                elem = NestedInteger()\\n                if stack: stack[-1].add(elem)\\n                stack.append(elem)\\n            elif c == \"]\":\\n                if num:\\n                    stack[-1].add(NestedInteger(int(num)))\\n                    num = \"\"\\n                last = stack.pop()\\n        return last if last else NestedInteger(int(num))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deserialize(self, s):\\n        stack, num, last = [], \"\", None\\n        for c in s:\\n            if c.isdigit() or c == \"-\": num += c\\n            elif c == \",\" and num:\\n                stack[-1].add(NestedInteger(int(num)))\\n                num = \"\"\\n            elif c == \"[\":\\n                elem = NestedInteger()\\n                if stack: stack[-1].add(elem)\\n                stack.append(elem)\\n            elif c == \"]\":\\n                if num:\\n                    stack[-1].add(NestedInteger(int(num)))\\n                    num = \"\"\\n                last = stack.pop()\\n        return last if last else NestedInteger(int(num))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86120,
                "title": "a-top-down-parser-using-c",
                "content": "```c++\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        int index = 0;\\n        char c = s[index];\\n        if (c == '[') {\\n            return parseList(s, index);\\n        } else {\\n            // starts with 0-9, '-'\\n            return parseNumber(s, index);\\n        }\\n    }\\n    \\n    NestedInteger parseList(string &s, int &index) {\\n        index++; // eat '['\\n        NestedInteger root;\\n        while (index < s.size()) {\\n            char c = s[index];\\n            if (c == '[') {\\n                root.add(parseList(s, index));\\n            } else if (isNumber(c) || c == '-') {\\n                root.add(parseNumber(s, index));\\n            } else if (c == ',') {\\n                // skip\\n                index++;\\n            } else if (c == ']') {\\n                break;\\n            }\\n        }\\n        index++; // eat ']'\\n        return root;\\n    }\\n    \\n    NestedInteger parseNumber(string &s, int &index) {\\n        int n = 0;\\n        int positive = 1;  // flag for positive number\\n        if (s[index] == '-') {\\n            positive = -1;\\n            index++;\\n        }\\n        while (index < s.size()) {\\n            char c = s[index];\\n            if (isNumber(c)) {\\n                n = 10 * n + c - '0';\\n                index++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return NestedInteger(n * positive);\\n    }\\n    \\n    bool isNumber(char c) {\\n        return '0' <= c && c <= '9';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        int index = 0;\\n        char c = s[index];\\n        if (c == '[') {\\n            return parseList(s, index);\\n        } else {\\n            // starts with 0-9, '-'\\n            return parseNumber(s, index);\\n        }\\n    }\\n    \\n    NestedInteger parseList(string &s, int &index) {\\n        index++; // eat '['\\n        NestedInteger root;\\n        while (index < s.size()) {\\n            char c = s[index];\\n            if (c == '[') {\\n                root.add(parseList(s, index));\\n            } else if (isNumber(c) || c == '-') {\\n                root.add(parseNumber(s, index));\\n            } else if (c == ',') {\\n                // skip\\n                index++;\\n            } else if (c == ']') {\\n                break;\\n            }\\n        }\\n        index++; // eat ']'\\n        return root;\\n    }\\n    \\n    NestedInteger parseNumber(string &s, int &index) {\\n        int n = 0;\\n        int positive = 1;  // flag for positive number\\n        if (s[index] == '-') {\\n            positive = -1;\\n            index++;\\n        }\\n        while (index < s.size()) {\\n            char c = s[index];\\n            if (isNumber(c)) {\\n                n = 10 * n + c - '0';\\n                index++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return NestedInteger(n * positive);\\n    }\\n    \\n    bool isNumber(char c) {\\n        return '0' <= c && c <= '9';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86083,
                "title": "short-java-recursive-solution",
                "content": "\\n```\\npublic class Solution {\\n    public NestedInteger deserialize(String s) {\\n        NestedInteger ret = new NestedInteger();\\n        if (s == null || s.length() == 0) return ret;\\n        if (s.charAt(0) != '[') {\\n            ret.setInteger(Integer.parseInt(s));\\n        }\\n        else if (s.length() > 2) {\\n            int start = 1, count = 0;\\n            for (int i = 1; i < s.length(); i++) {\\n                char c = s.charAt(i);\\n                if (count == 0 && (c == ',' || i == s.length() - 1)) {\\n                    ret.add(deserialize(s.substring(start, i)));\\n                    start = i + 1;\\n                }\\n                else if (c == '[') count++;\\n                else if (c == ']') count--;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public NestedInteger deserialize(String s) {\\n        NestedInteger ret = new NestedInteger();\\n        if (s == null || s.length() == 0) return ret;\\n        if (s.charAt(0) != '[') {\\n            ret.setInteger(Integer.parseInt(s));\\n        }\\n        else if (s.length() > 2) {\\n            int start = 1, count = 0;\\n            for (int i = 1; i < s.length(); i++) {\\n                char c = s.charAt(i);\\n                if (count == 0 && (c == ',' || i == s.length() - 1)) {\\n                    ret.add(deserialize(s.substring(start, i)));\\n                    start = i + 1;\\n                }\\n                else if (c == '[') count++;\\n                else if (c == ']') count--;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86204,
                "title": "java-solution-using-stack-logic-same-same-as-basic-calculator-question",
                "content": "```\\n    public NestedInteger deserialize(String s) {\\n        if(s == null || s.isEmpty()) return new NestedInteger();\\n        Stack<NestedInteger> stack = new Stack<>();\\n        int sign = 1, len = s.length() ;\\n        for(int i = 0 ; i < len ; i++){\\n            char c = s.charAt(i);\\n            if(c == '['){\\n                stack.push(new NestedInteger()); // start of a new NestedInteger\\n            }else if( c == ']' && stack.size() > 1){ // End of a NesterdInteger\\n                NestedInteger n = stack.pop();\\n                stack.peek().add(n); \\n            }else if(c == '-'){ // just change the sign \\n                sign = -1;\\n            }else if(Character.isDigit(c)){ // if digit check for all the continous ones\\n                int num = c - '0';\\n                while( i + 1 < len && Character.isDigit(s.charAt(i+1))){\\n                    num = num * 10 + s.charAt(i+1) - '0';\\n                    i++;\\n                }\\n                num = num * sign;\\n                if(!stack.isEmpty()){\\n                    stack.peek().add(new NestedInteger(num)); // add to previous item if not empty\\n                }else{\\n                    stack.push(new NestedInteger(num));\\n                }\\n                sign = 1; // reset the sign\\n            }\\n        }\\n        return stack.isEmpty() ? new NestedInteger() : stack.pop() ; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public NestedInteger deserialize(String s) {\\n        if(s == null || s.isEmpty()) return new NestedInteger();\\n        Stack<NestedInteger> stack = new Stack<>();\\n        int sign = 1, len = s.length() ;\\n        for(int i = 0 ; i < len ; i++){\\n            char c = s.charAt(i);\\n            if(c == '['){\\n                stack.push(new NestedInteger()); // start of a new NestedInteger\\n            }else if( c == ']' && stack.size() > 1){ // End of a NesterdInteger\\n                NestedInteger n = stack.pop();\\n                stack.peek().add(n); \\n            }else if(c == '-'){ // just change the sign \\n                sign = -1;\\n            }else if(Character.isDigit(c)){ // if digit check for all the continous ones\\n                int num = c - '0';\\n                while( i + 1 < len && Character.isDigit(s.charAt(i+1))){\\n                    num = num * 10 + s.charAt(i+1) - '0';\\n                    i++;\\n                }\\n                num = num * sign;\\n                if(!stack.isEmpty()){\\n                    stack.peek().add(new NestedInteger(num)); // add to previous item if not empty\\n                }else{\\n                    stack.push(new NestedInteger(num));\\n                }\\n                sign = 1; // reset the sign\\n            }\\n        }\\n        return stack.isEmpty() ? new NestedInteger() : stack.pop() ; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86157,
                "title": "straightforward-java-solution-with-explanation-and-a-simple-implementation-of-nestedinteger-for-your-ease-of-testing",
                "content": "Also viewable [here](https://github.com/fishercoder1534/Leetcode/blob/master/src/main/java/com/fishercoder/solutions/MiniParser.java).\\n\\nThe idea is very straightforward:\\n\\n1. if it's '[', we just construct a new nested integer and push it onto the stack\\n\\n2. if it's a number, we parse the whole number and add to the previous nested integer object\\n\\n3. if it's ',', we'll just continue;\\n\\n4. if it's ']', we'll just pop one nested integer from the working stack and assign it to the result\\n\\nAlso, we'll pay attention to this corner case or understand the input: the input could be \"324\", \"[324]\", they are different: the former should return a nested integer with one single integer, the latter should return a nested integer with a list\\n```\\npublic NestedInteger deserialize(String s) {\\n        if(s == null || s.isEmpty() || s.length() == 0) return new NestedInteger();\\n        Stack<NestedInteger> workStack = new Stack<NestedInteger>();\\n        NestedInteger result = null;\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0;\\n        //if it's just a single number, then we'll just return a nested integer with one integer\\n        if(s.charAt(i) != '['){\\n            sb.setLength(0);\\n            while(i < s.length() && ((Character.getNumericValue(s.charAt(i)) < 10 && Character.getNumericValue(s.charAt(i)) >= 0) || s.charAt(i) == '-')){\\n                sb.append(s.charAt(i));\\n                i++;\\n            }\\n            int num = Integer.parseInt(sb.toString());\\n            return new NestedInteger(num);\\n        }//all other cases, we'll return a nested integer with a list\\n        else{\\n            while (i < s.length()) {\\n                if (s.charAt(i) == '[') {\\n                    NestedInteger ni = new NestedInteger();\\n                    // we'll put this one into its last one if there's one on the workStack\\n                    if (!workStack.isEmpty()) {\\n                        NestedInteger lastNi = workStack.pop();\\n                        lastNi.add(ni);\\n                        workStack.push(lastNi);// then push it back\\n                    }\\n                    workStack.push(ni);\\n                    i++;\\n                } else if (s.charAt(i) == ',') {\\n                    i++;\\n                } else if (s.charAt(i) == ']') {\\n                    NestedInteger completedNi = workStack.pop();\\n                    result = completedNi;\\n                    i++;\\n                } else {\\n                    // then it must be a number\\n                    sb.setLength(0);\\n                    while (i < s.length()\\n                            && ((Character.getNumericValue(s.charAt(i)) < 10 && Character\\n                                    .getNumericValue(s.charAt(i)) >= 0) || s.charAt(i) == '-')) {\\n                        sb.append(s.charAt(i));\\n                        i++;\\n                    }\\n                    int num = Integer.parseInt(sb.toString());\\n                    NestedInteger ni = null;\\n                    if (!workStack.isEmpty())\\n                        ni = workStack.pop();\\n                    else\\n                        ni = new NestedInteger();\\n                    // case 1: if this one contains one integer\\n                    if (ni.isInteger()) {\\n                        // we'll add it to this ni\\n                        ni.add(new NestedInteger(num));\\n                    }\\n                    // case 2: if this one contains a nested integer\\n                    else if (ni.getList() != null && ni.getList().size() != 0) {\\n                        // we'll get the last nested integer and add this one to it\\n                        ni.add(new NestedInteger(num));\\n                    } else {\\n                        // case 3: if this is an empty nested integer\\n                        if(i > 0) ni.add(new NestedInteger(num));\\n                        else ni.setInteger(num);\\n                    }\\n                    workStack.push(ni);\\n                    if (i == s.length())\\n                        return ni;// this is for test cases like this: \"324\", there's no '[' or ']'\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```\\n\\nAlso, I've written a simple implementation for NestedInteger class, I find it helpful, posted it here as well:\\n```\\nclass NestedInteger {\\n    private List<NestedInteger> list;\\n    private Integer integer;\\n    \\n    public NestedInteger(List<NestedInteger> list){\\n        this.list = list;\\n    }\\n    \\n    public void add(NestedInteger nestedInteger) {\\n        if(this.list != null){\\n            this.list.add(nestedInteger);\\n        } else {\\n            this.list = new ArrayList();\\n            this.list.add(nestedInteger);\\n        }\\n    }\\n\\n    public void setInteger(int num) {\\n        this.integer = num;\\n    }\\n\\n    public NestedInteger(Integer integer){\\n        this.integer = integer;\\n    }\\n\\n    public NestedInteger() {\\n        this.list = new ArrayList();\\n    }\\n\\n    public boolean isInteger() {\\n        return integer != null;\\n    }\\n\\n    public Integer getInteger() {\\n        return integer;\\n    }\\n\\n    public List<NestedInteger> getList() {\\n        return list;\\n    }\\n    \\n    public String printNi(NestedInteger thisNi, StringBuilder sb){\\n        if(thisNi.isInteger()) {\\n            sb.append(thisNi.integer);\\n            sb.append(\",\");\\n        }\\n        sb.append(\"[\");\\n        for(NestedInteger ni : thisNi.list){\\n            if(ni.isInteger()) {\\n                sb.append(ni.integer);\\n                sb.append(\",\");\\n            }\\n            else {\\n                printNi(ni, sb);\\n            }\\n        }\\n        sb.append(\"]\");\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic NestedInteger deserialize(String s) {\\n        if(s == null || s.isEmpty() || s.length() == 0) return new NestedInteger();\\n        Stack<NestedInteger> workStack = new Stack<NestedInteger>();\\n        NestedInteger result = null;\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0;\\n        //if it's just a single number, then we'll just return a nested integer with one integer\\n        if(s.charAt(i) != '['){\\n            sb.setLength(0);\\n            while(i < s.length() && ((Character.getNumericValue(s.charAt(i)) < 10 && Character.getNumericValue(s.charAt(i)) >= 0) || s.charAt(i) == '-')){\\n                sb.append(s.charAt(i));\\n                i++;\\n            }\\n            int num = Integer.parseInt(sb.toString());\\n            return new NestedInteger(num);\\n        }//all other cases, we'll return a nested integer with a list\\n        else{\\n            while (i < s.length()) {\\n                if (s.charAt(i) == '[') {\\n                    NestedInteger ni = new NestedInteger();\\n                    // we'll put this one into its last one if there's one on the workStack\\n                    if (!workStack.isEmpty()) {\\n                        NestedInteger lastNi = workStack.pop();\\n                        lastNi.add(ni);\\n                        workStack.push(lastNi);// then push it back\\n                    }\\n                    workStack.push(ni);\\n                    i++;\\n                } else if (s.charAt(i) == ',') {\\n                    i++;\\n                } else if (s.charAt(i) == ']') {\\n                    NestedInteger completedNi = workStack.pop();\\n                    result = completedNi;\\n                    i++;\\n                } else {\\n                    // then it must be a number\\n                    sb.setLength(0);\\n                    while (i < s.length()\\n                            && ((Character.getNumericValue(s.charAt(i)) < 10 && Character\\n                                    .getNumericValue(s.charAt(i)) >= 0) || s.charAt(i) == '-')) {\\n                        sb.append(s.charAt(i));\\n                        i++;\\n                    }\\n                    int num = Integer.parseInt(sb.toString());\\n                    NestedInteger ni = null;\\n                    if (!workStack.isEmpty())\\n                        ni = workStack.pop();\\n                    else\\n                        ni = new NestedInteger();\\n                    // case 1: if this one contains one integer\\n                    if (ni.isInteger()) {\\n                        // we'll add it to this ni\\n                        ni.add(new NestedInteger(num));\\n                    }\\n                    // case 2: if this one contains a nested integer\\n                    else if (ni.getList() != null && ni.getList().size() != 0) {\\n                        // we'll get the last nested integer and add this one to it\\n                        ni.add(new NestedInteger(num));\\n                    } else {\\n                        // case 3: if this is an empty nested integer\\n                        if(i > 0) ni.add(new NestedInteger(num));\\n                        else ni.setInteger(num);\\n                    }\\n                    workStack.push(ni);\\n                    if (i == s.length())\\n                        return ni;// this is for test cases like this: \"324\", there's no '[' or ']'\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```\n```\\nclass NestedInteger {\\n    private List<NestedInteger> list;\\n    private Integer integer;\\n    \\n    public NestedInteger(List<NestedInteger> list){\\n        this.list = list;\\n    }\\n    \\n    public void add(NestedInteger nestedInteger) {\\n        if(this.list != null){\\n            this.list.add(nestedInteger);\\n        } else {\\n            this.list = new ArrayList();\\n            this.list.add(nestedInteger);\\n        }\\n    }\\n\\n    public void setInteger(int num) {\\n        this.integer = num;\\n    }\\n\\n    public NestedInteger(Integer integer){\\n        this.integer = integer;\\n    }\\n\\n    public NestedInteger() {\\n        this.list = new ArrayList();\\n    }\\n\\n    public boolean isInteger() {\\n        return integer != null;\\n    }\\n\\n    public Integer getInteger() {\\n        return integer;\\n    }\\n\\n    public List<NestedInteger> getList() {\\n        return list;\\n    }\\n    \\n    public String printNi(NestedInteger thisNi, StringBuilder sb){\\n        if(thisNi.isInteger()) {\\n            sb.append(thisNi.integer);\\n            sb.append(\",\");\\n        }\\n        sb.append(\"[\");\\n        for(NestedInteger ni : thisNi.list){\\n            if(ni.isInteger()) {\\n                sb.append(ni.integer);\\n                sb.append(\",\");\\n            }\\n            else {\\n                printNi(ni, sb);\\n            }\\n        }\\n        sb.append(\"]\");\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86181,
                "title": "very-short-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:   \\n    NestedInteger parse(string& s, int& i) {\\n      if(s[i]=='[') {\\n          ++i;\\n          NestedInteger list;\\n          while(s[i] != ']') {\\n              list.add(parse(s,i));\\n              if(s[i] ==',') ++i;\\n          }\\n          ++i;\\n          return list;\\n      } else {                       \\n        int sum = 0;\\n        int sign=1;\\n        if(s[i] == '-'){ sign = -1; ++i;}\\n        while(isdigit(s[i])) { sum *= 10; sum+= s[i]-'0'; ++i;}\\n          return NestedInteger(sum*sign);\\n      }\\n    }\\n    NestedInteger deserialize(string s) {\\n        int i = 0;\\n        return parse(s, i);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:   \\n    NestedInteger parse(string& s, int& i) {\\n      if(s[i]=='[') {\\n          ++i;\\n          NestedInteger list;\\n          while(s[i] != ']') {\\n              list.add(parse(s,i));\\n              if(s[i] ==',') ++i;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 86082,
                "title": "python-iterative-solution-with-stack-and-dummy-nestedinteger",
                "content": "    from collections import deque\\n\\n    class Solution(object):\\n        def deserialize(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: NestedInteger\\n            \"\"\"\\n            initial = NestedInteger()\\n            q = deque()\\n            q.append(initial)\\n            i = 0\\n\\n            while(i < len(s)):\\n                if s[i] == '[':\\n                    n = NestedInteger()\\n                    q[-1].add(n)\\n                    q.append(n)\\n                    i += 1\\n                elif s[i] == ']':\\n                    q.pop()\\n                    i += 1\\n                elif s[i] == ',':\\n                    i += 1\\n                else:\\n                    j = i\\n                    while j < len(s) and ('0' <= s[j] <= '9' or s[j] == '-'):\\n                        j += 1\\n                    q[-1].add(int(s[i:j]))\\n                    i = j\\n\\n            return q[0].getList()[0]",
                "solutionTags": [],
                "code": "    from collections import deque\\n\\n    class Solution(object):\\n        def deserialize(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: NestedInteger\\n            \"\"\"\\n            initial = NestedInteger()\\n            q = deque()\\n            q.append(initial)\\n            i = 0\\n\\n            while(i < len(s)):\\n                if s[i] == '[':\\n                    n = NestedInteger()\\n                    q[-1].add(n)\\n                    q.append(n)\\n                    i += 1\\n                elif s[i] == ']':\\n                    q.pop()\\n                    i += 1\\n                elif s[i] == ',':\\n                    i += 1\\n                else:\\n                    j = i\\n                    while j < len(s) and ('0' <= s[j] <= '9' or s[j] == '-'):\\n                        j += 1\\n                    q[-1].add(int(s[i:j]))\\n                    i = j\\n\\n            return q[0].getList()[0]",
                "codeTag": "Java"
            },
            {
                "id": 86182,
                "title": "c-clean-and-elegant-code-with-clear-logic",
                "content": "```cs\\nclass Solution {\\n    NestedInteger parse(const string &s, int & pos)\\n    {\\n        if (s[pos] == '[')\\n            return parseList(s, pos);\\n        return parseNum(s, pos);\\n    }\\n    NestedInteger parseNum(const string &s, int & pos)\\n    {\\n        int num = 0;\\n        int sign = s[pos] == '-' ? -1 : 1;\\n        if (s[pos] == '-' || s[pos] == '+')\\n            pos ++;\\n        for (;pos < s.size() && isdigit(s[pos]); pos ++)\\n            num = num * 10 + s[pos] - '0';\\n        return NestedInteger(sign * num);\\n    }\\n    NestedInteger parseList(const string &s, int &pos)\\n    {\\n        NestedInteger ni;\\n        while (s[pos] != ']')\\n        {\\n            pos ++;                   //skip [ or ,\\n            if (s[pos] == ']') break; //handle [] or [1,2,]\\n            ni.add(parse(s, pos));\\n        }\\n        pos ++;                       // skip ]\\n        return ni;\\n    }\\npublic:\\n    NestedInteger deserialize(const string &s) {\\n        int pos = 0;//pos ALWAYS points to 1 position past the last parsed string;\\n                    //This is an invariance maintained across the entire program.\\n        return parse(s, pos);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    NestedInteger parse(const string &s, int & pos)\\n    {\\n        if (s[pos] == '[')\\n            return parseList(s, pos);\\n        return parseNum(s, pos);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3254662,
                "title": "385-time-92-59-and-space-97-53-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We start by checking if the input string s starts with a [. If it doesn\\'t, then it must be a single integer, so we create a NestedInteger object with that value and return it.\\n\\n```\\nif s[0] != \\'[\\':\\n  return NestedInteger(int(s))\\n```\\n2. If the input string does start with a [, we create an empty stack to keep track of NestedInteger objects and sublists as we parse the input string.\\n```\\nstack = []\\n```\\n3. We then loop through each character in the input string, using enumerate to keep track of the index of the current character.\\n```\\nfor i, c in enumerate(s):\\n```\\n4. If we encounter an opening bracket [, we push a new empty NestedInteger object onto the stack and set the starting index for the next element to be parsed.\\n```\\nif c == \\'[\\':\\n  stack.append(NestedInteger())\\n  start = i + 1\\n```\\n5. If we encounter a comma ,, we check if there was a number between the previous comma or opening bracket and this one. If there was, we create a new NestedInteger object with that value and add it to the NestedInteger object on the top of the stack. We then update the starting index for the next element to be parsed.\\n```\\nelif c == \\',\\':\\n  if i > start:\\n    num = int(s[start:i])\\n    stack[-1].add(NestedInteger(num))\\n  start = i + 1\\n```\\n6. If we encounter a closing bracket ], we pop the top NestedInteger object from the stack and check if there was a number between the previous comma or opening bracket and this one. If there was, we create a new NestedInteger object with that value and add it to the popped NestedInteger object. If there are still NestedInteger objects on the stack, we add the popped NestedInteger to the one on top. Otherwise, we return the popped NestedInteger. We then update the starting index for the next element to be parsed.\\n\\n```\\nelif c == \\']\\':\\n  popped = stack.pop()\\n  if i > start:\\n    num = int(s[start:i])\\n    popped.add(NestedInteger(num))\\n  if stack:\\n    stack[-1].add(popped)\\n  else:\\n    return popped\\n  start = i + 1\\n```\\n7. After the loop is finished, we should have only one NestedInteger object left on the stack. We return this object as the final deserialized result.\\n```\\nreturn stack[-1]\\n```\\n# Complexity\\n- Time complexity:\\n92.59%\\n\\n- Space complexity:\\n97.53%\\n\\n# Code\\n```\\nclass Solution:\\n  def deserialize(self, s: str) -> NestedInteger:\\n    # If s doesn\\'t start with a \\'[\\', it must be a single integer, so create a NestedInteger object with that value\\n    if s[0] != \\'[\\':\\n      return NestedInteger(int(s))\\n\\n    # Create an empty stack to keep track of NestedInteger objects and sublists as we parse the input string\\n    stack = []\\n\\n    # Loop through each character in the string\\n    for i, c in enumerate(s):\\n      if c == \\'[\\':\\n        # If we encounter an opening bracket, push a new empty NestedInteger object onto the stack and set the starting index for the next element\\n        stack.append(NestedInteger())\\n        start = i + 1\\n      elif c == \\',\\':\\n        # If we encounter a comma, check if there was a number between the previous comma or opening bracket and this one.\\n        # If there was, create a new NestedInteger object with that value and add it to the NestedInteger object on the top of the stack\\n        if i > start:\\n          num = int(s[start:i])\\n          stack[-1].add(NestedInteger(num))\\n        # Update the starting index for the next element to be parsed\\n        start = i + 1\\n      elif c == \\']\\':\\n        # If we encounter a closing bracket, pop the top NestedInteger object from the stack and check if there was a number between the previous comma or opening bracket and this one.\\n        # If there was, create a new NestedInteger object with that value and add it to the popped NestedInteger object\\n        popped = stack.pop()\\n        if i > start:\\n          num = int(s[start:i])\\n          popped.add(NestedInteger(num))\\n        # If there are still NestedInteger objects on the stack, add the popped NestedInteger to the one on top. Otherwise, return the popped NestedInteger\\n        if stack:\\n          stack[-1].add(popped)\\n        else:\\n          return popped\\n        # Update the starting index for the next element to be parsed\\n        start = i + 1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nif s[0] != \\'[\\':\\n  return NestedInteger(int(s))\\n```\n```\\nstack = []\\n```\n```\\nfor i, c in enumerate(s):\\n```\n```\\nif c == \\'[\\':\\n  stack.append(NestedInteger())\\n  start = i + 1\\n```\n```\\nelif c == \\',\\':\\n  if i > start:\\n    num = int(s[start:i])\\n    stack[-1].add(NestedInteger(num))\\n  start = i + 1\\n```\n```\\nelif c == \\']\\':\\n  popped = stack.pop()\\n  if i > start:\\n    num = int(s[start:i])\\n    popped.add(NestedInteger(num))\\n  if stack:\\n    stack[-1].add(popped)\\n  else:\\n    return popped\\n  start = i + 1\\n```\n```\\nreturn stack[-1]\\n```\n```\\nclass Solution:\\n  def deserialize(self, s: str) -> NestedInteger:\\n    # If s doesn\\'t start with a \\'[\\', it must be a single integer, so create a NestedInteger object with that value\\n    if s[0] != \\'[\\':\\n      return NestedInteger(int(s))\\n\\n    # Create an empty stack to keep track of NestedInteger objects and sublists as we parse the input string\\n    stack = []\\n\\n    # Loop through each character in the string\\n    for i, c in enumerate(s):\\n      if c == \\'[\\':\\n        # If we encounter an opening bracket, push a new empty NestedInteger object onto the stack and set the starting index for the next element\\n        stack.append(NestedInteger())\\n        start = i + 1\\n      elif c == \\',\\':\\n        # If we encounter a comma, check if there was a number between the previous comma or opening bracket and this one.\\n        # If there was, create a new NestedInteger object with that value and add it to the NestedInteger object on the top of the stack\\n        if i > start:\\n          num = int(s[start:i])\\n          stack[-1].add(NestedInteger(num))\\n        # Update the starting index for the next element to be parsed\\n        start = i + 1\\n      elif c == \\']\\':\\n        # If we encounter a closing bracket, pop the top NestedInteger object from the stack and check if there was a number between the previous comma or opening bracket and this one.\\n        # If there was, create a new NestedInteger object with that value and add it to the popped NestedInteger object\\n        popped = stack.pop()\\n        if i > start:\\n          num = int(s[start:i])\\n          popped.add(NestedInteger(num))\\n        # If there are still NestedInteger objects on the stack, add the popped NestedInteger to the one on top. Otherwise, return the popped NestedInteger\\n        if stack:\\n          stack[-1].add(popped)\\n        else:\\n          return popped\\n        # Update the starting index for the next element to be parsed\\n        start = i + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86161,
                "title": "short-and-clean-java-recursive-solution-with-explanation",
                "content": "Using the \"lvl\" variable to track if we are inside an inner integer.\\nUsing lIndex to track the leftmost start position.\\nEvery time the program hit the \"[\" increase lvl, and decrease lvl when hit \"]\"\\nWhen the program meets \",\"\\n      If lvl != 0, ignore the \",\" since we are inside a nested integer\\n      else do recursive call  ,add the result to the current list and move lIndex.\\n\\n[ [abc, [xy]] , def, [qqq] ]\\nni.add(myDeserialize(\"[abc, [xy]]\"));\\nni.add(myDeserialize(\"def\");\\nni.add(myDeserialize(\"[qqq]\");\\n\\n\\n\\n    public NestedInteger deserialize(String s) {\\n        if (s.length() == 0)    return new NestedInteger();\\n        return myDeserialize(s, 0, s.length()-1);\\n    }\\n    \\n    private NestedInteger myDeserialize(String s, int start, int end) {\\n        if (s.charAt(start) != '[') \\n            return new NestedInteger(Integer.valueOf(s.substring(start, end+1)));\\n\\n        NestedInteger ni = new NestedInteger();\\n        int lvl = 0, lIndex = start+1;\\n \\n        for (int i=start+1 ; i<=end-1 ; ++i) {\\n            char ch = s.charAt(i);\\n            if (ch == '[')  ++lvl;\\n            else if (ch == ']') --lvl; \\n            else if (ch == ',' && lvl == 0) {\\n                ni.add(myDeserialize(s, lIndex, i-1));\\n                lIndex = i + 1;\\n            }\\n        }\\n        if (lIndex <= end-1) {\\n            ni.add(myDeserialize(s, lIndex, end-1));\\n        }\\n        return ni;        \\n    }",
                "solutionTags": [],
                "code": "Using the \"lvl\" variable to track if we are inside an inner integer.\\nUsing lIndex to track the leftmost start position.\\nEvery time the program hit the \"[\" increase lvl, and decrease lvl when hit \"]\"\\nWhen the program meets \",\"\\n      If lvl != 0, ignore the \",\" since we are inside a nested integer\\n      else do recursive call  ,add the result to the current list and move lIndex.\\n\\n[ [abc, [xy]] , def, [qqq] ]\\nni.add(myDeserialize(\"[abc, [xy]]\"));\\nni.add(myDeserialize(\"def\");\\nni.add(myDeserialize(\"[qqq]\");\\n\\n\\n\\n    public NestedInteger deserialize(String s) {\\n        if (s.length() == 0)    return new NestedInteger();\\n        return myDeserialize(s, 0, s.length()-1);\\n    }\\n    \\n    private NestedInteger myDeserialize(String s, int start, int end) {\\n        if (s.charAt(start) != '[') \\n            return new NestedInteger(Integer.valueOf(s.substring(start, end+1)));\\n\\n        NestedInteger ni = new NestedInteger();\\n        int lvl = 0, lIndex = start+1;\\n \\n        for (int i=start+1 ; i<=end-1 ; ++i) {\\n            char ch = s.charAt(i);\\n            if (ch == '[')  ++lvl;\\n            else if (ch == ']') --lvl; \\n            else if (ch == ',' && lvl == 0) {\\n                ni.add(myDeserialize(s, lIndex, i-1));\\n                lIndex = i + 1;\\n            }\\n        }\\n        if (lIndex <= end-1) {\\n            ni.add(myDeserialize(s, lIndex, end-1));\\n        }\\n        return ni;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 86128,
                "title": "simple-java-solution-beats-98",
                "content": "Basic idea:\\nThe Nested Integer is composed an Integer or a List;\\n\\n- If it is a List (starts with `[`), then for each element of the list, (Integer or nested List) call `deserialize()` and add the result of `deserialize()` to the current NestedInteger.\\n- If it is an Integer, just add it as Nested Integer with single value\\n\\nFor example for the input string `\"[123,456,[788,799,833],[[]],10,[]]\"` the elements to be processed with `deserialize()` will be:\\n```\\ndeserialize(\"[123,456,[788,799,833],[[]],10,[]]\")\\n    deserialize(\"123\")\\n    deserialize(\"456\")\\n    deserialize(\"[788,799,833]\")\\n        deserialize(\"788\")\\n        deserialize(\"799\")\\n        deserialize(\"833\")\\n    deserialize(\"[[]]\")\\n        deserialize(\"[]\")\\n    deserialize(\"10\")\\n    deserialize(\"[]\")\\n```\\nHere is the code implementing this idea:\\n```\\npublic NestedInteger deserialize(String s) {\\n\\tif(s.length()==0 || s.equals(\"[]\")) return new NestedInteger();\\n\\tNestedInteger ni = new NestedInteger();\\n\\tchar[] chars = s.toCharArray();\\n\\tif(chars[0]=='[') {\\n\\t\\tint elementStart = 1;\\n\\t\\twhile(elementStart<chars.length) {\\n\\t\\t\\tint elementEnd = searchForElementEnd(chars,elementStart);\\n\\t\\t\\tString nextListElement = new String(chars,elementStart,elementEnd-elementStart);\\n\\t\\t\\tni.add(deserialize(nextListElement));\\n\\t\\t\\telementStart=elementEnd+1;\\n\\t\\t}\\n\\t} else ni.setInteger(new Integer(new String(chars)));\\n\\treturn ni;\\n}\\n\\nprivate int searchForElementEnd(char[] chars, int elementStart) {\\n\\tint countBrackets = 0;\\n\\tint i=elementStart;\\n\\tif(chars[i++]=='[') countBrackets++;\\n\\twhile(i<chars.length) {\\n\\t\\tchar nextChar = chars[i];\\n\\t\\tif(nextChar==']') {\\n\\t\\t\\tcountBrackets--;\\n\\t\\t\\tif(countBrackets<=0) {\\n\\t\\t\\t\\tif(countBrackets==0) i++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(nextChar=='[') countBrackets++;\\n\\t\\telse if(nextChar==',' && countBrackets==0) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\ti++;\\n\\t}\\n\\treturn i;\\n}\\n```\\n\\n![0_1481379516757_Screen Shot 2016-12-10 at 13.32.20.png](/uploads/files/1481379519343-screen-shot-2016-12-10-at-13.32.20.png)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\ndeserialize(\"[123,456,[788,799,833],[[]],10,[]]\")\\n    deserialize(\"123\")\\n    deserialize(\"456\")\\n    deserialize(\"[788,799,833]\")\\n        deserialize(\"788\")\\n        deserialize(\"799\")\\n        deserialize(\"833\")\\n    deserialize(\"[[]]\")\\n        deserialize(\"[]\")\\n    deserialize(\"10\")\\n    deserialize(\"[]\")\\n```\n```\\npublic NestedInteger deserialize(String s) {\\n\\tif(s.length()==0 || s.equals(\"[]\")) return new NestedInteger();\\n\\tNestedInteger ni = new NestedInteger();\\n\\tchar[] chars = s.toCharArray();\\n\\tif(chars[0]=='[') {\\n\\t\\tint elementStart = 1;\\n\\t\\twhile(elementStart<chars.length) {\\n\\t\\t\\tint elementEnd = searchForElementEnd(chars,elementStart);\\n\\t\\t\\tString nextListElement = new String(chars,elementStart,elementEnd-elementStart);\\n\\t\\t\\tni.add(deserialize(nextListElement));\\n\\t\\t\\telementStart=elementEnd+1;\\n\\t\\t}\\n\\t} else ni.setInteger(new Integer(new String(chars)));\\n\\treturn ni;\\n}\\n\\nprivate int searchForElementEnd(char[] chars, int elementStart) {\\n\\tint countBrackets = 0;\\n\\tint i=elementStart;\\n\\tif(chars[i++]=='[') countBrackets++;\\n\\twhile(i<chars.length) {\\n\\t\\tchar nextChar = chars[i];\\n\\t\\tif(nextChar==']') {\\n\\t\\t\\tcountBrackets--;\\n\\t\\t\\tif(countBrackets<=0) {\\n\\t\\t\\t\\tif(countBrackets==0) i++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(nextChar=='[') countBrackets++;\\n\\t\\telse if(nextChar==',' && countBrackets==0) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\ti++;\\n\\t}\\n\\treturn i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2047371,
                "title": "python-recursion-1-pass-simplest-solution",
                "content": "```\\nclass Solution:\\n    def parseNumber(self, s, idx, isNegative=False):\\n        num = 0\\n        while idx < len(s) and s[idx].isdigit():\\n            num = num*10 + int(s[idx])\\n            idx += 1\\n        if isNegative:\\n            num = -num\\n        return NestedInteger(num), idx\\n    \\n    def parseList(self, s, idx):\\n        obj = NestedInteger()\\n        while idx < len(s) and s[idx] != \\']\\':\\n            if s[idx].isdigit():\\n                data, idx = self.parseNumber(s, idx)\\n                obj.add(data)\\n            elif s[idx] == \\'-\\':\\n                data, idx = self.parseNumber(s, idx+1, True)\\n                obj.add(data)\\n            elif s[idx] == \\'[\\':\\n                data, idx = self.parseList(s, idx+1)\\n                obj.add(data)\\n            else:\\n                idx += 1\\n\\n        return obj, idx+1\\n    \\n    def deserialize(self, s: str) -> NestedInteger:\\n        if s[0] != \\'[\\':\\n            if s[0] == \\'-\\':\\n                nestedInteger, _ = self.parseNumber(s, 1, True)\\n            else:\\n                nestedInteger, _ = self.parseNumber(s, 0)\\n        else:\\n            nestedInteger, _ = self.parseList(s, 1)        \\n\\n        return nestedInteger\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def parseNumber(self, s, idx, isNegative=False):\\n        num = 0\\n        while idx < len(s) and s[idx].isdigit():\\n            num = num*10 + int(s[idx])\\n            idx += 1\\n        if isNegative:\\n            num = -num\\n        return NestedInteger(num), idx\\n    \\n    def parseList(self, s, idx):\\n        obj = NestedInteger()\\n        while idx < len(s) and s[idx] != \\']\\':\\n            if s[idx].isdigit():\\n                data, idx = self.parseNumber(s, idx)\\n                obj.add(data)\\n            elif s[idx] == \\'-\\':\\n                data, idx = self.parseNumber(s, idx+1, True)\\n                obj.add(data)\\n            elif s[idx] == \\'[\\':\\n                data, idx = self.parseList(s, idx+1)\\n                obj.add(data)\\n            else:\\n                idx += 1\\n\\n        return obj, idx+1\\n    \\n    def deserialize(self, s: str) -> NestedInteger:\\n        if s[0] != \\'[\\':\\n            if s[0] == \\'-\\':\\n                nestedInteger, _ = self.parseNumber(s, 1, True)\\n            else:\\n                nestedInteger, _ = self.parseNumber(s, 0)\\n        else:\\n            nestedInteger, _ = self.parseList(s, 1)        \\n\\n        return nestedInteger\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86221,
                "title": "easy-python-recursive-solution-and-stack-solution-please-be-careful-about-time-complexity",
                "content": "```\\nclass Solution(object):\\n    def deserialize(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: NestedInteger\\n        \"\"\"\\n        if s[0] != '[':\\n            return NestedInteger(int(s))\\n        nested = NestedInteger()\\n        numP, start = 0, 1\\n        for i in range(1, len(s)):\\n            if (numP == 0 and s[i] == ',') or i == len(s) - 1:\\n                # make sure it is not an empty string\\n                if start < i:\\n                    nested.add(self.deserialize(s[start:i]))\\n                start = i + 1\\n            elif s[i] == '[':\\n                numP += 1\\n            elif s[i] == ']':\\n                numP -= 1\\n        return nested\\n```\\nI was a bit confused by add() and setInteger() both for adding integer element. I think add() can do what setInteger does.\\n\\n\\nPlease note that this is not a very fast solution since it requires scanning elements multiple times according to this element's depth.\\n\\nUsing stack would use space as a trade-off for multiple scanning.\\n\\nMy stack solution, as many people have similar solutions:\\n```\\nclass Solution(object):\\n    def deserialize(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: NestedInteger\\n        \"\"\"\\n        stack, start = [], -1\\n        for i, c in enumerate(s):\\n            if c == '[':\\n                stack.append(NestedInteger())\\n            elif c == ']':\\n                # for last ], it is possible that there is only one NestedInteger\\n                if len(stack) > 1:\\n                    t = stack.pop()\\n                    stack[-1].add(t)\\n            elif c.isdigit() or c == '-':\\n                if start == -1:\\n                    start = i\\n                if i == len(s) - 1 or not s[i + 1].isdigit():\\n                    if stack:\\n                        stack[-1].add(NestedInteger(int(s[start:i + 1])))\\n                    else:\\n                        stack.append(NestedInteger(int(s[start:i + 1])))\\n                    start = -1\\n        return stack.pop()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def deserialize(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: NestedInteger\\n        \"\"\"\\n        if s[0] != '[':\\n            return NestedInteger(int(s))\\n        nested = NestedInteger()\\n        numP, start = 0, 1\\n        for i in range(1, len(s)):\\n            if (numP == 0 and s[i] == ',') or i == len(s) - 1:\\n                # make sure it is not an empty string\\n                if start < i:\\n                    nested.add(self.deserialize(s[start:i]))\\n                start = i + 1\\n            elif s[i] == '[':\\n                numP += 1\\n            elif s[i] == ']':\\n                numP -= 1\\n        return nested\\n```\n```\\nclass Solution(object):\\n    def deserialize(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: NestedInteger\\n        \"\"\"\\n        stack, start = [], -1\\n        for i, c in enumerate(s):\\n            if c == '[':\\n                stack.append(NestedInteger())\\n            elif c == ']':\\n                # for last ], it is possible that there is only one NestedInteger\\n                if len(stack) > 1:\\n                    t = stack.pop()\\n                    stack[-1].add(t)\\n            elif c.isdigit() or c == '-':\\n                if start == -1:\\n                    start = i\\n                if i == len(s) - 1 or not s[i + 1].isdigit():\\n                    if stack:\\n                        stack[-1].add(NestedInteger(int(s[start:i + 1])))\\n                    else:\\n                        stack.append(NestedInteger(int(s[start:i + 1])))\\n                    start = -1\\n        return stack.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160756,
                "title": "python-solution-just-6-lines-easy-to-understand-approach-using-eval",
                "content": "```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n\\t\\t# eval(\"[1,2,3]\") => [1,2,3] it\\'ll convert string of list to list\\n        return self.find(eval(s))\\n    \\n    def find(self,s):\\n\\t\\t# if our elment s is type of int we\\'ll return new NestedInteger of that value\\n        if type(s) == type(1):\\n            return NestedInteger(s)\\n\\t\\t\\t\\n\\t\\t# create a new object that will contain our elements of type NestedInteger\\n        n = NestedInteger()\\n        \\n\\t\\tfor x in s:\\n\\t\\t\\t# traverse  the list s and recursively find all nestedIntegers and add them in container n\\n\\t\\t\\t# recursion will handle multiple nested lists\\n            n.add(self.find(x))\\n        return n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n\\t\\t# eval(\"[1,2,3]\") => [1,2,3] it\\'ll convert string of list to list\\n        return self.find(eval(s))\\n    \\n    def find(self,s):\\n\\t\\t# if our elment s is type of int we\\'ll return new NestedInteger of that value\\n        if type(s) == type(1):\\n            return NestedInteger(s)\\n\\t\\t\\t\\n\\t\\t# create a new object that will contain our elements of type NestedInteger\\n        n = NestedInteger()\\n        \\n\\t\\tfor x in s:\\n\\t\\t\\t# traverse  the list s and recursively find all nestedIntegers and add them in container n\\n\\t\\t\\t# recursion will handle multiple nested lists\\n            n.add(self.find(x))\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86137,
                "title": "python-recursive-solution",
                "content": "A python recursive solution:\\nFirst, determine the type of parsing: two scenarios can be met:\\n1. the first character of a given string is '[': to parse a list.\\nWhenever '[' is met, start parsing a list and end when ']' is met.\\n2. otherwise: to parse a simple integer.\\nThe recursive function should return the parsed result and the ending index of the subproblem or equivalently the start index of the next parsing task.\\n```\\ndef deserialize(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: NestedInteger\\n        \"\"\"\\n        parsed, _ = self.helper(s, 0)\\n        return parsed\\n\\n    def helper(self, s, ind):\\n        i = ind\\n        # scenario 1: to parse a nested list\\n        if s[i] == '[':\\n            parsed = NestedInteger()\\n            i += 1\\n            while i < len(s):\\n                if s[i] == ']':\\n                    return parsed, i+1\\n                if s[i] == '[':\\n                    nested, i = self.helper(s, i)\\n                    parsed.add(nested)\\n                elif s[i] in '-0123456789':\\n                    ele, i = self.helper(s, i)\\n                    parsed.add(ele)\\n               # put this case at the bottom so that we don't need list all the spaces (e.g. space, tab) or comma separator\\n                else:\\n                    i += 1\\n       # scenario 2: to parse an integer\\n        else:\\n            temp = i\\n            while temp < len(s) and s[temp] in '-0123456789':\\n                temp += 1\\n            return NestedInteger(int(s[i:temp])), temp\\n```",
                "solutionTags": [],
                "code": "```\\ndef deserialize(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: NestedInteger\\n        \"\"\"\\n        parsed, _ = self.helper(s, 0)\\n        return parsed\\n\\n    def helper(self, s, ind):\\n        i = ind\\n        # scenario 1: to parse a nested list\\n        if s[i] == '[':\\n            parsed = NestedInteger()\\n            i += 1\\n            while i < len(s):\\n                if s[i] == ']':\\n                    return parsed, i+1\\n                if s[i] == '[':\\n                    nested, i = self.helper(s, i)\\n                    parsed.add(nested)\\n                elif s[i] in '-0123456789':\\n                    ele, i = self.helper(s, i)\\n                    parsed.add(ele)\\n               # put this case at the bottom so that we don't need list all the spaces (e.g. space, tab) or comma separator\\n                else:\\n                    i += 1\\n       # scenario 2: to parse an integer\\n        else:\\n            temp = i\\n            while temp < len(s) and s[temp] in '-0123456789':\\n                temp += 1\\n            return NestedInteger(int(s[i:temp])), temp\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2672238,
                "title": "c-easy-to-understand-short",
                "content": "\\n# Code\\n```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Constructor initializes an empty nested list.\\n *     NestedInteger();\\n *\\n *     // Constructor initializes a single integer.\\n *     NestedInteger(int value);\\n *\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Set this NestedInteger to hold a single integer.\\n *     void setInteger(int value);\\n *\\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\\n *     void add(const NestedInteger &ni);\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        function<bool(char)> isnumber = [](char c){ return (c == \\'-\\') || isdigit(c); };\\n        \\n        stack<NestedInteger> stk;\\n        stk.push(NestedInteger());\\n        \\n        for (auto it = s.begin(); it != s.end();) {\\n            const char & c = (*it);\\n            if (isnumber(c)) {\\n                auto it2 = find_if_not(it, s.end(), isnumber);\\n                int val = stoi(string(it, it2));\\n                stk.top().add(NestedInteger(val));\\n                it = it2;\\n            }\\n            else {\\n                if (c == \\'[\\') {\\n                    stk.push(NestedInteger());\\n                }\\n                else if (c == \\']\\') {\\n                    NestedInteger ni = stk.top();\\n                    stk.pop();\\n                    stk.top().add(ni);\\n                }\\n                ++it;\\n            }\\n        }\\n        \\n        NestedInteger result = stk.top().getList().front();\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Constructor initializes an empty nested list.\\n *     NestedInteger();\\n *\\n *     // Constructor initializes a single integer.\\n *     NestedInteger(int value);\\n *\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Set this NestedInteger to hold a single integer.\\n *     void setInteger(int value);\\n *\\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\\n *     void add(const NestedInteger &ni);\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        function<bool(char)> isnumber = [](char c){ return (c == \\'-\\') || isdigit(c); };\\n        \\n        stack<NestedInteger> stk;\\n        stk.push(NestedInteger());\\n        \\n        for (auto it = s.begin(); it != s.end();) {\\n            const char & c = (*it);\\n            if (isnumber(c)) {\\n                auto it2 = find_if_not(it, s.end(), isnumber);\\n                int val = stoi(string(it, it2));\\n                stk.top().add(NestedInteger(val));\\n                it = it2;\\n            }\\n            else {\\n                if (c == \\'[\\') {\\n                    stk.push(NestedInteger());\\n                }\\n                else if (c == \\']\\') {\\n                    NestedInteger ni = stk.top();\\n                    stk.pop();\\n                    stk.top().add(ni);\\n                }\\n                ++it;\\n            }\\n        }\\n        \\n        NestedInteger result = stk.top().getList().front();\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947648,
                "title": "java-2-different-stack-solutions-explained",
                "content": "There are two ways we can make stack solution works and they work rather differently. The first way is slightly more optimal but they both run in O(n).\\n1. Initialize a new NestedList at the start and set it to `cur`\\n\\n2. Everytime we encounter `\\'[\\'`, we push `cur` onto the stack and set `cur` to be a new NestedList\\n\\n3. Everytime we encounter `-` or a `digit`, we parse the number and add it as a NestedInteger to `cur`\\n\\n4. Everytime we encounter `\\']\\'`, we end the `cur` NestedList by adding it to the top NestedList on the stack and set `cur` to that top NestedList and pop it.\\n\\n5. In the end, we return the first NestedList in `cur` because we\\'d created an empty NestedList at step 1.\\n\\nThis solution runs in 5ms.\\n```Java\\n    public NestedInteger deserialize(String s) {\\n        Deque<NestedInteger> stack = new ArrayDeque<>();\\n        NestedInteger cur = new NestedInteger();\\n        for (int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            if (ch == \\'[\\'){\\n                stack.push(cur);\\n                cur = new NestedInteger();\\n            }else if (ch == \\'-\\' || Character.isDigit(ch)){\\n                int j = i + 1;\\n                while(j < s.length() && Character.isDigit(s.charAt(j))){\\n                    ++j;\\n                }\\n                cur.add(parse(i, j, s));\\n                i = j - 1;\\n            }else if (ch == \\']\\'){\\n                stack.peek().add(cur);\\n                cur = stack.pop();\\n            }\\n        }\\n        return cur.getList().get(0);\\n    }\\n\\n    private NestedInteger parse(int lo, int hi, String s){\\n        return new NestedInteger(Integer.parseInt(s.substring(lo, hi)));\\n    }\\n```\\n\\nSecond way to make stack work is this:\\n1. Each time we encounter `\\'[\\'`, we push NestedInteger_MAX_Integer to the stack to note this is a start of some NestedList.\\n\\n2. Each time we encounter `-` or a `digit`, we parse the number and push it onto the stack as a NestedInteger.\\n\\n3. Each time we encounter `\\']\\'`, we create a new stack, pop of all the elements in the stack to that new stack until we are at a NestedInteger.MAX_INTEGER. Then we create a new NestedList and pop off all the elements in the new stack to that and store it back to the stack.\\n\\n4. In the end, we return the first element on the stack. There is no edge case like the first approach.\\n\\nThis runs run 7ms, which is slightly slower than the 1st approach above, because there are more popping and pushing operations.\\n\\n\\n\\n```Java\\n        Deque<NestedInteger> stack = new ArrayDeque<>();\\n        for (int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            if (ch == \\'[\\'){\\n                stack.push(new NestedInteger(Integer.MAX_VALUE));\\n            }else if (ch == \\'-\\' || Character.isDigit(ch)){\\n                int j = i + 1;\\n                while(j < s.length() && Character.isDigit(s.charAt(j))){\\n                    ++j;\\n                }\\n                stack.push(parse(i, j, s));\\n                i = j - 1;\\n            }else if (ch == \\']\\'){\\n                Deque<NestedInteger> save = new ArrayDeque<>();\\n                while(!stack.peek().isInteger() || Integer.MAX_VALUE != stack.peek().getInteger()){\\n                    save.push(stack.pop());\\n                }\\n                stack.pop();\\n                NestedInteger cur = new NestedInteger();\\n                while(!save.isEmpty()){\\n                    cur.add(save.pop());\\n                }\\n                stack.push(cur);\\n            }\\n        }\\n        return stack.peek();\\n    }\\n\\n    private NestedInteger parse(int lo, int hi, String s){\\n        return new NestedInteger(Integer.parseInt(s.substring(lo, hi)));\\n    }\\n```\\n**Which approach do you like more? Comment below :)**",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```Java\\n    public NestedInteger deserialize(String s) {\\n        Deque<NestedInteger> stack = new ArrayDeque<>();\\n        NestedInteger cur = new NestedInteger();\\n        for (int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            if (ch == \\'[\\'){\\n                stack.push(cur);\\n                cur = new NestedInteger();\\n            }else if (ch == \\'-\\' || Character.isDigit(ch)){\\n                int j = i + 1;\\n                while(j < s.length() && Character.isDigit(s.charAt(j))){\\n                    ++j;\\n                }\\n                cur.add(parse(i, j, s));\\n                i = j - 1;\\n            }else if (ch == \\']\\'){\\n                stack.peek().add(cur);\\n                cur = stack.pop();\\n            }\\n        }\\n        return cur.getList().get(0);\\n    }\\n\\n    private NestedInteger parse(int lo, int hi, String s){\\n        return new NestedInteger(Integer.parseInt(s.substring(lo, hi)));\\n    }\\n```\n```Java\\n        Deque<NestedInteger> stack = new ArrayDeque<>();\\n        for (int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            if (ch == \\'[\\'){\\n                stack.push(new NestedInteger(Integer.MAX_VALUE));\\n            }else if (ch == \\'-\\' || Character.isDigit(ch)){\\n                int j = i + 1;\\n                while(j < s.length() && Character.isDigit(s.charAt(j))){\\n                    ++j;\\n                }\\n                stack.push(parse(i, j, s));\\n                i = j - 1;\\n            }else if (ch == \\']\\'){\\n                Deque<NestedInteger> save = new ArrayDeque<>();\\n                while(!stack.peek().isInteger() || Integer.MAX_VALUE != stack.peek().getInteger()){\\n                    save.push(stack.pop());\\n                }\\n                stack.pop();\\n                NestedInteger cur = new NestedInteger();\\n                while(!save.isEmpty()){\\n                    cur.add(save.pop());\\n                }\\n                stack.push(cur);\\n            }\\n        }\\n        return stack.peek();\\n    }\\n\\n    private NestedInteger parse(int lo, int hi, String s){\\n        return new NestedInteger(Integer.parseInt(s.substring(lo, hi)));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578496,
                "title": "python-8-lines-of-code-built-in-json-parser",
                "content": "# Formal background.\\n\\nThe language we have to parse isn\\'t regular (https://en.wikipedia.org/wiki/Regular_language), so we can\\'t use a regex. Rather, the language is context-free (https://en.wikipedia.org/wiki/Context-free_language). As we don\\'t have access to a Context-Free Grammar parser module in python, we would have to parse the string ourselves using a while loop, which is a boring and tedious task that usually yields ugly code no matter how hard you try. Luckily, we can cheat our way out of this: we can use python\\'s built-in json parser, because the grammar we have to parse is a subset of json :). As json is an LL(1) grammar (https://en.wikipedia.org/wiki/LL_parser), it can be parsed in linear time and space, which is great. I don\\'t know with absolute certainty that Python\\'s built-in json parser actually runs in linear time and space, but it would be very strange if that weren\\'t the case.\\n# Code\\n\\n```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        def toNI(xs) -> NestedInteger:\\n            # Case where xs is a single integer.\\n            if isinstance(xs, int):\\n                return NestedInteger(xs)\\n            # Case where xs is a list of integers and/or lists.\\n            assert(isinstance(xs, list))\\n            n = NestedInteger()\\n            for x in xs:\\n                # For every element in the list, convert it to a NestedInteger\\n                # and add it to `n`.\\n                n.add(toNI(x))\\n            return n\\n\\t\\t\\t\\n        return toNI(json.loads(s))\\n```\\n\\n# Explanation of code\\n\\n`json.loads` parses the string and returns a python object. As we\\'re parsing lists and ints here, `json.loads` will return an object that is either an int, or a list that contains 1 or more ints/lists. We can therefore convert the object returned by `json.loads` to a `NestedInteger` very easily, by using a small recursive function that uses some type checking to know whether we are dealing with an int or list at any given time.\\n\\n# Complexity\\n\\nAs json is an LL(1) grammar (https://en.wikipedia.org/wiki/LL_parser),  it can be parsed in `O(n)` time and space. Our `toNI` function evaluates every int/list exactly once, and therefore also takes `O(n)` time and space.\\n\\nAll in all, comments and assertions excluded, this solution is 8 LOC and super easy to write. Top 93% speed, top 74% memory.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        def toNI(xs) -> NestedInteger:\\n            # Case where xs is a single integer.\\n            if isinstance(xs, int):\\n                return NestedInteger(xs)\\n            # Case where xs is a list of integers and/or lists.\\n            assert(isinstance(xs, list))\\n            n = NestedInteger()\\n            for x in xs:\\n                # For every element in the list, convert it to a NestedInteger\\n                # and add it to `n`.\\n                n.add(toNI(x))\\n            return n\\n\\t\\t\\t\\n        return toNI(json.loads(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488504,
                "title": "c-stack-concise",
                "content": "```\\nNestedInteger deserialize(string s) {\\n   if(s[0] != \\'[\\') return NestedInteger(stoi(s));\\n   \\n   stack<NestedInteger> stk;\\n   string num = \"\";\\n   for(char c: s) {\\n       if(c == \\'[\\') {\\n           stk.push(NestedInteger());\\n       }\\n       else if(c == \\']\\' || c == \\',\\') {\\n           if(num != \"\") {\\n               stk.top().add(NestedInteger(stoi(num)));\\n               num = \"\";\\n           }\\n           \\n           if(stk.size() >= 2 && c == \\']\\') {\\n               NestedInteger ni = stk.top(); stk.pop();\\n               stk.top().add(ni);    \\n           }\\n       }\\n       else num.push_back(c);\\n   }\\n   \\n   return stk.top();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nNestedInteger deserialize(string s) {\\n   if(s[0] != \\'[\\') return NestedInteger(stoi(s));\\n   \\n   stack<NestedInteger> stk;\\n   string num = \"\";\\n   for(char c: s) {\\n       if(c == \\'[\\') {\\n           stk.push(NestedInteger());\\n       }\\n       else if(c == \\']\\' || c == \\',\\') {\\n           if(num != \"\") {\\n               stk.top().add(NestedInteger(stoi(num)));\\n               num = \"\";\\n           }\\n           \\n           if(stk.size() >= 2 && c == \\']\\') {\\n               NestedInteger ni = stk.top(); stk.pop();\\n               stk.top().add(ni);    \\n           }\\n       }\\n       else num.push_back(c);\\n   }\\n   \\n   return stk.top();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 793482,
                "title": "go-0ms",
                "content": "```\\nfunc deserialize(s string) *NestedInteger {\\n    \\n    stack := []*NestedInteger{}\\n    \\n    i := 0\\n    for i < len(s) {\\n        switch {\\n            case s[i] == \\'[\\':\\n            stack = append(stack, &NestedInteger{})\\n            \\n            case s[i] == \\']\\':\\n            if len(stack) == 1 {\\n                break\\n            } else {\\n                stack[len(stack) - 2].Add(*stack[len(stack) - 1])\\n                stack = stack[:len(stack) - 1]\\n            }\\n            \\n            case (s[i] >= \\'0\\' && s[i] <= \\'9\\') || s[i] == \\'-\\' :\\n                sign := 1\\n                if s[i] == \\'-\\' {\\n                    sign = -1\\n                    i++\\n                }\\n                \\n                num := 0\\n                for i < len(s) && s[i] >= \\'0\\' && s[i] <= \\'9\\'{\\n                        num = num * 10 + int(s[i] - \\'0\\')\\n                        i++\\n                    }\\n                \\n                elem := &NestedInteger{}\\n                elem.SetInteger(sign * num)\\n            \\n                if len(stack) == 0 {\\n                    return elem\\n                }\\n                stack[len(stack) - 1].Add(*elem)\\n                i--\\n        }\\n        i++\\n    }\\n    \\n    return stack[0]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc deserialize(s string) *NestedInteger {\\n    \\n    stack := []*NestedInteger{}\\n    \\n    i := 0\\n    for i < len(s) {\\n        switch {\\n            case s[i] == \\'[\\':\\n            stack = append(stack, &NestedInteger{})\\n            \\n            case s[i] == \\']\\':\\n            if len(stack) == 1 {\\n                break\\n            } else {\\n                stack[len(stack) - 2].Add(*stack[len(stack) - 1])\\n                stack = stack[:len(stack) - 1]\\n            }\\n            \\n            case (s[i] >= \\'0\\' && s[i] <= \\'9\\') || s[i] == \\'-\\' :\\n                sign := 1\\n                if s[i] == \\'-\\' {\\n                    sign = -1\\n                    i++\\n                }\\n                \\n                num := 0\\n                for i < len(s) && s[i] >= \\'0\\' && s[i] <= \\'9\\'{\\n                        num = num * 10 + int(s[i] - \\'0\\')\\n                        i++\\n                    }\\n                \\n                elem := &NestedInteger{}\\n                elem.SetInteger(sign * num)\\n            \\n                if len(stack) == 0 {\\n                    return elem\\n                }\\n                stack[len(stack) - 1].Add(*elem)\\n                i--\\n        }\\n        i++\\n    }\\n    \\n    return stack[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 114184,
                "title": "recursive-solution-but-clean-and-simple-code-in-c",
                "content": "```\\nstruct NestedInteger* deserializeUtil(char** s) {\\n    struct NestedInteger *ni = NestedIntegerInit(), *num_ni = NULL;\\n    char *end = NULL;\\n    \\n    if(**s != '['){\\n        NestedIntegerSetInteger(ni, strtoul(*s, NULL, 0));\\n        return ni;\\n    }\\n    \\n    if(**s == '[') (*s)++;\\n    \\n    while(**s != ']'){\\n        if(**s == ',') (*s)++;\\n        else if(**s == '[') NestedIntegerAdd(ni, deserializeUtil(s));\\n        else {\\n            num_ni = NestedIntegerInit();\\n            NestedIntegerSetInteger(num_ni, strtol(*s, &end, 10));\\n            NestedIntegerAdd(ni, num_ni);\\n            *s = end;//http://en.cppreference.com/w/c/string/byte/strtol\\n        }\\n    }\\n\\n    if(**s == ']') (*s)++;\\n    \\n    return ni;\\n}\\n\\nstruct NestedInteger* deserialize(char* s) {\\n    return deserializeUtil(&s);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct NestedInteger* deserializeUtil(char** s) {\\n    struct NestedInteger *ni = NestedIntegerInit(), *num_ni = NULL;\\n    char *end = NULL;\\n    \\n    if(**s != '['){\\n        NestedIntegerSetInteger(ni, strtoul(*s, NULL, 0));\\n        return ni;\\n    }\\n    \\n    if(**s == '[') (*s)++;\\n    \\n    while(**s != ']'){\\n        if(**s == ',') (*s)++;\\n        else if(**s == '[') NestedIntegerAdd(ni, deserializeUtil(s));\\n        else {\\n            num_ni = NestedIntegerInit();\\n            NestedIntegerSetInteger(num_ni, strtol(*s, &end, 10));\\n            NestedIntegerAdd(ni, num_ni);\\n            *s = end;//http://en.cppreference.com/w/c/string/byte/strtol\\n        }\\n    }\\n\\n    if(**s == ']') (*s)++;\\n    \\n    return ni;\\n}\\n\\nstruct NestedInteger* deserialize(char* s) {\\n    return deserializeUtil(&s);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86152,
                "title": "clean-iterative-java-solution-using-stack",
                "content": "```\\npublic class Solution {\\n    public NestedInteger deserialize(String s) {\\n        String[] tokens = s.split(\",\");\\n        Stack<NestedInteger> stack = new Stack();\\n        NestedInteger root = new NestedInteger();\\n        stack.push(root);\\n        \\n        for (String token: tokens) {\\n            int start = 0;\\n            int end = token.length();\\n            \\n            while (token.charAt(start) == '[') {\\n                stack.push(new NestedInteger());\\n                start++;\\n            }\\n            \\n            NestedInteger topMost = stack.peek();\\n            \\n            while (token.charAt(end - 1) == ']') {\\n                NestedInteger prevList = stack.pop();\\n                stack.peek().add(prevList);\\n                end--;\\n            }\\n            \\n            if (start < end) {\\n                NestedInteger curInteger = new NestedInteger(Integer.parseInt(token.substring(start, end)));\\n                topMost.add(curInteger);    \\n            }\\n        }\\n        \\n        return root.getList().get(0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public NestedInteger deserialize(String s) {\\n        String[] tokens = s.split(\",\");\\n        Stack<NestedInteger> stack = new Stack();\\n        NestedInteger root = new NestedInteger();\\n        stack.push(root);\\n        \\n        for (String token: tokens) {\\n            int start = 0;\\n            int end = token.length();\\n            \\n            while (token.charAt(start) == '[') {\\n                stack.push(new NestedInteger());\\n                start++;\\n            }\\n            \\n            NestedInteger topMost = stack.peek();\\n            \\n            while (token.charAt(end - 1) == ']') {\\n                NestedInteger prevList = stack.pop();\\n                stack.peek().add(prevList);\\n                end--;\\n            }\\n            \\n            if (start < end) {\\n                NestedInteger curInteger = new NestedInteger(Integer.parseInt(token.substring(start, end)));\\n                topMost.add(curInteger);    \\n            }\\n        }\\n        \\n        return root.getList().get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86192,
                "title": "very-short-java-solution",
                "content": "```\\n    public NestedInteger deserialize(String s) {\\n        if (s.contains(\"[\")) {\\n            NestedInteger ans=new NestedInteger();\\n            if (s.length()>2) {\\n                int begin=1;\\n                char[] cs=s.toCharArray();\\n                int count=0;\\n                for (int i = 1; i < s.length()-1; i++) {\\n                    if (cs[i]==','&&count==0) {\\n                        ans.add(deserialize(s.substring(begin,i)));\\n                        begin=i+1;\\n                    }\\n                    if (cs[i]=='['||cs[i]==']') {  //ascii code '['->91 ']'->93\\n                        count+=(92-cs[i]);\\n                    }\\n                }\\n                ans.add(deserialize(s.substring(begin,s.length()-1)));\\n            }\\n            return ans;\\n        }\\n        return new NestedInteger(Integer.valueOf(s));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    public NestedInteger deserialize(String s) {\\n        if (s.contains(\"[\")) {\\n            NestedInteger ans=new NestedInteger();\\n            if (s.length()>2) {\\n                int begin=1;\\n                char[] cs=s.toCharArray();\\n                int count=0;\\n                for (int i = 1; i < s.length()-1; i++) {\\n                    if (cs[i]==','&&count==0) {\\n                        ans.add(deserialize(s.substring(begin,i)));\\n                        begin=i+1;\\n                    }\\n                    if (cs[i]=='['||cs[i]==']') {  //ascii code '['->91 ']'->93\\n                        count+=(92-cs[i]);\\n                    }\\n                }\\n                ans.add(deserialize(s.substring(begin,s.length()-1)));\\n            }\\n            return ans;\\n        }\\n        return new NestedInteger(Integer.valueOf(s));\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86188,
                "title": "java-iterative-and-recursive-including-one-pass-solution",
                "content": "Both are straight forward.\\n\\n```\\n    public NestedInteger deserialize(String s) {\\n        if (s.charAt(0) != '[') return new NestedInteger(Integer.parseInt(s));\\n        NestedInteger cur = new NestedInteger();\\n        Stack<NestedInteger> stack = new Stack<>();\\n        for (int i = 1, start = 1; i < s.length(); ++i) {\\n            if (s.charAt(i) == '[') {\\n                stack.push(cur);\\n                cur = new NestedInteger();\\n                stack.peek().add(cur);\\n                start = i + 1;\\n            } else if (s.charAt(i) == ']' || s.charAt(i) == ',') {\\n                if (start < i) \\n                    cur.add(new NestedInteger(Integer.parseInt(s.substring(start, i))));\\n                start = i + 1;\\n                if (s.charAt(i) == ']' && !stack.empty()) cur = stack.pop();\\n            }\\n        }\\n        return cur;\\n    }\\n```\\n```\\n    public NestedInteger deserialize(String s) {\\n        if (s.charAt(0) != '[') return new NestedInteger(Integer.parseInt(s));\\n        NestedInteger ans = new NestedInteger();\\n        int prev = 1;\\n        for (int i = 1, cnt = 0; i < s.length() - 1; ++i) {\\n            if (s.charAt(i) == '[') {\\n                cnt++;\\n            } else if (s.charAt(i) == ']') {\\n                cnt--;\\n            } else if (s.charAt(i) == ',' && cnt == 0) {\\n                ans.add(deserialize(s.substring(prev, i)));\\n                prev = i + 1;\\n            }\\n        }\\n        if (prev < s.length() - 1) // not '[]'\\n            ans.add(deserialize(s.substring(prev, s.length() - 1)));\\n        return ans;\\n    }\\n```\\n\\nOne pass recursive.\\n\\n```\\n    int idx;\\n    public NestedInteger deserialize(String s) {\\n        idx = 0;\\n        return helper(s);\\n    }\\n    NestedInteger helper(String s) {\\n        NestedInteger ans = new NestedInteger();\\n        if (s.charAt(idx) != '[') {\\n            int start = idx;\\n            while (idx < s.length() && s.charAt(idx) != ',' && s.charAt(idx) != ']') ++idx;\\n            ans.setInteger(Integer.parseInt(s.substring(start, idx--)));\\n        } else {\\n            for (++idx; idx < s.length() && s.charAt(idx) != ']'; ++idx)\\n                if (s.charAt(idx) != ',') ans.add(helper(s));\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public NestedInteger deserialize(String s) {\\n        if (s.charAt(0) != '[') return new NestedInteger(Integer.parseInt(s));\\n        NestedInteger cur = new NestedInteger();\\n        Stack<NestedInteger> stack = new Stack<>();\\n        for (int i = 1, start = 1; i < s.length(); ++i) {\\n            if (s.charAt(i) == '[') {\\n                stack.push(cur);\\n                cur = new NestedInteger();\\n                stack.peek().add(cur);\\n                start = i + 1;\\n            } else if (s.charAt(i) == ']' || s.charAt(i) == ',') {\\n                if (start < i) \\n                    cur.add(new NestedInteger(Integer.parseInt(s.substring(start, i))));\\n                start = i + 1;\\n                if (s.charAt(i) == ']' && !stack.empty()) cur = stack.pop();\\n            }\\n        }\\n        return cur;\\n    }\\n```\n```\\n    public NestedInteger deserialize(String s) {\\n        if (s.charAt(0) != '[') return new NestedInteger(Integer.parseInt(s));\\n        NestedInteger ans = new NestedInteger();\\n        int prev = 1;\\n        for (int i = 1, cnt = 0; i < s.length() - 1; ++i) {\\n            if (s.charAt(i) == '[') {\\n                cnt++;\\n            } else if (s.charAt(i) == ']') {\\n                cnt--;\\n            } else if (s.charAt(i) == ',' && cnt == 0) {\\n                ans.add(deserialize(s.substring(prev, i)));\\n                prev = i + 1;\\n            }\\n        }\\n        if (prev < s.length() - 1) // not '[]'\\n            ans.add(deserialize(s.substring(prev, s.length() - 1)));\\n        return ans;\\n    }\\n```\n```\\n    int idx;\\n    public NestedInteger deserialize(String s) {\\n        idx = 0;\\n        return helper(s);\\n    }\\n    NestedInteger helper(String s) {\\n        NestedInteger ans = new NestedInteger();\\n        if (s.charAt(idx) != '[') {\\n            int start = idx;\\n            while (idx < s.length() && s.charAt(idx) != ',' && s.charAt(idx) != ']') ++idx;\\n            ans.setInteger(Integer.parseInt(s.substring(start, idx--)));\\n        } else {\\n            for (++idx; idx < s.length() && s.charAt(idx) != ']'; ++idx)\\n                if (s.charAt(idx) != ',') ans.add(helper(s));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2586689,
                "title": "mini-parser-solution-java",
                "content": "class Solution {\\n  public NestedInteger deserialize(String s) {\\n    if (s.charAt(0) != \\'[\\')\\n      return new NestedInteger(Integer.parseInt(s));\\n\\n    Deque<NestedInteger> stack = new ArrayDeque<>();\\n    int start = 1;\\n\\n    for (int i = 0; i < s.length(); ++i)\\n      switch (s.charAt(i)) {\\n        case \\'[\\':\\n          stack.push(new NestedInteger());\\n          start = i + 1;\\n          break;\\n        case \\',\\':\\n          if (i > start) {\\n            final int num = Integer.parseInt(s.substring(start, i));\\n            stack.peek().add(new NestedInteger(num));\\n          }\\n          start = i + 1;\\n          break;\\n        case \\']\\':\\n          NestedInteger popped = stack.pop();\\n          if (i > start) {\\n            final int num = Integer.parseInt(s.substring(start, i));\\n            popped.add(new NestedInteger(num));\\n          }\\n          if (!stack.isEmpty())\\n            stack.peek().add(popped);\\n          else\\n            return popped;\\n          start = i + 1;\\n          break;\\n      }\\n\\n    throw new IllegalArgumentException();\\n  }\\n}\\n",
                "solutionTags": [
                    "String",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n  public NestedInteger deserialize(String s) {\\n    if (s.charAt(0) != \\'[\\')\\n      return new NestedInteger(Integer.parseInt(s));\\n\\n    Deque<NestedInteger> stack = new ArrayDeque<>();\\n    int start = 1;\\n\\n    for (int i = 0; i < s.length(); ++i)\\n      switch (s.charAt(i)) {\\n        case \\'[\\':\\n          stack.push(new NestedInteger());\\n          start = i + 1;\\n          break;\\n        case \\',\\':\\n          if (i > start) {\\n            final int num = Integer.parseInt(s.substring(start, i));\\n            stack.peek().add(new NestedInteger(num));\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1756343,
                "title": "javascript-easy-dfs-174ms",
                "content": "```\\nconst deserialize = (s) => {\\n    let a = JSON.parse(s);\\n    return dfs(a);\\n};\\n\\nconst dfs = (input) => {\\n    if (Number.isInteger(input)) return new NestedInteger(input); // if (!Array.isArray(input)) return new NestedInteger(input); also works\\n    let l = new NestedInteger();\\n    for (const e of input) l.add(dfs(e));\\n    return l;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nconst deserialize = (s) => {\\n    let a = JSON.parse(s);\\n    return dfs(a);\\n};\\n\\nconst dfs = (input) => {\\n    if (Number.isInteger(input)) return new NestedInteger(input); // if (!Array.isArray(input)) return new NestedInteger(input); also works\\n    let l = new NestedInteger();\\n    for (const e of input) l.add(dfs(e));\\n    return l;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1574693,
                "title": "python-recursive",
                "content": "```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        def search(i, s):\\n            res, j = NestedInteger(), i\\n            while i < len(s):\\n                if s[i].isdigit() or s[i] == \\'-\\':\\n                    i += 1\\n                elif s[i] == \\',\\':\\n                    if j < i:\\n                        res.add(NestedInteger(int(s[j:i])))\\n                    i += 1\\n                    j = i\\n                elif s[i] == \\'[\\':\\n                    _, i = search(i+1, s)\\n                    res.add(_)\\n                    i += 1\\n                    j = i\\n                else:  # \\']\\'\\n                    if j < i:\\n                        res.add(NestedInteger(int(s[j:i])))\\n                        j = i\\n                    return res, i\\n            if j < i:\\n                res.setInteger(int(s[j:i]))\\n            return res, i\\n\\n        return search(s[0] == \\'[\\', s)[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        def search(i, s):\\n            res, j = NestedInteger(), i\\n            while i < len(s):\\n                if s[i].isdigit() or s[i] == \\'-\\':\\n                    i += 1\\n                elif s[i] == \\',\\':\\n                    if j < i:\\n                        res.add(NestedInteger(int(s[j:i])))\\n                    i += 1\\n                    j = i\\n                elif s[i] == \\'[\\':\\n                    _, i = search(i+1, s)\\n                    res.add(_)\\n                    i += 1\\n                    j = i\\n                else:  # \\']\\'\\n                    if j < i:\\n                        res.add(NestedInteger(int(s[j:i])))\\n                        j = i\\n                    return res, i\\n            if j < i:\\n                res.setInteger(int(s[j:i]))\\n            return res, i\\n\\n        return search(s[0] == \\'[\\', s)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533385,
                "title": "java-stack-explanation",
                "content": "```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        if(s.charAt(0) != \\'[\\') return new NestedInteger(Integer.parseInt(s));\\n        \\n        NestedInteger root = new NestedInteger();\\n        Deque<NestedInteger> stack = new ArrayDeque<NestedInteger>();\\n        stack.push(root);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        NestedInteger curr;\\n        \\n        for(int i = 1; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n           \\n            if(c != \\'[\\' && c != \\',\\' && c != \\']\\') {          //if digit, append to sb\\n                sb.append(c);\\n                continue;\\n            }\\n            \\n            if (c == \\'[\\') {                                 // if \\'[\\'   --   1. create new list  and add it to previous list.  2. add this new list to stack.\\n                NestedInteger child = new NestedInteger();\\n                stack.peek().add(child);\\n                stack.push(child);\\n            } else if(c == \\']\\' || c == \\',\\') {              // if \\']\\' or \\',\\'  -- add sb to current list\\n                if(sb.length() != 0) {                     // skip if empty sb\\n                    curr = new NestedInteger(Integer.parseInt(sb.toString()));\\n                    stack.peek().add(curr);\\n                }\\n                \\n                if(c == \\']\\') stack.pop();                  // \\']\\' means end of current list. pop it from queue.\\n                }\\n\\t\\t\\t\\t\\n            sb.setLength(0);                              // clear current sb\\n        }\\n        return root;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public NestedInteger deserialize(String s) {\\n        if(s.charAt(0) != \\'[\\') return new NestedInteger(Integer.parseInt(s));\\n        \\n        NestedInteger root = new NestedInteger();\\n        Deque<NestedInteger> stack = new ArrayDeque<NestedInteger>();\\n        stack.push(root);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        NestedInteger curr;\\n        \\n        for(int i = 1; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n           \\n            if(c != \\'[\\' && c != \\',\\' && c != \\']\\') {          //if digit, append to sb\\n                sb.append(c);\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 875743,
                "title": "python3-a-concise-recursive-solution",
                "content": "\\n```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        if not s: return NestedInteger()\\n        if not s.startswith(\"[\"): return NestedInteger(int(s)) # integer \\n        ans = NestedInteger()\\n        s = s[1:-1] # strip outer \"[\" and \"]\"\\n        if s: \\n            ii = op = 0 \\n            for i in range(len(s)): \\n                if s[i] == \"[\": op += 1\\n                if s[i] == \"]\": op -= 1\\n                if s[i] == \",\" and op == 0: \\n                    ans.add(self.deserialize(s[ii:i]))\\n                    ii = i+1\\n            ans.add(self.deserialize(s[ii:i+1]))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        if not s: return NestedInteger()\\n        if not s.startswith(\"[\"): return NestedInteger(int(s)) # integer \\n        ans = NestedInteger()\\n        s = s[1:-1] # strip outer \"[\" and \"]\"\\n        if s: \\n            ii = op = 0 \\n            for i in range(len(s)): \\n                if s[i] == \"[\": op += 1\\n                if s[i] == \"]\": op -= 1\\n                if s[i] == \",\" and op == 0: \\n                    ans.add(self.deserialize(s[ii:i]))\\n                    ii = i+1\\n            ans.add(self.deserialize(s[ii:i+1]))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 840546,
                "title": "java-stack-solution-easy-to-understand",
                "content": "1 Everything will be pushed to stack, so no extra pointers or references needed (will get messy if there are many pointers)\\n2 If there is a \\'[\\', the nestedInteger will be a list, so just add a list.\\n3 if there is a num, it will be an integer, so get the list from stack, and add the integer to the stack\\n4 if there is a \\']\\', add current list to previous list\\n5 if there is a \\',\\', do nothing\\n\\n```\\npublic NestedInteger deserialize(String s) {\\n        if (s == null) {\\n            return null;\\n        }\\n        if (s.charAt(0) != \\'[\\') {\\n            return new NestedInteger(Integer.parseInt(s));\\n        }\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n        \\n        Stack<NestedInteger> stack = new Stack<>();\\n        int i = 0;\\n        while (i < n) {\\n            if (arr[i] == \\'[\\') {\\n                stack.push(new NestedInteger());\\n            } else if (Character.isDigit(arr[i]) || arr[i] == \\'-\\') {\\n                int num = 0;\\n                int sign = 1;\\n                if (arr[i] == \\'-\\') {\\n                    sign = -1;\\n                    i++;\\n                }\\n                while (i < n && Character.isDigit(arr[i])) {\\n                    num = num * 10 + arr[i] - \\'0\\';\\n                    i++;\\n                }\\n                i--;\\n                stack.peek().getList().add(new NestedInteger(num * sign));      \\n            } else if (arr[i] == \\']\\') {\\n                NestedInteger ni = stack.pop();\\n                if (!stack.isEmpty()) {\\n                    stack.peek().getList().add(ni);\\n                } else {\\n                    return ni;\\n                }\\n            }\\n            i++;\\n        }\\n        \\n        return stack.pop();\\n    }",
                "solutionTags": [],
                "code": "1 Everything will be pushed to stack, so no extra pointers or references needed (will get messy if there are many pointers)\\n2 If there is a \\'[\\', the nestedInteger will be a list, so just add a list.\\n3 if there is a num, it will be an integer, so get the list from stack, and add the integer to the stack\\n4 if there is a \\']\\', add current list to previous list\\n5 if there is a \\',\\', do nothing\\n\\n```\\npublic NestedInteger deserialize(String s) {\\n        if (s == null) {\\n            return null;\\n        }\\n        if (s.charAt(0) != \\'[\\') {\\n            return new NestedInteger(Integer.parseInt(s));\\n        }\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n        \\n        Stack<NestedInteger> stack = new Stack<>();\\n        int i = 0;\\n        while (i < n) {\\n            if (arr[i] == \\'[\\') {\\n                stack.push(new NestedInteger());\\n            } else if (Character.isDigit(arr[i]) || arr[i] == \\'-\\') {\\n                int num = 0;\\n                int sign = 1;\\n                if (arr[i] == \\'-\\') {\\n                    sign = -1;\\n                    i++;\\n                }\\n                while (i < n && Character.isDigit(arr[i])) {\\n                    num = num * 10 + arr[i] - \\'0\\';\\n                    i++;\\n                }\\n                i--;\\n                stack.peek().getList().add(new NestedInteger(num * sign));      \\n            } else if (arr[i] == \\']\\') {\\n                NestedInteger ni = stack.pop();\\n                if (!stack.isEmpty()) {\\n                    stack.peek().getList().add(ni);\\n                } else {\\n                    return ni;\\n                }\\n            }\\n            i++;\\n        }\\n        \\n        return stack.pop();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 804667,
                "title": "swift-simple-sweet-100",
                "content": "```\\nfunc deserialize(_ s: String) -> NestedInteger {\\n\\tif s.first != \"[\" {\\n\\t\\treturn NestedInteger(Int(s))\\n\\t}\\n\\n\\tvar stack = [NestedInteger]()\\n\\tvar result = NestedInteger()\\n\\tstack.append(result)\\n\\tvar curInt = \"\"\\n\\n\\tfor char in s.dropFirst() {\\n\\t\\tif char == \"[\" {\\n\\t\\t\\tvar ni = NestedInteger()\\n\\t\\t\\tstack.last!.add(ni)\\n\\t\\t\\tstack.append(ni)\\n\\t\\t} else if char == \",\" || char == \"]\" {\\n\\t\\t\\t// add the curInt to the last one\\n\\t\\t\\tif !curInt.isEmpty {\\n\\t\\t\\t\\tstack.last!.add(NestedInteger(Int(curInt)))\\n\\t\\t\\t}\\n\\t\\t\\tif char == \"]\" {\\n\\t\\t\\t\\tstack.popLast()!\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurInt = \"\"\\n\\t\\t} else {\\n\\t\\t\\tcurInt += String(char)\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n} \\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc deserialize(_ s: String) -> NestedInteger {\\n\\tif s.first != \"[\" {\\n\\t\\treturn NestedInteger(Int(s))\\n\\t}\\n\\n\\tvar stack = [NestedInteger]()\\n\\tvar result = NestedInteger()\\n\\tstack.append(result)\\n\\tvar curInt = \"\"\\n\\n\\tfor char in s.dropFirst() {\\n\\t\\tif char == \"[\" {\\n\\t\\t\\tvar ni = NestedInteger()\\n\\t\\t\\tstack.last!.add(ni)\\n\\t\\t\\tstack.append(ni)\\n\\t\\t} else if char == \",\" || char == \"]\" {\\n\\t\\t\\t// add the curInt to the last one\\n\\t\\t\\tif !curInt.isEmpty {\\n\\t\\t\\t\\tstack.last!.add(NestedInteger(Int(curInt)))\\n\\t\\t\\t}\\n\\t\\t\\tif char == \"]\" {\\n\\t\\t\\t\\tstack.popLast()!\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurInt = \"\"\\n\\t\\t} else {\\n\\t\\t\\tcurInt += String(char)\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 280205,
                "title": "very-simple-7-line-solution-in-java",
                "content": "There are 2 cases\\n1. list\\n2. number\\n\\nFor the list case, call recursively.\\n\\n```\\npublic NestedInteger deserialize(String s) {\\n\\tNestedInteger ans = new NestedInteger();\\n\\tif (s.charAt(0) == \\'[\\') { // list\\n\\t\\tArrays.stream(s.substring(1, s.length()-1).split(\",\"))\\n\\t\\t\\t  .forEach(a  -> ans.add(deserialize(a)));\\n\\t} else { // number\\n\\t\\tans.setInteger(Integer.parseInt(s));\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic NestedInteger deserialize(String s) {\\n\\tNestedInteger ans = new NestedInteger();\\n\\tif (s.charAt(0) == \\'[\\') { // list\\n\\t\\tArrays.stream(s.substring(1, s.length()-1).split(\",\"))\\n\\t\\t\\t  .forEach(a  -> ans.add(deserialize(a)));\\n\\t} else { // number\\n\\t\\tans.setInteger(Integer.parseInt(s));\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 170215,
                "title": "c-stack-100",
                "content": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Constructor initializes an empty nested list.\\n *     NestedInteger();\\n *\\n *     // Constructor initializes a single integer.\\n *     NestedInteger(int value);\\n *\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Set this NestedInteger to hold a single integer.\\n *     void setInteger(int value);\\n *\\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\\n *     void add(const NestedInteger &ni);\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        int n = s.length();\\n\\n        vector<pair<NestedInteger, bool>> stk;\\n\\n        int i = 0;\\n        int num = 0;\\n        int sign = 1;\\n        while (i < n) {\\n            if (s[i] == \\'[\\') {\\n                stk.push_back(make_pair(NestedInteger(), true));\\n                ++i;\\n            } else if (s[i] == \\'-\\') { // [note]: it\\'s possible the number is negative!!!\\n                sign = -1;\\n                ++i;\\n            } else if (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n                num = 0;\\n                while (i < n && s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n                    num = num * 10 + (s[i] - \\'0\\');\\n                    ++i;\\n                }\\n                stk.push_back(make_pair(NestedInteger(sign * num), false));\\n                sign = 1;\\n            } else if (s[i] == \\',\\') {\\n                ++i;\\n            } else {\\n                vector<NestedInteger> vec;\\n                while (!stk.back().second) {\\n                    vec.push_back(stk.back().first);\\n                    stk.pop_back();\\n                }\\n                auto pr = stk.back();\\n                stk.pop_back();\\n\\n                int nvec = vec.size();\\n                for (int j = nvec - 1; j >= 0; --j) {\\n                    pr.first.add(vec[j]);\\n                }\\n                pr.second = false;\\n                stk.push_back(pr);\\n                ++i;\\n            }\\n        }\\n\\n        return stk.back().first;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Constructor initializes an empty nested list.\\n *     NestedInteger();\\n *\\n *     // Constructor initializes a single integer.\\n *     NestedInteger(int value);\\n *\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Set this NestedInteger to hold a single integer.\\n *     void setInteger(int value);\\n *\\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\\n *     void add(const NestedInteger &ni);\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        int n = s.length();\\n\\n        vector<pair<NestedInteger, bool>> stk;\\n\\n        int i = 0;\\n        int num = 0;\\n        int sign = 1;\\n        while (i < n) {\\n            if (s[i] == \\'[\\') {\\n                stk.push_back(make_pair(NestedInteger(), true));\\n                ++i;\\n            } else if (s[i] == \\'-\\') { // [note]: it\\'s possible the number is negative!!!\\n                sign = -1;\\n                ++i;\\n            } else if (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n                num = 0;\\n                while (i < n && s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n                    num = num * 10 + (s[i] - \\'0\\');\\n                    ++i;\\n                }\\n                stk.push_back(make_pair(NestedInteger(sign * num), false));\\n                sign = 1;\\n            } else if (s[i] == \\',\\') {\\n                ++i;\\n            } else {\\n                vector<NestedInteger> vec;\\n                while (!stk.back().second) {\\n                    vec.push_back(stk.back().first);\\n                    stk.pop_back();\\n                }\\n                auto pr = stk.back();\\n                stk.pop_back();\\n\\n                int nvec = vec.size();\\n                for (int j = nvec - 1; j >= 0; --j) {\\n                    pr.first.add(vec[j]);\\n                }\\n                pr.second = false;\\n                stk.push_back(pr);\\n                ++i;\\n            }\\n        }\\n\\n        return stk.back().first;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86113,
                "title": "java-solution-using-stringtokenizer-and-stack-easy-and-clear-logic",
                "content": "```\\nimport java.util.StringTokenizer;\\npublic class Solution {\\n\\n    public NestedInteger deserialize(String s) {\\n        StringTokenizer tokenizer = new StringTokenizer(s, \"[],\", true);\\n\\n        Stack<NestedInteger> stack = new Stack<>();\\n        stack.push(new NestedInteger()); // a dummy list to simplify init\\n\\n        while (tokenizer.hasMoreTokens()) {\\n            String token = tokenizer.nextToken();\\n            switch (token) {\\n                case \"[\":\\n                    NestedInteger list = new NestedInteger();\\n                    stack.peek().add(list);\\n                    stack.push(list);\\n                    break;\\n                case \"]\":\\n                    stack.pop();\\n                    break;\\n                case \",\":\\n                    break;\\n                default: // number\\n                    NestedInteger num = new NestedInteger(Integer.parseInt(token));\\n                    stack.peek().add(num);\\n            }\\n        }\\n\\n        return stack.pop().getList().get(0);\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.StringTokenizer;\\npublic class Solution {\\n\\n    public NestedInteger deserialize(String s) {\\n        StringTokenizer tokenizer = new StringTokenizer(s, \"[],\", true);\\n\\n        Stack<NestedInteger> stack = new Stack<>();\\n        stack.push(new NestedInteger()); // a dummy list to simplify init\\n\\n        while (tokenizer.hasMoreTokens()) {\\n            String token = tokenizer.nextToken();\\n            switch (token) {\\n                case \"[\":\\n                    NestedInteger list = new NestedInteger();\\n                    stack.peek().add(list);\\n                    stack.push(list);\\n                    break;\\n                case \"]\":\\n                    stack.pop();\\n                    break;\\n                case \",\":\\n                    break;\\n                default: // number\\n                    NestedInteger num = new NestedInteger(Integer.parseInt(token));\\n                    stack.peek().add(num);\\n            }\\n        }\\n\\n        return stack.pop().getList().get(0);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86185,
                "title": "c-iterative-solution",
                "content": "Construct NestedInteger while parsing the string s:\\n```\\n     NestedInteger deserialize(string s) {\\n        stack<NestedInteger> st;\\n        int num = 0, sign = 1; \\n        bool numValid = false;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] == '-') {\\n                sign = -1;      \\n            } else if (isdigit(s[i])) {\\n                numValid = true;\\n                num = num * 10 + (s[i] - '0');\\n            } else if (s[i] == '[') {\\n                // start a new nested list as current active nested list\\n                st.push(NestedInteger());   \\n            } else {  \\n                // meaning s[i] == ',' || s[i] == ']'\\n                // add the last interger into current active nested list, and clear num/sign\\n                if (numValid) { st.top().add(NestedInteger(sign * num)); }\\n                numValid = false; num = 0; sign = 1;\\n                \\n                // add current active nested list to its parent nested list if the parent exists\\n                if (s[i] == ']' && st.size() > 1) {\\n                    auto temp = st.top(); st.pop();\\n                    st.top().add(temp);\\n                }\\n            } \\n        }\\n        \\n        // if there's only one single integer, return it\\n        if (numValid) {\\n            return NestedInteger(sign * num);\\n        }\\n        // else return the nested list\\n        return st.top();\\n    }\\n```\\n\\nA cleaner way with better decomposition:\\n```\\nclass Solution {\\nprivate:\\n    string getNext(string& s, int& pos) {                       // get next element: '[', ']', number string\\n        if (pos < s.length() && s[pos] == ',') { pos++; }       // skip ','\\n        if (pos < s.length() && (s[pos] == '[' || s[pos] == ']')) { return s.substr(pos++, 1); }\\n        int start = pos;\\n        if (pos < s.length() && s[pos] == '-') { pos++; }       // include '-' in a number substring\\n        while (pos < s.length() && isdigit(s[pos])) { pos++; }  // get the number substring\\n        return s.substr(start, pos - start);\\n    }\\n    \\npublic:\\n    NestedInteger deserialize(string s) {\\n        stack<NestedInteger> st;\\n        \\n        for (int pos = 0; pos < s.length();) {\\n            string curStr = getNext(s, pos);\\n            \\n            if (curStr == \"[\") {\\n                st.push(NestedInteger());                           // start a new nested list\\n            } else {                                                // curStr may be either \"]\" or a number string\\n                NestedInteger item;\\n                if (curStr == \"]\") { item = st.top(); st.pop(); }   // complete the last nested list / interger\\n                else { item = NestedInteger(stoi(curStr)); }        // it's a number string\\n                \\n                if (st.size()) { st.top().add(item); }              // merge it into previous nested list\\n                else { st.push(item); }                             // itself is the top parent nested list / integer\\n            }\\n        }\\n        \\n        return st.top();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n     NestedInteger deserialize(string s) {\\n        stack<NestedInteger> st;\\n        int num = 0, sign = 1; \\n        bool numValid = false;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] == '-') {\\n                sign = -1;      \\n            } else if (isdigit(s[i])) {\\n                numValid = true;\\n                num = num * 10 + (s[i] - '0');\\n            } else if (s[i] == '[') {\\n                // start a new nested list as current active nested list\\n                st.push(NestedInteger());   \\n            } else {  \\n                // meaning s[i] == ',' || s[i] == ']'\\n                // add the last interger into current active nested list, and clear num/sign\\n                if (numValid) { st.top().add(NestedInteger(sign * num)); }\\n                numValid = false; num = 0; sign = 1;\\n                \\n                // add current active nested list to its parent nested list if the parent exists\\n                if (s[i] == ']' && st.size() > 1) {\\n                    auto temp = st.top(); st.pop();\\n                    st.top().add(temp);\\n                }\\n            } \\n        }\\n        \\n        // if there's only one single integer, return it\\n        if (numValid) {\\n            return NestedInteger(sign * num);\\n        }\\n        // else return the nested list\\n        return st.top();\\n    }\\n```\n```\\nclass Solution {\\nprivate:\\n    string getNext(string& s, int& pos) {                       // get next element: '[', ']', number string\\n        if (pos < s.length() && s[pos] == ',') { pos++; }       // skip ','\\n        if (pos < s.length() && (s[pos] == '[' || s[pos] == ']')) { return s.substr(pos++, 1); }\\n        int start = pos;\\n        if (pos < s.length() && s[pos] == '-') { pos++; }       // include '-' in a number substring\\n        while (pos < s.length() && isdigit(s[pos])) { pos++; }  // get the number substring\\n        return s.substr(start, pos - start);\\n    }\\n    \\npublic:\\n    NestedInteger deserialize(string s) {\\n        stack<NestedInteger> st;\\n        \\n        for (int pos = 0; pos < s.length();) {\\n            string curStr = getNext(s, pos);\\n            \\n            if (curStr == \"[\") {\\n                st.push(NestedInteger());                           // start a new nested list\\n            } else {                                                // curStr may be either \"]\" or a number string\\n                NestedInteger item;\\n                if (curStr == \"]\") { item = st.top(); st.pop(); }   // complete the last nested list / interger\\n                else { item = NestedInteger(stoi(curStr)); }        // it's a number string\\n                \\n                if (st.size()) { st.top().add(item); }              // merge it into previous nested list\\n                else { st.push(item); }                             // itself is the top parent nested list / integer\\n            }\\n        }\\n        \\n        return st.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86226,
                "title": "share-my-simple-java-solution-with-explanation",
                "content": "Basic idea is: \\n1) when you see '[' you know you have to create a new NextedInteger object, but before that you have to store, if any, your current work into stack (we use stack structure to preserve the input order)\\n2) when you see ']' you can close current work and add it to the first element in stack, then replace your current work with this NextedInteger that previously worked with.\\n3) when you see a number (don't forget '-') you put it into a single valued NextedInteger object, add it to your current work.\\n\\nsome corner case: \"324\" v.s \"[324]\"  -->  Integer  v.s  single Valued NextedInteger object\\n\\n\\n```\\npublic class Solution {\\n    public NestedInteger deserialize(String s) {\\n        Stack<NestedInteger> stk = new Stack<>();\\n        Reader input = new Reader(s);\\n        NestedInteger cur = null;\\n        while(input.hasNext()){\\n            String next = input.next();\\n            if(next.equals(\"[\")){\\n                if(cur!=null){\\n                    stk.push(cur);\\n                }\\n                cur = new NestedInteger();\\n            }\\n            else if(next.equals(\"]\")){\\n                if(!stk.isEmpty()){\\n                    stk.peek().add(cur);\\n                    cur = stk.pop();\\n                }\\n            }\\n            else{\\n                int val = Integer.valueOf(next);\\n                if(cur==null){\\n                    cur = new NestedInteger(val);\\n                }\\n                else{\\n                    cur.add(new NestedInteger(val));\\n                }\\n            }\\n        }\\n        return cur;\\n    }\\n    \\n    class Reader{   // a helper class that passes input string into useful elements\\n        String str;\\n        int p, len;\\n        public Reader(String s){\\n            str = s;\\n            p = 0;\\n            len = str.length();\\n        }\\n        public boolean hasNext(){\\n            return p<len;\\n        }\\n        public String next(){\\n            if(str.charAt(p)==',') p++;\\n            int s = p;\\n            while(p<len && (str.charAt(p)=='-' || Character.isDigit(str.charAt(p)))) p++;\\n            if(s!=p) return str.substring(s,p);\\n            return str.substring(s,++p);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public NestedInteger deserialize(String s) {\\n        Stack<NestedInteger> stk = new Stack<>();\\n        Reader input = new Reader(s);\\n        NestedInteger cur = null;\\n        while(input.hasNext()){\\n            String next = input.next();\\n            if(next.equals(\"[\")){\\n                if(cur!=null){\\n                    stk.push(cur);\\n                }\\n                cur = new NestedInteger();\\n            }\\n            else if(next.equals(\"]\")){\\n                if(!stk.isEmpty()){\\n                    stk.peek().add(cur);\\n                    cur = stk.pop();\\n                }\\n            }\\n            else{\\n                int val = Integer.valueOf(next);\\n                if(cur==null){\\n                    cur = new NestedInteger(val);\\n                }\\n                else{\\n                    cur.add(new NestedInteger(val));\\n                }\\n            }\\n        }\\n        return cur;\\n    }\\n    \\n    class Reader{   // a helper class that passes input string into useful elements\\n        String str;\\n        int p, len;\\n        public Reader(String s){\\n            str = s;\\n            p = 0;\\n            len = str.length();\\n        }\\n        public boolean hasNext(){\\n            return p<len;\\n        }\\n        public String next(){\\n            if(str.charAt(p)==',') p++;\\n            int s = p;\\n            while(p<len && (str.charAt(p)=='-' || Character.isDigit(str.charAt(p)))) p++;\\n            if(s!=p) return str.substring(s,p);\\n            return str.substring(s,++p);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663252,
                "title": "dfs-implement-delimter-function-java-10-ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        if(isInteger(s)) {\\n            return s.isEmpty() ? new NestedInteger() : new NestedInteger(getIntegerValue(s));\\n        }\\n        s = removeBrackets(s);\\n        NestedInteger list = new NestedInteger();\\n        for (String child: delimitedStr(s)) {\\n            if(child.isEmpty()) continue;\\n            list.add(deserialize(child));\\n        }\\n        return list;\\n    }\\n\\n    private boolean isInteger(String str) {\\n        return !str.contains(\",\") && !str.startsWith(\"[\") && !str.endsWith(\"]\");\\n    }\\n\\n    private int getIntegerValue(String s) {\\n        if(s.startsWith(\"-\")) return - Integer.parseInt(s.substring(1));\\n        return Integer.parseInt(s);\\n    }\\n\\n    private String removeBrackets(String s) {\\n        return s.substring(1, s.length()-1);\\n    }\\n\\n    private List<String> delimitedStr(String str) {\\n        if(!str.contains(\",\")) return List.of(str);\\n        List<String> delimited = new ArrayList<>();\\n        int numBrackets = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for (Character c: str.toCharArray()) {\\n            if(!sb.isEmpty() && numBrackets == 0 && c == \\',\\') {\\n                delimited.add(sb.toString());\\n                sb = new StringBuilder();\\n            } else if(!sb.isEmpty() && c == \\']\\' && numBrackets-1 == 0) {\\n                sb.append(c);\\n                numBrackets = 0;\\n                delimited.add(sb.toString());\\n                sb = new StringBuilder();\\n            } else {\\n                if (sb.isEmpty() && c == \\',\\') continue; \\n                sb.append(c);\\n                if(c == \\'[\\') numBrackets++;\\n                if(c == \\']\\') numBrackets--;\\n            }\\n        }\\n        if(!sb.isEmpty()) delimited.add(sb.toString());\\n        return delimited;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        if(isInteger(s)) {\\n            return s.isEmpty() ? new NestedInteger() : new NestedInteger(getIntegerValue(s));\\n        }\\n        s = removeBrackets(s);\\n        NestedInteger list = new NestedInteger();\\n        for (String child: delimitedStr(s)) {\\n            if(child.isEmpty()) continue;\\n            list.add(deserialize(child));\\n        }\\n        return list;\\n    }\\n\\n    private boolean isInteger(String str) {\\n        return !str.contains(\",\") && !str.startsWith(\"[\") && !str.endsWith(\"]\");\\n    }\\n\\n    private int getIntegerValue(String s) {\\n        if(s.startsWith(\"-\")) return - Integer.parseInt(s.substring(1));\\n        return Integer.parseInt(s);\\n    }\\n\\n    private String removeBrackets(String s) {\\n        return s.substring(1, s.length()-1);\\n    }\\n\\n    private List<String> delimitedStr(String str) {\\n        if(!str.contains(\",\")) return List.of(str);\\n        List<String> delimited = new ArrayList<>();\\n        int numBrackets = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for (Character c: str.toCharArray()) {\\n            if(!sb.isEmpty() && numBrackets == 0 && c == \\',\\') {\\n                delimited.add(sb.toString());\\n                sb = new StringBuilder();\\n            } else if(!sb.isEmpty() && c == \\']\\' && numBrackets-1 == 0) {\\n                sb.append(c);\\n                numBrackets = 0;\\n                delimited.add(sb.toString());\\n                sb = new StringBuilder();\\n            } else {\\n                if (sb.isEmpty() && c == \\',\\') continue; \\n                sb.append(c);\\n                if(c == \\'[\\') numBrackets++;\\n                if(c == \\']\\') numBrackets--;\\n            }\\n        }\\n        if(!sb.isEmpty()) delimited.add(sb.toString());\\n        return delimited;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994108,
                "title": "java-recursive-solution",
                "content": "NestedInteger can contain Integer or List so handled them sepretly. \\n```\\nclass Solution {\\n    int c = 0;\\n    public NestedInteger deserialize(String s) {\\n        char[] chars = s.toCharArray();\\n        return deserialize(chars);\\n    }\\n    \\n    NestedInteger deserialize(char[] chars) {\\n        if(chars[c] == \\'[\\') {\\n            c++;\\n            NestedInteger parent = new NestedInteger(); \\n            \\n            while(c < chars.length && chars[c] != \\']\\') {\\n                if(chars[c] == \\',\\') {c++; continue;}\\n                parent.add(deserialize(chars));\\n            }\\n             c++;\\n            return parent;\\n           \\n        }\\n        else {\\n            StringBuilder sb = new StringBuilder();\\n            while(c < chars.length && ((chars[c] >= \\'0\\' && chars[c] <=\\'9\\') || (chars[c] == \\'-\\'))) {\\n                sb.append(chars[c]);\\n                c++;    \\n            }  \\n            return new NestedInteger(Integer.valueOf(sb.toString()));\\n        }\\n        \\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int c = 0;\\n    public NestedInteger deserialize(String s) {\\n        char[] chars = s.toCharArray();\\n        return deserialize(chars);\\n    }\\n    \\n    NestedInteger deserialize(char[] chars) {\\n        if(chars[c] == \\'[\\') {\\n            c++;\\n            NestedInteger parent = new NestedInteger(); \\n            \\n            while(c < chars.length && chars[c] != \\']\\') {\\n                if(chars[c] == \\',\\') {c++; continue;}\\n                parent.add(deserialize(chars));\\n            }\\n             c++;\\n            return parent;\\n           \\n        }\\n        else {\\n            StringBuilder sb = new StringBuilder();\\n            while(c < chars.length && ((chars[c] >= \\'0\\' && chars[c] <=\\'9\\') || (chars[c] == \\'-\\'))) {\\n                sb.append(chars[c]);\\n                c++;    \\n            }  \\n            return new NestedInteger(Integer.valueOf(sb.toString()));\\n        }\\n        \\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897083,
                "title": "python",
                "content": "\\n    def deserialize(self, s):\\n        if not s:\\n            return NestedInteger()\\n        \\n        if not s.startswith(\"[\"):\\n            return NestedInteger(int(s))\\n        \\n        ans = NestedInteger()\\n        \\n        s = s[1:-1]\\n        \\n        if s:\\n            ii = op = 0\\n            \\n            for i in range(len(s)):\\n                if s[i] == \"[\":\\n                    op += 1\\n                if s[i] == \"]\":\\n                    op -= 1\\n                if s[i] == \",\" and op == 0:\\n                    ans.add(self.deserialize(s[ii:i]))\\n                    ii = i + 1\\n                    \\n            ans.add(self.deserialize(s[ii:i+1]))\\n            \\n        return ans",
                "solutionTags": [],
                "code": "\\n    def deserialize(self, s):\\n        if not s:\\n            return NestedInteger()\\n        \\n        if not s.startswith(\"[\"):\\n            return NestedInteger(int(s))\\n        \\n        ans = NestedInteger()\\n        \\n        s = s[1:-1]\\n        \\n        if s:\\n            ii = op = 0\\n            \\n            for i in range(len(s)):\\n                if s[i] == \"[\":\\n                    op += 1\\n                if s[i] == \"]\":\\n                    op -= 1\\n                if s[i] == \",\" and op == 0:\\n                    ans.add(self.deserialize(s[ii:i]))\\n                    ii = i + 1\\n                    \\n            ans.add(self.deserialize(s[ii:i+1]))\\n            \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 1857677,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        if(s.charAt(0) != \\'[\\') return new NestedInteger(Integer.parseInt(s));\\n        \\n        NestedInteger res = new NestedInteger();\\n        int left = 1, right = s.length() - 1;\\n        while(left < right){\\n            int start = left;\\n            if(s.charAt(left) == \\',\\'){\\n                left++;\\n                continue;\\n            }else if(s.charAt(left) != \\'[\\'){\\n                 while(s.charAt(left) != \\',\\' && left < right) left++;\\n            }else {\\n                left++;\\n                int count = 1;\\n                while(count != 0 && left < right){\\n                    char c = s.charAt(left++);\\n                    count += (c == \\'[\\') ? 1 : (c == \\']\\' ? -1 : 0);\\n                }\\n            }\\n            NestedInteger inner = deserialize(s.substring(start, left));\\n            res.add(inner);\\n        }\\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        if(s.charAt(0) != \\'[\\') return new NestedInteger(Integer.parseInt(s));\\n        \\n        NestedInteger res = new NestedInteger();\\n        int left = 1, right = s.length() - 1;\\n        while(left < right){\\n            int start = left;\\n            if(s.charAt(left) == \\',\\'){\\n                left++;\\n                continue;\\n            }else if(s.charAt(left) != \\'[\\'){\\n                 while(s.charAt(left) != \\',\\' && left < right) left++;\\n            }else {\\n                left++;\\n                int count = 1;\\n                while(count != 0 && left < right){\\n                    char c = s.charAt(left++);\\n                    count += (c == \\'[\\') ? 1 : (c == \\']\\' ? -1 : 0);\\n                }\\n            }\\n            NestedInteger inner = deserialize(s.substring(start, left));\\n            res.add(inner);\\n        }\\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638534,
                "title": "elegant-python-one-pass-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        stack = []\\n        integerStr = \\'\\'\\n        \\n        for c in s:\\n            if c == \\'[\\':\\n                stack.append(NestedInteger())\\n            elif c == \\']\\':\\n                if len(integerStr)>0:\\n                    stack[-1].add(NestedInteger(int(integerStr)))\\n                integerStr = \\'\\'\\n                poppedList = stack.pop()\\n                if len(stack)==0:\\n                    return poppedList\\n                stack[-1].add(poppedList)\\n            elif c == \\',\\':\\n                if len(integerStr)>0:\\n                    stack[-1].add(NestedInteger(int(integerStr)))\\n                integerStr = \\'\\'\\n            else:\\n                integerStr += c\\n                \\n        return NestedInteger(int(s))\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        stack = []\\n        integerStr = \\'\\'\\n        \\n        for c in s:\\n            if c == \\'[\\':\\n                stack.append(NestedInteger())\\n            elif c == \\']\\':\\n                if len(integerStr)>0:\\n                    stack[-1].add(NestedInteger(int(integerStr)))\\n                integerStr = \\'\\'\\n                poppedList = stack.pop()\\n                if len(stack)==0:\\n                    return poppedList\\n                stack[-1].add(poppedList)\\n            elif c == \\',\\':\\n                if len(integerStr)>0:\\n                    stack[-1].add(NestedInteger(int(integerStr)))\\n                integerStr = \\'\\'\\n            else:\\n                integerStr += c\\n                \\n        return NestedInteger(int(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594456,
                "title": "python-solution-using-stack",
                "content": "Using Stack:\\n```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        if s.find(\\'[\\') == -1:\\n            return NestedInteger(int(s))\\n        \\n        stack = []\\n        sign = 1\\n        num = None\\n        \\n        for ch in s:\\n            if ch == \\'-\\':\\n                sign = -1\\n            elif ch == \\',\\':\\n                if num is not None:\\n                    stack[-1].add(NestedInteger(sign * num))\\n                    sign = 1\\n                    num = None\\n            elif ch == \\'[\\':\\n                stack.append(NestedInteger())\\n            elif ch == \\']\\':\\n                if num is not None:\\n                    stack[-1].add(NestedInteger(sign * num))\\n                    sign = 1\\n                    num = None\\n                _list = stack.pop()\\n                if stack:\\n                    stack[-1].add(_list)\\n                else:\\n                    return _list\\n            else:\\n                num = num * 10 + int(ch) if num else int(ch)\\n```\\n**Side note:** This is assuming the given string is serialized by us and will always be valid. If it can be invalid we will need to handle edge cases.\\n\\nUsing json module (which I don\\'t think is the intended solution, but might come in handy in development):\\n```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        \\n        def build(data):\\n            if isinstance(data, int):\\n                return NestedInteger(data)\\n            \\n            result = NestedInteger()\\n            for val in data:\\n                result.add(build(val))\\n                \\n            return result\\n            \\n        return build(json.loads(s))\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        if s.find(\\'[\\') == -1:\\n            return NestedInteger(int(s))\\n        \\n        stack = []\\n        sign = 1\\n        num = None\\n        \\n        for ch in s:\\n            if ch == \\'-\\':\\n                sign = -1\\n            elif ch == \\',\\':\\n                if num is not None:\\n                    stack[-1].add(NestedInteger(sign * num))\\n                    sign = 1\\n                    num = None\\n            elif ch == \\'[\\':\\n                stack.append(NestedInteger())\\n            elif ch == \\']\\':\\n                if num is not None:\\n                    stack[-1].add(NestedInteger(sign * num))\\n                    sign = 1\\n                    num = None\\n                _list = stack.pop()\\n                if stack:\\n                    stack[-1].add(_list)\\n                else:\\n                    return _list\\n            else:\\n                num = num * 10 + int(ch) if num else int(ch)\\n```\n```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        \\n        def build(data):\\n            if isinstance(data, int):\\n                return NestedInteger(data)\\n            \\n            result = NestedInteger()\\n            for val in data:\\n                result.add(build(val))\\n                \\n            return result\\n            \\n        return build(json.loads(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583464,
                "title": "java-easy-stack-solution",
                "content": "```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        // sb for digit value\\n        StringBuilder sb = new StringBuilder();\\n        \\n        Stack<NestedInteger> stack = new Stack<>();\\n        \\n        NestedInteger lastList = null;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            \\n            if (c == \\'[\\') {\\n                NestedInteger list = new NestedInteger();\\n                stack.push(list);\\n            } else if (isDigit(c)) {\\n                sb.append(c);\\n            } else if (c == \\',\\') {\\n                if (sb.length() > 0) {\\n                    stack.peek().add(new NestedInteger(toInt(sb.toString())));\\n                    sb = new StringBuilder();\\n                }\\n            } else if (c == \\']\\') {\\n                lastList = stack.pop();\\n                if (sb.length() > 0) lastList.add(new NestedInteger(toInt(sb.toString())));\\n                sb = new StringBuilder();\\n                if (!stack.isEmpty()) {\\n                    stack.peek().add(lastList);\\n                }\\n            }\\n        }\\n        \\n        if (lastList == null) {\\n            return new NestedInteger(toInt(sb.toString()));\\n        } else {\\n            return lastList;\\n        }\\n    }\\n    \\n    private boolean isDigit(char c) {\\n        if ((c >= \\'0\\') && (c <= \\'9\\')) {\\n            return true;\\n        }\\n        \\n        return c == \\'-\\';\\n    }\\n    \\n    private int toInt(String s) {\\n        return Integer.valueOf(s).intValue();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        // sb for digit value\\n        StringBuilder sb = new StringBuilder();\\n        \\n        Stack<NestedInteger> stack = new Stack<>();\\n        \\n        NestedInteger lastList = null;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            \\n            if (c == \\'[\\') {\\n                NestedInteger list = new NestedInteger();\\n                stack.push(list);\\n            } else if (isDigit(c)) {\\n                sb.append(c);\\n            } else if (c == \\',\\') {\\n                if (sb.length() > 0) {\\n                    stack.peek().add(new NestedInteger(toInt(sb.toString())));\\n                    sb = new StringBuilder();\\n                }\\n            } else if (c == \\']\\') {\\n                lastList = stack.pop();\\n                if (sb.length() > 0) lastList.add(new NestedInteger(toInt(sb.toString())));\\n                sb = new StringBuilder();\\n                if (!stack.isEmpty()) {\\n                    stack.peek().add(lastList);\\n                }\\n            }\\n        }\\n        \\n        if (lastList == null) {\\n            return new NestedInteger(toInt(sb.toString()));\\n        } else {\\n            return lastList;\\n        }\\n    }\\n    \\n    private boolean isDigit(char c) {\\n        if ((c >= \\'0\\') && (c <= \\'9\\')) {\\n            return true;\\n        }\\n        \\n        return c == \\'-\\';\\n    }\\n    \\n    private int toInt(String s) {\\n        return Integer.valueOf(s).intValue();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530209,
                "title": "c-recursive-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        int index = 0;\\n        return deserialize(s, index);\\n    }\\n    \\n    NestedInteger deserialize(string s, int &index) {\\n        NestedInteger result;\\n        if (s[index] == \\'[\\') {\\n            parseList(s, index, &result);\\n        } else {\\n            result.setInteger(parseNum(s, index));\\n        }\\n        return result;\\n    }\\n    \\n    void parseList(string s, int &index, NestedInteger *parent) {\\n        index++;\\n        while (s[index] != \\']\\') {\\n            if (s[index] == \\',\\') {\\n                index++;\\n            } else if (s[index] == \\'[\\') {\\n                NestedInteger n;\\n                parseList(s, index, &n);\\n                parent->add(n);\\n            } else {\\n                NestedInteger n;\\n                n.setInteger(parseNum(s, index));\\n                parent->add(n);\\n            }\\n        }\\n        index++;\\n    }\\n    \\n    int parseNum(string s, int &index) {\\n        bool negative = false;\\n        int value = 0;\\n        if (s[index] == \\'-\\') {\\n            negative = true;\\n            index++;\\n        }\\n        int result = 0;\\n        while (isNum(s[index])) {\\n            result *= 10;\\n            result += (s[index] - \\'0\\');\\n            index += 1;\\n        }\\n        if (negative) {\\n            result = -result;\\n        }\\n        return result;\\n    }\\n    \\n    bool isNum(char c) {\\n        if (c >= \\'0\\' && c <= \\'9\\') { return true; }\\n        return false;\\n    }\\n};\\n```\\n\\nCoo Coo",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        int index = 0;\\n        return deserialize(s, index);\\n    }\\n    \\n    NestedInteger deserialize(string s, int &index) {\\n        NestedInteger result;\\n        if (s[index] == \\'[\\') {\\n            parseList(s, index, &result);\\n        } else {\\n            result.setInteger(parseNum(s, index));\\n        }\\n        return result;\\n    }\\n    \\n    void parseList(string s, int &index, NestedInteger *parent) {\\n        index++;\\n        while (s[index] != \\']\\') {\\n            if (s[index] == \\',\\') {\\n                index++;\\n            } else if (s[index] == \\'[\\') {\\n                NestedInteger n;\\n                parseList(s, index, &n);\\n                parent->add(n);\\n            } else {\\n                NestedInteger n;\\n                n.setInteger(parseNum(s, index));\\n                parent->add(n);\\n            }\\n        }\\n        index++;\\n    }\\n    \\n    int parseNum(string s, int &index) {\\n        bool negative = false;\\n        int value = 0;\\n        if (s[index] == \\'-\\') {\\n            negative = true;\\n            index++;\\n        }\\n        int result = 0;\\n        while (isNum(s[index])) {\\n            result *= 10;\\n            result += (s[index] - \\'0\\');\\n            index += 1;\\n        }\\n        if (negative) {\\n            result = -result;\\n        }\\n        return result;\\n    }\\n    \\n    bool isNum(char c) {\\n        if (c >= \\'0\\' && c <= \\'9\\') { return true; }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506292,
                "title": "faster-than-100-nice",
                "content": "```javascript\\nvar deserialize = function(s) {\\n    if(!s) return null\\n    s = JSON.parse(s)\\n    let n = new NestedInteger()\\n    function fn(nt, s) {\\n        if(Array.isArray(s)) {\\n            let a = new NestedInteger()\\n            for(let item of s) {\\n                let ret = fn(a, item)\\n                a.add(ret)\\n            }\\n            return a\\n        }\\n        return new NestedInteger(s)\\n    }\\n\\n    let ret = fn(n, s)\\n\\n    return ret\\n};\\n```\\n\\nmodified at 2023-01-08\\n```js\\nvar deserialize = function(s) {\\n    if(!s) return null\\n    s = JSON.parse(s)\\n    function fn(s) {\\n        if(Array.isArray(s)) {\\n            let a = new NestedInteger()\\n            for(let item of s) {\\n                let ret = fn(item)\\n                a.add(ret)\\n            }\\n            return a\\n        }\\n        return new NestedInteger(s)\\n    }\\n\\n    let ret = fn(s)\\n\\n    return ret\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar deserialize = function(s) {\\n    if(!s) return null\\n    s = JSON.parse(s)\\n    let n = new NestedInteger()\\n    function fn(nt, s) {\\n        if(Array.isArray(s)) {\\n            let a = new NestedInteger()\\n            for(let item of s) {\\n                let ret = fn(a, item)\\n                a.add(ret)\\n            }\\n            return a\\n        }\\n        return new NestedInteger(s)\\n    }\\n\\n    let ret = fn(n, s)\\n\\n    return ret\\n};\\n```\n```js\\nvar deserialize = function(s) {\\n    if(!s) return null\\n    s = JSON.parse(s)\\n    function fn(s) {\\n        if(Array.isArray(s)) {\\n            let a = new NestedInteger()\\n            for(let item of s) {\\n                let ret = fn(item)\\n                a.add(ret)\\n            }\\n            return a\\n        }\\n        return new NestedInteger(s)\\n    }\\n\\n    let ret = fn(s)\\n\\n    return ret\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1398284,
                "title": "c-no-stack-easy-solution",
                "content": "```csharp\\npublic NestedInteger Deserialize(string s) {\\n\\tif (!s.Contains(\\'[\\')) {\\n\\t\\treturn new NestedInteger(Convert.ToInt32(s));\\n\\t}\\n\\tvar list = new NestedInteger();\\n\\ts = s.Substring(1, s.Length - 2);\\n\\tvar i = 0;\\n\\tvar j = 0;\\n\\tvar bracketCounter = 0;\\n\\twhile (i < s.Length) {\\n\\t\\tif (bracketCounter == 0) {\\n\\t\\t\\tj = i;\\n\\t\\t}\\n\\t\\twhile (i < s.Length && s[i] != \\',\\') {\\n\\t\\t\\tif (s[i] == \\'[\\') {\\n\\t\\t\\t\\tbracketCounter++;\\n\\t\\t\\t} else if (s[i] == \\']\\') {\\n\\t\\t\\t\\tbracketCounter--;\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tif (bracketCounter == 0) {\\n\\t\\t\\tlist.Add(Deserialize(s.Substring(j, i - j)));\\n\\t\\t}\\n\\t\\ti++;\\n\\t}\\n\\treturn list;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic NestedInteger Deserialize(string s) {\\n\\tif (!s.Contains(\\'[\\')) {\\n\\t\\treturn new NestedInteger(Convert.ToInt32(s));\\n\\t}\\n\\tvar list = new NestedInteger();\\n\\ts = s.Substring(1, s.Length - 2);\\n\\tvar i = 0;\\n\\tvar j = 0;\\n\\tvar bracketCounter = 0;\\n\\twhile (i < s.Length) {\\n\\t\\tif (bracketCounter == 0) {\\n\\t\\t\\tj = i;\\n\\t\\t}\\n\\t\\twhile (i < s.Length && s[i] != \\',\\') {\\n\\t\\t\\tif (s[i] == \\'[\\') {\\n\\t\\t\\t\\tbracketCounter++;\\n\\t\\t\\t} else if (s[i] == \\']\\') {\\n\\t\\t\\t\\tbracketCounter--;\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tif (bracketCounter == 0) {\\n\\t\\t\\tlist.Add(Deserialize(s.Substring(j, i - j)));\\n\\t\\t}\\n\\t\\ti++;\\n\\t}\\n\\treturn list;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1387689,
                "title": "go-easy",
                "content": "```\\nfunc deserialize(s string) *NestedInteger {\\n    stk:=[]*NestedInteger{}\\n    curr:=\"\"\\n    for _,v:=range s{\\n        if v==\\'[\\'{\\n            //init\\n            stk=append(stk,&NestedInteger{})\\n        }else if v==\\']\\'{\\n            if curr!=\"\"{\\n                stk[len(stk)-1].Add(*buildNI(curr))\\n                curr=\"\"\\n            }\\n            if len(stk)>1{//tricky\\n                back:=stk[len(stk)-1]\\n                stk=stk[:len(stk)-1]\\n                stk[len(stk)-1].Add(*back)\\n            }\\n        \\n        }else if v==\\',\\'{\\n            if curr==\"\"{\\n                continue\\n            }\\n            stk[len(stk)-1].Add(*buildNI(curr))\\n            curr=\"\"\\n        }else{\\n            curr+=string(v)\\n        }\\n    }\\n    if curr!=\"\"{\\n        stk=append(stk,buildNI(curr))\\n    }\\n    return stk[len(stk)-1]\\n}\\n\\nfunc buildNI(val string) *NestedInteger{\\n    temp:=&NestedInteger{}\\n    v,_:=strconv.Atoi(val)\\n    temp.SetInteger(v)\\n    return temp\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc deserialize(s string) *NestedInteger {\\n    stk:=[]*NestedInteger{}\\n    curr:=\"\"\\n    for _,v:=range s{\\n        if v==\\'[\\'{\\n            //init\\n            stk=append(stk,&NestedInteger{})\\n        }else if v==\\']\\'{\\n            if curr!=\"\"{\\n                stk[len(stk)-1].Add(*buildNI(curr))\\n                curr=\"\"\\n            }\\n            if len(stk)>1{//tricky\\n                back:=stk[len(stk)-1]\\n                stk=stk[:len(stk)-1]\\n                stk[len(stk)-1].Add(*back)\\n            }\\n        \\n        }else if v==\\',\\'{\\n            if curr==\"\"{\\n                continue\\n            }\\n            stk[len(stk)-1].Add(*buildNI(curr))\\n            curr=\"\"\\n        }else{\\n            curr+=string(v)\\n        }\\n    }\\n    if curr!=\"\"{\\n        stk=append(stk,buildNI(curr))\\n    }\\n    return stk[len(stk)-1]\\n}\\n\\nfunc buildNI(val string) *NestedInteger{\\n    temp:=&NestedInteger{}\\n    v,_:=strconv.Atoi(val)\\n    temp.SetInteger(v)\\n    return temp\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1320503,
                "title": "python-beat-100-runtime-and-99-48-memory-recursive-solution",
                "content": "```\\ndef deserialize(self, s: str) -> NestedInteger:\\n\\n\\n\\n\\tdef helper(new_str, idx, is_list=False):\\n\\n\\t\\tstart = idx\\n\\n\\t\\tif is_list:\\n\\t\\t\\tresult = list()\\n\\t\\telse:\\n\\t\\t\\tresult = NestedInteger()\\n\\n\\t\\tfor cur_idx, ch in enumerate(new_str[idx:]):\\n\\t\\t\\tif ch == \",\":\\n\\t\\t\\t\\tni = NestedInteger(new_str[start:idx+cur_idx])\\n\\n\\t\\t\\t\\tif is_list:\\n\\t\\t\\t\\t\\tresult.append(ni)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn ni\\n\\n\\t\\t\\t\\tstart = idx + cur_idx + 1\\n\\n\\t\\t\\telif ch == \\'[\\':\\n\\t\\t\\t\\tresult.append(helper(new_str, idx + cur_idx + 1, is_list=True))\\n\\n\\t\\t\\telif ch == \\']\\':\\n\\t\\t\\t\\tbreak\\n\\n\\t\\treturn NestedInteger(new_str)\\n\\n\\tif s[0] == \"[\":\\n\\t\\treturn helper(s, 1, is_list=True)\\n\\telse:\\n\\t\\treturn helper(s, 0, is_list=False)\\n```",
                "solutionTags": [],
                "code": "```\\ndef deserialize(self, s: str) -> NestedInteger:\\n\\n\\n\\n\\tdef helper(new_str, idx, is_list=False):\\n\\n\\t\\tstart = idx\\n\\n\\t\\tif is_list:\\n\\t\\t\\tresult = list()\\n\\t\\telse:\\n\\t\\t\\tresult = NestedInteger()\\n\\n\\t\\tfor cur_idx, ch in enumerate(new_str[idx:]):\\n\\t\\t\\tif ch == \",\":\\n\\t\\t\\t\\tni = NestedInteger(new_str[start:idx+cur_idx])\\n\\n\\t\\t\\t\\tif is_list:\\n\\t\\t\\t\\t\\tresult.append(ni)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn ni\\n\\n\\t\\t\\t\\tstart = idx + cur_idx + 1\\n\\n\\t\\t\\telif ch == \\'[\\':\\n\\t\\t\\t\\tresult.append(helper(new_str, idx + cur_idx + 1, is_list=True))\\n\\n\\t\\t\\telif ch == \\']\\':\\n\\t\\t\\t\\tbreak\\n\\n\\t\\treturn NestedInteger(new_str)\\n\\n\\tif s[0] == \"[\":\\n\\t\\treturn helper(s, 1, is_list=True)\\n\\telse:\\n\\t\\treturn helper(s, 0, is_list=False)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1227931,
                "title": "c-o-n-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s)\\n    {\\n        NestedInteger ans;\\n        stack<NestedInteger>st;\\n        int i=0;\\n        if(s[i]!=\\'[\\')//just one integer\\n        {\\n            ans=NestedInteger(stoi(s));\\n            return ans;\\n        }\\n        while(i<s.size())\\n        {\\n            if(s[i]==\\',\\')//ignore\\n            {\\n                i++;\\n                continue;\\n            }\\n            if(s[i]==\\'[\\')//start new NestedInteger\\n            {\\n                NestedInteger temp=NestedInteger();\\n                st.push(temp);\\n            }\\n            else if(s[i]==\\'-\\' || isdigit(s[i]))//number begins\\n            {\\n                int sign=1;\\n                if(s[i]==\\'-\\')\\n                {\\n                    sign=-1;\\n                    i++;\\n                }\\n                int num=0;\\n                while(i<s.size() && isdigit(s[i]))//form number till \\',\\' or \\']\\' is found\\n                {\\n                    num=(num*10)+(s[i]-\\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                num=num*sign;\\n                st.top().add(num);//push it to current NestedInteger\\n            }\\n            else//s[i]==\\']\\'\\n            {\\n                NestedInteger top = st.top();//this will be added to next current NestedInteger, or become final answer\\n                st.pop();\\n                if(st.empty())\\n                    ans=top;\\n                else\\n                    st.top().add(top);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s)\\n    {\\n        NestedInteger ans;\\n        stack<NestedInteger>st;\\n        int i=0;\\n        if(s[i]!=\\'[\\')//just one integer\\n        {\\n            ans=NestedInteger(stoi(s));\\n            return ans;\\n        }\\n        while(i<s.size())\\n        {\\n            if(s[i]==\\',\\')//ignore\\n            {\\n                i++;\\n                continue;\\n            }\\n            if(s[i]==\\'[\\')//start new NestedInteger\\n            {\\n                NestedInteger temp=NestedInteger();\\n                st.push(temp);\\n            }\\n            else if(s[i]==\\'-\\' || isdigit(s[i]))//number begins\\n            {\\n                int sign=1;\\n                if(s[i]==\\'-\\')\\n                {\\n                    sign=-1;\\n                    i++;\\n                }\\n                int num=0;\\n                while(i<s.size() && isdigit(s[i]))//form number till \\',\\' or \\']\\' is found\\n                {\\n                    num=(num*10)+(s[i]-\\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                num=num*sign;\\n                st.top().add(num);//push it to current NestedInteger\\n            }\\n            else//s[i]==\\']\\'\\n            {\\n                NestedInteger top = st.top();//this will be added to next current NestedInteger, or become final answer\\n                st.pop();\\n                if(st.empty())\\n                    ans=top;\\n                else\\n                    st.top().add(top);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212320,
                "title": "93-python-eval-recursion",
                "content": "```\\n# \"\"\"\\n# This is the interface that allows for creating nested lists.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n#class NestedInteger:\\n#    def __init__(self, value=None):\\n#        \"\"\"\\n#        If value is not specified, initializes an empty list.\\n#        Otherwise initializes a single integer equal to value.\\n#        \"\"\"\\n#\\n#    def isInteger(self):\\n#        \"\"\"\\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\\n#        :rtype bool\\n#        \"\"\"\\n#\\n#    def add(self, elem):\\n#        \"\"\"\\n#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\\n#        :rtype void\\n#        \"\"\"\\n#\\n#    def setInteger(self, value):\\n#        \"\"\"\\n#        Set this NestedInteger to hold a single integer equal to value.\\n#        :rtype void\\n#        \"\"\"\\n#\\n#    def getInteger(self):\\n#        \"\"\"\\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\\n#        Return None if this NestedInteger holds a nested list\\n#        :rtype int\\n#        \"\"\"\\n#\\n#    def getList(self):\\n#        \"\"\"\\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\\n#        Return None if this NestedInteger holds a single integer\\n#        :rtype List[NestedInteger]\\n#        \"\"\"\\n\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        s = eval(s)\\n        def getNestedInteger(nums):\\n            if type(nums) == int:\\n                return NestedInteger(nums)\\n            ans = NestedInteger()\\n            for num in nums:\\n                ans.add(getNestedInteger(num))\\n            return ans \\n        return getNestedInteger(s)\\n```",
                "solutionTags": [],
                "code": "```\\n# \"\"\"\\n# This is the interface that allows for creating nested lists.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n#class NestedInteger:\\n#    def __init__(self, value=None):\\n#        \"\"\"\\n#        If value is not specified, initializes an empty list.\\n#        Otherwise initializes a single integer equal to value.\\n#        \"\"\"\\n#\\n#    def isInteger(self):\\n#        \"\"\"\\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\\n#        :rtype bool\\n#        \"\"\"\\n#\\n#    def add(self, elem):\\n#        \"\"\"\\n#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\\n#        :rtype void\\n#        \"\"\"\\n#\\n#    def setInteger(self, value):\\n#        \"\"\"\\n#        Set this NestedInteger to hold a single integer equal to value.\\n#        :rtype void\\n#        \"\"\"\\n#\\n#    def getInteger(self):\\n#        \"\"\"\\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\\n#        Return None if this NestedInteger holds a nested list\\n#        :rtype int\\n#        \"\"\"\\n#\\n#    def getList(self):\\n#        \"\"\"\\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\\n#        Return None if this NestedInteger holds a single integer\\n#        :rtype List[NestedInteger]\\n#        \"\"\"\\n\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        s = eval(s)\\n        def getNestedInteger(nums):\\n            if type(nums) == int:\\n                return NestedInteger(nums)\\n            ans = NestedInteger()\\n            for num in nums:\\n                ans.add(getNestedInteger(num))\\n            return ans \\n        return getNestedInteger(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150792,
                "title": "python-one-pass-stack-solution",
                "content": "this problem is not clear and kind of broken.\\nthe only useful api of the class is ```__init__``` and ```add```, others only make this problem confusing. Took me 20 min efforts to guess what the question wants and only 10 min to solve.\\nNotice that you have to use ```add(NestedInteger(#num))``` instead of using ```add(#num)``` directly. \\n\\n```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        stack = []\\n        num = \"\"\\n        for x in s:\\n            if x == \\'[\\':\\n                if not (not num or not stack):\\n                    stack[-1].add(int(num))\\n                    num = \"\"\\n                stack.append(NestedInteger())\\n            elif x == \\']\\':\\n                tmp = stack.pop()\\n                if num:\\n                    tmp.add(NestedInteger(int(num)))\\n                    num = \"\"\\n                if not stack:\\n                    return tmp\\n                else:\\n                    stack[-1].add(tmp)\\n            elif x == \\',\\':\\n                if num:\\n                    stack[-1].add(NestedInteger(int(num)))\\n                    num = \"\"\\n            else:\\n                num += x\\n        return NestedInteger(int(num))\\n```",
                "solutionTags": [],
                "code": "```__init__```\n```add```\n```add(NestedInteger(#num))```\n```add(#num)```\n```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        stack = []\\n        num = \"\"\\n        for x in s:\\n            if x == \\'[\\':\\n                if not (not num or not stack):\\n                    stack[-1].add(int(num))\\n                    num = \"\"\\n                stack.append(NestedInteger())\\n            elif x == \\']\\':\\n                tmp = stack.pop()\\n                if num:\\n                    tmp.add(NestedInteger(int(num)))\\n                    num = \"\"\\n                if not stack:\\n                    return tmp\\n                else:\\n                    stack[-1].add(tmp)\\n            elif x == \\',\\':\\n                if num:\\n                    stack[-1].add(NestedInteger(int(num)))\\n                    num = \"\"\\n            else:\\n                num += x\\n        return NestedInteger(int(num))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119942,
                "title": "c-recursive-soln",
                "content": "\\nRecursive solution, similar to https://leetcode.com/problems/decode-string/\\n```\\nNestedInteger deserialize(string s) {\\n        if (s.empty()) return NestedInteger();\\n        if (s[0] != \\'[\\') return NestedInteger(stoi(s));\\n        if (s.size() <= 2) return NestedInteger();\\n        int pos = 1;\\n        return parse(s, pos);\\n    }\\n    \\n    NestedInteger parse(string s, int& i) {\\n        int intVal = 0;\\n        NestedInteger res;\\n        char sign = \\'+\\';\\n        for (; i < s.size(); i++) {\\n            if (s[i] == \\'-\\') sign = \\'-\\';\\n            else if (isdigit(s[i])) {\\n                while (isdigit(s[i])) {\\n                    intVal = intVal * 10 + (s[i++] - \\'0\\');\\n                }\\n                res.add(sign == \\'+\\' ? intVal : -intVal);\\n                intVal = 0;\\n                sign = \\'+\\';\\n                i--;\\n            }\\n            else if (s[i] == \\'[\\') {\\n                res.add(parse(s, ++i));\\n            } \\n            else if (s[i] == \\']\\') {\\n                return res;\\n            }\\n        }\\n        return res;\\n    }\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "\\nRecursive solution, similar to https://leetcode.com/problems/decode-string/\\n```\\nNestedInteger deserialize(string s) {\\n        if (s.empty()) return NestedInteger();\\n        if (s[0] != \\'[\\') return NestedInteger(stoi(s));\\n        if (s.size() <= 2) return NestedInteger();\\n        int pos = 1;\\n        return parse(s, pos);\\n    }\\n    \\n    NestedInteger parse(string s, int& i) {\\n        int intVal = 0;\\n        NestedInteger res;\\n        char sign = \\'+\\';\\n        for (; i < s.size(); i++) {\\n            if (s[i] == \\'-\\') sign = \\'-\\';\\n            else if (isdigit(s[i])) {\\n                while (isdigit(s[i])) {\\n                    intVal = intVal * 10 + (s[i++] - \\'0\\');\\n                }\\n                res.add(sign == \\'+\\' ? intVal : -intVal);\\n                intVal = 0;\\n                sign = \\'+\\';\\n                i--;\\n            }\\n            else if (s[i] == \\'[\\') {\\n                res.add(parse(s, ++i));\\n            } \\n            else if (s[i] == \\']\\') {\\n                return res;\\n            }\\n        }\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1073143,
                "title": "java-recursion-like-n-ary-tree-deserializtion",
                "content": "```\\n    public NestedInteger deserialize(String s) {\\n        if(s.charAt(0) == \\'[\\') {\\n            NestedInteger root = new NestedInteger();\\n            s = s.substring(1, s.length() - 1); //remove \\'[]\\'\\n            \\n            while(!s.equals(\"\")) {\\n                if(s.charAt(0) != \\'[\\') {\\n                    int index = s.indexOf(\",\");\\n                    if(index == -1) { // \\',\\' not found\\n                        root.add(deserialize(s));\\n                        s = \"\";\\n                    } else { //found \\',\\'\\n                        root.add(deserialize(s.substring(0, index)));\\n                        s = s.substring(index + 1);\\n                    }\\n                } else {\\n                    int i = 0, count = 0;\\n                    while(i < s.length()) {\\n                        if(s.charAt(i) == \\'[\\') count++;\\n                        if(s.charAt(i) == \\']\\') count--;\\n                        if(count == 0) break;\\n                        i++;\\n                    }\\n                    root.add(deserialize(s.substring(0, ++i)));\\n                    if(i == s.length()) s = \"\"; // if it\\'s end\\n                    else s = s.substring(i + 1); // it\\'s not end, it has \\',\\'\\n                }\\n            }\\n\\n            return root;\\n        } else {\\n            return new NestedInteger(Integer.parseInt(s));\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public NestedInteger deserialize(String s) {\\n        if(s.charAt(0) == \\'[\\') {\\n            NestedInteger root = new NestedInteger();\\n            s = s.substring(1, s.length() - 1); //remove \\'[]\\'\\n            \\n            while(!s.equals(\"\")) {\\n                if(s.charAt(0) != \\'[\\') {\\n                    int index = s.indexOf(\",\");\\n                    if(index == -1) { // \\',\\' not found\\n                        root.add(deserialize(s));\\n                        s = \"\";\\n                    } else { //found \\',\\'\\n                        root.add(deserialize(s.substring(0, index)));\\n                        s = s.substring(index + 1);\\n                    }\\n                } else {\\n                    int i = 0, count = 0;\\n                    while(i < s.length()) {\\n                        if(s.charAt(i) == \\'[\\') count++;\\n                        if(s.charAt(i) == \\']\\') count--;\\n                        if(count == 0) break;\\n                        i++;\\n                    }\\n                    root.add(deserialize(s.substring(0, ++i)));\\n                    if(i == s.length()) s = \"\"; // if it\\'s end\\n                    else s = s.substring(i + 1); // it\\'s not end, it has \\',\\'\\n                }\\n            }\\n\\n            return root;\\n        } else {\\n            return new NestedInteger(Integer.parseInt(s));\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009577,
                "title": "java-using-recursion-time-o-n-and-space-o-1-except-output-objects",
                "content": "```\\nclass Solution {\\n    \\n    private int index = 0;\\n    \\n    public NestedInteger deserialize(String s) {\\n        NestedInteger ni = new NestedInteger();\\n        \\n        if (s.charAt(index) == \\'[\\') {\\n            // ni will be list object\\n            index++;\\n        } else {\\n            // Return simple integer object\\n            return getIntegerObject(s);\\n        }\\n        \\n        while (index < s.length()) {\\n            if (s.charAt(index) == \\'[\\') {\\n                ni.add(deserialize(s));\\n            } else if (s.charAt(index) != \\']\\') {\\n                ni.add(getIntegerObject(s));\\n            }\\n            if (s.charAt(index) == \\']\\') {\\n                // If we encounter ], then stop return current list object\\n                index++;\\n                break;\\n            }             \\n            index++;\\n        }\\n        return ni;\\n    }\\n    \\n    private NestedInteger getIntegerObject(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        while (index < s.length()) {\\n            // Parse num strings\\n            if (s.charAt(index) == \\',\\' || s.charAt(index) == \\']\\') {\\n                break;\\n            }\\n            sb.append(s.charAt(index));\\n            index++;\\n        }\\n        // Index will stop at \\',\\' or \\']\\'\\n        return new NestedInteger(Integer.parseInt(sb.toString()));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private int index = 0;\\n    \\n    public NestedInteger deserialize(String s) {\\n        NestedInteger ni = new NestedInteger();\\n        \\n        if (s.charAt(index) == \\'[\\') {\\n            // ni will be list object\\n            index++;\\n        } else {\\n            // Return simple integer object\\n            return getIntegerObject(s);\\n        }\\n        \\n        while (index < s.length()) {\\n            if (s.charAt(index) == \\'[\\') {\\n                ni.add(deserialize(s));\\n            } else if (s.charAt(index) != \\']\\') {\\n                ni.add(getIntegerObject(s));\\n            }\\n            if (s.charAt(index) == \\']\\') {\\n                // If we encounter ], then stop return current list object\\n                index++;\\n                break;\\n            }             \\n            index++;\\n        }\\n        return ni;\\n    }\\n    \\n    private NestedInteger getIntegerObject(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        while (index < s.length()) {\\n            // Parse num strings\\n            if (s.charAt(index) == \\',\\' || s.charAt(index) == \\']\\') {\\n                break;\\n            }\\n            sb.append(s.charAt(index));\\n            index++;\\n        }\\n        // Index will stop at \\',\\' or \\']\\'\\n        return new NestedInteger(Integer.parseInt(sb.toString()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823511,
                "title": "detailed-solution-to-an-ambiguous-question-no-wonder-why-so-many-dislikes",
                "content": "Hi guys this is an ambigious question and no good explaination is available anywhere, here i\\'ve heavily commented the code so that the reader can understand, also if you have doubts please comment!\\ni\\'ll create a youtube video on this ans share the link here [];\\n\\n```\\n//NI -- > Nested Integer\\nclass Solution {\\n    \\n    Stack<NestedInteger> stack = new Stack<>();\\n    NestedInteger ans = new NestedInteger();\\n    \\n    //for keeping at what index of string are we\\n    int index;\\n    \\n    /*since the string can also contain negative integers, we will have to keep track of sign */\\n    \\n    int sign;\\n\\n    //function provided by leetcode\\n    public NestedInteger deserialize(String s) {\\n        /* \\n            We will start traversing form the 1 index of the string, that is where \\n            a number would begin with.\\n            if a string begins with a number that means there is only one integer in\\n            it , becuase if there was a list ,it would begin with [\\n        */\\n        index = 1;\\n        sign = 1;  \\n        \\n        //checking if the list contains only one integer\\n        if(s.charAt(0)!=\\'[\\'){\\n            return new NestedInteger(Integer.parseInt(s));\\n        }\\n        \\n        myDeserialize(s);\\n        return ans;\\n    }\\n    \\n    \\n    /*Each time a call to myDerialize is called it means a nesting has taken place*/\\n    \\n    public void myDeserialize(String s){\\n        //just a safety check\\n        if(index >=s.length())return ;\\n        \\n        //initialize a new NestedInteger for this call\\n        NestedInteger newNI = new NestedInteger();\\n        \\n        /* if the stack is emtpy then we just push the current NI if not then\\n            we add the newly created NI to the last NI.\\n            [IMP] : The top of stack contains the current list always\\n        */\\n        if(stack.size()!=0)stack.peek().add(newNI);\\n        else{\\n            /*first time we create a NI , that is our answer, so we store it\\'s refrence*/\\n            \\n            ans = newNI;\\n        }\\n        //pushing current NI to top of the stack\\n        stack.push(newNI);\\n        \\n        //iterate till our string is over\\n        while(index<s.length()){\\n            char ch = s.charAt(index);\\n            /*\\n                if at some time [ is encountered a nesting is detected hence recursive call \\n            */\\n            if(ch==\\'[\\'){\\n                index++;\\n                myDeserialize(s);\\n            }\\n            \\n            /*  \\n                If ] is encountered that means current NI\\'s work is over , pop it from stack\\n            */\\n            else if (ch ==\\']\\'){\\n                index++;\\n                stack.pop();\\n            }\\n            //maintain the sign of the integer\\n            else if (ch ==\\'-\\'){\\n                sign = -1;\\n                index++;\\n            }\\n            //if comma , do nothing , just move forward \\n            else if(ch==\\',\\'){\\n                index++;\\n            }\\n            /*\\n                if a digit is encountered, then trverse till there are digits\\n                form a number , convert it into an integer and push the number\\n                in the current NI\\n            */\\n            else{\\n                //getting the current integer\\n                int endIndex = index;\\n                while(Character.isDigit(s.charAt(++endIndex)));\\n                String number_string = s.substring(index , endIndex);\\n                int number = sign*Integer.parseInt(number_string);\\n                stack.peek().add(new NestedInteger(number));\\n                sign = 1;\\n                index = endIndex;\\n            }\\n                \\n        }\\n        \\n    }\\n    \\n}\\n\\n\\n```\\nPlease upvote if it helped you :)\\nThankyou",
                "solutionTags": [],
                "code": "```\\n//NI -- > Nested Integer\\nclass Solution {\\n    \\n    Stack<NestedInteger> stack = new Stack<>();\\n    NestedInteger ans = new NestedInteger();\\n    \\n    //for keeping at what index of string are we\\n    int index;\\n    \\n    /*since the string can also contain negative integers, we will have to keep track of sign */\\n    \\n    int sign;\\n\\n    //function provided by leetcode\\n    public NestedInteger deserialize(String s) {\\n        /* \\n            We will start traversing form the 1 index of the string, that is where \\n            a number would begin with.\\n            if a string begins with a number that means there is only one integer in\\n            it , becuase if there was a list ,it would begin with [\\n        */\\n        index = 1;\\n        sign = 1;  \\n        \\n        //checking if the list contains only one integer\\n        if(s.charAt(0)!=\\'[\\'){\\n            return new NestedInteger(Integer.parseInt(s));\\n        }\\n        \\n        myDeserialize(s);\\n        return ans;\\n    }\\n    \\n    \\n    /*Each time a call to myDerialize is called it means a nesting has taken place*/\\n    \\n    public void myDeserialize(String s){\\n        //just a safety check\\n        if(index >=s.length())return ;\\n        \\n        //initialize a new NestedInteger for this call\\n        NestedInteger newNI = new NestedInteger();\\n        \\n        /* if the stack is emtpy then we just push the current NI if not then\\n            we add the newly created NI to the last NI.\\n            [IMP] : The top of stack contains the current list always\\n        */\\n        if(stack.size()!=0)stack.peek().add(newNI);\\n        else{\\n            /*first time we create a NI , that is our answer, so we store it\\'s refrence*/\\n            \\n            ans = newNI;\\n        }\\n        //pushing current NI to top of the stack\\n        stack.push(newNI);\\n        \\n        //iterate till our string is over\\n        while(index<s.length()){\\n            char ch = s.charAt(index);\\n            /*\\n                if at some time [ is encountered a nesting is detected hence recursive call \\n            */\\n            if(ch==\\'[\\'){\\n                index++;\\n                myDeserialize(s);\\n            }\\n            \\n            /*  \\n                If ] is encountered that means current NI\\'s work is over , pop it from stack\\n            */\\n            else if (ch ==\\']\\'){\\n                index++;\\n                stack.pop();\\n            }\\n            //maintain the sign of the integer\\n            else if (ch ==\\'-\\'){\\n                sign = -1;\\n                index++;\\n            }\\n            //if comma , do nothing , just move forward \\n            else if(ch==\\',\\'){\\n                index++;\\n            }\\n            /*\\n                if a digit is encountered, then trverse till there are digits\\n                form a number , convert it into an integer and push the number\\n                in the current NI\\n            */\\n            else{\\n                //getting the current integer\\n                int endIndex = index;\\n                while(Character.isDigit(s.charAt(++endIndex)));\\n                String number_string = s.substring(index , endIndex);\\n                int number = sign*Integer.parseInt(number_string);\\n                stack.peek().add(new NestedInteger(number));\\n                sign = 1;\\n                index = endIndex;\\n            }\\n                \\n        }\\n        \\n    }\\n    \\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760454,
                "title": "java-clean-easy-to-read",
                "content": "```java\\npublic static class StringIterator {\\n        \\n\\tprivate final String s;\\n\\tprivate int i;\\n\\n\\tStringIterator(String s) {\\n\\t\\tthis.s = s;\\n\\t\\tthis.i = 0;\\n\\t}\\n\\n\\tpublic boolean hasNext() {\\n\\t\\treturn i < s.length();\\n\\t}\\n\\n\\tpublic char next() {\\n\\t\\tchar c = s.charAt(i);\\n\\t\\ti++;\\n\\t\\treturn c;\\n\\t}\\n\\n\\tpublic char peek() {\\n\\t\\treturn s.charAt(i);\\n\\t}\\n}\\n\\npublic NestedInteger deserialize(String s) {\\n\\treturn deserialize(new StringIterator(s)); \\n}\\n\\npublic NestedInteger deserialize(StringIterator iter) {\\n\\tchar c = iter.peek();\\n\\n\\tif (Character.isDigit(c) || c == \\'-\\') {\\n\\t\\treturn new NestedInteger(parseNumber(iter));\\n\\t}\\n\\n\\tNestedInteger nestedIntegerList = new NestedInteger();\\n\\t// If it doesn\\'t start with a number, it should start with a \\'[\\'\\n\\titer.next();\\n\\twhile (iter.hasNext()) {\\n\\t\\tc = iter.peek();\\n\\t\\tswitch (c) {\\n\\t\\t\\tcase \\']\\':\\n\\t\\t\\t\\titer.next();\\n\\t\\t\\t\\treturn nestedIntegerList;\\n\\t\\t\\tcase \\',\\':\\n\\t\\t\\t\\titer.next();\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tnestedIntegerList.add(deserialize(iter));\\n\\t\\t}\\n\\t}\\n\\treturn nestedIntegerList;\\n}\\n\\nprivate int parseNumber(StringIterator iter) {\\n\\tboolean isNegative = iter.peek() == \\'-\\';\\n\\tif (isNegative) {\\n\\t\\titer.next();\\n\\t}\\n\\tint value = 0;\\n\\n\\twhile (iter.hasNext() && Character.isDigit(iter.peek())) {\\n\\t\\tvalue *= 10;\\n\\t\\tvalue += (iter.next() - \\'0\\') * (isNegative ? -1 : 1);\\n\\t}\\n\\treturn value;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic static class StringIterator {\\n        \\n\\tprivate final String s;\\n\\tprivate int i;\\n\\n\\tStringIterator(String s) {\\n\\t\\tthis.s = s;\\n\\t\\tthis.i = 0;\\n\\t}\\n\\n\\tpublic boolean hasNext() {\\n\\t\\treturn i < s.length();\\n\\t}\\n\\n\\tpublic char next() {\\n\\t\\tchar c = s.charAt(i);\\n\\t\\ti++;\\n\\t\\treturn c;\\n\\t}\\n\\n\\tpublic char peek() {\\n\\t\\treturn s.charAt(i);\\n\\t}\\n}\\n\\npublic NestedInteger deserialize(String s) {\\n\\treturn deserialize(new StringIterator(s)); \\n}\\n\\npublic NestedInteger deserialize(StringIterator iter) {\\n\\tchar c = iter.peek();\\n\\n\\tif (Character.isDigit(c) || c == \\'-\\') {\\n\\t\\treturn new NestedInteger(parseNumber(iter));\\n\\t}\\n\\n\\tNestedInteger nestedIntegerList = new NestedInteger();\\n\\t// If it doesn\\'t start with a number, it should start with a \\'[\\'\\n\\titer.next();\\n\\twhile (iter.hasNext()) {\\n\\t\\tc = iter.peek();\\n\\t\\tswitch (c) {\\n\\t\\t\\tcase \\']\\':\\n\\t\\t\\t\\titer.next();\\n\\t\\t\\t\\treturn nestedIntegerList;\\n\\t\\t\\tcase \\',\\':\\n\\t\\t\\t\\titer.next();\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tnestedIntegerList.add(deserialize(iter));\\n\\t\\t}\\n\\t}\\n\\treturn nestedIntegerList;\\n}\\n\\nprivate int parseNumber(StringIterator iter) {\\n\\tboolean isNegative = iter.peek() == \\'-\\';\\n\\tif (isNegative) {\\n\\t\\titer.next();\\n\\t}\\n\\tint value = 0;\\n\\n\\twhile (iter.hasNext() && Character.isDigit(iter.peek())) {\\n\\t\\tvalue *= 10;\\n\\t\\tvalue += (iter.next() - \\'0\\') * (isNegative ? -1 : 1);\\n\\t}\\n\\treturn value;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729728,
                "title": "simple-java-solution",
                "content": "This seemed complicated at first, but as I implemented, I found that it is not that difficult.\\nOn the otherhand, as I said, I couldn\\'t figure out the solution very clearly before start to code, so I might fail if this was my coding question.\\n\\n```\\nclass Solution {    \\n    private boolean isDigit(char ch) {\\n        return ch >= \\'0\\' && ch <= \\'9\\';\\n    }\\n    \\n    public NestedInteger deserialize(String s) {\\n        if (!s.startsWith(\"[\")) {\\n            return new NestedInteger(Integer.valueOf(s));\\n        }\\n        \\n        Stack<NestedInteger> stk = new Stack<>();\\n        \\n        char[] chs = s.toCharArray();\\n        int ret = 0;\\n        int sign = 1;\\n        NestedInteger ni;\\n        for (int i = 0; i < chs.length; i++) {\\n            switch (chs[i]) {\\n                case \\'[\\':\\n                    ni = new NestedInteger();\\n                    if (stk.size() > 0) {\\n                        stk.peek().add(ni);\\n                    }\\n                    stk.push(ni);\\n                    break;\\n                case \\']\\':\\n                    ni = stk.pop();\\n                    if (isDigit(chs[i-1])) {\\n                        ni.add(new NestedInteger(ret * sign));\\n                        sign = 1;\\n                        ret = 0;\\n                    }\\n                    if (i == chs.length-1) {\\n                        return ni;\\n                    }\\n                    break;\\n                case \\'-\\':\\n                    sign = -1;\\n                    break;\\n                case \\',\\':\\n                    if (isDigit(chs[i-1])) {\\n                        stk.peek().add(new NestedInteger(ret * sign));\\n                        sign = 1;\\n                        ret = 0;\\n                    }\\n                    break;\\n                default:\\n                    ret = ret * 10 + (int) (chs[i]-\\'0\\');\\n            }\\n        }\\n        \\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {    \\n    private boolean isDigit(char ch) {\\n        return ch >= \\'0\\' && ch <= \\'9\\';\\n    }\\n    \\n    public NestedInteger deserialize(String s) {\\n        if (!s.startsWith(\"[\")) {\\n            return new NestedInteger(Integer.valueOf(s));\\n        }\\n        \\n        Stack<NestedInteger> stk = new Stack<>();\\n        \\n        char[] chs = s.toCharArray();\\n        int ret = 0;\\n        int sign = 1;\\n        NestedInteger ni;\\n        for (int i = 0; i < chs.length; i++) {\\n            switch (chs[i]) {\\n                case \\'[\\':\\n                    ni = new NestedInteger();\\n                    if (stk.size() > 0) {\\n                        stk.peek().add(ni);\\n                    }\\n                    stk.push(ni);\\n                    break;\\n                case \\']\\':\\n                    ni = stk.pop();\\n                    if (isDigit(chs[i-1])) {\\n                        ni.add(new NestedInteger(ret * sign));\\n                        sign = 1;\\n                        ret = 0;\\n                    }\\n                    if (i == chs.length-1) {\\n                        return ni;\\n                    }\\n                    break;\\n                case \\'-\\':\\n                    sign = -1;\\n                    break;\\n                case \\',\\':\\n                    if (isDigit(chs[i-1])) {\\n                        stk.peek().add(new NestedInteger(ret * sign));\\n                        sign = 1;\\n                        ret = 0;\\n                    }\\n                    break;\\n                default:\\n                    ret = ret * 10 + (int) (chs[i]-\\'0\\');\\n            }\\n        }\\n        \\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 647192,
                "title": "c-recursive-slution",
                "content": "```C++\\nNestedInteger deserialize(string s) {\\n        \\n        if (s.size() == 0) return NestedInteger();\\n        if (s[0] != \\'[\\') return NestedInteger(stoi(s));\\n        NestedInteger res;\\n        // comma split\\n        int cnt = 0, last = 1;\\n        for (int i=1; i<s.size()-1; i++) {\\n            if (s[i] == \\'[\\') cnt += 1;\\n            else if (s[i] == \\']\\')  cnt -= 1; \\n            else if (s[i] == \\',\\' && cnt == 0) {\\n                    string seg = s.substr(last, i - last);\\n                    res.add(deserialize(seg));\\n                    last = i + 1;\\n            }\\n        }\\n        \\n        if (s.size()-1-last > 0) {\\n            string seg = s.substr(last, s.size()-1-last);\\n            res.add(deserialize(seg));\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```C++\\nNestedInteger deserialize(string s) {\\n        \\n        if (s.size() == 0) return NestedInteger();\\n        if (s[0] != \\'[\\') return NestedInteger(stoi(s));\\n        NestedInteger res;\\n        // comma split\\n        int cnt = 0, last = 1;\\n        for (int i=1; i<s.size()-1; i++) {\\n            if (s[i] == \\'[\\') cnt += 1;\\n            else if (s[i] == \\']\\')  cnt -= 1; \\n            else if (s[i] == \\',\\' && cnt == 0) {\\n                    string seg = s.substr(last, i - last);\\n                    res.add(deserialize(seg));\\n                    last = i + 1;\\n            }\\n        }\\n        \\n        if (s.size()-1-last > 0) {\\n            string seg = s.substr(last, s.size()-1-last);\\n            res.add(deserialize(seg));\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 612603,
                "title": "java-recursive-solution-with-full-explanation",
                "content": "Since the question mentions *nested* structure, use of recursion is necessary.\\n\\nAlso, it\\'s mentioned that the element is *either an integer or list of NestedIntegers*. So, **the base-case will be, the string which does not start with \\'[\\'.** - which means, the nested integer contains only one integer.\\n\\nNow we have got our base-case, let\\'s focus on how we can recurse. \\n* if the base-condition is not satisfied, that means, what we have a serialized version of *list of nested integers.* And such a list will always be enclosed with `[` and `]`. So, get rid of it.\\n* Process individual elements separated by `,` and deserialize them recursively.\\n* Also, if we encounter a nested integer in between, use a stack to get the last `]` for that element and process that nested integer separately through recursion. \\n\\nFor example, let\\'s take a complicated string as below:\\n```\\n\"[123,456,[788,799,833],[[]],10,[]]\"\\n```\\n\\nClearly, the given string won\\'t satisfy the base condition. So, getting rid of surrounding brackets, the string becomes\\n```\\n\"123,456,[788,799,833],[[]],10,[]\"\\n```\\n\\nAfter that, extract individual elements of this outer-most nested integer.\\n\\n```\\n\"123\" // this will satisfy the base-condition in the next recursion call\\n```\\n```\\n\"456\" // this will satisfy the base-condition in the next recursion call\\n```\\n```\\n\"[788,799,833]\" // use stack to extract the perfect nested integer enclosed between brackets\\n```\\n```\\n\"[[]]\" // use stack to extract the perfect nested integer enclosed between outer brackets\\n```\\n\\n```\\n\"10\" // this will satisfy the base-condition in the next recursion call\\n```\\n\\n```\\n[] // use stack to extract the perfect nested integer enclosed between outer brackets\\n```\\n\\nThe **Java** implementation for this approach is:\\n\\n```\\npublic NestedInteger deserialize(String s) {\\n\\tNestedInteger res = new NestedInteger();\\n\\tif (s.charAt(0) != \\'[\\') {\\n\\t\\tint num  = Integer.parseInt(s);\\n\\t\\tres.setInteger(num);\\n\\t\\treturn res;\\n\\n\\t}\\n\\n\\ts = s.substring(1, s.length() - 1);\\n\\tif (s.isEmpty()) {\\n\\t\\treturn new NestedInteger();\\n\\n\\t} else {\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tif (s.charAt(i) == \\'[\\') {\\n\\t\\t\\t\\tStack<Character> stack = new Stack<>();\\n\\t\\t\\t\\tstack.push(s.charAt(i));\\n\\t\\t\\t\\tint j = i+1;\\n\\t\\t\\t\\twhile (j < s.length() && !stack.isEmpty()) {\\n\\t\\t\\t\\t\\tif (s.charAt(j) == \\'[\\') {\\n\\t\\t\\t\\t\\t\\tstack.push(\\'[\\');\\n\\t\\t\\t\\t\\t} else if (s.charAt(j) == \\']\\') {\\n\\t\\t\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t++j;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tres.add(deserialize(s.substring(i, j)));\\n\\t\\t\\t\\ti = j;\\n\\t\\t\\t} else if (s.charAt(i) == \\',\\') {\\n\\t\\t\\t\\tres.add(deserialize(sb.toString()));\\n\\t\\t\\t\\tsb = new StringBuilder();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsb.append(s.charAt(i));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (sb.length() != 0) {\\n\\t\\t\\tres.add(deserialize(sb.toString()));\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n\"[123,456,[788,799,833],[[]],10,[]]\"\\n```\n```\\n\"123,456,[788,799,833],[[]],10,[]\"\\n```\n```\\n\"123\" // this will satisfy the base-condition in the next recursion call\\n```\n```\\n\"456\" // this will satisfy the base-condition in the next recursion call\\n```\n```\\n\"[788,799,833]\" // use stack to extract the perfect nested integer enclosed between brackets\\n```\n```\\n\"[[]]\" // use stack to extract the perfect nested integer enclosed between outer brackets\\n```\n```\\n\"10\" // this will satisfy the base-condition in the next recursion call\\n```\n```\\n[] // use stack to extract the perfect nested integer enclosed between outer brackets\\n```\n```\\npublic NestedInteger deserialize(String s) {\\n\\tNestedInteger res = new NestedInteger();\\n\\tif (s.charAt(0) != \\'[\\') {\\n\\t\\tint num  = Integer.parseInt(s);\\n\\t\\tres.setInteger(num);\\n\\t\\treturn res;\\n\\n\\t}\\n\\n\\ts = s.substring(1, s.length() - 1);\\n\\tif (s.isEmpty()) {\\n\\t\\treturn new NestedInteger();\\n\\n\\t} else {\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tif (s.charAt(i) == \\'[\\') {\\n\\t\\t\\t\\tStack<Character> stack = new Stack<>();\\n\\t\\t\\t\\tstack.push(s.charAt(i));\\n\\t\\t\\t\\tint j = i+1;\\n\\t\\t\\t\\twhile (j < s.length() && !stack.isEmpty()) {\\n\\t\\t\\t\\t\\tif (s.charAt(j) == \\'[\\') {\\n\\t\\t\\t\\t\\t\\tstack.push(\\'[\\');\\n\\t\\t\\t\\t\\t} else if (s.charAt(j) == \\']\\') {\\n\\t\\t\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t++j;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tres.add(deserialize(s.substring(i, j)));\\n\\t\\t\\t\\ti = j;\\n\\t\\t\\t} else if (s.charAt(i) == \\',\\') {\\n\\t\\t\\t\\tres.add(deserialize(sb.toString()));\\n\\t\\t\\t\\tsb = new StringBuilder();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsb.append(s.charAt(i));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (sb.length() != 0) {\\n\\t\\t\\tres.add(deserialize(sb.toString()));\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 584774,
                "title": "python-iterative",
                "content": "```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        \\n        if (len(s) == 0):\\n            return NestedInteger()\\n        elif (s[0] != \\'[\\'):\\n            return NestedInteger(int(s))\\n        \\n        number=\\'\\'\\n        stack = [NestedInteger()]\\n        \\n        for char in s:\\n            if char.isdigit() or char==\\'-\\':\\n                number += char\\n            elif char == \\',\\':\\n                if (number):\\n                    stack[-1].add(NestedInteger(int(number)))\\n                    number=\\'\\'\\n            elif char == \\'[\\':\\n                stack.append(NestedInteger())\\n            else:\\n                if (number):\\n                    stack[-1].add(NestedInteger(int(number)))\\n                    number=\\'\\'\\n                haha = stack.pop()\\n                stack[-1].add(haha);\\n        \\n        ans = stack[0]\\n        return ans.getList()[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        \\n        if (len(s) == 0):\\n            return NestedInteger()\\n        elif (s[0] != \\'[\\'):\\n            return NestedInteger(int(s))\\n        \\n        number=\\'\\'\\n        stack = [NestedInteger()]\\n        \\n        for char in s:\\n            if char.isdigit() or char==\\'-\\':\\n                number += char\\n            elif char == \\',\\':\\n                if (number):\\n                    stack[-1].add(NestedInteger(int(number)))\\n                    number=\\'\\'\\n            elif char == \\'[\\':\\n                stack.append(NestedInteger())\\n            else:\\n                if (number):\\n                    stack[-1].add(NestedInteger(int(number)))\\n                    number=\\'\\'\\n                haha = stack.pop()\\n                stack[-1].add(haha);\\n        \\n        ans = stack[0]\\n        return ans.getList()[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566892,
                "title": "java-solution-uses-recursive",
                "content": "case 1: s = \"123\" -> 123\\ncase 2: [] -> return new NestedInteger()\\ncase 3: [123, 456, 789, [1, 2, 3], [4, 5, 6]]\\n\\n```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        NestedInteger res = new NestedInteger();\\n        if (s == null || s.length() == 0) return res;\\n        if (s.charAt(0) != \\'[\\') { // case 1\\n            res.setInteger(Integer.parseInt(s));\\n            return res;\\n        }\\n        if (s.length() <= 2) return res; // case 2 \\n        int start = 1, count = 0;\\n        for (int i = 1; i < s.length(); i++) { // case 3\\n            char c = s.charAt(i);\\n            if (count == 0 && (c == \\',\\' || i == s.length() - 1)) {\\n                res.add(deserialize(s.substring(start, i)));\\n                start = i + 1;\\n            } else if (c == \\'[\\') count++;\\n            else if (c == \\']\\') count--;\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        NestedInteger res = new NestedInteger();\\n        if (s == null || s.length() == 0) return res;\\n        if (s.charAt(0) != \\'[\\') { // case 1\\n            res.setInteger(Integer.parseInt(s));\\n            return res;\\n        }\\n        if (s.length() <= 2) return res; // case 2 \\n        int start = 1, count = 0;\\n        for (int i = 1; i < s.length(); i++) { // case 3\\n            char c = s.charAt(i);\\n            if (count == 0 && (c == \\',\\' || i == s.length() - 1)) {\\n                res.add(deserialize(s.substring(start, i)));\\n                start = i + 1;\\n            } else if (c == \\'[\\') count++;\\n            else if (c == \\']\\') count--;\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537858,
                "title": "java-29-27-time-30-space-iterative-w-stack",
                "content": "````\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        if(!s.startsWith(\"[\"))return new NestedInteger(Integer.valueOf(s));\\n        Stack<NestedInteger> st=new Stack<NestedInteger>();\\n        NestedInteger res = new NestedInteger();\\n        st.push(res);\\n        int start=1;\\n        for(int i=1;i<s.length();i++){\\n            if(s.charAt(i)==\\'[\\'){\\n                NestedInteger cur=new NestedInteger();\\n                st.peek().add(cur);\\n                st.push(cur);\\n                start=i+1;\\n            }else if(s.charAt(i)==\\']\\' || s.charAt(i)==\\',\\'){\\n                if(start<i){\\n                    int end=i;\\n                    String n=s.substring(start,end);\\n                    st.peek().add(new NestedInteger(Integer.valueOf(n)));\\n                }\\n                start=i+1;\\n                if(s.charAt(i)==\\']\\')st.pop();\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public NestedInteger deserialize(String s) {\\n        if(!s.startsWith(\"[\"))return new NestedInteger(Integer.valueOf(s));\\n        Stack<NestedInteger> st=new Stack<NestedInteger>();\\n        NestedInteger res = new NestedInteger();\\n        st.push(res);\\n        int start=1;\\n        for(int i=1;i<s.length();i++){\\n            if(s.charAt(i)==\\'[\\'){\\n                NestedInteger cur=new NestedInteger();\\n                st.peek().add(cur);\\n                st.push(cur);\\n                start=i+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 482435,
                "title": "swift-solution-using-stack",
                "content": "```\\nclass Solution {\\n    func deserialize(_ s: String) -> NestedInteger {\\n        var stack:[NestedInteger] = []\\n        var current:NestedInteger = NestedInteger()\\n        let head = current\\n        var currentItem = \"\"\\n        var negative = false\\n        for item in s{\\n            if item == \"[\"{\\n                let nItem = NestedInteger()\\n                stack.append(current)\\n                current = nItem\\n            }else if item == \"]\"{\\n                if let number = Int(currentItem) {\\n                    let nItem = NestedInteger()\\n                    nItem.setInteger(negative == false ? number : number * -1)\\n                    current.add(nItem)\\n                    currentItem = \"\"\\n                    negative = false\\n                }\\n                let lastItem = stack.popLast()!\\n                lastItem.add(current)\\n                current = lastItem\\n                \\n            }else if item == \",\"{\\n                if let number = Int(currentItem) {\\n                    let nItem = NestedInteger()\\n                    nItem.setInteger(negative == false ? number : number * -1)\\n                    current.add(nItem)\\n                    currentItem = \"\"\\n                    negative = false\\n                }\\n            }else if let digit = Int(String(item)){\\n                currentItem += String(item)\\n            }else if item == \"-\"{\\n                negative = true\\n            }\\n        }\\n        if let number = Int(currentItem) {\\n            let nItem = NestedInteger()\\n            nItem.setInteger(negative == false ? number : number * -1)\\n            current.add(nItem)\\n            currentItem = \"\"\\n        }\\n        return head.getList().first!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    func deserialize(_ s: String) -> NestedInteger {\\n        var stack:[NestedInteger] = []\\n        var current:NestedInteger = NestedInteger()\\n        let head = current\\n        var currentItem = \"\"\\n        var negative = false\\n        for item in s{\\n            if item == \"[\"{\\n                let nItem = NestedInteger()\\n                stack.append(current)\\n                current = nItem\\n            }else if item == \"]\"{\\n                if let number = Int(currentItem) {\\n                    let nItem = NestedInteger()\\n                    nItem.setInteger(negative == false ? number : number * -1)\\n                    current.add(nItem)\\n                    currentItem = \"\"\\n                    negative = false\\n                }\\n                let lastItem = stack.popLast()!\\n                lastItem.add(current)\\n                current = lastItem\\n                \\n            }else if item == \",\"{\\n                if let number = Int(currentItem) {\\n                    let nItem = NestedInteger()\\n                    nItem.setInteger(negative == false ? number : number * -1)\\n                    current.add(nItem)\\n                    currentItem = \"\"\\n                    negative = false\\n                }\\n            }else if let digit = Int(String(item)){\\n                currentItem += String(item)\\n            }else if item == \"-\"{\\n                negative = true\\n            }\\n        }\\n        if let number = Int(currentItem) {\\n            let nItem = NestedInteger()\\n            nItem.setInteger(negative == false ? number : number * -1)\\n            current.add(nItem)\\n            currentItem = \"\"\\n        }\\n        return head.getList().first!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468761,
                "title": "python-solution-to-parse-the-input-string-into-a-native-nested-list-in-python",
                "content": "Not sure why we need a NestedInteger type in python since python could already represent such values.  The parse step and creation of NestedInteger could be combined into one step.\\n\\n```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        if s[0].isdigit():\\n            return NestedInteger(int(s))\\n        lis = parse_list_expression(s)\\n        res = helper(lis)\\n        return res\\n        \\ndef helper(x):\\n    if type(x) is int:\\n        return NestedInteger(x)\\n    res = NestedInteger()\\n    for e in x:\\n        res.add(helper(e))\\n    return res\\n        \\ndef parse_list_expression(s):\\n        lis = []\\n        for c in s:\\n                if c == \\'[\\':\\n                        if lis and lis[-1] == \\',\\':\\n                                lis.pop()\\n                        lis.append(c)\\n                elif c == \\'-\\':\\n                        if lis and lis[-1] == \\',\\':\\n                                lis.pop()\\n                        lis.append(c)\\n                elif c == \\',\\':\\n                        lis.append(c)\\n                elif c.isdigit():\\n                        process_digit(lis, c)\\n                elif c == \\']\\':\\n                        process_list(lis)\\n        return lis[0]\\n    \\ndef process_digit(lis, c):\\n        x = lis[-1]\\n        c = int(c)\\n        if x == \\'-\\':\\n                lis[-1] = -c\\n        elif x== \\',\\':\\n                lis[-1] = c\\n        elif x == \\'[\\':\\n                lis.append(c)\\n        elif type(x) is int:\\n                if x >= 0:\\n                        lis[-1] = 10*x + c\\n                else:\\n                        lis[-1] = 10*x - c\\n\\ndef process_list(lis):\\n        res = []\\n        while lis[-1] != \\'[\\':\\n                res.append(lis.pop())\\n        lis.pop()\\n        lis.append(res[::-1])\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        if s[0].isdigit():\\n            return NestedInteger(int(s))\\n        lis = parse_list_expression(s)\\n        res = helper(lis)\\n        return res\\n        \\ndef helper(x):\\n    if type(x) is int:\\n        return NestedInteger(x)\\n    res = NestedInteger()\\n    for e in x:\\n        res.add(helper(e))\\n    return res\\n        \\ndef parse_list_expression(s):\\n        lis = []\\n        for c in s:\\n                if c == \\'[\\':\\n                        if lis and lis[-1] == \\',\\':\\n                                lis.pop()\\n                        lis.append(c)\\n                elif c == \\'-\\':\\n                        if lis and lis[-1] == \\',\\':\\n                                lis.pop()\\n                        lis.append(c)\\n                elif c == \\',\\':\\n                        lis.append(c)\\n                elif c.isdigit():\\n                        process_digit(lis, c)\\n                elif c == \\']\\':\\n                        process_list(lis)\\n        return lis[0]\\n    \\ndef process_digit(lis, c):\\n        x = lis[-1]\\n        c = int(c)\\n        if x == \\'-\\':\\n                lis[-1] = -c\\n        elif x== \\',\\':\\n                lis[-1] = c\\n        elif x == \\'[\\':\\n                lis.append(c)\\n        elif type(x) is int:\\n                if x >= 0:\\n                        lis[-1] = 10*x + c\\n                else:\\n                        lis[-1] = 10*x - c\\n\\ndef process_list(lis):\\n        res = []\\n        while lis[-1] != \\'[\\':\\n                res.append(lis.pop())\\n        lis.pop()\\n        lis.append(res[::-1])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 450653,
                "title": "java-straightforward-stack-solution",
                "content": "```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        Deque<NestedInteger> stack = new ArrayDeque<>();\\n        int i = 0;\\n        while (i < s.length()) {\\n            if (s.charAt(i) == \\'[\\') {\\n                stack.push(new NestedInteger());\\n                i++;\\n            } else if (s.charAt(i) == \\',\\') {\\n                i++;\\n            } else if (s.charAt(i) == \\']\\') {\\n                NestedInteger last = stack.pop();\\n                if (stack.isEmpty()) {\\n                    return last;\\n                }\\n                stack.peek().add(last);\\n                i++;\\n            } else { // isDigit or -\\n                boolean negative = s.charAt(i) == \\'-\\';\\n                int count = 0;\\n                if (negative) {\\n                    i++;\\n                }\\n                while (i < s.length() && Character.isDigit(s.charAt(i))) {\\n                    count = count * 10 + s.charAt(i) - \\'0\\';\\n                    i++;\\n                }\\n                if (negative) {\\n                    count = -count;\\n                }\\n                if (i >= s.length()) {\\n                    return new NestedInteger(count);\\n                }\\n                stack.peek().add(new NestedInteger(count));\\n            }\\n        }\\n        return null;\\n    }\\n}\\n\\n/*\\nif we found [ : push a NestList into stack (isList)\\nif we found a number: record down the number (), and add it to list of last element in the stack\\nif we found a , : i++\\nif we found a ] : push last integer into stack top pop stack top, and add the number to second stack top, or return if stack is empty.\\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        Deque<NestedInteger> stack = new ArrayDeque<>();\\n        int i = 0;\\n        while (i < s.length()) {\\n            if (s.charAt(i) == \\'[\\') {\\n                stack.push(new NestedInteger());\\n                i++;\\n            } else if (s.charAt(i) == \\',\\') {\\n                i++;\\n            } else if (s.charAt(i) == \\']\\') {\\n                NestedInteger last = stack.pop();\\n                if (stack.isEmpty()) {\\n                    return last;\\n                }\\n                stack.peek().add(last);\\n                i++;\\n            } else { // isDigit or -\\n                boolean negative = s.charAt(i) == \\'-\\';\\n                int count = 0;\\n                if (negative) {\\n                    i++;\\n                }\\n                while (i < s.length() && Character.isDigit(s.charAt(i))) {\\n                    count = count * 10 + s.charAt(i) - \\'0\\';\\n                    i++;\\n                }\\n                if (negative) {\\n                    count = -count;\\n                }\\n                if (i >= s.length()) {\\n                    return new NestedInteger(count);\\n                }\\n                stack.peek().add(new NestedInteger(count));\\n            }\\n        }\\n        return null;\\n    }\\n}\\n\\n/*\\nif we found [ : push a NestList into stack (isList)\\nif we found a number: record down the number (), and add it to list of last element in the stack\\nif we found a , : i++\\nif we found a ] : push last integer into stack top pop stack top, and add the number to second stack top, or return if stack is empty.\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 403379,
                "title": "recursive-solution-written-in-c",
                "content": "this problem is very similiar to [pasring a boolean expression](https://leetcode.com/problems/parsing-a-boolean-expression/discuss/325228/C%2B%2B-Polish-Notation), so we can use the same method. use a cnt to count the number of parenthesis, and to check whether a coma could split a NestedInteger object\\n```\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        NestedInteger res;\\n        \\n        if(s == \"[]\"){\\n            return res;\\n        }\\n        \\n        if(s[0] != \\'[\\'){\\n            res.setInteger(stoi(s));\\n            return res;\\n        }\\n        int cnt = 0;\\n        for(int i = 1, j = 1; i < s.size(); i++){\\n            if(s[i] == \\'[\\') cnt++;\\n            if(s[i] == \\']\\') cnt--;\\n            if(i==s.size()-1 || (s[i]==\\',\\' && cnt==0)){\\n                res.add(deserialize(s.substr(j, i-j)));\\n                j = i+1;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        NestedInteger res;\\n        \\n        if(s == \"[]\"){\\n            return res;\\n        }\\n        \\n        if(s[0] != \\'[\\'){\\n            res.setInteger(stoi(s));\\n            return res;\\n        }\\n        int cnt = 0;\\n        for(int i = 1, j = 1; i < s.size(); i++){\\n            if(s[i] == \\'[\\') cnt++;\\n            if(s[i] == \\']\\') cnt--;\\n            if(i==s.size()-1 || (s[i]==\\',\\' && cnt==0)){\\n                res.add(deserialize(s.substr(j, i-j)));\\n                j = i+1;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382022,
                "title": "simple-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    int i = 0;\\n    public NestedInteger deserialize(String s) {\\n        return dfs(s).getList().get(0);\\n    }\\n    \\n    public NestedInteger dfs(String s) {\\n        NestedInteger res = new NestedInteger();        \\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c) || c == \\'-\\') {\\n                StringBuilder num = new StringBuilder();\\n                num.append(c);\\n                while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1))) {\\n                    num.append(s.charAt(i + 1));\\n                    i++;\\n                }\\n                i++;\\n                res.add(new NestedInteger(Integer.parseInt(num.toString())));\\n            } else if (c == \\'[\\') {\\n                i = i + 1;\\n                NestedInteger next = dfs(s);\\n                res.add(next);\\n            } else if (c == \\']\\') {\\n                i = i + 1;\\n                break;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int i = 0;\\n    public NestedInteger deserialize(String s) {\\n        return dfs(s).getList().get(0);\\n    }\\n    \\n    public NestedInteger dfs(String s) {\\n        NestedInteger res = new NestedInteger();        \\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c) || c == \\'-\\') {\\n                StringBuilder num = new StringBuilder();\\n                num.append(c);\\n                while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1))) {\\n                    num.append(s.charAt(i + 1));\\n                    i++;\\n                }\\n                i++;\\n                res.add(new NestedInteger(Integer.parseInt(num.toString())));\\n            } else if (c == \\'[\\') {\\n                i = i + 1;\\n                NestedInteger next = dfs(s);\\n                res.add(next);\\n            } else if (c == \\']\\') {\\n                i = i + 1;\\n                break;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340851,
                "title": "simple-java-solution-for-slow-learners-like-myself-with-comments-4ms",
                "content": "```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        if (s == null || \"\".equals(s)) \\n\\t\\t\\treturn null;\\n        if (!isEnclosed(s)) \\n\\t\\t\\treturn new NestedInteger(Integer.parseInt(s)); //if not enclosed its number so simply parse out result\\n\\n        NestedInteger root = new NestedInteger();\\n        s = s.substring(1, s.length() - 1); //strip out outer most layer\\n        int i = 0;\\n        while (i < s.length()) {\\n            //if we encounter comma, skip as this means nothing\\n            if (s.charAt(i) == \\',\\') {\\n                i++;\\n                continue;\\n            }\\n            boolean isNumber = Character.isDigit(s.charAt(i)) || s.charAt(i) == \\'-\\';\\n            int end = isNumber ? getNumberEnd(s, i) : getBracketEnd(s, i);\\n            //if it is number, simply parse the number and add it to the current list\\n            if (isNumber) \\n\\t\\t\\t\\troot.add(new NestedInteger(Integer.parseInt(s.substring(i, end))));\\n            //since we encountered a bracket, find the end of the bracket, and the recursive result to the current list\\n            else \\n\\t\\t\\t\\troot.add(deserialize(s.substring(i, end)));\\n            //advance i to the end as we are done processing the current block\\n            i = end;\\n        }\\n        return root;\\n    }\\n    \\n    private int getBracketEnd(String s, int start) {\\n        int open = 0, close = 0;\\n        while (start < s.length()) {\\n            if (s.charAt(start) == \\'[\\') \\n\\t\\t\\t\\topen++;\\n            else if (s.charAt(start) == \\']\\') \\n\\t\\t\\t\\topen--;\\n            if (open == 0 && close == 0) \\n\\t\\t\\t\\tbreak; //all the brackets i care about is closed at this point   \\n            start++;\\n        }\\n        return start + 1;\\n    }\\n    \\n    private int getNumberEnd(String s, int start) {\\n        while (start < s.length()) {\\n            if (s.charAt(start) == \\',\\') \\n\\t\\t\\t\\tbreak;\\n            start++;\\n        }\\n        return start;\\n    }\\n    \\n    private boolean isEnclosed(String s) {\\n        return s.charAt(0) == \\'[\\';\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        if (s == null || \"\".equals(s)) \\n\\t\\t\\treturn null;\\n        if (!isEnclosed(s)) \\n\\t\\t\\treturn new NestedInteger(Integer.parseInt(s)); //if not enclosed its number so simply parse out result\\n\\n        NestedInteger root = new NestedInteger();\\n        s = s.substring(1, s.length() - 1); //strip out outer most layer\\n        int i = 0;\\n        while (i < s.length()) {\\n            //if we encounter comma, skip as this means nothing\\n            if (s.charAt(i) == \\',\\') {\\n                i++;\\n                continue;\\n            }\\n            boolean isNumber = Character.isDigit(s.charAt(i)) || s.charAt(i) == \\'-\\';\\n            int end = isNumber ? getNumberEnd(s, i) : getBracketEnd(s, i);\\n            //if it is number, simply parse the number and add it to the current list\\n            if (isNumber) \\n\\t\\t\\t\\troot.add(new NestedInteger(Integer.parseInt(s.substring(i, end))));\\n            //since we encountered a bracket, find the end of the bracket, and the recursive result to the current list\\n            else \\n\\t\\t\\t\\troot.add(deserialize(s.substring(i, end)));\\n            //advance i to the end as we are done processing the current block\\n            i = end;\\n        }\\n        return root;\\n    }\\n    \\n    private int getBracketEnd(String s, int start) {\\n        int open = 0, close = 0;\\n        while (start < s.length()) {\\n            if (s.charAt(start) == \\'[\\') \\n\\t\\t\\t\\topen++;\\n            else if (s.charAt(start) == \\']\\') \\n\\t\\t\\t\\topen--;\\n            if (open == 0 && close == 0) \\n\\t\\t\\t\\tbreak; //all the brackets i care about is closed at this point   \\n            start++;\\n        }\\n        return start + 1;\\n    }\\n    \\n    private int getNumberEnd(String s, int start) {\\n        while (start < s.length()) {\\n            if (s.charAt(start) == \\',\\') \\n\\t\\t\\t\\tbreak;\\n            start++;\\n        }\\n        return start;\\n    }\\n    \\n    private boolean isEnclosed(String s) {\\n        return s.charAt(0) == \\'[\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292002,
                "title": "recursive-python-solution",
                "content": "```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        if not s:\\n            return NestedInteger()\\n        if s[0] != \"[\":\\n            return int(s)\\n        s,temp,memo,i = s[1:-1], NestedInteger(),\"1234567890-\",0\\n        while i < len(s):\\n            if s[i] in memo:\\n                d = \"\"\\n                while i < len(s) and s[i] in memo:\\n                    d += s[i]\\n                    i += 1\\n                temp.add(int(d))\\n            elif s[i] == \"[\":\\n                l,r,t = 0,0,\"\"\\n                while 1:\\n                    t += s[i]\\n                    if s[i] == \"[\":\\n                        l += 1\\n                    if s[i] == \"]\":\\n                        r += 1\\n                    if l == r:\\n                        break\\n                    i += 1\\n                temp.add(self.deserialize(t))\\n            i += 1\\n        return temp",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        if not s:\\n            return NestedInteger()\\n        if s[0] != \"[\":\\n            return int(s)\\n        s,temp,memo,i = s[1:-1], NestedInteger(),\"1234567890-\",0\\n        while i < len(s):\\n            if s[i] in memo:\\n                d = \"\"\\n                while i < len(s) and s[i] in memo:\\n                    d += s[i]\\n                    i += 1\\n                temp.add(int(d))\\n            elif s[i] == \"[\":\\n                l,r,t = 0,0,\"\"\\n                while 1:\\n                    t += s[i]\\n                    if s[i] == \"[\":\\n                        l += 1\\n                    if s[i] == \"]\":\\n                        r += 1\\n                    if l == r:\\n                        break\\n                    i += 1\\n                temp.add(self.deserialize(t))\\n            i += 1\\n        return temp",
                "codeTag": "Java"
            },
            {
                "id": 132485,
                "title": "simple-fast-python",
                "content": "```\\nclass Solution(object):\\n    def deserialize(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: NestedInteger\\n        \"\"\"\\n        \\n        if s[0]!=\\'[\\': return NestedInteger(int(s))\\n        \\n        stack=[NestedInteger()]\\n        num=\\'\\'\\n        for i in s:\\n            if i==\\'[\\': \\n                stack.append(NestedInteger())\\n            elif i==\\']\\':\\n                if num:\\n                    stack[-1].add(int(num))\\n                num=\\'\\'\\n                buf=stack.pop()\\n                stack[-1].add(buf)\\n            elif i==\\',\\':\\n                if num:\\n                    stack[-1].add(int(num))\\n                num=\\'\\'\\n            else:\\n                num+=i\\n        \\n        return stack[0].getList()[0]\\n        ",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def deserialize(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: NestedInteger\\n        \"\"\"\\n        \\n        if s[0]!=\\'[\\': return NestedInteger(int(s))\\n        \\n        stack=[NestedInteger()]\\n        num=\\'\\'\\n        for i in s:\\n            if i==\\'[\\': \\n                stack.append(NestedInteger())\\n            elif i==\\']\\':\\n                if num:\\n                    stack[-1].add(int(num))\\n                num=\\'\\'\\n                buf=stack.pop()\\n                stack[-1].add(buf)\\n            elif i==\\',\\':\\n                if num:\\n                    stack[-1].add(int(num))\\n                num=\\'\\'\\n            else:\\n                num+=i\\n        \\n        return stack[0].getList()[0]\\n        ",
                "codeTag": "Java"
            },
            {
                "id": 128870,
                "title": "java-solution",
                "content": "```\\npublic class Solution {\\n\\n\\tpublic NestedInteger deserialize(String s) {\\n\\t\\tint len = s.length();\\n\\t\\tif (!s.startsWith(\"[\")) {\\n\\t\\t\\tNestedInteger ni = new NestedInteger(Integer.parseInt(s));\\n\\t\\t\\treturn ni;\\n\\t\\t}\\n\\t\\tNestedInteger root = new NestedInteger();\\n\\t\\tStack<NestedInteger> stack = new Stack<>();\\n\\t\\tstack.push(root);\\n\\t\\tfor (int i = 1; i < len - 1; i++) {\\n\\t\\t\\tchar c = s.charAt(i);\\n\\t\\t\\tif (c == \\'[\\') {\\n\\t\\t\\t\\tNestedInteger ni = new NestedInteger();\\n\\t\\t\\t\\tstack.peek().add(ni);\\n\\t\\t\\t\\tstack.push(ni);\\n\\t\\t\\t} else if (c == \\',\\') {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else if (c == \\']\\') {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint start = i;\\n\\t\\t\\t\\twhile (i < len - 1 && s.charAt(i + 1) >= \\'0\\' && s.charAt(i + 1) <= \\'9\\') {\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint end = i;\\n\\t\\t\\t\\tstack.peek().add(new NestedInteger(Integer.parseInt(s.substring(start, end + 1))));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn stack.pop();\\n\\t}\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n\\tpublic NestedInteger deserialize(String s) {\\n\\t\\tint len = s.length();\\n\\t\\tif (!s.startsWith(\"[\")) {\\n\\t\\t\\tNestedInteger ni = new NestedInteger(Integer.parseInt(s));\\n\\t\\t\\treturn ni;\\n\\t\\t}\\n\\t\\tNestedInteger root = new NestedInteger();\\n\\t\\tStack<NestedInteger> stack = new Stack<>();\\n\\t\\tstack.push(root);\\n\\t\\tfor (int i = 1; i < len - 1; i++) {\\n\\t\\t\\tchar c = s.charAt(i);\\n\\t\\t\\tif (c == \\'[\\') {\\n\\t\\t\\t\\tNestedInteger ni = new NestedInteger();\\n\\t\\t\\t\\tstack.peek().add(ni);\\n\\t\\t\\t\\tstack.push(ni);\\n\\t\\t\\t} else if (c == \\',\\') {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else if (c == \\']\\') {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint start = i;\\n\\t\\t\\t\\twhile (i < len - 1 && s.charAt(i + 1) >= \\'0\\' && s.charAt(i + 1) <= \\'9\\') {\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint end = i;\\n\\t\\t\\t\\tstack.peek().add(new NestedInteger(Integer.parseInt(s.substring(start, end + 1))));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn stack.pop();\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111876,
                "title": "very-short-and-simple-python-solution",
                "content": "```\\nreturn eval(s)\\n```",
                "solutionTags": [],
                "code": "```\\nreturn eval(s)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86095,
                "title": "really-easy-to-understand-java-19ms-recursive-solution-without-stack-beats-82-59",
                "content": "```\\npublic NestedInteger deserialize(String s) {\\n        NestedInteger res = new NestedInteger();\\n        if (s.length() == 0) return res;\\n        if (s.charAt(0) != '[') {\\n            res.setInteger(Integer.parseInt(s));\\n            return res;\\n        }\\n        helper(res, s);\\n        return res;\\n    }\\n    \\n    public void helper(NestedInteger res, String s) {\\n        for (int i = 1; i < s.length() - 1; ++i) {\\n            if (s.charAt(i) == '[') {\\n                int start = i;\\n                int count = 1;\\n                while (count != 0) {\\n                    i++;\\n                    if (s.charAt(i) == ']') count--;\\n                    if (s.charAt(i) == '[') count++;\\n                }\\n                NestedInteger temp = new NestedInteger();\\n                helper(temp, s.substring(start, i + 1));\\n                res.add(temp);\\n            }\\n            if (Character.isDigit(s.charAt(i)) || s.charAt(i) == '-') {\\n                int start = i;\\n                while (s.charAt(i) != ',' && s.charAt(i) != ']') i += 1;\\n                res.add(new NestedInteger(Integer.parseInt(s.substring(start, i))));\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "```\\npublic NestedInteger deserialize(String s) {\\n        NestedInteger res = new NestedInteger();\\n        if (s.length() == 0) return res;\\n        if (s.charAt(0) != '[') {\\n            res.setInteger(Integer.parseInt(s));\\n            return res;\\n        }\\n        helper(res, s);\\n        return res;\\n    }\\n    \\n    public void helper(NestedInteger res, String s) {\\n        for (int i = 1; i < s.length() - 1; ++i) {\\n            if (s.charAt(i) == '[') {\\n                int start = i;\\n                int count = 1;\\n                while (count != 0) {\\n                    i++;\\n                    if (s.charAt(i) == ']') count--;\\n                    if (s.charAt(i) == '[') count++;\\n                }\\n                NestedInteger temp = new NestedInteger();\\n                helper(temp, s.substring(start, i + 1));\\n                res.add(temp);\\n            }\\n            if (Character.isDigit(s.charAt(i)) || s.charAt(i) == '-') {\\n                int start = i;\\n                while (s.charAt(i) != ',' && s.charAt(i) != ']') i += 1;\\n                res.add(new NestedInteger(Integer.parseInt(s.substring(start, i))));\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 86107,
                "title": "java-iterative-accepted-solution-using-stack",
                "content": "```\\npublic class Solution {\\n    public NestedInteger deserialize(String s) {\\n        NestedInteger ret = new NestedInteger();\\n        if(s == null || s.isEmpty()) {\\n            return new NestedInteger();\\n        }\\n        \\n        Stack<NestedInteger> stack = new Stack<>();\\n        stack.push(ret);\\n        int sign = 1;\\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if(c == '[') {\\n                NestedInteger ni = new NestedInteger();\\n                if(!stack.isEmpty()) {\\n                    stack.peek().add(ni);\\n                }\\n                stack.push(ni);\\n                sign = 1;\\n            } else if(Character.isDigit(c)) {\\n                int num = c - '0';\\n                while(i+1 < s.length() && Character.isDigit(s.charAt(i+1))) {\\n                    num = num * 10 + s.charAt(i+1) - '0';\\n                    i++;\\n                }\\n                num = num * sign;\\n                sign = 1;\\n                stack.peek().add(new NestedInteger(num));\\n            } else if (c == ',') {\\n                continue;\\n            } else if (c == ']') {\\n                stack.pop();\\n            } else if (c == '-') {\\n                sign = -1;\\n            }\\n        }\\n\\n        return ret.getList().isEmpty() ? ret : ret.getList().get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\npublic class Solution {\\n    public NestedInteger deserialize(String s) {\\n        NestedInteger ret = new NestedInteger();\\n        if(s == null || s.isEmpty()) {\\n            return new NestedInteger();\\n        }\\n        \\n        Stack<NestedInteger> stack = new Stack<>();\\n        stack.push(ret);\\n        int sign = 1;\\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if(c == '[') {\\n                NestedInteger ni = new NestedInteger();\\n                if(!stack.isEmpty()) {\\n                    stack.peek().add(ni);\\n                }\\n                stack.push(ni);\\n                sign = 1;\\n            } else if(Character.isDigit(c)) {\\n                int num = c - '0';\\n                while(i+1 < s.length() && Character.isDigit(s.charAt(i+1))) {\\n                    num = num * 10 + s.charAt(i+1) - '0';\\n                    i++;\\n                }\\n                num = num * sign;\\n                sign = 1;\\n                stack.peek().add(new NestedInteger(num));\\n            } else if (c == ',') {\\n                continue;\\n            } else if (c == ']') {\\n                stack.pop();\\n            } else if (c == '-') {\\n                sign = -1;\\n            }\\n        }\\n\\n        return ret.getList().isEmpty() ? ret : ret.getList().get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86114,
                "title": "java-15ms-recursive-solution-beats-88-short-and-clean",
                "content": "```\\npublic NestedInteger deserialize(String s) {\\n        if (s.charAt(0) != '[') return new NestedInteger(Integer.valueOf(s));\\n\\tNestedInteger res = new NestedInteger();\\n\\tif (s.length() == 2) return res;\\n\\tint start = 1, end = 1, brackets= 0;\\n\\tfor (;end < s.length()-1; end++) {\\n\\t\\tchar cur = s.charAt(end);\\n\\t\\tif (cur == '[') brackets++;\\n\\t\\telse if (cur == ']') brackets--;\\n\\t\\telse if (cur == ',' && brackets== 0) {\\n\\t\\t\\tres.add(deserialize(s.substring(start, end)));\\n\\t\\t\\tstart = end+1;\\n\\t\\t}\\n\\t}\\n\\tres.add(deserialize(s.substring(start, end)));\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic NestedInteger deserialize(String s) {\\n        if (s.charAt(0) != '[') return new NestedInteger(Integer.valueOf(s));\\n\\tNestedInteger res = new NestedInteger();\\n\\tif (s.length() == 2) return res;\\n\\tint start = 1, end = 1, brackets= 0;\\n\\tfor (;end < s.length()-1; end++) {\\n\\t\\tchar cur = s.charAt(end);\\n\\t\\tif (cur == '[') brackets++;\\n\\t\\telse if (cur == ']') brackets--;\\n\\t\\telse if (cur == ',' && brackets== 0) {\\n\\t\\t\\tres.add(deserialize(s.substring(start, end)));\\n\\t\\t\\tstart = end+1;\\n\\t\\t}\\n\\t}\\n\\tres.add(deserialize(s.substring(start, end)));\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86139,
                "title": "concise-java-solution",
                "content": "The following pattern is very generic for similar questions:\\n\\n    public NestedInteger deserialize(String s) {\\n        if (s.charAt(0) != '[') {\\n            return new NestedInteger(Integer.valueOf(s));\\n        }\\n\\n        Deque<NestedInteger> stack = new ArrayDeque<>();\\n        NestedInteger curr = new NestedInteger();\\n        \\n        Integer num = null;\\n        int sign = 1;\\n        \\n        for (char c : s.toCharArray()) {\\n            if (c == '[') {\\n                stack.push(curr);\\n                curr = new NestedInteger();\\n                \\n            } else if (c == ',') {\\n                if (num != null) {\\n                    curr.add(new NestedInteger(sign * num));\\n                }\\n                num = null;\\n                sign = 1;\\n                \\n            } else if (c == ']') {\\n                if (num != null) {\\n                    curr.add(new NestedInteger(sign * num));\\n                } \\n                NestedInteger parent = stack.pop();\\n                parent.add(curr);\\n                curr = parent;\\n                \\n                num = null;\\n                sign = 1;\\n                \\n            } else if (c == '-') {\\n                sign = -1;\\n                \\n            } else {\\n                if (num == null) {\\n                    num = 0;\\n                }\\n                num = num * 10 + c - '0';\\n            }\\n        }\\n        \\n        return curr.getList().get(0);\\n    }",
                "solutionTags": [],
                "code": "The following pattern is very generic for similar questions:\\n\\n    public NestedInteger deserialize(String s) {\\n        if (s.charAt(0) != '[') {\\n            return new NestedInteger(Integer.valueOf(s));\\n        }\\n\\n        Deque<NestedInteger> stack = new ArrayDeque<>();\\n        NestedInteger curr = new NestedInteger();\\n        \\n        Integer num = null;\\n        int sign = 1;\\n        \\n        for (char c : s.toCharArray()) {\\n            if (c == '[') {\\n                stack.push(curr);\\n                curr = new NestedInteger();\\n                \\n            } else if (c == ',') {\\n                if (num != null) {\\n                    curr.add(new NestedInteger(sign * num));\\n                }\\n                num = null;\\n                sign = 1;\\n                \\n            } else if (c == ']') {\\n                if (num != null) {\\n                    curr.add(new NestedInteger(sign * num));\\n                } \\n                NestedInteger parent = stack.pop();\\n                parent.add(curr);\\n                curr = parent;\\n                \\n                num = null;\\n                sign = 1;\\n                \\n            } else if (c == '-') {\\n                sign = -1;\\n                \\n            } else {\\n                if (num == null) {\\n                    num = 0;\\n                }\\n                num = num * 10 + c - '0';\\n            }\\n        }\\n        \\n        return curr.getList().get(0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 86141,
                "title": "simple-and-short-java-solution",
                "content": "```\\n    public NestedInteger deserialize(String s) {\\n        Stack<NestedInteger> stack = new Stack<>();\\n        for (int i = 0, num = 0, sign = 1; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - '0';\\n                if (i + 1 < s.length() && !Character.isDigit(s.charAt(i + 1))) {\\n                    stack.peek().add(new NestedInteger(num * sign));\\n                    num = 0;\\n                    sign = 1;\\n                }\\n            } else if (c == '-') {\\n                sign = -1;\\n            } else if (c == '[') {\\n                stack.push(new NestedInteger());\\n            } else if (c == ']') {\\n                NestedInteger current = stack.pop();\\n                if (stack.isEmpty()) {\\n                    return current;\\n                } else {\\n                    stack.peek().add(current);\\n                }\\n            }\\n        }\\n        \\n        return s.isEmpty() ? new NestedInteger() : new NestedInteger(Integer.parseInt(s));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public NestedInteger deserialize(String s) {\\n        Stack<NestedInteger> stack = new Stack<>();\\n        for (int i = 0, num = 0, sign = 1; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - '0';\\n                if (i + 1 < s.length() && !Character.isDigit(s.charAt(i + 1))) {\\n                    stack.peek().add(new NestedInteger(num * sign));\\n                    num = 0;\\n                    sign = 1;\\n                }\\n            } else if (c == '-') {\\n                sign = -1;\\n            } else if (c == '[') {\\n                stack.push(new NestedInteger());\\n            } else if (c == ']') {\\n                NestedInteger current = stack.pop();\\n                if (stack.isEmpty()) {\\n                    return current;\\n                } else {\\n                    stack.peek().add(current);\\n                }\\n            }\\n        }\\n        \\n        return s.isEmpty() ? new NestedInteger() : new NestedInteger(Integer.parseInt(s));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86151,
                "title": "python-recursive-solution",
                "content": "```\\nclass Solution(object):\\n    def deserialize(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: NestedInteger\\n        \"\"\"\\n        try:\\n            return int(s)\\n        except:\\n            i, open_paren, result = 1, 0, []\\n            for j in range(1, len(s)-1):\\n                if s[j] == ',' and not open_paren:\\n                    result.append(s[i:j])\\n                    i = j+1\\n                elif s[j] == '[':\\n                    open_paren += 1\\n                elif s[j] == ']':\\n                    open_paren -= 1\\n            if i < len(s)-1:\\n                result.append(s[i:len(s)-1])\\n            \\n            for i in range(len(result)):\\n                result[i] = self.deserialize(result[i])\\n            \\n            return result\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def deserialize(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: NestedInteger\\n        \"\"\"\\n        try:\\n            return int(s)\\n        except:\\n            i, open_paren, result = 1, 0, []\\n            for j in range(1, len(s)-1):\\n                if s[j] == ',' and not open_paren:\\n                    result.append(s[i:j])\\n                    i = j+1\\n                elif s[j] == '[':\\n                    open_paren += 1\\n                elif s[j] == ']':\\n                    open_paren -= 1\\n            if i < len(s)-1:\\n                result.append(s[i:len(s)-1])\\n            \\n            for i in range(len(result)):\\n                result[i] = self.deserialize(result[i])\\n            \\n            return result\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 86154,
                "title": "simple-java-iterative-solution",
                "content": "I like this simple version.\\n\\n```\\npublic class Solution {\\n\\n    public NestedInteger deserialize(String s) {\\n        if (s.charAt(0) != '[') {\\n            return new NestedInteger(Integer.parseInt(s));\\n        }\\n        Deque<NestedInteger> stack = new LinkedList<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == '[') { // start a new NestedInteger\\n                stack.push(new NestedInteger());\\n            } else if (c == ']' && stack.size() > 1) { // end, check if need to add curr to upper level\\n                NestedInteger n = stack.pop();\\n                stack.peek().add(n);\\n            } else if (Character.isDigit(c) || c == '-') { // is number, parse it, then add it to upper level\\n                boolean isNegative = false;\\n                if (c == '-') {\\n                    isNegative = true;\\n                    i++;\\n                }\\n                int num = s.charAt(i) - '0';\\n                while (i + 1< s.length() && Character.isDigit(s.charAt(i + 1))) {\\n                    num = num * 10 + (s.charAt(i + 1) - '0');\\n                    i++;\\n                }\\n                NestedInteger ni = new NestedInteger(isNegative ? -num : num);\\n                stack.peek().add(ni);\\n            }\\n        }\\n        return stack.pop();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n    public NestedInteger deserialize(String s) {\\n        if (s.charAt(0) != '[') {\\n            return new NestedInteger(Integer.parseInt(s));\\n        }\\n        Deque<NestedInteger> stack = new LinkedList<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == '[') { // start a new NestedInteger\\n                stack.push(new NestedInteger());\\n            } else if (c == ']' && stack.size() > 1) { // end, check if need to add curr to upper level\\n                NestedInteger n = stack.pop();\\n                stack.peek().add(n);\\n            } else if (Character.isDigit(c) || c == '-') { // is number, parse it, then add it to upper level\\n                boolean isNegative = false;\\n                if (c == '-') {\\n                    isNegative = true;\\n                    i++;\\n                }\\n                int num = s.charAt(i) - '0';\\n                while (i + 1< s.length() && Character.isDigit(s.charAt(i + 1))) {\\n                    num = num * 10 + (s.charAt(i + 1) - '0');\\n                    i++;\\n                }\\n                NestedInteger ni = new NestedInteger(isNegative ? -num : num);\\n                stack.peek().add(ni);\\n            }\\n        }\\n        return stack.pop();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86167,
                "title": "c-code-with-36ms",
                "content": "    class Solution{\\n          stack<NestedInteger*> Stack;\\n    public:\\n          NestedInteger<string s>{\\n                 NestedInteger *cur;\\n                 for(int i=0;i<s.size();i++){\\n                      if(s[i]==',')continue;\\n                      cur=new NestedInteger();\\n                      if(s[i]=='[')Stack.push(new NestedInteger());\\n                      else if(s[i]==']'){\\n                            cur=Stack.top();\\n                            Stack.pop();\\n                            if(!Stack.empty())Stack.top()->add(*cur);\\n                      }else{\\n                            int j=i;\\n                            while(j<s.size()&&s[j]!=']'&&s[j]!=',')j++;\\n                            cur->setInteger(stoi(s.substr(i,j-i));\\n                            if(!Stack.empty())Stack.top()->add(*cur);\\n                            i=j-1;\\n                     }\\n               }\\n               return Stack.empty()? *cur:*Stack.top();\\n          }\\n      };",
                "solutionTags": [],
                "code": "class Solution{\\n          stack<NestedInteger*> Stack;\\n    public:\\n          NestedInteger<string s>{\\n                 NestedInteger *cur;\\n                 for(int i=0;i<s.size();i++){\\n                      if(s[i]==',')continue;\\n                      cur=new NestedInteger();\\n                      if(s[i]=='[')Stack.push(new NestedInteger());\\n                      else if(s[i]==']'){\\n                            cur=Stack.top();\\n                            Stack.pop();\\n                            if(!Stack.empty())Stack.top()->add(*cur);\\n                      }",
                "codeTag": "Java"
            },
            {
                "id": 86176,
                "title": "my-solution-using-formal-grammar-long-but-elegant-in-my-opinion",
                "content": " ```\\n/**\\n  * grammar for the context.\\n  * NestedInteger           := Number | [InnerNestedIneger]\\n  * InnerNestedInteger      := NestedInteger | InnerNestedInteger,NestedInteger\\n  * Number                  := -PositiveNumber | PositiveNumber\\n  * PositiveNumber          := digit | digitPositiveNumber\\n  */\\npublic class Solution {\\n    \\n    private int index;\\n    private int sLen;\\n    \\n    public NestedInteger deserialize(String s) {\\n        sLen = s.length();\\n        if (sLen == 0) {\\n            return new NestedInteger();\\n        }\\n        index = 0;\\n        return nestedInteger(s);\\n    }\\n    \\n    public NestedInteger nestedInteger(String s) {\\n        \\n        if (leftBracket(s)) {\\n            NestedInteger result = innerNestedInteger(s);\\n            rightBracket(s);\\n            return result;\\n        } else {\\n            return integer(s);\\n        }\\n        \\n    }\\n    \\n    public NestedInteger innerNestedInteger(String s) {\\n        NestedInteger result = new NestedInteger();\\n        do {\\n            NestedInteger subResult = nestedInteger(s);\\n            if (subResult != null) {\\n                result.add(subResult);\\n            }\\n        }  while (comma(s));\\n        return result;\\n    }\\n    \\n    public boolean leftBracket(String s) {\\n        if (index >= sLen) {\\n            return false;\\n        }\\n        if (s.charAt(index) == '[') {\\n            index++;\\n            return true;\\n        } else\\n            return false;\\n    }\\n    \\n    public NestedInteger integer(String s) {\\n        int posOrNeg = negtiveSign(s) ? -1 : 1;\\n        \\n        int num = positiveInteger(s); \\n        if (num != -1) {\\n            num *= posOrNeg;\\n            return new NestedInteger(num);\\n        }\\n        \\n        return null;\\n    }\\n    \\n    public int positiveInteger(String s) {\\n        int num = 0;\\n        int digit = 0;\\n        boolean foundDigit = false;\\n        while (digit != -1) {\\n            digit = digit(s);\\n            if (digit > -1 && digit < 10) {\\n                foundDigit = true;\\n                num = num * 10 + digit;\\n            }\\n        }\\n        return foundDigit ? num : -1;\\n    }\\n    \\n    public boolean comma(String s) {\\n        if (index >= sLen) {\\n            return false;\\n        }\\n        if (s.charAt(index) == ',') {\\n            index++;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    public int digit(String s) {\\n        if (index >= sLen) {\\n            return -1;\\n        }\\n        int result = s.charAt(index) - '0';\\n        if (result >= 0 && result <= 9) {\\n            index++;\\n            return result;\\n        } else {\\n            return -1;\\n        }\\n    }\\n    \\n    public boolean rightBracket(String s) {\\n        if (index >= sLen) {\\n            return false;\\n        }\\n        if (s.charAt(index) == ']') {\\n            index++;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    public boolean negtiveSign(String s) {\\n        if (index >= sLen) {\\n            return false;\\n        }\\n        if (s.charAt(index) == '-') {\\n            index++;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n  * grammar for the context.\\n  * NestedInteger           := Number | [InnerNestedIneger]\\n  * InnerNestedInteger      := NestedInteger | InnerNestedInteger,NestedInteger\\n  * Number                  := -PositiveNumber | PositiveNumber\\n  * PositiveNumber          := digit | digitPositiveNumber\\n  */\\npublic class Solution {\\n    \\n    private int index;\\n    private int sLen;\\n    \\n    public NestedInteger deserialize(String s) {\\n        sLen = s.length();\\n        if (sLen == 0) {\\n            return new NestedInteger();\\n        }\\n        index = 0;\\n        return nestedInteger(s);\\n    }\\n    \\n    public NestedInteger nestedInteger(String s) {\\n        \\n        if (leftBracket(s)) {\\n            NestedInteger result = innerNestedInteger(s);\\n            rightBracket(s);\\n            return result;\\n        } else {\\n            return integer(s);\\n        }\\n        \\n    }\\n    \\n    public NestedInteger innerNestedInteger(String s) {\\n        NestedInteger result = new NestedInteger();\\n        do {\\n            NestedInteger subResult = nestedInteger(s);\\n            if (subResult != null) {\\n                result.add(subResult);\\n            }\\n        }  while (comma(s));\\n        return result;\\n    }\\n    \\n    public boolean leftBracket(String s) {\\n        if (index >= sLen) {\\n            return false;\\n        }\\n        if (s.charAt(index) == '[') {\\n            index++;\\n            return true;\\n        } else\\n            return false;\\n    }\\n    \\n    public NestedInteger integer(String s) {\\n        int posOrNeg = negtiveSign(s) ? -1 : 1;\\n        \\n        int num = positiveInteger(s); \\n        if (num != -1) {\\n            num *= posOrNeg;\\n            return new NestedInteger(num);\\n        }\\n        \\n        return null;\\n    }\\n    \\n    public int positiveInteger(String s) {\\n        int num = 0;\\n        int digit = 0;\\n        boolean foundDigit = false;\\n        while (digit != -1) {\\n            digit = digit(s);\\n            if (digit > -1 && digit < 10) {\\n                foundDigit = true;\\n                num = num * 10 + digit;\\n            }\\n        }\\n        return foundDigit ? num : -1;\\n    }\\n    \\n    public boolean comma(String s) {\\n        if (index >= sLen) {\\n            return false;\\n        }\\n        if (s.charAt(index) == ',') {\\n            index++;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    public int digit(String s) {\\n        if (index >= sLen) {\\n            return -1;\\n        }\\n        int result = s.charAt(index) - '0';\\n        if (result >= 0 && result <= 9) {\\n            index++;\\n            return result;\\n        } else {\\n            return -1;\\n        }\\n    }\\n    \\n    public boolean rightBracket(String s) {\\n        if (index >= sLen) {\\n            return false;\\n        }\\n        if (s.charAt(index) == ']') {\\n            index++;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    public boolean negtiveSign(String s) {\\n        if (index >= sLen) {\\n            return false;\\n        }\\n        if (s.charAt(index) == '-') {\\n            index++;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86187,
                "title": "extremely-simple-python-solution",
                "content": "```python\\nclass Solution(object):\\n    def deserialize(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: NestedInteger\\n        \"\"\"\\n        return eval(s)\\n```\\nThis code could pass the test cases. But I don't know whether this solution is legal or not.",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def deserialize(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: NestedInteger\\n        \"\"\"\\n        return eval(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86189,
                "title": "my-clean-solution-using-one-stack",
                "content": "```\\npublic NestedInteger deserialize(String s) {\\n    if (s == null) {\\n        return null;\\n    }\\n    if (s.charAt(0) != '[') {\\n        return new NestedInteger(Integer.valueOf(s));\\n    }\\n    NestedInteger nestedInteger = null;\\n    Stack<NestedInteger> stack = new Stack<NestedInteger>();\\n        \\n    for (String elem: s.split(\",\")) {\\n        String elem1 = elem.replace(\"[\", \"\");\\n        for (int i = 0; i <elem.length() -elem1.length(); i++) {\\n            stack.push(new NestedInteger());\\n        }    \\n        String elem2 = elem1.replace(\"]\", \"\");\\n        if (elem2.length() > 0) {\\n            int value = Integer.valueOf(elem2);\\n            stack.peek().add(new NestedInteger(value));\\n        }    \\n        for (int i = 0; i < elem1.length() - elem2.length(); i++) {\\n            nestedInteger = stack.pop();\\n            if (!stack.isEmpty()) {\\n                stack.peek().add(nestedInteger);\\n            }\\n        }\\n    }\\n        \\n    return nestedInteger;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic NestedInteger deserialize(String s) {\\n    if (s == null) {\\n        return null;\\n    }\\n    if (s.charAt(0) != '[') {\\n        return new NestedInteger(Integer.valueOf(s));\\n    }\\n    NestedInteger nestedInteger = null;\\n    Stack<NestedInteger> stack = new Stack<NestedInteger>();\\n        \\n    for (String elem: s.split(\",\")) {\\n        String elem1 = elem.replace(\"[\", \"\");\\n        for (int i = 0; i <elem.length() -elem1.length(); i++) {\\n            stack.push(new NestedInteger());\\n        }    \\n        String elem2 = elem1.replace(\"]\", \"\");\\n        if (elem2.length() > 0) {\\n            int value = Integer.valueOf(elem2);\\n            stack.peek().add(new NestedInteger(value));\\n        }    \\n        for (int i = 0; i < elem1.length() - elem2.length(); i++) {\\n            nestedInteger = stack.pop();\\n            if (!stack.isEmpty()) {\\n                stack.peek().add(nestedInteger);\\n            }\\n        }\\n    }\\n        \\n    return nestedInteger;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 86191,
                "title": "a-very-clear-and-detailed-explained-iterative-solution",
                "content": "Iterate through the whole string. Keep a stack to track the NestedInteger objects.\\nThe top of the stack is always the current NestedInteger we are working on.\\n'[': push a new object into stack\\n']': if there are more that one object in the stack, it means the top NestedInteger is an element of the last but one NestedInteger.\\n',': just continue\\n'0'-'9'\\uff1aadd the number to the top NestInteger in stack.\\n\\nHopefully there are more clean solutions!\\n```\\npublic class Solution {\\n    public NestedInteger Deserialize(string s) {\\n        int i = 0;\\n        int N = s.Count();\\n        var objst = new Stack<NestedInteger>();\\n        \\n        if(s[0] != '[')\\n        {\\n            return new NestedInteger(Convert.ToInt32(s));\\n        }\\n\\n        while(i < N)\\n        {\\n            if(s[i] == '[')\\n            {\\n                objst.Push(new NestedInteger());\\n                i++;\\n                continue;\\n            }\\n            if(s[i] == ',')\\n            {\\n                i++;\\n                continue;\\n            }\\n            if(s[i] == ']')\\n            {\\n                if(objst.Count()>1)\\n                {\\n                    var obj = objst.Pop();\\n                    objst.Peek().Add(obj);\\n                }\\n                i++;\\n                continue;\\n            }\\n            int n = 0;\\n            int sign = 1;\\n            if(s[i] == '-')\\n            {\\n                sign = -1;\\n                i++;\\n            }\\n            while(i < N && s[i] >= '0' && s[i] <= '9')\\n            {\\n                n = n*10+(s[i] - '0');\\n                i++;\\n            }\\n            objst.Peek().Add(new NestedInteger(sign*n));\\n        }\\n        return objst.Peek();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public NestedInteger Deserialize(string s) {\\n        int i = 0;\\n        int N = s.Count();\\n        var objst = new Stack<NestedInteger>();\\n        \\n        if(s[0] != '[')\\n        {\\n            return new NestedInteger(Convert.ToInt32(s));\\n        }\\n\\n        while(i < N)\\n        {\\n            if(s[i] == '[')\\n            {\\n                objst.Push(new NestedInteger());\\n                i++;\\n                continue;\\n            }\\n            if(s[i] == ',')\\n            {\\n                i++;\\n                continue;\\n            }\\n            if(s[i] == ']')\\n            {\\n                if(objst.Count()>1)\\n                {\\n                    var obj = objst.Pop();\\n                    objst.Peek().Add(obj);\\n                }\\n                i++;\\n                continue;\\n            }\\n            int n = 0;\\n            int sign = 1;\\n            if(s[i] == '-')\\n            {\\n                sign = -1;\\n                i++;\\n            }\\n            while(i < N && s[i] >= '0' && s[i] <= '9')\\n            {\\n                n = n*10+(s[i] - '0');\\n                i++;\\n            }\\n            objst.Peek().Add(new NestedInteger(sign*n));\\n        }\\n        return objst.Peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86203,
                "title": "python-14-liner-iterative-solution",
                "content": "```\\ndef deserialize(self, s):\\n    stk, num = [NestedInteger()], ''\\n    for ch in s+' ':\\n        if ch == '[':\\n            tmp = NestedInteger()\\n            stk[-1].add(tmp)\\n            stk.append(tmp)\\n        elif ch in '-01234556789':\\n            num += ch\\n        elif num:\\n            stk[-1].add(NestedInteger(int(num)))\\n            num = ''\\n        if ch == ']':\\n            stk.pop()\\n    return stk[-1].getList()[0]\\n```",
                "solutionTags": [],
                "code": "```\\ndef deserialize(self, s):\\n    stk, num = [NestedInteger()], ''\\n    for ch in s+' ':\\n        if ch == '[':\\n            tmp = NestedInteger()\\n            stk[-1].add(tmp)\\n            stk.append(tmp)\\n        elif ch in '-01234556789':\\n            num += ch\\n        elif num:\\n            stk[-1].add(NestedInteger(int(num)))\\n            num = ''\\n        if ch == ']':\\n            stk.pop()\\n    return stk[-1].getList()[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 86077,
                "title": "java-recursive-solution-one-scan-clean-easy-to-understand",
                "content": "1. if '[', construct a new NestedInteger;\\n\\n2. if ']', add the number before ']' if it exists, the character before ']' must be a number or ']';\\n\\n3. if ',', add the number before ',' if it exists, the character before ',' must be a number or ']';\\n\\n4. if a number, just add the right pointer.\\n\\n```\\npublic class Solution {\\n    public NestedInteger deserialize(String s) {\\n        if (s.charAt(0) != '[') return new NestedInteger(Integer.parseInt(s));\\n        NestedInteger result = new NestedInteger();\\n        helper(s, 1, result);\\n        return result;\\n    }\\n\\n    private int helper(String s, int idx, NestedInteger parent) {\\n        int l = idx, r = idx;\\n        while (r < s.length()) {\\n            String num = s.substring(l, r);\\n            if (s.charAt(r) == '[') {\\n                NestedInteger child = new NestedInteger();\\n                parent.add(child);\\n                r = helper(s, r + 1, child);\\n                l = r;\\n            } else if (s.charAt(r) == ']') {\\n                if (!num.isEmpty()) parent.add(new NestedInteger(Integer.valueOf(num)));\\n                return r + 1;\\n            } else if (s.charAt(r) == ',') {\\n                if (!num.isEmpty()) parent.add(new NestedInteger(Integer.valueOf(num)));\\n                r++;\\n                l = r;\\n            } else {\\n                r++;\\n            }\\n        }\\n        return s.length();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public NestedInteger deserialize(String s) {\\n        if (s.charAt(0) != '[') return new NestedInteger(Integer.parseInt(s));\\n        NestedInteger result = new NestedInteger();\\n        helper(s, 1, result);\\n        return result;\\n    }\\n\\n    private int helper(String s, int idx, NestedInteger parent) {\\n        int l = idx, r = idx;\\n        while (r < s.length()) {\\n            String num = s.substring(l, r);\\n            if (s.charAt(r) == '[') {\\n                NestedInteger child = new NestedInteger();\\n                parent.add(child);\\n                r = helper(s, r + 1, child);\\n                l = r;\\n            } else if (s.charAt(r) == ']') {\\n                if (!num.isEmpty()) parent.add(new NestedInteger(Integer.valueOf(num)));\\n                return r + 1;\\n            } else if (s.charAt(r) == ',') {\\n                if (!num.isEmpty()) parent.add(new NestedInteger(Integer.valueOf(num)));\\n                r++;\\n                l = r;\\n            } else {\\n                r++;\\n            }\\n        }\\n        return s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 86220,
                "title": "easy-to-understand-use-stack-java-solution",
                "content": "```\\npublic NestedInteger deserialize(String s) {\\n        NestedInteger res = new NestedInteger();\\n        Stack<NestedInteger> stack = new Stack<NestedInteger>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == '[') {\\n                stack.push(new NestedInteger());\\n                continue;\\n            }\\n            if (c == ',') {\\n                continue;\\n            }\\n            if (c == ']') {\\n                NestedInteger temp = stack.pop();\\n                if (!stack.isEmpty()) {\\n                    stack.peek().add(temp);\\n                } else {\\n                    stack.push(temp);\\n                }\\n                continue;\\n            }\\n            int j = i;\\n            while (j < s.length() && (Character.isDigit(s.charAt(j)) || s.charAt(j) == '-')) {\\n                j++;\\n            }\\n            if (j > i) {\\n                int num = Integer.parseInt(s.substring(i, j));\\n                if (!stack.isEmpty()) {\\n                    NestedInteger ni = new NestedInteger(num);\\n                    stack.peek().add(ni);\\n                } else {\\n                    NestedInteger ni = new NestedInteger(num);\\n                    stack.push(ni);\\n                }\\n                i = j - 1;\\n            }\\n        }\\n        return stack.peek();\\n    }",
                "solutionTags": [],
                "code": "```\\npublic NestedInteger deserialize(String s) {\\n        NestedInteger res = new NestedInteger();\\n        Stack<NestedInteger> stack = new Stack<NestedInteger>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == '[') {\\n                stack.push(new NestedInteger());\\n                continue;\\n            }\\n            if (c == ',') {\\n                continue;\\n            }\\n            if (c == ']') {\\n                NestedInteger temp = stack.pop();\\n                if (!stack.isEmpty()) {\\n                    stack.peek().add(temp);\\n                } else {\\n                    stack.push(temp);\\n                }\\n                continue;\\n            }\\n            int j = i;\\n            while (j < s.length() && (Character.isDigit(s.charAt(j)) || s.charAt(j) == '-')) {\\n                j++;\\n            }\\n            if (j > i) {\\n                int num = Integer.parseInt(s.substring(i, j));\\n                if (!stack.isEmpty()) {\\n                    NestedInteger ni = new NestedInteger(num);\\n                    stack.peek().add(ni);\\n                } else {\\n                    NestedInteger ni = new NestedInteger(num);\\n                    stack.push(ni);\\n                }\\n                i = j - 1;\\n            }\\n        }\\n        return stack.peek();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 86211,
                "title": "java-10-ms-while-loop-recursion-one-scan",
                "content": "I found that most of the recursion solutions have to scan through the string s more than once since they find a ',' as a breaking point at each layer in order to return a NestedInteger between two ',' or between ',' and ']'. \\nMy solution also uses recursion. However, it not only return a NestedInteger but also an index point to the next unseen char. This way, we only need to scan the string s once just like the iterative solution. \\n```\\npublic class Solution {\\n    public int helper(char[] cc, int idx, NestedInteger res){\\n        NestedInteger ret = null; // for storing the list element\\n        Integer num=null; // for storing the number element\\n        int sign = 1; // sign of the number\\n        while ( idx < cc.length && cc[idx] != ']') { // parsing between [ and ]\\n            char c = cc[idx++];\\n            if ( c == '[' ) { // start parsing a list by calling helper function\\n                ret = new NestedInteger();\\n                idx = helper(cc, idx, ret); // idx is the next index after ]\\n            } else if ( c == ',' ){  // time to add a element to the list\\n                if (ret != null) { // it is a List element\\n                    res.add(ret);\\n                } else { // it is a integer or null\\n                    if (num != null) res.add(new NestedInteger( sign*num ) );\\n                }\\n                ret = null;  // reset \\n                num = null;\\n                sign = 1;\\n            } else if ( c == '-' ){ // sign of the number\\n                sign = -1;\\n            } else { // calculate the number\\n                num = num == null ? (int)(c-'0'): (num*10) + (int)(c-'0');\\n            }\\n        }\\n        if (ret != null) { // add the last element or the element before ]\\n            res.add(ret);\\n        } else {\\n            if (num != null) res.add(new NestedInteger(sign*num));\\n        }\\n        return idx+1; // very important!!! return the next index \\n    }\\n    \\n    public NestedInteger deserialize(String s) {\\n        NestedInteger ret = new NestedInteger(); // a dummy root element\\n        helper(s.toCharArray(), 0, ret);\\n        return ret.getList().get(0); // return a element in the dummy root\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int helper(char[] cc, int idx, NestedInteger res){\\n        NestedInteger ret = null; // for storing the list element\\n        Integer num=null; // for storing the number element\\n        int sign = 1; // sign of the number\\n        while ( idx < cc.length && cc[idx] != ']') { // parsing between [ and ]\\n            char c = cc[idx++];\\n            if ( c == '[' ) { // start parsing a list by calling helper function\\n                ret = new NestedInteger();\\n                idx = helper(cc, idx, ret); // idx is the next index after ]\\n            } else if ( c == ',' ){  // time to add a element to the list\\n                if (ret != null) { // it is a List element\\n                    res.add(ret);\\n                } else { // it is a integer or null\\n                    if (num != null) res.add(new NestedInteger( sign*num ) );\\n                }\\n                ret = null;  // reset \\n                num = null;\\n                sign = 1;\\n            } else if ( c == '-' ){ // sign of the number\\n                sign = -1;\\n            } else { // calculate the number\\n                num = num == null ? (int)(c-'0'): (num*10) + (int)(c-'0');\\n            }\\n        }\\n        if (ret != null) { // add the last element or the element before ]\\n            res.add(ret);\\n        } else {\\n            if (num != null) res.add(new NestedInteger(sign*num));\\n        }\\n        return idx+1; // very important!!! return the next index \\n    }\\n    \\n    public NestedInteger deserialize(String s) {\\n        NestedInteger ret = new NestedInteger(); // a dummy root element\\n        helper(s.toCharArray(), 0, ret);\\n        return ret.getList().get(0); // return a element in the dummy root\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054907,
                "title": "easy-recursive-solution-java-hyder-nabi",
                "content": "# Code\\n```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * public interface NestedInteger {\\n *     // Constructor initializes an empty nested list.\\n *     public NestedInteger();\\n *\\n *     // Constructor initializes a single integer.\\n *     public NestedInteger(int value);\\n *\\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     public boolean isInteger();\\n *\\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // Return null if this NestedInteger holds a nested list\\n *     public Integer getInteger();\\n *\\n *     // Set this NestedInteger to hold a single integer.\\n *     public void setInteger(int value);\\n *\\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\\n *     public void add(NestedInteger ni);\\n *\\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // Return empty list if this NestedInteger holds a single integer\\n *     public List<NestedInteger> getList();\\n * }\\n */\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        List<String> input = new ArrayList<>();\\n        int i = 0;\\n        while(i<s.length()){\\n            char c = s.charAt(i);\\n            if(c == \\']\\' || c==\\'[\\') {\\n                input.add(c+\"\");\\n                i++;\\n            } else if(c == \\',\\'){\\n                i++;\\n                continue;\\n            }else {\\n                String integer = c+\"\";\\n                i++;\\n                while(i<s.length() && Character.isDigit(s.charAt(i))){\\n                    integer+=s.charAt(i);\\n                    i++;\\n                }\\n                input.add(integer);\\n            }\\n        }\\n        if(!input.get(0).equals(\"[\")) {\\n            return new NestedInteger(Integer.valueOf(input.get(0)));\\n        } else {\\n            return helper(input);\\n        }\\n    }\\n\\n\\n    public NestedInteger helper(List<String> list) {\\n        \\n            NestedInteger ni = new NestedInteger();\\n            list.remove(0);\\n            while(!list.get(0).equals(\"]\")) {\\n                if(list.get(0).equals(\"[\")) {\\n                    NestedInteger nil = helper(list);\\n                    ni.add(nil);\\n                } else {\\n                    ni.add(new NestedInteger(Integer.valueOf(list.get(0))));\\n                    list.remove(0);\\n                }\\n            }\\n            list.remove(0);\\n            return ni;\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * public interface NestedInteger {\\n *     // Constructor initializes an empty nested list.\\n *     public NestedInteger();\\n *\\n *     // Constructor initializes a single integer.\\n *     public NestedInteger(int value);\\n *\\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     public boolean isInteger();\\n *\\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // Return null if this NestedInteger holds a nested list\\n *     public Integer getInteger();\\n *\\n *     // Set this NestedInteger to hold a single integer.\\n *     public void setInteger(int value);\\n *\\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\\n *     public void add(NestedInteger ni);\\n *\\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // Return empty list if this NestedInteger holds a single integer\\n *     public List<NestedInteger> getList();\\n * }\\n */\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        List<String> input = new ArrayList<>();\\n        int i = 0;\\n        while(i<s.length()){\\n            char c = s.charAt(i);\\n            if(c == \\']\\' || c==\\'[\\') {\\n                input.add(c+\"\");\\n                i++;\\n            } else if(c == \\',\\'){\\n                i++;\\n                continue;\\n            }else {\\n                String integer = c+\"\";\\n                i++;\\n                while(i<s.length() && Character.isDigit(s.charAt(i))){\\n                    integer+=s.charAt(i);\\n                    i++;\\n                }\\n                input.add(integer);\\n            }\\n        }\\n        if(!input.get(0).equals(\"[\")) {\\n            return new NestedInteger(Integer.valueOf(input.get(0)));\\n        } else {\\n            return helper(input);\\n        }\\n    }\\n\\n\\n    public NestedInteger helper(List<String> list) {\\n        \\n            NestedInteger ni = new NestedInteger();\\n            list.remove(0);\\n            while(!list.get(0).equals(\"]\")) {\\n                if(list.get(0).equals(\"[\")) {\\n                    NestedInteger nil = helper(list);\\n                    ni.add(nil);\\n                } else {\\n                    ni.add(new NestedInteger(Integer.valueOf(list.get(0))));\\n                    list.remove(0);\\n                }\\n            }\\n            list.remove(0);\\n            return ni;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015217,
                "title": "even-faster-solution",
                "content": "# Intuition\\nJSON-like parsing. Recurtion.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n$$O(n)$$ complexity and near zero memory usage (for result data only).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * *********************************************************************\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * *********************************************************************\\n *\\n * // Initializes an empty nested list and return a reference to the nested integer.\\n * struct NestedInteger *NestedIntegerInit();\\n *\\n * // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n * bool NestedIntegerIsInteger(struct NestedInteger *);\\n *\\n * // Return the single integer that this NestedInteger holds, if it holds a single integer\\n * // The result is undefined if this NestedInteger holds a nested list\\n * int NestedIntegerGetInteger(struct NestedInteger *);\\n *\\n * // Set this NestedInteger to hold a single integer.\\n * void NestedIntegerSetInteger(struct NestedInteger *ni, int value);\\n *\\n * // Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\\n * void NestedIntegerAdd(struct NestedInteger *ni, struct NestedInteger *elem);\\n *\\n * // Return the nested list that this NestedInteger holds, if it holds a nested list\\n * // The result is undefined if this NestedInteger holds a single integer\\n * struct NestedInteger **NestedIntegerGetList(struct NestedInteger *);\\n *\\n * // Return the nested list\\'s size that this NestedInteger holds, if it holds a nested list\\n * // The result is undefined if this NestedInteger holds a single integer\\n * int NestedIntegerGetListSize(struct NestedInteger *);\\n * };\\n */\\n\\nstatic int parse(char *s, int start, int end, struct NestedInteger* node)\\n{\\n    uint8_t value_exists = 0;\\n    int8_t minus = 1;\\n    int value = 0;\\n    struct NestedInteger *newNode;\\n    int i;\\n\\n    for (i = start; i < end; i++)\\n    {\\n        char c = s[i];\\n        if (c == \\'-\\')\\n        {\\n            minus = -1;\\n        } else if (c >= \\'0\\' && c <= \\'9\\')\\n        {\\n            value_exists = 1;\\n            value *= 10;\\n            value += s[i] - \\'0\\';\\n        } else {\\n            if (value_exists) {\\n                newNode = NestedIntegerInit();\\n                NestedIntegerAdd(node, newNode);\\n                NestedIntegerSetInteger(newNode, value * minus);\\n                minus = 1;\\n                value = 0;\\n                value_exists = 0;\\n            }\\n            switch (c)\\n            {\\n                case \\'[\\':\\n                    newNode = NestedIntegerInit();\\n                    NestedIntegerAdd(node, newNode);\\n                    i = parse(s, i + 1, end, newNode);\\n                    break;\\n                case \\']\\':\\n                    return i;\\n            }\\n        }\\n    }\\n\\n    if (value_exists) {\\n        newNode = NestedIntegerInit();\\n        NestedIntegerAdd(node, newNode);\\n        NestedIntegerSetInteger(newNode, value * minus);\\n    }\\n\\n    return i;\\n}\\n\\nstruct NestedInteger* deserialize(char * s){\\n    struct NestedInteger* node = NestedIntegerInit();\\n    parse(s, 0, strlen(s), node);\\n    return NestedIntegerGetList(node)[0];\\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * *********************************************************************\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * *********************************************************************\\n *\\n * // Initializes an empty nested list and return a reference to the nested integer.\\n * struct NestedInteger *NestedIntegerInit();\\n *\\n * // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n * bool NestedIntegerIsInteger(struct NestedInteger *);\\n *\\n * // Return the single integer that this NestedInteger holds, if it holds a single integer\\n * // The result is undefined if this NestedInteger holds a nested list\\n * int NestedIntegerGetInteger(struct NestedInteger *);\\n *\\n * // Set this NestedInteger to hold a single integer.\\n * void NestedIntegerSetInteger(struct NestedInteger *ni, int value);\\n *\\n * // Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\\n * void NestedIntegerAdd(struct NestedInteger *ni, struct NestedInteger *elem);\\n *\\n * // Return the nested list that this NestedInteger holds, if it holds a nested list\\n * // The result is undefined if this NestedInteger holds a single integer\\n * struct NestedInteger **NestedIntegerGetList(struct NestedInteger *);\\n *\\n * // Return the nested list\\'s size that this NestedInteger holds, if it holds a nested list\\n * // The result is undefined if this NestedInteger holds a single integer\\n * int NestedIntegerGetListSize(struct NestedInteger *);\\n * };\\n */\\n\\nstatic int parse(char *s, int start, int end, struct NestedInteger* node)\\n{\\n    uint8_t value_exists = 0;\\n    int8_t minus = 1;\\n    int value = 0;\\n    struct NestedInteger *newNode;\\n    int i;\\n\\n    for (i = start; i < end; i++)\\n    {\\n        char c = s[i];\\n        if (c == \\'-\\')\\n        {\\n            minus = -1;\\n        } else if (c >= \\'0\\' && c <= \\'9\\')\\n        {\\n            value_exists = 1;\\n            value *= 10;\\n            value += s[i] - \\'0\\';\\n        } else {\\n            if (value_exists) {\\n                newNode = NestedIntegerInit();\\n                NestedIntegerAdd(node, newNode);\\n                NestedIntegerSetInteger(newNode, value * minus);\\n                minus = 1;\\n                value = 0;\\n                value_exists = 0;\\n            }\\n            switch (c)\\n            {\\n                case \\'[\\':\\n                    newNode = NestedIntegerInit();\\n                    NestedIntegerAdd(node, newNode);\\n                    i = parse(s, i + 1, end, newNode);\\n                    break;\\n                case \\']\\':\\n                    return i;\\n            }\\n        }\\n    }\\n\\n    if (value_exists) {\\n        newNode = NestedIntegerInit();\\n        NestedIntegerAdd(node, newNode);\\n        NestedIntegerSetInteger(newNode, value * minus);\\n    }\\n\\n    return i;\\n}\\n\\nstruct NestedInteger* deserialize(char * s){\\n    struct NestedInteger* node = NestedIntegerInit();\\n    parse(s, 0, strlen(s), node);\\n    return NestedIntegerGetList(node)[0];\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009742,
                "title": "fastest-solution-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * *********************************************************************\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * *********************************************************************\\n *\\n * // Initializes an empty nested list and return a reference to the nested integer.\\n * struct NestedInteger *NestedIntegerInit();\\n *\\n * // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n * bool NestedIntegerIsInteger(struct NestedInteger *);\\n *\\n * // Return the single integer that this NestedInteger holds, if it holds a single integer\\n * // The result is undefined if this NestedInteger holds a nested list\\n * int NestedIntegerGetInteger(struct NestedInteger *);\\n *\\n * // Set this NestedInteger to hold a single integer.\\n * void NestedIntegerSetInteger(struct NestedInteger *ni, int value);\\n *\\n * // Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\\n * void NestedIntegerAdd(struct NestedInteger *ni, struct NestedInteger *elem);\\n *\\n * // Return the nested list that this NestedInteger holds, if it holds a nested list\\n * // The result is undefined if this NestedInteger holds a single integer\\n * struct NestedInteger **NestedIntegerGetList(struct NestedInteger *);\\n *\\n * // Return the nested list\\'s size that this NestedInteger holds, if it holds a nested list\\n * // The result is undefined if this NestedInteger holds a single integer\\n * int NestedIntegerGetListSize(struct NestedInteger *);\\n * };\\n */\\n\\nstatic void parse(char *s, int start, int end, struct NestedInteger* node)\\n{\\n    if (start == end)\\n        return;\\n    if (s[start] == \\'[\\')\\n    {\\n        int br = 0;\\n        struct NestedInteger *newNode;\\n        start++;\\n        int i;\\n        for(i = start; i < end - 2; i++)\\n        {\\n            char c = s[i];\\n            switch(c)\\n            {\\n                case \\',\\':\\n                    if (br == 0)\\n                    {\\n                        if (start != i)\\n                        {\\n                            newNode = NestedIntegerInit();\\n                            NestedIntegerAdd(node, newNode);\\n                            parse(s, start, i, newNode);\\n                        }\\n                        start = i + 1;\\n                    }\\n                    break;\\n                case \\'[\\':\\n                    br++;\\n                    break;\\n                case \\']\\':\\n                    br--;\\n                    if (br == 0)\\n                    {\\n                        newNode = NestedIntegerInit();\\n                        NestedIntegerAdd(node, newNode);\\n                        parse(s, start, i + 1, newNode);\\n                        start = i + 1;\\n                    }\\n                    break;\\n            }\\n        }\\n        if (start < end - 1)\\n        {\\n            newNode = NestedIntegerInit();\\n            NestedIntegerAdd(node, newNode);\\n            parse(s, start, end - 1, newNode);\\n        }\\n    } else {\\n        char temp[end - start + 1];\\n        memcpy(temp, s + start, end - start);\\n        temp[end - start] = 0;\\n        int v = atoi(temp);\\n        NestedIntegerSetInteger(node, v);\\n    }\\n}\\n\\n\\nstruct NestedInteger* deserialize(char * s){\\n    struct NestedInteger* node = NestedIntegerInit();\\n    parse(s, 0, strlen(s), node);\\n    return node;\\n}\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * *********************************************************************\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * *********************************************************************\\n *\\n * // Initializes an empty nested list and return a reference to the nested integer.\\n * struct NestedInteger *NestedIntegerInit();\\n *\\n * // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n * bool NestedIntegerIsInteger(struct NestedInteger *);\\n *\\n * // Return the single integer that this NestedInteger holds, if it holds a single integer\\n * // The result is undefined if this NestedInteger holds a nested list\\n * int NestedIntegerGetInteger(struct NestedInteger *);\\n *\\n * // Set this NestedInteger to hold a single integer.\\n * void NestedIntegerSetInteger(struct NestedInteger *ni, int value);\\n *\\n * // Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\\n * void NestedIntegerAdd(struct NestedInteger *ni, struct NestedInteger *elem);\\n *\\n * // Return the nested list that this NestedInteger holds, if it holds a nested list\\n * // The result is undefined if this NestedInteger holds a single integer\\n * struct NestedInteger **NestedIntegerGetList(struct NestedInteger *);\\n *\\n * // Return the nested list\\'s size that this NestedInteger holds, if it holds a nested list\\n * // The result is undefined if this NestedInteger holds a single integer\\n * int NestedIntegerGetListSize(struct NestedInteger *);\\n * };\\n */\\n\\nstatic void parse(char *s, int start, int end, struct NestedInteger* node)\\n{\\n    if (start == end)\\n        return;\\n    if (s[start] == \\'[\\')\\n    {\\n        int br = 0;\\n        struct NestedInteger *newNode;\\n        start++;\\n        int i;\\n        for(i = start; i < end - 2; i++)\\n        {\\n            char c = s[i];\\n            switch(c)\\n            {\\n                case \\',\\':\\n                    if (br == 0)\\n                    {\\n                        if (start != i)\\n                        {\\n                            newNode = NestedIntegerInit();\\n                            NestedIntegerAdd(node, newNode);\\n                            parse(s, start, i, newNode);\\n                        }\\n                        start = i + 1;\\n                    }\\n                    break;\\n                case \\'[\\':\\n                    br++;\\n                    break;\\n                case \\']\\':\\n                    br--;\\n                    if (br == 0)\\n                    {\\n                        newNode = NestedIntegerInit();\\n                        NestedIntegerAdd(node, newNode);\\n                        parse(s, start, i + 1, newNode);\\n                        start = i + 1;\\n                    }\\n                    break;\\n            }\\n        }\\n        if (start < end - 1)\\n        {\\n            newNode = NestedIntegerInit();\\n            NestedIntegerAdd(node, newNode);\\n            parse(s, start, end - 1, newNode);\\n        }\\n    } else {\\n        char temp[end - start + 1];\\n        memcpy(temp, s + start, end - start);\\n        temp[end - start] = 0;\\n        int v = atoi(temp);\\n        NestedIntegerSetInteger(node, v);\\n    }\\n}\\n\\n\\nstruct NestedInteger* deserialize(char * s){\\n    struct NestedInteger* node = NestedIntegerInit();\\n    parse(s, 0, strlen(s), node);\\n    return node;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3999233,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * function NestedInteger() {\\n *\\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     @return {boolean}\\n *     this.isInteger = function() {\\n *         ...\\n *     };\\n *\\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     Return null if this NestedInteger holds a nested list\\n *     @return {integer}\\n *     this.getInteger = function() {\\n *         ...\\n *     };\\n *\\n *     Set this NestedInteger to hold a single integer equal to value.\\n *     @return {void}\\n *     this.setInteger = function(value) {\\n *         ...\\n *     };\\n *\\n *     Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\\n *     @return {void}\\n *     this.add = function(elem) {\\n *         ...\\n *     };\\n *\\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     Return null if this NestedInteger holds a single integer\\n *     @return {NestedInteger[]}\\n *     this.getList = function() {\\n *         ...\\n *     };\\n * };\\n */\\n/**\\n * @param {string} s\\n * @return {NestedInteger}\\n */\\nvar deserialize = function(s) {\\n    const helper = (input) => {\\n        if (Number.isInteger(input)) return new NestedInteger(input); \\n        let l = new NestedInteger();\\n        for (const e of input) l.add(helper(e));\\n        return l;\\n    };\\n    let a = JSON.parse(s);\\n    return helper(a);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * function NestedInteger() {\\n *\\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     @return {boolean}\\n *     this.isInteger = function() {\\n *         ...\\n *     };\\n *\\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     Return null if this NestedInteger holds a nested list\\n *     @return {integer}\\n *     this.getInteger = function() {\\n *         ...\\n *     };\\n *\\n *     Set this NestedInteger to hold a single integer equal to value.\\n *     @return {void}\\n *     this.setInteger = function(value) {\\n *         ...\\n *     };\\n *\\n *     Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\\n *     @return {void}\\n *     this.add = function(elem) {\\n *         ...\\n *     };\\n *\\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     Return null if this NestedInteger holds a single integer\\n *     @return {NestedInteger[]}\\n *     this.getList = function() {\\n *         ...\\n *     };\\n * };\\n */\\n/**\\n * @param {string} s\\n * @return {NestedInteger}\\n */\\nvar deserialize = function(s) {\\n    const helper = (input) => {\\n        if (Number.isInteger(input)) return new NestedInteger(input); \\n        let l = new NestedInteger();\\n        for (const e of input) l.add(helper(e));\\n        return l;\\n    };\\n    let a = JSON.parse(s);\\n    return helper(a);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941504,
                "title": "beats-100-00-of-users-with-python3",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen we encounter an opening bracket [, we create a new NestedInteger and push it onto a stack.\\n\\nWhen we encounter a closing bracket ], we finish constructing the current NestedInteger and pop it from the stack.\\n\\nWhile processing numbers and commas, we build the numbers and add them to the current NestedInteger.\\n\\nWe continue this process until we\\'ve read the entire input string.\\n\\nAt the end, we\\'re left with a single NestedInteger object, which represents the entire nested structure.\\n\\nOur approach w uses a stack to manage the nesting level and creates NestedInteger objects as we parse the input string. The final NestedInteger object represents the complete nested list. \\n\\n# Complexity\\n- Time complexity: **O(n)** where n is the length of the input string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n + d)** where n is the length of the input string and d is the maximum depth of nesting.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# \"\"\"\\n# This is the interface that allows for creating nested lists.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n#class NestedInteger:\\n#    def __init__(self, value=None):\\n#        \"\"\"\\n#        If value is not specified, initializes an empty list.\\n#        Otherwise initializes a single integer equal to value.\\n#        \"\"\"\\n#\\n#    def isInteger(self):\\n#        \"\"\"\\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\\n#        :rtype bool\\n#        \"\"\"\\n#\\n#    def add(self, elem):\\n#        \"\"\"\\n#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\\n#        :rtype void\\n#        \"\"\"\\n#\\n#    def setInteger(self, value):\\n#        \"\"\"\\n#        Set this NestedInteger to hold a single integer equal to value.\\n#        :rtype void\\n#        \"\"\"\\n#\\n#    def getInteger(self):\\n#        \"\"\"\\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\\n#        Return None if this NestedInteger holds a nested list\\n#        :rtype int\\n#        \"\"\"\\n#\\n#    def getList(self):\\n#        \"\"\"\\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\\n#        Return None if this NestedInteger holds a single integer\\n#        :rtype List[NestedInteger]\\n#        \"\"\"\\n\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        if not s:\\n            return None\\n        \\n        stack = []\\n        current = None\\n        num = \"\"\\n        \\n        for char in s:\\n            if char == \\'[\\':\\n                if current:\\n                    stack.append(current)\\n                current = NestedInteger()\\n            elif char == \\']\\':\\n                if num:\\n                    current.add(NestedInteger(int(num)))\\n                    num = \"\"\\n                if stack:\\n                    top = stack.pop()\\n                    top.add(current)\\n                    current = top\\n            elif char == \\',\\':\\n                if num:\\n                    current.add(NestedInteger(int(num)))\\n                    num = \"\"\\n            else:\\n                num += char\\n        \\n        if num:\\n            return NestedInteger(int(num))\\n        \\n        return current\\n\\n# Example usage\\n# serialized = \"[123,[456,[789]]]\"\\n# solution = Solution()\\n# result = solution.deserialize(serialized)\\n# print(result.getList()[0].getInteger())  # Output: 123\\n# print(result.getList()[1].getList()[0].getInteger())  # Output: 456\\n# print(result.getList()[1].getList()[1].getList()[0].getInteger())\\n# Output: 789\\n# print(result)  # Output: [123,[456,[789]]]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# \"\"\"\\n# This is the interface that allows for creating nested lists.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n#class NestedInteger:\\n#    def __init__(self, value=None):\\n#        \"\"\"\\n#        If value is not specified, initializes an empty list.\\n#        Otherwise initializes a single integer equal to value.\\n#        \"\"\"\\n#\\n#    def isInteger(self):\\n#        \"\"\"\\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\\n#        :rtype bool\\n#        \"\"\"\\n#\\n#    def add(self, elem):\\n#        \"\"\"\\n#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\\n#        :rtype void\\n#        \"\"\"\\n#\\n#    def setInteger(self, value):\\n#        \"\"\"\\n#        Set this NestedInteger to hold a single integer equal to value.\\n#        :rtype void\\n#        \"\"\"\\n#\\n#    def getInteger(self):\\n#        \"\"\"\\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\\n#        Return None if this NestedInteger holds a nested list\\n#        :rtype int\\n#        \"\"\"\\n#\\n#    def getList(self):\\n#        \"\"\"\\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\\n#        Return None if this NestedInteger holds a single integer\\n#        :rtype List[NestedInteger]\\n#        \"\"\"\\n\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        if not s:\\n            return None\\n        \\n        stack = []\\n        current = None\\n        num = \"\"\\n        \\n        for char in s:\\n            if char == \\'[\\':\\n                if current:\\n                    stack.append(current)\\n                current = NestedInteger()\\n            elif char == \\']\\':\\n                if num:\\n                    current.add(NestedInteger(int(num)))\\n                    num = \"\"\\n                if stack:\\n                    top = stack.pop()\\n                    top.add(current)\\n                    current = top\\n            elif char == \\',\\':\\n                if num:\\n                    current.add(NestedInteger(int(num)))\\n                    num = \"\"\\n            else:\\n                num += char\\n        \\n        if num:\\n            return NestedInteger(int(num))\\n        \\n        return current\\n\\n# Example usage\\n# serialized = \"[123,[456,[789]]]\"\\n# solution = Solution()\\n# result = solution.deserialize(serialized)\\n# print(result.getList()[0].getInteger())  # Output: 123\\n# print(result.getList()[1].getList()[0].getInteger())  # Output: 456\\n# print(result.getList()[1].getList()[1].getList()[0].getInteger())\\n# Output: 789\\n# print(result)  # Output: [123,[456,[789]]]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831823,
                "title": "intuitive-java-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nRecursively resolve the string into NestedInteger. If the string contains [*], it means it is a list. Otherwise, it is a number.\\n\\nOne tricky thing is to handle the string with comma, it can not simply divided by comma, because \\n\\n\"123,[456,[789]]\" should be 123 and [456,[789]]\\nbut not 123 and [456 and [789]]\\n\\nThus, if a comma is inside pairs of closed [], it means it is not a valid divider.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * public interface NestedInteger {\\n *     // Constructor initializes an empty nested list.\\n *     public NestedInteger();\\n *\\n *     // Constructor initializes a single integer.\\n *     public NestedInteger(int value);\\n *\\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     public boolean isInteger();\\n *\\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // Return null if this NestedInteger holds a nested list\\n *     public Integer getInteger();\\n *\\n *     // Set this NestedInteger to hold a single integer.\\n *     public void setInteger(int value);\\n *\\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\\n *     public void add(NestedInteger ni);\\n *\\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // Return empty list if this NestedInteger holds a single integer\\n *     public List<NestedInteger> getList();\\n * }\\n */\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        if (s.charAt(0) != \\'[\\') {\\n            return new NestedInteger(Integer.parseInt(s));\\n        } else {\\n            if (s.length() == 2) {\\n                return new NestedInteger();\\n            }\\n        }\\n        s = s.substring(1, s.length() - 1); // scrub the []\\n        List<NestedInteger> parts = specialCut(s);\\n        NestedInteger ni = new NestedInteger();\\n        for (NestedInteger part : parts) {\\n            ni.add(part);\\n        }\\n\\n        return ni;\\n    }\\n\\n    // 123,[456,[789]],234 -> 123 and [456,[789]] and 234\\n    private List<NestedInteger> specialCut(String s) {\\n        int p = 0;\\n        int prev = 0;\\n        int leftCount = 0;\\n        List<NestedInteger> result = new LinkedList<>();\\n        while (p < s.length()) {\\n            if (s.charAt(p) == \\',\\') {\\n                if (leftCount == 0) {\\n                    result.add(deserialize(s.substring(prev, p)));\\n                    prev = p + 1;\\n                }\\n            } else if (s.charAt(p) == \\'[\\') {\\n                leftCount++;\\n            } else if (s.charAt(p) == \\']\\') {\\n                leftCount--;\\n            }\\n            p++;\\n        }\\n        result.add(deserialize(s.substring(prev)));\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * public interface NestedInteger {\\n *     // Constructor initializes an empty nested list.\\n *     public NestedInteger();\\n *\\n *     // Constructor initializes a single integer.\\n *     public NestedInteger(int value);\\n *\\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     public boolean isInteger();\\n *\\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // Return null if this NestedInteger holds a nested list\\n *     public Integer getInteger();\\n *\\n *     // Set this NestedInteger to hold a single integer.\\n *     public void setInteger(int value);\\n *\\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\\n *     public void add(NestedInteger ni);\\n *\\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // Return empty list if this NestedInteger holds a single integer\\n *     public List<NestedInteger> getList();\\n * }\\n */\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        if (s.charAt(0) != \\'[\\') {\\n            return new NestedInteger(Integer.parseInt(s));\\n        } else {\\n            if (s.length() == 2) {\\n                return new NestedInteger();\\n            }\\n        }\\n        s = s.substring(1, s.length() - 1); // scrub the []\\n        List<NestedInteger> parts = specialCut(s);\\n        NestedInteger ni = new NestedInteger();\\n        for (NestedInteger part : parts) {\\n            ni.add(part);\\n        }\\n\\n        return ni;\\n    }\\n\\n    // 123,[456,[789]],234 -> 123 and [456,[789]] and 234\\n    private List<NestedInteger> specialCut(String s) {\\n        int p = 0;\\n        int prev = 0;\\n        int leftCount = 0;\\n        List<NestedInteger> result = new LinkedList<>();\\n        while (p < s.length()) {\\n            if (s.charAt(p) == \\',\\') {\\n                if (leftCount == 0) {\\n                    result.add(deserialize(s.substring(prev, p)));\\n                    prev = p + 1;\\n                }\\n            } else if (s.charAt(p) == \\'[\\') {\\n                leftCount++;\\n            } else if (s.charAt(p) == \\']\\') {\\n                leftCount--;\\n            }\\n            p++;\\n        }\\n        result.add(deserialize(s.substring(prev)));\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717122,
                "title": "python-code-along-with-algorithm",
                "content": "# Approach\\nUsing Stack and DFS(Depth-first search)\\n\\nSince the input is a string, which is not much helpful for our stack approach\\nFirst we will convert the string into an array with the following condition:\\n- The $$]$$, $$[$$, and the integers (represented as string) should be added as a sepearte element to the array\\n- All \\'$$,$$\\' should be ignored\\ne.g. \"[123,[345,654]]\" $$\\\\rightarrow$$ $$[$$ \\' [ \\', \\'123\\', \\'[\\', \\'345\\', \\'654\\', \\']\\', \\']\\' $$]$$\\n\\n#### convert string to array algorithm\\n```\\nCONVERT(string):\\n    Step 1: Declare an array \\'arr\\' and a variable \\'cache\\'\\n    Step 2: For each individual character \\'ele\\' in string\\n        Step 2.1: if ele is \"[\": add ele to arr\\n        Step 2.2: else if ele is \"]\":\\n            Step 2.2.1: First add cache to the arr, then assign cache = \"\"\\n            Step 2.2.2: Add ele to the arr\\n        Step 2.3: else if ele is \",\":\\n            Step 2.3.1: Add the cache to the arr, then assign cache = \"\"\\n        Step 2.4: else: add ele to the cache\\n    Step 3: if cache is not empty string: add cache to the arr\\n    Step 4: Return arr\\n```\\nThe next approach is very simple\\n```\\nStep 1: string_arr = CONVERT(s) and declare a stack = []\\nStep 2: if length(string_arr) = 1: s is just an integer\\n    Step 2.1: Return NestedInteger(int(string_arr[0]))\\nStep 3: For each element \\'ele\\' in string_arr:\\n    Step 3.1: if ele not equals to \\']\\': add to the stack\\n    Step 3.2: else:\\n        Step 3.2.1: Keeping poping from stack and save it to \\'temp\\' array until \\'[\\' is encountered:\\n        Step 3.2.2: create a NestedInteger object \\'temp_ans\\' and add the element of temp array to temp_ans using .add function\\n        Step 3.2.3: Add temp_ans to stack\\nStep 4: Return stack[0]\\n\\n```\\n> check out the Python code for implementation, there may be some obvious pitfalls while implementing the idea\\n# Code\\n```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        def convert(string):\\n            arr = []\\n            cache =\"\"\\n            for ele in string:\\n                if ele == \"[\":\\n                    arr.append(ele)\\n                elif ele == \"]\":\\n                    if cache:\\n                        arr.append(cache)\\n                    arr.append(ele)\\n                    cache = \"\"\\n                elif ele == \",\":\\n                    if cache:\\n                        arr.append(cache)\\n                    cache = \"\"\\n                else:\\n                    cache += ele\\n            if cache:\\n                arr.append(cache)\\n            return arr\\n        string_arr = convert(s)\\n        stack = []\\n        ans = None\\n        # print(string_arr)\\n\\n        if len(string_arr) == 1:\\n            return NestedInteger(int(string_arr[0]))        \\n        for i in range(len(string_arr)):\\n            ele = string_arr[i]\\n            if ele != \\']\\':\\n                stack.append(ele)\\n            else:\\n                temp = []\\n                while(stack[-1] != \\'[\\'):\\n                    poped = stack.pop(-1)\\n                    temp = [poped] + temp\\n                stack.pop(-1)\\n                temp_ans = NestedInteger()\\n                for t in temp:\\n                    if type(t) == type(\"1\"):\\n                        temp_ans.add(NestedInteger( int(t)) )\\n                    else:\\n                        temp_ans.add(t)\\n                stack.append(temp_ans)\\n               \\n        return stack[0]\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nCONVERT(string):\\n    Step 1: Declare an array \\'arr\\' and a variable \\'cache\\'\\n    Step 2: For each individual character \\'ele\\' in string\\n        Step 2.1: if ele is \"[\": add ele to arr\\n        Step 2.2: else if ele is \"]\":\\n            Step 2.2.1: First add cache to the arr, then assign cache = \"\"\\n            Step 2.2.2: Add ele to the arr\\n        Step 2.3: else if ele is \",\":\\n            Step 2.3.1: Add the cache to the arr, then assign cache = \"\"\\n        Step 2.4: else: add ele to the cache\\n    Step 3: if cache is not empty string: add cache to the arr\\n    Step 4: Return arr\\n```\n```\\nStep 1: string_arr = CONVERT(s) and declare a stack = []\\nStep 2: if length(string_arr) = 1: s is just an integer\\n    Step 2.1: Return NestedInteger(int(string_arr[0]))\\nStep 3: For each element \\'ele\\' in string_arr:\\n    Step 3.1: if ele not equals to \\']\\': add to the stack\\n    Step 3.2: else:\\n        Step 3.2.1: Keeping poping from stack and save it to \\'temp\\' array until \\'[\\' is encountered:\\n        Step 3.2.2: create a NestedInteger object \\'temp_ans\\' and add the element of temp array to temp_ans using .add function\\n        Step 3.2.3: Add temp_ans to stack\\nStep 4: Return stack[0]\\n\\n```\n```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        def convert(string):\\n            arr = []\\n            cache =\"\"\\n            for ele in string:\\n                if ele == \"[\":\\n                    arr.append(ele)\\n                elif ele == \"]\":\\n                    if cache:\\n                        arr.append(cache)\\n                    arr.append(ele)\\n                    cache = \"\"\\n                elif ele == \",\":\\n                    if cache:\\n                        arr.append(cache)\\n                    cache = \"\"\\n                else:\\n                    cache += ele\\n            if cache:\\n                arr.append(cache)\\n            return arr\\n        string_arr = convert(s)\\n        stack = []\\n        ans = None\\n        # print(string_arr)\\n\\n        if len(string_arr) == 1:\\n            return NestedInteger(int(string_arr[0]))        \\n        for i in range(len(string_arr)):\\n            ele = string_arr[i]\\n            if ele != \\']\\':\\n                stack.append(ele)\\n            else:\\n                temp = []\\n                while(stack[-1] != \\'[\\'):\\n                    poped = stack.pop(-1)\\n                    temp = [poped] + temp\\n                stack.pop(-1)\\n                temp_ans = NestedInteger()\\n                for t in temp:\\n                    if type(t) == type(\"1\"):\\n                        temp_ans.add(NestedInteger( int(t)) )\\n                    else:\\n                        temp_ans.add(t)\\n                stack.append(temp_ans)\\n               \\n        return stack[0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599357,
                "title": "c-recursively-break-down-nested-expressions",
                "content": "This is not intended as an optimal solution, just one that is easy to understand. \\n```\\nclass Solution {\\n  // Parse input and handle case when input is not an integer\\n  optional<int> parseInt(string_view s) {\\n    int x;\\n    auto result = from_chars(s.data(), s.data() + s.size(), x);\\n    if (result.ec == errc::invalid_argument) {\\n      return nullopt;\\n    }\\n    return optional<int>(x);\\n  }\\npublic:\\n    NestedInteger deserialize(string_view s) {\\n      // Base numeric case: 123\\n      if (s[0] != \\'[\\') {\\n        if (auto x = parseInt(s))\\n          return NestedInteger(*x);\\n        return NestedInteger();\\n      }\\n      \\n      int n = s.length(), pos = 1;\\n      // Base empty case: []\\n      if (n == 2) \\n        return NestedInteger();\\n      \\n      // Nested case: comma separated tokens\\n      NestedInteger ni;\\n      vector<string_view> tokens;\\n      for (int i = 1; i < n; i++) {\\n        if (s[i] == \\',\\') {\\n          tokens.push_back(s.substr(pos, i - pos));\\n          pos = i + 1;\\n        } else if (s[i] == \\'[\\') {\\n          // move `i` to end of nested expression - balanced brackets\\n          stack<int> stk; stk.push(i);\\n          for (i = i + 1; i < n-1 && !stk.empty(); i++) {\\n            if (s[i] == \\']\\') stk.pop();\\n            else if (s[i] == \\'[\\') stk.push(i);\\n          }\\n          tokens.push_back(s.substr(pos, i - pos));\\n          pos = i + 1;\\n        }\\n      }\\n      // Grab the last token\\n      if (pos != n)\\n        tokens.push_back(s.substr(pos, n - 1 - pos));\\n      \\n      // Deserialize each token and add to current NestedInteger\\n      for (auto t : tokens) {\\n        ni.add(deserialize(t));\\n      }\\n      return ni;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  // Parse input and handle case when input is not an integer\\n  optional<int> parseInt(string_view s) {\\n    int x;\\n    auto result = from_chars(s.data(), s.data() + s.size(), x);\\n    if (result.ec == errc::invalid_argument) {\\n      return nullopt;\\n    }\\n    return optional<int>(x);\\n  }\\npublic:\\n    NestedInteger deserialize(string_view s) {\\n      // Base numeric case: 123\\n      if (s[0] != \\'[\\') {\\n        if (auto x = parseInt(s))\\n          return NestedInteger(*x);\\n        return NestedInteger();\\n      }\\n      \\n      int n = s.length(), pos = 1;\\n      // Base empty case: []\\n      if (n == 2) \\n        return NestedInteger();\\n      \\n      // Nested case: comma separated tokens\\n      NestedInteger ni;\\n      vector<string_view> tokens;\\n      for (int i = 1; i < n; i++) {\\n        if (s[i] == \\',\\') {\\n          tokens.push_back(s.substr(pos, i - pos));\\n          pos = i + 1;\\n        } else if (s[i] == \\'[\\') {\\n          // move `i` to end of nested expression - balanced brackets\\n          stack<int> stk; stk.push(i);\\n          for (i = i + 1; i < n-1 && !stk.empty(); i++) {\\n            if (s[i] == \\']\\') stk.pop();\\n            else if (s[i] == \\'[\\') stk.push(i);\\n          }\\n          tokens.push_back(s.substr(pos, i - pos));\\n          pos = i + 1;\\n        }\\n      }\\n      // Grab the last token\\n      if (pos != n)\\n        tokens.push_back(s.substr(pos, n - 1 - pos));\\n      \\n      // Deserialize each token and add to current NestedInteger\\n      for (auto t : tokens) {\\n        ni.add(deserialize(t));\\n      }\\n      return ni;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584975,
                "title": "c-one-pass-with-stack-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public NestedInteger Deserialize(string s) \\n    {\\n        var st = new Stack<NestedInteger>();\\n\\n        // dummy root to avoid st.Count > 0 check\\n        st.Push(new NestedInteger()); \\n\\n        NestedInteger current = null;\\n\\n        for(var i=0; i < s.Length; i++)\\n        {\\n            var ch = s[i];\\n\\n            if(ch == \\'[\\')\\n            {\\n                current = new NestedInteger();\\n                st.Peek().Add(current);\\n                st.Push(current);\\n            }\\n            else if(ch == \\']\\')\\n            {\\n                current = st.Pop();\\n            }\\n            else if(ch == \\',\\')\\n            {\\n                continue;\\n            }\\n            else // parse digits and \\'-\\'\\n            {\\n                var j = i + 1; \\n\\n                while(j < s.Length && \\n                    (Char.IsDigit(s[j]) || s[j] == \\'-\\')) j++;\\n\\n                current = new NestedInteger(int.Parse(s[i..j]));\\n\\n                st.Peek().Add(current);\\n\\n                i = j - 1;\\n            }\\n        }\\n\\n        return current;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public NestedInteger Deserialize(string s) \\n    {\\n        var st = new Stack<NestedInteger>();\\n\\n        // dummy root to avoid st.Count > 0 check\\n        st.Push(new NestedInteger()); \\n\\n        NestedInteger current = null;\\n\\n        for(var i=0; i < s.Length; i++)\\n        {\\n            var ch = s[i];\\n\\n            if(ch == \\'[\\')\\n            {\\n                current = new NestedInteger();\\n                st.Peek().Add(current);\\n                st.Push(current);\\n            }\\n            else if(ch == \\']\\')\\n            {\\n                current = st.Pop();\\n            }\\n            else if(ch == \\',\\')\\n            {\\n                continue;\\n            }\\n            else // parse digits and \\'-\\'\\n            {\\n                var j = i + 1; \\n\\n                while(j < s.Length && \\n                    (Char.IsDigit(s[j]) || s[j] == \\'-\\')) j++;\\n\\n                current = new NestedInteger(int.Parse(s[i..j]));\\n\\n                st.Peek().Add(current);\\n\\n                i = j - 1;\\n            }\\n        }\\n\\n        return current;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341737,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\nprivate:\\n    NestedInteger dfs(string& s, int& i) {\\n        NestedInteger res;\\n        int n(s.size());\\n        for ( ;i < n; ++i) {\\n            if (s[i] == \\',\\') continue;\\n            if (s[i] == \\'[\\') res.add(dfs(s,++i));\\n            else if (s[i]==\\']\\') break;\\n            else {\\n                int sgn(0);\\n                if (s[i]==\\'-\\') sgn = s[i++];\\n                int m(s[i]-\\'0\\');\\n                while (i+1 < n && isdigit(s[i+1])) m = m*10+(s[++i]-\\'0\\');\\n                res.add(NestedInteger(sgn?-m:m));\\n            }\\n        }\\n        return res;\\n    }\\npublic:\\n    NestedInteger deserialize(string s) {\\n        int i(0);\\n        return dfs(s,i).getList()[0];\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        if s[0] != \\'[\\':\\n            return NestedInteger(int(s))\\n        word = \\'\\'\\n\\n        output = NestedInteger()\\n        parents = [output]\\n        word = \\'\\'\\n        for char in s[1:-1]:\\n            if char in {\\'[\\', \\',\\', \\']\\'}:\\n                if word:\\n                    parents[-1].add(NestedInteger(int(word)))\\n                    word = \\'\\'\\n                if char == \\'[\\':\\n                    newlist = NestedInteger()\\n                    parents[-1].add(newlist)\\n                    parents.append(newlist)\\n                elif char == \\']\\':\\n                    parents.pop()\\n            else:\\n                word += char\\n        if word:\\n            parents[-1].add(NestedInteger(int(word)))\\n        return output\\n```\\n\\n```Java []\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        return run(s, 0, new int[1]).getList().get(0);\\n    }\\n    NestedInteger run(String s, int idx, int[] nextidx) {\\n\\n        int i = idx;\\n        \\n        NestedInteger newni = new NestedInteger();\\n        boolean neg = false;\\n        while(i < s.length()) {\\n\\n            char c = s.charAt(i);\\n\\n            if(isInteger(c)) {\\n                int v = 0;\\n                while(i < s.length()  && isInteger(s.charAt(i))) {\\n                    c = s.charAt(i);\\n                    v = v * 10 + c - \\'0\\';\\n                    i++;\\n                }\\n                i--;\\n                if(neg) {\\n                    v = v * -1;\\n                }\\n                neg = false;\\n                NestedInteger ni = new NestedInteger(v);\\n                newni.add(ni);\\n            } else if (c == \\',\\') {\\n\\n            } else if (c == \\'[\\') {\\n                newni.add(run(s, i + 1, nextidx));\\n                i = nextidx[0];\\n            } else if (c == \\']\\') {\\n                nextidx[0] = i;\\n                return newni;\\n            } else {\\n                neg = true;\\n            }\\n            i++;\\n        }\\n        return newni;\\n    }\\n    boolean isInteger(char c) {\\n        return c >= \\'0\\' && c <= \\'9\\';\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\nprivate:\\n    NestedInteger dfs(string& s, int& i) {\\n        NestedInteger res;\\n        int n(s.size());\\n        for ( ;i < n; ++i) {\\n            if (s[i] == \\',\\') continue;\\n            if (s[i] == \\'[\\') res.add(dfs(s,++i));\\n            else if (s[i]==\\']\\') break;\\n            else {\\n                int sgn(0);\\n                if (s[i]==\\'-\\') sgn = s[i++];\\n                int m(s[i]-\\'0\\');\\n                while (i+1 < n && isdigit(s[i+1])) m = m*10+(s[++i]-\\'0\\');\\n                res.add(NestedInteger(sgn?-m:m));\\n            }\\n        }\\n        return res;\\n    }\\npublic:\\n    NestedInteger deserialize(string s) {\\n        int i(0);\\n        return dfs(s,i).getList()[0];\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        if s[0] != \\'[\\':\\n            return NestedInteger(int(s))\\n        word = \\'\\'\\n\\n        output = NestedInteger()\\n        parents = [output]\\n        word = \\'\\'\\n        for char in s[1:-1]:\\n            if char in {\\'[\\', \\',\\', \\']\\'}:\\n                if word:\\n                    parents[-1].add(NestedInteger(int(word)))\\n                    word = \\'\\'\\n                if char == \\'[\\':\\n                    newlist = NestedInteger()\\n                    parents[-1].add(newlist)\\n                    parents.append(newlist)\\n                elif char == \\']\\':\\n                    parents.pop()\\n            else:\\n                word += char\\n        if word:\\n            parents[-1].add(NestedInteger(int(word)))\\n        return output\\n```\n```Java []\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        return run(s, 0, new int[1]).getList().get(0);\\n    }\\n    NestedInteger run(String s, int idx, int[] nextidx) {\\n\\n        int i = idx;\\n        \\n        NestedInteger newni = new NestedInteger();\\n        boolean neg = false;\\n        while(i < s.length()) {\\n\\n            char c = s.charAt(i);\\n\\n            if(isInteger(c)) {\\n                int v = 0;\\n                while(i < s.length()  && isInteger(s.charAt(i))) {\\n                    c = s.charAt(i);\\n                    v = v * 10 + c - \\'0\\';\\n                    i++;\\n                }\\n                i--;\\n                if(neg) {\\n                    v = v * -1;\\n                }\\n                neg = false;\\n                NestedInteger ni = new NestedInteger(v);\\n                newni.add(ni);\\n            } else if (c == \\',\\') {\\n\\n            } else if (c == \\'[\\') {\\n                newni.add(run(s, i + 1, nextidx));\\n                i = nextidx[0];\\n            } else if (c == \\']\\') {\\n                nextidx[0] = i;\\n                return newni;\\n            } else {\\n                neg = true;\\n            }\\n            i++;\\n        }\\n        return newni;\\n    }\\n    boolean isInteger(char c) {\\n        return c >= \\'0\\' && c <= \\'9\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216312,
                "title": "recursion-on-a-single-pass",
                "content": "# Intuition\\nAt each level step in whenever we see an open bracket and step out when we see a close bracket\\n\\n# Approach\\nConvert the string to vector in order to simplify tracking which characters have already been parsed.\\n\\n# Complexity\\n- Time complexity:\\nO(n) since we process each char only once.\\n\\n- Space complexity:\\nIn the case we open m brackets then close them the recursion creates m new function calls, so worst case is O(n).\\n\\n# Code\\n```\\nuse NestedInteger::{Int,List};\\nimpl Solution {\\n    pub fn deserialize(s: String) -> NestedInteger {\\n        fn step(mut i:usize, bs: &Vec<u8>) -> (NestedInteger, usize) {\\n            let mut lst = List(Vec::new());\\n            let mut num: Option<i32> = None;\\n            let mut sgn = 1_i32;\\n            while i < bs.len() {\\n                match bs[i] {\\n                    b@ b\\'0\\'..=b\\'9\\' => {num = Some(num.unwrap_or(0) * 10 + (b - b\\'0\\') as i32);},\\n                    b\\'-\\' => {sgn = -1;},\\n                    b\\',\\' => {\\n                        if let Some(n) = num {\\n                            if let List(ref mut v) = lst {\\n                                v.push(Int(sgn * n));\\n                            }\\n                            num = None;\\n                            sgn = 1;\\n                        }\\n                    },\\n                    b\\'[\\' => {\\n                        if let List(ref mut v) = lst {\\n                            let (ni,new_i) = step(i+1,bs);\\n                            v.push(ni);\\n                            i = new_i;\\n                        }\\n                    },\\n                    b\\']\\' => {\\n                        if let Some(n) = num {\\n                            if let List(ref mut v) = lst {\\n                                v.push(Int(sgn * n));\\n                            }\\n                            num = None;\\n                            sgn = 1;\\n                        }\\n                        return (lst,i)\\n                    },\\n                    b@ _ => unreachable!(\"unallowed byte: {:?}\", b)\\n                }\\n                i += 1;\\n            }\\n            if let Some(n) = num {\\n                (Int(sgn * n), i)\\n            } else if let List(mut r) = lst {\\n                (r.pop().unwrap(),i)\\n            } else {\\n                (Int(0), i)\\n            }\\n        }\\n        let bs = s.bytes().collect::<Vec<_>>();\\n        step(0, &bs).0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse NestedInteger::{Int,List};\\nimpl Solution {\\n    pub fn deserialize(s: String) -> NestedInteger {\\n        fn step(mut i:usize, bs: &Vec<u8>) -> (NestedInteger, usize) {\\n            let mut lst = List(Vec::new());\\n            let mut num: Option<i32> = None;\\n            let mut sgn = 1_i32;\\n            while i < bs.len() {\\n                match bs[i] {\\n                    b@ b\\'0\\'..=b\\'9\\' => {num = Some(num.unwrap_or(0) * 10 + (b - b\\'0\\') as i32);},\\n                    b\\'-\\' => {sgn = -1;},\\n                    b\\',\\' => {\\n                        if let Some(n) = num {\\n                            if let List(ref mut v) = lst {\\n                                v.push(Int(sgn * n));\\n                            }\\n                            num = None;\\n                            sgn = 1;\\n                        }\\n                    },\\n                    b\\'[\\' => {\\n                        if let List(ref mut v) = lst {\\n                            let (ni,new_i) = step(i+1,bs);\\n                            v.push(ni);\\n                            i = new_i;\\n                        }\\n                    },\\n                    b\\']\\' => {\\n                        if let Some(n) = num {\\n                            if let List(ref mut v) = lst {\\n                                v.push(Int(sgn * n));\\n                            }\\n                            num = None;\\n                            sgn = 1;\\n                        }\\n                        return (lst,i)\\n                    },\\n                    b@ _ => unreachable!(\"unallowed byte: {:?}\", b)\\n                }\\n                i += 1;\\n            }\\n            if let Some(n) = num {\\n                (Int(sgn * n), i)\\n            } else if let List(mut r) = lst {\\n                (r.pop().unwrap(),i)\\n            } else {\\n                (Int(0), i)\\n            }\\n        }\\n        let bs = s.bytes().collect::<Vec<_>>();\\n        step(0, &bs).0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3209531,
                "title": "one-pass-stack",
                "content": "# Intuition\\nHere we see nested structs. It is good to use stack for this type of tasks\\n\\n\\n# Complexity\\n- Time complexity:\\n0(1)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Constructor initializes an empty nested list.\\n *     NestedInteger();\\n *\\n *     // Constructor initializes a single integer.\\n *     NestedInteger(int value);\\n *\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Set this NestedInteger to hold a single integer.\\n *     void setInteger(int value);\\n *\\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\\n *     void add(const NestedInteger &ni);\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n\\n        stack<NestedInteger> st;\\n        bool minus = false;\\n        optional<int> val;\\n        for(char ch : s) {\\n            switch(ch) {\\n                case \\'-\\' : minus = true; break;\\n                case \\',\\' : {\\n                    if(val) {\\n                        NestedInteger &v = st.top();\\n                        if(minus) {\\n                            *val *= -1;\\n                            minus = false;\\n                        }\\n                        v.add(*val);\\n                        val.reset();\\n                    }\\n                    break;\\n                }\\n                case \\'[\\' : {\\n                    st.push(NestedInteger());\\n                    break;\\n                }\\n                case \\']\\' : {\\n                    if(val) {\\n                        NestedInteger &v = st.top();\\n                        if(minus) {\\n                            *val *= -1;\\n                            minus = false;\\n                        }\\n                        v.add(*val);\\n                        val.reset();\\n                    }\\n                    if(st.size() > 1) {\\n                        NestedInteger l = st.top();\\n                        st.pop();\\n                        NestedInteger &v = st.top();\\n                        v.add(l);\\n                    }\\n                    break;\\n                }\\n                default : {\\n                    if(val)\\n                        val = (*val * 10) + (ch - \\'0\\');\\n                    else\\n                        val = (ch - \\'0\\');\\n                }\\n            }\\n        }\\n        if(val) {\\n            if(st.empty())\\n                st.push(NestedInteger());\\n            if(minus)\\n                *val *= -1;\\n            NestedInteger &v = st.top();\\n            v.setInteger(*val);\\n        }\\n\\n        return st.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Constructor initializes an empty nested list.\\n *     NestedInteger();\\n *\\n *     // Constructor initializes a single integer.\\n *     NestedInteger(int value);\\n *\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Set this NestedInteger to hold a single integer.\\n *     void setInteger(int value);\\n *\\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\\n *     void add(const NestedInteger &ni);\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n\\n        stack<NestedInteger> st;\\n        bool minus = false;\\n        optional<int> val;\\n        for(char ch : s) {\\n            switch(ch) {\\n                case \\'-\\' : minus = true; break;\\n                case \\',\\' : {\\n                    if(val) {\\n                        NestedInteger &v = st.top();\\n                        if(minus) {\\n                            *val *= -1;\\n                            minus = false;\\n                        }\\n                        v.add(*val);\\n                        val.reset();\\n                    }\\n                    break;\\n                }\\n                case \\'[\\' : {\\n                    st.push(NestedInteger());\\n                    break;\\n                }\\n                case \\']\\' : {\\n                    if(val) {\\n                        NestedInteger &v = st.top();\\n                        if(minus) {\\n                            *val *= -1;\\n                            minus = false;\\n                        }\\n                        v.add(*val);\\n                        val.reset();\\n                    }\\n                    if(st.size() > 1) {\\n                        NestedInteger l = st.top();\\n                        st.pop();\\n                        NestedInteger &v = st.top();\\n                        v.add(l);\\n                    }\\n                    break;\\n                }\\n                default : {\\n                    if(val)\\n                        val = (*val * 10) + (ch - \\'0\\');\\n                    else\\n                        val = (ch - \\'0\\');\\n                }\\n            }\\n        }\\n        if(val) {\\n            if(st.empty())\\n                st.push(NestedInteger());\\n            if(minus)\\n                *val *= -1;\\n            NestedInteger &v = st.top();\\n            v.setInteger(*val);\\n        }\\n\\n        return st.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192644,
                "title": "antarnab-100-faster-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Constructor initializes an empty nested list.\\n *     NestedInteger();\\n *\\n *     // Constructor initializes a single integer.\\n *     NestedInteger(int value);\\n *\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Set this NestedInteger to hold a single integer.\\n *     void setInteger(int value);\\n *\\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\\n *     void add(const NestedInteger &ni);\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        function<bool(char)> isnumber = [](char c){ return (c == \\'-\\') || isdigit(c); };\\n        \\n        stack<NestedInteger> stk;\\n        stk.push(NestedInteger());\\n        \\n        for (auto it = s.begin(); it != s.end();) {\\n            const char & c = (*it);\\n            if (isnumber(c)) {\\n                auto it2 = find_if_not(it, s.end(), isnumber);\\n                int val = stoi(string(it, it2));\\n                stk.top().add(NestedInteger(val));\\n                it = it2;\\n            }\\n            else {\\n                if (c == \\'[\\') {\\n                    stk.push(NestedInteger());\\n                }\\n                else if (c == \\']\\') {\\n                    NestedInteger ni = stk.top();\\n                    stk.pop();\\n                    stk.top().add(ni);\\n                }\\n                ++it;\\n            }\\n        }\\n        \\n        NestedInteger result = stk.top().getList().front();\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Constructor initializes an empty nested list.\\n *     NestedInteger();\\n *\\n *     // Constructor initializes a single integer.\\n *     NestedInteger(int value);\\n *\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Set this NestedInteger to hold a single integer.\\n *     void setInteger(int value);\\n *\\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\\n *     void add(const NestedInteger &ni);\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        function<bool(char)> isnumber = [](char c){ return (c == \\'-\\') || isdigit(c); };\\n        \\n        stack<NestedInteger> stk;\\n        stk.push(NestedInteger());\\n        \\n        for (auto it = s.begin(); it != s.end();) {\\n            const char & c = (*it);\\n            if (isnumber(c)) {\\n                auto it2 = find_if_not(it, s.end(), isnumber);\\n                int val = stoi(string(it, it2));\\n                stk.top().add(NestedInteger(val));\\n                it = it2;\\n            }\\n            else {\\n                if (c == \\'[\\') {\\n                    stk.push(NestedInteger());\\n                }\\n                else if (c == \\']\\') {\\n                    NestedInteger ni = stk.top();\\n                    stk.pop();\\n                    stk.top().add(ni);\\n                }\\n                ++it;\\n            }\\n        }\\n        \\n        NestedInteger result = stk.top().getList().front();\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142252,
                "title": "recursive-parse",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g.  -->\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Constructor initializes an empty nested list.\\n *     NestedInteger();\\n *\\n *     // Constructor initializes a single integer.\\n *     NestedInteger(int value);\\n *\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Set this NestedInteger to hold a single integer.\\n *     void setInteger(int value);\\n *\\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\\n *     void add(const NestedInteger &ni);\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        int pos = 0;\\n        return build(s, pos);\\n    }\\n\\n    NestedInteger build(string & s, int & pos) {\\n        // cout << \"calling : \" << s.substr(pos) << endl;\\n        if(s[pos] == \\'-\\' or isdigit(s[pos])) {\\n            bool neg = false;\\n            if(s[pos] == \\'-\\') {neg = true; pos++;}\\n            int num = 0;\\n            while(pos < s.size() and isdigit(s[pos])) {\\n                num *= 10;\\n                num += s[pos++] - \\'0\\';   \\n            }\\n            if(neg) return NestedInteger(-num);\\n            else return NestedInteger(num);\\n        }\\n        NestedInteger root;\\n        if(s[pos] == \\'[\\') pos++;\\n        while(s[pos] != \\']\\') {\\n            if(isdigit(s[pos]) or s[pos]== \\'-\\' or s[pos] == \\'[\\') {\\n                root.add(build(s, pos));\\n            }\\n            else if(s[pos] == \\',\\') {\\n                pos++;\\n            }\\n        }\\n        pos++;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * class NestedInteger {\\n *   public:\\n *     // Constructor initializes an empty nested list.\\n *     NestedInteger();\\n *\\n *     // Constructor initializes a single integer.\\n *     NestedInteger(int value);\\n *\\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     bool isInteger() const;\\n *\\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // The result is undefined if this NestedInteger holds a nested list\\n *     int getInteger() const;\\n *\\n *     // Set this NestedInteger to hold a single integer.\\n *     void setInteger(int value);\\n *\\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\\n *     void add(const NestedInteger &ni);\\n *\\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // The result is undefined if this NestedInteger holds a single integer\\n *     const vector<NestedInteger> &getList() const;\\n * };\\n */\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        int pos = 0;\\n        return build(s, pos);\\n    }\\n\\n    NestedInteger build(string & s, int & pos) {\\n        // cout << \"calling : \" << s.substr(pos) << endl;\\n        if(s[pos] == \\'-\\' or isdigit(s[pos])) {\\n            bool neg = false;\\n            if(s[pos] == \\'-\\') {neg = true; pos++;}\\n            int num = 0;\\n            while(pos < s.size() and isdigit(s[pos])) {\\n                num *= 10;\\n                num += s[pos++] - \\'0\\';   \\n            }\\n            if(neg) return NestedInteger(-num);\\n            else return NestedInteger(num);\\n        }\\n        NestedInteger root;\\n        if(s[pos] == \\'[\\') pos++;\\n        while(s[pos] != \\']\\') {\\n            if(isdigit(s[pos]) or s[pos]== \\'-\\' or s[pos] == \\'[\\') {\\n                root.add(build(s, pos));\\n            }\\n            else if(s[pos] == \\',\\') {\\n                pos++;\\n            }\\n        }\\n        pos++;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3124616,
                "title": "fast-deserialize-with-recursion",
                "content": "# Intuition\\nRecursion\\n\\n# Approach\\nBreaking the String down to identify Integers and Nested NestedIntegers.\\n\\n# Code\\n```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        if(s.charAt(0) != \\'[\\') return new NestedInteger(Integer.parseInt(s));\\n        NestedInteger nt = new NestedInteger();\\n        int open = 0;\\n        int posfirstOpen = 1;\\n        int numStart = -1;\\n        for(int i = 1; i < s.length()-1; i++) {\\n            switch (s.charAt(i)) {\\n                case \\'[\\':\\n                    if(open++ == 0) posfirstOpen = i; \\n                    break;\\n                case \\']\\':\\n                    if(--open == 0) \\n                        nt.add(deserialize(s.substring(posfirstOpen, i+1)));\\n                    break;\\n                case \\',\\':\\n                    if(numStart == -1) break;\\n                    nt.add(deserialize(s.substring(numStart, i)));\\n                    numStart = -1;\\n                    break;\\n                default:\\n                    if(numStart == -1 && open == 0) numStart = i;\\n            }\\n        }\\n        if(numStart != -1) \\n            nt.add(deserialize(s.substring(numStart,s.length()-1)));\\n        return nt; \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        if(s.charAt(0) != \\'[\\') return new NestedInteger(Integer.parseInt(s));\\n        NestedInteger nt = new NestedInteger();\\n        int open = 0;\\n        int posfirstOpen = 1;\\n        int numStart = -1;\\n        for(int i = 1; i < s.length()-1; i++) {\\n            switch (s.charAt(i)) {\\n                case \\'[\\':\\n                    if(open++ == 0) posfirstOpen = i; \\n                    break;\\n                case \\']\\':\\n                    if(--open == 0) \\n                        nt.add(deserialize(s.substring(posfirstOpen, i+1)));\\n                    break;\\n                case \\',\\':\\n                    if(numStart == -1) break;\\n                    nt.add(deserialize(s.substring(numStart, i)));\\n                    numStart = -1;\\n                    break;\\n                default:\\n                    if(numStart == -1 && open == 0) numStart = i;\\n            }\\n        }\\n        if(numStart != -1) \\n            nt.add(deserialize(s.substring(numStart,s.length()-1)));\\n        return nt; \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046554,
                "title": "go-simple-solution",
                "content": "```\\nfunc deserialize(s string) *NestedInteger {\\n    res := &NestedInteger{}\\n\\n    if s == \"[]\" {\\n        return res\\n    }\\n\\n    if s[0] != \\'[\\' {\\n        val, _ := strconv.Atoi(s)\\n        res.SetInteger(val)\\n        return res\\n    }\\n\\n    for i := 1; i < len(s); i++ {\\n        start := i\\n\\n        if s[i] == \\'[\\' {\\n            count := 0\\n\\n            for ; i < len(s); i++ {\\n                if s[i] == \\'[\\' {\\n                    count++\\n                } else if s[i] == \\']\\' {\\n                    count--\\n                }\\n\\n                if count == 0 {\\n                    break\\n                }\\n            }\\n\\n            i++\\n        } else {\\n            for ; i < len(s) && s[i] != \\',\\' && s[i] != \\']\\'; i++ {}\\n        }\\n\\n        res.Add(*deserialize(s[start:i]))\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc deserialize(s string) *NestedInteger {\\n    res := &NestedInteger{}\\n\\n    if s == \"[]\" {\\n        return res\\n    }\\n\\n    if s[0] != \\'[\\' {\\n        val, _ := strconv.Atoi(s)\\n        res.SetInteger(val)\\n        return res\\n    }\\n\\n    for i := 1; i < len(s); i++ {\\n        start := i\\n\\n        if s[i] == \\'[\\' {\\n            count := 0\\n\\n            for ; i < len(s); i++ {\\n                if s[i] == \\'[\\' {\\n                    count++\\n                } else if s[i] == \\']\\' {\\n                    count--\\n                }\\n\\n                if count == 0 {\\n                    break\\n                }\\n            }\\n\\n            i++\\n        } else {\\n            for ; i < len(s) && s[i] != \\',\\' && s[i] != \\']\\'; i++ {}\\n        }\\n\\n        res.Add(*deserialize(s[start:i]))\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3004403,
                "title": "o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea for this problem is to use a recursive approach to deserialize the string representation of a nested integer. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- If the input string is empty, return an empty nested integer.\\n- If the first character of the input string is not \\'[\\', return a nested integer with the value of the input string converted to an integer.\\n- If the input string has a length of 2 or less, return an empty nested integer.\\n- Initialize a result nested integer and a start index to 1.\\n- Iterate over the input string starting from index 1.\\n- If the current character is a \\',\\' or the last character of the string and the count of open brackets is 0, deserialize the sub-string from the start index to the current index, add it to the result nested integer and update the start index to the current index + 1.\\n- If the current character is a \\'[\\', increment the count of open brackets.\\n- If the current character is a \\']\\', decrement the count of open brackets.\\n- Return the result nested integer.\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe need to perform a single pass through the input string.\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe need to store the intermediate results in the call stack, which takes $O(n)$ space.\\n# Code\\n```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        if not s:\\n            return NestedInteger()\\n        if s[0] != \\'[\\':\\n            return NestedInteger(int(s))\\n        if len(s) <= 2:\\n            return NestedInteger()\\n        start, cnt = 1, 0\\n        res = NestedInteger()\\n        for i in range(1, len(s)):\\n            if cnt == 0 and (s[i] == \\',\\' or i == len(s) - 1):\\n                res.add(self.deserialize(s[start:i]))\\n                start = i + 1\\n            elif s[i] == \\'[\\':\\n                cnt += 1\\n            elif s[i] == \\']\\':\\n                cnt -= 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        if not s:\\n            return NestedInteger()\\n        if s[0] != \\'[\\':\\n            return NestedInteger(int(s))\\n        if len(s) <= 2:\\n            return NestedInteger()\\n        start, cnt = 1, 0\\n        res = NestedInteger()\\n        for i in range(1, len(s)):\\n            if cnt == 0 and (s[i] == \\',\\' or i == len(s) - 1):\\n                res.add(self.deserialize(s[start:i]))\\n                start = i + 1\\n            elif s[i] == \\'[\\':\\n                cnt += 1\\n            elif s[i] == \\']\\':\\n                cnt -= 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981927,
                "title": "c-istringsteam-and-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        s.push_back(\\']\\');\\n        istringstream is(move(s));\\n        vector<NestedInteger> stack(2);\\n        for(char c = is.get(); !is.eof(); c = is.get()) {\\n            if(c != \\',\\') {\\n                if(c == \\']\\') {\\n                    stack[stack.size() - 2].add(move(stack.back()));\\n                    stack.pop_back();\\n                }\\n                else if(c == \\'[\\')\\n                    stack.push_back({});\\n                else {\\n                    is.putback(c);\\n                    int n;  is >> n;\\n                    stack.back().add(NestedInteger(n));\\n                } \\n            }\\n        }\\n        return stack.back().getList().front().getList().front();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n        s.push_back(\\']\\');\\n        istringstream is(move(s));\\n        vector<NestedInteger> stack(2);\\n        for(char c = is.get(); !is.eof(); c = is.get()) {\\n            if(c != \\',\\') {\\n                if(c == \\']\\') {\\n                    stack[stack.size() - 2].add(move(stack.back()));\\n                    stack.pop_back();\\n                }\\n                else if(c == \\'[\\')\\n                    stack.push_back({});\\n                else {\\n                    is.putback(c);\\n                    int n;  is >> n;\\n                    stack.back().add(NestedInteger(n));\\n                } \\n            }\\n        }\\n        return stack.back().getList().front().getList().front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951130,
                "title": "385-mini-parser",
                "content": "# Code\\n```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n       if(s.contains(\",\")||s.contains(\"[\")){\\n            return split(s);\\n        }else{\\n            return new NestedInteger(Integer.parseInt(s));\\n        }\\n    }\\n    private NestedInteger split(String s){\\n        if(s.startsWith(\"[\")){\\n            s = s.substring(1,s.length()-1);\\n        }\\n        int level = 0; \\n        NestedInteger nested = new NestedInteger();\\n        int start = 0;\\n        int end = 0;\\n        while(end<s.length()){\\n            if(s.charAt(end)==\\',\\'&&level==0){\\n                if(end-start>0)nested.add(deserialize(s.substring(start,end)));\\n                start = end+1;\\n            }else if(s.charAt(end)==\\'[\\'){\\n                level++;\\n            }else if(s.charAt(end)==\\']\\'){\\n                level--;\\n                if(level==0){\\n                    nested.add(deserialize(s.substring(start,end+1)));\\n                    start = end+1;\\n                }\\n            }\\n            end++;\\n        }\\n        if(end-start>0)nested.add(deserialize(s.substring(start,end)));\\n        return nested;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n       if(s.contains(\",\")||s.contains(\"[\")){\\n            return split(s);\\n        }else{\\n            return new NestedInteger(Integer.parseInt(s));\\n        }\\n    }\\n    private NestedInteger split(String s){\\n        if(s.startsWith(\"[\")){\\n            s = s.substring(1,s.length()-1);\\n        }\\n        int level = 0; \\n        NestedInteger nested = new NestedInteger();\\n        int start = 0;\\n        int end = 0;\\n        while(end<s.length()){\\n            if(s.charAt(end)==\\',\\'&&level==0){\\n                if(end-start>0)nested.add(deserialize(s.substring(start,end)));\\n                start = end+1;\\n            }else if(s.charAt(end)==\\'[\\'){\\n                level++;\\n            }else if(s.charAt(end)==\\']\\'){\\n                level--;\\n                if(level==0){\\n                    nested.add(deserialize(s.substring(start,end+1)));\\n                    start = end+1;\\n                }\\n            }\\n            end++;\\n        }\\n        if(end-start>0)nested.add(deserialize(s.substring(start,end)));\\n        return nested;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943775,
                "title": "c-simple-straight-forward-with-stack",
                "content": "# Intuition\\nSimple straight forward with stack.\\n\\n# Approach\\nScan the string, add a node to stack if we see \\'[\\', pop the node if the see \\']\\', set the node value or add list accordingly.\\n\\n# Complexity\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n \\n        int pos = 0;\\n        int next = 0;\\n\\n        std::stack<NestedInteger*> pending;\\n        NestedInteger* temp = nullptr;\\n        do {\\n            next = s.find_first_of(\"[],\", pos);\\n            if (next == s.npos) {\\n                next = s.length();\\n            }\\n            string sub = s.substr(pos, next - pos);\\n            if (sub.length() != 0) {\\n                int val = 0;\\n                if (sub[0] == \\'-\\') {\\n                    val = -atoi(sub.c_str() + 1);\\n                }\\n                else {\\n                    val = atoi(sub.c_str());\\n                }\\n                temp = new NestedInteger(val);\\n            }\\n\\n            if (next < s.length()) {\\n                if (s[next] == \\'[\\') {\\n                    pending.push(new NestedInteger);\\n                }\\n                else if (s[next] == \\']\\') {\\n                    if (temp != nullptr) {\\n                        pending.top()->add(*temp);\\n                    }\\n                    temp = pending.top();\\n                    pending.pop();\\n                }\\n                else {\\n                    if (!pending.empty() && temp != nullptr) {\\n                        pending.top()->add(*temp);\\n                        temp = nullptr;\\n                    }\\n                }\\n            }\\n            pos = next + 1;\\n        } while (pos < s.length());\\n        return *temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n \\n        int pos = 0;\\n        int next = 0;\\n\\n        std::stack<NestedInteger*> pending;\\n        NestedInteger* temp = nullptr;\\n        do {\\n            next = s.find_first_of(\"[],\", pos);\\n            if (next == s.npos) {\\n                next = s.length();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2878806,
                "title": "python-solution-with-index-memoization",
                "content": "## What\\'s special:\\n\\n- Manipulate index is cheaper (regarding time&space complexity) than substring\\n- Recur between `[]` but creating a `ci` (closing index) to quickly find where the `[]` ends and jump to that index \\n\\n## Code\\n\\n```python\\nclass Solution:\\n    s: str\\n    ci: dict[int, int]  # V is ind of close parenthesis of opening parenthesis K\\n\\n    def deserialize(self, s: str) -> NestedInteger:\\n        # prepare ci\\n        self.s = s\\n        self.ci = ci = {}  # closing indices of keys\\n        ps: list[int] = []  # stack of parentheses\\' pos\\n        for i, ch in enumerate(s):\\n            if ch == \"[\":\\n                ps.append(i)\\n            elif ch == \"]\":\\n                oi = ps.pop()  # opening index\\n                ci[oi] = i\\n\\n        # work\\n        return self.recur(0, len(s) - 1).getList()[0]\\n\\n    def recur(self, start, end) -> NestedInteger:\\n        # both start and end are inclusive\\n        ni = NestedInteger()\\n        s = self.s\\n        if start + 1 == end and s[start] == \"[\" and s[end] == \"]\":\\n            ni.add(NestedInteger())\\n            return ni\\n        i = start\\n        ns = i  # number start\\n        while i <= end:\\n            if s[i] == \"[\":\\n                ni.add(self.recur(i + 1, self.ci[i] - 1))\\n                ns = i = self.ci[i] + 1\\n            elif s[i] == \",\":\\n                if i != ns:\\n                    ni.add(NestedInteger(int(s[ns:i])))\\n                ns = i = i + 1\\n            else:\\n                i += 1\\n        if ns <= end:\\n            ni.add(NestedInteger(int(s[ns : end + 1])))\\n        return ni\\n```\\n\\n\\n## TL;DR\\n\\nPlease upvote if you like to see more solutions like this.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    s: str\\n    ci: dict[int, int]  # V is ind of close parenthesis of opening parenthesis K\\n\\n    def deserialize(self, s: str) -> NestedInteger:\\n        # prepare ci\\n        self.s = s\\n        self.ci = ci = {}  # closing indices of keys\\n        ps: list[int] = []  # stack of parentheses\\' pos\\n        for i, ch in enumerate(s):\\n            if ch == \"[\":\\n                ps.append(i)\\n            elif ch == \"]\":\\n                oi = ps.pop()  # opening index\\n                ci[oi] = i\\n\\n        # work\\n        return self.recur(0, len(s) - 1).getList()[0]\\n\\n    def recur(self, start, end) -> NestedInteger:\\n        # both start and end are inclusive\\n        ni = NestedInteger()\\n        s = self.s\\n        if start + 1 == end and s[start] == \"[\" and s[end] == \"]\":\\n            ni.add(NestedInteger())\\n            return ni\\n        i = start\\n        ns = i  # number start\\n        while i <= end:\\n            if s[i] == \"[\":\\n                ni.add(self.recur(i + 1, self.ci[i] - 1))\\n                ns = i = self.ci[i] + 1\\n            elif s[i] == \",\":\\n                if i != ns:\\n                    ni.add(NestedInteger(int(s[ns:i])))\\n                ns = i = i + 1\\n            else:\\n                i += 1\\n        if ns <= end:\\n            ni.add(NestedInteger(int(s[ns : end + 1])))\\n        return ni\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846624,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\n#[derive(Clone, Debug, PartialEq, Eq)]\\npub enum NestedInteger {\\n    Int(i32),\\n    List(Vec<NestedInteger>),\\n}\\n\\nimpl NestedInteger {\\n    fn new() -> Self {\\n        NestedInteger::List(Vec::new())\\n    }\\n\\n    fn new_int(value: i32) -> Self {\\n        NestedInteger::Int(value)\\n    }\\n\\n    fn is_integer(&self) -> bool {\\n        match self {\\n            NestedInteger::Int(_) => true,\\n            _ => false,\\n        }\\n    }\\n\\n    fn get_integer(&self) -> i32 {\\n        match self {\\n            NestedInteger::Int(i) => *i,\\n            _ => panic!(\"Not an integer\"),\\n        }\\n    }\\n\\n    fn set_integer(&mut self, value: i32) {\\n        *self = NestedInteger::Int(value);\\n    }\\n\\n    fn add(&mut self, ni: NestedInteger) {\\n        match self {\\n            NestedInteger::List(list) => list.push(ni),\\n            _ => panic!(\"Not a list\"),\\n        }\\n    }\\n\\n    fn get_list(&self) -> &Vec<NestedInteger> {\\n        match self {\\n            NestedInteger::List(list) => list,\\n            _ => panic!(\"Not a list\"),\\n        }\\n    }\\n\\n    fn serialize(&self) -> String {\\n        self.to_string()\\n    }\\n}\\n\\nimpl std::str::FromStr for NestedInteger {\\n    type Err = std::num::ParseIntError;\\n\\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\\n        if s.starts_with(\\'[\\') {\\n            let mut list = Vec::new();\\n            let mut i = 1;\\n            while i < s.len() - 1 {\\n                let mut j = i;\\n                let mut depth = 0;\\n                while j < s.len() - 1 && (depth > 0 || &s[j..j + 1] != \",\") {\\n                    if &s[j..j + 1] == \"[\" {\\n                        depth += 1;\\n                    } else if &s[j..j + 1] == \"]\" {\\n                        depth -= 1;\\n                    }\\n                    j += 1;\\n                }\\n                list.push(NestedInteger::from_str(&s[i..j])?);\\n                i = j + 1;\\n            }\\n            Ok(NestedInteger::List(list))\\n        } else {\\n            Ok(NestedInteger::Int(s.parse()?))\\n        }\\n    }\\n}\\n\\nimpl std::fmt::Display for NestedInteger {\\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\\n        match self {\\n            NestedInteger::Int(i) => write!(f, \"{}\", i),\\n            NestedInteger::List(list) => {\\n                write!(f, \"[\")?;\\n                for (i, ni) in list.iter().enumerate() {\\n                    if i > 0 {\\n                        write!(f, \",\")?;\\n                    }\\n                    write!(f, \"{}\", ni)?;\\n                }\\n                write!(f, \"]\")\\n            }\\n        }\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn deserialize(s: String) -> NestedInteger {\\n        s.parse().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n#[derive(Clone, Debug, PartialEq, Eq)]\\npub enum NestedInteger {\\n    Int(i32),\\n    List(Vec<NestedInteger>),\\n}\\n\\nimpl NestedInteger {\\n    fn new() -> Self {\\n        NestedInteger::List(Vec::new())\\n    }\\n\\n    fn new_int(value: i32) -> Self {\\n        NestedInteger::Int(value)\\n    }\\n\\n    fn is_integer(&self) -> bool {\\n        match self {\\n            NestedInteger::Int(_) => true,\\n            _ => false,\\n        }\\n    }\\n\\n    fn get_integer(&self) -> i32 {\\n        match self {\\n            NestedInteger::Int(i) => *i,\\n            _ => panic!(\"Not an integer\"),\\n        }\\n    }\\n\\n    fn set_integer(&mut self, value: i32) {\\n        *self = NestedInteger::Int(value);\\n    }\\n\\n    fn add(&mut self, ni: NestedInteger) {\\n        match self {\\n            NestedInteger::List(list) => list.push(ni),\\n            _ => panic!(\"Not a list\"),\\n        }\\n    }\\n\\n    fn get_list(&self) -> &Vec<NestedInteger> {\\n        match self {\\n            NestedInteger::List(list) => list,\\n            _ => panic!(\"Not a list\"),\\n        }\\n    }\\n\\n    fn serialize(&self) -> String {\\n        self.to_string()\\n    }\\n}\\n\\nimpl std::str::FromStr for NestedInteger {\\n    type Err = std::num::ParseIntError;\\n\\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\\n        if s.starts_with(\\'[\\') {\\n            let mut list = Vec::new();\\n            let mut i = 1;\\n            while i < s.len() - 1 {\\n                let mut j = i;\\n                let mut depth = 0;\\n                while j < s.len() - 1 && (depth > 0 || &s[j..j + 1] != \",\") {\\n                    if &s[j..j + 1] == \"[\" {\\n                        depth += 1;\\n                    } else if &s[j..j + 1] == \"]\" {\\n                        depth -= 1;\\n                    }\\n                    j += 1;\\n                }\\n                list.push(NestedInteger::from_str(&s[i..j])?);\\n                i = j + 1;\\n            }\\n            Ok(NestedInteger::List(list))\\n        } else {\\n            Ok(NestedInteger::Int(s.parse()?))\\n        }\\n    }\\n}\\n\\nimpl std::fmt::Display for NestedInteger {\\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\\n        match self {\\n            NestedInteger::Int(i) => write!(f, \"{}\", i),\\n            NestedInteger::List(list) => {\\n                write!(f, \"[\")?;\\n                for (i, ni) in list.iter().enumerate() {\\n                    if i > 0 {\\n                        write!(f, \",\")?;\\n                    }\\n                    write!(f, \"{}\", ni)?;\\n                }\\n                write!(f, \"]\")\\n            }\\n        }\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn deserialize(s: String) -> NestedInteger {\\n        s.parse().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2786629,
                "title": "java-solution-stack",
                "content": "```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        // \\u6808 + \\u5BF9\\u8C61\\n        Deque<NestedInteger> stack = new LinkedList<>();\\n        NestedInteger tmpNi = new NestedInteger();\\n        Integer tmpInt = null;\\n        int sign = 1;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'-\\') {\\n                sign = -1;\\n            }\\n            if (c == \\'[\\') {\\n                stack.push(tmpNi);\\n                tmpNi = new NestedInteger();\\n            }\\n            if (c == \\',\\') {\\n                if (tmpInt != null) tmpNi.add(new NestedInteger(tmpInt * sign));\\n                tmpInt = null;\\n                sign = 1;\\n            }\\n            if (c == \\']\\') {\\n                if (tmpInt != null) {\\n                    tmpNi.add(new NestedInteger(tmpInt * sign));\\n                    tmpInt = null;\\n                    sign = 1;\\n                }\\n                stack.peek().add(tmpNi);\\n                tmpNi = stack.pop();\\n            }\\n            if (Character.isDigit(c)) {\\n                if (tmpInt == null) tmpInt = c - \\'0\\';\\n                else tmpInt = tmpInt * 10 + (c - \\'0\\');\\n            }\\n        }\\n        if (tmpInt != null) return new NestedInteger(tmpInt * sign);\\n        \\n        return tmpNi.getList().get(0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        // \\u6808 + \\u5BF9\\u8C61\\n        Deque<NestedInteger> stack = new LinkedList<>();\\n        NestedInteger tmpNi = new NestedInteger();\\n        Integer tmpInt = null;\\n        int sign = 1;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'-\\') {\\n                sign = -1;\\n            }\\n            if (c == \\'[\\') {\\n                stack.push(tmpNi);\\n                tmpNi = new NestedInteger();\\n            }\\n            if (c == \\',\\') {\\n                if (tmpInt != null) tmpNi.add(new NestedInteger(tmpInt * sign));\\n                tmpInt = null;\\n                sign = 1;\\n            }\\n            if (c == \\']\\') {\\n                if (tmpInt != null) {\\n                    tmpNi.add(new NestedInteger(tmpInt * sign));\\n                    tmpInt = null;\\n                    sign = 1;\\n                }\\n                stack.peek().add(tmpNi);\\n                tmpNi = stack.pop();\\n            }\\n            if (Character.isDigit(c)) {\\n                if (tmpInt == null) tmpInt = c - \\'0\\';\\n                else tmpInt = tmpInt * 10 + (c - \\'0\\');\\n            }\\n        }\\n        if (tmpInt != null) return new NestedInteger(tmpInt * sign);\\n        \\n        return tmpNi.getList().get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733465,
                "title": "python-stack-solution",
                "content": "```\\ndef deserialize(self, s: str) -> NestedInteger:\\n\\tstack, num, ans = [], \"\", None\\n\\tfor c in s:\\n\\t\\tif c in \\'-0123456789\\': \\n\\t\\t\\tnum += c\\n\\t\\telif c == \"[\":\\n\\t\\t\\telem = NestedInteger()\\n\\t\\t\\tif stack: \\n\\t\\t\\t\\tstack[-1].add(elem)\\n\\t\\t\\tstack.append(elem)\\n\\t\\telif c in \",]\":\\n\\t\\t\\tif num:\\n\\t\\t\\t\\tstack[-1].add(NestedInteger(int(num)))\\n\\t\\t\\t\\tnum = \"\"\\n\\t\\t\\tif c==\\']\\':\\n\\t\\t\\t\\tans = stack.pop()\\n\\treturn ans if ans else NestedInteger(int(num))\\n```",
                "solutionTags": [],
                "code": "```\\ndef deserialize(self, s: str) -> NestedInteger:\\n\\tstack, num, ans = [], \"\", None\\n\\tfor c in s:\\n\\t\\tif c in \\'-0123456789\\': \\n\\t\\t\\tnum += c\\n\\t\\telif c == \"[\":\\n\\t\\t\\telem = NestedInteger()\\n\\t\\t\\tif stack: \\n\\t\\t\\t\\tstack[-1].add(elem)\\n\\t\\t\\tstack.append(elem)\\n\\t\\telif c in \",]\":\\n\\t\\t\\tif num:\\n\\t\\t\\t\\tstack[-1].add(NestedInteger(int(num)))\\n\\t\\t\\t\\tnum = \"\"\\n\\t\\t\\tif c==\\']\\':\\n\\t\\t\\t\\tans = stack.pop()\\n\\treturn ans if ans else NestedInteger(int(num))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2693658,
                "title": "java-iterative-with-stack",
                "content": "```java\\nclass Solution {\\n    private int mPosition = 0;\\n    private String mInput;\\n    \\n    private enum Kind {\\n        OPEN_BRACKET, CLOSE_BRACKET, COMMA, NUMBER, EOF\\n    }\\n    \\n    private static class Token {\\n        public Kind mKind;\\n        public int mValue;\\n        \\n        Token(Kind kind, int value) {\\n            mKind = kind;\\n            mValue = value;\\n        }\\n    }\\n    \\n    private Token next() {\\n        if (mPosition >= mInput.length()) {\\n            return new Token(Kind.EOF, 0);\\n        }\\n        \\n        int start = mPosition;\\n        \\n        while (mPosition < mInput.length() && (Character.isDigit(mInput.charAt(mPosition)) || mInput.charAt(mPosition) == \\'-\\')) {\\n            ++mPosition;\\n        }\\n        \\n        if (Character.isDigit(mInput.charAt(start)) || mInput.charAt(start) == \\'-\\') {\\n            int value = Integer.parseInt(mInput.substring(start, mPosition));\\n            return new Token(Kind.NUMBER, value);\\n        } else if (mInput.charAt(start) == \\'[\\') {\\n            ++mPosition;\\n            return new Token(Kind.OPEN_BRACKET, 0);\\n        } else if (mInput.charAt(start) == \\']\\') {\\n            ++mPosition;\\n            return new Token(Kind.CLOSE_BRACKET, 0);\\n        } else {\\n            ++mPosition;\\n            return new Token(Kind.COMMA, 0);\\n        }\\n    }\\n    \\n    public NestedInteger deserialize(String s) {\\n        mPosition = 0;\\n        mInput = s;\\n        \\n        Token curToken = next();\\n        NestedInteger current = null;\\n        Deque<NestedInteger> stack = new ArrayDeque<NestedInteger>();\\n        \\n        while (curToken.mKind != Kind.EOF) {\\n            switch (curToken.mKind) {\\n                case COMMA:\\n                    break;\\n                case OPEN_BRACKET:\\n                    stack.push(new NestedInteger());\\n                    if (current == null) {\\n                        current = stack.peek();\\n                    } else {\\n                        current.add(stack.peek());\\n                        current = stack.peek();\\n                    }\\n                    break;\\n                case CLOSE_BRACKET:\\n                    stack.pop();\\n                    if (!stack.isEmpty()) {\\n                        current = stack.peek();\\n                    }\\n                    break;\\n                case NUMBER:\\n                    NestedInteger integer = new NestedInteger(curToken.mValue);\\n                    if (current == null) {\\n                        current = integer;\\n                    } else {\\n                        current.add(integer);\\n                    }\\n                    break;\\n                default:\\n                    break;\\n            }\\n            \\n            curToken = next();\\n        }\\n        \\n        return current;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```java\\nclass Solution {\\n    private int mPosition = 0;\\n    private String mInput;\\n    \\n    private enum Kind {\\n        OPEN_BRACKET, CLOSE_BRACKET, COMMA, NUMBER, EOF\\n    }\\n    \\n    private static class Token {\\n        public Kind mKind;\\n        public int mValue;\\n        \\n        Token(Kind kind, int value) {\\n            mKind = kind;\\n            mValue = value;\\n        }\\n    }\\n    \\n    private Token next() {\\n        if (mPosition >= mInput.length()) {\\n            return new Token(Kind.EOF, 0);\\n        }\\n        \\n        int start = mPosition;\\n        \\n        while (mPosition < mInput.length() && (Character.isDigit(mInput.charAt(mPosition)) || mInput.charAt(mPosition) == \\'-\\')) {\\n            ++mPosition;\\n        }\\n        \\n        if (Character.isDigit(mInput.charAt(start)) || mInput.charAt(start) == \\'-\\') {\\n            int value = Integer.parseInt(mInput.substring(start, mPosition));\\n            return new Token(Kind.NUMBER, value);\\n        } else if (mInput.charAt(start) == \\'[\\') {\\n            ++mPosition;\\n            return new Token(Kind.OPEN_BRACKET, 0);\\n        } else if (mInput.charAt(start) == \\']\\') {\\n            ++mPosition;\\n            return new Token(Kind.CLOSE_BRACKET, 0);\\n        } else {\\n            ++mPosition;\\n            return new Token(Kind.COMMA, 0);\\n        }\\n    }\\n    \\n    public NestedInteger deserialize(String s) {\\n        mPosition = 0;\\n        mInput = s;\\n        \\n        Token curToken = next();\\n        NestedInteger current = null;\\n        Deque<NestedInteger> stack = new ArrayDeque<NestedInteger>();\\n        \\n        while (curToken.mKind != Kind.EOF) {\\n            switch (curToken.mKind) {\\n                case COMMA:\\n                    break;\\n                case OPEN_BRACKET:\\n                    stack.push(new NestedInteger());\\n                    if (current == null) {\\n                        current = stack.peek();\\n                    } else {\\n                        current.add(stack.peek());\\n                        current = stack.peek();\\n                    }\\n                    break;\\n                case CLOSE_BRACKET:\\n                    stack.pop();\\n                    if (!stack.isEmpty()) {\\n                        current = stack.peek();\\n                    }\\n                    break;\\n                case NUMBER:\\n                    NestedInteger integer = new NestedInteger(curToken.mValue);\\n                    if (current == null) {\\n                        current = integer;\\n                    } else {\\n                        current.add(integer);\\n                    }\\n                    break;\\n                default:\\n                    break;\\n            }\\n            \\n            curToken = next();\\n        }\\n        \\n        return current;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677096,
                "title": "cpp",
                "content": "```cpp\\ntypedef long long ll;\\n\\n#define clamp(n, lo, hi) ((n >= hi) ? hi : ((n <= lo) ? lo : n))\\n#define is_sign(ch) ((ch == \\'+\\') ? true : ((ch == \\'-\\') ? true : false))\\n#define isDigit(ch) (ch >= \\'0\\' && ch <= \\'9\\')\\n#define unordered_map um\\n\\ntemplate <typename T>\\nusing v = vector<T>;\\n\\ntemplate <typename T>\\nusing matrix = vector<vector<T>>;\\n\\nclass Solution {\\npublic:\\n    NestedInteger parsePrimary(string &s, int &currIdx) {\\n        if (isDigit(s[currIdx]) || is_sign(s[currIdx])) {\\n            int n = 0, sign = 1;\\n            \\n            if (s[currIdx] == \\'-\\') {\\n                sign = -1;\\n                ++currIdx;\\n            }\\n            \\n            while (currIdx < s.size() && isDigit(s[currIdx])) {\\n                n = (n * 10) + (s[currIdx] - \\'0\\');\\n                ++currIdx;\\n            }\\n            return NestedInteger(sign * n);\\n        } else if (s[currIdx] == \\'[\\') {\\n            NestedInteger l;\\n            currIdx += 1;\\n            \\n            while (currIdx < s.size() && s[currIdx] != \\']\\') {\\n                l.add(parsePrimary(s, currIdx));\\n                if (s[currIdx] == \\']\\') break;\\n                ++currIdx;\\n            }\\n            \\n            ++currIdx;\\n            return l;\\n        } else {\\n            assert(false && \"unreachable\");\\n        }\\n    }\\n    \\n    NestedInteger deserialize(string s) {\\n        int currIdx = 0;\\n        return parsePrimary(s, currIdx);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\ntypedef long long ll;\\n\\n#define clamp(n, lo, hi) ((n >= hi) ? hi : ((n <= lo) ? lo : n))\\n#define is_sign(ch) ((ch == \\'+\\') ? true : ((ch == \\'-\\') ? true : false))\\n#define isDigit(ch) (ch >= \\'0\\' && ch <= \\'9\\')\\n#define unordered_map um\\n\\ntemplate <typename T>\\nusing v = vector<T>;\\n\\ntemplate <typename T>\\nusing matrix = vector<vector<T>>;\\n\\nclass Solution {\\npublic:\\n    NestedInteger parsePrimary(string &s, int &currIdx) {\\n        if (isDigit(s[currIdx]) || is_sign(s[currIdx])) {\\n            int n = 0, sign = 1;\\n            \\n            if (s[currIdx] == \\'-\\') {\\n                sign = -1;\\n                ++currIdx;\\n            }\\n            \\n            while (currIdx < s.size() && isDigit(s[currIdx])) {\\n                n = (n * 10) + (s[currIdx] - \\'0\\');\\n                ++currIdx;\\n            }\\n            return NestedInteger(sign * n);\\n        } else if (s[currIdx] == \\'[\\') {\\n            NestedInteger l;\\n            currIdx += 1;\\n            \\n            while (currIdx < s.size() && s[currIdx] != \\']\\') {\\n                l.add(parsePrimary(s, currIdx));\\n                if (s[currIdx] == \\']\\') break;\\n                ++currIdx;\\n            }\\n            \\n            ++currIdx;\\n            return l;\\n        } else {\\n            assert(false && \"unreachable\");\\n        }\\n    }\\n    \\n    NestedInteger deserialize(string s) {\\n        int currIdx = 0;\\n        return parsePrimary(s, currIdx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538831,
                "title": "simple-java-code",
                "content": "**class Solution {\\n    public NestedInteger deserialize(String s) {\\n        Stack<NestedInteger>stack=new Stack<>();\\n        stack.add(new NestedInteger());\\n        boolean parse=false;\\n        boolean minus=false;\\n        int currInt=0;\\n        int i=0;\\n        for(char c:s.toCharArray())\\n        {\\n            if(c==\\'[\\')\\n            {\\n               if(i==0&&stack.size()!=0) {i=1; continue;}\\n                stack.push(new NestedInteger());\\n            }\\n            else if(c>=\\'0\\'&&c<=\\'9\\')\\n            {\\n                parse=true;\\n                currInt=10*currInt+(c-\\'0\\');\\n            }\\n            else if(c==\\',\\')\\n            {\\n                if(parse)\\n                {\\n                    parse=false;\\n                    if(minus) currInt=-1*currInt;\\n                    minus=false;\\n                    stack.peek().add(new NestedInteger(currInt));\\n                    currInt=0;\\n                }\\n            }\\n            else if(c==\\']\\')\\n            {\\n                if(parse)\\n                {\\n                    parse=false;\\n                    if(minus) currInt=-1*currInt;\\n                    minus=false;\\n                    stack.peek().add(new NestedInteger(currInt));\\n                    currInt=0;\\n                }\\n                if(stack.size()==1) return stack.peek();\\n                NestedInteger r=stack.pop();\\n                stack.peek().add(r);\\n                \\n            }\\n            else if(c==\\'-\\') minus=true;\\n        }\\n        if(parse)\\n        {\\n            if(minus) currInt=-1*currInt;\\n            minus=false;\\n            stack.peek().setInteger(currInt);\\n        }\\n        return stack.peek();\\n    }\\n}**",
                "solutionTags": [],
                "code": "class Solution {\\n    public NestedInteger deserialize(String s) {\\n        Stack<NestedInteger>stack=new Stack<>();\\n        stack.add(new NestedInteger());\\n        boolean parse=false;\\n        boolean minus=false;\\n        int currInt=0;\\n        int i=0;\\n        for(char c:s.toCharArray())\\n        {\\n            if(c==\\'[\\')\\n            {\\n               if(i==0&&stack.size()!=0) {i=1; continue;}",
                "codeTag": "Java"
            },
            {
                "id": 2516084,
                "title": "python-simple-maths",
                "content": "\\n    def deserialize(self, s):\\n        if s[0] != \"[\":\\n            return NestedInteger(int(s))\\n        \\n        ans, res = NestedInteger(), [] if s == \"[]\" else s[1:-1].split(\",\")\\n        \\n        count, low = 0, 0\\n        \\n        for high, ss in enumerate(res):\\n            count += ss.count(\"[\") - ss.count(\"]\")\\n            \\n            if count == 0:\\n                ans.add(self.deserialize(\",\".join(res[low:high+1])))\\n                low = high + 1\\n        \\n        return ans",
                "solutionTags": [],
                "code": "\\n    def deserialize(self, s):\\n        if s[0] != \"[\":\\n            return NestedInteger(int(s))\\n        \\n        ans, res = NestedInteger(), [] if s == \"[]\" else s[1:-1].split(\",\")\\n        \\n        count, low = 0, 0\\n        \\n        for high, ss in enumerate(res):\\n            count += ss.count(\"[\") - ss.count(\"]\")\\n            \\n            if count == 0:\\n                ans.add(self.deserialize(\",\".join(res[low:high+1])))\\n                low = high + 1\\n        \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2491140,
                "title": "java-simple-intuitive-solution",
                "content": "```\\npublic NestedInteger deserialize(String s) {\\n\\tMap<Integer, List<NestedInteger>> map = new HashMap<>();\\n\\tint depth = 0;\\n\\tint index = 0;\\n\\tint n = s.length();\\n\\twhile (index < n) {\\n\\t\\tchar ch = s.charAt(index);\\n\\t\\tif (ch == \\'[\\') {\\n\\t\\t\\tdepth++;\\n\\t\\t\\tindex++;\\n\\t\\t} else if (Character.isDigit(ch) || ch == \\'-\\') {\\n\\t\\t\\tint startIndex = index;\\n\\t\\t\\twhile (index < n && (Character.isDigit(s.charAt(index)) || s.charAt(index) == \\'-\\')) {\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t}\\n\\t\\t\\tNestedInteger newInt = new NestedInteger(Integer.parseInt(s.substring(startIndex, index)));\\n\\t\\t\\tmap.putIfAbsent(depth, new ArrayList<>());\\n\\t\\t\\tmap.get(depth).add(newInt);\\n\\t\\t} else if (ch == \\',\\') {\\n\\t\\t\\tindex++;\\n\\t\\t} else if (ch == \\']\\') {\\n\\t\\t\\tNestedInteger newInt = new NestedInteger();\\n\\t\\t\\tList<NestedInteger> list = map.get(depth);\\n\\t\\t\\tif (list != null) {\\n\\t\\t\\t\\tfor (NestedInteger curInt: list) {\\n\\t\\t\\t\\t\\tnewInt.add(curInt);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmap.remove(depth);\\n\\t\\t\\tdepth--;\\n\\t\\t\\tmap.putIfAbsent(depth, new ArrayList<>());\\n\\t\\t\\tmap.get(depth).add(newInt);\\n\\t\\t\\tindex++;\\n\\t\\t}\\t\\n\\t}\\n\\treturn map.get(0).get(0);\\n}\\n// time: O (n)\\n// space: O (n)\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic NestedInteger deserialize(String s) {\\n\\tMap<Integer, List<NestedInteger>> map = new HashMap<>();\\n\\tint depth = 0;\\n\\tint index = 0;\\n\\tint n = s.length();\\n\\twhile (index < n) {\\n\\t\\tchar ch = s.charAt(index);\\n\\t\\tif (ch == \\'[\\') {\\n\\t\\t\\tdepth++;\\n\\t\\t\\tindex++;\\n\\t\\t} else if (Character.isDigit(ch) || ch == \\'-\\') {\\n\\t\\t\\tint startIndex = index;\\n\\t\\t\\twhile (index < n && (Character.isDigit(s.charAt(index)) || s.charAt(index) == \\'-\\')) {\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t}\\n\\t\\t\\tNestedInteger newInt = new NestedInteger(Integer.parseInt(s.substring(startIndex, index)));\\n\\t\\t\\tmap.putIfAbsent(depth, new ArrayList<>());\\n\\t\\t\\tmap.get(depth).add(newInt);\\n\\t\\t} else if (ch == \\',\\') {\\n\\t\\t\\tindex++;\\n\\t\\t} else if (ch == \\']\\') {\\n\\t\\t\\tNestedInteger newInt = new NestedInteger();\\n\\t\\t\\tList<NestedInteger> list = map.get(depth);\\n\\t\\t\\tif (list != null) {\\n\\t\\t\\t\\tfor (NestedInteger curInt: list) {\\n\\t\\t\\t\\t\\tnewInt.add(curInt);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmap.remove(depth);\\n\\t\\t\\tdepth--;\\n\\t\\t\\tmap.putIfAbsent(depth, new ArrayList<>());\\n\\t\\t\\tmap.get(depth).add(newInt);\\n\\t\\t\\tindex++;\\n\\t\\t}\\t\\n\\t}\\n\\treturn map.get(0).get(0);\\n}\\n// time: O (n)\\n// space: O (n)\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2424460,
                "title": "python-beats-90-with-recursion",
                "content": "```\\ndef getNumber(s: List[str], idx) -> (Optional[int], int):\\n    n = None \\n    negative = False\\n    while idx < len(s):\\n        try:\\n            if s[idx] == \\'-\\':\\n                negative = True \\n                idx += 1\\n                continue\\n            actual_n = int(s[idx])\\n            n = (n or 0) + actual_n\\n            n *= 10\\n            idx += 1\\n        except:\\n            break\\n    result_n = (n // 10 if n else n)\\n    if result_n and negative:\\n        result_n *= -1\\n    return result_n, idx\\n\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        return self.recurse(list(s), 0)[0]\\n        \\n    def recurse(self, s: List[str], idx: int) -> (Optional[NestedInteger], int):\\n        \\n        while idx < len(s):\\n            if s[idx] == \\',\\':\\n                idx += 1\\n                continue\\n                \\n            actual_n, idx = getNumber(s, idx)\\n            if actual_n is not None:\\n                return NestedInteger(actual_n), idx\\n            elif s[idx] == \\'[\\':\\n                idx += 1\\n                nested_integer = NestedInteger()\\n                while s:\\n                    nested_value, idx = self.recurse(s, idx)\\n                    if not nested_value:\\n                        return nested_integer, idx\\n                    nested_integer.add(nested_value)\\n            elif s[idx] == \\']\\':\\n                return None, idx + 1\\n                \\n        return None, idx",
                "solutionTags": [],
                "code": "```\\ndef getNumber(s: List[str], idx) -> (Optional[int], int):\\n    n = None \\n    negative = False\\n    while idx < len(s):\\n        try:\\n            if s[idx] == \\'-\\':\\n                negative = True \\n                idx += 1\\n                continue\\n            actual_n = int(s[idx])\\n            n = (n or 0) + actual_n\\n            n *= 10\\n            idx += 1\\n        except:\\n            break\\n    result_n = (n // 10 if n else n)\\n    if result_n and negative:\\n        result_n *= -1\\n    return result_n, idx\\n\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        return self.recurse(list(s), 0)[0]\\n        \\n    def recurse(self, s: List[str], idx: int) -> (Optional[NestedInteger], int):\\n        \\n        while idx < len(s):\\n            if s[idx] == \\',\\':\\n                idx += 1\\n                continue\\n                \\n            actual_n, idx = getNumber(s, idx)\\n            if actual_n is not None:\\n                return NestedInteger(actual_n), idx\\n            elif s[idx] == \\'[\\':\\n                idx += 1\\n                nested_integer = NestedInteger()\\n                while s:\\n                    nested_value, idx = self.recurse(s, idx)\\n                    if not nested_value:\\n                        return nested_integer, idx\\n                    nested_integer.add(nested_value)\\n            elif s[idx] == \\']\\':\\n                return None, idx + 1\\n                \\n        return None, idx",
                "codeTag": "Java"
            },
            {
                "id": 2382546,
                "title": "c-clean-code-using-stack",
                "content": "class Solution {\\npublic:\\n\\n    NestedInteger deserialize(string s) {\\n        if(s[0] != \\'[\\') return NestedInteger(stoi(s)); // if string contains single number ex: \"123\".\\n        \\n        vector<NestedInteger> v; // using vector to simulate stack\\n        string num = \"\"; // num will store the number, number can be negative or positive.\\n        \\n        for(auto c: s){\\n            if(c == \\'[\\'){\\n                v.push_back(NestedInteger());\\n            }\\n            else if(c == \\']\\' or c == \\',\\'){\\n                if(num != \"\"){\\n                    v.back().add(NestedInteger(stoi(num)));\\n                    num = \"\";\\n                }\\n                \\n                if(c == \\']\\' and v.size() >= 2){\\n                    NestedInteger ni = v.back();\\n                    v.pop_back();\\n                    v.back().add(ni);\\n                }\\n            }\\n            else num.push_back(c); // if c is a digit just add to num.\\n        }\\n        \\n        return v.back();\\n    }\\n};\\n\\n**Time: O(N), Space: O(N).**\\n**PLEASE UPVOTE IF HELPFUL!!!**\\nFor query or doubt, comment below.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    NestedInteger deserialize(string s) {\\n        if(s[0] != \\'[\\') return NestedInteger(stoi(s)); // if string contains single number ex: \"123\".\\n        \\n        vector<NestedInteger> v; // using vector to simulate stack\\n        string num = \"\"; // num will store the number, number can be negative or positive.\\n        \\n        for(auto c: s){\\n            if(c == \\'[\\'){\\n                v.push_back(NestedInteger());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2358892,
                "title": "c-easy-recursion",
                "content": "```\\nclass Solution{\\npublic:\\n    int convert(string& s1,int i){\\n        if(i>=s1.size()) return 0;\\n        if(s1[i]==\\'-\\') return -1*convert(s1,i+1);\\n        return (s1[i]-48)*pow(10,s1.size()-i-1)+convert(s1,i+1);\\n    }\\n    NestedInteger deser(string& s,int& i,bool flag){\\n        NestedInteger ls;\\n        while(i<s.size()){\\n            if(s[i]!=\\']\\' && s[i]!=\\'[\\'  && s[i]!=\\',\\'){\\n                int res=0;\\n                int k=i;\\n                if(s[i]==\\'-\\') k++;\\n                while(k<s.size() && s[k]>=48 && s[k]<=57) k++;\\n                string s2=s.substr(i,k-i);\\n                res=(convert(s2,0));\\n                i=k;\\n                if(i>=s.size()){\\n                    return res;\\n                }\\n                if(flag){\\n                    ls.add(res);\\n                }\\n            }\\n            else if(s[i]==\\'[\\'){\\n                i++;\\n                if(flag) ls.add(deser(s,i,true));\\n                else return deser(s,i,true);\\n            }\\n            else if(s[i]==\\']\\'){\\n                i++;\\n                return ls;\\n            }\\n            else if(s[i]==\\',\\') i++;\\n        }\\n        return ls;\\n    }\\n    NestedInteger deserialize(string s) {\\n        int i=0;\\n        NestedInteger n1=deser(s,i,false);\\n        \\n        return n1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int convert(string& s1,int i){\\n        if(i>=s1.size()) return 0;\\n        if(s1[i]==\\'-\\') return -1*convert(s1,i+1);\\n        return (s1[i]-48)*pow(10,s1.size()-i-1)+convert(s1,i+1);\\n    }\\n    NestedInteger deser(string& s,int& i,bool flag){\\n        NestedInteger ls;\\n        while(i<s.size()){\\n            if(s[i]!=\\']\\' && s[i]!=\\'[\\'  && s[i]!=\\',\\'){\\n                int res=0;\\n                int k=i;\\n                if(s[i]==\\'-\\') k++;\\n                while(k<s.size() && s[k]>=48 && s[k]<=57) k++;\\n                string s2=s.substr(i,k-i);\\n                res=(convert(s2,0));\\n                i=k;\\n                if(i>=s.size()){\\n                    return res;\\n                }\\n                if(flag){\\n                    ls.add(res);\\n                }\\n            }\\n            else if(s[i]==\\'[\\'){\\n                i++;\\n                if(flag) ls.add(deser(s,i,true));\\n                else return deser(s,i,true);\\n            }\\n            else if(s[i]==\\']\\'){\\n                i++;\\n                return ls;\\n            }\\n            else if(s[i]==\\',\\') i++;\\n        }\\n        return ls;\\n    }\\n    NestedInteger deserialize(string s) {\\n        int i=0;\\n        NestedInteger n1=deser(s,i,false);\\n        \\n        return n1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356015,
                "title": "c-simple-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n\\n        int i = 0;\\n        return helper(s, i).getList()[0];\\n    }\\n    \\n    NestedInteger helper(string &s, int &i)\\n    {\\n        NestedInteger nI;\\n        \\n        while(i < s.size())\\n        {\\n            if(s[i] == \\',\\')\\n            {\\n                i++;\\n                continue;\\n            }\\n            \\n            if(s[i] == \\']\\')\\n            {\\n                i++;\\n                return nI;\\n            }\\n            \\n            if(s[i] == \\'[\\')\\n                nI.add(helper(s, ++i));\\n            else\\n            {\\n                string tmp;\\n                while(i < s.size() && s[i] != \\',\\' && s[i] != \\']\\')\\n                    tmp += s[i++];\\n                \\n                NestedInteger tmp_nI(stoi(tmp));\\n                nI.add(tmp_nI);\\n            }\\n        }\\n        \\n        return nI;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string s) {\\n\\n        int i = 0;\\n        return helper(s, i).getList()[0];\\n    }\\n    \\n    NestedInteger helper(string &s, int &i)\\n    {\\n        NestedInteger nI;\\n        \\n        while(i < s.size())\\n        {\\n            if(s[i] == \\',\\')\\n            {\\n                i++;\\n                continue;\\n            }\\n            \\n            if(s[i] == \\']\\')\\n            {\\n                i++;\\n                return nI;\\n            }\\n            \\n            if(s[i] == \\'[\\')\\n                nI.add(helper(s, ++i));\\n            else\\n            {\\n                string tmp;\\n                while(i < s.size() && s[i] != \\',\\' && s[i] != \\']\\')\\n                    tmp += s[i++];\\n                \\n                NestedInteger tmp_nI(stoi(tmp));\\n                nI.add(tmp_nI);\\n            }\\n        }\\n        \\n        return nI;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310789,
                "title": "why-is-it-called-mini-parser",
                "content": "Any idea? Can it be a more meaningful name? Thanks",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2276909,
                "title": "c-solution-made-with-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    NestedInteger* head;\\n    std::stack<NestedInteger*> myStack;\\n    \\n    void helper(std::string& s){\\n        NestedInteger* q = nullptr;\\n        int len = s.size();\\n        std::string temp =\"\";\\n        int tempInt;\\n        \\n        for (int i=0; i<len; i++){\\n            //std::cout<<\"temp = \"<<temp<<\"\\\\n\";\\n            if (s[i]==\\'-\\'||(s[i]>=\\'0\\' && s[i]<=\\'9\\')){\\n                temp += s[i]; \\n                continue;\\n            }\\n            \\n            if (s[i]==\\'[\\'){\\n                q = new NestedInteger();\\n                myStack.push(q);\\n                q = nullptr;\\n            }\\n            \\n            if (s[i]==\\',\\'){\\n                if (temp!=\"\"){\\n                    tempInt = std::stoi(temp); \\n                    myStack.top()->add(NestedInteger(tempInt));\\n                    temp = \"\";\\n                }\\n            }\\n            \\n            if (s[i]==\\']\\'){\\n                if (temp!=\"\"){\\n                    tempInt = std::stoi(temp);\\n                    myStack.top()->add(NestedInteger(tempInt));\\n                }\\n                q = myStack.top();\\n                myStack.pop();\\n                if (myStack.empty()){\\n                    head = q;\\n                }else{\\n                    myStack.top()->add(*q);\\n                }\\n                q = nullptr;\\n                temp = \"\";\\n            }\\n        }\\n    }\\n    \\n    NestedInteger deserialize(string s) {\\n        int len = s.size();\\n        if (s.find(\\'[\\')==std::string::npos){\\n            head = new NestedInteger(std::stoi(s));\\n            return *head;\\n        }\\n        helper(s);\\n        return *head;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    NestedInteger* head;\\n    std::stack<NestedInteger*> myStack;\\n    \\n    void helper(std::string& s){\\n        NestedInteger* q = nullptr;\\n        int len = s.size();\\n        std::string temp =\"\";\\n        int tempInt;\\n        \\n        for (int i=0; i<len; i++){\\n            //std::cout<<\"temp = \"<<temp<<\"\\\\n\";\\n            if (s[i]==\\'-\\'||(s[i]>=\\'0\\' && s[i]<=\\'9\\')){\\n                temp += s[i]; \\n                continue;\\n            }\\n            \\n            if (s[i]==\\'[\\'){\\n                q = new NestedInteger();\\n                myStack.push(q);\\n                q = nullptr;\\n            }\\n            \\n            if (s[i]==\\',\\'){\\n                if (temp!=\"\"){\\n                    tempInt = std::stoi(temp); \\n                    myStack.top()->add(NestedInteger(tempInt));\\n                    temp = \"\";\\n                }\\n            }\\n            \\n            if (s[i]==\\']\\'){\\n                if (temp!=\"\"){\\n                    tempInt = std::stoi(temp);\\n                    myStack.top()->add(NestedInteger(tempInt));\\n                }\\n                q = myStack.top();\\n                myStack.pop();\\n                if (myStack.empty()){\\n                    head = q;\\n                }else{\\n                    myStack.top()->add(*q);\\n                }\\n                q = nullptr;\\n                temp = \"\";\\n            }\\n        }\\n    }\\n    \\n    NestedInteger deserialize(string s) {\\n        int len = s.size();\\n        if (s.find(\\'[\\')==std::string::npos){\\n            head = new NestedInteger(std::stoi(s));\\n            return *head;\\n        }\\n        helper(s);\\n        return *head;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2199656,
                "title": "do-nothing-and-beat-100-both-time-and-memory",
                "content": "```\\n\\n# \"\"\"\\n# This is the interface that allows for creating nested lists.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n#class NestedInteger(object):\\n#    def __init__(self, value=None):\\n#        \"\"\"\\n#        If value is not specified, initializes an empty list.\\n#        Otherwise initializes a single integer equal to value.\\n#        \"\"\"\\n#\\n#    def isInteger(self):\\n#        \"\"\"\\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\\n#        :rtype bool\\n#        \"\"\"\\n#\\n#    def add(self, elem):\\n#        \"\"\"\\n#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\\n#        :rtype void\\n#        \"\"\"\\n#\\n#    def setInteger(self, value):\\n#        \"\"\"\\n#        Set this NestedInteger to hold a single integer equal to value.\\n#        :rtype void\\n#        \"\"\"\\n#\\n#    def getInteger(self):\\n#        \"\"\"\\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\\n#        Return None if this NestedInteger holds a nested list\\n#        :rtype int\\n#        \"\"\"\\n#\\n#    def getList(self):\\n#        \"\"\"\\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\\n#        Return None if this NestedInteger holds a single integer\\n#        :rtype List[NestedInteger]\\n#        \"\"\"\\n\\nclass Solution(object):\\n    def deserialize(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: NestedInteger\\n        \"\"\"\\n        NestedInt = NestedInteger(s)\\n        return NestedInt\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\\n# \"\"\"\\n# This is the interface that allows for creating nested lists.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n#class NestedInteger(object):\\n#    def __init__(self, value=None):\\n#        \"\"\"\\n#        If value is not specified, initializes an empty list.\\n#        Otherwise initializes a single integer equal to value.\\n#        \"\"\"\\n#\\n#    def isInteger(self):\\n#        \"\"\"\\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\\n#        :rtype bool\\n#        \"\"\"\\n#\\n#    def add(self, elem):\\n#        \"\"\"\\n#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\\n#        :rtype void\\n#        \"\"\"\\n#\\n#    def setInteger(self, value):\\n#        \"\"\"\\n#        Set this NestedInteger to hold a single integer equal to value.\\n#        :rtype void\\n#        \"\"\"\\n#\\n#    def getInteger(self):\\n#        \"\"\"\\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\\n#        Return None if this NestedInteger holds a nested list\\n#        :rtype int\\n#        \"\"\"\\n#\\n#    def getList(self):\\n#        \"\"\"\\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\\n#        Return None if this NestedInteger holds a single integer\\n#        :rtype List[NestedInteger]\\n#        \"\"\"\\n\\nclass Solution(object):\\n    def deserialize(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: NestedInteger\\n        \"\"\"\\n        NestedInt = NestedInteger(s)\\n        return NestedInt\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175674,
                "title": "rust-dfs",
                "content": "```\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub enum NestedInteger {\\n//   Int(i32),\\n//   List(Vec<NestedInteger>)\\n// }\\nimpl Solution {\\n    pub fn deserialize(s: String) -> NestedInteger {\\n        let mut u = 0;\\n        dfs(s.as_bytes(), &mut u)\\n    }\\n}\\n\\nfn dfs(s: &[u8], u: &mut usize) -> NestedInteger {\\n    let mut res = Vec::new();\\n    match s[*u] {\\n        b\\'[\\' => {\\n            *u += 1; // jump \\'[\\'\\n            while s[*u] != b\\']\\' {\\n                res.push(dfs(s, u));\\n            }\\n            *u += 1; // jumo \\']\\'\\n            if *u < s.len() && s[*u] == b\\',\\' {\\n                // jump \\',\\'\\n                *u += 1;\\n            }\\n        }\\n        _ => {\\n            let mut k = *u;\\n            while k < s.len() && s[k] != b\\',\\' && s[k] != b\\']\\' {\\n                k += 1;\\n            }\\n            let f = NestedInteger::Int(parse_to_int(&s[*u..k]));\\n            if k < s.len() && s[k] == b\\',\\' {\\n                // jump \\',\\'\\n                k += 1;\\n            }\\n            *u = k;\\n            // delay return\\n            return f;\\n        }\\n    }\\n    NestedInteger::List(res)\\n}\\n\\nfn parse_to_int(s: &[u8]) -> i32 {\\n    let mut res = 0;\\n    let mut sign = 1;\\n    for c in s {\\n        if *c == b\\'-\\' {\\n            sign = -1;\\n            continue;\\n        }\\n        if !c.is_ascii_digit() {\\n            break;\\n        }\\n        res = res * 10 + (*c - b\\'0\\') as i32;\\n    }\\n    res * sign\\n}\\n```",
                "solutionTags": [
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub enum NestedInteger {\\n//   Int(i32),\\n//   List(Vec<NestedInteger>)\\n// }\\nimpl Solution {\\n    pub fn deserialize(s: String) -> NestedInteger {\\n        let mut u = 0;\\n        dfs(s.as_bytes(), &mut u)\\n    }\\n}\\n\\nfn dfs(s: &[u8], u: &mut usize) -> NestedInteger {\\n    let mut res = Vec::new();\\n    match s[*u] {\\n        b\\'[\\' => {\\n            *u += 1; // jump \\'[\\'\\n            while s[*u] != b\\']\\' {\\n                res.push(dfs(s, u));\\n            }\\n            *u += 1; // jumo \\']\\'\\n            if *u < s.len() && s[*u] == b\\',\\' {\\n                // jump \\',\\'\\n                *u += 1;\\n            }\\n        }\\n        _ => {\\n            let mut k = *u;\\n            while k < s.len() && s[k] != b\\',\\' && s[k] != b\\']\\' {\\n                k += 1;\\n            }\\n            let f = NestedInteger::Int(parse_to_int(&s[*u..k]));\\n            if k < s.len() && s[k] == b\\',\\' {\\n                // jump \\',\\'\\n                k += 1;\\n            }\\n            *u = k;\\n            // delay return\\n            return f;\\n        }\\n    }\\n    NestedInteger::List(res)\\n}\\n\\nfn parse_to_int(s: &[u8]) -> i32 {\\n    let mut res = 0;\\n    let mut sign = 1;\\n    for c in s {\\n        if *c == b\\'-\\' {\\n            sign = -1;\\n            continue;\\n        }\\n        if !c.is_ascii_digit() {\\n            break;\\n        }\\n        res = res * 10 + (*c - b\\'0\\') as i32;\\n    }\\n    res * sign\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084064,
                "title": "python-dfs-traversal-74-faster-64-less-space",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    we can approach this problem using stack\\n    \"\"\"\\n    \\n    def dfs(self, i, s):\\n        res = NestedInteger()\\n        while i < len(s):\\n            if s[i] == \\'[\\':\\n                y, i = self.dfs(i+1, s)\\n                res.add(y)\\n            elif i < len(s) and s[i] == \\']\\':\\n                i+=1\\n                return res, i\\n            elif i < len(s) and s[i] == \\',\\':\\n                i+=1\\n            else: \\n                if i < len(s):\\n                    start = i\\n                    while s[i] != \\',\\' and s[i] != \\']\\':\\n                        i+=1\\n                    res.add(NestedInteger(int(s[start:i])))\\n        return res, i\\n    \\n    def deserialize(self, s: str) -> NestedInteger:\\n        if s[0] == \\'[\\':\\n            res, i = self.dfs(1, s)\\n            return res\\n        else:\\n            num = int(s)\\n            res = NestedInteger()\\n            res.setInteger(num)\\n            return res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    we can approach this problem using stack\\n    \"\"\"\\n    \\n    def dfs(self, i, s):\\n        res = NestedInteger()\\n        while i < len(s):\\n            if s[i] == \\'[\\':\\n                y, i = self.dfs(i+1, s)\\n                res.add(y)\\n            elif i < len(s) and s[i] == \\']\\':\\n                i+=1\\n                return res, i\\n            elif i < len(s) and s[i] == \\',\\':\\n                i+=1\\n            else: \\n                if i < len(s):\\n                    start = i\\n                    while s[i] != \\',\\' and s[i] != \\']\\':\\n                        i+=1\\n                    res.add(NestedInteger(int(s[start:i])))\\n        return res, i\\n    \\n    def deserialize(self, s: str) -> NestedInteger:\\n        if s[0] == \\'[\\':\\n            res, i = self.dfs(1, s)\\n            return res\\n        else:\\n            num = int(s)\\n            res = NestedInteger()\\n            res.setInteger(num)\\n            return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078887,
                "title": "java",
                "content": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * public interface NestedInteger {\\n *     // Constructor initializes an empty nested list.\\n *     public NestedInteger();\\n *\\n *     // Constructor initializes a single integer.\\n *     public NestedInteger(int value);\\n *\\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     public boolean isInteger();\\n *\\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // Return null if this NestedInteger holds a nested list\\n *     public Integer getInteger();\\n *\\n *     // Set this NestedInteger to hold a single integer.\\n *     public void setInteger(int value);\\n *\\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\\n *     public void add(NestedInteger ni);\\n *\\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // Return empty list if this NestedInteger holds a single integer\\n *     public List<NestedInteger> getList();\\n * }\\n */\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        if(s.charAt(0)!=\\'[\\')return new NestedInteger(Integer.parseInt(s));\\n        return dfs(s.toCharArray());\\n    }\\n    int x=0;\\n    private NestedInteger dfs(char[]s){\\n        int st=0,p=1;\\n        NestedInteger root=new NestedInteger();\\n        int i=x+1;\\n        for(;i<s.length;++i){\\n            if(s[i]==\\'[\\'){\\n                x=i;\\n                root.add(dfs(s));\\n                i=x;\\n            }else if(s[i]<=\\'9\\'&&s[i]>=\\'0\\'){\\n                st=st*10+s[i]-\\'0\\';\\n                if(s[i+1]>\\'9\\'||s[i+1]<\\'0\\'){\\n                    root.add(new NestedInteger(st*p));\\n                    st=0;p=1;\\n                }\\n            }else if(s[i]==\\']\\'){\\n                x=i;\\n                return root;\\n            }else if(s[i]==\\'-\\'){\\n                p=-1;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * public interface NestedInteger {\\n *     // Constructor initializes an empty nested list.\\n *     public NestedInteger();\\n *\\n *     // Constructor initializes a single integer.\\n *     public NestedInteger(int value);\\n *\\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\\n *     public boolean isInteger();\\n *\\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\\n *     // Return null if this NestedInteger holds a nested list\\n *     public Integer getInteger();\\n *\\n *     // Set this NestedInteger to hold a single integer.\\n *     public void setInteger(int value);\\n *\\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\\n *     public void add(NestedInteger ni);\\n *\\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\\n *     // Return empty list if this NestedInteger holds a single integer\\n *     public List<NestedInteger> getList();\\n * }\\n */\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        if(s.charAt(0)!=\\'[\\')return new NestedInteger(Integer.parseInt(s));\\n        return dfs(s.toCharArray());\\n    }\\n    int x=0;\\n    private NestedInteger dfs(char[]s){\\n        int st=0,p=1;\\n        NestedInteger root=new NestedInteger();\\n        int i=x+1;\\n        for(;i<s.length;++i){\\n            if(s[i]==\\'[\\'){\\n                x=i;\\n                root.add(dfs(s));\\n                i=x;\\n            }else if(s[i]<=\\'9\\'&&s[i]>=\\'0\\'){\\n                st=st*10+s[i]-\\'0\\';\\n                if(s[i+1]>\\'9\\'||s[i+1]<\\'0\\'){\\n                    root.add(new NestedInteger(st*p));\\n                    st=0;p=1;\\n                }\\n            }else if(s[i]==\\']\\'){\\n                x=i;\\n                return root;\\n            }else if(s[i]==\\'-\\'){\\n                p=-1;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028333,
                "title": "simple-iterative-solution",
                "content": "\\n\\n```java\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        \\n        \\n        Stack<NestedInteger> st = new Stack<>();\\n\\n        char [] ch = s.toCharArray();\\n        \\n        if (ch[0] != \\'[\\') {\\n            return new NestedInteger(Integer.valueOf(s));\\n        }\\n        \\n        String num = \"\";\\n        \\n        for (int i = 0; i < ch.length; i++) {\\n            char c = ch[i];\\n            \\n            if (Character.isDigit(c) || c ==\\'-\\') {\\n                num += c;\\n            } \\n            else\\n                if (c == \\',\\') {\\n                    if (num.length() > 0) {\\n                        st.peek().add(new NestedInteger(Integer.valueOf(num)));\\n                        num = \"\";\\n                    }\\n\\n                }\\n            else \\n                if (c == \\'[\\') {\\n                    st.push(new NestedInteger());\\n                } \\n            else \\n                if (c == \\']\\') {\\n                    if (num.length() > 0) {\\n                        st.peek().add(new NestedInteger(Integer.valueOf(num)));\\n                        num = \"\";\\n                    }\\n                    NestedInteger last = st.pop();\\n                    if (st.isEmpty()) {\\n                        st.push(last);\\n                    } else {\\n                        st.peek().add(last);\\n                    }\\n                }\\n                \\n        }\\n        \\n        return st.pop();\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack",
                    "Iterator"
                ],
                "code": "```java\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        \\n        \\n        Stack<NestedInteger> st = new Stack<>();\\n\\n        char [] ch = s.toCharArray();\\n        \\n        if (ch[0] != \\'[\\') {\\n            return new NestedInteger(Integer.valueOf(s));\\n        }\\n        \\n        String num = \"\";\\n        \\n        for (int i = 0; i < ch.length; i++) {\\n            char c = ch[i];\\n            \\n            if (Character.isDigit(c) || c ==\\'-\\') {\\n                num += c;\\n            } \\n            else\\n                if (c == \\',\\') {\\n                    if (num.length() > 0) {\\n                        st.peek().add(new NestedInteger(Integer.valueOf(num)));\\n                        num = \"\";\\n                    }\\n\\n                }\\n            else \\n                if (c == \\'[\\') {\\n                    st.push(new NestedInteger());\\n                } \\n            else \\n                if (c == \\']\\') {\\n                    if (num.length() > 0) {\\n                        st.peek().add(new NestedInteger(Integer.valueOf(num)));\\n                        num = \"\";\\n                    }\\n                    NestedInteger last = st.pop();\\n                    if (st.isEmpty()) {\\n                        st.push(last);\\n                    } else {\\n                        st.peek().add(last);\\n                    }\\n                }\\n                \\n        }\\n        \\n        return st.pop();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024356,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn deserialize(s: String) -> NestedInteger {\\n        if !s.starts_with(\\'[\\') {\\n            return NestedInteger::Int(s.parse::<i32>().unwrap());\\n        }\\n        Self::parse_to_list(&s.chars().collect::<Vec<char>>(), 0, None).0\\n    }\\n    fn parse_to_list(\\n        s: &[char],\\n        cursor: usize,\\n        prev: Option<NestedInteger>,\\n    ) -> (NestedInteger, usize) {\\n        let mut cur = cursor;\\n        let mut list = vec![];\\n        let mut item = prev;\\n        while cur < s.len() {\\n            match s[cur] {\\n                \\'[\\' => {\\n                    let (l, c) = Self::parse_to_list(s, cur + 1, item);\\n                    item = Some(l);\\n                    cur = c;\\n                }\\n                \\',\\' => {\\n                    if let Some(v) = item {\\n                        list.push(v);\\n                        cur += 1;\\n                        item = None;\\n                    }\\n                }\\n                \\']\\' => {\\n                    if let Some(v) = item {\\n                        list.push(v);\\n                    }\\n                    return (NestedInteger::List(list), cur + 1);\\n                }\\n                c if c.is_digit(10) || c == \\'-\\' => {\\n                    let (val, len) = Self::parse_to_int(&s[cur..]);\\n                    item = Some(NestedInteger::Int(val));\\n                    cur += len;\\n                }\\n                _ => {\\n                    cur += 1;\\n                }\\n            }\\n        }\\n        (item.unwrap(), cur)\\n    }\\n    fn parse_to_int(s: &[char]) -> (i32, usize) {\\n        let mut res = 0;\\n        let mut sign = 1;\\n        let mut len = 0;\\n        for c in s {\\n            if *c == \\'-\\' {\\n                sign = -1;\\n                len += 1;\\n                continue;\\n            }\\n            if !c.is_digit(10) {\\n                break;\\n            }\\n            res = res * 10 + c.to_digit(10).unwrap() as i32;\\n            len += 1;\\n        }\\n        (res * sign, len)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn deserialize(s: String) -> NestedInteger {\\n        if !s.starts_with(\\'[\\') {\\n            return NestedInteger::Int(s.parse::<i32>().unwrap());\\n        }\\n        Self::parse_to_list(&s.chars().collect::<Vec<char>>(), 0, None).0\\n    }\\n    fn parse_to_list(\\n        s: &[char],\\n        cursor: usize,\\n        prev: Option<NestedInteger>,\\n    ) -> (NestedInteger, usize) {\\n        let mut cur = cursor;\\n        let mut list = vec![];\\n        let mut item = prev;\\n        while cur < s.len() {\\n            match s[cur] {\\n                \\'[\\' => {\\n                    let (l, c) = Self::parse_to_list(s, cur + 1, item);\\n                    item = Some(l);\\n                    cur = c;\\n                }\\n                \\',\\' => {\\n                    if let Some(v) = item {\\n                        list.push(v);\\n                        cur += 1;\\n                        item = None;\\n                    }\\n                }\\n                \\']\\' => {\\n                    if let Some(v) = item {\\n                        list.push(v);\\n                    }\\n                    return (NestedInteger::List(list), cur + 1);\\n                }\\n                c if c.is_digit(10) || c == \\'-\\' => {\\n                    let (val, len) = Self::parse_to_int(&s[cur..]);\\n                    item = Some(NestedInteger::Int(val));\\n                    cur += len;\\n                }\\n                _ => {\\n                    cur += 1;\\n                }\\n            }\\n        }\\n        (item.unwrap(), cur)\\n    }\\n    fn parse_to_int(s: &[char]) -> (i32, usize) {\\n        let mut res = 0;\\n        let mut sign = 1;\\n        let mut len = 0;\\n        for c in s {\\n            if *c == \\'-\\' {\\n                sign = -1;\\n                len += 1;\\n                continue;\\n            }\\n            if !c.is_digit(10) {\\n                break;\\n            }\\n            res = res * 10 + c.to_digit(10).unwrap() as i32;\\n            len += 1;\\n        }\\n        (res * sign, len)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1999576,
                "title": "python-clear-recursive-solution-with-comments",
                "content": "```\\n\\'\\'\\'\\nParse all the ni in the current level.\\nRecursively deserialize all of them and add to the current ni list\\nBase case: if current ni is not a list and is an integer.\\n\\nTest cases:\\n\"[-123,[-456,[7839,[[[[]]]]]]]\"\\n\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        \\n        ni = NestedInteger()\\n        \\n        elements = []\\n        is_list = False\\n        if s[0] == \\'[\\':\\n            is_list = True\\n        \\n        # Base case: if current ni is not a list return int ni\\n        if not is_list:\\n            return NestedInteger(int(s))\\n        \\n        # Parse all the elements in the current level and add to a list\\n        i = 1\\n        while i < len(s)-1:\\n            if s[i] == \\',\\':\\n                i+=1\\n            elif s[i] == \\'[\\':\\n                # Parse list\\n                i+=1\\n                bal = 1\\n                cur = [\\'[\\']\\n                while i<len(s)-1 and bal > 0:\\n                    if s[i] == \\']\\':\\n                        bal-=1\\n                    elif s[i] == \\'[\\':\\n                        bal+=1\\n                    cur.append(s[i])\\n                    i+=1\\n                elements.append(\\'\\'.join(cur))\\n            else:\\n                cur = []\\n                while i<len(s)-1 and s[i] != \\',\\':\\n                    cur.append(s[i])\\n                    i+=1\\n                elements.append(\\'\\'.join(cur))\\n        \\n        # For each parsed element, recursively call deserialize and add to the ni list\\n        for element in elements:\\n            cur_ni = self.deserialize(element)\\n            ni.add(cur_ni)\\n        return ni\\n            \\n            \\n        \\n                \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\nParse all the ni in the current level.\\nRecursively deserialize all of them and add to the current ni list\\nBase case: if current ni is not a list and is an integer.\\n\\nTest cases:\\n\"[-123,[-456,[7839,[[[[]]]]]]]\"\\n\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n    def deserialize(self, s: str) -> NestedInteger:\\n        \\n        ni = NestedInteger()\\n        \\n        elements = []\\n        is_list = False\\n        if s[0] == \\'[\\':\\n            is_list = True\\n        \\n        # Base case: if current ni is not a list return int ni\\n        if not is_list:\\n            return NestedInteger(int(s))\\n        \\n        # Parse all the elements in the current level and add to a list\\n        i = 1\\n        while i < len(s)-1:\\n            if s[i] == \\',\\':\\n                i+=1\\n            elif s[i] == \\'[\\':\\n                # Parse list\\n                i+=1\\n                bal = 1\\n                cur = [\\'[\\']\\n                while i<len(s)-1 and bal > 0:\\n                    if s[i] == \\']\\':\\n                        bal-=1\\n                    elif s[i] == \\'[\\':\\n                        bal+=1\\n                    cur.append(s[i])\\n                    i+=1\\n                elements.append(\\'\\'.join(cur))\\n            else:\\n                cur = []\\n                while i<len(s)-1 and s[i] != \\',\\':\\n                    cur.append(s[i])\\n                    i+=1\\n                elements.append(\\'\\'.join(cur))\\n        \\n        # For each parsed element, recursively call deserialize and add to the ni list\\n        for element in elements:\\n            cur_ni = self.deserialize(element)\\n            ni.add(cur_ni)\\n        return ni\\n            \\n            \\n        \\n                \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1928504,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar deserialize = function(s) {\\n\\t\\tif (s[0] !== \\'[\\') return new NestedInteger(s);\\n\\n\\t\\tconst stack = [];\\n\\t\\tlet start = 0;\\n\\t\\tconst process = {\\n\\t\\t\\t\\'[\\'(index) {\\n\\t\\t\\t\\tstack.push(new NestedInteger());\\n\\t\\t\\t\\tstart = index + 1;\\n\\t\\t\\t},\\n\\t\\t\\t\\',\\'(index) {\\n\\t\\t\\t\\tif (index > start) {\\n\\t\\t\\t\\t\\tconst value = s.slice(start, index);\\n\\t\\t\\t\\t\\tstack[stack.length - 1].add(new NestedInteger(value));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstart = index + 1;\\n\\t\\t\\t},\\n\\t\\t\\t\\']\\'(index) {\\n\\t\\t\\t\\tthis[\\',\\'](index);\\n\\t\\t\\t\\tif (stack.length < 2) return;\\n\\t\\t\\t\\tconst last = stack.pop();\\n\\t\\t\\t\\tstack[stack.length - 1].add(last);\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\t[...s].forEach((current, index) => process[current]?.(index));\\n\\n\\t\\treturn stack[0];\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar deserialize = function(s) {\\n\\t\\tif (s[0] !== \\'[\\') return new NestedInteger(s);\\n\\n\\t\\tconst stack = [];\\n\\t\\tlet start = 0;\\n\\t\\tconst process = {\\n\\t\\t\\t\\'[\\'(index) {\\n\\t\\t\\t\\tstack.push(new NestedInteger());\\n\\t\\t\\t\\tstart = index + 1;\\n\\t\\t\\t},\\n\\t\\t\\t\\',\\'(index) {\\n\\t\\t\\t\\tif (index > start) {\\n\\t\\t\\t\\t\\tconst value = s.slice(start, index);\\n\\t\\t\\t\\t\\tstack[stack.length - 1].add(new NestedInteger(value));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstart = index + 1;\\n\\t\\t\\t},\\n\\t\\t\\t\\']\\'(index) {\\n\\t\\t\\t\\tthis[\\',\\'](index);\\n\\t\\t\\t\\tif (stack.length < 2) return;\\n\\t\\t\\t\\tconst last = stack.pop();\\n\\t\\t\\t\\tstack[stack.length - 1].add(last);\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\t[...s].forEach((current, index) => process[current]?.(index));\\n\\n\\t\\treturn stack[0];\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1885422,
                "title": "go-golang-iterative-time-o-n-8-ms-33-33-space-o-n-4-5-mb-100",
                "content": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * type NestedInteger struct {\\n * }\\n *\\n * // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n * func (n NestedInteger) IsInteger() bool {}\\n *\\n * // Return the single integer that this NestedInteger holds, if it holds a single integer\\n * // The result is undefined if this NestedInteger holds a nested list\\n * // So before calling this method, you should have a check\\n * func (n NestedInteger) GetInteger() int {}\\n *\\n * // Set this NestedInteger to hold a single integer.\\n * func (n *NestedInteger) SetInteger(value int) {}\\n *\\n * // Set this NestedInteger to hold a nested list and adds a nested integer to it.\\n * func (n *NestedInteger) Add(elem NestedInteger) {}\\n *\\n * // Return the nested list that this NestedInteger holds, if it holds a nested list\\n * // The list length is zero if this NestedInteger holds a single integer\\n * // You can access NestedInteger\\'s List element directly if you want to modify it\\n * func (n NestedInteger) GetList() []*NestedInteger {}\\n */\\nfunc deserialize(s string) *NestedInteger {\\n    if s[0] != \\'[\\' {\\n        value, _ := strconv.Atoi(s)\\n        result := &NestedInteger{}\\n        result.SetInteger(value)\\n        return result\\n    }\\n\\n    stack, start := []*NestedInteger{}, 1\\n    \\n    for i, c := range s {\\n        switch c {\\n        case \\'[\\':\\n            stack = append(stack, &NestedInteger{})\\n            start = i + 1\\n        case \\',\\':\\n            top := stack[len(stack) - 1]\\n            if start < i {\\n                value, _ := strconv.Atoi(s[start:i])\\n                current := &NestedInteger{}\\n                current.SetInteger(value)\\n                top.Add(*current)\\n            }\\n            start = i + 1\\n        case \\']\\':\\n            top := stack[len(stack) - 1]\\n            stack = stack[:len(stack) - 1]\\n            if start < i {\\n                value, _ := strconv.Atoi(s[start:i])\\n                current := &NestedInteger{}\\n                current.SetInteger(value)\\n                top.Add(*current)\\n            }\\n            start = i + 1\\n            if len(stack) > 0 {\\n                stack[len(stack) - 1].Add(*top)\\n            } else {\\n                return top\\n            }\\n        }\\n    }\\n    \\n    return nil\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * // This is the interface that allows for creating nested lists.\\n * // You should not implement it, or speculate about its implementation\\n * type NestedInteger struct {\\n * }\\n *\\n * // Return true if this NestedInteger holds a single integer, rather than a nested list.\\n * func (n NestedInteger) IsInteger() bool {}\\n *\\n * // Return the single integer that this NestedInteger holds, if it holds a single integer\\n * // The result is undefined if this NestedInteger holds a nested list\\n * // So before calling this method, you should have a check\\n * func (n NestedInteger) GetInteger() int {}\\n *\\n * // Set this NestedInteger to hold a single integer.\\n * func (n *NestedInteger) SetInteger(value int) {}\\n *\\n * // Set this NestedInteger to hold a nested list and adds a nested integer to it.\\n * func (n *NestedInteger) Add(elem NestedInteger) {}\\n *\\n * // Return the nested list that this NestedInteger holds, if it holds a nested list\\n * // The list length is zero if this NestedInteger holds a single integer\\n * // You can access NestedInteger\\'s List element directly if you want to modify it\\n * func (n NestedInteger) GetList() []*NestedInteger {}\\n */\\nfunc deserialize(s string) *NestedInteger {\\n    if s[0] != \\'[\\' {\\n        value, _ := strconv.Atoi(s)\\n        result := &NestedInteger{}\\n        result.SetInteger(value)\\n        return result\\n    }\\n\\n    stack, start := []*NestedInteger{}, 1\\n    \\n    for i, c := range s {\\n        switch c {\\n        case \\'[\\':\\n            stack = append(stack, &NestedInteger{})\\n            start = i + 1\\n        case \\',\\':\\n            top := stack[len(stack) - 1]\\n            if start < i {\\n                value, _ := strconv.Atoi(s[start:i])\\n                current := &NestedInteger{}\\n                current.SetInteger(value)\\n                top.Add(*current)\\n            }\\n            start = i + 1\\n        case \\']\\':\\n            top := stack[len(stack) - 1]\\n            stack = stack[:len(stack) - 1]\\n            if start < i {\\n                value, _ := strconv.Atoi(s[start:i])\\n                current := &NestedInteger{}\\n                current.SetInteger(value)\\n                top.Add(*current)\\n            }\\n            start = i + 1\\n            if len(stack) > 0 {\\n                stack[len(stack) - 1].Add(*top)\\n            } else {\\n                return top\\n            }\\n        }\\n    }\\n    \\n    return nil\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1860479,
                "title": "php-using-recursion",
                "content": "Solution uses recursion with storing all replaced lists\\n```\\nclass Solution\\n{\\n    public function deserialize($s, array $stored = [])\\n    {\\n        // no brackets - this is an integer\\n        if ($s[0] !== \\'[\\') {\\n            return new NestedInteger($s);\\n        }\\n\\n        // only one pair of brackets - this is a plain array\\n        if (substr_count($s, \\'[\\') === 1) {\\n            $s = trim($s, \\'[]\\');\\n            $ni = new NestedInteger();\\n\\n            if ($s === \\'\\') {\\n                return $ni;\\n            }\\n\\n            foreach (explode(\\',\\', $s) as $elem) {\\n                if ($elem[0] === \\':\\' && isset($stored[$elem])) {\\n                    // one of stored lists found\\n                    $ni->add($stored[$elem]);\\n                } elseif (is_numeric($elem)) {\\n                    // an integer found\\n                    $ni->add(new NestedInteger($elem));\\n                } elseif ($elem[0] === \\'[\\') {\\n                    // a nested array found\\n                    $ni->add($this->deserialize($elem, $stored));\\n                }\\n            }\\n\\n            return $ni;\\n        }\\n\\n        // find one (the most nested or last) array\\n        $lastOpenBracket = strrpos($s, \\'[\\');\\n        $lastCloseBracket = strpos($s, \\']\\', $lastOpenBracket);\\n        $length = $lastCloseBracket - $lastOpenBracket + 1;\\n\\n        // here comes recursion for a single array\\n        $substring = substr($s, $lastOpenBracket, $length);\\n        $carry = $this->deserialize($substring, $stored);\\n        // use \":\" as a prefix for distinguishing hashes\\n        $hash = \\':\\' . spl_object_hash($carry);\\n        $stored[$hash] = $carry;\\n\\n        $replace = substr_replace($s, $hash, $lastOpenBracket, $length);\\n\\n        return $this->deserialize($replace, $stored);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    public function deserialize($s, array $stored = [])\\n    {\\n        // no brackets - this is an integer\\n        if ($s[0] !== \\'[\\') {\\n            return new NestedInteger($s);\\n        }\\n\\n        // only one pair of brackets - this is a plain array\\n        if (substr_count($s, \\'[\\') === 1) {\\n            $s = trim($s, \\'[]\\');\\n            $ni = new NestedInteger();\\n\\n            if ($s === \\'\\') {\\n                return $ni;\\n            }\\n\\n            foreach (explode(\\',\\', $s) as $elem) {\\n                if ($elem[0] === \\':\\' && isset($stored[$elem])) {\\n                    // one of stored lists found\\n                    $ni->add($stored[$elem]);\\n                } elseif (is_numeric($elem)) {\\n                    // an integer found\\n                    $ni->add(new NestedInteger($elem));\\n                } elseif ($elem[0] === \\'[\\') {\\n                    // a nested array found\\n                    $ni->add($this->deserialize($elem, $stored));\\n                }\\n            }\\n\\n            return $ni;\\n        }\\n\\n        // find one (the most nested or last) array\\n        $lastOpenBracket = strrpos($s, \\'[\\');\\n        $lastCloseBracket = strpos($s, \\']\\', $lastOpenBracket);\\n        $length = $lastCloseBracket - $lastOpenBracket + 1;\\n\\n        // here comes recursion for a single array\\n        $substring = substr($s, $lastOpenBracket, $length);\\n        $carry = $this->deserialize($substring, $stored);\\n        // use \":\" as a prefix for distinguishing hashes\\n        $hash = \\':\\' . spl_object_hash($carry);\\n        $stored[$hash] = $carry;\\n\\n        $replace = substr_replace($s, $hash, $lastOpenBracket, $length);\\n\\n        return $this->deserialize($replace, $stored);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850312,
                "title": "some-kind-of-parser",
                "content": "```\\nclass Solution {\\n    NestedInteger parseNested(string& s, int& i) {\\n        vector<NestedInteger> list;\\n        bool sign = false;\\n        int d = INT_MIN;\\n        while (i < s.size()) {\\n            char c = s[i++];\\n            if (c == \\'[\\') {\\n                NestedInteger ni = parseNested(s, i);\\n                list.push_back(ni);\\n            } else if (c == \\']\\') {\\n                if (d != INT_MIN) {\\n                    if (sign)\\n                        d = -d;\\n                    list.push_back(NestedInteger(d));\\n                }\\n                NestedInteger res;\\n                for (auto& ni : list)\\n                    res.add(ni);\\n                return res;\\n            } else if (c == \\',\\') {\\n                if (d != INT_MIN) {\\n                    if (sign)\\n                        d = -d;\\n                    list.push_back(NestedInteger(d));\\n                    d = INT_MIN;\\n                }\\n                sign = false;\\n            } else if (isdigit(c)) {\\n                if (d == INT_MIN)\\n                    d = 0;\\n                d = d * 10 + c - \\'0\\';\\n            } else if (c == \\'-\\') {\\n                sign = true;\\n            }\\n        }\\n        return NestedInteger();\\n    }\\npublic:\\n    NestedInteger deserialize(string s) {\\n        if (isdigit(s[0]) || s[0] == \\'-\\')\\n            return NestedInteger(stoi(s));\\n        int i = 1;\\n        return parseNested(s, i);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    NestedInteger parseNested(string& s, int& i) {\\n        vector<NestedInteger> list;\\n        bool sign = false;\\n        int d = INT_MIN;\\n        while (i < s.size()) {\\n            char c = s[i++];\\n            if (c == \\'[\\') {\\n                NestedInteger ni = parseNested(s, i);\\n                list.push_back(ni);\\n            } else if (c == \\']\\') {\\n                if (d != INT_MIN) {\\n                    if (sign)\\n                        d = -d;\\n                    list.push_back(NestedInteger(d));\\n                }\\n                NestedInteger res;\\n                for (auto& ni : list)\\n                    res.add(ni);\\n                return res;\\n            } else if (c == \\',\\') {\\n                if (d != INT_MIN) {\\n                    if (sign)\\n                        d = -d;\\n                    list.push_back(NestedInteger(d));\\n                    d = INT_MIN;\\n                }\\n                sign = false;\\n            } else if (isdigit(c)) {\\n                if (d == INT_MIN)\\n                    d = 0;\\n                d = d * 10 + c - \\'0\\';\\n            } else if (c == \\'-\\') {\\n                sign = true;\\n            }\\n        }\\n        return NestedInteger();\\n    }\\npublic:\\n    NestedInteger deserialize(string s) {\\n        if (isdigit(s[0]) || s[0] == \\'-\\')\\n            return NestedInteger(stoi(s));\\n        int i = 1;\\n        return parseNested(s, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791615,
                "title": "python-no-built-in-libs-the-way-you-cut-makes-difference",
                "content": "````\\nclass Solution:\\n    def cut_children(self, s):\\n        if not s: return []\\n        result = []\\n        i, N, child = 0, len(s), \\'\\'\\n        while i < N:\\n            c = s[i]\\n            if c == \\',\\':\\n                result.append(child)\\n                child = \\'\\'\\n                i += 1\\n            elif c == \\'[\\':\\n                count = 1\\n                child = \\'[\\'\\n                i += 1\\n                while i < N and count > 0:\\n                    if s[i] == \\'[\\': count += 1                    \\n                    if s[i] == \\']\\': count -= 1\\n                    child += s[i]\\n                    i += 1\\n            else:\\n                child += s[i]\\n                i += 1   \\n            \\n            if i == N:\\n                result.append(child)\\n        return result\\n                  \\n    def make_node(self, s):\\n        me = NestedInteger()\\n        if s[0] == \\'[\\':\\n            s = s[1:-1]\\n            for child in self.cut_children(s): me.add(self.make_node(child)) \\n        else: me.setInteger(int(s))\\n        return me\\n    def deserialize(self, s: str) -> NestedInteger:\\n        return self.make_node(s)\\n````",
                "solutionTags": [],
                "code": "````\\nclass Solution:\\n    def cut_children(self, s):\\n        if not s: return []\\n        result = []\\n        i, N, child = 0, len(s), \\'\\'\\n        while i < N:\\n            c = s[i]\\n            if c == \\',\\':\\n                result.append(child)\\n                child = \\'\\'\\n                i += 1\\n            elif c == \\'[\\':\\n                count = 1\\n                child = \\'[\\'\\n                i += 1\\n                while i < N and count > 0:\\n                    if s[i] == \\'[\\': count += 1                    \\n                    if s[i] == \\']\\': count -= 1\\n                    child += s[i]\\n                    i += 1\\n            else:\\n                child += s[i]\\n                i += 1   \\n            \\n            if i == N:\\n                result.append(child)\\n        return result\\n                  \\n    def make_node(self, s):\\n        me = NestedInteger()\\n        if s[0] == \\'[\\':\\n            s = s[1:-1]\\n            for child in self.cut_children(s): me.add(self.make_node(child)) \\n        else: me.setInteger(int(s))\\n        return me\\n    def deserialize(self, s: str) -> NestedInteger:\\n        return self.make_node(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775842,
                "title": "c-solution-using-a-tokenizer",
                "content": "```cpp\\nstruct Token {\\n  char type;\\n  int val;\\n};\\n\\nclass Solution {\\n public:\\n  NestedInteger deserialize(string s) {\\n    int index = 0;\\n    return deserialize(s, index);\\n  }\\n\\n private:\\n  Token cache_;\\n  bool isFull_;\\n\\n  NestedInteger deserialize(string s, int &index) {\\n    Token tok = getNextToken(s, index);\\n    if (tok.type == \\'0\\') {\\n      return NestedInteger(tok.val);\\n    } else {\\n      NestedInteger list;\\n      Token temp = getNextToken(s, index);\\n      if (temp.type == \\']\\') {\\n        return list;\\n      }\\n      putBack(temp);\\n      while (true) {\\n        list.add(deserialize(s, index));\\n        Token nextTok = getNextToken(s, index);\\n        if (nextTok.type == \\']\\') {\\n          break;\\n        }\\n      }\\n      return list;\\n    }\\n  }\\n\\n  Token getNextToken(string s, int &index) {\\n    if (isFull_) {\\n      isFull_ = false;\\n      return cache_;\\n    }\\n    if (string(\"[],\").find(s[index]) != string::npos) {\\n      return {\\n          s[index++],\\n      };\\n    }\\n    int num = 0;\\n    int multiply = 1;\\n    if (s[index] == \\'-\\') {\\n      multiply = -1;\\n      ++index;\\n    }\\n    while (index < s.size() && (isdigit(s[index]))) {\\n      num = num * 10 + toInt(s[index]);\\n      ++index;\\n    }\\n    return {\\'0\\', num*multiply};\\n  }\\n\\n  void putBack(Token tok) {\\n    assert(isFull_ == false);\\n    cache_ = tok;\\n    isFull_ = true;\\n  }\\n\\n  int toInt(char c) { return c - \\'0\\'; }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstruct Token {\\n  char type;\\n  int val;\\n};\\n\\nclass Solution {\\n public:\\n  NestedInteger deserialize(string s) {\\n    int index = 0;\\n    return deserialize(s, index);\\n  }\\n\\n private:\\n  Token cache_;\\n  bool isFull_;\\n\\n  NestedInteger deserialize(string s, int &index) {\\n    Token tok = getNextToken(s, index);\\n    if (tok.type == \\'0\\') {\\n      return NestedInteger(tok.val);\\n    } else {\\n      NestedInteger list;\\n      Token temp = getNextToken(s, index);\\n      if (temp.type == \\']\\') {\\n        return list;\\n      }\\n      putBack(temp);\\n      while (true) {\\n        list.add(deserialize(s, index));\\n        Token nextTok = getNextToken(s, index);\\n        if (nextTok.type == \\']\\') {\\n          break;\\n        }\\n      }\\n      return list;\\n    }\\n  }\\n\\n  Token getNextToken(string s, int &index) {\\n    if (isFull_) {\\n      isFull_ = false;\\n      return cache_;\\n    }\\n    if (string(\"[],\").find(s[index]) != string::npos) {\\n      return {\\n          s[index++],\\n      };\\n    }\\n    int num = 0;\\n    int multiply = 1;\\n    if (s[index] == \\'-\\') {\\n      multiply = -1;\\n      ++index;\\n    }\\n    while (index < s.size() && (isdigit(s[index]))) {\\n      num = num * 10 + toInt(s[index]);\\n      ++index;\\n    }\\n    return {\\'0\\', num*multiply};\\n  }\\n\\n  void putBack(Token tok) {\\n    assert(isFull_ == false);\\n    cache_ = tok;\\n    isFull_ = true;\\n  }\\n\\n  int toInt(char c) { return c - \\'0\\'; }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670562,
                "title": "typescript-tokenizer-one-pass",
                "content": "```TypeScript\\ntype Rule = [string | RegExp, Array<[string | RegExp, (v: string) => void]>];\\n\\nclass LiteralNode {\\n  val: string;\\n  type: \"number\" | \"list\";\\n  children: LiteralNode[];\\n  parent: LiteralNode;\\n  constructor(v = \"\", isList = 0) {\\n    this.val = v;\\n    this.type = isList ? \"list\" : \"number\";\\n    if (this.type === \"list\") {\\n      this.children = [];\\n    }\\n  }\\n\\n  get isList() {\\n    return this.type === \"list\";\\n  }\\n  get currentString() {\\n    return this.val ? \"\" : this.val[this.val.length - 1];\\n  }\\n}\\nconst emptyMarker = \"empty\";\\n\\nfunction deserialize(s: string): any {\\n  let currentNode: LiteralNode = new LiteralNode(\"\", 0);\\n  let root: LiteralNode;\\n  let idx = 0;\\n  const rule = [\\n    [\\n      \"\",\\n      [\\n        [\\n          /\\\\d|-/,\\n          function (v) {\\n            currentNode = new LiteralNode(v, 0);\\n            root = currentNode;\\n          },\\n        ],\\n        [\\n          /\\\\[/,\\n          function (v) {\\n            currentNode = new LiteralNode(v, 1);\\n            root = currentNode;\\n          },\\n        ],\\n      ],\\n    ],\\n    [\\n      \"-\",\\n      [\\n        [\\n          /\\\\d/,\\n          function (v) {\\n            currentNode.val += v;\\n          },\\n        ],\\n      ],\\n    ],\\n    [\\n      /\\\\d/,\\n      [\\n        [\\n          /\\\\d/,\\n          function (v) {\\n            return (currentNode.val += v);\\n          },\\n        ],\\n        [\\n          /,/,\\n          function (v) {\\n            if (!currentNode.parent || !currentNode.parent.isList) {\\n              throw new Error(`parent is not a list ${currentNode.val}${v}`);\\n            }\\n            const newNode = new LiteralNode(emptyMarker, 0);\\n            newNode.parent = currentNode.parent;\\n            currentNode.parent.children.push(newNode);\\n            currentNode = newNode;\\n          },\\n        ],\\n        [\\n          /\\\\]/,\\n          function (v) {\\n            if (!currentNode.parent || !currentNode.parent.isList) {\\n              throw new Error(`parent is not a list ${currentNode.val}${v}`);\\n            }\\n            currentNode = currentNode.parent;\\n            currentNode.val += v;\\n          },\\n        ],\\n      ],\\n    ],\\n    [\\n      /\\\\[/,\\n      [\\n        [\\n          /\\\\d|-/,\\n          function (v) {\\n            const newNode = new LiteralNode(v, 0);\\n            currentNode.children.push(newNode);\\n            newNode.parent = currentNode;\\n            currentNode = newNode;\\n          },\\n        ],\\n        [\\n          /\\\\[/,\\n          function (v) {\\n            const newNode = new LiteralNode(v, 1);\\n            currentNode.children.push(newNode);\\n            newNode.parent = currentNode;\\n            currentNode = newNode;\\n          },\\n        ],\\n        [\\n          /\\\\]/,\\n          function (v) {\\n            currentNode.val += v;\\n          },\\n        ],\\n        [\\n          /,/,\\n          function () {\\n            const newNode = new LiteralNode(emptyMarker, 0);\\n            currentNode.children.push(newNode);\\n            newNode.parent = currentNode;\\n            currentNode = newNode;\\n          },\\n        ],\\n      ],\\n    ],\\n    [\\n      /\\\\]/,\\n      [\\n        [\\n          /\\\\]/,\\n          function (v) {\\n            if (!currentNode.parent) {\\n              throw new Error(\"redundant closing tag ]\");\\n            }\\n            currentNode = currentNode.parent;\\n            currentNode.val += v;\\n          },\\n        ],\\n        [\\n          /,/,\\n          function () {\\n            if (!currentNode.parent) {\\n              throw new Error(\"can find the parent list for ,\");\\n            }\\n            const newNode = new LiteralNode(emptyMarker, 0);\\n            currentNode.parent.children.push(newNode);\\n            newNode.parent = currentNode.parent;\\n            currentNode = newNode;\\n          },\\n        ],\\n      ],\\n    ],\\n    [\\n      /,/,\\n      [\\n        [\\n          /\\\\d|-/,\\n          function (v) {\\n            if (!currentNode.parent) {\\n              throw new Error(\"can find the parent list for ,\");\\n            }\\n            const newNode = new LiteralNode(v, 0);\\n            const parent = currentNode.parent;\\n            newNode.parent = parent;\\n            Object.assign(currentNode, newNode);\\n          },\\n        ],\\n        [\\n          /\\\\[/,\\n          function (v) {\\n            if (!currentNode.parent) {\\n              throw new Error(\"can find the parent list for ,\");\\n            }\\n            const newNode = new LiteralNode(v, 1);\\n            const parent = currentNode.parent;\\n            newNode.parent = parent;\\n            Object.assign(currentNode, newNode);\\n          },\\n        ],\\n        [\\n          /\\\\]/,\\n          function (v) {\\n            if (!currentNode.parent) {\\n              throw new Error(\"can find the parent list for ,\");\\n            }\\n            const parent = currentNode.parent;\\n            parent.val += v;\\n            currentNode = parent;\\n          },\\n        ],\\n        [\\n          /,/,\\n          function () {\\n            if (!currentNode.parent) {\\n              throw new Error(\"can find the parent list for ,\");\\n            }\\n            const newNode = new LiteralNode(emptyMarker, 0);\\n            const parent = currentNode.parent;\\n            newNode.parent = parent;\\n            parent.children.push(newNode);\\n            currentNode = newNode;\\n          },\\n        ],\\n      ],\\n    ],\\n  ] as Rule[];\\n  const openingTags = [\"[\", \",\", \"-\"];\\n  function matcher(r: string | RegExp, val: string) {\\n    if (typeof r === \"string\") {\\n      return r === val;\\n    }\\n    return (r as RegExp).test(val);\\n  }\\n  function parse() {\\n    const nextString = s[idx];\\n    if (!nextString) {\\n      if (currentNode !== root) {\\n        throw new Error(\"list not closing\");\\n      }\\n      return;\\n    }\\n    const currentValue =\\n      currentNode.val === emptyMarker\\n        ? \",\"\\n        : currentNode.val\\n        ? currentNode.val[currentNode.val.length - 1]\\n        : \"\";\\n\\n    for (let i = 0; i < rule.length + 1; i++) {\\n      const subR = rule[i];\\n      if (!subR) {\\n        throw new Error(\\n          `unable to match current string ${currentValue} with rules`\\n        );\\n      }\\n      const [r, rulesForNextValue] = subR;\\n      const matchedRule = rulesForNextValue.find(\\n        ([subRule, _]) =>\\n          matcher(r, currentValue) && matcher(subRule, nextString)\\n      );\\n      if (matchedRule) {\\n        const [_, action] = matchedRule;\\n        action(nextString);\\n        break;\\n      }\\n    }\\n\\n    idx += 1;\\n    parse();\\n  }\\n\\n  if (!s.length) {\\n    throw new Error(`unable to parse empty string`);\\n  }\\n  if (openingTags.includes(s[s.length - 1])) {\\n    throw new Error(`unable to parse redundant openings ${s[s.length - 1]}`);\\n  }\\n  parse();\\n  return constructNestedInteger(root);\\n}\\n\\nfunction constructNestedInteger(\\n  literalRoot: LiteralNode,\\n  nestedIntegerTree = new NestedInteger()\\n) {\\n  if (!literalRoot.isList) {\\n    nestedIntegerTree.setInteger(+literalRoot.val);\\n  } else {\\n    literalRoot.children.forEach((child) => {\\n      if (child.val === emptyMarker) {\\n        return;\\n      }\\n      if (!literalRoot.isList) {\\n        nestedIntegerTree.add(new NestedInteger(+literalRoot.val));\\n      } else {\\n        const seg = new NestedInteger();\\n        nestedIntegerTree.add(seg);\\n        return constructNestedInteger(child, seg);\\n      }\\n    });\\n  }\\n\\n  return nestedIntegerTree;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```TypeScript\\ntype Rule = [string | RegExp, Array<[string | RegExp, (v: string) => void]>];\\n\\nclass LiteralNode {\\n  val: string;\\n  type: \"number\" | \"list\";\\n  children: LiteralNode[];\\n  parent: LiteralNode;\\n  constructor(v = \"\", isList = 0) {\\n    this.val = v;\\n    this.type = isList ? \"list\" : \"number\";\\n    if (this.type === \"list\") {\\n      this.children = [];\\n    }\\n  }\\n\\n  get isList() {\\n    return this.type === \"list\";\\n  }\\n  get currentString() {\\n    return this.val ? \"\" : this.val[this.val.length - 1];\\n  }\\n}\\nconst emptyMarker = \"empty\";\\n\\nfunction deserialize(s: string): any {\\n  let currentNode: LiteralNode = new LiteralNode(\"\", 0);\\n  let root: LiteralNode;\\n  let idx = 0;\\n  const rule = [\\n    [\\n      \"\",\\n      [\\n        [\\n          /\\\\d|-/,\\n          function (v) {\\n            currentNode = new LiteralNode(v, 0);\\n            root = currentNode;\\n          },\\n        ],\\n        [\\n          /\\\\[/,\\n          function (v) {\\n            currentNode = new LiteralNode(v, 1);\\n            root = currentNode;\\n          },\\n        ],\\n      ],\\n    ],\\n    [\\n      \"-\",\\n      [\\n        [\\n          /\\\\d/,\\n          function (v) {\\n            currentNode.val += v;\\n          },\\n        ],\\n      ],\\n    ],\\n    [\\n      /\\\\d/,\\n      [\\n        [\\n          /\\\\d/,\\n          function (v) {\\n            return (currentNode.val += v);\\n          },\\n        ],\\n        [\\n          /,/,\\n          function (v) {\\n            if (!currentNode.parent || !currentNode.parent.isList) {\\n              throw new Error(`parent is not a list ${currentNode.val}${v}`);\\n            }\\n            const newNode = new LiteralNode(emptyMarker, 0);\\n            newNode.parent = currentNode.parent;\\n            currentNode.parent.children.push(newNode);\\n            currentNode = newNode;\\n          },\\n        ],\\n        [\\n          /\\\\]/,\\n          function (v) {\\n            if (!currentNode.parent || !currentNode.parent.isList) {\\n              throw new Error(`parent is not a list ${currentNode.val}${v}`);\\n            }\\n            currentNode = currentNode.parent;\\n            currentNode.val += v;\\n          },\\n        ],\\n      ],\\n    ],\\n    [\\n      /\\\\[/,\\n      [\\n        [\\n          /\\\\d|-/,\\n          function (v) {\\n            const newNode = new LiteralNode(v, 0);\\n            currentNode.children.push(newNode);\\n            newNode.parent = currentNode;\\n            currentNode = newNode;\\n          },\\n        ],\\n        [\\n          /\\\\[/,\\n          function (v) {\\n            const newNode = new LiteralNode(v, 1);\\n            currentNode.children.push(newNode);\\n            newNode.parent = currentNode;\\n            currentNode = newNode;\\n          },\\n        ],\\n        [\\n          /\\\\]/,\\n          function (v) {\\n            currentNode.val += v;\\n          },\\n        ],\\n        [\\n          /,/,\\n          function () {\\n            const newNode = new LiteralNode(emptyMarker, 0);\\n            currentNode.children.push(newNode);\\n            newNode.parent = currentNode;\\n            currentNode = newNode;\\n          },\\n        ],\\n      ],\\n    ],\\n    [\\n      /\\\\]/,\\n      [\\n        [\\n          /\\\\]/,\\n          function (v) {\\n            if (!currentNode.parent) {\\n              throw new Error(\"redundant closing tag ]\");\\n            }\\n            currentNode = currentNode.parent;\\n            currentNode.val += v;\\n          },\\n        ],\\n        [\\n          /,/,\\n          function () {\\n            if (!currentNode.parent) {\\n              throw new Error(\"can find the parent list for ,\");\\n            }\\n            const newNode = new LiteralNode(emptyMarker, 0);\\n            currentNode.parent.children.push(newNode);\\n            newNode.parent = currentNode.parent;\\n            currentNode = newNode;\\n          },\\n        ],\\n      ],\\n    ],\\n    [\\n      /,/,\\n      [\\n        [\\n          /\\\\d|-/,\\n          function (v) {\\n            if (!currentNode.parent) {\\n              throw new Error(\"can find the parent list for ,\");\\n            }\\n            const newNode = new LiteralNode(v, 0);\\n            const parent = currentNode.parent;\\n            newNode.parent = parent;\\n            Object.assign(currentNode, newNode);\\n          },\\n        ],\\n        [\\n          /\\\\[/,\\n          function (v) {\\n            if (!currentNode.parent) {\\n              throw new Error(\"can find the parent list for ,\");\\n            }\\n            const newNode = new LiteralNode(v, 1);\\n            const parent = currentNode.parent;\\n            newNode.parent = parent;\\n            Object.assign(currentNode, newNode);\\n          },\\n        ],\\n        [\\n          /\\\\]/,\\n          function (v) {\\n            if (!currentNode.parent) {\\n              throw new Error(\"can find the parent list for ,\");\\n            }\\n            const parent = currentNode.parent;\\n            parent.val += v;\\n            currentNode = parent;\\n          },\\n        ],\\n        [\\n          /,/,\\n          function () {\\n            if (!currentNode.parent) {\\n              throw new Error(\"can find the parent list for ,\");\\n            }\\n            const newNode = new LiteralNode(emptyMarker, 0);\\n            const parent = currentNode.parent;\\n            newNode.parent = parent;\\n            parent.children.push(newNode);\\n            currentNode = newNode;\\n          },\\n        ],\\n      ],\\n    ],\\n  ] as Rule[];\\n  const openingTags = [\"[\", \",\", \"-\"];\\n  function matcher(r: string | RegExp, val: string) {\\n    if (typeof r === \"string\") {\\n      return r === val;\\n    }\\n    return (r as RegExp).test(val);\\n  }\\n  function parse() {\\n    const nextString = s[idx];\\n    if (!nextString) {\\n      if (currentNode !== root) {\\n        throw new Error(\"list not closing\");\\n      }\\n      return;\\n    }\\n    const currentValue =\\n      currentNode.val === emptyMarker\\n        ? \",\"\\n        : currentNode.val\\n        ? currentNode.val[currentNode.val.length - 1]\\n        : \"\";\\n\\n    for (let i = 0; i < rule.length + 1; i++) {\\n      const subR = rule[i];\\n      if (!subR) {\\n        throw new Error(\\n          `unable to match current string ${currentValue} with rules`\\n        );\\n      }\\n      const [r, rulesForNextValue] = subR;\\n      const matchedRule = rulesForNextValue.find(\\n        ([subRule, _]) =>\\n          matcher(r, currentValue) && matcher(subRule, nextString)\\n      );\\n      if (matchedRule) {\\n        const [_, action] = matchedRule;\\n        action(nextString);\\n        break;\\n      }\\n    }\\n\\n    idx += 1;\\n    parse();\\n  }\\n\\n  if (!s.length) {\\n    throw new Error(`unable to parse empty string`);\\n  }\\n  if (openingTags.includes(s[s.length - 1])) {\\n    throw new Error(`unable to parse redundant openings ${s[s.length - 1]}`);\\n  }\\n  parse();\\n  return constructNestedInteger(root);\\n}\\n\\nfunction constructNestedInteger(\\n  literalRoot: LiteralNode,\\n  nestedIntegerTree = new NestedInteger()\\n) {\\n  if (!literalRoot.isList) {\\n    nestedIntegerTree.setInteger(+literalRoot.val);\\n  } else {\\n    literalRoot.children.forEach((child) => {\\n      if (child.val === emptyMarker) {\\n        return;\\n      }\\n      if (!literalRoot.isList) {\\n        nestedIntegerTree.add(new NestedInteger(+literalRoot.val));\\n      } else {\\n        const seg = new NestedInteger();\\n        nestedIntegerTree.add(seg);\\n        return constructNestedInteger(child, seg);\\n      }\\n    });\\n  }\\n\\n  return nestedIntegerTree;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670558,
                "title": "typescript-javascript-dfs-one-pass-solution",
                "content": "```Typescript\\nfunction deserialize(s: string): NestedInteger {\\n  if (!s) {\\n    return new NestedInteger(0);\\n  }\\n  if (s[0] !== \"[\") {\\n    return new NestedInteger(+s);\\n  }\\n\\n  return dfs({\\n    s,\\n    i: 0,\\n    stack: [],\\n    currentNestedInteger: new NestedInteger(),\\n  });\\n}\\n\\nconst integers = \"-0123456789\".split(\"\");\\n\\nfunction dfs({\\n  s,\\n  i,\\n  currentNestedInteger,\\n  stack,\\n}: {\\n  s: string;\\n  i: number;\\n  currentNestedInteger: NestedInteger;\\n  stack: NestedInteger[];\\n}) {\\n  if (s[i] === \"]\") {\\n    const tmp = stack.pop();\\n\\n    if (stack.length) {\\n      stack[stack.length - 1].add(tmp);\\n\\n      i += 1;\\n      currentNestedInteger = stack[stack.length - 1];\\n      return dfs({\\n        s,\\n        i,\\n        currentNestedInteger,\\n        stack,\\n      });\\n    }\\n\\n    return tmp;\\n  }\\n\\n  if (s[i] === \"[\") {\\n    currentNestedInteger = new NestedInteger();\\n    stack.push(currentNestedInteger);\\n    i += 1;\\n\\n    return dfs({\\n      s,\\n      i,\\n      currentNestedInteger,\\n      stack,\\n    });\\n  }\\n\\n  if (s[i] === \",\") {\\n    i += 1;\\n    return dfs({\\n      s,\\n      i,\\n      currentNestedInteger,\\n      stack,\\n    });\\n  }\\n\\n  const numberChars: string[] = [];\\n  while (integers.includes(s[i])) {\\n    numberChars.push(s[i]);\\n    i += 1;\\n  }\\n  currentNestedInteger.add(new NestedInteger(+numberChars.join(\"\")));\\n\\n  return dfs({\\n    s,\\n    i,\\n    currentNestedInteger,\\n    stack,\\n  });\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```Typescript\\nfunction deserialize(s: string): NestedInteger {\\n  if (!s) {\\n    return new NestedInteger(0);\\n  }\\n  if (s[0] !== \"[\") {\\n    return new NestedInteger(+s);\\n  }\\n\\n  return dfs({\\n    s,\\n    i: 0,\\n    stack: [],\\n    currentNestedInteger: new NestedInteger(),\\n  });\\n}\\n\\nconst integers = \"-0123456789\".split(\"\");\\n\\nfunction dfs({\\n  s,\\n  i,\\n  currentNestedInteger,\\n  stack,\\n}: {\\n  s: string;\\n  i: number;\\n  currentNestedInteger: NestedInteger;\\n  stack: NestedInteger[];\\n}) {\\n  if (s[i] === \"]\") {\\n    const tmp = stack.pop();\\n\\n    if (stack.length) {\\n      stack[stack.length - 1].add(tmp);\\n\\n      i += 1;\\n      currentNestedInteger = stack[stack.length - 1];\\n      return dfs({\\n        s,\\n        i,\\n        currentNestedInteger,\\n        stack,\\n      });\\n    }\\n\\n    return tmp;\\n  }\\n\\n  if (s[i] === \"[\") {\\n    currentNestedInteger = new NestedInteger();\\n    stack.push(currentNestedInteger);\\n    i += 1;\\n\\n    return dfs({\\n      s,\\n      i,\\n      currentNestedInteger,\\n      stack,\\n    });\\n  }\\n\\n  if (s[i] === \",\") {\\n    i += 1;\\n    return dfs({\\n      s,\\n      i,\\n      currentNestedInteger,\\n      stack,\\n    });\\n  }\\n\\n  const numberChars: string[] = [];\\n  while (integers.includes(s[i])) {\\n    numberChars.push(s[i]);\\n    i += 1;\\n  }\\n  currentNestedInteger.add(new NestedInteger(+numberChars.join(\"\")));\\n\\n  return dfs({\\n    s,\\n    i,\\n    currentNestedInteger,\\n    stack,\\n  });\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1658399,
                "title": "javascript-solution",
                "content": "```\\nvar deserialize = function(s) {\\n    if(!s) return null;\\n    \\n    if(!isNaN(s)) {\\n        let t = new NestedInteger();\\n        t.setInteger(+s);\\n        return t;\\n    }\\n    let num = 0, sign = 1;\\n    let stack = [];\\n    let curr = null;\\n    \\n    for(let i = 0; i < s.length; i += 1) {\\n        const chr = s[i];\\n        switch(chr) {\\n            case \\'[\\' : {\\n                stack.push(new NestedInteger());\\n                break;\\n            }\\n            case \\']\\':{\\n                curr = stack.pop();\\n                if(!isNaN(s[i -1])) {\\n                    const t = new NestedInteger();\\n                    t.setInteger(sign * num);\\n                    sign = 1;\\n                    num = 0;\\n                    curr.add(t);\\n                }\\n                if(stack[stack.length - 1] instanceof NestedInteger) {\\n                    stack[stack.length - 1].add(curr);\\n                }   \\n                break;\\n            }\\n            case \\',\\': {\\n                if(!isNaN(s[i - 1])) {\\n                    const t = new NestedInteger();\\n                    t.setInteger(sign * num);\\n                    stack[stack.length - 1].add(t);\\n                    sign = 1;\\n                    num = 0;   \\n                }\\n                break;\\n            }\\n            case \\'-\\': {\\n                sign = -1;\\n                break;\\n            }\\n            default: {\\n                num = num * 10 + (+chr);\\n                break;\\n            }\\n        }\\n    }\\n    return curr;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar deserialize = function(s) {\\n    if(!s) return null;\\n    \\n    if(!isNaN(s)) {\\n        let t = new NestedInteger();\\n        t.setInteger(+s);\\n        return t;\\n    }\\n    let num = 0, sign = 1;\\n    let stack = [];\\n    let curr = null;\\n    \\n    for(let i = 0; i < s.length; i += 1) {\\n        const chr = s[i];\\n        switch(chr) {\\n            case \\'[\\' : {\\n                stack.push(new NestedInteger());\\n                break;\\n            }\\n            case \\']\\':{\\n                curr = stack.pop();\\n                if(!isNaN(s[i -1])) {\\n                    const t = new NestedInteger();\\n                    t.setInteger(sign * num);\\n                    sign = 1;\\n                    num = 0;\\n                    curr.add(t);\\n                }\\n                if(stack[stack.length - 1] instanceof NestedInteger) {\\n                    stack[stack.length - 1].add(curr);\\n                }   \\n                break;\\n            }\\n            case \\',\\': {\\n                if(!isNaN(s[i - 1])) {\\n                    const t = new NestedInteger();\\n                    t.setInteger(sign * num);\\n                    stack[stack.length - 1].add(t);\\n                    sign = 1;\\n                    num = 0;   \\n                }\\n                break;\\n            }\\n            case \\'-\\': {\\n                sign = -1;\\n                break;\\n            }\\n            default: {\\n                num = num * 10 + (+chr);\\n                break;\\n            }\\n        }\\n    }\\n    return curr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1634025,
                "title": "java-simple-iterative-stack-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic NestedInteger deserialize(String s) {\\n\\t\\t\\tif(s.charAt(0)!=\\'[\\')    return new NestedInteger(Integer.parseInt(s));\\n\\t\\t\\tStack<NestedInteger> st=new Stack<>();\\n\\t\\t\\tint i=0;\\n\\t\\t\\twhile(i<s.length()){\\n\\t\\t\\t\\tif(s.charAt(i)==\\'[\\')        st.add(null);\\n\\t\\t\\t\\telse if(s.charAt(i)==\\',\\');\\n\\t\\t\\t\\telse if(s.charAt(i)==\\']\\')   solve(st);\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint x=0,m=1;\\n\\t\\t\\t\\t\\tif(s.charAt(i)==\\'-\\'){\\n\\t\\t\\t\\t\\t\\tm=-1;i++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twhile(i<s.length() && Character.isDigit(s.charAt(i))) x=x*10+s.charAt(i++)-\\'0\\';\\n\\t\\t\\t\\t\\tst.add(new NestedInteger(x*m));i--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\treturn st.pop();\\n\\t\\t}\\n\\t\\tprivate void solve(Stack<NestedInteger>  st){\\n\\t\\t\\tNestedInteger ni=new NestedInteger();\\n\\t\\t\\tStack<NestedInteger> rev=new Stack<>();\\n\\t\\t\\twhile(!st.isEmpty()){\\n\\t\\t\\t\\tNestedInteger x=st.pop();\\n\\t\\t\\t\\tif(x==null)   break;\\n\\t\\t\\t\\trev.add(x);\\n\\t\\t\\t}\\n\\t\\t\\twhile(!rev.isEmpty())   ni.add(rev.pop());\\n\\t\\t\\tst.add(ni);\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\n\\t\\tpublic NestedInteger deserialize(String s) {\\n\\t\\t\\tif(s.charAt(0)!=\\'[\\')    return new NestedInteger(Integer.parseInt(s));\\n\\t\\t\\tStack<NestedInteger> st=new Stack<>();\\n\\t\\t\\tint i=0;\\n\\t\\t\\twhile(i<s.length()){\\n\\t\\t\\t\\tif(s.charAt(i)==\\'[\\')        st.add(null);\\n\\t\\t\\t\\telse if(s.charAt(i)==\\',\\');\\n\\t\\t\\t\\telse if(s.charAt(i)==\\']\\')   solve(st);\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint x=0,m=1;\\n\\t\\t\\t\\t\\tif(s.charAt(i)==\\'-\\'){\\n\\t\\t\\t\\t\\t\\tm=-1;i++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1632356,
                "title": "java-simple-recursive-4ms-solution",
                "content": "\\tclass Solution {\\n\\t\\tint i=0;\\n\\t\\tpublic NestedInteger deserialize(String s) {\\n\\t\\t\\treturn get_ans(s);\\n\\t\\t}\\n\\t\\tprivate NestedInteger get_ans(String s){\\n\\t\\t\\tif(s.charAt(i)==\\'[\\'){\\n\\t\\t\\t\\tNestedInteger ni=new NestedInteger();\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\twhile(i<s.length() && s.charAt(i)!=\\']\\'){\\n\\t\\t\\t\\t\\tni.add(get_ans(s));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\treturn ni;\\n\\t\\t\\t}\\n\\t\\t\\telse if(s.charAt(i)==\\',\\'){\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\treturn get_ans(s);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tint x=0,m=1;\\n\\t\\t\\t\\tif(s.charAt(i)==\\'-\\'){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tm=-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twhile(i<s.length() && Character.isDigit(s.charAt(i))){\\n\\t\\t\\t\\t\\tx=x*10+s.charAt(i++)-\\'0\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tx*=m;\\n\\t\\t\\t\\treturn new NestedInteger(x);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tint i=0;\\n\\t\\tpublic NestedInteger deserialize(String s) {\\n\\t\\t\\treturn get_ans(s);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1548468,
                "title": "python-faster-than-99-recursion-and-splitting",
                "content": "The key to solving this problem efficiently is to split the array string into the form:\\n[x1, x2, x3, inner_array_string1, x4....]\\n\\nwhere x1, x2, x3, ...... are integers and inner_array_string is an inner array simply left untouched as a string. \\n\\nNow, deserialization works as such:\\n\\n[NestedInteger(x1), NestedInteger(x2), NestedInteger(x3), deserialize(inner_array_string1), NestedInteger(x4), ....]\\n \\nCode for this approach is as follows:\\n\\n```\\nclass Solution:\\n    def arrayStringToNumAndSubArraySplit(self, s):\\n        split = []\\n        splitPointer = 1\\n        \\n        while splitPointer < len(s) - 1:\\n            if s[splitPointer] == \"[\":\\n                innerArrayString = \"\"\\n                openBrackets = 1\\n                while openBrackets > 0:\\n                    innerArrayString += s[splitPointer]\\n                    splitPointer += 1\\n                    if s[splitPointer] == \"[\":\\n                        openBrackets += 1\\n                    elif s[splitPointer] == \"]\":\\n                        openBrackets -= 1\\n                \\n                innerArrayString += \"]\"\\n                split.append(innerArrayString)\\n                splitPointer += 1\\n                \\n            else:\\n                numberString = \"\"\\n                while s[splitPointer] != \",\" and splitPointer < len(s) - 1:\\n                    numberString += s[splitPointer]\\n                    splitPointer += 1\\n                \\n                if numberString != \"\":\\n                    split.append(int(numberString)) \\n                splitPointer += 1\\n            \\n        return split\\n\\n    def deserialize(self, s: str) -> NestedInteger:\\n        try:\\n            num = int(s)\\n            return NestedInteger(num)\\n        except:\\n            pass\\n        \\n        array = NestedInteger()\\n        \\n        #split the string into integers and lists\\n        split = self.arrayStringToNumAndSubArraySplit(s)\\n        for i in range(len(split)):\\n            element = split[i]\\n            if type(element) == \\'str\\':\\n                deserialized = self.deserialize(element)\\n                array.add(deserialized)\\n            else:\\n                integer = NestedInteger(element)\\n                array.add(integer)\\n                \\n        return array           \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayStringToNumAndSubArraySplit(self, s):\\n        split = []\\n        splitPointer = 1\\n        \\n        while splitPointer < len(s) - 1:\\n            if s[splitPointer] == \"[\":\\n                innerArrayString = \"\"\\n                openBrackets = 1\\n                while openBrackets > 0:\\n                    innerArrayString += s[splitPointer]\\n                    splitPointer += 1\\n                    if s[splitPointer] == \"[\":\\n                        openBrackets += 1\\n                    elif s[splitPointer] == \"]\":\\n                        openBrackets -= 1\\n                \\n                innerArrayString += \"]\"\\n                split.append(innerArrayString)\\n                splitPointer += 1\\n                \\n            else:\\n                numberString = \"\"\\n                while s[splitPointer] != \",\" and splitPointer < len(s) - 1:\\n                    numberString += s[splitPointer]\\n                    splitPointer += 1\\n                \\n                if numberString != \"\":\\n                    split.append(int(numberString)) \\n                splitPointer += 1\\n            \\n        return split\\n\\n    def deserialize(self, s: str) -> NestedInteger:\\n        try:\\n            num = int(s)\\n            return NestedInteger(num)\\n        except:\\n            pass\\n        \\n        array = NestedInteger()\\n        \\n        #split the string into integers and lists\\n        split = self.arrayStringToNumAndSubArraySplit(s)\\n        for i in range(len(split)):\\n            element = split[i]\\n            if type(element) == \\'str\\':\\n                deserialized = self.deserialize(element)\\n                array.add(deserialized)\\n            else:\\n                integer = NestedInteger(element)\\n                array.add(integer)\\n                \\n        return array           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539848,
                "title": "javascript-2-solutions",
                "content": "**Recursive, using JSON.parse()**\\n```\\nvar deserialize = function(s) {\\n    s = JSON.parse(s);\\n\\n    const find = (s) => {\\n        let ans = new NestedInteger();\\n\\n        for (let i = 0; i < s.length; i++) {\\n            ans.add(Array.isArray(s[i]) ? find(s[i]) : new NestedInteger(s[i]));\\n        }\\n        return ans;\\n    };\\n       \\n    return Array.isArray(s) ? find(s) : new NestedInteger(s);\\n};\\n```\\n\\n**Stack, without using JSON.parse()**\\n```\\nvar deserialize = function(s) {\\n    let stack = [];\\n\\n    for (let i = s.length - 1; i >= 0; i--) {\\n        if (s[i] === \"]\") {\\n            stack.push(s[i]);\\n        } else if (s[i] === \"[\") {\\n            let cur = new NestedInteger();\\n\\n            while (stack.length && stack[stack.length - 1] !== \"]\") {\\n                cur.add(stack.pop());\\n            }\\n            stack.pop();\\n            stack.push(cur);\\n        } else if (s[i] >= \"0\" && s[i] <= \"9\") {\\n            let cur = s[i];\\n\\n            while ((s[i - 1] >= \"0\" && s[i - 1] <= \"9\") || s[i - 1] === \"-\")\\n                cur = s[--i] + cur;\\n\\n            stack.push(new NestedInteger(cur));\\n        }\\n\\n    }\\n    \\n    return stack[0];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar deserialize = function(s) {\\n    s = JSON.parse(s);\\n\\n    const find = (s) => {\\n        let ans = new NestedInteger();\\n\\n        for (let i = 0; i < s.length; i++) {\\n            ans.add(Array.isArray(s[i]) ? find(s[i]) : new NestedInteger(s[i]));\\n        }\\n        return ans;\\n    };\\n       \\n    return Array.isArray(s) ? find(s) : new NestedInteger(s);\\n};\\n```\n```\\nvar deserialize = function(s) {\\n    let stack = [];\\n\\n    for (let i = s.length - 1; i >= 0; i--) {\\n        if (s[i] === \"]\") {\\n            stack.push(s[i]);\\n        } else if (s[i] === \"[\") {\\n            let cur = new NestedInteger();\\n\\n            while (stack.length && stack[stack.length - 1] !== \"]\") {\\n                cur.add(stack.pop());\\n            }\\n            stack.pop();\\n            stack.push(cur);\\n        } else if (s[i] >= \"0\" && s[i] <= \"9\") {\\n            let cur = s[i];\\n\\n            while ((s[i - 1] >= \"0\" && s[i - 1] <= \"9\") || s[i - 1] === \"-\")\\n                cur = s[--i] + cur;\\n\\n            stack.push(new NestedInteger(cur));\\n        }\\n\\n    }\\n    \\n    return stack[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1474054,
                "title": "easy-c-solution-using-stack",
                "content": "```c++\\nclass Solution {\\npublic:\\n    typedef NestedInteger ni;\\n    NestedInteger deserialize(string s) {\\n        //stack<char>s;\\n        if(s[0]!=\\'[\\'){\\n            ni a(stoi(s));\\n            return a;\\n        }\\n        stack<ni>st;\\n        string temp = \"\";\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'[\\'){\\n                ni a;\\n                st.push(a);\\n                temp = \"\";\\n \\n            }\\n            else if(s[i]==\\',\\'){\\n                if(temp!=\"\"){\\n                    ni &par = st.top();\\n                    par.add(stoi(temp));\\n                }\\n                temp = \"\";\\n            }\\n            else if(s[i]==\\']\\'){\\n                ni par = st.top();\\n                st.pop();\\n                if(temp!=\"\"){\\n                    par.add(stoi(temp));\\n                    temp = \"\";\\n                }\\n                if(st.size()==0){\\n                    st.push(par);\\n                    break;\\n                }\\n                ni &grandpar = st.top();\\n                grandpar.add(par);\\n            }\\n            else{\\n                temp+=s[i];\\n            }\\n        }\\n        return st.top();\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    typedef NestedInteger ni;\\n    NestedInteger deserialize(string s) {\\n        //stack<char>s;\\n        if(s[0]!=\\'[\\'){\\n            ni a(stoi(s));\\n            return a;\\n        }\\n        stack<ni>st;\\n        string temp = \"\";\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'[\\'){\\n                ni a;\\n                st.push(a);\\n                temp = \"\";\\n \\n            }\\n            else if(s[i]==\\',\\'){\\n                if(temp!=\"\"){\\n                    ni &par = st.top();\\n                    par.add(stoi(temp));\\n                }\\n                temp = \"\";\\n            }\\n            else if(s[i]==\\']\\'){\\n                ni par = st.top();\\n                st.pop();\\n                if(temp!=\"\"){\\n                    par.add(stoi(temp));\\n                    temp = \"\";\\n                }\\n                if(st.size()==0){\\n                    st.push(par);\\n                    break;\\n                }\\n                ni &grandpar = st.top();\\n                grandpar.add(par);\\n            }\\n            else{\\n                temp+=s[i];\\n            }\\n        }\\n        return st.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461325,
                "title": "java-stack-simple-iterative-implementation-o-n",
                "content": "```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        if(s.charAt(0) != \\'[\\') return new NestedInteger(Integer.valueOf(s));\\n        \\n        int n = s.length();\\n\\t\\t\\n        Stack<NestedInteger> stack = new Stack();\\n        NestedInteger parent = new NestedInteger();\\n        stack.add(parent);\\n\\t\\t\\n        StringBuilder sb = new StringBuilder();\\n        \\n\\t\\tfor(int i = 1; i < n; i++) {\\n            char c = s.charAt(i);\\n            if(c != \\'[\\' && c != \\']\\' && c != \\',\\') {\\n                sb.append(c);\\n            } else {\\n                if(c == \\'[\\') {\\n                    NestedInteger sub = new NestedInteger();\\n                    stack.peek().add(sub);\\n                    stack.add(sub);\\n                } else if(c == \\']\\') {\\n                    addNested(sb, stack.peek());\\n                    stack.pop();\\n                } else if(c == \\',\\') {\\n                    addNested(sb, stack.peek());\\n                }\\n                \\n                sb = new StringBuilder();\\n            }\\n        }\\n        \\n        return parent;\\n    }\\n    \\n    public void addNested(StringBuilder sb, NestedInteger n) {\\n        if(sb.length() == 0) return;\\n        int val = Integer.parseInt(sb.toString());\\n        n.add(new NestedInteger(val));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public NestedInteger deserialize(String s) {\\n        if(s.charAt(0) != \\'[\\') return new NestedInteger(Integer.valueOf(s));\\n        \\n        int n = s.length();\\n\\t\\t\\n        Stack<NestedInteger> stack = new Stack();\\n        NestedInteger parent = new NestedInteger();\\n        stack.add(parent);\\n\\t\\t\\n        StringBuilder sb = new StringBuilder();\\n        \\n\\t\\tfor(int i = 1; i < n; i++) {\\n            char c = s.charAt(i);\\n            if(c != \\'[\\' && c != \\']\\' && c != \\',\\') {\\n                sb.append(c);\\n            } else {\\n                if(c == \\'[\\') {\\n                    NestedInteger sub = new NestedInteger();\\n                    stack.peek().add(sub);\\n                    stack.add(sub);\\n                } else if(c == \\']\\') {\\n                    addNested(sb, stack.peek());\\n                    stack.pop();\\n                } else if(c == \\',\\') {\\n                    addNested(sb, stack.peek());\\n                }\\n                \\n                sb = new StringBuilder();\\n            }\\n        }\\n        \\n        return parent;\\n    }\\n    \\n    public void addNested(StringBuilder sb, NestedInteger n) {\\n        if(sb.length() == 0) return;\\n        int val = Integer.parseInt(sb.toString());\\n        n.add(new NestedInteger(val));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435791,
                "title": "recursion-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string& s, int start, int& end)\\n    {\\n        int i;\\n        char c=s[start];\\n        if(c==\\'-\\'||(c>=\\'0\\'&&c<=\\'9\\'))\\n        {\\n            for(i=start+1; i<s.length(); i++)\\n            {\\n                c=s[i];\\n                if(c<\\'0\\'||c>\\'9\\')\\n                    break;\\n            }\\n            string s_int=s.substr(start, i-start);\\n            end=i;\\n            return NestedInteger(stoi(s_int));\\n        }\\n        if(c==\\'[\\')\\n        {\\n            if(s[start+1]==\\']\\')\\n            {\\n                end=start+2;\\n                return NestedInteger();\\n            }\\n            NestedInteger me;\\n            while(end<s.length())\\n            {\\n                start++;\\n                NestedInteger sub=deserialize(s, start, end);\\n                me.add(sub);\\n                if(s[end]!=\\',\\') break;\\n                start=end;\\n            }\\n            if(s[end]!=\\']\\') printf(\"error 1\\\\n\");\\n            end++;\\n            return me;\\n        }    \\n        printf(\"error 2\\\\n\");\\n        return NestedInteger();\\n    }\\n    NestedInteger deserialize(string s) {\\n        int end=0;\\n        return deserialize(s, 0, end);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    NestedInteger deserialize(string& s, int start, int& end)\\n    {\\n        int i;\\n        char c=s[start];\\n        if(c==\\'-\\'||(c>=\\'0\\'&&c<=\\'9\\'))\\n        {\\n            for(i=start+1; i<s.length(); i++)\\n            {\\n                c=s[i];\\n                if(c<\\'0\\'||c>\\'9\\')\\n                    break;\\n            }\\n            string s_int=s.substr(start, i-start);\\n            end=i;\\n            return NestedInteger(stoi(s_int));\\n        }\\n        if(c==\\'[\\')\\n        {\\n            if(s[start+1]==\\']\\')\\n            {\\n                end=start+2;\\n                return NestedInteger();\\n            }\\n            NestedInteger me;\\n            while(end<s.length())\\n            {\\n                start++;\\n                NestedInteger sub=deserialize(s, start, end);\\n                me.add(sub);\\n                if(s[end]!=\\',\\') break;\\n                start=end;\\n            }\\n            if(s[end]!=\\']\\') printf(\"error 1\\\\n\");\\n            end++;\\n            return me;\\n        }    \\n        printf(\"error 2\\\\n\");\\n        return NestedInteger();\\n    }\\n    NestedInteger deserialize(string s) {\\n        int end=0;\\n        return deserialize(s, 0, end);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411849,
                "title": "concise-c-solution-recursion-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int i=0;\\n    \\n    NestedInteger deserialize(string &s) {\\n        if(s[i]==\\'[\\') {\\n            NestedInteger newN = NestedInteger();\\n            i++;\\n            while(i<s.size() && s[i]!=\\']\\') {\\n                NestedInteger temp = deserialize(s);\\n                newN.add(temp);\\n                if(s[i]==\\',\\') i++;\\n            }\\n            if(s[i]==\\']\\') i++;\\n            return newN;\\n        }\\n        else {\\n            int flag=1;\\n            if(s[i]==\\'-\\') {\\n                flag = -1;\\n                i++;\\n            }\\n            int temp=0;\\n            while(i<s.size() && s[i]!=\\',\\' && s[i]!=\\']\\') {\\n                temp = temp*10 + s[i] - \\'0\\';\\n                i++;\\n            }\\n            NestedInteger newN = NestedInteger(temp*flag);\\n            return newN;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int i=0;\\n    \\n    NestedInteger deserialize(string &s) {\\n        if(s[i]==\\'[\\') {\\n            NestedInteger newN = NestedInteger();\\n            i++;\\n            while(i<s.size() && s[i]!=\\']\\') {\\n                NestedInteger temp = deserialize(s);\\n                newN.add(temp);\\n                if(s[i]==\\',\\') i++;\\n            }\\n            if(s[i]==\\']\\') i++;\\n            return newN;\\n        }\\n        else {\\n            int flag=1;\\n            if(s[i]==\\'-\\') {\\n                flag = -1;\\n                i++;\\n            }\\n            int temp=0;\\n            while(i<s.size() && s[i]!=\\',\\' && s[i]!=\\']\\') {\\n                temp = temp*10 + s[i] - \\'0\\';\\n                i++;\\n            }\\n            NestedInteger newN = NestedInteger(temp*flag);\\n            return newN;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564715,
                "content": [
                    {
                        "username": "zchen39",
                        "content": "No offense but this problem seriously needs some more explanation and grammar check. I want to add a few clarification as follows so it saves you some time:\\n\\n1. the add() method adds a NestedInteger object to the caller. e.g.:\\nouter = NestedInteger() # []\\nnested = NestedInteger(5) \\nouter2 = nested\\nouter.add(nested) # outer is now [5]\\nouter2.add(outer) # outer2 is now [5, [5]]\\n\\n\"Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\" cannot be more vague.\\n\\n2. '-' means negative. It's not a delimiter.\\n\\n3. For test cases like \"324\" you need to return something like NestedInteger(324) not \"[324]\". \\n\\n4. A list cannot have multiple consecutive integers. e.g. \"321, 231\" is invalid. I guess it's for difficulty purposes."
                    },
                    {
                        "username": "hai8",
                        "content": "This is quite difficult."
                    },
                    {
                        "username": "ahcox",
                        "content": "Before I start, why is there such a bad upvote to downvote ratio? Is it broken?"
                    },
                    {
                        "username": "wang2019",
                        "content": "Why contains \\'-\\' ?"
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question description states the following:\\nString contains only digits 0-9 , [, ,,(comma),-,].\\nThere are no test cases with hyphen so just ignore this character."
                    },
                    {
                        "username": "justdoit2000",
                        "content": "please add the following testing cases \"[,[]]\" and \"[,]\". I believe there are problems in all the solutions passed and posted here."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem is a perfect example of how you should NOT design interfaces of your classes."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "In python\n\nvar1=NestedInteger(99) // var1 is [99]\nvar2=NestedInteger(89) // var2 is [89]\nvar2.add(var1)  # I expected var2 to become [89,[99]]\nprint(var2)   #but this printed [,[99]]\n\nWhy is this happening description says Add will just add given NestedInteger to it's caller. What am i missing ?"
                    },
                    {
                        "username": "mechalas",
                        "content": "Once you initialize the object as an integer, you can\\'t convert it to a list. You have to initialize it as a list, then populate the members."
                    }
                ]
            },
            {
                "id": 1567705,
                "content": [
                    {
                        "username": "zchen39",
                        "content": "No offense but this problem seriously needs some more explanation and grammar check. I want to add a few clarification as follows so it saves you some time:\\n\\n1. the add() method adds a NestedInteger object to the caller. e.g.:\\nouter = NestedInteger() # []\\nnested = NestedInteger(5) \\nouter2 = nested\\nouter.add(nested) # outer is now [5]\\nouter2.add(outer) # outer2 is now [5, [5]]\\n\\n\"Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\" cannot be more vague.\\n\\n2. '-' means negative. It's not a delimiter.\\n\\n3. For test cases like \"324\" you need to return something like NestedInteger(324) not \"[324]\". \\n\\n4. A list cannot have multiple consecutive integers. e.g. \"321, 231\" is invalid. I guess it's for difficulty purposes."
                    },
                    {
                        "username": "hai8",
                        "content": "This is quite difficult."
                    },
                    {
                        "username": "ahcox",
                        "content": "Before I start, why is there such a bad upvote to downvote ratio? Is it broken?"
                    },
                    {
                        "username": "wang2019",
                        "content": "Why contains \\'-\\' ?"
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question description states the following:\\nString contains only digits 0-9 , [, ,,(comma),-,].\\nThere are no test cases with hyphen so just ignore this character."
                    },
                    {
                        "username": "justdoit2000",
                        "content": "please add the following testing cases \"[,[]]\" and \"[,]\". I believe there are problems in all the solutions passed and posted here."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem is a perfect example of how you should NOT design interfaces of your classes."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "In python\n\nvar1=NestedInteger(99) // var1 is [99]\nvar2=NestedInteger(89) // var2 is [89]\nvar2.add(var1)  # I expected var2 to become [89,[99]]\nprint(var2)   #but this printed [,[99]]\n\nWhy is this happening description says Add will just add given NestedInteger to it's caller. What am i missing ?"
                    },
                    {
                        "username": "mechalas",
                        "content": "Once you initialize the object as an integer, you can\\'t convert it to a list. You have to initialize it as a list, then populate the members."
                    }
                ]
            },
            {
                "id": 1569781,
                "content": [
                    {
                        "username": "zchen39",
                        "content": "No offense but this problem seriously needs some more explanation and grammar check. I want to add a few clarification as follows so it saves you some time:\\n\\n1. the add() method adds a NestedInteger object to the caller. e.g.:\\nouter = NestedInteger() # []\\nnested = NestedInteger(5) \\nouter2 = nested\\nouter.add(nested) # outer is now [5]\\nouter2.add(outer) # outer2 is now [5, [5]]\\n\\n\"Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\" cannot be more vague.\\n\\n2. '-' means negative. It's not a delimiter.\\n\\n3. For test cases like \"324\" you need to return something like NestedInteger(324) not \"[324]\". \\n\\n4. A list cannot have multiple consecutive integers. e.g. \"321, 231\" is invalid. I guess it's for difficulty purposes."
                    },
                    {
                        "username": "hai8",
                        "content": "This is quite difficult."
                    },
                    {
                        "username": "ahcox",
                        "content": "Before I start, why is there such a bad upvote to downvote ratio? Is it broken?"
                    },
                    {
                        "username": "wang2019",
                        "content": "Why contains \\'-\\' ?"
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question description states the following:\\nString contains only digits 0-9 , [, ,,(comma),-,].\\nThere are no test cases with hyphen so just ignore this character."
                    },
                    {
                        "username": "justdoit2000",
                        "content": "please add the following testing cases \"[,[]]\" and \"[,]\". I believe there are problems in all the solutions passed and posted here."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem is a perfect example of how you should NOT design interfaces of your classes."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "In python\n\nvar1=NestedInteger(99) // var1 is [99]\nvar2=NestedInteger(89) // var2 is [89]\nvar2.add(var1)  # I expected var2 to become [89,[99]]\nprint(var2)   #but this printed [,[99]]\n\nWhy is this happening description says Add will just add given NestedInteger to it's caller. What am i missing ?"
                    },
                    {
                        "username": "mechalas",
                        "content": "Once you initialize the object as an integer, you can\\'t convert it to a list. You have to initialize it as a list, then populate the members."
                    }
                ]
            },
            {
                "id": 1573840,
                "content": [
                    {
                        "username": "zchen39",
                        "content": "No offense but this problem seriously needs some more explanation and grammar check. I want to add a few clarification as follows so it saves you some time:\\n\\n1. the add() method adds a NestedInteger object to the caller. e.g.:\\nouter = NestedInteger() # []\\nnested = NestedInteger(5) \\nouter2 = nested\\nouter.add(nested) # outer is now [5]\\nouter2.add(outer) # outer2 is now [5, [5]]\\n\\n\"Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\" cannot be more vague.\\n\\n2. '-' means negative. It's not a delimiter.\\n\\n3. For test cases like \"324\" you need to return something like NestedInteger(324) not \"[324]\". \\n\\n4. A list cannot have multiple consecutive integers. e.g. \"321, 231\" is invalid. I guess it's for difficulty purposes."
                    },
                    {
                        "username": "hai8",
                        "content": "This is quite difficult."
                    },
                    {
                        "username": "ahcox",
                        "content": "Before I start, why is there such a bad upvote to downvote ratio? Is it broken?"
                    },
                    {
                        "username": "wang2019",
                        "content": "Why contains \\'-\\' ?"
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question description states the following:\\nString contains only digits 0-9 , [, ,,(comma),-,].\\nThere are no test cases with hyphen so just ignore this character."
                    },
                    {
                        "username": "justdoit2000",
                        "content": "please add the following testing cases \"[,[]]\" and \"[,]\". I believe there are problems in all the solutions passed and posted here."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem is a perfect example of how you should NOT design interfaces of your classes."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "In python\n\nvar1=NestedInteger(99) // var1 is [99]\nvar2=NestedInteger(89) // var2 is [89]\nvar2.add(var1)  # I expected var2 to become [89,[99]]\nprint(var2)   #but this printed [,[99]]\n\nWhy is this happening description says Add will just add given NestedInteger to it's caller. What am i missing ?"
                    },
                    {
                        "username": "mechalas",
                        "content": "Once you initialize the object as an integer, you can\\'t convert it to a list. You have to initialize it as a list, then populate the members."
                    }
                ]
            },
            {
                "id": 1571660,
                "content": [
                    {
                        "username": "zchen39",
                        "content": "No offense but this problem seriously needs some more explanation and grammar check. I want to add a few clarification as follows so it saves you some time:\\n\\n1. the add() method adds a NestedInteger object to the caller. e.g.:\\nouter = NestedInteger() # []\\nnested = NestedInteger(5) \\nouter2 = nested\\nouter.add(nested) # outer is now [5]\\nouter2.add(outer) # outer2 is now [5, [5]]\\n\\n\"Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\" cannot be more vague.\\n\\n2. '-' means negative. It's not a delimiter.\\n\\n3. For test cases like \"324\" you need to return something like NestedInteger(324) not \"[324]\". \\n\\n4. A list cannot have multiple consecutive integers. e.g. \"321, 231\" is invalid. I guess it's for difficulty purposes."
                    },
                    {
                        "username": "hai8",
                        "content": "This is quite difficult."
                    },
                    {
                        "username": "ahcox",
                        "content": "Before I start, why is there such a bad upvote to downvote ratio? Is it broken?"
                    },
                    {
                        "username": "wang2019",
                        "content": "Why contains \\'-\\' ?"
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question description states the following:\\nString contains only digits 0-9 , [, ,,(comma),-,].\\nThere are no test cases with hyphen so just ignore this character."
                    },
                    {
                        "username": "justdoit2000",
                        "content": "please add the following testing cases \"[,[]]\" and \"[,]\". I believe there are problems in all the solutions passed and posted here."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem is a perfect example of how you should NOT design interfaces of your classes."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "In python\n\nvar1=NestedInteger(99) // var1 is [99]\nvar2=NestedInteger(89) // var2 is [89]\nvar2.add(var1)  # I expected var2 to become [89,[99]]\nprint(var2)   #but this printed [,[99]]\n\nWhy is this happening description says Add will just add given NestedInteger to it's caller. What am i missing ?"
                    },
                    {
                        "username": "mechalas",
                        "content": "Once you initialize the object as an integer, you can\\'t convert it to a list. You have to initialize it as a list, then populate the members."
                    }
                ]
            },
            {
                "id": 1571661,
                "content": [
                    {
                        "username": "zchen39",
                        "content": "No offense but this problem seriously needs some more explanation and grammar check. I want to add a few clarification as follows so it saves you some time:\\n\\n1. the add() method adds a NestedInteger object to the caller. e.g.:\\nouter = NestedInteger() # []\\nnested = NestedInteger(5) \\nouter2 = nested\\nouter.add(nested) # outer is now [5]\\nouter2.add(outer) # outer2 is now [5, [5]]\\n\\n\"Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\" cannot be more vague.\\n\\n2. '-' means negative. It's not a delimiter.\\n\\n3. For test cases like \"324\" you need to return something like NestedInteger(324) not \"[324]\". \\n\\n4. A list cannot have multiple consecutive integers. e.g. \"321, 231\" is invalid. I guess it's for difficulty purposes."
                    },
                    {
                        "username": "hai8",
                        "content": "This is quite difficult."
                    },
                    {
                        "username": "ahcox",
                        "content": "Before I start, why is there such a bad upvote to downvote ratio? Is it broken?"
                    },
                    {
                        "username": "wang2019",
                        "content": "Why contains \\'-\\' ?"
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question description states the following:\\nString contains only digits 0-9 , [, ,,(comma),-,].\\nThere are no test cases with hyphen so just ignore this character."
                    },
                    {
                        "username": "justdoit2000",
                        "content": "please add the following testing cases \"[,[]]\" and \"[,]\". I believe there are problems in all the solutions passed and posted here."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem is a perfect example of how you should NOT design interfaces of your classes."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "In python\n\nvar1=NestedInteger(99) // var1 is [99]\nvar2=NestedInteger(89) // var2 is [89]\nvar2.add(var1)  # I expected var2 to become [89,[99]]\nprint(var2)   #but this printed [,[99]]\n\nWhy is this happening description says Add will just add given NestedInteger to it's caller. What am i missing ?"
                    },
                    {
                        "username": "mechalas",
                        "content": "Once you initialize the object as an integer, you can\\'t convert it to a list. You have to initialize it as a list, then populate the members."
                    }
                ]
            },
            {
                "id": 2076874,
                "content": [
                    {
                        "username": "zchen39",
                        "content": "No offense but this problem seriously needs some more explanation and grammar check. I want to add a few clarification as follows so it saves you some time:\\n\\n1. the add() method adds a NestedInteger object to the caller. e.g.:\\nouter = NestedInteger() # []\\nnested = NestedInteger(5) \\nouter2 = nested\\nouter.add(nested) # outer is now [5]\\nouter2.add(outer) # outer2 is now [5, [5]]\\n\\n\"Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\" cannot be more vague.\\n\\n2. '-' means negative. It's not a delimiter.\\n\\n3. For test cases like \"324\" you need to return something like NestedInteger(324) not \"[324]\". \\n\\n4. A list cannot have multiple consecutive integers. e.g. \"321, 231\" is invalid. I guess it's for difficulty purposes."
                    },
                    {
                        "username": "hai8",
                        "content": "This is quite difficult."
                    },
                    {
                        "username": "ahcox",
                        "content": "Before I start, why is there such a bad upvote to downvote ratio? Is it broken?"
                    },
                    {
                        "username": "wang2019",
                        "content": "Why contains \\'-\\' ?"
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question description states the following:\\nString contains only digits 0-9 , [, ,,(comma),-,].\\nThere are no test cases with hyphen so just ignore this character."
                    },
                    {
                        "username": "justdoit2000",
                        "content": "please add the following testing cases \"[,[]]\" and \"[,]\". I believe there are problems in all the solutions passed and posted here."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem is a perfect example of how you should NOT design interfaces of your classes."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "In python\n\nvar1=NestedInteger(99) // var1 is [99]\nvar2=NestedInteger(89) // var2 is [89]\nvar2.add(var1)  # I expected var2 to become [89,[99]]\nprint(var2)   #but this printed [,[99]]\n\nWhy is this happening description says Add will just add given NestedInteger to it's caller. What am i missing ?"
                    },
                    {
                        "username": "mechalas",
                        "content": "Once you initialize the object as an integer, you can\\'t convert it to a list. You have to initialize it as a list, then populate the members."
                    }
                ]
            },
            {
                "id": 1721415,
                "content": [
                    {
                        "username": "zchen39",
                        "content": "No offense but this problem seriously needs some more explanation and grammar check. I want to add a few clarification as follows so it saves you some time:\\n\\n1. the add() method adds a NestedInteger object to the caller. e.g.:\\nouter = NestedInteger() # []\\nnested = NestedInteger(5) \\nouter2 = nested\\nouter.add(nested) # outer is now [5]\\nouter2.add(outer) # outer2 is now [5, [5]]\\n\\n\"Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\" cannot be more vague.\\n\\n2. '-' means negative. It's not a delimiter.\\n\\n3. For test cases like \"324\" you need to return something like NestedInteger(324) not \"[324]\". \\n\\n4. A list cannot have multiple consecutive integers. e.g. \"321, 231\" is invalid. I guess it's for difficulty purposes."
                    },
                    {
                        "username": "hai8",
                        "content": "This is quite difficult."
                    },
                    {
                        "username": "ahcox",
                        "content": "Before I start, why is there such a bad upvote to downvote ratio? Is it broken?"
                    },
                    {
                        "username": "wang2019",
                        "content": "Why contains \\'-\\' ?"
                    },
                    {
                        "username": "butterman1986",
                        "content": "The question description states the following:\\nString contains only digits 0-9 , [, ,,(comma),-,].\\nThere are no test cases with hyphen so just ignore this character."
                    },
                    {
                        "username": "justdoit2000",
                        "content": "please add the following testing cases \"[,[]]\" and \"[,]\". I believe there are problems in all the solutions passed and posted here."
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem is a perfect example of how you should NOT design interfaces of your classes."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "In python\n\nvar1=NestedInteger(99) // var1 is [99]\nvar2=NestedInteger(89) // var2 is [89]\nvar2.add(var1)  # I expected var2 to become [89,[99]]\nprint(var2)   #but this printed [,[99]]\n\nWhy is this happening description says Add will just add given NestedInteger to it's caller. What am i missing ?"
                    },
                    {
                        "username": "mechalas",
                        "content": "Once you initialize the object as an integer, you can\\'t convert it to a list. You have to initialize it as a list, then populate the members."
                    }
                ]
            }
        ]
    }
]