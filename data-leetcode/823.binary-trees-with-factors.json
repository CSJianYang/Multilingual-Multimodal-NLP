[
    {
        "title": "Binary Trees With Factors",
        "question_content": "Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1.\nWe make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of its children.\nReturn the number of binary trees we can make. The answer may be too large so return the answer modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: arr = [2,4]\nOutput: 3\nExplanation: We can make these trees: [2], [4], [4, 2, 2]\nExample 2:\n\nInput: arr = [2,4,5,10]\nOutput: 7\nExplanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].\n&nbsp;\nConstraints:\n\n\t1 <= arr.length <= 1000\n\t2 <= arr[i] <= 109\n\tAll the values of arr are unique.",
        "solutions": [
            {
                "id": 125794,
                "title": "c-java-python-dp-solution",
                "content": "Sort the list `A` at first. Scan `A` from small element to bigger.\\n\\nDP equation:\\n`dp[i] = sum(dp[j] * dp[i / j])`\\n`res  = sum(dp[i])`\\nwith `i, j, i / j` in the list `L`\\n\\n\\n**C++**\\n```cpp\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        long res = 0, mod = pow(10, 9) + 7;\\n        sort(A.begin(), A.end());\\n        unordered_map<int, long> dp;\\n        for (int i = 0; i < A.size(); ++i) {\\n            dp[A[i]] = 1;\\n            for (int j = 0; j < i; ++j)\\n                if (A[i] % A[j] == 0)\\n                    dp[A[i]] = (dp[A[i]] + dp[A[j]] * dp[A[i] / A[j]]) % mod;\\n            res = (res + dp[A[i]]) % mod;\\n        }\\n        return res;\\n    }\\n```\\n**Java**\\n```java\\n    public int numFactoredBinaryTrees(int[] A) {\\n        long res = 0L, mod = (long)1e9 + 7;\\n        Arrays.sort(A);\\n        HashMap<Integer, Long> dp = new HashMap<>();\\n        for (int i = 0; i < A.length; ++i) {\\n            dp.put(A[i], 1L);\\n            for (int j = 0; j < i; ++j)\\n                if (A[i] % A[j] == 0)\\n                    dp.put(A[i], (dp.get(A[i]) + dp.get(A[j]) * dp.getOrDefault(A[i] / A[j], 0L)) % mod);\\n            res = (res + dp.get(A[i])) % mod;\\n        }\\n        return (int) res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def numFactoredBinaryTrees(self, A):\\n        dp = {}\\n        for a in sorted(A):\\n            dp[a] = sum(dp[b] * dp.get(a / b, 0) for b in dp if a % b == 0) + 1\\n        return sum(dp.values()) % (10**9 + 7)\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        long res = 0, mod = pow(10, 9) + 7;\\n        sort(A.begin(), A.end());\\n        unordered_map<int, long> dp;\\n        for (int i = 0; i < A.size(); ++i) {\\n            dp[A[i]] = 1;\\n            for (int j = 0; j < i; ++j)\\n                if (A[i] % A[j] == 0)\\n                    dp[A[i]] = (dp[A[i]] + dp[A[j]] * dp[A[i] / A[j]]) % mod;\\n            res = (res + dp[A[i]]) % mod;\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public int numFactoredBinaryTrees(int[] A) {\\n        long res = 0L, mod = (long)1e9 + 7;\\n        Arrays.sort(A);\\n        HashMap<Integer, Long> dp = new HashMap<>();\\n        for (int i = 0; i < A.length; ++i) {\\n            dp.put(A[i], 1L);\\n            for (int j = 0; j < i; ++j)\\n                if (A[i] % A[j] == 0)\\n                    dp.put(A[i], (dp.get(A[i]) + dp.get(A[j]) * dp.getOrDefault(A[i] / A[j], 0L)) % mod);\\n            res = (res + dp.get(A[i])) % mod;\\n        }\\n        return (int) res;\\n    }\\n```\n```py\\n    def numFactoredBinaryTrees(self, A):\\n        dp = {}\\n        for a in sorted(A):\\n            dp[a] = sum(dp[b] * dp.get(a / b, 0) for b in dp if a % b == 0) + 1\\n        return sum(dp.values()) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 126277,
                "title": "concise-java-solution-using-hashmap-with-detailed-explanation-easily-understand",
                "content": "```\\n/**sort the array\\n * and use HashMap to record each Integer, and the number of trees with that Integer as root\\n * (1) each integer A[i] will always have one tree with only itself\\n * (2) if A[i] has divisor (a) in the map, and if A[i]/a also in the map\\n *     then a can be the root of its left subtree, and A[i]/a can be the root of its right subtree;\\n *     the number of such tree is map.get(a) * map.get(A[i]/a)\\n * (3) sum over the map\\n */\\nclass Solution {    \\n    public int numFactoredBinaryTrees(int[] A) {\\n        Arrays.sort(A);\\n        Map<Integer, Long> map = new HashMap();\\n        long count = 1;\\n        map.put(A[0], count);\\n        for (int i = 1; i < A.length; i++) {\\n            count = 1;\\n            for (Integer n : map.keySet()) {\\n                if (A[i] % n == 0 && map.containsKey(A[i] / n)) {\\n                    count += map.get(n) * map.get(A[i] / n);\\n                }\\n            }\\n            map.put(A[i], count);\\n        }\\n        long sum = 0;\\n        for (Integer n : map.keySet()) {\\n            sum = (sum + map.get(n)) % ((int) Math.pow(10, 9) + 7) ;\\n        }\\n        return (int) sum;\\n    }        \\n}",
                "solutionTags": [],
                "code": "class Solution {    \\n    public int numFactoredBinaryTrees(int[] A) {\\n        Arrays.sort(A);\\n        Map<Integer, Long> map = new HashMap();\\n        long count = 1;\\n        map.put(A[0], count);\\n        for (int i = 1; i < A.length; i++) {\\n            count = 1;\\n            for (Integer n : map.keySet()) {\\n                if (A[i] % n == 0 && map.containsKey(A[i] / n)) {\\n                    count += map.get(n) * map.get(A[i] / n);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2399992,
                "title": "c-clean-code-explained",
                "content": "sort the array and use HashMap to record each Integer, and the number of trees with that Integer as root\\n(1) each integer A[i] will always have one tree with only itself\\n(2) if A[i] has divisor (a) in the map, and if A[i]/a also in the map then a can be the root of its left subtree, and A[i]/a can be the root of its right subtree;\\nthe number of such tree is map.get(a) * map.get(A[i]/a)\\n(3) sum over the map\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n     int mod = pow(10,9) + 7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        unordered_map <int, long> rootWithCount;\\n        rootWithCount[arr[0]] = 1;\\n        for(int i = 1; i < arr.size(); i++){\\n            long count = 1;\\n            for(auto j : rootWithCount){\\n                int rootEle = j.first;\\n                if(arr[i] % rootEle == 0 && rootWithCount.find(arr[i] / rootEle) != rootWithCount.end()){\\n                    count += rootWithCount[rootEle] * rootWithCount[arr[i] / rootEle];\\n                    \\n                }\\n            }\\n            rootWithCount[arr[i]] = count;\\n        }\\n        int noOfTrees = 0;\\n        for(auto i : rootWithCount){\\n            noOfTrees = (noOfTrees + i.second) % mod;\\n        }\\n        return noOfTrees;\\n    }\\n};\\n```\\n\\nTC: O(N^2)\\nSC: O(N)\\n\\n**IF YOU LIKE MY SOLUTION THEN JUST PLEASE PLEASE UPVOTE IT**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int mod = pow(10,9) + 7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        unordered_map <int, long> rootWithCount;\\n        rootWithCount[arr[0]] = 1;\\n        for(int i = 1; i < arr.size(); i++){\\n            long count = 1;\\n            for(auto j : rootWithCount){\\n                int rootEle = j.first;\\n                if(arr[i] % rootEle == 0 && rootWithCount.find(arr[i] / rootEle) != rootWithCount.end()){\\n                    count += rootWithCount[rootEle] * rootWithCount[arr[i] / rootEle];\\n                    \\n                }\\n            }\\n            rootWithCount[arr[i]] = count;\\n        }\\n        int noOfTrees = 0;\\n        for(auto i : rootWithCount){\\n            noOfTrees = (noOfTrees + i.second) % mod;\\n        }\\n        return noOfTrees;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400030,
                "title": "python-dp-detailed-explantion-dictionary-t-m-91-4-90-9-easy-to-understand",
                "content": "1.sort the array in ascending order\\n2.create a dictionary and initialize it\\n3.loop through the data\\n4.return sum of values\\n\\nTake this for example:\\n\\t`arr = [2, 4, 5, 10] `\\n![image](https://assets.leetcode.com/users/images/6eaaaab7-d9bc-4384-bafb-5bba4ab8ac04_1660010194.973968.png)\\n\\nCode:\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        \\n        arr.sort()\\n        MOD = 10**9 + 7\\n        \\n        # create a dictionary and initialize\\n        dp = {}\\n        for n in arr:\\n            dp[n] = 1\\n            \\n        # loop through each number\\n        for i, n in enumerate(arr):\\n            for j in range(i):\\n                if not(n % arr[j]) and n // arr[j] in dp:\\n                    dp[n] += dp[arr[j]] * dp[n//arr[j]]\\n                    dp[n] %= MOD\\n        \\n        return sum(dp.values()) % MOD\\n```\\n**Please UPVOTE if you LIKE !!!**\\n![image](https://assets.leetcode.com/users/images/c6a55e6b-4ada-4103-ba39-c7a2197aee9b_1660008862.3782873.png)\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        \\n        arr.sort()\\n        MOD = 10**9 + 7\\n        \\n        # create a dictionary and initialize\\n        dp = {}\\n        for n in arr:\\n            dp[n] = 1\\n            \\n        # loop through each number\\n        for i, n in enumerate(arr):\\n            for j in range(i):\\n                if not(n % arr[j]) and n // arr[j] in dp:\\n                    dp[n] += dp[arr[j]] * dp[n//arr[j]]\\n                    dp[n] %= MOD\\n        \\n        return sum(dp.values()) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107208,
                "title": "python-short-o-n-2-solution-explained",
                "content": "Let `dp(num)` be the answer to the question: how many binary trees exists such that their root equal to `num` and they follow the problem statement. We can calculate this number of trees, if we look at the left subtree and at the right subtree. So, first of all we create `s_arr`: set of possible values, and then for each `cand in s_arr`, we check:\\n\\n1. If `num % cand == 0`, that is number is divisible.\\n2. If `num//cand in s_arr`, that is if the second children also in set of admissible values.\\n3. We add `dp(cand)*dp(num//cand)` to `ans`, total number of trees we found. Note that we define `ans = 1`, because we can always have tree with one node.\\n\\n**Complexity**: time complexity is `O(n^2)`, because we have `n` different states and from each state we make at most `O(n)` steps. Space complexity is `O(n)`.\\n\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr):\\n        s_arr, N = set(arr), 10**9 + 7\\n        \\n        @lru_cache(None)\\n        def dp(num):\\n            ans = 1\\n            for cand in s_arr:\\n                if num % cand == 0 and num//cand in s_arr:\\n                    ans += dp(cand)*dp(num//cand)\\n            return ans\\n        \\n        return sum(dp(num) for num in s_arr) % N\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr):\\n        s_arr, N = set(arr), 10**9 + 7\\n        \\n        @lru_cache(None)\\n        def dp(num):\\n            ans = 1\\n            for cand in s_arr:\\n                if num % cand == 0 and num//cand in s_arr:\\n                    ans += dp(cand)*dp(num//cand)\\n            return ans\\n        \\n        return sum(dp(num) for num in s_arr) % N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400159,
                "title": "java-easy-solution-using-hashmap",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>();\\n        long ans=1;\\n        map.put(arr[0],ans);\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans=ans+sum;\\n        }\\n        return (int)(ans%1000000007);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>();\\n        long ans=1;\\n        map.put(arr[0],ans);\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans=ans+sum;\\n        }\\n        return (int)(ans%1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107268,
                "title": "js-python-java-c-fastest-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe trick to this problem is realizing that we can break it down into smaller pieces. A number can always be a leaf, so the number of **ways** it can form a branch should always start at **1**.\\n\\nIf the number can be made from multiple factor pairs, then **ways** is our starting value of **1** plus the sum of all the ways to make those factor pairs. \\n\\nFor each existing factor pair (**fA** & **fB**), the number of ways to make that that particular pair configuration is the product of the number of ways to make **fA** and **fB**.\\n\\nSo we can see that each number relies on first solving the same question for each of its factors. This means that we should start by sorting our numbers array (**A**). Then we can iterate through **A** and figure out each number in ascending order, so that we will have completed any factors for larger numbers before we need to use them.\\n\\nThis means storing the information, which we can do in a **map**, so that we can look up the results by value.\\n\\nIn order to be more efficient when we attempt to find each factor pair, we only need to iterate through **A** up to the **square root** of the number in question, so that we don\\'t duplicate the same factor pairs going the opposite direction. That means we need to double every pair result where **fA** and **fB** are not the same.\\n\\nSince each number can be the head of a tree, our answer (**ans**) will be the sum of each number\\'s result. We shouldn\\'t forget to modulo at each round of summation.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJava and C++, having typed variables, should use **long** for **ways** and **ans**, but will need to cast **ans** back to **int** before returning. They will also need an extra **continue** conditional when checking for factors.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **96ms / 43.8MB** (beats 100% / 82%).\\n```javascript\\nvar numFactoredBinaryTrees = function(A) {\\n    A.sort((a,b) => a - b)\\n    let len = A.length, fmap = new Map(), ans = 0\\n    for (let i = 0; i < len; i++) {\\n        let num = A[i], ways = 1, lim = Math.sqrt(num)\\n        for (let j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n            let fB = num / fA\\n            if (fmap.has(fB))\\n                ways = (ways + fmap.get(fA) * fmap.get(fB) * (fA === fB ? 1 : 2)) % 1000000007\\n        }\\n        fmap.set(num, ways), ans = (ans + ways) % 1000000007\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **96ms / 14.4MB** (beats 99% / 74%).\\n```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n        A.sort()\\n        fmap, ans = defaultdict(), 0\\n        for num in A:\\n            ways, lim = 1, sqrt(num)\\n            for fA in A:\\n                if fA > lim: break\\n                fB = num / fA\\n                if fB in fmap:\\n                    ways += fmap[fA] * fmap[fB] * (1 if fA == fB else 2)\\n            fmap[num], ans = ways, (ans + ways)\\n        return ans % 1000000007\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **10ms / 38.7MB** (beats 99% / 91%).\\n```java\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] A) {\\n        Arrays.sort(A);\\n        int len = A.length;\\n        long ans = 0;\\n        HashMap<Integer, Long> fmap = new HashMap<>();\\n        for (int num : A) {\\n            long ways = 1;\\n            double lim = Math.sqrt(num);\\n            for (int j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.containsKey(fB))\\n                    ways = (ways + fmap.get(fA) * fmap.get(fB) * (fA == fB ? 1 : 2)) % 1000000007;\\n            }\\n            fmap.put(num, ways);\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **12ms / 9.1MB** (beats 100% / 81%).\\n```c++\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int len = A.size();\\n        long ans = 0;\\n        unordered_map<int, long> fmap;\\n        for (int num : A) {\\n            long ways = 1;\\n            double lim = sqrt(num);\\n            for (int j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.find(fB) != fmap.end())\\n                    ways = (ways + fmap[fA] * fmap[fB] * (fA == fB ? 1 : 2)) % 1000000007;\\n            }\\n            fmap[num] = ways;\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar numFactoredBinaryTrees = function(A) {\\n    A.sort((a,b) => a - b)\\n    let len = A.length, fmap = new Map(), ans = 0\\n    for (let i = 0; i < len; i++) {\\n        let num = A[i], ways = 1, lim = Math.sqrt(num)\\n        for (let j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n            let fB = num / fA\\n            if (fmap.has(fB))\\n                ways = (ways + fmap.get(fA) * fmap.get(fB) * (fA === fB ? 1 : 2)) % 1000000007\\n        }\\n        fmap.set(num, ways), ans = (ans + ways) % 1000000007\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n        A.sort()\\n        fmap, ans = defaultdict(), 0\\n        for num in A:\\n            ways, lim = 1, sqrt(num)\\n            for fA in A:\\n                if fA > lim: break\\n                fB = num / fA\\n                if fB in fmap:\\n                    ways += fmap[fA] * fmap[fB] * (1 if fA == fB else 2)\\n            fmap[num], ans = ways, (ans + ways)\\n        return ans % 1000000007\\n```\n```java\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] A) {\\n        Arrays.sort(A);\\n        int len = A.length;\\n        long ans = 0;\\n        HashMap<Integer, Long> fmap = new HashMap<>();\\n        for (int num : A) {\\n            long ways = 1;\\n            double lim = Math.sqrt(num);\\n            for (int j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.containsKey(fB))\\n                    ways = (ways + fmap.get(fA) * fmap.get(fB) * (fA == fB ? 1 : 2)) % 1000000007;\\n            }\\n            fmap.put(num, ways);\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int len = A.size();\\n        long ans = 0;\\n        unordered_map<int, long> fmap;\\n        for (int num : A) {\\n            long ways = 1;\\n            double lim = sqrt(num);\\n            for (int j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.find(fB) != fmap.end())\\n                    ways = (ways + fmap[fA] * fmap[fB] * (fA == fB ? 1 : 2)) % 1000000007;\\n            }\\n            fmap[num] = ways;\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402569,
                "title": "python-detailed-explanation-easily-understood-dp-o-n-sqrt-n",
                "content": "**Appreciate if you could upvote this solution**\\n\\nMethod: `DP`\\n\\nSince the parent node is the product of the children, the value of the parent nodes must larger than the values of its children.\\nThus, we can sort the `arr` first, and start to calculate the combination of products **from smallest node to the largest one**.\\nFor example, `arr = [18, 3, 6, 2]`\\nAfter sorting, `arr = [2, 3, 6, 18]`\\nThen, a dict `count_product_dict` needs to be created to store the count of combinations and all the initial values should be `1`.\\n\\n```\\nFor 2:\\n\\t- We can ignore the first number as the smallest number does not have a product of 2 smaller numbers.\\n\\nFor 3:\\n\\t- We can just scan the numbers smaller than 3\\n\\t\\t- Since 2 is larger than half of 3, it is rejected as 3 must not be a product of 2 and a integer.\\n\\nFor 6:\\n\\t- We can just scan the numbers smaller than 6\\n\\t\\t- 6 % 2 == 0 -> (2, 6 // 2)\\n\\t\\t\\t- count_product_dict[6] += count_product_dict[2] * count_product_dict[6 // 2]\\n\\t\\t- 6 % 3 == 0 -> (3, 6 // 3)\\n\\t\\t\\t- count_product_dict[6] += count_product_dict[2] * count_product_dict[6 // 2]\\n\\nAnd so on...\\nFinally, count_product_dict = {18: 7, 3: 1, 6: 3, 2: 1}\\n```\\n\\nCode:\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        total_nums = len(arr)\\n        moduler = 1000000007\\n        count_product_dict = {num: 1 for num in arr}\\n        arr.sort()\\n\\n        for i in range(1, total_nums):\\n            for j in range(i):\\n                quotient = arr[i] // arr[j]\\n                if quotient < 2 or math.sqrt(arr[i]) > arr[i- 1]:\\n                    break\\n                if arr[i] % arr[j] == 0:\\n                    count_product_dict[arr[i]] += count_product_dict[arr[j]] * count_product_dict.get(quotient, 0)\\n                    count_product_dict[arr[i]] %= moduler\\n                    \\n        return sum(count_product_dict.values()) % moduler\\n```\\n\\n**Time Complexity**: O(n ^ 2)\\n**Space Complexity**: O(n)\\n<br />",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nFor 2:\\n\\t- We can ignore the first number as the smallest number does not have a product of 2 smaller numbers.\\n\\nFor 3:\\n\\t- We can just scan the numbers smaller than 3\\n\\t\\t- Since 2 is larger than half of 3, it is rejected as 3 must not be a product of 2 and a integer.\\n\\nFor 6:\\n\\t- We can just scan the numbers smaller than 6\\n\\t\\t- 6 % 2 == 0 -> (2, 6 // 2)\\n\\t\\t\\t- count_product_dict[6] += count_product_dict[2] * count_product_dict[6 // 2]\\n\\t\\t- 6 % 3 == 0 -> (3, 6 // 3)\\n\\t\\t\\t- count_product_dict[6] += count_product_dict[2] * count_product_dict[6 // 2]\\n\\nAnd so on...\\nFinally, count_product_dict = {18: 7, 3: 1, 6: 3, 2: 1}\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        total_nums = len(arr)\\n        moduler = 1000000007\\n        count_product_dict = {num: 1 for num in arr}\\n        arr.sort()\\n\\n        for i in range(1, total_nums):\\n            for j in range(i):\\n                quotient = arr[i] // arr[j]\\n                if quotient < 2 or math.sqrt(arr[i]) > arr[i- 1]:\\n                    break\\n                if arr[i] % arr[j] == 0:\\n                    count_product_dict[arr[i]] += count_product_dict[arr[j]] * count_product_dict.get(quotient, 0)\\n                    count_product_dict[arr[i]] %= moduler\\n                    \\n        return sum(count_product_dict.values()) % moduler\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107269,
                "title": "binary-trees-with-factors-js-python-java-c-fastest-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe trick to this problem is realizing that we can break it down into smaller pieces. A number can always be a leaf, so the number of **ways** it can form a branch should always start at **1**.\\n\\nIf the number can be made from multiple factor pairs, then **ways** is our starting value of **1** plus the sum of all the ways to make those factor pairs. \\n\\nFor each existing factor pair (**fA** & **fB**), the number of ways to make that that particular pair configuration is the product of the number of ways to make **fA** and **fB**.\\n\\nSo we can see that each number relies on first solving the same question for each of its factors. This means that we should start by sorting our numbers array (**A**). Then we can iterate through **A** and figure out each number in ascending order, so that we will have completed any factors for larger numbers before we need to use them.\\n\\nThis means storing the information, which we can do in a **map**, so that we can look up the results by value.\\n\\nIn order to be more efficient when we attempt to find each factor pair, we only need to iterate through **A** up to the **square root** of the number in question, so that we don\\'t duplicate the same factor pairs going the opposite direction. That means we need to double every pair result where **fA** and **fB** are not the same.\\n\\nSince each number can be the head of a tree, our answer (**ans**) will be the sum of each number\\'s result. We shouldn\\'t forget to modulo at each round of summation.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJava and C++, having typed variables, should use **long** for **ways** and **ans**, but will need to cast **ans** back to **int** before returning. They will also need an extra **continue** conditional when checking for factors.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **96ms / 43.8MB** (beats 100% / 82%).\\n```javascript\\nvar numFactoredBinaryTrees = function(A) {\\n    A.sort((a,b) => a - b)\\n    let len = A.length, fmap = new Map(), ans = 0\\n    for (let i = 0; i < len; i++) {\\n        let num = A[i], ways = 1, lim = Math.sqrt(num)\\n        for (let j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n            let fB = num / fA\\n            if (fmap.has(fB))\\n                ways += fmap.get(fA) * fmap.get(fB) * (fA === fB ? 1 : 2)\\n        }\\n        fmap.set(num, ways), ans += ways\\n    }\\n    return ans % 1000000007\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **96ms / 14.4MB** (beats 99% / 74%).\\n```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n        A.sort()\\n        fmap, ans = defaultdict(), 0\\n        for num in A:\\n            ways, lim = 1, sqrt(num)\\n            for fA in A:\\n                if fA > lim: break\\n                fB = num / fA\\n                if fB in fmap:\\n                    ways += fmap[fA] * fmap[fB] * (1 if fA == fB else 2)\\n            fmap[num], ans = ways, (ans + ways)\\n        return ans % 1000000007\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **10ms / 38.7MB** (beats 99% / 91%).\\n```java\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] A) {\\n        Arrays.sort(A);\\n        int len = A.length;\\n        long ans = 0;\\n        HashMap<Integer, Long> fmap = new HashMap<>();\\n        for (int num : A) {\\n            long ways = 1;\\n            double lim = Math.sqrt(num);\\n            for (int j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.containsKey(fB))\\n                    ways += fmap.get(fA) * fmap.get(fB) * (fA == fB ? 1 : 2);\\n            }\\n            fmap.put(num, ways);\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **12ms / 9.1MB** (beats 100% / 81%).\\n```c++\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int len = A.size();\\n        long ans = 0;\\n        unordered_map<int, long> fmap;\\n        for (int num : A) {\\n            long ways = 1;\\n            double lim = sqrt(num);\\n            for (int j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.find(fB) != fmap.end())\\n                    ways += fmap[fA] * fmap[fB] * (fA == fB ? 1 : 2);\\n            }\\n            fmap[num] = ways;\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar numFactoredBinaryTrees = function(A) {\\n    A.sort((a,b) => a - b)\\n    let len = A.length, fmap = new Map(), ans = 0\\n    for (let i = 0; i < len; i++) {\\n        let num = A[i], ways = 1, lim = Math.sqrt(num)\\n        for (let j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n            let fB = num / fA\\n            if (fmap.has(fB))\\n                ways += fmap.get(fA) * fmap.get(fB) * (fA === fB ? 1 : 2)\\n        }\\n        fmap.set(num, ways), ans += ways\\n    }\\n    return ans % 1000000007\\n};\\n```\n```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n        A.sort()\\n        fmap, ans = defaultdict(), 0\\n        for num in A:\\n            ways, lim = 1, sqrt(num)\\n            for fA in A:\\n                if fA > lim: break\\n                fB = num / fA\\n                if fB in fmap:\\n                    ways += fmap[fA] * fmap[fB] * (1 if fA == fB else 2)\\n            fmap[num], ans = ways, (ans + ways)\\n        return ans % 1000000007\\n```\n```java\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] A) {\\n        Arrays.sort(A);\\n        int len = A.length;\\n        long ans = 0;\\n        HashMap<Integer, Long> fmap = new HashMap<>();\\n        for (int num : A) {\\n            long ways = 1;\\n            double lim = Math.sqrt(num);\\n            for (int j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.containsKey(fB))\\n                    ways += fmap.get(fA) * fmap.get(fB) * (fA == fB ? 1 : 2);\\n            }\\n            fmap.put(num, ways);\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int len = A.size();\\n        long ans = 0;\\n        unordered_map<int, long> fmap;\\n        for (int num : A) {\\n            long ways = 1;\\n            double lim = sqrt(num);\\n            for (int j = 0, fA = A[0]; fA <= lim; fA = A[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.find(fB) != fmap.end())\\n                    ways += fmap[fA] * fmap[fB] * (fA == fB ? 1 : 2);\\n            }\\n            fmap[num] = ways;\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400901,
                "title": "simple-short-c-explained-solution-by-mr-coder",
                "content": "**\\u2190\\u2190Must Not Forget To Upvote this by clicking up side arrow**\\n**YOU CAN WATCH THIS VIDEO FOR THE BETTER EXPLANATION**\\n**Recommended- **\\nhttps://www.youtube.com/watch?v=f0mAAQqvqR8\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define MOD 1000000007\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        ll ans =0;\\n        unordered_map<ll, ll> up;\\n        sort(arr.begin(), arr.end());\\n        for(int i=0; i< arr.size(); i++){\\n            ll currentans=1;\\n            for(int j=0; j< i; j++)\\n            {\\n                if(arr[i]% arr[j]) continue;\\n                int ans1= arr[i]/ arr[j];\\n               int ans2=  arr[j];\\n                currentans= (currentans+ up[ans1]*up[ans2]%MOD)%MOD;\\n                \\n                \\n            }\\n            up[arr[i]]= currentans;\\n            ans = ans+ currentans;\\n            \\n        }\\n        return ans% MOD;\\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    #define ll long long\\n    #define MOD 1000000007\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        ll ans =0;\\n        unordered_map<ll, ll> up;\\n        sort(arr.begin(), arr.end());\\n        for(int i=0; i< arr.size(); i++){\\n            ll currentans=1;\\n            for(int j=0; j< i; j++)\\n            {\\n                if(arr[i]% arr[j]) continue;\\n                int ans1= arr[i]/ arr[j];\\n               int ans2=  arr[j];\\n                currentans= (currentans+ up[ans1]*up[ans2]%MOD)%MOD;\\n                \\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1376361,
                "title": "python-top-down-dp-clean-concise-o-n-2",
                "content": "**Idea**\\n- Convert `arr` into `arrSet` to we can check if an element exists in array in `O(1)`.\\n- Let `dp(root)` is number of binary trees which has root with value `root` and follow the problem rules.\\n- To calculate `dp(root)`\\n\\t- We try `cand` in `arrSet`:\\n\\t\\t- If `root % cand == 0` and `root // cand` in `arrSet`, then we can form a valid binary tree with values of 2 children nodes are `cand` and `root // cand`, so\\n\\t\\t\\t- Number of valid increase by `dp(cand) * dp(root // cand)`\\n```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        MOD = 10**9+7\\n        arrSet = set(arr)\\n        \\n        @lru_cache(None)\\n        def dp(root):\\n            ans = 1\\n            for cand in arrSet:\\n                if root % cand == 0 and (root // cand) in arrSet:\\n                    ans += dp(cand) * dp(root // cand)\\n                    ans %= MOD\\n            return ans\\n        \\n        return sum(dp(x) for x in arrSet) % MOD\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 1000` is number of elements in the array.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        MOD = 10**9+7\\n        arrSet = set(arr)\\n        \\n        @lru_cache(None)\\n        def dp(root):\\n            ans = 1\\n            for cand in arrSet:\\n                if root % cand == 0 and (root // cand) in arrSet:\\n                    ans += dp(cand) * dp(root // cand)\\n                    ans %= MOD\\n            return ans\\n        \\n        return sum(dp(x) for x in arrSet) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107283,
                "title": "python-dp",
                "content": "As we are counting a large number of trees it\\'s not a surprise this is dynamic programming. There\\'s some structure in the problem and we need to represent in in our DP. Here is how it proceeds: First sort the array (they don\\'t sort it for you, so help yourself). \\n\\nNow at every step we want to find the number of trees that end at value `x`. For that we consider every `y < x`. If `z = x//y` is such that `z*y = x` we can have `dp[y]*dp[z]` amount of trees that have children `y` and `z` and root `x`. Furthermore the set of `y,z` we consider are disjoint so we can sum them up to find all trees that end at root `z`. We used the two basic rules of counting: sum and product rules. It is important to note the pairs of `y,z` are disjoint, so that we can use simple summation (and not the Principle of Inclusion and Exclusion). We are left with one final question: we have `x`, we have `y`. How can we quickly access the counts for `z`? If we use the python built-in defaultdict, then if `z` cannot be achieved its count will be 0 and the product will evaluate to 0. This leads to the following short solution.\\n\\nIt\\'s trickier than it appears...\\n\\nNote: Also the question statement is ambiguous, as if you have a tree like `7 -> 7 -> 7 -> ... ` the one-children \"product\" is always the same as root, and the solution is always infinite. So it has to be noted that to be a valid product you need to have both children nodes. \\n\\n```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr):\\n        arr.sort()\\n        \\n        dp = collections.defaultdict(int)\\n        for x in arr:\\n            dp[x] = 1\\n        \\n        for i in range(1, len(arr)):\\n            for j in range(i):\\n                x, y, z = arr[i], arr[j], arr[i]//arr[j]\\n                if y*z == x:\\n                    dp[x] += dp[y]*dp[z]\\n                \\n        return sum(dp.values()) % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr):\\n        arr.sort()\\n        \\n        dp = collections.defaultdict(int)\\n        for x in arr:\\n            dp[x] = 1\\n        \\n        for i in range(1, len(arr)):\\n            for j in range(i):\\n                x, y, z = arr[i], arr[j], arr[i]//arr[j]\\n                if y*z == x:\\n                    dp[x] += dp[y]*dp[z]\\n                \\n        return sum(dp.values()) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637537,
                "title": "faqs-about-binary-trees-with-factors",
                "content": "Providing you some of the *Frequently Asked Questions* for this question.\\nI arranged the questions from less to more (frequency).\\nIf you don\\'t know about the solution please have a look at it before reading FAQs. I have attached it below!\\n\\n**Why hashmap?**\\nBecause we need to store count of trees which can be made with corresponding values of array.\\n\\n**Why count is initially mapped as 1?**\\nSince single element can make a tree!\\n\\n**Why sorted? (Most Frequently Asked Question)**\\nInorder to understand this answer, we need to look at another question (Follow up)\\n\\n**`Why it is A[i] % rootEle == 0 && rootWithCount.find(A[i] / rootEle) != rootWithCount.end() ?`**\\n**`Why  A[i] % rootEle == 0 ? `**\\n We have to check whether any rootEle (previously stored value in hashmap) is a factor of A[i]. \\n As per the question, For a element to be valid root, we should have two childrens whose product is equal to root.\\n \\n*If we need to get element by multipling any two numbers, atleast one of it has to be its factor.*\\n **Example: Root -> 10; Childrens -> 5, 2 Both 5 and 2 are factors.**\\n \\n**` Why rootWithCount.find(A[i] / rootEle) != rootWithCount.end() ?`**\\n We found rootEle as a factor, is there are any element in the map, so that they multiplies to give the root value.\\n \\n Now coming back to our question (why sorted)\\n \\n **For every number, their factors will be less than it**. SIMPLE SO SORTED.\\n\\n\\n**Upvote. It would be encouraging.** Correct me if am wrong!\\n\\nHere is my C++ version of @Self_Learner Solution!\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = pow(10,9) + 7;\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        unordered_map <int, long> rootWithCount;\\n        \\n        rootWithCount[A[0]] = 1;\\n        for(int i = 1; i < A.size(); i++){\\n            long count = 1;\\n            for(auto j : rootWithCount){\\n                int rootEle = j.first;\\n                if(A[i] % rootEle == 0 && rootWithCount.find(A[i] / rootEle) != rootWithCount.end()){\\n                    count += rootWithCount[rootEle] * rootWithCount[A[i] / rootEle];\\n                    \\n                }\\n            }\\n            rootWithCount[A[i]] = count;\\n        }\\n        int noOfTrees = 0;\\n        for(auto i : rootWithCount){\\n            noOfTrees = (noOfTrees + i.second) % mod;\\n        }\\n        return noOfTrees;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = pow(10,9) + 7;\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        unordered_map <int, long> rootWithCount;\\n        \\n        rootWithCount[A[0]] = 1;\\n        for(int i = 1; i < A.size(); i++){\\n            long count = 1;\\n            for(auto j : rootWithCount){\\n                int rootEle = j.first;\\n                if(A[i] % rootEle == 0 && rootWithCount.find(A[i] / rootEle) != rootWithCount.end()){\\n                    count += rootWithCount[rootEle] * rootWithCount[A[i] / rootEle];\\n                    \\n                }\\n            }\\n            rootWithCount[A[i]] = count;\\n        }\\n        int noOfTrees = 0;\\n        for(auto i : rootWithCount){\\n            noOfTrees = (noOfTrees + i.second) % mod;\\n        }\\n        return noOfTrees;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126016,
                "title": "short-simple-python",
                "content": "My `t[a]` tells the number of trees with root value `a`. The `1` is for making a leaf (there\\'s one way to make a leaf with that value), the `sum` is for non-leaves (go over every possible left child value `b`).\\n\\n    def numFactoredBinaryTrees(self, A):\\n        t = {}\\n        for a in sorted(A):\\n            t[a] = 1 + sum(t[b] * t.get(a/b, 0) for b in A if b < a)\\n        return sum(t.values()) % (10**9 + 7)\\n",
                "solutionTags": [],
                "code": "My `t[a]` tells the number of trees with root value `a`. The `1` is for making a leaf (there\\'s one way to make a leaf with that value), the `sum` is for non-leaves (go over every possible left child value `b`).\\n\\n    def numFactoredBinaryTrees(self, A):\\n        t = {}\\n        for a in sorted(A):\\n            t[a] = 1 + sum(t[b] * t.get(a/b, 0) for b in A if b < a)\\n        return sum(t.values()) % (10**9 + 7)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2400378,
                "title": "c-dp-two-pointers-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        vector<long> dp(n);\\n        dp[0] = 1;\\n        int res = 0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            int target = arr[i];\\n            int p = 0, q = i - 1; \\n            long ways = 1;\\n            while(p <= q)\\n            {\\n                long mul = (((long)arr[p]) * (arr[q]));\\n                if (mul == target) \\n                {\\n                    if (p == q) ways += (dp[p] * dp[q]) % mod;\\n                    else ways += ((dp[p] * dp[q]) * 2) % mod;\\n                    p++;\\n                    q--;\\n                }\\n                else if (mul < target) p++;\\n                else if (mul > target) q--;\\n            }\\n            dp[i] = ways;\\n            res  = (int)((res + dp[i]) % mod);\\n        }\\n        return res + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        vector<long> dp(n);\\n        dp[0] = 1;\\n        int res = 0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            int target = arr[i];\\n            int p = 0, q = i - 1; \\n            long ways = 1;\\n            while(p <= q)\\n            {\\n                long mul = (((long)arr[p]) * (arr[q]));\\n                if (mul == target) \\n                {\\n                    if (p == q) ways += (dp[p] * dp[q]) % mod;\\n                    else ways += ((dp[p] * dp[q]) * 2) % mod;\\n                    p++;\\n                    q--;\\n                }\\n                else if (mul < target) p++;\\n                else if (mul > target) q--;\\n            }\\n            dp[i] = ways;\\n            res  = (int)((res + dp[i]) % mod);\\n        }\\n        return res + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401187,
                "title": "c-memoized-recursive-code",
                "content": "The readability of the code has somewhat decreased but still i will try explaning:\\n1. we sort the array to reduce the extra time in the for loop for bigger numbers than the number we want to find factors of. \\n2. we store the elements in a set so that accesing them will be simpler.\\n3. run the loop for each element and calculate the no of trees which can be formed.\\n4. Jumping to the helper function.\\n5. we keep the initial count as 1 , as we can form a tree of singlr node always.\\n6. then iterate over the array, check if the number we are on is smaller than the number we need find factors of else we break the loop.\\n7. then we check for its factors and see if they are present on the set if yes we call the helper function for the subtrees.\\n8. return the total count.\\n9. we use a map to memoize the code and store the results and return directly when a similar tree or subtree is formed.\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    long long helper(vector<int> & arr,unordered_map<int,long long> &m,unordered_set<int> &st, int i)\\n    {\\n        if(m.find(i)!=m.end())\\n            return m[i];\\n        long long cnt =1;\\n        for(auto it:  arr)\\n        {\\n            if(it>i)\\n                break;\\n            if(i%it==0 && st.find(i/it)!=st.end())\\n                cnt= cnt%mod + (helper(arr,m,st,i/it)%mod)*(helper(arr,m,st,it)%mod);\\n        }\\n        return m[i]=cnt%mod;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        unordered_map<int,long long> m;\\n        unordered_set<int> st;\\n        sort(arr.begin(),arr.end());\\n        for(auto it: arr)\\n            st.insert(it);\\n        int ans=0;\\n        for(auto it : arr)\\n            ans = ans%mod + helper(arr,m,st,it)%mod;\\n        return ans%mod;\\n    }\\n};\\n```\\n**THANKS  FOR READING IF YOU DID I\\'M JUST TRYING TO GET BETTER AT EXPLANING THINGS.**\\n![image](https://assets.leetcode.com/users/images/274ca368-21b2-4830-a9ea-d278020fdc90_1660030690.2098832.jpeg)\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    long long helper(vector<int> & arr,unordered_map<int,long long> &m,unordered_set<int> &st, int i)\\n    {\\n        if(m.find(i)!=m.end())\\n            return m[i];\\n        long long cnt =1;\\n        for(auto it:  arr)\\n        {\\n            if(it>i)\\n                break;\\n            if(i%it==0 && st.find(i/it)!=st.end())\\n                cnt= cnt%mod + (helper(arr,m,st,i/it)%mod)*(helper(arr,m,st,it)%mod);\\n        }\\n        return m[i]=cnt%mod;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        unordered_map<int,long long> m;\\n        unordered_set<int> st;\\n        sort(arr.begin(),arr.end());\\n        for(auto it: arr)\\n            st.insert(it);\\n        int ans=0;\\n        for(auto it : arr)\\n            ans = ans%mod + helper(arr,m,st,it)%mod;\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126261,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nFor each candidate root `x` of the input array `A`, consider `x = y * z` where `y` and `z` are candidates for the left/right subtrees of `x`, ie. we use the rule-of-product to accumulate the count `cnt` of subtrees, initially set to 1 for `x` as a tree comprised of a single root node.\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun numFactoredBinaryTrees(A: IntArray, MOD: Long = (1e9 + 7).toLong()): Int {\\n        var N = A.size\\n        var seen = A.toSet()\\n        fun go(x: Int): Long {\\n            var cnt = 1L\\n            for (y in A) {\\n                if (x % y != 0)\\n                    continue\\n                var z = x / y\\n                if (seen.contains(z))\\n                    cnt = (cnt + (go(y) * go(z) % MOD)) % MOD\\n            }\\n            return cnt\\n        }\\n        var t = 0L\\n        for (x in A)\\n            t = (t + go(x)) % MOD\\n        return t.toInt()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun numFactoredBinaryTrees(A: IntArray, MOD: Long = (1e9 + 7).toLong()): Int {\\n        var N = A.size\\n        var seen = A.toSet()\\n        var m = mutableMapOf<Int, Long>()\\n        fun go(x: Int): Long {\\n            if (!m.contains(x)) {\\n                var cnt = 1L\\n                for (y in A) {\\n                    if (x % y != 0)\\n                        continue\\n                    var z = x / y\\n                    if (seen.contains(z))\\n                        cnt = (cnt + (go(y) * go(z) % MOD)) % MOD\\n                }\\n                m[x] = cnt\\n            }\\n            return m[x]!!\\n        }\\n        var t = 0L\\n        for (x in A)\\n            t = (t + go(x)) % MOD\\n        return t.toInt()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun numFactoredBinaryTrees(A: IntArray, MOD: Long = (1e9 + 7).toLong()): Int {\\n        var N = A.size\\n        var seen = A.toSet()\\n        var m = mutableMapOf<Int, Long>()\\n        for (x in A)\\n            m[x] = 1L\\n        A.sort()\\n        for (x in A) {\\n            for (y in A) {\\n                if (x % y != 0)\\n                    continue\\n                var z = x / y\\n                if (z in seen)\\n                    m[x] = (m[x]!! + (m[y]!! * m[z]!! % MOD)) % MOD\\n            }\\n        }\\n        var t = 0L\\n        for ((_, cnt) in m)\\n            t = (t + cnt) % MOD\\n        return t.toInt()\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet numFactoredBinaryTrees = (A, seen = new Set(A), MOD = Number(1e9 + 7), t = 0) => {\\n    let go = x => {\\n        let cnt = 1;\\n        for (let y of A) {\\n            if (x % y)\\n                continue;\\n            let z = Math.floor(x / y);\\n            if (seen.has(z))\\n                cnt = (cnt + go(y) * go(z) % MOD) % MOD;\\n        }\\n        return cnt;\\n    };\\n    for (let x of A)\\n        t = (t + go(x)) % MOD;\\n    return t;\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet numFactoredBinaryTrees = (A, seen = new Set(A), MOD = Number(1e9 + 7), m = new Map(), t = 0) => {\\n    let go = x => {\\n        if (!m.has(x)) {\\n            let cnt = 1;\\n            for (let y of A) {\\n                if (x % y)\\n                    continue;\\n                let z = Math.floor(x / y);\\n                if (seen.has(z))\\n                    cnt = (cnt + go(y) * go(z) % MOD) % MOD;\\n            }\\n            m.set(x, cnt);\\n        }\\n        return m.get(x);\\n    };\\n    for (let x of A)\\n        t = (t + go(x)) % MOD;\\n    return t;\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet numFactoredBinaryTrees = (A, seen = new Set(A), MOD = Number(1e9 + 7), m = new Map(), t = 0) => {\\n    A.sort((a, b) => a - b);\\n    for (let x of A)\\n        m.set(x, 1);\\n    for (let x of A) {\\n        for (let y of A) {\\n            if (x % y)\\n                continue;\\n            let z = Math.floor(x / y);\\n            if (seen.has(z))\\n                m.set(x, m.get(x) + (m.get(y) * m.get(z) % MOD) % MOD);\\n        }\\n    }\\n    for (let [_, cnt] of m)\\n        t = (t + cnt) % MOD;\\n    return t;\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int], MOD = int(1e9 + 7), t = 0) -> int:\\n        seen = set(A)\\n        def go(x):\\n            cnt = 1\\n            for y in A:\\n                if x % y:\\n                    continue\\n                z = x // y\\n                if z in seen:\\n                    cnt = (cnt + (go(y) * go(z) % MOD)) % MOD\\n            return cnt\\n        for x in A:\\n            t = (t + go(x)) % MOD\\n        return t\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int], MOD = int(1e9 + 7), t = 0) -> int:\\n        seen = set(A)\\n        @cache\\n        def go(x):\\n            cnt = 1\\n            for y in A:\\n                if x % y:\\n                    continue\\n                z = x // y\\n                if z in seen:\\n                    cnt = (cnt + (go(y) * go(z) % MOD)) % MOD\\n            return cnt\\n        for x in A:\\n            t = (t + go(x)) % MOD\\n        return t\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int], MOD = int(1e9 + 7)) -> int:\\n        seen = set(A)\\n        m = {x: 1 for x in A}\\n        A.sort()\\n        for x in A:\\n            for y in A:\\n                if x % y:\\n                    continue\\n                z = x // y\\n                if z in seen:\\n                    m[x] = (m[x] + (m[y] * m[z] % MOD)) % MOD\\n        return sum(m.values()) % MOD\\n```\\n\\n---\\n\\n**Rust Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\ntype VI = Vec<i32>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn num_factored_binary_trees(A: VI) -> i32 {\\n        let seen: HashSet<i32> = A.clone().into_iter().collect();\\n        fn go(A: &VI, x: i32, seen: &HashSet<i32>) -> i64 {\\n            let MOD = (1e9 as i64 + 7);\\n            let mut cnt = 1 as i64;\\n            for y in A {\\n                if x % y != 0 {\\n                    continue;\\n                }\\n                let z = x / y;\\n                if seen.contains(&z) {\\n                    cnt = (cnt + go(A, *y, seen) * go(A, z, seen) % MOD) % MOD;\\n                }\\n            }\\n            return cnt;\\n        }\\n        let mut t = 0 as i64;\\n        for x in &A {\\n            t = (t + go(&A, *x, &seen)) % (1e9 as i64 + 7);\\n        }\\n        return t as i32;\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\ntype VI = Vec<i32>;\\nuse std::collections::{HashMap, HashSet};\\nimpl Solution {\\n    pub fn num_factored_binary_trees(A: VI) -> i32 {\\n        let seen: HashSet<i32> = A.clone().into_iter().collect();\\n        let mut m = HashMap::new();\\n        fn go(A: &VI, x: i32, seen: &HashSet<i32>, m: &mut HashMap<i32, i64>) -> i64 {\\n            if !m.contains_key(&x) {\\n                let MOD = (1e9 as i64 + 7);\\n                let mut cnt = 1 as i64;\\n                for y in A {\\n                    if x % y != 0 {\\n                        continue;\\n                    }\\n                    let z = x / y;\\n                    if seen.contains(&z) {\\n                        cnt = (cnt + go(A, *y, seen, m) * go(A, z, seen, m) % MOD) % MOD;\\n                    }\\n                }\\n                m.insert(x.clone(), cnt);\\n            }\\n            *m.get(&x).unwrap()\\n        }\\n        let mut t = 0 as i64;\\n        for x in &A {\\n            t = (t + go(&A, *x, &seen, &mut m)) % (1e9 as i64 + 7);\\n        }\\n        return t as i32;\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\n// TODO: implement me!\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    using fun = function<LL(int)>;\\n    int numFactoredBinaryTrees(VI& A, LL MOD = 1e9 + 7, LL t = 0) {\\n        Set seen{ A.begin(), A.end() };\\n        fun go = [&](auto x) {\\n            auto cnt = 1LL;\\n            for (auto y: A) {\\n                if (x % y)\\n                    continue;\\n                auto z = x / y;\\n                if (seen.find(z) != seen.end())\\n                    cnt = (cnt + (go(y) * go(z) % MOD) % MOD);\\n            }\\n            return cnt;\\n        };\\n        for (auto x: A)\\n            t = (t + go(x)) % MOD;\\n        return t;\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    using fun = function<LL(int)>;\\n    using Map = unordered_map<int, LL>;\\n    int numFactoredBinaryTrees(VI& A, LL MOD = 1e9 + 7, Map m = {}, LL t = 0) {\\n        Set seen{ A.begin(), A.end() };\\n        fun go = [&](auto x) {\\n            if (m.find(x) == m.end()) {\\n                auto cnt = 1LL;\\n                for (auto y: A) {\\n                    if (x % y)\\n                        continue;\\n                    auto z = x / y;\\n                    if (seen.find(z) != seen.end())\\n                        cnt = (cnt + (go(y) * go(z) % MOD) % MOD);\\n                }\\n                m[x] = cnt;\\n            }\\n            return m[x];\\n        };\\n        for (auto x: A)\\n            t = (t + go(x)) % MOD;\\n        return t;\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    using fun = function<LL(int)>;\\n    using Map = unordered_map<int, LL>;\\n    int numFactoredBinaryTrees(VI& A, LL MOD = 1e9 + 7, Map m = {}, LL t = 0) {\\n        Set seen{ A.begin(), A.end() };\\n        sort(A.begin(), A.end());\\n        for (auto x: A)\\n            m[x] = 1LL;\\n        for (auto x: A) {\\n            for (auto y: A) {\\n                if (x % y)\\n                    continue;\\n                auto z = x / y;\\n                if (seen.find(z) != seen.end())\\n                    m[x] = (m[x] + (m[y] * m[z] % MOD) % MOD);\\n            }\\n        }\\n        for (auto [_, cnt]: m)\\n            t = (t + cnt) % MOD;\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun numFactoredBinaryTrees(A: IntArray, MOD: Long = (1e9 + 7).toLong()): Int {\\n        var N = A.size\\n        var seen = A.toSet()\\n        fun go(x: Int): Long {\\n            var cnt = 1L\\n            for (y in A) {\\n                if (x % y != 0)\\n                    continue\\n                var z = x / y\\n                if (seen.contains(z))\\n                    cnt = (cnt + (go(y) * go(z) % MOD)) % MOD\\n            }\\n            return cnt\\n        }\\n        var t = 0L\\n        for (x in A)\\n            t = (t + go(x)) % MOD\\n        return t.toInt()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun numFactoredBinaryTrees(A: IntArray, MOD: Long = (1e9 + 7).toLong()): Int {\\n        var N = A.size\\n        var seen = A.toSet()\\n        var m = mutableMapOf<Int, Long>()\\n        fun go(x: Int): Long {\\n            if (!m.contains(x)) {\\n                var cnt = 1L\\n                for (y in A) {\\n                    if (x % y != 0)\\n                        continue\\n                    var z = x / y\\n                    if (seen.contains(z))\\n                        cnt = (cnt + (go(y) * go(z) % MOD)) % MOD\\n                }\\n                m[x] = cnt\\n            }\\n            return m[x]!!\\n        }\\n        var t = 0L\\n        for (x in A)\\n            t = (t + go(x)) % MOD\\n        return t.toInt()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun numFactoredBinaryTrees(A: IntArray, MOD: Long = (1e9 + 7).toLong()): Int {\\n        var N = A.size\\n        var seen = A.toSet()\\n        var m = mutableMapOf<Int, Long>()\\n        for (x in A)\\n            m[x] = 1L\\n        A.sort()\\n        for (x in A) {\\n            for (y in A) {\\n                if (x % y != 0)\\n                    continue\\n                var z = x / y\\n                if (z in seen)\\n                    m[x] = (m[x]!! + (m[y]!! * m[z]!! % MOD)) % MOD\\n            }\\n        }\\n        var t = 0L\\n        for ((_, cnt) in m)\\n            t = (t + cnt) % MOD\\n        return t.toInt()\\n    }\\n}\\n```\n```\\nlet numFactoredBinaryTrees = (A, seen = new Set(A), MOD = Number(1e9 + 7), t = 0) => {\\n    let go = x => {\\n        let cnt = 1;\\n        for (let y of A) {\\n            if (x % y)\\n                continue;\\n            let z = Math.floor(x / y);\\n            if (seen.has(z))\\n                cnt = (cnt + go(y) * go(z) % MOD) % MOD;\\n        }\\n        return cnt;\\n    };\\n    for (let x of A)\\n        t = (t + go(x)) % MOD;\\n    return t;\\n};\\n```\n```\\nlet numFactoredBinaryTrees = (A, seen = new Set(A), MOD = Number(1e9 + 7), m = new Map(), t = 0) => {\\n    let go = x => {\\n        if (!m.has(x)) {\\n            let cnt = 1;\\n            for (let y of A) {\\n                if (x % y)\\n                    continue;\\n                let z = Math.floor(x / y);\\n                if (seen.has(z))\\n                    cnt = (cnt + go(y) * go(z) % MOD) % MOD;\\n            }\\n            m.set(x, cnt);\\n        }\\n        return m.get(x);\\n    };\\n    for (let x of A)\\n        t = (t + go(x)) % MOD;\\n    return t;\\n};\\n```\n```\\nlet numFactoredBinaryTrees = (A, seen = new Set(A), MOD = Number(1e9 + 7), m = new Map(), t = 0) => {\\n    A.sort((a, b) => a - b);\\n    for (let x of A)\\n        m.set(x, 1);\\n    for (let x of A) {\\n        for (let y of A) {\\n            if (x % y)\\n                continue;\\n            let z = Math.floor(x / y);\\n            if (seen.has(z))\\n                m.set(x, m.get(x) + (m.get(y) * m.get(z) % MOD) % MOD);\\n        }\\n    }\\n    for (let [_, cnt] of m)\\n        t = (t + cnt) % MOD;\\n    return t;\\n};\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int], MOD = int(1e9 + 7), t = 0) -> int:\\n        seen = set(A)\\n        def go(x):\\n            cnt = 1\\n            for y in A:\\n                if x % y:\\n                    continue\\n                z = x // y\\n                if z in seen:\\n                    cnt = (cnt + (go(y) * go(z) % MOD)) % MOD\\n            return cnt\\n        for x in A:\\n            t = (t + go(x)) % MOD\\n        return t\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int], MOD = int(1e9 + 7), t = 0) -> int:\\n        seen = set(A)\\n        @cache\\n        def go(x):\\n            cnt = 1\\n            for y in A:\\n                if x % y:\\n                    continue\\n                z = x // y\\n                if z in seen:\\n                    cnt = (cnt + (go(y) * go(z) % MOD)) % MOD\\n            return cnt\\n        for x in A:\\n            t = (t + go(x)) % MOD\\n        return t\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int], MOD = int(1e9 + 7)) -> int:\\n        seen = set(A)\\n        m = {x: 1 for x in A}\\n        A.sort()\\n        for x in A:\\n            for y in A:\\n                if x % y:\\n                    continue\\n                z = x // y\\n                if z in seen:\\n                    m[x] = (m[x] + (m[y] * m[z] % MOD)) % MOD\\n        return sum(m.values()) % MOD\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn num_factored_binary_trees(A: VI) -> i32 {\\n        let seen: HashSet<i32> = A.clone().into_iter().collect();\\n        fn go(A: &VI, x: i32, seen: &HashSet<i32>) -> i64 {\\n            let MOD = (1e9 as i64 + 7);\\n            let mut cnt = 1 as i64;\\n            for y in A {\\n                if x % y != 0 {\\n                    continue;\\n                }\\n                let z = x / y;\\n                if seen.contains(&z) {\\n                    cnt = (cnt + go(A, *y, seen) * go(A, z, seen) % MOD) % MOD;\\n                }\\n            }\\n            return cnt;\\n        }\\n        let mut t = 0 as i64;\\n        for x in &A {\\n            t = (t + go(&A, *x, &seen)) % (1e9 as i64 + 7);\\n        }\\n        return t as i32;\\n    }\\n}\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::collections::{HashMap, HashSet};\\nimpl Solution {\\n    pub fn num_factored_binary_trees(A: VI) -> i32 {\\n        let seen: HashSet<i32> = A.clone().into_iter().collect();\\n        let mut m = HashMap::new();\\n        fn go(A: &VI, x: i32, seen: &HashSet<i32>, m: &mut HashMap<i32, i64>) -> i64 {\\n            if !m.contains_key(&x) {\\n                let MOD = (1e9 as i64 + 7);\\n                let mut cnt = 1 as i64;\\n                for y in A {\\n                    if x % y != 0 {\\n                        continue;\\n                    }\\n                    let z = x / y;\\n                    if seen.contains(&z) {\\n                        cnt = (cnt + go(A, *y, seen, m) * go(A, z, seen, m) % MOD) % MOD;\\n                    }\\n                }\\n                m.insert(x.clone(), cnt);\\n            }\\n            *m.get(&x).unwrap()\\n        }\\n        let mut t = 0 as i64;\\n        for x in &A {\\n            t = (t + go(&A, *x, &seen, &mut m)) % (1e9 as i64 + 7);\\n        }\\n        return t as i32;\\n    }\\n}\\n```\n```\\n// TODO: implement me!\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    using fun = function<LL(int)>;\\n    int numFactoredBinaryTrees(VI& A, LL MOD = 1e9 + 7, LL t = 0) {\\n        Set seen{ A.begin(), A.end() };\\n        fun go = [&](auto x) {\\n            auto cnt = 1LL;\\n            for (auto y: A) {\\n                if (x % y)\\n                    continue;\\n                auto z = x / y;\\n                if (seen.find(z) != seen.end())\\n                    cnt = (cnt + (go(y) * go(z) % MOD) % MOD);\\n            }\\n            return cnt;\\n        };\\n        for (auto x: A)\\n            t = (t + go(x)) % MOD;\\n        return t;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    using fun = function<LL(int)>;\\n    using Map = unordered_map<int, LL>;\\n    int numFactoredBinaryTrees(VI& A, LL MOD = 1e9 + 7, Map m = {}, LL t = 0) {\\n        Set seen{ A.begin(), A.end() };\\n        fun go = [&](auto x) {\\n            if (m.find(x) == m.end()) {\\n                auto cnt = 1LL;\\n                for (auto y: A) {\\n                    if (x % y)\\n                        continue;\\n                    auto z = x / y;\\n                    if (seen.find(z) != seen.end())\\n                        cnt = (cnt + (go(y) * go(z) % MOD) % MOD);\\n                }\\n                m[x] = cnt;\\n            }\\n            return m[x];\\n        };\\n        for (auto x: A)\\n            t = (t + go(x)) % MOD;\\n        return t;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    using fun = function<LL(int)>;\\n    using Map = unordered_map<int, LL>;\\n    int numFactoredBinaryTrees(VI& A, LL MOD = 1e9 + 7, Map m = {}, LL t = 0) {\\n        Set seen{ A.begin(), A.end() };\\n        sort(A.begin(), A.end());\\n        for (auto x: A)\\n            m[x] = 1LL;\\n        for (auto x: A) {\\n            for (auto y: A) {\\n                if (x % y)\\n                    continue;\\n                auto z = x / y;\\n                if (seen.find(z) != seen.end())\\n                    m[x] = (m[x] + (m[y] * m[z] % MOD) % MOD);\\n            }\\n        }\\n        for (auto [_, cnt]: m)\\n            t = (t + cnt) % MOD;\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 125815,
                "title": "java-accepted-solution",
                "content": "for num `i`, if `m * n == i`, number of trees for `i` is `1 + count(m) * count(n)`, means root `i` self, add number of trees when `m` is root times number of trees when `n` is root.\\n```\\n    public int numFactoredBinaryTrees(int[] A) {\\n        if(A==null || A.length==0)\\n            return 0;\\n        Map<Integer,Long> map = new HashMap<>();\\n        Arrays.sort(A);\\n        for(int i=0; i<A.length; i++){\\n            long count = 1;\\n            for(int j=0; j<i; j++){\\n                if(A[i]%A[j]==0 && map.containsKey(A[i]/A[j])){\\n                    count += map.get(A[i]/A[j]) * map.get(A[j]);\\n                }\\n            }\\n            map.put(A[i],count);\\n        }\\n        long sum = 0;\\n        for(long cnt : map.values())\\n            sum += cnt;\\n        return (int) (sum % (Math.pow(10,9) + 7));\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int numFactoredBinaryTrees(int[] A) {\\n        if(A==null || A.length==0)\\n            return 0;\\n        Map<Integer,Long> map = new HashMap<>();\\n        Arrays.sort(A);\\n        for(int i=0; i<A.length; i++){\\n            long count = 1;\\n            for(int j=0; j<i; j++){\\n                if(A[i]%A[j]==0 && map.containsKey(A[i]/A[j])){\\n                    count += map.get(A[i]/A[j]) * map.get(A[j]);\\n                }\\n            }\\n            map.put(A[i],count);\\n        }\\n        long sum = 0;\\n        for(long cnt : map.values())\\n            sum += cnt;\\n        return (int) (sum % (Math.pow(10,9) + 7));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2400089,
                "title": "recursive-memo-c-java-detailed-explanation",
                "content": "**C++**\\n**Recursive Solution**\\n\\n```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    unordered_set<int> st;\\nprivate:\\n    int factorCount(int root)\\n    {\\n        // count = 1 , root element will also be our one of the ans\\n        int count = 1;\\n        \\n        // iterate through set\\n        for(auto &val : st)\\n        {\\n            // check if root is divisible or not\\n            if(root % val != 0) continue;\\n            \\n            // if its divisible, call recursively for its factor\\n            int factor1 = val, factor2 = root / val;\\n            \\n            // check its factor is present in given arr\\n            if(st.count(factor2))\\n            {\\n                count += factorCount(factor1) * factorCount(factor2);\\n                count %= mod;\\n            }\\n            \\n         }\\n        \\n        return count;\\n    }\\n    \\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        st.insert(arr.begin(), arr.end());\\n        \\n        int res = 0;\\n        \\n        for(auto &curVal : arr)\\n        {\\n            // check from root to leaf\\n            // make cur val as root and find its factors i.e leaves\\n            res += factorCount(curVal);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Recursion + Memoization**\\n\\n```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    unordered_map<int, long long int> dp;\\n    unordered_set<int> st;\\nprivate:\\n    long long int factorCount(int root)\\n    {\\n        // check in dp, if count has been calculated already for this root\\n        if(dp.count(root))\\n            return dp[root];\\n        \\n        // count = 1 , root element will also be our one of the ans\\n        long long int count = 1;\\n        \\n        // iterate through set\\n        for(auto &val : st)\\n        {\\n            // check if root is divisible or not\\n            if(root % val != 0) continue;\\n            \\n            // if its divisible, call recursively for its factor\\n            int factor1 = val, factor2 = root / val;\\n            \\n            // check its factor is present in given arr\\n            if(st.count(factor2))\\n            {\\n                count += factorCount(factor1) * factorCount(factor2);\\n                count %= mod;\\n            }\\n            \\n         }\\n        \\n        return dp[root] = count;\\n    }\\n    \\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n                \\n        st.insert(arr.begin(), arr.end());\\n        \\n        int res = 0;\\n        \\n        for(auto &curVal : arr)\\n        {\\n            // check from root to leaf\\n            // make cur val as root and find its factors i.e leaves\\n            res += factorCount(curVal);\\n            res %= mod;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Java (Recursion + Memo)**\\n```\\nclass Solution {\\n    private int mod = (int) 1e9 + 7;\\n    Set<Integer> st = new HashSet<>();\\n    Map<Integer, Long> dp = new HashMap<>();\\n    \\n    \\n    private long factorCount(int root)\\n    {\\n        if(dp.containsKey(root))\\n            return dp.get(root);\\n        \\n        // considering root as well into count, so only count = 1\\n        long count = 1;\\n        \\n        for(int val : st)\\n        {\\n            // check if its divisible or not\\n            if(root % val != 0) continue;\\n            \\n            int factor1 = val, factor2 = root/val;\\n            \\n            // check factors are in set\\n            if(st.contains(factor2))\\n            {\\n                // call recursively for its factors\\n                count += factorCount(val) * factorCount(factor2);\\n                count %= mod;\\n            }\\n        }\\n        \\n        // insert into map\\n        dp.put(root, count);\\n        \\n        return count;\\n    }\\n    \\n    public int numFactoredBinaryTrees(int[] arr) {\\n        \\n        // add elements in set\\n        for(int val : arr)\\n            st.add(val);\\n        \\n        int res = 0;\\n        \\n        // iterate each element in arr, consider as root\\n        for(int curVal : arr)\\n        {\\n            res += factorCount(curVal);\\n            res %= mod;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    unordered_set<int> st;\\nprivate:\\n    int factorCount(int root)\\n    {\\n        // count = 1 , root element will also be our one of the ans\\n        int count = 1;\\n        \\n        // iterate through set\\n        for(auto &val : st)\\n        {\\n            // check if root is divisible or not\\n            if(root % val != 0) continue;\\n            \\n            // if its divisible, call recursively for its factor\\n            int factor1 = val, factor2 = root / val;\\n            \\n            // check its factor is present in given arr\\n            if(st.count(factor2))\\n            {\\n                count += factorCount(factor1) * factorCount(factor2);\\n                count %= mod;\\n            }\\n            \\n         }\\n        \\n        return count;\\n    }\\n    \\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        st.insert(arr.begin(), arr.end());\\n        \\n        int res = 0;\\n        \\n        for(auto &curVal : arr)\\n        {\\n            // check from root to leaf\\n            // make cur val as root and find its factors i.e leaves\\n            res += factorCount(curVal);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    unordered_map<int, long long int> dp;\\n    unordered_set<int> st;\\nprivate:\\n    long long int factorCount(int root)\\n    {\\n        // check in dp, if count has been calculated already for this root\\n        if(dp.count(root))\\n            return dp[root];\\n        \\n        // count = 1 , root element will also be our one of the ans\\n        long long int count = 1;\\n        \\n        // iterate through set\\n        for(auto &val : st)\\n        {\\n            // check if root is divisible or not\\n            if(root % val != 0) continue;\\n            \\n            // if its divisible, call recursively for its factor\\n            int factor1 = val, factor2 = root / val;\\n            \\n            // check its factor is present in given arr\\n            if(st.count(factor2))\\n            {\\n                count += factorCount(factor1) * factorCount(factor2);\\n                count %= mod;\\n            }\\n            \\n         }\\n        \\n        return dp[root] = count;\\n    }\\n    \\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n                \\n        st.insert(arr.begin(), arr.end());\\n        \\n        int res = 0;\\n        \\n        for(auto &curVal : arr)\\n        {\\n            // check from root to leaf\\n            // make cur val as root and find its factors i.e leaves\\n            res += factorCount(curVal);\\n            res %= mod;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private int mod = (int) 1e9 + 7;\\n    Set<Integer> st = new HashSet<>();\\n    Map<Integer, Long> dp = new HashMap<>();\\n    \\n    \\n    private long factorCount(int root)\\n    {\\n        if(dp.containsKey(root))\\n            return dp.get(root);\\n        \\n        // considering root as well into count, so only count = 1\\n        long count = 1;\\n        \\n        for(int val : st)\\n        {\\n            // check if its divisible or not\\n            if(root % val != 0) continue;\\n            \\n            int factor1 = val, factor2 = root/val;\\n            \\n            // check factors are in set\\n            if(st.contains(factor2))\\n            {\\n                // call recursively for its factors\\n                count += factorCount(val) * factorCount(factor2);\\n                count %= mod;\\n            }\\n        }\\n        \\n        // insert into map\\n        dp.put(root, count);\\n        \\n        return count;\\n    }\\n    \\n    public int numFactoredBinaryTrees(int[] arr) {\\n        \\n        // add elements in set\\n        for(int val : arr)\\n            st.add(val);\\n        \\n        int res = 0;\\n        \\n        // iterate each element in arr, consider as root\\n        for(int curVal : arr)\\n        {\\n            res += factorCount(curVal);\\n            res %= mod;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450830,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=f0mAAQqvqR8\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n#define MOD 1000000007\\nint numFactoredBinaryTrees(vector& arr) {\\nll ans =0;\\nunordered_map<ll, ll> up;\\nsort(arr.begin(), arr.end());\\nfor(int i=0; i< arr.size(); i++){\\nll currentans=1;\\nfor(int j=0; j< i; j++)\\n{\\nif(arr[i]% arr[j]) continue;\\nint ans1= arr[i]/ arr[j];\\nint ans2= arr[j];\\ncurrentans= (currentans+ up[ans1]*up[ans2]%MOD)%MOD;\\n\\n        }\\n        up[arr[i]]= currentans;\\n        ans = ans+ currentans;\\n        \\n    }\\n    return ans% MOD;\\n}\\n};\\n```\\n**JAVA**\\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>();\\n        long ans=1;\\n        map.put(arr[0],ans);\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans=ans+sum;\\n        }\\n        return (int)(ans%1000000007);\\n    }\\n}\\n```\\n**PYTHON**\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        \\n        arr.sort()\\n        MOD = 10**9 + 7\\n        \\n        # create a dictionary and initialize\\n        dp = {}\\n        for n in arr:\\n            dp[n] = 1\\n            \\n        # loop through each number\\n        for i, n in enumerate(arr):\\n            for j in range(i):\\n                if not(n % arr[j]) and n // arr[j] in dp:\\n                    dp[n] += dp[arr[j]] * dp[n//arr[j]]\\n                    dp[n] %= MOD\\n        \\n        return sum(dp.values()) % MOD\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\n#define MOD 1000000007\\nint numFactoredBinaryTrees(vector& arr) {\\nll ans =0;\\nunordered_map<ll, ll> up;\\nsort(arr.begin(), arr.end());\\nfor(int i=0; i< arr.size(); i++){\\nll currentans=1;\\nfor(int j=0; j< i; j++)\\n{\\nif(arr[i]% arr[j]) continue;\\nint ans1= arr[i]/ arr[j];\\nint ans2= arr[j];\\ncurrentans= (currentans+ up[ans1]*up[ans2]%MOD)%MOD;\\n\\n        }\\n        up[arr[i]]= currentans;\\n        ans = ans+ currentans;\\n        \\n    }\\n    return ans% MOD;\\n}\\n};\\n```\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>();\\n        long ans=1;\\n        map.put(arr[0],ans);\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans=ans+sum;\\n        }\\n        return (int)(ans%1000000007);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        \\n        arr.sort()\\n        MOD = 10**9 + 7\\n        \\n        # create a dictionary and initialize\\n        dp = {}\\n        for n in arr:\\n            dp[n] = 1\\n            \\n        # loop through each number\\n        for i, n in enumerate(arr):\\n            for j in range(i):\\n                if not(n % arr[j]) and n // arr[j] in dp:\\n                    dp[n] += dp[arr[j]] * dp[n//arr[j]]\\n                    dp[n] %= MOD\\n        \\n        return sum(dp.values()) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401118,
                "title": "c-2-approach-2-pointer-linear-and-map-find-dynamic-programming-maths",
                "content": "\\n\\nLet\\'s understand 2 basic things \\n\\n1. For any node, it can be root with total nodes in tree as 1 \\n2. If a root is having child1 and child2 as their left and right chidren then answer for that node as root of tree is 1 + (child1 as root * child2 as root)\\n\\n\\nThe basic idea is to store the no of trees that can be formed having node as the root, then we can solve the problem very easily\\nSo for any node we will find the children and update the answer as (ans(child1) * ans(child2) + 1)\\n\\nWe are adding 1 because each node can form a tree having itself as root and having no children\\n\\n**Okay so how to search the factors?**\\n\\n1. One way can be like we can create all factor pairs for the number and search it inside the map, but can you guess, how time consuming this process can be\\n2. The other way is that we can sort the array the if index i is that number, then we can clearly say that its factors lies from 0 to i-1 because any number in array greater than ith index will be greater than the number so we don\\'t need to look after that\\n\\n\\n**Now again how can we find the factors in 0 to i-1?**\\nAgain there are 2 ways\\n1. we iterate j  from  0 to i-1 and check wheather number is divided by arr[j], if it is divided then it is one of the factors then the other factor will be number / arr[j], as arr[j]*other factor = number, we find that the other factor is present in map or not\\n2. The other way is that we can have a 2-pointer search from 0 to i-1 \\n\\t\\tleft = 0 and right = i-1\\n\\t\\twe do a 2-pointer search and find that when arr[left]*arr[right] == number, then arr[left] and arr[right] are the factors \\n\\t\\there is also a crunch, in step 1 let us suppose [2, 5, 10 ], we will calculare answer for 2 and 5 saperately\\n\\t\\tbut in this case if we have child1 and child2 then we will directly multiply answer by 2 because [root, child1, child2] and [root, child2, child1] have same answer\\n\\n\\n\\nAlgorithm -\\n1. create an unordered map mp to store the answer for each particular node\\n2. sort the array for factors search\\n3. iterate the array and mp[arr[i]] = 1\\n\\tsearch the factor, if factor is fiund then update mp[arr[i]] = product of the answers of both the children for linear search and when doing 2-pointer search update the answer as mp[arr[i]] = product of answers of chilren * 2\\n\\n4. add mp[arr[i]] to answer \\n5. return answer\\n\\n\\n\\n\\n\\n\\n\\nLinear search Code\\n\\n\\n\\n```\\nclass Solution {\\n   \\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int mod = 1000000007;\\n        int n = arr.size();\\n        unordered_map<long long,long long> mp;\\n        sort(arr.begin(), arr.end());\\n        \\n        \\n        int ans = 0;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            mp[arr[i]] += 1;\\n            for(int j = 0 ; j < i ; j++){\\n                if(arr[i] % arr[j] == 0){\\n                    int child1 = arr[j];\\n                    int child2 = arr[i]/arr[j];\\n                    if(mp.find(child2) != mp.end()){\\n                        mp[arr[i]] += (mp[child1] * mp[child2])%mod;\\n                        mp[arr[i]] %= mod;\\n                    }\\n                }\\n            }\\n            ans += mp[arr[i]];\\n            ans %= mod;\\n        }\\n        \\n        return ans;\\n \\n    }\\n};\\n```\\n\\n\\n2-pointer Search Code\\n\\n```\\nclass Solution {\\n   \\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int mod = 1000000007;\\n        int n = arr.size();\\n        unordered_map<long long,long long> mp;\\n        sort(arr.begin(), arr.end());\\n        \\n        \\n        int ans = 0;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            mp[arr[i]] += 1;\\n            int left = 0;\\n            int right = i-1;\\n            \\n            while(left <= right){\\n                long long child1 = arr[left];\\n                long long child2 = arr[right];\\n                long long product = (child1 * child2);\\n                if(product == arr[i]){\\n                   if(left == right){\\n\\t\\t\\t\\t\\t   mp[arr[i]] += (mp[arr[left]] * mp[arr[right]] )%mod;   \\n                   }\\n                  else{\\n                       mp[arr[i]] += (mp[arr[left]] * mp[arr[right]] * 2)%mod;\\n                        \\n                    }\\n                  mp[arr[i]] %= mod;\\n                  left += 1;\\n                  right -= 1;\\n                }\\n                \\n             if(product < arr[i]){\\n                    left += 1;\\n             }\\n             else if(product > arr[i]){\\n                    right -= 1;\\n             }\\n           }\\n            \\n            \\n            ans += mp[arr[i]];\\n            ans %= mod;\\n        }\\n        \\n        return ans;\\n \\n    }\\n};\\n```\\nBoth the approaches have same time complexity\\n\\nTime Complexity - O(N*N) \\nSpace Complexity - O(N)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n   \\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int mod = 1000000007;\\n        int n = arr.size();\\n        unordered_map<long long,long long> mp;\\n        sort(arr.begin(), arr.end());\\n        \\n        \\n        int ans = 0;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            mp[arr[i]] += 1;\\n            for(int j = 0 ; j < i ; j++){\\n                if(arr[i] % arr[j] == 0){\\n                    int child1 = arr[j];\\n                    int child2 = arr[i]/arr[j];\\n                    if(mp.find(child2) != mp.end()){\\n                        mp[arr[i]] += (mp[child1] * mp[child2])%mod;\\n                        mp[arr[i]] %= mod;\\n                    }\\n                }\\n            }\\n            ans += mp[arr[i]];\\n            ans %= mod;\\n        }\\n        \\n        return ans;\\n \\n    }\\n};\\n```\n```\\nclass Solution {\\n   \\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int mod = 1000000007;\\n        int n = arr.size();\\n        unordered_map<long long,long long> mp;\\n        sort(arr.begin(), arr.end());\\n        \\n        \\n        int ans = 0;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            mp[arr[i]] += 1;\\n            int left = 0;\\n            int right = i-1;\\n            \\n            while(left <= right){\\n                long long child1 = arr[left];\\n                long long child2 = arr[right];\\n                long long product = (child1 * child2);\\n                if(product == arr[i]){\\n                   if(left == right){\\n\\t\\t\\t\\t\\t   mp[arr[i]] += (mp[arr[left]] * mp[arr[right]] )%mod;   \\n                   }\\n                  else{\\n                       mp[arr[i]] += (mp[arr[left]] * mp[arr[right]] * 2)%mod;\\n                        \\n                    }\\n                  mp[arr[i]] %= mod;\\n                  left += 1;\\n                  right -= 1;\\n                }\\n                \\n             if(product < arr[i]){\\n                    left += 1;\\n             }\\n             else if(product > arr[i]){\\n                    right -= 1;\\n             }\\n           }\\n            \\n            \\n            ans += mp[arr[i]];\\n            ans %= mod;\\n        }\\n        \\n        return ans;\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400129,
                "title": "c-dp-map-easy-understanding",
                "content": "````\\nclass Solution\\n{\\n    public:\\n        const int mod = 1e9 + 7;\\n    int numFactoredBinaryTrees(vector<int> &arr)\\n    {\\n        vector < long long > dp(arr.size(), 1);\\n        unordered_map<int, int> mp;\\n        sort(arr.begin(), arr.end());\\n        \\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            mp[arr[i]] = i;//store the index of various elements of the array\\n            for (int j = i - 1; j >= 0; j--)\\n            {\\n                if (arr[i] % arr[j] == 0)//to check whether arr[j] is a factor of arr[i] or not\\n                {\\n                    int temp = arr[i] / arr[j];\\n                    if (mp.count(temp)) dp[i] += (dp[j] *dp[mp[temp]]) % mod;//check the presence of the required no in map, If it is in the map then increase dp[i] by the product of the dp[j] and dp[mp[temp]] taking the modulus\\n                }\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        ans = accumulate(dp.begin(), dp.end(), 0LL);\\n        return ans%mod;//return toatl sum after taking modulus\\n    }\\n};\\n````",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution\\n{\\n    public:\\n        const int mod = 1e9 + 7;\\n    int numFactoredBinaryTrees(vector<int> &arr)\\n    {\\n        vector < long long > dp(arr.size(), 1);\\n        unordered_map<int, int> mp;\\n        sort(arr.begin(), arr.end());\\n        \\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            mp[arr[i]] = i;//store the index of various elements of the array\\n            for (int j = i - 1; j >= 0; j--)\\n            {\\n                if (arr[i] % arr[j] == 0)//to check whether arr[j] is a factor of arr[i] or not\\n                {\\n                    int temp = arr[i] / arr[j];\\n                    if (mp.count(temp)) dp[i] += (dp[j] *dp[mp[temp]]) % mod;//check the presence of the required no in map, If it is in the map then increase dp[i] by the product of the dp[j] and dp[mp[temp]] taking the modulus\\n                }\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        ans = accumulate(dp.begin(), dp.end(), 0LL);\\n        return ans%mod;//return toatl sum after taking modulus\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400037,
                "title": "c-dp-maps",
                "content": "\\t\\t// Provided logic comprises of working with factors of given number ans storing them in a hashmap which helps to achieve dynamic programming \\n\\t\\t// Initially we create a map and keep on updating frequency as 1 for all elements in the given array, indicating that every element forms an independent tree\\n\\t\\t// Further we traverse through the whole array to check the factors of the element\\n\\t\\t// If we find one factor we have to check whether there is another factor available in the given array, whose product with current factor is the current element\\n\\t\\t// If we find such a pair then we multiply number of trees of both the elements and finally multiply it with 2 becasue one node can have 2 possibilities of trees, and add it to the number of trees of current element\\n\\t\\t// Further we check whether the square root of element is there or not, if it exists then we multiply the square root with itself and add it to number of trees\\n\\t\\t// Finally we calculate total number of trees for all elements and the above dicussed logic satisfies all the test cases\\n\\t\\tint mod = 1000000007;\\n\\t\\tint numFactoredBinaryTrees(vector<int>& arr) {\\n\\t\\t\\tmap<int, long long> mp;\\n\\t\\t\\tsort(arr.begin(), arr.end());\\n\\t\\t\\tfor(auto i:arr){\\n\\t\\t\\t\\tmp[i]=1;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<arr.size();i++){\\n\\t\\t\\t\\tfor(int j=2;j<sqrt(arr[i]);j++){\\n\\t\\t\\t\\t\\tif(arr[i]%j == 0 and (j * (arr[i]/j) == arr[i])){\\n\\t\\t\\t\\t\\t\\tif(mp.find(j)!=mp.end() and mp.find(arr[i]/j)!=mp.end()){\\n\\t\\t\\t\\t\\t\\t\\tmp[arr[i]]+= (((((mp[j]%mod)*(mp[arr[i]/j]%mod))%mod)*2)%mod);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(int(sqrt(arr[i]))*int(sqrt(arr[i])) == arr[i] and mp.find(sqrt(arr[i]))!=mp.end()){\\n\\t\\t\\t\\t\\tmp[arr[i]]+= (((mp[sqrt(arr[i])]%mod)*(mp[sqrt(arr[i])])%mod)%mod);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//here int gives wrong answer since the number of trees can exceed the integer \\n\\t\\t\\tlong s = 0;\\n\\t\\t\\tfor(auto i:mp){\\n\\t\\t\\t\\ts+= (i.second);\\n\\t\\t\\t}\\n\\n\\t\\t\\t//mod of the final answer else it does not return an integer\\n\\t\\t\\treturn s%mod;\\n\\t\\t}",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "\\t\\t// Provided logic comprises of working with factors of given number ans storing them in a hashmap which helps to achieve dynamic programming \\n\\t\\t// Initially we create a map and keep on updating frequency as 1 for all elements in the given array, indicating that every element forms an independent tree\\n\\t\\t// Further we traverse through the whole array to check the factors of the element\\n\\t\\t// If we find one factor we have to check whether there is another factor available in the given array, whose product with current factor is the current element\\n\\t\\t// If we find such a pair then we multiply number of trees of both the elements and finally multiply it with 2 becasue one node can have 2 possibilities of trees, and add it to the number of trees of current element\\n\\t\\t// Further we check whether the square root of element is there or not, if it exists then we multiply the square root with itself and add it to number of trees\\n\\t\\t// Finally we calculate total number of trees for all elements and the above dicussed logic satisfies all the test cases\\n\\t\\tint mod = 1000000007;\\n\\t\\tint numFactoredBinaryTrees(vector<int>& arr) {\\n\\t\\t\\tmap<int, long long> mp;\\n\\t\\t\\tsort(arr.begin(), arr.end());\\n\\t\\t\\tfor(auto i:arr){\\n\\t\\t\\t\\tmp[i]=1;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<arr.size();i++){\\n\\t\\t\\t\\tfor(int j=2;j<sqrt(arr[i]);j++){\\n\\t\\t\\t\\t\\tif(arr[i]%j == 0 and (j * (arr[i]/j) == arr[i])){\\n\\t\\t\\t\\t\\t\\tif(mp.find(j)!=mp.end() and mp.find(arr[i]/j)!=mp.end()){\\n\\t\\t\\t\\t\\t\\t\\tmp[arr[i]]+= (((((mp[j]%mod)*(mp[arr[i]/j]%mod))%mod)*2)%mod);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(int(sqrt(arr[i]))*int(sqrt(arr[i])) == arr[i] and mp.find(sqrt(arr[i]))!=mp.end()){\\n\\t\\t\\t\\t\\tmp[arr[i]]+= (((mp[sqrt(arr[i])]%mod)*(mp[sqrt(arr[i])])%mod)%mod);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//here int gives wrong answer since the number of trees can exceed the integer \\n\\t\\t\\tlong s = 0;\\n\\t\\t\\tfor(auto i:mp){\\n\\t\\t\\t\\ts+= (i.second);\\n\\t\\t\\t}\\n\\n\\t\\t\\t//mod of the final answer else it does not return an integer\\n\\t\\t\\treturn s%mod;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2430958,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=f0mAAQqvqR8\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n#define MOD 1000000007\\nint numFactoredBinaryTrees(vector& arr) {\\nll ans =0;\\nunordered_map<ll, ll> up;\\nsort(arr.begin(), arr.end());\\nfor(int i=0; i< arr.size(); i++){\\nll currentans=1;\\nfor(int j=0; j< i; j++)\\n{\\nif(arr[i]% arr[j]) continue;\\nint ans1= arr[i]/ arr[j];\\nint ans2= arr[j];\\ncurrentans= (currentans+ up[ans1]*up[ans2]%MOD)%MOD;\\n\\n        }\\n        up[arr[i]]= currentans;\\n        ans = ans+ currentans;\\n        \\n    }\\n    return ans% MOD;\\n}\\n};\\n```\\n**JAVA**\\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>();\\n        long ans=1;\\n        map.put(arr[0],ans);\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans=ans+sum;\\n        }\\n        return (int)(ans%1000000007);\\n    }\\n}\\n```\\n**PYTHON**\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        \\n        arr.sort()\\n        MOD = 10**9 + 7\\n        \\n        # create a dictionary and initialize\\n        dp = {}\\n        for n in arr:\\n            dp[n] = 1\\n            \\n        # loop through each number\\n        for i, n in enumerate(arr):\\n            for j in range(i):\\n                if not(n % arr[j]) and n // arr[j] in dp:\\n                    dp[n] += dp[arr[j]] * dp[n//arr[j]]\\n                    dp[n] %= MOD\\n        \\n        return sum(dp.values()) % MOD\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\n#define MOD 1000000007\\nint numFactoredBinaryTrees(vector& arr) {\\nll ans =0;\\nunordered_map<ll, ll> up;\\nsort(arr.begin(), arr.end());\\nfor(int i=0; i< arr.size(); i++){\\nll currentans=1;\\nfor(int j=0; j< i; j++)\\n{\\nif(arr[i]% arr[j]) continue;\\nint ans1= arr[i]/ arr[j];\\nint ans2= arr[j];\\ncurrentans= (currentans+ up[ans1]*up[ans2]%MOD)%MOD;\\n\\n        }\\n        up[arr[i]]= currentans;\\n        ans = ans+ currentans;\\n        \\n    }\\n    return ans% MOD;\\n}\\n};\\n```\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>();\\n        long ans=1;\\n        map.put(arr[0],ans);\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans=ans+sum;\\n        }\\n        return (int)(ans%1000000007);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        \\n        arr.sort()\\n        MOD = 10**9 + 7\\n        \\n        # create a dictionary and initialize\\n        dp = {}\\n        for n in arr:\\n            dp[n] = 1\\n            \\n        # loop through each number\\n        for i, n in enumerate(arr):\\n            for j in range(i):\\n                if not(n % arr[j]) and n // arr[j] in dp:\\n                    dp[n] += dp[arr[j]] * dp[n//arr[j]]\\n                    dp[n] %= MOD\\n        \\n        return sum(dp.values()) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400249,
                "title": "c-based-on-concept-of-two-sum-really-easy-solution-fastest",
                "content": "```\\nclass Solution {\\npublic:\\n    int MOD = 1000000007;\\n    int numFactoredBinaryTrees(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        vector<long> dp(n);\\n        dp[0] = 1;\\n        int ans = 0;\\n        for (int idx = 1; idx < n; idx++)\\n        {\\n            int target = arr[idx];  //root \\n            //===========================================\\n            //EXACTLY SAME AS CONCEPT OF \"TWO SUM\" PROBLEM\\n            \\n            int i = 0, j = idx - 1; //two pointers for the \"Two product\" problem (same as Two Sum)\\n            long ways = 1;\\n            while(i <= j)\\n            {\\n                long prod = (((long)arr[i]) * (arr[j]));\\n                if (prod == target) \\n                {\\n                    if (i == j) ways += (dp[i] * dp[j]) % MOD;\\n                    else ways += ((dp[i] * dp[j]) * 2) % MOD;  \\n                    //\"*2\" becoz 1) arr[i] is left child, arr[j] is right child\\n                    //           2) arr[j] is left child, arr[i] is right child\\n                    \\n                    i++;\\n                    j--;\\n                }\\n                else if (prod < target) i++;\\n                else if (prod > target) j--;\\n            }\\n            \\n            //============================================================\\n            dp[idx] = ways;\\n            ans  = (int)((ans + dp[idx]) % MOD); //add all the cases\\n        }\\n        return ans + 1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = 1000000007;\\n    int numFactoredBinaryTrees(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        vector<long> dp(n);\\n        dp[0] = 1;\\n        int ans = 0;\\n        for (int idx = 1; idx < n; idx++)\\n        {\\n            int target = arr[idx];  //root \\n            //===========================================\\n            //EXACTLY SAME AS CONCEPT OF \"TWO SUM\" PROBLEM\\n            \\n            int i = 0, j = idx - 1; //two pointers for the \"Two product\" problem (same as Two Sum)\\n            long ways = 1;\\n            while(i <= j)\\n            {\\n                long prod = (((long)arr[i]) * (arr[j]));\\n                if (prod == target) \\n                {\\n                    if (i == j) ways += (dp[i] * dp[j]) % MOD;\\n                    else ways += ((dp[i] * dp[j]) * 2) % MOD;  \\n                    //\"*2\" becoz 1) arr[i] is left child, arr[j] is right child\\n                    //           2) arr[j] is left child, arr[i] is right child\\n                    \\n                    i++;\\n                    j--;\\n                }\\n                else if (prod < target) i++;\\n                else if (prod > target) j--;\\n            }\\n            \\n            //============================================================\\n            dp[idx] = ways;\\n            ans  = (int)((ans + dp[idx]) % MOD); //add all the cases\\n        }\\n        return ans + 1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399859,
                "title": "daily-leetcoding-challenge-august-day-9",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-trees-with-factors/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-trees-with-factors/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1109498,
                "title": "c-clear-clean-understandable-solution",
                "content": "m stores for each integer in arr the count of binarytrees\\n  that can be represented when this integer is the head\\n\\n**Python**\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        m = {}\\n        res = 0\\n        \\n        arr.sort()\\n        \\n        for head in arr:\\n            m[head] = 1\\n            for child1 in m.keys():\\n                child2 = head / child1\\n                if child2 in m:\\n                    tmp = (m[child1] * m[child2]) % mod\\n                    m[head] = (m[head] + tmp) % mod\\n                    \\n            res = (res + m[head]) % mod\\n            \\n        return res\\n```\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int mod = 1e9 + 7;\\n        unordered_map<int, int> m;\\n        int res = 0;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        for (int head : arr)\\n        {\\n            m[head] = 1;\\n            for (auto [child1, value] : m)\\n            {\\n                int child2 = head / child1;\\n                if (child1 *child2 == head && m.find(child2) != m.end())\\n                {\\n                    long tmp = ((long)m[child1] * (long)m[child2]) % mod;\\n                    m[head] = (m[head] + tmp) % mod;\\n                }\\n            }\\n            res = (res + m[head]) % mod;\\n        }\\n       \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        m = {}\\n        res = 0\\n        \\n        arr.sort()\\n        \\n        for head in arr:\\n            m[head] = 1\\n            for child1 in m.keys():\\n                child2 = head / child1\\n                if child2 in m:\\n                    tmp = (m[child1] * m[child2]) % mod\\n                    m[head] = (m[head] + tmp) % mod\\n                    \\n            res = (res + m[head]) % mod\\n            \\n        return res\\n```\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int mod = 1e9 + 7;\\n        unordered_map<int, int> m;\\n        int res = 0;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        for (int head : arr)\\n        {\\n            m[head] = 1;\\n            for (auto [child1, value] : m)\\n            {\\n                int child2 = head / child1;\\n                if (child1 *child2 == head && m.find(child2) != m.end())\\n                {\\n                    long tmp = ((long)m[child1] * (long)m[child2]) % mod;\\n                    m[head] = (m[head] + tmp) % mod;\\n                }\\n            }\\n            res = (res + m[head]) % mod;\\n        }\\n       \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107571,
                "title": "c-100-faster-95-space-efficient-easy-and-direct-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int size_ = arr.size();\\n        unordered_map<int, unsigned long long> umap_;\\n        int total = 0;\\n        int MOD = 1000000007;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 0; i < size_; i++) {\\n            int curr = arr[i];\\n            umap_[curr] = 1;\\n            for (int j = 0; j < i; j++) {\\n                if (arr[i]%arr[j] == 0) {\\n                    int a = arr[j];\\n                    int b = arr[i]/arr[j];\\n                    if (a > b) {\\n                        break;\\n                    }\\n                    else if (a == b) {\\n                        umap_[curr] += umap_[a]*umap_[a];\\n                    }\\n                    else if (umap_.count(b)) {\\n                        umap_[curr] += 2*umap_[a]*umap_[b];\\n                    }\\n                }\\n            }\\n            total = (total + umap_[curr])%MOD;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int size_ = arr.size();\\n        unordered_map<int, unsigned long long> umap_;\\n        int total = 0;\\n        int MOD = 1000000007;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 0; i < size_; i++) {\\n            int curr = arr[i];\\n            umap_[curr] = 1;\\n            for (int j = 0; j < i; j++) {\\n                if (arr[i]%arr[j] == 0) {\\n                    int a = arr[j];\\n                    int b = arr[i]/arr[j];\\n                    if (a > b) {\\n                        break;\\n                    }\\n                    else if (a == b) {\\n                        umap_[curr] += umap_[a]*umap_[a];\\n                    }\\n                    else if (umap_.count(b)) {\\n                        umap_[curr] += 2*umap_[a]*umap_[b];\\n                    }\\n                }\\n            }\\n            total = (total + umap_[curr])%MOD;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154329,
                "title": "concise-python-solution-which-beats-95",
                "content": "The idea is very simple. We can define subproblem dp[i] as the number of different trees rooted A[i]. \\nHere is the recurision formula: dp[i] = sum(dp[x] * dp[y] | x * y = i). To reduce the complexity we can only compute where x <= y, and plus x > y on the time x < y. \\n``` python\\n    def numFactoredBinaryTrees(self, A):\\n        A.sort()\\n        N = len(A)\\n        dp = {A[0]: 1}\\n        for i in range(1, N):\\n            dp[A[i]] = 1\\n            for j in range(i):\\n                div, mod = divmod(A[i], A[j])\\n                if div < A[j]: break\\n                if mod != 0: continue\\n                if div in dp: \\n                    mul = dp[div] * dp[A[j]]\\n                    dp[A[i]] += mul if div == A[j] else 2 * mul\\n                    \\n        return sum(dp.values()) % (10 ** 9 + 7)\\n```",
                "solutionTags": [],
                "code": "``` python\\n    def numFactoredBinaryTrees(self, A):\\n        A.sort()\\n        N = len(A)\\n        dp = {A[0]: 1}\\n        for i in range(1, N):\\n            dp[A[i]] = 1\\n            for j in range(i):\\n                div, mod = divmod(A[i], A[j])\\n                if div < A[j]: break\\n                if mod != 0: continue\\n                if div in dp: \\n                    mul = dp[div] * dp[A[j]]\\n                    dp[A[i]] += mul if div == A[j] else 2 * mul\\n                    \\n        return sum(dp.values()) % (10 ** 9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 143127,
                "title": "java-easy-understanding-dp-solution-with-explanation",
                "content": "Start to calculate from the smallest element to the biggest element in ```int[] A```.\\nIf there are two elements ```A[s]```, ```A[e]``` where ```A[s]*A[e] == A[i] and s<i && e<i```\\nthat means we have found ```dp[s]*dp[e]``` more trees for element ```A[i]```.\\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] A) {\\n        long res = 0L, mod = (long) 1000000007;\\n        long[] dp = new long[A.length];\\n        Arrays.fill(dp,1);\\n        Arrays.sort(A);\\n        for(int i = 1; i < A.length; i++) {\\n            int s = 0, e = i-1;\\n            while(s <= e) {\\n                if(A[s]*A[e] > A[i])e--;\\n                else if(A[s]*A[e] < A[i])s++;\\n                else {\\n                    dp[i] = ((dp[s]*dp[e]*(A[s] == A[e]? 1:2)%mod+dp[i]))%mod;\\n                    s++;\\n                }\\n            }\\n        }\\n        for(long d: dp) {\\n            res = (d+res)%mod;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```int[] A```\n```A[s]```\n```A[e]```\n```A[s]*A[e] == A[i] and s<i && e<i```\n```dp[s]*dp[e]```\n```A[i]```\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] A) {\\n        long res = 0L, mod = (long) 1000000007;\\n        long[] dp = new long[A.length];\\n        Arrays.fill(dp,1);\\n        Arrays.sort(A);\\n        for(int i = 1; i < A.length; i++) {\\n            int s = 0, e = i-1;\\n            while(s <= e) {\\n                if(A[s]*A[e] > A[i])e--;\\n                else if(A[s]*A[e] < A[i])s++;\\n                else {\\n                    dp[i] = ((dp[s]*dp[e]*(A[s] == A[e]? 1:2)%mod+dp[i]))%mod;\\n                    s++;\\n                }\\n            }\\n        }\\n        for(long d: dp) {\\n            res = (d+res)%mod;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403219,
                "title": "easy-java-solution-using-hashmap-faster-than-77-87",
                "content": "**Please Upvote if  you like this approach**\\n\\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        int mod = 1000000007;\\n        HashMap<Integer,Long>map = new HashMap<Integer,Long>();\\n        long ans = 1;\\n        map.put(arr[0],ans);\\n        for(int i = 1; i<arr.length; i++)\\n        {\\n            long sum = 1;\\n            for(int j = 0; j<i ;j++)\\n            {\\n                if(arr[i]%arr[j] == 0 && map.containsKey(arr[i]/arr[j]))\\n                    sum = sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans = ans+sum;\\n        }\\n        return (int)(ans%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        int mod = 1000000007;\\n        HashMap<Integer,Long>map = new HashMap<Integer,Long>();\\n        long ans = 1;\\n        map.put(arr[0],ans);\\n        for(int i = 1; i<arr.length; i++)\\n        {\\n            long sum = 1;\\n            for(int j = 0; j<i ;j++)\\n            {\\n                if(arr[i]%arr[j] == 0 && map.containsKey(arr[i]/arr[j]))\\n                    sum = sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans = ans+sum;\\n        }\\n        return (int)(ans%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402436,
                "title": "823-binary-trees-with-factors-in-c-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n\\t//given in problem\\n\\tconst int mod = 1e9 + 7;\\n\\tint numFactoredBinaryTrees(vector<int> &arr)\\n\\t{\\n\\t\\t//define n as zize of array\\n\\t\\tint n = arr.size();\\n\\t\\tvector < long long > dp(n, 1);\\n\\t\\tunordered_map<int, int> mp;\\n\\t\\tsort(arr.begin(), arr.end());\\n\\t\\t//iterate the loop\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\t//store the index of various elements of the array\\n\\t\\t\\tmp[arr[i]] = i;\\n\\t\\t\\tfor (int j = i - 1; j >= 0; j--)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//to check whether arr[j] is a factor of arr[i] or not\\n\\t\\t\\t\\tif (arr[i] % arr[j] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t//store to temp\\n\\t\\t\\t\\t\\tint temp = arr[i] / arr[j];\\n\\t\\t\\t\\t\\t//now check if count of temp in map exists then\\n\\t\\t\\t\\t\\tif (mp.count(temp))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t//check the presence of the required no in map,\\n\\t\\t\\t\\t\\t\\t//If it is in the map then increase dp[i] by the product of the dp[j]\\n\\t\\t\\t\\t\\t\\t//dp[mp[temp]] taking the modulus\\n\\t\\t\\t\\t\\t\\tdp[i] += (dp[j] * dp[mp[temp]]) % mod;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tlong long ans = 0;\\n\\t\\tans = accumulate(dp.begin(), dp.end(), 0LL);\\n\\t\\t//return total sum with mod\\n\\t\\treturn (ans % mod);\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t//given in problem\\n\\tconst int mod = 1e9 + 7;\\n\\tint numFactoredBinaryTrees(vector<int> &arr)\\n\\t{\\n\\t\\t//define n as zize of array\\n\\t\\tint n = arr.size();\\n\\t\\tvector < long long > dp(n, 1);\\n\\t\\tunordered_map<int, int> mp;\\n\\t\\tsort(arr.begin(), arr.end());\\n\\t\\t//iterate the loop\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\t//store the index of various elements of the array\\n\\t\\t\\tmp[arr[i]] = i;\\n\\t\\t\\tfor (int j = i - 1; j >= 0; j--)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//to check whether arr[j] is a factor of arr[i] or not\\n\\t\\t\\t\\tif (arr[i] % arr[j] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t//store to temp\\n\\t\\t\\t\\t\\tint temp = arr[i] / arr[j];\\n\\t\\t\\t\\t\\t//now check if count of temp in map exists then\\n\\t\\t\\t\\t\\tif (mp.count(temp))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t//check the presence of the required no in map,\\n\\t\\t\\t\\t\\t\\t//If it is in the map then increase dp[i] by the product of the dp[j]\\n\\t\\t\\t\\t\\t\\t//dp[mp[temp]] taking the modulus\\n\\t\\t\\t\\t\\t\\tdp[i] += (dp[j] * dp[mp[temp]]) % mod;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tlong long ans = 0;\\n\\t\\tans = accumulate(dp.begin(), dp.end(), 0LL);\\n\\t\\t//return total sum with mod\\n\\t\\treturn (ans % mod);\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401367,
                "title": "java-dp-solution-o-n-2",
                "content": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int mod = 1000000007;\\n        Map<Integer,Long>trees = new HashMap<>();\\n\\t\\tArrays.sort(arr);\\n        \\n        for (int i=0;i<arr.length;i++){\\n            long currentTreesNum=1;\\n            for (int j=0;j<i;j++){\\n                if (arr[i]%arr[j]==0 && trees.containsKey(arr[i]/arr[j])){\\n                    currentTreesNum=(currentTreesNum+(trees.get(arr[i]/arr[j])*trees.get(arr[j]))%mod)%mod;\\n                }\\n            }\\n            trees.put(arr[i], currentTreesNum);\\n        }\\n        long res = 0;\\n        for (long treeNum: trees.values())res=(res+treeNum)%mod;\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int mod = 1000000007;\\n        Map<Integer,Long>trees = new HashMap<>();\\n\\t\\tArrays.sort(arr);\\n        \\n        for (int i=0;i<arr.length;i++){\\n            long currentTreesNum=1;\\n            for (int j=0;j<i;j++){\\n                if (arr[i]%arr[j]==0 && trees.containsKey(arr[i]/arr[j])){\\n                    currentTreesNum=(currentTreesNum+(trees.get(arr[i]/arr[j])*trees.get(arr[j]))%mod)%mod;\\n                }\\n            }\\n            trees.put(arr[i], currentTreesNum);\\n        }\\n        long res = 0;\\n        for (long treeNum: trees.values())res=(res+treeNum)%mod;\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400751,
                "title": "beats-100-other-s-solutions",
                "content": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n                    A.sort()\\n                    fmap, ans = defaultdict(), 0\\n                    for num in A:\\n                        ways, lim = 1, sqrt(num)\\n                        for fA in A:\\n                            if fA > lim: break\\n                            fB = num / fA\\n                            if fB in fmap:\\n                                ways += fmap[fA] * fmap[fB] * (1 if fA == fB else 2)\\n                        fmap[num], ans = ways, (ans + ways)\\n                    return ans % 1000000007\\n            \\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n                    A.sort()\\n                    fmap, ans = defaultdict(), 0\\n                    for num in A:\\n                        ways, lim = 1, sqrt(num)\\n                        for fA in A:\\n                            if fA > lim: break\\n                            fB = num / fA\\n                            if fB in fmap:\\n                                ways += fmap[fA] * fmap[fB] * (1 if fA == fB else 2)\\n                        fmap[num], ans = ways, (ans + ways)\\n                    return ans % 1000000007\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400318,
                "title": "c-easy-solution-using-hashmap-tabulation-dp-easy-understanding",
                "content": "# **C++ Easy Solution Using Hashmap Tabulation || DP || Easy understanding**\\nPlease Consider *Upvote* if you like this Solution Thank You\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        unordered_map<long long,long long>m;\\n        sort(arr.begin(),arr.end());\\n        \\n        for(int i=0;i<n;i++)\\n            m[arr[i]]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                int val=arr[i]/arr[j];\\n                if(val*arr[j]==arr[i]&&m.count(val)){\\n                    m[arr[i]]=m[arr[i]]+(m[val]*m[arr[j]]);\\n                    \\n                }\\n            }\\n        }\\n        \\n        int sum=0;\\n        int mod=1e9+7;\\n        for(int i=0;i<n;i++)\\n            sum=(sum+m[arr[i]])%mod;\\n        return sum;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        unordered_map<long long,long long>m;\\n        sort(arr.begin(),arr.end());\\n        \\n        for(int i=0;i<n;i++)\\n            m[arr[i]]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                int val=arr[i]/arr[j];\\n                if(val*arr[j]==arr[i]&&m.count(val)){\\n                    m[arr[i]]=m[arr[i]]+(m[val]*m[arr[j]]);\\n                    \\n                }\\n            }\\n        }\\n        \\n        int sum=0;\\n        int mod=1e9+7;\\n        for(int i=0;i<n;i++)\\n            sum=(sum+m[arr[i]])%mod;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399994,
                "title": "python-dp-with-perhaps-too-detailed-explanation-99-speed",
                "content": "**[Observation 1]** \\nGiven positive integers `a`, `b`, and `c`, if `c = a * b`, then `c >= a` and `c >= b`. Thus, only larger numbers can have children consisting of smaller numbers.\\n**[Strategy 1]** \\nWe first compute the valid trees with smaller numbers as the topmost parent, then append these trees as children to a larger number and see if they remain valid. In other words: we scan from small numbers to large numbers, and at each number (outer loop), we look back and see if there were some smaller numbers (inner loop) being the divisor as our current number. Therefore it\\'s a DP problem.\\n\\n**[Observation 2]** For positive integers `a`, `b`, and `c`, if `a * b = c` and `a <= b`, then the possibilities are:\\n` 1 * b = c      ->       b = c`\\n` 2 * b = c      ->       b = c/2`\\n` 3 * b = c      ->       b = c/3`\\n` 4 * b = c      ->       b = c/4`\\n`...`\\nOf course these may not all be true, depending on whether `c` really has 2, 3, 4, ... as its divisors, but you can see besides `b = c`, the largest possible value for b is no larger than `c/2`.\\n**[Strategy 2]** Given a current number `i` (outer loop), when we look back to smaller numbers (inner loop), we skip those that are greater than `i/2`.\\n\\n**[Observation 3]** Let `c = a * b` and let the numbers of possible trees for `a` and `b` be `na` and `nb`, respectively. If `a == b`, there\\'s only one way to append the trees: append `a(==b)` to both the left and the right. The total number of possible configurations is `na * na == nb * nb`.\\nHowever if `a != b`, then there are two ways to append the `a` and `b` trees to `c`, namely (1) `a` to the left and `b` to the right and (2) `a` to the right and `b` to the left. The total number of possible ways to append is then `na * nb * 2`.\\n**[Strategy 3]** The implication is that if we have `c = a * b` and `a < b`, then we will meet `a` in our inner loop first (because `a` is smaller), and we don\\'t need to check `b` later because we already take into account the configurations including `b` when we first meet `a`. Therefore, if at some `a` we find `a > c / a`, we can break out of the inner loop to save time.\\n\\n**[Code]**\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n\\t\\t# use a hashmap to quickly look up checked numbers\\n\\t\\t# {key: value} = {n: number of trees with n as its topmost parent}\\n        d = {}\\n\\t\\t# observation 1\\n        for i in arr: # outer loop\\n\\t\\t\\t# an isolated i itself is always a valid tree\\n            d[i] = 1\\n            for j in arr: # inner loop\\n\\t\\t\\t\\t# observation 2 & 3\\n                if j == i or j > i//2+1 or j > i//j: break\\n\\t\\t\\t\\t# observation 3\\n                if i%j == 0 and i//j in d:\\n                    if j == i//j:\\n                        d[i] = d[i] + d[j]*d[i//j]\\n                    else:\\n                        d[i] = d[i] + d[j]*d[i//j]*2\\n        return sum(d.values())%(10**9+7)\\n```\\n\\nTime complexity: O(N^2)\\nSpace complexity: O(N)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n\\t\\t# use a hashmap to quickly look up checked numbers\\n\\t\\t# {key: value} = {n: number of trees with n as its topmost parent}\\n        d = {}\\n\\t\\t# observation 1\\n        for i in arr: # outer loop\\n\\t\\t\\t# an isolated i itself is always a valid tree\\n            d[i] = 1\\n            for j in arr: # inner loop\\n\\t\\t\\t\\t# observation 2 & 3\\n                if j == i or j > i//2+1 or j > i//j: break\\n\\t\\t\\t\\t# observation 3\\n                if i%j == 0 and i//j in d:\\n                    if j == i//j:\\n                        d[i] = d[i] + d[j]*d[i//j]\\n                    else:\\n                        d[i] = d[i] + d[j]*d[i//j]*2\\n        return sum(d.values())%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402508,
                "title": "c-dp-map-easy-sorting",
                "content": "\\n**Dynamic Programming and Map Approach\\nTime Complexity:- O(N*N)\\nSpace Complexity:- O(N)**\\n\\n***Note:-** In this Problem we need to calculate the factors of each numbers(which is  nothing but the leaf nodes) and checking whether its product is is equal to the values of the nodes or not. Also we need to use unordered map for storing the current values (No. of Binary trees obtained).*\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define mod 1000000007\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        // Map for checking whether the factors are present or not.\\n        unordered_map<ll,ll> mp;\\n        \\n        ll res=0;\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        for(int i=0;i<arr.size();i++){\\n            \\n            // Curr value should be 1 i.e. Leaf Node\\n            ll curr = 1;\\n            \\n            for(int j=0;j<i;j++){\\n                \\n                if((arr[i]%arr[j])>0){\\n                    continue;\\n                }\\n                \\n                ll n1 = arr[j], n2 = arr[i]/arr[j];\\n                \\n                curr = (curr + (mp[n1]*mp[n2])%mod)%mod;\\n            }\\n            \\n            //Updating the map\\n            \\n            mp[arr[i]] = curr;\\n            \\n            // Storing the number of binary trees obtained in a variable\\n            res = (res+curr)%mod;\\n        }\\n        \\n        \\n        //Returning the number of binary trees we can make \\n        \\n        return (int)res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    #define ll long long\\n    #define mod 1000000007\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        // Map for checking whether the factors are present or not.\\n        unordered_map<ll,ll> mp;\\n        \\n        ll res=0;\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        for(int i=0;i<arr.size();i++){\\n            \\n            // Curr value should be 1 i.e. Leaf Node\\n            ll curr = 1;\\n            \\n            for(int j=0;j<i;j++){\\n                \\n                if((arr[i]%arr[j])>0){\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2400611,
                "title": "with-dp-two-pointer-combinotrics-maths-and-sorting",
                "content": "```\\n Hey Guys, How are You all !!\\n\\n Lets start Today\\'s problem solution.\\n \\n => Here, we have to find total valid binary tree which must follow below condition,\\n         1) every parent is product of his child.\\n\\n => To solve this question some steps we will be following,\\n       \\n\\t   1)  sort all array .\\n\\t          reason : because every element we are choosing as a root and we are finding two \\n\\t\\t\\t  element which product is this number another reason is we have to use two \\n\\t\\t\\t  pointer to find product so we need to sort.\\n\\t\\t\\t  \\n\\t\\t2)  taverse fron first and make that node as a root node and find two element which\\n\\t\\t    product is this root so that two number can be my child.\\n\\t\\t\\t\\n\\t\\t\\t=> now we need to use dp here because we are choosing child node but we need\\n\\t\\t\\t     to consider all subtree with this child node.\\n\\t\\t\\t\\n\\t\\t\\t      suppose, we have\\n\\t\\t\\t\\t           50  as a root and 25 and 2 as a child,\\n\\t\\t\\t\\t\\t\\t  25     2    \\n\\t\\t\\t\\t\\t\\t5   5\\n\\t\\t\\t\\t\\t we are taking all combination of child like,\\n\\t\\t\\t\\t    1)  50\\n\\t\\t\\t\\t    2)   50 \\n\\t\\t\\t\\t        25   2\\n\\t\\t\\t\\t\\t3)      50 \\n\\t\\t\\t\\t\\t     25   2\\n\\t\\t\\t\\t\\t  5    5\\n\\t\\t\\t\\t\\n\\t\\t\\t 3) so  that\\'s it we have all tree count in ith node so take sum of all dp and this is\\n\\t\\t\\t     our answer\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\n\\t\\nIf you not understood so take time and dry with pen and paper run because this problem uses concept of DP, Two-pointer, Combinotrics ( Maths ) and Sorting.\\n  \\n```\\n\\n **Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9 + 7;\\n    int numFactoredBinaryTrees(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int>dp(n,1);\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int f=0,e=i-1;\\n           unsigned long long tar=nums[i];\\n            \\n            while(f<=e)\\n            { \\n               unsigned long long pro=1LL*nums[f]*nums[e];\\n                \\n                if(pro==tar){\\n                    \\n                    dp[i]=(dp[i] + (1LL*dp[f]*dp[e]))%mod;\\n                \\n                    if(f!=e){\\n                        dp[i]=(dp[i] + (1LL*dp[f]*dp[e]))%mod;\\n                    }\\n                    \\n                    f++;\\n                    e--;\\n                }else if(pro<tar)\\n                {\\n                    f++;\\n                }else{\\n                    e--;\\n                }\\n            }\\n            \\n        }\\n        \\n        int ans=0;\\n       \\n        for(int i=0;i<n;i++){\\n            ans= (ans + dp[i])%mod;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\n Hey Guys, How are You all !!\\n\\n Lets start Today\\'s problem solution.\\n \\n => Here, we have to find total valid binary tree which must follow below condition,\\n         1) every parent is product of his child.\\n\\n => To solve this question some steps we will be following,\\n       \\n\\t   1)  sort all array .\\n\\t          reason : because every element we are choosing as a root and we are finding two \\n\\t\\t\\t  element which product is this number another reason is we have to use two \\n\\t\\t\\t  pointer to find product so we need to sort.\\n\\t\\t\\t  \\n\\t\\t2)  taverse fron first and make that node as a root node and find two element which\\n\\t\\t    product is this root so that two number can be my child.\\n\\t\\t\\t\\n\\t\\t\\t=> now we need to use dp here because we are choosing child node but we need\\n\\t\\t\\t     to consider all subtree with this child node.\\n\\t\\t\\t\\n\\t\\t\\t      suppose, we have\\n\\t\\t\\t\\t           50  as a root and 25 and 2 as a child,\\n\\t\\t\\t\\t\\t\\t  25     2    \\n\\t\\t\\t\\t\\t\\t5   5\\n\\t\\t\\t\\t\\t we are taking all combination of child like,\\n\\t\\t\\t\\t    1)  50\\n\\t\\t\\t\\t    2)   50 \\n\\t\\t\\t\\t        25   2\\n\\t\\t\\t\\t\\t3)      50 \\n\\t\\t\\t\\t\\t     25   2\\n\\t\\t\\t\\t\\t  5    5\\n\\t\\t\\t\\t\\n\\t\\t\\t 3) so  that\\'s it we have all tree count in ith node so take sum of all dp and this is\\n\\t\\t\\t     our answer\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\n\\t\\nIf you not understood so take time and dry with pen and paper run because this problem uses concept of DP, Two-pointer, Combinotrics ( Maths ) and Sorting.\\n  \\n```\n```\\nclass Solution {\\npublic:\\n    int mod=1e9 + 7;\\n    int numFactoredBinaryTrees(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int>dp(n,1);\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int f=0,e=i-1;\\n           unsigned long long tar=nums[i];\\n            \\n            while(f<=e)\\n            { \\n               unsigned long long pro=1LL*nums[f]*nums[e];\\n                \\n                if(pro==tar){\\n                    \\n                    dp[i]=(dp[i] + (1LL*dp[f]*dp[e]))%mod;\\n                \\n                    if(f!=e){\\n                        dp[i]=(dp[i] + (1LL*dp[f]*dp[e]))%mod;\\n                    }\\n                    \\n                    f++;\\n                    e--;\\n                }else if(pro<tar)\\n                {\\n                    f++;\\n                }else{\\n                    e--;\\n                }\\n            }\\n            \\n        }\\n        \\n        int ans=0;\\n       \\n        for(int i=0;i<n;i++){\\n            ans= (ans + dp[i])%mod;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400058,
                "title": "python-dp-with-hash-table",
                "content": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        ans = 0\\n        dp = {}\\n        for n in arr:\\n            temp = 1\\n            for k in dp.keys():\\n                if n%k==0 and n//k in dp:\\n                    temp+=dp[k]*dp[n//k]\\n            ans+= temp\\n            dp[n] = temp\\n        return ans%(10**9+7)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        ans = 0\\n        dp = {}\\n        for n in arr:\\n            temp = 1\\n            for k in dp.keys():\\n                if n%k==0 and n//k in dp:\\n                    temp+=dp[k]*dp[n//k]\\n            ans+= temp\\n            dp[n] = temp\\n        return ans%(10**9+7)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399914,
                "title": "python-3-as-short-as-it-gets-o-n-2-98-time-90-memory",
                "content": "This is as short as I could get my code: \\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        mod = 1000 * 1000 * 1000 + 7\\n        arr =sorted(arr)\\n        dp = {a:1 for a in arr}\\n            \\n        for i,a in enumerate(arr):\\n            for j in range(i):\\n                b, c = arr[j], a//arr[j]\\n                if c < b:\\n                    break\\n                if a % b != 0 or c not in dp:\\n                    continue\\n                add = dp[b] * dp[c]\\n                dp[a] += add if b == c else 2 * add\\n            dp[a] = dp[a] % mod\\n        return sum(dp.values()) % mod\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        mod = 1000 * 1000 * 1000 + 7\\n        arr =sorted(arr)\\n        dp = {a:1 for a in arr}\\n            \\n        for i,a in enumerate(arr):\\n            for j in range(i):\\n                b, c = arr[j], a//arr[j]\\n                if c < b:\\n                    break\\n                if a % b != 0 or c not in dp:\\n                    continue\\n                add = dp[b] * dp[c]\\n                dp[a] += add if b == c else 2 * add\\n            dp[a] = dp[a] % mod\\n        return sum(dp.values()) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639558,
                "title": "c-dp-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n         sort(arr.begin(),arr.end());\\n         int mod = 1e9 + 7;\\n        map<int, long long> mp;\\n        \\n        for(int i=0; i<arr.size(); i++){\\n              mp[arr[i]] = 1;\\n            for(int j=0; j<i; j++){\\n                if(arr[i] % arr[j] == 0){\\n                    mp[arr[i]] += (long long)(mp[arr[j]] * mp[arr[i] / arr[j]]) % mod;\\n                    mp[arr[i]] %= mod;\\n                }\\n            }\\n        }\\n          long long ans = 0;\\n        \\n        for(auto it = mp.begin(); it!=mp.end(); it++){\\n             ans= (ans + it->second)  % mod;\\n        }\\n           return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n         sort(arr.begin(),arr.end());\\n         int mod = 1e9 + 7;\\n        map<int, long long> mp;\\n        \\n        for(int i=0; i<arr.size(); i++){\\n              mp[arr[i]] = 1;\\n            for(int j=0; j<i; j++){\\n                if(arr[i] % arr[j] == 0){\\n                    mp[arr[i]] += (long long)(mp[arr[j]] * mp[arr[i] / arr[j]]) % mod;\\n                    mp[arr[i]] %= mod;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1108175,
                "title": "java-simple-and-easy-to-understand-solution-using-dp-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    static int MOD = 1_000_000_007;\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int n = arr.length;\\n        \\n        Arrays.sort(arr);\\n        \\n        //consider as root for each number\\n        //save the count of BT\\n        long[] dp = new long[n];\\n        Arrays.fill(dp, 1);\\n        \\n        //num to index mapping\\n        Map<Integer, Integer> mapIndex = new HashMap();\\n        for(int i = 0; i < n; i++)\\n            mapIndex.put(arr[i], i);\\n        \\n        for(int rootIndex = 0; rootIndex < n; rootIndex++){\\n            int root = arr[rootIndex];\\n            \\n            for(int leftIndex = 0; leftIndex < rootIndex; leftIndex++){\\n                int left = arr[leftIndex];\\n                \\n                if(root % left == 0){\\n                    int right = root / left;\\n                    \\n                    if(mapIndex.containsKey(right)){\\n                        int rightIndex = mapIndex.get(right);\\n                        \\n                        dp[rootIndex] = (dp[rootIndex] + (dp[leftIndex] * dp[rightIndex])) % MOD; \\n                    }\\n                }\\n            }\\n        }\\n        \\n        //count all the trees\\n        long counts = 0;\\n        for(long count : dp) counts += count;\\n        \\n        \\n        return (int) (counts % MOD);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    static int MOD = 1_000_000_007;\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int n = arr.length;\\n        \\n        Arrays.sort(arr);\\n        \\n        //consider as root for each number\\n        //save the count of BT\\n        long[] dp = new long[n];\\n        Arrays.fill(dp, 1);\\n        \\n        //num to index mapping\\n        Map<Integer, Integer> mapIndex = new HashMap();\\n        for(int i = 0; i < n; i++)\\n            mapIndex.put(arr[i], i);\\n        \\n        for(int rootIndex = 0; rootIndex < n; rootIndex++){\\n            int root = arr[rootIndex];\\n            \\n            for(int leftIndex = 0; leftIndex < rootIndex; leftIndex++){\\n                int left = arr[leftIndex];\\n                \\n                if(root % left == 0){\\n                    int right = root / left;\\n                    \\n                    if(mapIndex.containsKey(right)){\\n                        int rightIndex = mapIndex.get(right);\\n                        \\n                        dp[rootIndex] = (dp[rootIndex] + (dp[leftIndex] * dp[rightIndex])) % MOD; \\n                    }\\n                }\\n            }\\n        }\\n        \\n        //count all the trees\\n        long counts = 0;\\n        for(long count : dp) counts += count;\\n        \\n        \\n        return (int) (counts % MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107566,
                "title": "cpp-easy-solution-o-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1)\\n            return 1;\\n        sort(arr.begin(),arr.end());\\n        map<int,long>m1;\\n        for(int a:arr)\\n        {\\n            m1[a]=1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(arr[i]%arr[j]==0)\\n                {\\n                    int r=arr[i]/arr[j];\\n                    if(m1[r]>0)\\n                    {\\n                        m1[arr[i]]+=m1[arr[j]]*m1[r];\\n                    }\\n                }\\n            }\\n        }\\n        long  int sum=0;\\n        for(auto it:m1)\\n        {\\n            sum+=it.second;\\n        }\\n        return int(sum%1000000007);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1)\\n            return 1;\\n        sort(arr.begin(),arr.end());\\n        map<int,long>m1;\\n        for(int a:arr)\\n        {\\n            m1[a]=1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(arr[i]%arr[j]==0)\\n                {\\n                    int r=arr[i]/arr[j];\\n                    if(m1[r]>0)\\n                    {\\n                        m1[arr[i]]+=m1[arr[j]]*m1[r];\\n                    }\\n                }\\n            }\\n        }\\n        long  int sum=0;\\n        for(auto it:m1)\\n        {\\n            sum+=it.second;\\n        }\\n        return int(sum%1000000007);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107431,
                "title": "java-short-and-crisp-using-dp-two-pointer-approach",
                "content": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        int n = arr.length ,mod = 1_000_000_007;\\n        long res=0, ways[] = new long[n];\\n        \\n        for(int i=0,l=0,r=0 ;i<n; i++){\\n            ways[i] = 1;\\n            //Two-poitner Approach\\n            l = 0; r = i-1;\\n            while(l <= r){\\n\\t\\t\\t/*Instead of checking arr[l]*arr[r] == arr[i], to prevent overflow\\n\\t\\t\\tuse arr[l] == arr[i]/arr[r]. */\\n                if( arr[l]*1.0 == arr[i]*1.0/arr[r]){         \\n                    ways[i] += ways[l]*ways[r]*( l==r ? 1 : 2 );\\n                    l++;r--;\\n                }\\n                else if ( arr[l]*1.0 > arr[i]*1.0/arr[r]) r--;\\n                else l++;\\n            }\\n            res = (res+ways[i]) % mod;\\n        }\\n        \\n        return (int)res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        int n = arr.length ,mod = 1_000_000_007;\\n        long res=0, ways[] = new long[n];\\n        \\n        for(int i=0,l=0,r=0 ;i<n; i++){\\n            ways[i] = 1;\\n            //Two-poitner Approach\\n            l = 0; r = i-1;\\n            while(l <= r){\\n\\t\\t\\t/*Instead of checking arr[l]*arr[r] == arr[i], to prevent overflow\\n\\t\\t\\tuse arr[l] == arr[i]/arr[r]. */\\n                if( arr[l]*1.0 == arr[i]*1.0/arr[r]){         \\n                    ways[i] += ways[l]*ways[r]*( l==r ? 1 : 2 );\\n                    l++;r--;\\n                }\\n                else if ( arr[l]*1.0 > arr[i]*1.0/arr[r]) r--;\\n                else l++;\\n            }\\n            res = (res+ways[i]) % mod;\\n        }\\n        \\n        return (int)res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107384,
                "title": "why-is-sorting-required-here",
                "content": "Why do so many solutions use sorting here? My code works fine without sorting. Whats the need for sorting at all?\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        \\n        \\n        MOD = 10**9+7\\n        nodes = set(arr)\\n        \\n        @lru_cache(None)\\n        def rootTree(rootVal):\\n            \\n            count = 1\\n            for left in nodes:\\n                if rootVal%left == 0:\\n                    right = rootVal // left\\n                    if right in nodes:\\n                        count += rootTree(left)*rootTree(right)\\n                        \\n            return count\\n        \\n        \\n        count = 0\\n        for x in arr:\\n            count+=rootTree(x)\\n            \\n        return count % MOD\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        \\n        \\n        MOD = 10**9+7\\n        nodes = set(arr)\\n        \\n        @lru_cache(None)\\n        def rootTree(rootVal):\\n            \\n            count = 1\\n            for left in nodes:\\n                if rootVal%left == 0:\\n                    right = rootVal // left\\n                    if right in nodes:\\n                        count += rootTree(left)*rootTree(right)\\n                        \\n            return count\\n        \\n        \\n        count = 0\\n        for x in arr:\\n            count+=rootTree(x)\\n            \\n        return count % MOD\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 934727,
                "title": "python3-two-approaches",
                "content": "Approach 1 - priority queue \\nThe essential argument is that if we find `x*y = z` in `A`, then `cnt[z] += cnt[x]*cnt[y]`. One caveat is that we have to process from small value to large value to make sure that when updating `z` the count of `x` and `y` are already accurate. \\n\\nOne straightforward approach is to use a priority queue to store `(z, x, y)` triplet, and process them one by one. \\n\\nImplementation \\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n        As = set(A) # set for O(1) lookup \\n        pq = [] # min heap \\n        for x, y in product(A, A): \\n            if x*y in As: heappush(pq, (x*y, x, y))\\n        \\n        cnt = {x: 1 for x in A}\\n        while pq: \\n            z, x, y = heappop(pq)\\n            cnt[z] += cnt[x] * cnt[y]\\n        \\n        return sum(cnt.values()) % 1_000_000_007\\n```\\n\\nAnalysis\\nTime complexity `O(N^2)` on the assumption that `pq` is `O(N)`\\nSpace complexity `O(N)` \\n\\nApproach 2 - greedy \\nWe can solve this problem more directly via greedy approach. Scan through `A` from smallest to largest and collect its count. \\n\\nImplementation \\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n        cnt = {}\\n        for x in sorted(A): \\n            cnt[x] = 1 + sum(cnt[xx]*cnt[x//xx] for xx in cnt if not x%xx and x//xx in cnt)\\n        return sum(cnt.values()) % 1_000_000_007\\n```\\n\\nAnalysis\\nTime complexity `O(N^2)`\\nSpace complexity `O(N)`\\n\\nEdited on 3/13/2021\\nAdding an easier to follow implementation\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        freq = {}\\n        for x in sorted(arr): \\n            freq[x] = 1\\n            for xx in freq: \\n                freq[x] += freq[xx] * freq.get(x/xx, 0)\\n        return sum(freq.values()) % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n        As = set(A) # set for O(1) lookup \\n        pq = [] # min heap \\n        for x, y in product(A, A): \\n            if x*y in As: heappush(pq, (x*y, x, y))\\n        \\n        cnt = {x: 1 for x in A}\\n        while pq: \\n            z, x, y = heappop(pq)\\n            cnt[z] += cnt[x] * cnt[y]\\n        \\n        return sum(cnt.values()) % 1_000_000_007\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A: List[int]) -> int:\\n        cnt = {}\\n        for x in sorted(A): \\n            cnt[x] = 1 + sum(cnt[xx]*cnt[x//xx] for xx in cnt if not x%xx and x//xx in cnt)\\n        return sum(cnt.values()) % 1_000_000_007\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        freq = {}\\n        for x in sorted(arr): \\n            freq[x] = 1\\n            for xx in freq: \\n                freq[x] += freq[xx] * freq.get(x/xx, 0)\\n        return sum(freq.values()) % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 682191,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    private static final long MOD = (long) 1e9 + 7;\\n    \\n    public int numFactoredBinaryTrees(int[] A) {\\n        Arrays.sort(A);\\n        int n = A.length;\\n        Map<Integer, Long> dp = new HashMap<>();\\n\\n        long answer = 0;\\n        for (int num : A) {\\n            dfs(dp, A, num);\\n            answer = (answer + dp.get(num)) % MOD;\\n        }\\n        \\n        return (int) answer;\\n    }\\n    \\n    private long dfs(Map<Integer, Long> dp, int[] A, int cur) {\\n        if (cur < 0) {\\n            return 0;\\n        }\\n        \\n        if (cur == 1) {\\n            return 1;\\n        }\\n        \\n        if (dp.containsKey(cur)) {\\n            return dp.get(cur);\\n        }\\n        \\n        long answer = 0;\\n        for (int num : A) {\\n            if (cur % num == 0) {\\n                int quotient = cur / num;\\n                \\n                if (quotient == 1) {\\n                    answer = (answer + 1) % MOD;\\n                } else if (Arrays.binarySearch(A, quotient) >= 0) {\\n                    answer = (answer + dfs(dp, A, quotient) * dfs(dp, A, num)) % MOD;\\n                }\\n            }\\n        }\\n        \\n        dp.put(cur, answer);\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final long MOD = (long) 1e9 + 7;\\n    \\n    public int numFactoredBinaryTrees(int[] A) {\\n        Arrays.sort(A);\\n        int n = A.length;\\n        Map<Integer, Long> dp = new HashMap<>();\\n\\n        long answer = 0;\\n        for (int num : A) {\\n            dfs(dp, A, num);\\n            answer = (answer + dp.get(num)) % MOD;\\n        }\\n        \\n        return (int) answer;\\n    }\\n    \\n    private long dfs(Map<Integer, Long> dp, int[] A, int cur) {\\n        if (cur < 0) {\\n            return 0;\\n        }\\n        \\n        if (cur == 1) {\\n            return 1;\\n        }\\n        \\n        if (dp.containsKey(cur)) {\\n            return dp.get(cur);\\n        }\\n        \\n        long answer = 0;\\n        for (int num : A) {\\n            if (cur % num == 0) {\\n                int quotient = cur / num;\\n                \\n                if (quotient == 1) {\\n                    answer = (answer + 1) % MOD;\\n                } else if (Arrays.binarySearch(A, quotient) >= 0) {\\n                    answer = (answer + dfs(dp, A, quotient) * dfs(dp, A, num)) % MOD;\\n                }\\n            }\\n        }\\n        \\n        dp.put(cur, answer);\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412600,
                "title": "c-dp-using-unordered-map",
                "content": "```\\nint numFactoredBinaryTrees(vector<int>& A) {\\n        int n = A.size();\\n        if(n==0) return 0;\\n        unordered_map<int,long long int> dp; // key is the product, value is the count\\n        sort(A.begin(), A.end());\\n        dp[A[0]] = 1;\\n        for(int i=1; i<n; i++) {\\n            dp[A[i]] = 1;\\n            for(auto it=dp.begin(); it!=dp.end(); it++) {\\n                int p1 = it->first;\\n                if(A[i] % p1 != 0) continue;\\n                int p2 = A[i] / p1;\\n                if(!dp.count(p2)) continue;\\n                dp[A[i]] += it->second * dp[p2];\\n                dp[A[i]] %= 1000000007;\\n            }\\n        }\\n        int res = 0;\\n        for(auto it=dp.begin(); it!=dp.end(); it++) {\\n            res += it->second;\\n            res %= 1000000007;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint numFactoredBinaryTrees(vector<int>& A) {\\n        int n = A.size();\\n        if(n==0) return 0;\\n        unordered_map<int,long long int> dp; // key is the product, value is the count\\n        sort(A.begin(), A.end());\\n        dp[A[0]] = 1;\\n        for(int i=1; i<n; i++) {\\n            dp[A[i]] = 1;\\n            for(auto it=dp.begin(); it!=dp.end(); it++) {\\n                int p1 = it->first;\\n                if(A[i] % p1 != 0) continue;\\n                int p2 = A[i] / p1;\\n                if(!dp.count(p2)) continue;\\n                dp[A[i]] += it->second * dp[p2];\\n                dp[A[i]] %= 1000000007;\\n            }\\n        }\\n        int res = 0;\\n        for(auto it=dp.begin(); it!=dp.end(); it++) {\\n            res += it->second;\\n            res %= 1000000007;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 203398,
                "title": "cleaar-dp-python-solution",
                "content": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A):\\n        A.sort()\\n        dp = collections.Counter()\\n        for i,num in enumerate(A):\\n            dp[num] = 1\\n            for j in range(i):\\n                if num % A[j] == 0:\\n                    dp[num] += dp[A[j]] * dp[num/A[j]]\\n            s += dp[num]\\n        return s % (10**9 + 7)\\n                    \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A):\\n        A.sort()\\n        dp = collections.Counter()\\n        for i,num in enumerate(A):\\n            dp[num] = 1\\n            for j in range(i):\\n                if num % A[j] == 0:\\n                    dp[num] += dp[A[j]] * dp[num/A[j]]\\n            s += dp[num]\\n        return s % (10**9 + 7)\\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 187964,
                "title": "c-dp-solution-with-two-pointer",
                "content": "Use two pointer to find out all combinations that product is A[i].\n```\nclass Solution {\npublic:\n    int numFactoredBinaryTrees(vector<int>& A) {\n        long mod = 1000000007;\n        sort(A.begin(), A.end());\n        vector<long> dp(A.size());\n        \n        int result = 0;\n        for (int i = 0; i < dp.size(); ++i) {\n            dp[i] = 1;\n            int begin = 0;\n            int end = i-1;\n            while (begin <= end) {\n                if (A[begin]*A[end] > A[i]) {\n                    end--;\n                } else if (A[begin]*A[end] < A[i]) {\n                    begin++;\n                } else {\n                    dp[i] = (dp[i] + (dp[begin]*dp[end])*(begin == end ? 1 : 2)) % mod;\n                    begin++;\n                }\n            }\n            result  = (result + dp[i]) % mod;\n        }\n        return result;\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    int numFactoredBinaryTrees(vector<int>& A) {\n        long mod = 1000000007;\n        sort(A.begin(), A.end());\n        vector<long> dp(A.size());\n        \n        int result = 0;\n        for (int i = 0; i < dp.size(); ++i) {\n            dp[i] = 1;\n            int begin = 0;\n            int end = i-1;\n            while (begin <= end) {\n                if (A[begin]*A[end] > A[i]) {\n                    end--;\n                } else if (A[begin]*A[end] < A[i]) {\n                    begin++;\n                } else {\n                    dp[i] = (dp[i] + (dp[begin]*dp[end])*(begin == end ? 1 : 2)) % mod;\n                    begin++;\n                }\n            }\n            result  = (result + dp[i]) % mod;\n        }\n        return result;\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403437,
                "title": "c-hashmap-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        long ans=0;\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,long> rootWithCount;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            long currentAns = 1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j])\\n                    continue;\\n                \\n                int a = arr[i]/arr[j];\\n                int b = arr[j];\\n                \\n                currentAns = (currentAns + rootWithCount[a]*rootWithCount[b]%MOD)%MOD;\\n            }\\n            rootWithCount[arr[i]] = currentAns;\\n            ans += currentAns;\\n        }\\n        return ans%MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        long ans=0;\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,long> rootWithCount;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            long currentAns = 1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j])\\n                    continue;\\n                \\n                int a = arr[i]/arr[j];\\n                int b = arr[j];\\n                \\n                currentAns = (currentAns + rootWithCount[a]*rootWithCount[b]%MOD)%MOD;\\n            }\\n            rootWithCount[arr[i]] = currentAns;\\n            ans += currentAns;\\n        }\\n        return ans%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403334,
                "title": "c-simplified-solution-using-dp-c-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        long long n=arr.size();\\n        long long mod=1e9+7;\\n        vector<int> ans(n, 1);\\n        sort(arr.begin(), arr.end());\\n        long long ans1=0;\\n        for(int i=0; i<n; i++){\\n            int in=0, en=i;\\n            int k=0;\\n            while(in<i && en>=0){\\n                if((long long)arr[in]*arr[en]==arr[i]){\\n                    long long k=(long long)ans[in]*ans[en]; k%=mod;\\n                    ans[i]+=k;\\n                    ans[i]%=mod;\\n                    in++; en--;\\n                }\\n                else if((long long)arr[in]*arr[en]>arr[i]){\\n                    en--;\\n                }\\n                else in++;\\n            } \\n        }\\n        for(int i=0; i<n; i++){ \\n            ans1+=ans[i];\\n            ans1%=mod;\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        long long n=arr.size();\\n        long long mod=1e9+7;\\n        vector<int> ans(n, 1);\\n        sort(arr.begin(), arr.end());\\n        long long ans1=0;\\n        for(int i=0; i<n; i++){\\n            int in=0, en=i;\\n            int k=0;\\n            while(in<i && en>=0){\\n                if((long long)arr[in]*arr[en]==arr[i]){\\n                    long long k=(long long)ans[in]*ans[en]; k%=mod;\\n                    ans[i]+=k;\\n                    ans[i]%=mod;\\n                    in++; en--;\\n                }\\n                else if((long long)arr[in]*arr[en]>arr[i]){\\n                    en--;\\n                }\\n                else in++;\\n            } \\n        }\\n        for(int i=0; i<n; i++){ \\n            ans1+=ans[i];\\n            ans1%=mod;\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402041,
                "title": "java-solution-easy-to-understand-hapmap-dp-38-ms-solution-inline-comments",
                "content": "**Java Hapmap | 38ms solution**\\n\\n\\n```\\n public int numFactoredBinaryTrees(int[] arr) {\\n        //sort the arr first \\n        int MOD=1000000007;//get mod because of ans to long\\n         Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>(); // declare map to keep track of arr value and they sum \\n        long ans=1;\\n        map.put(arr[0],ans); //key=2,vaule=1;\\n        for(int i=1;i<arr.length;i++)//i=1\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)//j=0\\n            {\\n                if(arr[i]%arr[j]==0 &&map.containsKey(arr[i]/arr[j]))\\n                    //(4%2==0&&keyinmap(4/2=2))ture\\n                    sum+=(map.get(arr[i]/arr[j])*map.get(arr[j]));//sum=(1*1)+1=2\\n            }\\n            map.put(arr[i],sum);//key=4,2\\n            ans+=sum;//3\\n        }\\n        return (int)(ans%MOD);//3%MOD\\n\\t\\t}\\n```\\n**TC : O(N^2)**\\n**SC: O(N)**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n public int numFactoredBinaryTrees(int[] arr) {\\n        //sort the arr first \\n        int MOD=1000000007;//get mod because of ans to long\\n         Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>(); // declare map to keep track of arr value and they sum \\n        long ans=1;\\n        map.put(arr[0],ans); //key=2,vaule=1;\\n        for(int i=1;i<arr.length;i++)//i=1\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)//j=0\\n            {\\n                if(arr[i]%arr[j]==0 &&map.containsKey(arr[i]/arr[j]))\\n                    //(4%2==0&&keyinmap(4/2=2))ture\\n                    sum+=(map.get(arr[i]/arr[j])*map.get(arr[j]));//sum=(1*1)+1=2\\n            }\\n            map.put(arr[i],sum);//key=4,2\\n            ans+=sum;//3\\n        }\\n        return (int)(ans%MOD);//3%MOD\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2402035,
                "title": "detailed-explanation-with-example-and-code-c-dp",
                "content": "Let\\'s say that **A** is a number that can be represented as\\n\\n**A = B * C** \\n**A = D * D**\\n**A = C * B**\\n\\nand The array **arr[]** contains all the numbers A,B,C, and D.  Now ,\\n\\n**N(A)** = Number of binary trees which has root node A\\n**N(B)** = Number of binary trees which has root node B\\n**N(C)** = Number of binary trees which has root node C\\n**N(D)** = Number of binary trees which has root node D\\n**N(T)** = Total Number of Nodes\\n\\n***N(A) = ( N(B)  N(C) )  + ( N(D)  N(D) )  +  ( N(C)  N(B) ) + 1 .  .... (1)***\\n\\n**N(B) * N(C)** now equals **N(C) * N(B)**. Therefore, the only thing we can do is multiply N(B) * N(C) by 2 .\\xA0 Equation (1) can therefore be expressed as\\n\\n***N(A) = ( N(B)  N(C) )  2  + ( N(D)  N(D) )  + 1 .  .... (2)***\\n\\n* If the left and right nodes are not the same, we can state that their product will be multiplied by two and added to the result.\\n* If the left and right nodes are not the same, we can state that their product will be multiplied by one and added to the result.\\n* 1 will be added to the answer because every node itself is a tree with one node only. \\n\\nTotal number of Nodes will be \\n**N(T) = N(A) + N(B) + N(C) + N(D)** \\n\\n\\nLet us apply the above formula for arr = [ 2, 4 , 8 , 16 ]\\n\\n* **2** : we will get only one binary tree  so , N(2) = 1  \\n* **4** :  4 = 2 * 2 .  As we know N(2) = 1  and here both the factors are same so we will multiply their product by 1 and add to the answer .  so, N(4) = ( N(2) * N(2) ) * 1 + 1 = (1 * 1) * 1 + 1 = 2 \\n* **8**:  8 = 2 * 4 .  as we know N(4) = 2 , N(2) = 1 and here both the factors are different so we will multiply their product by 2 and add to the answer. so, N(8) = ( (N(2) * N(4) ) * 2 + 1 = 5 .  now 8 can be also written as 8 = 4 * 2 . However, as we previously stated, we would only select one combination between (2, 4) and (4, 2), thus we multiplied the product of N(2) and N(4) by 2.  \\n* **16**: 16 = 4 * 4 and 16 = 2 * 8 . so we can say , N(16) = N(4) * N(4) * 1 + N(2) * N ( 8) * 2 + 1 = 2 * 2 * 1 + 5 * 1 * 2 + 1 = 15 . \\n\\nHere are the trees which have 2,4 and 8 as their root node respectively ,\\n\\n![image](https://assets.leetcode.com/users/images/d6ff0304-571c-4f24-9051-8f2c59873316_1660044028.5125227.png)\\nnow **N(T) = N(16) + N(8) + N(4) + N(2) = 15 + 5 + 2 + 1 = 23**\\n\\nRecursive DP Solution : \\n\\n```\\nclass Solution {\\npublic:\\n    map<int,int> factor;\\n    int MOD = 1e9 + 7 ;\\n    void setUp(vector<int>& arr) {\\n        for ( int i = 0 ; i < arr.size() ; i++) factor[arr[i]] = i+1 ;\\n    }\\n\\n    int solution(vector<int>& arr, vector<int>& dp, int index) {\\n        if ( index < 0) return 0 ;\\n        if ( dp[index] != -1) return dp[index];\\n        dp[index] = 1 ;\\n        for ( int i = 2 ; i*i <= arr[index] ; i++ ) {\\n            if ( arr[index] % i == 0 && factor[i] && factor[arr[index]/i]) {\\n                long long way1 = solution(arr,dp,factor[i]-1)%MOD;\\n                long long way2 = solution(arr,dp,factor[arr[index]/i]-1)%MOD;\\n                long long prod = (way1*way2)%MOD ;\\n                if ( i == arr[index]/i) dp[index] += prod;\\n                else dp[index] += ((2*prod)%MOD) ;\\n                dp[index] = dp[index]%MOD;\\n            }\\n        }\\n        return dp[index]%MOD;\\n    }\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        setUp(arr);\\n        vector <int> dp (arr.size()+2,-1);\\n        long long ans = 0 ;\\n        for ( int i = arr.size()-1 ; i >= 0 ; i-- ) ans += ((solution(arr,dp,i)%MOD)%MOD) ;   \\n        return ans%MOD ;\\n    }\\n};\\n```\\nNow let me explain some of lines of my code : \\n\\n* Suppose A = B * C and A = C * B ( Here, B < C ) line below will take only the pair B * C in count . \\n  \\n  ```\\n       for ( int i = 2 ; i*i <= arr[index] ; i++ )\\n  ```\\n*  Suppose A = D * D then we will mutiply N(D) * N (D) by 1 and if A = B * C then we will multiply N(B) * N(C) by 2 .\\n    ```\\n        if ( i == arr[index]/i) dp[index] += prod;\\n        else dp[index] += ((2*prod)%MOD) ;\\n    ```\\n\\n*  Every Node itself is a binary tree .\\n    ```\\n        dp[index] = 1 \\n   ```\\n\\n*  Let Us check if both the factors are presented in the array arr[] with the help of map which we constructed  . \\n   ```\\n      if ( arr[index] % i == 0 && factor[i] && factor[arr[index]/i])\\n   ```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int> factor;\\n    int MOD = 1e9 + 7 ;\\n    void setUp(vector<int>& arr) {\\n        for ( int i = 0 ; i < arr.size() ; i++) factor[arr[i]] = i+1 ;\\n    }\\n\\n    int solution(vector<int>& arr, vector<int>& dp, int index) {\\n        if ( index < 0) return 0 ;\\n        if ( dp[index] != -1) return dp[index];\\n        dp[index] = 1 ;\\n        for ( int i = 2 ; i*i <= arr[index] ; i++ ) {\\n            if ( arr[index] % i == 0 && factor[i] && factor[arr[index]/i]) {\\n                long long way1 = solution(arr,dp,factor[i]-1)%MOD;\\n                long long way2 = solution(arr,dp,factor[arr[index]/i]-1)%MOD;\\n                long long prod = (way1*way2)%MOD ;\\n                if ( i == arr[index]/i) dp[index] += prod;\\n                else dp[index] += ((2*prod)%MOD) ;\\n                dp[index] = dp[index]%MOD;\\n            }\\n        }\\n        return dp[index]%MOD;\\n    }\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        setUp(arr);\\n        vector <int> dp (arr.size()+2,-1);\\n        long long ans = 0 ;\\n        for ( int i = arr.size()-1 ; i >= 0 ; i-- ) ans += ((solution(arr,dp,i)%MOD)%MOD) ;   \\n        return ans%MOD ;\\n    }\\n};\\n```\n```\\n       for ( int i = 2 ; i*i <= arr[index] ; i++ )\\n  ```\n```\\n        if ( i == arr[index]/i) dp[index] += prod;\\n        else dp[index] += ((2*prod)%MOD) ;\\n    ```\n```\\n        dp[index] = 1 \\n   ```\n```\\n      if ( arr[index] % i == 0 && factor[i] && factor[arr[index]/i])\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 2401937,
                "title": "c-2-approaches-tc-o-n-2-sc-o-n",
                "content": "```\\n//Approach 1 : Top-Down Recursive Approach \\n/*\\n1 . First sort the array (Now we can say 2 number multiple is always its left side )\\n2 . Using 2 Pointer find out the 2 numbers (s=0 && e =n-1)\\n3 . if arr[s]*arr[e]==arr[curInd] It means arr[s] and arr[e] is 2 child (and increase s++ and decrese e--)\\n{\\nIf we found 2 no then again recursively call for child (total no of tree formed using both child)\\nchild1 = x\\nchild2 = y\\ntotal no of tree for current parent = x*y (if s==e)\\nor\\ntotal no of tree for current parent = 2 * x*y (if s!=e)\\n}\\n\\tif arr[s]*arr[e]>arr[curInd] then we have to decrease our e--\\n\\telse s++\\n4 .Using this approach we can find all no of pairs for every index \\n*/\\n/*\\nExample : 2 10 4 5\\n1 . sort the array :-> 2 4 5 10\\n2 . start from index 0 or n-1( here i am starting with n-1) \\ns = 0 \\ne = 3-1 = 2\\n2 4 5 10\\n^   ^\\nmul = 2*5 = 10\\nHere we got 10 (2,5 is one pair)\\n2!=5 (or s!=e)\\ndp[curInd] = 2 * dp[s]*dp[e]\\nagain call for n-1 recursively\\n*/\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int mod = 1000000007;\\n    long solve(vector<int>&arr,int ind){\\n        if(ind==-1) return 0; \\n        if(dp[ind]!=-1) return dp[ind];\\n        long cnt = 1;\\n        int s = 0;\\n        int e = ind-1;\\n        while(s<=e){\\n            long mul = (long)arr[s]*arr[e];\\n            if(mul==arr[ind]){\\n                long temp = (solve(arr,s) * solve(arr,e))%mod;\\n                if(s!=e) temp=temp*2;\\n                cnt = (cnt+temp)%mod;\\n                s++;\\n                e--;\\n            }\\n            else if(mul>arr[ind]) e--;\\n            else s++;\\n        }\\n        return dp[ind] = cnt;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n       sort(arr.begin(),arr.end());\\n      dp.resize(arr.size(),-1);\\n        long cnt = 0;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=(cnt+solve(arr,i))%mod;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n```\\n//Approach 2 : Bottom-Up \\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        vector<long> dp(arr.size(),1);\\n        int ans = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int s = 0;\\n            int e = i-1;\\n            while(s<=e){\\n                long mul = (long)arr[s]*arr[e];\\n                if(mul==arr[i]){\\n                    long cnt = (dp[s]*dp[e]) %mod;\\n                    if(s!=e) cnt*=2;\\n                    dp[i]= (dp[i]+cnt)%mod;\\n                    e--;\\n                    s++;\\n                }\\n                else if(mul>arr[i]) e--;\\n                else s++;\\n            }\\n            ans=(ans+dp[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf You Like Please Upvote :)\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n//Approach 1 : Top-Down Recursive Approach \\n/*\\n1 . First sort the array (Now we can say 2 number multiple is always its left side )\\n2 . Using 2 Pointer find out the 2 numbers (s=0 && e =n-1)\\n3 . if arr[s]*arr[e]==arr[curInd] It means arr[s] and arr[e] is 2 child (and increase s++ and decrese e--)\\n{\\nIf we found 2 no then again recursively call for child (total no of tree formed using both child)\\nchild1 = x\\nchild2 = y\\ntotal no of tree for current parent = x*y (if s==e)\\nor\\ntotal no of tree for current parent = 2 * x*y (if s!=e)\\n}\\n\\tif arr[s]*arr[e]>arr[curInd] then we have to decrease our e--\\n\\telse s++\\n4 .Using this approach we can find all no of pairs for every index \\n*/\\n/*\\nExample : 2 10 4 5\\n1 . sort the array :-> 2 4 5 10\\n2 . start from index 0 or n-1( here i am starting with n-1) \\ns = 0 \\ne = 3-1 = 2\\n2 4 5 10\\n^   ^\\nmul = 2*5 = 10\\nHere we got 10 (2,5 is one pair)\\n2!=5 (or s!=e)\\ndp[curInd] = 2 * dp[s]*dp[e]\\nagain call for n-1 recursively\\n*/\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int mod = 1000000007;\\n    long solve(vector<int>&arr,int ind){\\n        if(ind==-1) return 0; \\n        if(dp[ind]!=-1) return dp[ind];\\n        long cnt = 1;\\n        int s = 0;\\n        int e = ind-1;\\n        while(s<=e){\\n            long mul = (long)arr[s]*arr[e];\\n            if(mul==arr[ind]){\\n                long temp = (solve(arr,s) * solve(arr,e))%mod;\\n                if(s!=e) temp=temp*2;\\n                cnt = (cnt+temp)%mod;\\n                s++;\\n                e--;\\n            }\\n            else if(mul>arr[ind]) e--;\\n            else s++;\\n        }\\n        return dp[ind] = cnt;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n       sort(arr.begin(),arr.end());\\n      dp.resize(arr.size(),-1);\\n        long cnt = 0;\\n        for(int i=0;i<arr.size();i++){\\n            cnt=(cnt+solve(arr,i))%mod;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\n//Approach 2 : Bottom-Up \\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        vector<long> dp(arr.size(),1);\\n        int ans = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int s = 0;\\n            int e = i-1;\\n            while(s<=e){\\n                long mul = (long)arr[s]*arr[e];\\n                if(mul==arr[i]){\\n                    long cnt = (dp[s]*dp[e]) %mod;\\n                    if(s!=e) cnt*=2;\\n                    dp[i]= (dp[i]+cnt)%mod;\\n                    e--;\\n                    s++;\\n                }\\n                else if(mul>arr[i]) e--;\\n                else s++;\\n            }\\n            ans=(ans+dp[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401629,
                "title": "binary-tree-with-factors-c-explained-solution",
                "content": "The question here is quite good and needs some good observations. Lets try to find how will we count this number of trees. Lets take an array : **[2 , 4 , 5 , 10 , 20]**. Now we know that **2** and **5** will form only a single tree because they are prime. What about **4, 10 and 20 ?**. Lets see, basically every number can be a binary tree of single node with this number as the root but for composite numbers they can also be subdivided into its factors. Now lets take **4**, Now since 4 has only **2** as its other factor **( 1 is not considered cause it has been considered already when number itself is root, moreover array will contain numbers only greater than 1 )** . Since **2** and **4/2 = 2** are same only thus swapping them as right and left child will not create a new tree. Thus we need to count this only once. But lets take **10**, Now 10 can be single (root only) and **10** can be divided into **2** and **5** too. Since both of them are different and both of them are present in the array also thus for this pair we have **2 distinct trees**. Thus recursive relation looks something like :\\n\\n**ans = ans + ways(i) x ways(num/i)**\\n\\n**Note num should be divisible by i.  Secondly the value of ans = 1 initially, this is done to count the trees when tree consists of only a single node (number itself). We could also have used a loop for factorising num but by this way we would encounter a lot of numbers that are useless cause they might not be present inside the array. So its better that we focus on the numbers that are given in the array. By this way we also reduce the time complexity. Also we use a hashmap for storing DP states cause numbers are very big**. 2 Code implementations are given below :\\n\\n**Implementation 1 : Less Optimised**\\nTime Complexity :  O(N x Sum(root(A[i]))) for all i from **0 to N-1**\\nSpace Complexity : O(N), cause we store results only for numbers in the array.\\n**PS : You can also see that there is also a bit change in recursive relation in this implementation**\\n\\nCode :\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    map<ll,ll>mp;\\n    map<ll,ll>dp;\\n    ll mod = 1e9+7;\\n    ll ways(ll val){\\n        if(dp.find(val)!=dp.end()){\\n            return dp[val];\\n        }\\n        ll ans = 1;\\n        for(ll j = 2; j*j<=val; j++){\\n            if(val%j==0){\\n                if(mp.find(j)!=mp.end() && mp.find(val/j)!=mp.end()){\\n                    if(j*j==val){\\n                        ll prod = ways(j)*ways(val/j);\\n                        prod%=mod;\\n                        ans+=prod;\\n                        ans%=mod;\\n                    }\\n                    else{\\n                        ll prod = ways(j)*ways(val/j);\\n                        prod%=mod;\\n                        prod = (prod*2)%mod;\\n                        ans+=prod;\\n                        ans%=mod;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[val] = ans;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        ios_base::sync_with_stdio(0);\\n        int n = arr.size();\\n        for(auto it : arr){\\n            mp[it]++;\\n        }\\n        ll ans = 0;\\n        for(int i = 0; i<n; i++){            \\n\\t\\t\\tans+=ways(arr[i]);\\n            ans%=mod;\\n        }\\n        dp.clear();\\n        mp.clear();\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n**Implementation 2 : Most Optimised**\\nTime Complexity : O(N^2)\\nSpace Complexity : O(N), cause we are storing results for numbers that are present in array else not.\\n\\nCode : \\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    map<ll,ll>mp;\\n    map<ll,ll>dp;\\n    ll mod = 1e9+7;\\n    ll ways(ll val){\\n        if(dp.find(val)!=dp.end()){\\n            return dp[val];\\n        }\\n        ll ans = 1;\\n        for(auto it : mp){\\n            ll j = it.first;\\n            if(val%j==0 && mp.find(val/j)!=mp.end()){\\n                ll prod = ways(j)*ways(val/j);\\n                prod%=mod;\\n                ans+=prod;\\n                ans%=mod;\\n            }\\n        }\\n        return dp[val] = ans;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        ios_base::sync_with_stdio(0);\\n        int n = arr.size();\\n        for(auto it : arr){\\n            mp[it]++;\\n        }\\n        ll ans = 0;\\n        for(int i = 0; i<n; i++){\\n            ans+=ways(arr[i]);\\n            ans%=mod;\\n        }\\n        dp.clear();\\n        mp.clear();\\n        return ans;\\n    }\\n};\\n```\\n**Do Upvote If Found Helpful !**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    map<ll,ll>mp;\\n    map<ll,ll>dp;\\n    ll mod = 1e9+7;\\n    ll ways(ll val){\\n        if(dp.find(val)!=dp.end()){\\n            return dp[val];\\n        }\\n        ll ans = 1;\\n        for(ll j = 2; j*j<=val; j++){\\n            if(val%j==0){\\n                if(mp.find(j)!=mp.end() && mp.find(val/j)!=mp.end()){\\n                    if(j*j==val){\\n                        ll prod = ways(j)*ways(val/j);\\n                        prod%=mod;\\n                        ans+=prod;\\n                        ans%=mod;\\n                    }\\n                    else{\\n                        ll prod = ways(j)*ways(val/j);\\n                        prod%=mod;\\n                        prod = (prod*2)%mod;\\n                        ans+=prod;\\n                        ans%=mod;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[val] = ans;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        ios_base::sync_with_stdio(0);\\n        int n = arr.size();\\n        for(auto it : arr){\\n            mp[it]++;\\n        }\\n        ll ans = 0;\\n        for(int i = 0; i<n; i++){            \\n\\t\\t\\tans+=ways(arr[i]);\\n            ans%=mod;\\n        }\\n        dp.clear();\\n        mp.clear();\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    map<ll,ll>mp;\\n    map<ll,ll>dp;\\n    ll mod = 1e9+7;\\n    ll ways(ll val){\\n        if(dp.find(val)!=dp.end()){\\n            return dp[val];\\n        }\\n        ll ans = 1;\\n        for(auto it : mp){\\n            ll j = it.first;\\n            if(val%j==0 && mp.find(val/j)!=mp.end()){\\n                ll prod = ways(j)*ways(val/j);\\n                prod%=mod;\\n                ans+=prod;\\n                ans%=mod;\\n            }\\n        }\\n        return dp[val] = ans;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        ios_base::sync_with_stdio(0);\\n        int n = arr.size();\\n        for(auto it : arr){\\n            mp[it]++;\\n        }\\n        ll ans = 0;\\n        for(int i = 0; i<n; i++){\\n            ans+=ways(arr[i]);\\n            ans%=mod;\\n        }\\n        dp.clear();\\n        mp.clear();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401425,
                "title": "c-hashmap-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n= arr.size();\\n        vector<long long> dp(n,1);\\n        int mod= 1e9+7;\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        //element --> index\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n; i++)\\n            mp[arr[i]] = i;\\n        \\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<i; j++) {\\n                if(arr[i]%arr[j]==0) {\\n                    int quo = arr[i]/arr[j];\\n                    if(mp.count(quo)) {\\n                        dp[i] += dp[j] * dp[mp[quo]];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        long long result = 0;\\n        for(auto &ele : dp) {\\n            result += ele;\\n        }\\n        \\n        return result%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n= arr.size();\\n        vector<long long> dp(n,1);\\n        int mod= 1e9+7;\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        //element --> index\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n; i++)\\n            mp[arr[i]] = i;\\n        \\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<i; j++) {\\n                if(arr[i]%arr[j]==0) {\\n                    int quo = arr[i]/arr[j];\\n                    if(mp.count(quo)) {\\n                        dp[i] += dp[j] * dp[mp[quo]];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        long long result = 0;\\n        for(auto &ele : dp) {\\n            result += ele;\\n        }\\n        \\n        return result%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401291,
                "title": "c-solution-time-o-n-k-memory-o-n-easy-to-understand-dynamic-programming-dictionary",
                "content": "```C#\\npublic class Solution {\\n    private static int _mod = 1000000007;\\n    public int NumFactoredBinaryTrees(int[] arr) {\\n        Dictionary<int, long> memo = new ();\\n        \\n        HashSet<int> nums = new (arr);\\n        int ans = 0;\\n        for (int i = 0; i < arr.Length; i++)\\n            ans = (ans + (int)Solve(arr[i])) % _mod;\\n        \\n        return ans;\\n        \\n        long Solve(int num) {\\n            if (memo.TryGetValue(num, out var memoizedResult)) return memoizedResult;\\n            \\n            long count = 0;\\n            if (nums.Contains(num)) {\\n                count++;\\n\\n                int sqrt = (int)Math.Sqrt(num);\\n                for (int i = 2; i <= sqrt; i++) {\\n                    if (num % i == 0) {\\n                        int t = num / i;\\n                        long p = Solve(i) * Solve(t) % _mod;\\n                        count = (count + (int)p) % _mod;\\n                        if (i != t) count = (count + (int)p) % _mod;\\n                    }\\n                }\\n            }\\n            \\n            memo[num] = count;\\n            return count;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```C#\\npublic class Solution {\\n    private static int _mod = 1000000007;\\n    public int NumFactoredBinaryTrees(int[] arr) {\\n        Dictionary<int, long> memo = new ();\\n        \\n        HashSet<int> nums = new (arr);\\n        int ans = 0;\\n        for (int i = 0; i < arr.Length; i++)\\n            ans = (ans + (int)Solve(arr[i])) % _mod;\\n        \\n        return ans;\\n        \\n        long Solve(int num) {\\n            if (memo.TryGetValue(num, out var memoizedResult)) return memoizedResult;\\n            \\n            long count = 0;\\n            if (nums.Contains(num)) {\\n                count++;\\n\\n                int sqrt = (int)Math.Sqrt(num);\\n                for (int i = 2; i <= sqrt; i++) {\\n                    if (num % i == 0) {\\n                        int t = num / i;\\n                        long p = Solve(i) * Solve(t) % _mod;\\n                        count = (count + (int)p) % _mod;\\n                        if (i != t) count = (count + (int)p) % _mod;\\n                    }\\n                }\\n            }\\n            \\n            memo[num] = count;\\n            return count;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401267,
                "title": "c-most-efficient-approach-beats-99",
                "content": "***Simple Approach***\\n1. Assume dp[i] is the number of combinations and the recurrence relation is:\\n***dp[i]=1+sum(dp[j]*dp[k]) for j=0 to i-1 and A[k]=A[i]/A[j]***\\n*we have to sort the array in ascending order so that the recurrence relation is correct.*\\n\\n2. Use the hash set to store all the numbers before i to save lookup time.\\nBe sure to use **long long** for **dp[j]*dp[k]**, otherwise it will overflow.\\nalso the accumulation has to use 0LL for the initial value to avoid overflow.\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        //a single node automatically satisify\\n        //for any number we shall try all possible combinations\\n        vector<long long> dp(A.size(),1);//long long is key!\\n        sort(A.begin(),A.end());\\n        const int tt=1000000000+7;\\n        //A[i]=A[j]*A[i/j]\\n        unordered_map<int,int> ms;//value with index\\n        for(int i=0;i<A.size();i++)\\n        {\\n            ms[A[i]]=i;\\n            for(int j=i-1;j>=0;j--) \\n            {\\n                if(A[i]%A[j]==0)//find one factor\\n                {\\n                    int t=A[i]/A[j];\\n                    if(ms.count(t)) dp[i]+=(dp[j]*dp[ms[t]])%tt;\\n                }\\n            }\\n        }\\n        //copy(dp.begin(),dp.end(),ostream_iterator<int>(cout,\" \"));\\n        long long ans=0;\\n        ans=accumulate(dp.begin(),dp.end(),0LL);\\n        //for(int i=0;i<dp.size();i++) ans=(ans+dp[i])%tt;\\n        return ans%tt;//%tt+7;\\n    }\\n};\\n\\nPLEASE UPVOTE ****",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        //a single node automatically satisify\\n        //for any number we shall try all possible combinations\\n        vector<long long> dp(A.size(),1);//long long is key!\\n        sort(A.begin(),A.end());\\n        const int tt=1000000000+7;\\n        //A[i]=A[j]*A[i/j]\\n        unordered_map<int,int> ms;//value with index\\n        for(int i=0;i<A.size();i++)\\n        {\\n            ms[A[i]]=i;\\n            for(int j=i-1;j>=0;j--) \\n            {\\n                if(A[i]%A[j]==0)//find one factor\\n                {\\n                    int t=A[i]/A[j];\\n                    if(ms.count(t)) dp[i]+=(dp[j]*dp[ms[t]])%tt;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2401000,
                "title": "dp-rec-memo-tabul-c",
                "content": "So let\\'s underestand the problem,\\nInput: 2, 5, 6, 10, 4, 3\\nOutput: 11\\n\\nThat means by using these numbers we can create 11 unique binary trees by following the rule,\\n**root_val = left_child_val * right_child_val**\\n\\nFrom this, we can get the left and right values that need to be less than the root. So to efficiently check on fewer values we can sort the array so that all the indices less than will have scope to be its child node.\\n\\nNow let\\'s think of a recursive solution(top-down), For each number from left to right (n-1, 0) as root, let\\'s check how many trees can be made, and let\\'s sum it up.\\n\\nOn recursion, we can check on 0 to i - 1 for finding the left child value and right child value.\\n\\nIf we find left and right children we can run recursion on both of them as roots, and their results multiplication will give us the answer(multiplication to get different combinations). Sorry, I am not good at explanations.\\n\\n**Note**: Taking a map to store index after sort so we can easily check if the right child can be found for the respective left child.\\n\\n**Driver code:**\\n```\\nint numFactoredBinaryTrees(vector<int>& arr) {\\n\\tsort(arr.begin(), arr.end());\\n\\n\\tint n = arr.size();\\n\\tunordered_map<int, int> mp;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tmp[arr[i]] = i;\\n\\t}\\n\\n\\tlong ans = 0; \\n\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\tans = (ans + rec(arr, i, mp)) % MOD;\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\\n\\n**Recurssion:**\\n```\\nlong rec(vector<int>& arr, int i, unordered_map<int, int>& mp) {\\n\\tlong ans = 1;\\n\\tfor (int j = 0; j < i; j++) {\\n\\t\\tif (arr[i] % arr[j] == 0 && mp.find(arr[i] / arr[j]) != mp.end()) {\\n\\t\\t\\tlong left = rec(arr, j, mp);\\n\\t\\t\\tlong right = rec(arr, mp[arr[i] / arr[j]], mp);\\n\\t\\t\\tans = (ans + (left * right)) % MOD;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\nOptimizing this with DP memoization because this has overlaping sub problem. (Take the example input and try to draw the recursive call). DP can be implemented by few modifications.\\n\\n**Driver Code:**\\n```\\nvector<int> dp(n, -1);\\nfor (int i = n - 1; i >= 0; i--) {\\n\\t// Last parameter dp array\\n\\tans = (ans + memo(arr, i, mp, dp)) % MOD;\\n}\\n```\\n\\n**Memoization:**\\n```\\nlong memo(vector<int>& arr, int i, unordered_map<int, int>& mp, vector<int>& dp) {\\n\\tif (dp[i] != -1) return dp[i]; // Add on\\n\\tlong ans = 1; \\n\\tfor (int j = 0; j < i; j++) {\\n\\t\\tif (arr[i] % arr[j] == 0 && mp.find(arr[i] / arr[j]) != mp.end()) {\\n\\t\\t\\tlong left = memo(arr, j, mp, dp);\\n\\t\\t\\tlong right = memo(arr, mp[arr[i] / arr[j]], mp, dp);\\n\\t\\t\\tans = (ans + (left * right)) % MOD;\\n\\t\\t}\\n\\t}\\n\\treturn dp[i] = ans; // Add on\\n}\\n```\\n\\n\\nSo lets optimize memoization to reduce recursive stack space, we can use tabulation(bottom-up).\\n\\n**Driver Code:**\\n```\\nvector<int> dp(n, 0);\\ntabu(arr, n, mp, dp);\\nfor (int i = 0; i < n; i++) {\\n\\tans = (ans + dp[i]) % MOD;\\n}\\n\\nreturn ans;\\n```\\n\\n\\n**Tabulation Code:**\\n```\\nvoid tabu(vector<int>& arr, int n, unordered_map<int, int>& mp, vector<int>& dp) {\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint ans = 1;\\n\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\tif (arr[i] % arr[j] == 0 && mp.find(arr[i] / arr[j]) != mp.end()) {\\n\\t\\t\\t\\tlong left = dp[j];\\n\\t\\t\\t\\tlong right = dp[mp[arr[i] / arr[j]]];\\n\\t\\t\\t\\tans = (ans + (left * right)) % MOD;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[i] = ans;\\n\\t}\\n}\\n```\\n\\nWe can\\'t further space optimaize this because of `dp[mp[arr[i] / arr[j]]]` which can be any previous index.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint numFactoredBinaryTrees(vector<int>& arr) {\\n\\tsort(arr.begin(), arr.end());\\n\\n\\tint n = arr.size();\\n\\tunordered_map<int, int> mp;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tmp[arr[i]] = i;\\n\\t}\\n\\n\\tlong ans = 0; \\n\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\tans = (ans + rec(arr, i, mp)) % MOD;\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\n```\\nlong rec(vector<int>& arr, int i, unordered_map<int, int>& mp) {\\n\\tlong ans = 1;\\n\\tfor (int j = 0; j < i; j++) {\\n\\t\\tif (arr[i] % arr[j] == 0 && mp.find(arr[i] / arr[j]) != mp.end()) {\\n\\t\\t\\tlong left = rec(arr, j, mp);\\n\\t\\t\\tlong right = rec(arr, mp[arr[i] / arr[j]], mp);\\n\\t\\t\\tans = (ans + (left * right)) % MOD;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nvector<int> dp(n, -1);\\nfor (int i = n - 1; i >= 0; i--) {\\n\\t// Last parameter dp array\\n\\tans = (ans + memo(arr, i, mp, dp)) % MOD;\\n}\\n```\n```\\nlong memo(vector<int>& arr, int i, unordered_map<int, int>& mp, vector<int>& dp) {\\n\\tif (dp[i] != -1) return dp[i]; // Add on\\n\\tlong ans = 1; \\n\\tfor (int j = 0; j < i; j++) {\\n\\t\\tif (arr[i] % arr[j] == 0 && mp.find(arr[i] / arr[j]) != mp.end()) {\\n\\t\\t\\tlong left = memo(arr, j, mp, dp);\\n\\t\\t\\tlong right = memo(arr, mp[arr[i] / arr[j]], mp, dp);\\n\\t\\t\\tans = (ans + (left * right)) % MOD;\\n\\t\\t}\\n\\t}\\n\\treturn dp[i] = ans; // Add on\\n}\\n```\n```\\nvector<int> dp(n, 0);\\ntabu(arr, n, mp, dp);\\nfor (int i = 0; i < n; i++) {\\n\\tans = (ans + dp[i]) % MOD;\\n}\\n\\nreturn ans;\\n```\n```\\nvoid tabu(vector<int>& arr, int n, unordered_map<int, int>& mp, vector<int>& dp) {\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint ans = 1;\\n\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\tif (arr[i] % arr[j] == 0 && mp.find(arr[i] / arr[j]) != mp.end()) {\\n\\t\\t\\t\\tlong left = dp[j];\\n\\t\\t\\t\\tlong right = dp[mp[arr[i] / arr[j]]];\\n\\t\\t\\t\\tans = (ans + (left * right)) % MOD;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[i] = ans;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2400878,
                "title": "c-solution-dynamic-programming-explained",
                "content": "**Language Used: C++**\\n\\n*If you have any questions, feel free to ask. If you like the solution and explanation, please **upvote!***\\n\\nTime: O(n^2);\\nSpace: O(n)\\n\\n*  dp[i] := represents possible combinationswith ith element at its node;\\n*  Lets arr[] be {x, y, x*y}; dp[0]:= contains possible ans for x as its root.\\n*  Same goes for dp[1], but in dp[2] we need to check.\\n*  Check whether x divides (x*y), if yes then it might acct as left node.\\n*  Check whether right node is present (using hashmap).\\n*  Save results in dp (dp[i] += dp[left] * dp[right]).\\n\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        constexpr int Mod = 1e9 + 7;\\n        const int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        vector<long> dp(n, 1);\\n        // Initialized with 1 because we can make atleast 1 BT with that number.\\n        \\n        unordered_map<int, int> Ind;\\n        \\n        for(int i{}; i<n; i++){\\n            Ind[arr[i]] = i;\\n        }\\n        \\n        for(int i{}; i<n; i++){\\n            for(int j{}; j<i; j++){\\n                if(arr[i]%arr[j] == 0){\\n                    int rig = arr[i]/arr[j];\\n\\t\\t\\t\\t\\t// Checking whether right exists?\\n                    if(Ind.count(rig)){\\n                        dp[i] += dp[j] * dp[Ind[rig]];\\n                        dp[i] %= Mod;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return accumulate(dp.begin(), dp.end(), 0L)%Mod;\\n    }\\n};\\n```\\nKeep Coding\\n**`while(!success){ tryAgain(); } :)`**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        constexpr int Mod = 1e9 + 7;\\n        const int n = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        vector<long> dp(n, 1);\\n        // Initialized with 1 because we can make atleast 1 BT with that number.\\n        \\n        unordered_map<int, int> Ind;\\n        \\n        for(int i{}; i<n; i++){\\n            Ind[arr[i]] = i;\\n        }\\n        \\n        for(int i{}; i<n; i++){\\n            for(int j{}; j<i; j++){\\n                if(arr[i]%arr[j] == 0){\\n                    int rig = arr[i]/arr[j];\\n\\t\\t\\t\\t\\t// Checking whether right exists?\\n                    if(Ind.count(rig)){\\n                        dp[i] += dp[j] * dp[Ind[rig]];\\n                        dp[i] %= Mod;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return accumulate(dp.begin(), dp.end(), 0L)%Mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400275,
                "title": "java-solution-using-sorting-and-dp",
                "content": "Main Points :\\nSort the array , as we have to find for each element present in arr[i] , **can we make it a parent node by multplying its children** , basically does **both factors of a element are present in order to make it a parent node.**\\nIf we find that the factors are indeed present **we further have to multiply the number of ways of both children** ,in which these children can be formed if they are present as parent node.\\nso for each element we store the number of ways in which it can be a parent element in a dp array.\\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        \\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        \\n        long trees = 0;\\n        long mod = (long)1e9+7;\\n\\t\\t// making a dp array to store at each point the numbers of ways to make a tree if the current element is taken as parent node\\n        long []dp = new long[n];\\n        \\n        for( int i=0; i<n; i++ ){\\n\\t\\t\\t// current trees initialized as 1 , as a number can always make a single by itself\\n            long curr = 1;\\n            \\n            int lo = 0;\\n            int hi = i-1;\\n            \\n\\t\\t\\t// two pointers approach to find the factors of current element and if both factors are present in the array\\n            while( lo <= hi ){\\n                \\n                long prod = arr[lo] * arr[hi];\\n\\t\\t\\t\\t// check to find factors and second check to make sure that the number is valid ( i did this check as i was encountering a problem in a testcase even though the numbers were big their product was small and coming out to be exact as current element)\\n                if( prod == ( arr[i] % mod ) && arr[lo] <= ( arr[i]/2 ) && arr[hi] <= ( arr[i]/2 ) ){\\n                    int diff = 2;\\n\\t\\t\\t\\t\\t// if both the numbers are same there is only one way we can arrange as either being on left or right is same for them\\n                    if( arr[lo] == arr[hi] ) diff = 1;\\n                    curr = ( curr +  ( ( ( dp[hi] * dp[lo] ) % mod ) * diff ) % mod ) % mod;\\n                    lo++;\\n                    hi--;\\n                }\\n                else if ( prod > arr[i] ) hi--;\\n                else lo++;\\n            }\\n            // storing the current trees\\n            dp[i] = curr;\\n\\t\\t\\t// storing total trees we can make\\n            trees = ( trees + curr )%mod;\\n        }\\n        \\n        return (int)trees;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        \\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        \\n        long trees = 0;\\n        long mod = (long)1e9+7;\\n\\t\\t// making a dp array to store at each point the numbers of ways to make a tree if the current element is taken as parent node\\n        long []dp = new long[n];\\n        \\n        for( int i=0; i<n; i++ ){\\n\\t\\t\\t// current trees initialized as 1 , as a number can always make a single by itself\\n            long curr = 1;\\n            \\n            int lo = 0;\\n            int hi = i-1;\\n            \\n\\t\\t\\t// two pointers approach to find the factors of current element and if both factors are present in the array\\n            while( lo <= hi ){\\n                \\n                long prod = arr[lo] * arr[hi];\\n\\t\\t\\t\\t// check to find factors and second check to make sure that the number is valid ( i did this check as i was encountering a problem in a testcase even though the numbers were big their product was small and coming out to be exact as current element)\\n                if( prod == ( arr[i] % mod ) && arr[lo] <= ( arr[i]/2 ) && arr[hi] <= ( arr[i]/2 ) ){\\n                    int diff = 2;\\n\\t\\t\\t\\t\\t// if both the numbers are same there is only one way we can arrange as either being on left or right is same for them\\n                    if( arr[lo] == arr[hi] ) diff = 1;\\n                    curr = ( curr +  ( ( ( dp[hi] * dp[lo] ) % mod ) * diff ) % mod ) % mod;\\n                    lo++;\\n                    hi--;\\n                }\\n                else if ( prod > arr[i] ) hi--;\\n                else lo++;\\n            }\\n            // storing the current trees\\n            dp[i] = curr;\\n\\t\\t\\t// storing total trees we can make\\n            trees = ( trees + curr )%mod;\\n        }\\n        \\n        return (int)trees;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400239,
                "title": "java-based-on-concept-of-two-sum-really-easy-solution-fastest",
                "content": "```\\nclass Solution {\\n    private int MOD = 1000000007;\\n    public int numFactoredBinaryTrees(int[] arr) \\n    {\\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        long[] dp = new long[n];\\n        dp[0] = 1;\\n        int ans = 0;\\n        for (int idx = 1; idx < n; idx++)\\n        {\\n            int target = arr[idx];  //root \\n            //===========================================\\n            //EXACTLY SAME AS CONCEPT OF \"TWO SUM\" PROBLEM\\n            \\n            int i = 0, j = idx - 1; //two pointers for the \"Two product\" problem (same as Two Sum)\\n            long ways = 1;\\n            while(i <= j)\\n            {\\n                long prod = (((long)arr[i]) * (arr[j]));\\n                if (prod == target) \\n                {\\n                    if (i == j) ways += (dp[i] * dp[j]) % MOD;\\n                    else ways += ((dp[i] * dp[j]) * 2) % MOD;  \\n                    //\"*2\" becoz 1) arr[i] is left child, arr[j] is right child\\n                    //           2) arr[j] is left child, arr[i] is right child\\n                    \\n                    i++;\\n                    j--;\\n                }\\n                else if (prod < target) i++;\\n                else if (prod > target) j--;\\n            }\\n            \\n            //============================================================\\n            dp[idx] = ways;\\n            ans  = (int)((ans + dp[idx]) % MOD); //add all the cases\\n        }\\n        return ans + 1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private int MOD = 1000000007;\\n    public int numFactoredBinaryTrees(int[] arr) \\n    {\\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        long[] dp = new long[n];\\n        dp[0] = 1;\\n        int ans = 0;\\n        for (int idx = 1; idx < n; idx++)\\n        {\\n            int target = arr[idx];  //root \\n            //===========================================\\n            //EXACTLY SAME AS CONCEPT OF \"TWO SUM\" PROBLEM\\n            \\n            int i = 0, j = idx - 1; //two pointers for the \"Two product\" problem (same as Two Sum)\\n            long ways = 1;\\n            while(i <= j)\\n            {\\n                long prod = (((long)arr[i]) * (arr[j]));\\n                if (prod == target) \\n                {\\n                    if (i == j) ways += (dp[i] * dp[j]) % MOD;\\n                    else ways += ((dp[i] * dp[j]) * 2) % MOD;  \\n                    //\"*2\" becoz 1) arr[i] is left child, arr[j] is right child\\n                    //           2) arr[j] is left child, arr[i] is right child\\n                    \\n                    i++;\\n                    j--;\\n                }\\n                else if (prod < target) i++;\\n                else if (prod > target) j--;\\n            }\\n            \\n            //============================================================\\n            dp[idx] = ways;\\n            ans  = (int)((ans + dp[idx]) % MOD); //add all the cases\\n        }\\n        return ans + 1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400065,
                "title": "c-easy-understanding-top-down-dp-solution",
                "content": "The top-down idea is straightforward, just to find the total counts of each number, and sum up with sub-recursions. The sub-nodes can be found with simple factor calculation, each number will be calculated only once.\\n\\n```\\nclass Solution {\\n    unordered_set<int> set;\\n    unordered_map<int, long long> map;\\n    long long mod = 1e9+7;\\npublic:\\n    long long findCount(vector<int> &arr, int num1) {\\n        if(map.find(num1) != map.end()) return map[num1];\\n\\t\\t// for each number, at least counts itself as leaf\\n        long long cnt = 1;\\n        for(int num2: arr) {\\n\\t\\t\\t// find sub-nodes\\n            if(num2 <= num1 && num1 % num2 == 0 && set.count(num1 / num2)) {\\n                cnt += findCount(arr, num2) * findCount(arr, num1 / num2);\\n            }\\n        }\\n        return map[num1] = cnt;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        long long ans = 0;\\n        set.insert(arr.begin(), arr.end());\\n        for(int num: arr) {\\n            ans += findCount(arr, num);\\n            ans %= mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime complexity: `O(n^2)`\\nSpace complexity: `O(n)`",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    unordered_set<int> set;\\n    unordered_map<int, long long> map;\\n    long long mod = 1e9+7;\\npublic:\\n    long long findCount(vector<int> &arr, int num1) {\\n        if(map.find(num1) != map.end()) return map[num1];\\n\\t\\t// for each number, at least counts itself as leaf\\n        long long cnt = 1;\\n        for(int num2: arr) {\\n\\t\\t\\t// find sub-nodes\\n            if(num2 <= num1 && num1 % num2 == 0 && set.count(num1 / num2)) {\\n                cnt += findCount(arr, num2) * findCount(arr, num1 / num2);\\n            }\\n        }\\n        return map[num1] = cnt;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        long long ans = 0;\\n        set.insert(arr.begin(), arr.end());\\n        for(int num: arr) {\\n            ans += findCount(arr, num);\\n            ans %= mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958524,
                "title": "c-dp-solution-o-n-2",
                "content": "Runtime: 77 ms, faster than 71.87% of C++ online submissions for Binary Trees With Factors.\\nMemory Usage: 9.2 MB, less than 77.68% of C++ online submissions for Binary Trees With Factors.\\n\\n\\n```\\nWe can get the tree count for current number from the tree count of the factors of the current number.\\nSo, Binary Tree count for num => DP[num] += DP[X] * DP[num/X] where X and num/X are factors\\n\\n1. Sort the numbers and process smaller numbers first as they will be the factor of larger number\\n2. Then loop from first to current number and check if previous values are factors of current number \\nupdate tree count for number using DP equation\\n3. User Hash Table to track the count of tree for each number as root\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        sort(arr.begin(),arr.end());\\n\\n        // track the tree count for each number as root\\n        unordered_map<int,long long>dp;\\n        long long count = 0;\\n        int MOD = 1000000007;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            dp[arr[i]] = 1L;    // each number is root itself\\n            \\n            for(int j=0;j<i;j++)\\n            {\\n                if((arr[i] % arr[j]) == 0)\\n                {\\n                    // both factor present in dp, then add the tree count\\n                    if(dp.find(arr[i]/arr[j])!=dp.end())\\n                        dp[arr[i]] =  (dp[arr[i]] + dp[arr[j]] * dp[arr[i]/arr[j]]) % MOD;\\n                }                \\n            }\\n            \\n            count = (count + dp[arr[i]]) % MOD;\\n        }\\n        \\n        return count;   // total tree count\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nWe can get the tree count for current number from the tree count of the factors of the current number.\\nSo, Binary Tree count for num => DP[num] += DP[X] * DP[num/X] where X and num/X are factors\\n\\n1. Sort the numbers and process smaller numbers first as they will be the factor of larger number\\n2. Then loop from first to current number and check if previous values are factors of current number \\nupdate tree count for number using DP equation\\n3. User Hash Table to track the count of tree for each number as root\\n```\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        sort(arr.begin(),arr.end());\\n\\n        // track the tree count for each number as root\\n        unordered_map<int,long long>dp;\\n        long long count = 0;\\n        int MOD = 1000000007;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            dp[arr[i]] = 1L;    // each number is root itself\\n            \\n            for(int j=0;j<i;j++)\\n            {\\n                if((arr[i] % arr[j]) == 0)\\n                {\\n                    // both factor present in dp, then add the tree count\\n                    if(dp.find(arr[i]/arr[j])!=dp.end())\\n                        dp[arr[i]] =  (dp[arr[i]] + dp[arr[j]] * dp[arr[i]/arr[j]]) % MOD;\\n                }                \\n            }\\n            \\n            count = (count + dp[arr[i]]) % MOD;\\n        }\\n        \\n        return count;   // total tree count\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400606,
                "title": "simple-python-dynamic-programming-solution",
                "content": "```\\nMOD = 1000000007\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        # smaller numbers multiply to form a larger number\\n        # after sorting we only have to worry about numbers\\n        # to the left of the current number\\n        arr.sort()\\n        # let dp[x] be the number of possible binary trees we\\n        # can form using x as the root\\n        dp = {x: 1 for x in arr}\\n        # iterate through each number, using it as the root\\n        for i in range(len(arr)):\\n            # iterate through all numbers smaller than the current\\n            # number\\n            for j in range(i):\\n                # check if big/small is in array, if yes, there\\'d be\\n                # dp[small]*dp[big/small] possible trees with big as\\n                # root\\n                if arr[i]/arr[j] in dp:\\n                    dp[arr[i]] += dp[arr[j]]*dp[arr[i]/arr[j]]\\n        \\n        return sum(dp[x] for x in dp) % MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nMOD = 1000000007\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        # smaller numbers multiply to form a larger number\\n        # after sorting we only have to worry about numbers\\n        # to the left of the current number\\n        arr.sort()\\n        # let dp[x] be the number of possible binary trees we\\n        # can form using x as the root\\n        dp = {x: 1 for x in arr}\\n        # iterate through each number, using it as the root\\n        for i in range(len(arr)):\\n            # iterate through all numbers smaller than the current\\n            # number\\n            for j in range(i):\\n                # check if big/small is in array, if yes, there\\'d be\\n                # dp[small]*dp[big/small] possible trees with big as\\n                # root\\n                if arr[i]/arr[j] in dp:\\n                    dp[arr[i]] += dp[arr[j]]*dp[arr[i]/arr[j]]\\n        \\n        return sum(dp[x] for x in dp) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108540,
                "title": "c-dp-o-n-2-88ms",
                "content": "\\n\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        std::sort(arr.begin(), arr.end());\\n        int n = arr.size();\\n        vector<long long> dp(n, 1);\\n        int mod = 1e9 + 7;\\n        std::unordered_map<int, int> pos;\\n        for(int i = 0; i < n; ++i) {\\n            pos[arr[i]] = i;\\n        }\\n        \\n        for(int i = 0; i < n; ++i) {\\n            for(int j = 0; j < i; ++j) {\\n                if (arr[i] % arr[j] > 0 ) continue;\\n                int current = arr[i] / arr[j];\\n                if (pos.find(current) != pos.end()) {\\n                    dp[i] += dp[pos[current]] * dp[j];\\n                }\\n            }\\n        }\\n        \\n        long long res = 0;\\n        for(auto& c : dp) {\\n            res += c;\\n        }\\n        return res % mod;\\n    }",
                "solutionTags": [],
                "code": "\\n\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        std::sort(arr.begin(), arr.end());\\n        int n = arr.size();\\n        vector<long long> dp(n, 1);\\n        int mod = 1e9 + 7;\\n        std::unordered_map<int, int> pos;\\n        for(int i = 0; i < n; ++i) {\\n            pos[arr[i]] = i;\\n        }\\n        \\n        for(int i = 0; i < n; ++i) {\\n            for(int j = 0; j < i; ++j) {\\n                if (arr[i] % arr[j] > 0 ) continue;\\n                int current = arr[i] / arr[j];\\n                if (pos.find(current) != pos.end()) {\\n                    dp[i] += dp[pos[current]] * dp[j];\\n                }\\n            }\\n        }\\n        \\n        long long res = 0;\\n        for(auto& c : dp) {\\n            res += c;\\n        }\\n        return res % mod;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1108077,
                "title": "javascript-simple-dp-approach",
                "content": "Time: `O(N^2)`\\nSpace: `O(N)`\\n```javascript\\nvar numFactoredBinaryTrees = function(arr) {\\n    const memo = new Map();\\n    const mod = 10**9 + 7\\n    \\n    arr.sort((a, b) => a - b);\\n    arr.forEach(num => memo.set(num, 1))\\n           \\n    for(let i = 1; i < arr.length; i++) {\\n        \\n        for(let j = i-1; j >= 0; j--) {\\n            \\n            if(arr[i] % arr[j]) continue; // if the number doesn\\'t divide \\n            \\n            const num2 = arr[i] / arr[j];;\\n            \\n            if(!memo.has(num2)) continue; // if the complimentary number doesn\\'t exit\\n            \\n            const waysToNum1 = memo.get(arr[j]);\\n            const waysToNum2 = memo.get(num2);\\n            const totalWays = waysToNum1 * waysToNum2;\\n            \\n            memo.set(arr[i], (memo.get(arr[i]) + totalWays));\\n        }\\n    }\\n    \\n    const totalTrees = [...memo.values()].reduce((acc, cur) => acc + cur, 0);\\n    return totalTrees % mod;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\nvar numFactoredBinaryTrees = function(arr) {\\n    const memo = new Map();\\n    const mod = 10**9 + 7\\n    \\n    arr.sort((a, b) => a - b);\\n    arr.forEach(num => memo.set(num, 1))\\n           \\n    for(let i = 1; i < arr.length; i++) {\\n        \\n        for(let j = i-1; j >= 0; j--) {\\n            \\n            if(arr[i] % arr[j]) continue; // if the number doesn\\'t divide \\n            \\n            const num2 = arr[i] / arr[j];;\\n            \\n            if(!memo.has(num2)) continue; // if the complimentary number doesn\\'t exit\\n            \\n            const waysToNum1 = memo.get(arr[j]);\\n            const waysToNum2 = memo.get(num2);\\n            const totalWays = waysToNum1 * waysToNum2;\\n            \\n            memo.set(arr[i], (memo.get(arr[i]) + totalWays));\\n        }\\n    }\\n    \\n    const totalTrees = [...memo.values()].reduce((acc, cur) => acc + cur, 0);\\n    return totalTrees % mod;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1107886,
                "title": "c-dynamic-programming-two-pointer",
                "content": "This solution revolves around constructing solutions for larger numbers provided in `arr` by first building solutions for smaller numbers in `arr` and then building these solutions using dynamic programming.\\n\\nWe start by sorting `arr` so that we can traverse it in an increasing order, since larger numbers cannot be factors of smaller numbers that precede them, but smaller numbers in  `arr` can be factors of larger numbers in `arr`.\\n\\nThen, we build our `dp` array of type `long` and initialize all elements to 1. This is because every element in the `dp` represents something that appears in `arr`, and so by definition, there is *at least* one way to build said element as a binary tree (i.e. an empty tree rooted at that element). We use type `long` to avoid overflow error in our calculations.\\n\\nFrom here, we use `dppos` to represent the element in `arr` currently under consideration. For this element, we are aiming to answer the question ***for this element, using smaller elements in the array, how many ways can we represent this element as a binary tree under the rules stipulated in the problem description?*** To do so, we iterate through all elements in `arr` smaller than the given element using two pointers, with a left pointer starting at the smallest element and a right pointer starting at the highest element. At each point, we run into three cases:\\n1. If the product of `arr[left]` and `arr[right]` exceed the given element, we know our product is too large, so we decrement `right`.\\n2. If the product of `arr[left]` and `arr[right]` is less than the given element, we know our product is too small, so we increment `left`.\\n3. Otherwise, we have found a way to represent the given element as a factor of two smaller elements, so we increase our count of the number of ways to make the current element (i.e. `dp[dppos]`) by the product of the number of ways to make each of the smaller elements, because for each subtree rooted at the given element, we have a choice on which \"way\" we are going to make the factor of the larger element. Note that if we are multiplying the same element twice, we do not multiply the overall product by 2, since the same element is being used twice, creating an inherent symmetry in the tree.\\n\\nTo avoid overflow, we cast operand to type `long` and use the modulo operator at the end of each iteration. Using a global `total` variable allows us to keep track of the total number of trees capable of being made with this array as we go along, which we return as our final answer.\\n\\nThis method requires linear extra space in the number of elements in `arr` and requires quadratic time, since for each element in `arr` we are looping through elements smaller than it.\\n\\n```\\nint numFactoredBinaryTrees(vector<int>& arr) {\\n\\tsort(arr.begin(), arr.end());\\n\\tvector<long> dp(arr.size(), 1);\\n\\tint total = 0;\\n\\tfor (int dppos = 0; dppos < dp.size(); dppos++) {\\n\\t\\tint left = 0, right = dppos - 1;\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tif (long(arr[left]) * arr[right] > arr[dppos]) {\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t} else if (long(arr[left]) * arr[right] < arr[dppos]) {\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (left == right) {\\n\\t\\t\\t\\t\\tdp[dppos] += (dp[left] * dp[right]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[dppos] += 2 * (dp[left] * dp[right]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ttotal = ((total % 1000000007) + dp[dppos]) % 1000000007;   \\n\\t}\\n\\treturn total;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numFactoredBinaryTrees(vector<int>& arr) {\\n\\tsort(arr.begin(), arr.end());\\n\\tvector<long> dp(arr.size(), 1);\\n\\tint total = 0;\\n\\tfor (int dppos = 0; dppos < dp.size(); dppos++) {\\n\\t\\tint left = 0, right = dppos - 1;\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tif (long(arr[left]) * arr[right] > arr[dppos]) {\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t} else if (long(arr[left]) * arr[right] < arr[dppos]) {\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (left == right) {\\n\\t\\t\\t\\t\\tdp[dppos] += (dp[left] * dp[right]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[dppos] += 2 * (dp[left] * dp[right]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ttotal = ((total % 1000000007) + dp[dppos]) % 1000000007;   \\n\\t}\\n\\treturn total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1107767,
                "title": "java-easy-to-understand-recursive",
                "content": "1. Go from each node as root and then try to find out number of tree from that number as a root\\n2. Creating Map `numToIndex` that can give Index of the number as well as if that number is present to verify factors are there\\n3. `dp` to store each number with number of trees it can form, for memoization\\n\\n```\\nclass Solution {\\n    final static int MOD = 1000_000_000 + 7;\\n    int[] arr;\\n    Map<Integer, Integer> numToIndex;\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        numToIndex = new HashMap<>();\\n        this.arr = arr;\\n        long[] dp = new long[arr.length];\\n        Arrays.fill(dp, -1);\\n        for(int i=0;i<arr.length;i++) numToIndex.put(arr[i], i);\\n        \\n        long total = 0;\\n        for(int i=0;i<arr.length;i++) {\\n            total += getNumBinaryTrees(arr[i], dp);\\n        }\\n        return (int) (total % MOD);\\n    }\\n    \\n    private long getNumBinaryTrees(int num, long[] dp) {\\n\\t\\t/// Don\\'t process this number if this number not even present in input `arr`\\n        if(!numToIndex.containsKey(num)) return 0;\\n        \\n        int index = numToIndex.get(num);\\n\\t\\t/// if for this `num` we already calculated the result, then return the result\\n        if(dp[index] != -1) return dp[index];\\n        \\n\\t\\t/// Very beginning single node can form a tree, so initialize count = 1\\n        long count = 1;\\n        \\n        for(int i=0;i<arr.length;i++) {\\n\\t\\t\\t// Check if this `arr[i]` is factor of parameter `num` as well as there is other factor `num / arr[i]` present in input \\n            if(num % arr[i] == 0 && numToIndex.containsKey(num / arr[i])) {\\n                count += (getNumBinaryTrees(arr[i], dp) * getNumBinaryTrees(num / arr[i], dp)); \\n            }\\n        }\\n\\t\\t/// Update DP with count we found\\n        dp[index] = count;\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    final static int MOD = 1000_000_000 + 7;\\n    int[] arr;\\n    Map<Integer, Integer> numToIndex;\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        numToIndex = new HashMap<>();\\n        this.arr = arr;\\n        long[] dp = new long[arr.length];\\n        Arrays.fill(dp, -1);\\n        for(int i=0;i<arr.length;i++) numToIndex.put(arr[i], i);\\n        \\n        long total = 0;\\n        for(int i=0;i<arr.length;i++) {\\n            total += getNumBinaryTrees(arr[i], dp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1107610,
                "title": "rust-hashmap-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nconst MOD: i64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn num_factored_binary_trees(arr: Vec<i32>) -> i32 {\\n        let mut hm = arr.iter().map(|&n| (n, 1)).collect::<HashMap<_, _>>();\\n        let mut arr = arr;\\n        arr.sort_unstable();\\n        for i in 1..arr.len() {\\n            for j in 0..i {\\n                if arr[i] % arr[j] == 0 {\\n                    if let Some(&v) = hm.get(&(arr[i] / arr[j])) {\\n                        let vj = *hm.get_mut(&arr[j]).unwrap();\\n                        if let Some(vi) = hm.get_mut(&arr[i]) {\\n                            *vi = (*vi + vj * v) % MOD\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        (hm.values().sum::<i64>() % MOD) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nconst MOD: i64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn num_factored_binary_trees(arr: Vec<i32>) -> i32 {\\n        let mut hm = arr.iter().map(|&n| (n, 1)).collect::<HashMap<_, _>>();\\n        let mut arr = arr;\\n        arr.sort_unstable();\\n        for i in 1..arr.len() {\\n            for j in 0..i {\\n                if arr[i] % arr[j] == 0 {\\n                    if let Some(&v) = hm.get(&(arr[i] / arr[j])) {\\n                        let vj = *hm.get_mut(&arr[j]).unwrap();\\n                        if let Some(vi) = hm.get_mut(&arr[i]) {\\n                            *vi = (*vi + vj * v) % MOD\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        (hm.values().sum::<i64>() % MOD) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1107357,
                "title": "python-go-by-dp-w-diagram",
                "content": "**Hint**:\\n\\n1. **Sort** A to make it in **ascending order**\\n\\n2. **Scan each root** node value, and **decompose it to all possible factors** (i.e., the so-called child node value in binary tree).\\n\\n3. **Update the number of binary tree** into dp table by dp[ x ] += dp[ y ] * dp[ x / y ]\\n\\n4. Repeat step 2 and step 3 to build DP table in bottom-up order.\\n\\n5. Finally, **sum up the DP table\\'s value** and get the total count.\\n\\n6. **Don\\'t forget to take the mod** (10^9 + 7), which is defined by description.\\n\\n---\\n\\n**Diagram**:\\n\\n![image](https://assets.leetcode.com/users/images/7e2920a0-022f-41d4-8030-3dde4f47e9d5_1615643306.8414311.png)\\n\\n\\n---\\n\\n**Implementation** by classic 2D DP\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A):\\n        \\n        ## dictionary\\n        # key: root node value\\n        # value: number of binary tree\\n        dp = defaultdict(int)\\n        \\n        \\n        # keep A sorted in ascending order\\n        A.sort()\\n        \\n        constant, size = (10**9 + 7), len(A)\\n        \\n        \\n        # scan each possible root node value\\n        for i, cur_num in enumerate(A):\\n            \\n            # Case 1: cur_num as root with child nodes\\n            \\n            # scan each potential child node value    \\n            for j in range(i):\\n                \\n                factor = A[j]\\n                quotient, remainder = divmod(cur_num, factor)\\n                \\n                # current (factor, quotient) pair are feasible to be child nodes \\n                if remainder == 0:\\n                    dp[cur_num] += dp[quotient] * dp[factor]\\n            \\n            # Case 2: cur_num as root without child nodes\\n            dp[cur_num] += 1\\n            \\n        return sum( dp.values() ) % constant\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nimport (\\n    \"math\"\\n    \"sort\"\\n)\\n\\nfunc numFactoredBinaryTrees(arr []int) int {\\n    \\n    \\n    \\n    // map\\n    // key: root node value\\n    // value: number of binary tree\\n    dp := make( map[int]int) \\n    \\n    constant := (int)(math.Pow(10, 9) + 7)\\n    \\n    // keep A sorted in ascending order\\n    sort.Ints(arr)\\n    \\n    // scan each possible root node value\\n    for i, curNum := range arr{\\n        \\n        // Case 1: cur_num as root with child nodes\\n        \\n        // scan each potential child node value    \\n        for j := 0 ; j < i ; j+=1 {\\n            \\n            factor := arr[j]\\n            \\n            quotient, remainder := curNum / factor, curNum % factor\\n            \\n            // current (factor, quotient) pair are feasible to be child nodes \\n            if remainder == 0{\\n                dp[curNum] += dp[factor] * dp[quotient]\\n            }\\n            \\n        }\\n        \\n        \\n        // Case 2: cur_num as root without child nodes\\n        dp[curNum] += 1\\n        \\n    }\\n    \\n    \\n    totalCount := 0\\n    for _, count := range dp{\\n        totalCount += count\\n    }\\n    \\n    return totalCount % constant\\n}\\n//end of function numFactoredBinaryTrees\\n```\\n\\n---\\n\\n**Implementation** by classic 2D DP with improvement on factor search upperbound\\n\\nPython:\\n\\n```\\n# native bisection module in Python\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A):\\n        \\n        ## dictionary\\n        # key: root node value\\n        # value: number of binary tree\\n        dp = defaultdict(int)\\n        \\n        \\n        # keep A sorted in ascending order\\n        A.sort()\\n        \\n        constant, size = (10**9 + 7), len(A)\\n        \\n        \\n        # scan each possible root node value\\n        for i, cur_num in enumerate(A):\\n            \\n            # upper bound is the index of largest factor to cur_num\\n            upperbound = bisect(A ,int(sqrt(cur_num)))\\n            \\n            # Case 1: cur_num as root with child nodes\\n            \\n            # scan each potential child node value    \\n            for j in range(upperbound):\\n                \\n                factor = A[j]\\n                quotient, remainder = divmod(cur_num, factor)\\n                \\n                # current (factor, quotient) pair are feasible to be child nodes \\n                if remainder == 0:\\n                    \\n                    if quotient == factor:\\n                        # factor is square root of cur_num\\n                        dp[cur_num] += dp[quotient] * dp[factor]\\n                        \\n                    else:\\n                        # factor is not square root of cur_num\\n                        # (factor, quotient) and (quotient, factor) are symmetric, therefore * 2\\n                        dp[cur_num] += dp[quotient] * dp[factor] * 2\\n            \\n            # Case 2: cur_num as root without child nodes\\n            dp[cur_num] += 1\\n            \\n        return sum( dp.values() ) % constant\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nimport (\\n    \"math\"\\n    \"sort\"\\n)\\n\\nfunc numFactoredBinaryTrees(arr []int) int {\\n    \\n    \\n    \\n    // map\\n    // key: root node value\\n    // value: number of binary tree\\n    dp := make( map[int]int) \\n    \\n    constant := (int)(math.Pow(10, 9) + 7)\\n    \\n    // keep A sorted in ascending order\\n    sort.Ints(arr)\\n    \\n    // scan each possible root node value\\n    for _, curNum := range arr{\\n        \\n        upperbound := sort.Search( len(arr), func(i int) bool { return arr[i] > int(math.Sqrt( float64(curNum) ) ) } )\\n        \\n        // Case 1: cur_num as root with child nodes\\n        \\n        // scan each potential child node value    \\n        for j := 0 ; j < upperbound ; j+=1 {\\n            \\n            factor := arr[j]\\n            \\n            quotient, remainder := curNum / factor, curNum % factor\\n            \\n            // current (factor, quotient) pair are feasible to be child nodes \\n            if remainder == 0{\\n                \\n                if quotient == factor{\\n                    \\n                    // factor is square root of cur_num\\n                    dp[curNum] += dp[factor] * dp[quotient]    \\n                    \\n                }else{\\n                    \\n                    // factor is not square root of cur_num\\n                    // (factor, quotient) and (quotient, factor) are symmetric, therefore * 2\\n                    dp[curNum] += dp[factor] * dp[quotient] * 2\\n                }\\n            }\\n            \\n        }\\n        //end of loop j\\n        \\n        // Case 2: cur_num as root without child nodes\\n        dp[curNum] += 1\\n        \\n    }\\n    //end of loop i\\n    \\n    totalCount := 0\\n    for _, count := range dp{\\n        totalCount += count\\n    }\\n    \\n    return totalCount % constant\\n}\\n//end of function numFactoredBinaryTrees\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [MIT OCW: Dynamic Programming](https://youtu.be/OQ5jsbhAv_M)\\n\\n[2] [Python official docs about bisection module](https://docs.python.org/3/library/bisect.html)\\n\\n[3] [Golang official docs about sort and search](https://golang.org/pkg/sort/)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A):\\n        \\n        ## dictionary\\n        # key: root node value\\n        # value: number of binary tree\\n        dp = defaultdict(int)\\n        \\n        \\n        # keep A sorted in ascending order\\n        A.sort()\\n        \\n        constant, size = (10**9 + 7), len(A)\\n        \\n        \\n        # scan each possible root node value\\n        for i, cur_num in enumerate(A):\\n            \\n            # Case 1: cur_num as root with child nodes\\n            \\n            # scan each potential child node value    \\n            for j in range(i):\\n                \\n                factor = A[j]\\n                quotient, remainder = divmod(cur_num, factor)\\n                \\n                # current (factor, quotient) pair are feasible to be child nodes \\n                if remainder == 0:\\n                    dp[cur_num] += dp[quotient] * dp[factor]\\n            \\n            # Case 2: cur_num as root without child nodes\\n            dp[cur_num] += 1\\n            \\n        return sum( dp.values() ) % constant\\n```\n```\\nimport (\\n    \"math\"\\n    \"sort\"\\n)\\n\\nfunc numFactoredBinaryTrees(arr []int) int {\\n    \\n    \\n    \\n    // map\\n    // key: root node value\\n    // value: number of binary tree\\n    dp := make( map[int]int) \\n    \\n    constant := (int)(math.Pow(10, 9) + 7)\\n    \\n    // keep A sorted in ascending order\\n    sort.Ints(arr)\\n    \\n    // scan each possible root node value\\n    for i, curNum := range arr{\\n        \\n        // Case 1: cur_num as root with child nodes\\n        \\n        // scan each potential child node value    \\n        for j := 0 ; j < i ; j+=1 {\\n            \\n            factor := arr[j]\\n            \\n            quotient, remainder := curNum / factor, curNum % factor\\n            \\n            // current (factor, quotient) pair are feasible to be child nodes \\n            if remainder == 0{\\n                dp[curNum] += dp[factor] * dp[quotient]\\n            }\\n            \\n        }\\n        \\n        \\n        // Case 2: cur_num as root without child nodes\\n        dp[curNum] += 1\\n        \\n    }\\n    \\n    \\n    totalCount := 0\\n    for _, count := range dp{\\n        totalCount += count\\n    }\\n    \\n    return totalCount % constant\\n}\\n//end of function numFactoredBinaryTrees\\n```\n```\\n# native bisection module in Python\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def numFactoredBinaryTrees(self, A):\\n        \\n        ## dictionary\\n        # key: root node value\\n        # value: number of binary tree\\n        dp = defaultdict(int)\\n        \\n        \\n        # keep A sorted in ascending order\\n        A.sort()\\n        \\n        constant, size = (10**9 + 7), len(A)\\n        \\n        \\n        # scan each possible root node value\\n        for i, cur_num in enumerate(A):\\n            \\n            # upper bound is the index of largest factor to cur_num\\n            upperbound = bisect(A ,int(sqrt(cur_num)))\\n            \\n            # Case 1: cur_num as root with child nodes\\n            \\n            # scan each potential child node value    \\n            for j in range(upperbound):\\n                \\n                factor = A[j]\\n                quotient, remainder = divmod(cur_num, factor)\\n                \\n                # current (factor, quotient) pair are feasible to be child nodes \\n                if remainder == 0:\\n                    \\n                    if quotient == factor:\\n                        # factor is square root of cur_num\\n                        dp[cur_num] += dp[quotient] * dp[factor]\\n                        \\n                    else:\\n                        # factor is not square root of cur_num\\n                        # (factor, quotient) and (quotient, factor) are symmetric, therefore * 2\\n                        dp[cur_num] += dp[quotient] * dp[factor] * 2\\n            \\n            # Case 2: cur_num as root without child nodes\\n            dp[cur_num] += 1\\n            \\n        return sum( dp.values() ) % constant\\n```\n```\\nimport (\\n    \"math\"\\n    \"sort\"\\n)\\n\\nfunc numFactoredBinaryTrees(arr []int) int {\\n    \\n    \\n    \\n    // map\\n    // key: root node value\\n    // value: number of binary tree\\n    dp := make( map[int]int) \\n    \\n    constant := (int)(math.Pow(10, 9) + 7)\\n    \\n    // keep A sorted in ascending order\\n    sort.Ints(arr)\\n    \\n    // scan each possible root node value\\n    for _, curNum := range arr{\\n        \\n        upperbound := sort.Search( len(arr), func(i int) bool { return arr[i] > int(math.Sqrt( float64(curNum) ) ) } )\\n        \\n        // Case 1: cur_num as root with child nodes\\n        \\n        // scan each potential child node value    \\n        for j := 0 ; j < upperbound ; j+=1 {\\n            \\n            factor := arr[j]\\n            \\n            quotient, remainder := curNum / factor, curNum % factor\\n            \\n            // current (factor, quotient) pair are feasible to be child nodes \\n            if remainder == 0{\\n                \\n                if quotient == factor{\\n                    \\n                    // factor is square root of cur_num\\n                    dp[curNum] += dp[factor] * dp[quotient]    \\n                    \\n                }else{\\n                    \\n                    // factor is not square root of cur_num\\n                    // (factor, quotient) and (quotient, factor) are symmetric, therefore * 2\\n                    dp[curNum] += dp[factor] * dp[quotient] * 2\\n                }\\n            }\\n            \\n        }\\n        //end of loop j\\n        \\n        // Case 2: cur_num as root without child nodes\\n        dp[curNum] += 1\\n        \\n    }\\n    //end of loop i\\n    \\n    totalCount := 0\\n    for _, count := range dp{\\n        totalCount += count\\n    }\\n    \\n    return totalCount % constant\\n}\\n//end of function numFactoredBinaryTrees\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107218,
                "title": "simple-dp-solution-in-java-using-hashmap-and-sorting-explained",
                "content": "Notes before approaching the problem -\\n* The key to this problem is not thinking of it as a tree problem at all. \\n* Just have to think of it as number of ways of forming 3 numbers such that `number1 * number2 == number3 and number3 > number1 and number3 > number2`\\n* The fact that you can use any number any number of times actually makes it easier than complex. You are saved from the hassle of deleting the number or marking it visited etc.\\n\\nImportant points while approaching the problem - \\n* We need to give each element in the array a chance to be a root node and since its childrens\\' multiplication is supposed to equal it, it is better if we sort the array and then move an `i` pointer ahead being the root and `j` pointer moving till `i`. ie) `i from 0 to array.length` and `j from 0 to i - 1`. \\n* While moving with `i` pointer if we find a `j`  that divides `arr[i]`, then we might have a solution because - If `a * b == c`, where `a` is the `arr[j]` and `c` is the `arr[i]`, we have a solution because acco to the problem, `b` can be equal to `a` ie) can be repeated. If not, we can find a `b` eventually by setting a variable called `b= c / a` and see if it exists in the array and if it does, it is the other child of the a, b and c subtree/tree.\\n* Use a hashmap to map elements to indexes while finding the `b` as said above\\n* We can use a DP table to track this down where initially all elements of DP table are `1` because every element of the array without any children is a  tree in itself. If the last two points above help us find an `a, b, c` pair, update the `dp[c] = dp[a] * dp[b]` as it will cover all the cases like `c` being the root, `a` the right child and `b` left child and  `c` being the root, `a` the left child and `b` right child.\\n* The final solution will be sum of values of the DP table. Take care of `long` in case of Java, CPP or C.\\n\\nJava code - \\n\\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int n = arr.length;\\n        if(n == 1){\\n            return 1;\\n        }\\n        Arrays.sort(arr);\\n        \\n        long[] dp = new long[n];\\n        Arrays.fill(dp, 1);\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            map.put(arr[i], i);\\n        }\\n        \\n        long ans = 0;\\n        int remaining = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                if(arr[i] % arr[j] == 0){\\n                    remaining = arr[i] / arr[j];\\n                    if(map.containsKey(remaining)){\\n                        dp[i] += dp[j] * dp[map.get(remaining)];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(long v : dp){\\n            ans += v;\\n        }\\n        return (int) (ans % 1_000_000_007);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int n = arr.length;\\n        if(n == 1){\\n            return 1;\\n        }\\n        Arrays.sort(arr);\\n        \\n        long[] dp = new long[n];\\n        Arrays.fill(dp, 1);\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            map.put(arr[i], i);\\n        }\\n        \\n        long ans = 0;\\n        int remaining = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                if(arr[i] % arr[j] == 0){\\n                    remaining = arr[i] / arr[j];\\n                    if(map.containsKey(remaining)){\\n                        dp[i] += dp[j] * dp[map.get(remaining)];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(long v : dp){\\n            ans += v;\\n        }\\n        return (int) (ans % 1_000_000_007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086422,
                "title": "explained-short-dp-solution-cpp-similar-question-link-also",
                "content": "If you had already solved question in which you have to find the pairs in array whose sum is divisible by k (any integer) using hashmap then congratulations you already solved 80% of this question for remaining 20% let me help you.\\nnow first you have to sort the given array so that you can iterate over the elements before a particular element and consider it as a non-leaf node element and the elements before it as it\\'s childrens . now simply you have to find the pairs divisible by it and multiply thier value and add it to the result.\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n         unordered_map<int,int64_t> freq;\\n         long long int count=0;\\n         long long int mod = pow(10,9)+7;\\n         sort(arr.begin(),arr.end());\\n         for(int i=0;i<arr.size();i++){\\n             int data = arr[i];\\n             freq[arr[i]]++;\\n             for(int j=i-1;j>=0;j--){\\n                 if(data%arr[j] == 0 && freq.count(data/arr[j])){\\n                     freq[data] = (freq[data]+(freq[arr[j]] * freq[data/arr[j]]))%mod;\\n                 }\\n             }\\n             count = (count+freq[data])%mod;\\n         }\\n         return count;\\n    }\\n};\\n```\\n\\nQuestion Link : https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/\\nKindly upvote if you like my solution.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n         unordered_map<int,int64_t> freq;\\n         long long int count=0;\\n         long long int mod = pow(10,9)+7;\\n         sort(arr.begin(),arr.end());\\n         for(int i=0;i<arr.size();i++){\\n             int data = arr[i];\\n             freq[arr[i]]++;\\n             for(int j=i-1;j>=0;j--){\\n                 if(data%arr[j] == 0 && freq.count(data/arr[j])){\\n                     freq[data] = (freq[data]+(freq[arr[j]] * freq[data/arr[j]]))%mod;\\n                 }\\n             }\\n             count = (count+freq[data])%mod;\\n         }\\n         return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955960,
                "title": "java-beat-100-10ms-dp",
                "content": "```java\\npublic int numFactoredBinaryTrees(int[] A) {\\n\\tArrays.sort(A);\\n\\tMap<Long, Integer> numbers = new HashMap<>();\\n\\tfor(int i = 0; i < A.length; i++) {\\n\\t\\tnumbers.put((long) A[i], i);\\n\\t}\\n\\n\\tlong[] memo = new long[A.length];\\n\\tArrays.fill(memo, 1);\\n\\n\\tlong count = 0;\\n\\tfor(int idx = 0; idx < A.length; idx++) {\\n\\t\\t for(int i = 0; i <= idx; i++) {\\n\\t\\t\\tlong mul = ((long) A[i])*A[idx];\\n\\t\\t\\t if(mul > Integer.MAX_VALUE) {\\n\\t\\t\\t\\t break;\\n\\t\\t\\t }\\n\\t\\t\\tInteger pos = numbers.get(mul);\\n\\t\\t\\tif(pos != null) {\\n\\t\\t\\t\\tint factor = A[i] == A[idx] ? 1 : 2;\\n\\t\\t\\t\\tmemo[pos] += factor * memo[i] * memo[idx];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcount += memo[idx];\\n\\t}\\n\\n\\treturn (int) (count % 1000000007);\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int numFactoredBinaryTrees(int[] A) {\\n\\tArrays.sort(A);\\n\\tMap<Long, Integer> numbers = new HashMap<>();\\n\\tfor(int i = 0; i < A.length; i++) {\\n\\t\\tnumbers.put((long) A[i], i);\\n\\t}\\n\\n\\tlong[] memo = new long[A.length];\\n\\tArrays.fill(memo, 1);\\n\\n\\tlong count = 0;\\n\\tfor(int idx = 0; idx < A.length; idx++) {\\n\\t\\t for(int i = 0; i <= idx; i++) {\\n\\t\\t\\tlong mul = ((long) A[i])*A[idx];\\n\\t\\t\\t if(mul > Integer.MAX_VALUE) {\\n\\t\\t\\t\\t break;\\n\\t\\t\\t }\\n\\t\\t\\tInteger pos = numbers.get(mul);\\n\\t\\t\\tif(pos != null) {\\n\\t\\t\\t\\tint factor = A[i] == A[idx] ? 1 : 2;\\n\\t\\t\\t\\tmemo[pos] += factor * memo[i] * memo[idx];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcount += memo[idx];\\n\\t}\\n\\n\\treturn (int) (count % 1000000007);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 835232,
                "title": "recursive-dp-intuition-c",
                "content": "It\\'s extremely slow, but I\\'m quite proud of what I came up with.\\nThe intuition goes like this: \\nSay we\\'re given an array such as [20, 10, 5, 4, 2] (doesn\\'t have to be sorted)\\nWe can choose to break up 20 with 10, 5, 4, or 2 and count trees(20) i.e. the number of trees 20 can form. Start with 10 as the left node of 20 and 20/10 = 2 (which we check if it is in the array). Then we break the problem down into a sub problem where we repeat the same with trees(10) and trees(2).\\nOnce we\\'re done finding trees(10) can form with trees(2), we multiply them together. This is because\\ntrees(2) = length of [[2]] and trees(10) = [[10, 2, 5], [10]] and we can make 20 by using their different combinations.\\nSince we\\'re going to run into 10 later in the list, we use dynamic programming to memoize trees(10), storing it in a map.\\nThe listed solution stores the index instead which is smarter to do since it\\'s faster to access and under 1e9. We mod by 1e9+7 along the way to make sure it\\'s under overflow.\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    unordered_map<int, long> dp;\\n    unordered_map<int, int> exists;\\n    long total = 0;\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        for (int i = 0; i < A.size(); i++) {\\n            exists.insert({A[i], i});\\n            dp.insert({A[i], 0});\\n        }\\n        for (int i = 0; i < A.size(); i++) {\\n            total = (total + trees(A, i))%mod;\\n        }\\n        return total%mod;\\n    }\\n    \\n    long trees(vector<int>& A, int i) {\\n        auto searchdp = dp.find(A[i]);\\n        if (searchdp->second) return searchdp->second;\\n        searchdp->second = 1;\\n        for (int j = 0; j < A.size(); j++) {\\n            auto search = exists.find(A[i]/A[j]);\\n            if (!(A[i]%A[j]) && search != exists.end()) {\\n                searchdp->second = (searchdp->second + trees(A, j)*trees(A, search->second)) % mod;\\n            }\\n        }\\n        return searchdp->second;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    unordered_map<int, long> dp;\\n    unordered_map<int, int> exists;\\n    long total = 0;\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        for (int i = 0; i < A.size(); i++) {\\n            exists.insert({A[i], i});\\n            dp.insert({A[i], 0});\\n        }\\n        for (int i = 0; i < A.size(); i++) {\\n            total = (total + trees(A, i))%mod;\\n        }\\n        return total%mod;\\n    }\\n    \\n    long trees(vector<int>& A, int i) {\\n        auto searchdp = dp.find(A[i]);\\n        if (searchdp->second) return searchdp->second;\\n        searchdp->second = 1;\\n        for (int j = 0; j < A.size(); j++) {\\n            auto search = exists.find(A[i]/A[j]);\\n            if (!(A[i]%A[j]) && search != exists.end()) {\\n                searchdp->second = (searchdp->second + trees(A, j)*trees(A, search->second)) % mod;\\n            }\\n        }\\n        return searchdp->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 641851,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        long res = 0, mod = pow(10, 9) + 7;\\n        sort(A.begin(), A.end());\\n        unordered_map<int, long> dp;\\n        for (int i = 0; i < A.size(); ++i) {\\n            dp[A[i]] = 1;\\n            for (int j = 0; j < i; ++j)\\n                if (A[i] % A[j] == 0)\\n                    dp[A[i]] = (dp[A[i]] + dp[A[j]] * dp[A[i] / A[j]]) % mod;\\n            res = (res + dp[A[i]]) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        long res = 0, mod = pow(10, 9) + 7;\\n        sort(A.begin(), A.end());\\n        unordered_map<int, long> dp;\\n        for (int i = 0; i < A.size(); ++i) {\\n            dp[A[i]] = 1;\\n            for (int j = 0; j < i; ++j)\\n                if (A[i] % A[j] == 0)\\n                    dp[A[i]] = (dp[A[i]] + dp[A[j]] * dp[A[i] / A[j]]) % mod;\\n            res = (res + dp[A[i]]) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361866,
                "title": "simple-scala-solution",
                "content": "Intuition: \\n\\nFor each element `a` of the sorted array `A`, we filter out all the `k`-keys found so far such that `a % k == 0`. As stated in the main solution, if we have a `dp`-table that memoizes all solutions seen so far (in sorted order) and the root node of the tree (with value `v`) has children with values `left` and `right` (and `left * right == v`), then this contributes `dp(left) * dp(right)` possible ways to make this tree.\\n\\nWe fold the filtered values with a starting value of 1 (for the identity case in which the tree is a single element) and sum all the products, defaulting to 0 when the complementing child cannot be found.\\n\\n```\\nobject Solution {\\n    def numFactoredBinaryTrees(A: Array[Int]): Int = {\\n      var dp = Map[Int, Long]().withDefaultValue(0L)      \\n      for (a <- A.sorted) {\\n        val dpValue = dp\\n          .keys\\n          .filter(a % _ == 0)\\n          .foldLeft(1L)((x, y) => {x + dp(y) * dp.getOrElse(a / y, 0L)})\\n        dp += (a -> dpValue)\\n      }\\n      (dp.values.sum % 1000000007L).toInt\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def numFactoredBinaryTrees(A: Array[Int]): Int = {\\n      var dp = Map[Int, Long]().withDefaultValue(0L)      \\n      for (a <- A.sorted) {\\n        val dpValue = dp\\n          .keys\\n          .filter(a % _ == 0)\\n          .foldLeft(1L)((x, y) => {x + dp(y) * dp.getOrElse(a / y, 0L)})\\n        dp += (a -> dpValue)\\n      }\\n      (dp.values.sum % 1000000007L).toInt\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 125916,
                "title": "c-dp-solution",
                "content": "assume dp[i] is the number of combinations and the recurrence relation is:\\ndp[i]=1+sum(dp[j]*dp[k]) for j=0 to i-1 and A[k]=A[i]/A[j]\\nwe have to sort the array in ascending order so that the recurrence relation is correct.\\n\\nUse the hash set to store all the numbers before i to save lookup time.\\nBe sure to use long long for dp[j]*dp[k], otherwise it will overflow.\\nalso the accumulation has to use 0LL for the initial value to avoid overflow.\\n\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        //a single node automatically satisify\\n        //for any number we shall try all possible combinations\\n        vector<long long> dp(A.size(),1);//long long is key!\\n        sort(A.begin(),A.end());\\n        const int tt=1000000000+7;\\n        //A[i]=A[j]*A[i/j]\\n        unordered_map<int,int> ms;//value with index\\n        for(int i=0;i<A.size();i++)\\n        {\\n            ms[A[i]]=i;\\n            for(int j=i-1;j>=0;j--) \\n            {\\n                if(A[i]%A[j]==0)//find one factor\\n                {\\n                    int t=A[i]/A[j];\\n                    if(ms.count(t)) dp[i]+=(dp[j]*dp[ms[t]])%tt;\\n                }\\n            }\\n        }\\n        //copy(dp.begin(),dp.end(),ostream_iterator<int>(cout,\" \"));\\n        long long ans=0;\\n        ans=accumulate(dp.begin(),dp.end(),0LL);\\n        //for(int i=0;i<dp.size();i++) ans=(ans+dp[i])%tt;\\n        return ans%tt;//%tt+7;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& A) {\\n        //a single node automatically satisify\\n        //for any number we shall try all possible combinations\\n        vector<long long> dp(A.size(),1);//long long is key!\\n        sort(A.begin(),A.end());\\n        const int tt=1000000000+7;\\n        //A[i]=A[j]*A[i/j]\\n        unordered_map<int,int> ms;//value with index\\n        for(int i=0;i<A.size();i++)\\n        {\\n            ms[A[i]]=i;\\n            for(int j=i-1;j>=0;j--) \\n            {\\n                if(A[i]%A[j]==0)//find one factor\\n                {\\n                    int t=A[i]/A[j];\\n                    if(ms.count(t)) dp[i]+=(dp[j]*dp[ms[t]])%tt;\\n                }\\n            }\\n        }\\n        //copy(dp.begin(),dp.end(),ostream_iterator<int>(cout,\" \"));\\n        long long ans=0;\\n        ans=accumulate(dp.begin(),dp.end(),0LL);\\n        //for(int i=0;i<dp.size();i++) ans=(ans+dp[i])%tt;\\n        return ans%tt;//%tt+7;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3863486,
                "title": "easy-implementation-using-sorting-and-map-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n = arr.size(), mod = 1e9+7;\\n        sort(arr.begin(),arr.end());\\n        map<int,int>idx;\\n        map<int,long long>mp;\\n        for(int i=0; i<n; i++){\\n            idx[arr[i]] = i;\\n            mp[i] = 1;\\n        }\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(arr[i] % arr[j] == 0 && idx.find(arr[i]/arr[j]) != idx.end()){\\n                    mp[i] += (mp[j] * mp[idx[arr[i]/arr[j]]]);\\n                    mp[i] = mp[i]%mod;\\n                }\\n            }\\n        }\\n\\n        long long ans = 0;\\n        for(auto i : mp){\\n            ans += i.second;\\n            ans %= mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n = arr.size(), mod = 1e9+7;\\n        sort(arr.begin(),arr.end());\\n        map<int,int>idx;\\n        map<int,long long>mp;\\n        for(int i=0; i<n; i++){\\n            idx[arr[i]] = i;\\n            mp[i] = 1;\\n        }\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(arr[i] % arr[j] == 0 && idx.find(arr[i]/arr[j]) != idx.end()){\\n                    mp[i] += (mp[j] * mp[idx[arr[i]/arr[j]]]);\\n                    mp[i] = mp[i]%mod;\\n                }\\n            }\\n        }\\n\\n        long long ans = 0;\\n        for(auto i : mp){\\n            ans += i.second;\\n            ans %= mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481564,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr)\\n    {\\n         sort(arr.begin(), arr.end());\\n        int len = arr.size();\\n        long ans = 0;\\n        unordered_map<int, long> fmap;\\n        for (int num : arr) {\\n            long ways = 1;\\n            double lim = sqrt(num);\\n            for (int j = 0, fA = arr[0]; fA <= lim; fA = arr[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.find(fB) != fmap.end())\\n                    ways = (ways + fmap[fA] * fmap[fB] * (fA == fB ? 1 : 2)) % 1000000007;\\n            }\\n            fmap[num] = ways;\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        total_nums = len(arr)\\n        moduler = 1000000007\\n        count_product_dict = {num: 1 for num in arr}\\n        arr.sort()\\n\\n        for i in range(1, total_nums):\\n            for j in range(i):\\n                quotient = arr[i] // arr[j]\\n                if quotient < 2 or math.sqrt(arr[i]) > arr[i- 1]:\\n                    break\\n                if arr[i] % arr[j] == 0:\\n                    count_product_dict[arr[i]] += count_product_dict[arr[j]] * count_product_dict.get(quotient, 0)\\n                    count_product_dict[arr[i]] %= moduler\\n                    \\n        return sum(count_product_dict.values()) % moduler\\n```\\n\\n```Java []\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        long [] dp = new long[arr.length];\\n        Arrays.fill(dp,1);\\n        long MOD=(int)1e9+7,ans=1;\\n        dp[0]=1;\\n        Map<Integer,Integer> index = new HashMap<Integer,Integer>();\\n        index.put(arr[0],0);\\n\\n        for(int i=1;i<dp.length;i++){\\n            index.put(arr[i],i);\\n\\n            for(int j=0;arr[j]<=Math.sqrt(arr[i]);j++){\\n                if(arr[j]*(long )arr[j]==arr[i]){\\n                    dp[i]+=dp[j] *(long ) dp[j]%MOD;\\n                    dp[i]%=MOD;\\n                }\\n                else if(arr[i]%arr[j]==0&&index.containsKey(arr[i]/arr[j])){\\n                    dp[i]+=dp[j]*dp[index.get(arr[i]/arr[j])]*2%MOD;\\n                }\\n            }\\n            ans=(ans+dp[i])%MOD;\\n        }\\n        return (int)ans;\\n     }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr)\\n    {\\n         sort(arr.begin(), arr.end());\\n        int len = arr.size();\\n        long ans = 0;\\n        unordered_map<int, long> fmap;\\n        for (int num : arr) {\\n            long ways = 1;\\n            double lim = sqrt(num);\\n            for (int j = 0, fA = arr[0]; fA <= lim; fA = arr[++j]) {\\n                if (num % fA != 0) continue;\\n                int fB = num / fA;\\n                if (fmap.find(fB) != fmap.end())\\n                    ways = (ways + fmap[fA] * fmap[fB] * (fA == fB ? 1 : 2)) % 1000000007;\\n            }\\n            fmap[num] = ways;\\n            ans = (ans + ways) % 1000000007;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        total_nums = len(arr)\\n        moduler = 1000000007\\n        count_product_dict = {num: 1 for num in arr}\\n        arr.sort()\\n\\n        for i in range(1, total_nums):\\n            for j in range(i):\\n                quotient = arr[i] // arr[j]\\n                if quotient < 2 or math.sqrt(arr[i]) > arr[i- 1]:\\n                    break\\n                if arr[i] % arr[j] == 0:\\n                    count_product_dict[arr[i]] += count_product_dict[arr[j]] * count_product_dict.get(quotient, 0)\\n                    count_product_dict[arr[i]] %= moduler\\n                    \\n        return sum(count_product_dict.values()) % moduler\\n```\n```Java []\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        long [] dp = new long[arr.length];\\n        Arrays.fill(dp,1);\\n        long MOD=(int)1e9+7,ans=1;\\n        dp[0]=1;\\n        Map<Integer,Integer> index = new HashMap<Integer,Integer>();\\n        index.put(arr[0],0);\\n\\n        for(int i=1;i<dp.length;i++){\\n            index.put(arr[i],i);\\n\\n            for(int j=0;arr[j]<=Math.sqrt(arr[i]);j++){\\n                if(arr[j]*(long )arr[j]==arr[i]){\\n                    dp[i]+=dp[j] *(long ) dp[j]%MOD;\\n                    dp[i]%=MOD;\\n                }\\n                else if(arr[i]%arr[j]==0&&index.containsKey(arr[i]/arr[j])){\\n                    dp[i]+=dp[j]*dp[index.get(arr[i]/arr[j])]*2%MOD;\\n                }\\n            }\\n            ans=(ans+dp[i])%MOD;\\n        }\\n        return (int)ans;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514113,
                "title": "c-simple-and-straight-forword-solution",
                "content": "**Please upvote if you like this solution**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        long long int ans=1;\\n        sort(arr.begin(),arr.end());\\n        map<int,long long int> mp;\\n        mp[arr[0]]++;\\n        for(int i=1;i<arr.size();i++){\\n            mp[arr[i]]++;\\n            for(int j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    if(mp[arr[i]/arr[j]]>0){\\n                         mp[arr[i]]+= (mp[arr[j]]*mp[arr[i]/arr[j]]);\\n                    }\\n                }\\n            }\\n            ans+=mp[arr[i]];\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        long long int ans=1;\\n        sort(arr.begin(),arr.end());\\n        map<int,long long int> mp;\\n        mp[arr[0]]++;\\n        for(int i=1;i<arr.size();i++){\\n            mp[arr[i]]++;\\n            for(int j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    if(mp[arr[i]/arr[j]]>0){\\n                         mp[arr[i]]+= (mp[arr[j]]*mp[arr[i]/arr[j]]);\\n                    }\\n                }\\n            }\\n            ans+=mp[arr[i]];\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430488,
                "title": "golang-math",
                "content": "If x%a == 0 and x%b == 0\\nand a,b are already in the map, (since the arr is sorted, the factors would come before the actual num) \\nthen num of factors of mem[x] = mem[a] * mem[b]\\nwhere mem[i] is the number of factors of i\\n```\\nfunc numFactoredBinaryTrees(arr []int) int {\\n    mem := make(map[int]int, 0)\\n    \\n    sort.Slice(arr, func(i,j int) bool {return arr[i] < arr[j]})\\n    \\n    result := 0\\n    \\n    for i:=0; i<len(arr); i++ {\\n        \\n        for key, _ := range mem {\\n            if arr[i] % key == 0 {\\n                quotient := arr[i]/key\\n                \\n                if _, ok := mem[quotient]; ok {\\n                    mem[arr[i]] += (mem[key] % (1e9 + 7)) * (mem[quotient] % (1e9 + 7))\\n                }\\n            }\\n        }\\n        mem[arr[i]] += 1\\n        result += mem[arr[i]] % (1e9 + 7)\\n    }\\n    \\n    return result % (1e9 + 7)\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "If x%a == 0 and x%b == 0\\nand a,b are already in the map, (since the arr is sorted, the factors would come before the actual num) \\nthen num of factors of mem[x] = mem[a] * mem[b]\\nwhere mem[i] is the number of factors of i\\n```\\nfunc numFactoredBinaryTrees(arr []int) int {\\n    mem := make(map[int]int, 0)\\n    \\n    sort.Slice(arr, func(i,j int) bool {return arr[i] < arr[j]})\\n    \\n    result := 0\\n    \\n    for i:=0; i<len(arr); i++ {\\n        \\n        for key, _ := range mem {\\n            if arr[i] % key == 0 {\\n                quotient := arr[i]/key\\n                \\n                if _, ok := mem[quotient]; ok {\\n                    mem[arr[i]] += (mem[key] % (1e9 + 7)) * (mem[quotient] % (1e9 + 7))\\n                }\\n            }\\n        }\\n        mem[arr[i]] += 1\\n        result += mem[arr[i]] % (1e9 + 7)\\n    }\\n    \\n    return result % (1e9 + 7)\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2426630,
                "title": "python3-solution-using-bottom-up-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr = sorted(arr)\\n        dp = {x: 1 for x in arr}\\n        count = 1\\n        for i in range(1, len(arr)):\\n            for j in range(i):\\n                if arr[i] % arr[j] == 0 and arr[i] / arr[j] in dp:\\n                    dp[arr[i]] += dp[arr[j]] * dp[arr[i] / arr[j]]\\n            count += dp[arr[i]]\\n        return count % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr = sorted(arr)\\n        dp = {x: 1 for x in arr}\\n        count = 1\\n        for i in range(1, len(arr)):\\n            for j in range(i):\\n                if arr[i] % arr[j] == 0 and arr[i] / arr[j] in dp:\\n                    dp[arr[i]] += dp[arr[j]] * dp[arr[i] / arr[j]]\\n            count += dp[arr[i]]\\n        return count % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411219,
                "title": "go-75",
                "content": "```\\nfunc numFactoredBinaryTrees(arr []int) int {\\n    sort.Ints(arr)\\n    mod := int(1e9 + 7)\\n    dp := map[int]int{}\\n    for _, num := range arr {\\n        dp[num] = 1\\n    }\\n    \\n    for i, num := range arr {\\n        for _, x := range arr[:i] {\\n            if num % x != 0 {\\n                continue\\n            }\\n            if v, ok := dp[num / x]; ok {\\n                dp[num] += dp[x] * v\\n                dp[num] %= mod\\n            }\\n        } \\n    }\\n    \\n    sum := 0\\n    for _, v := range dp {\\n        sum += v\\n    }\\n    return sum % mod\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numFactoredBinaryTrees(arr []int) int {\\n    sort.Ints(arr)\\n    mod := int(1e9 + 7)\\n    dp := map[int]int{}\\n    for _, num := range arr {\\n        dp[num] = 1\\n    }\\n    \\n    for i, num := range arr {\\n        for _, x := range arr[:i] {\\n            if num % x != 0 {\\n                continue\\n            }\\n            if v, ok := dp[num / x]; ok {\\n                dp[num] += dp[x] * v\\n                dp[num] %= mod\\n            }\\n        } \\n    }\\n    \\n    sum := 0\\n    for _, v := range dp {\\n        sum += v\\n    }\\n    return sum % mod\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2409005,
                "title": "python-simple-and-easy-solution-clean-code-faster-than-99",
                "content": "# Approach:\\n\\nFor every parent we want to see how many pairs of child exist \\n\\nLets take an example: `[4,2,8]`\\nFor `8` we can have `(4,2)`, `(2,4)`  and then for `4` we can have `(2,2)`\\nBuilding up on the solution of `4`, for `8` there are 5 ways: \\n`8 -> ((2,2), 2)` \\n`8 -> (2, (2,2))` \\n`8 -> (4, 2)` \\n`8 -> (2, 4)`\\n`8 `\\n\\n\\n# Solution: \\n\\nFirst we sort the array in ascending order: `[2,4,8]` so that we can build (no of ways) from smallest element\\nand then build up the solution for parent:\\n\\n`no_of_ways[parent] = no_of_ways[child] * no_of_ways[other_child]`\\n\\n\\nSee solution below:\\n\\n```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        \\n        mem = {}\\n        for parent in arr:\\n            mem[parent] = 1\\n            \\n            for child in arr:\\n                other_child = parent/child\\n                if other_child in mem:\\n                    mem[parent] += (mem[other_child] * mem[child]) % 1000000007\\n\\n        \\n        \\n        return (sum(mem.values()) % 1000000007)\\n```\\n\\nAbove solution has `O(n^2)` time complexity.\\n\\nTo optimise this further, we can run the inner loop till `sqrt(n)` (since we will identify all the factors for the parent present in the array)\\n\\nNote: But if the two children are different they are to be counted separatem eg: `(2,4)` and `(4,2)` \\nand when the two children are same they are to be counted as one eg: `(2,2)`\\n\\n\\n```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n\\n        mem = {}\\n        for parent in arr:\\n            mem[parent] = 1\\n\\n            for child in arr:\\n                if child > math.sqrt(parent):\\n                    break\\n\\n                other_child = parent / child\\n                if other_child in mem:\\n                    mem[parent] += (\\n                        (mem[other_child] * mem[child])\\n                        * (1 if other_child == child else 2)\\n                    ) % 1000000007\\n\\n        return sum(mem.values()) % 1000000007\\n```\\n\\nFor worst cases time complexity is still `O(n^2)`",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        \\n        mem = {}\\n        for parent in arr:\\n            mem[parent] = 1\\n            \\n            for child in arr:\\n                other_child = parent/child\\n                if other_child in mem:\\n                    mem[parent] += (mem[other_child] * mem[child]) % 1000000007\\n\\n        \\n        \\n        return (sum(mem.values()) % 1000000007)\\n```\n```python\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n\\n        mem = {}\\n        for parent in arr:\\n            mem[parent] = 1\\n\\n            for child in arr:\\n                if child > math.sqrt(parent):\\n                    break\\n\\n                other_child = parent / child\\n                if other_child in mem:\\n                    mem[parent] += (\\n                        (mem[other_child] * mem[child])\\n                        * (1 if other_child == child else 2)\\n                    ) % 1000000007\\n\\n        return sum(mem.values()) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403783,
                "title": "java-detailed-solution-using-dp",
                "content": "Hopefully everyone get the solution with the help of comments...\\n```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int n = arr.length;\\n        //returning 0 if the length of the array is 0 because binary tree should is not possible.\\n        if(n == 0)\\n            return 0;\\n        //sort will help to track the elements\\n        Arrays.sort(arr);\\n        \\n        //map will remember for already occured elements\\n        HashMap<Integer, Long> mp = new HashMap<>();\\n        \\n        //i will not change so treating like a constant only\\n        int i = 0;\\n        for(; i < n; i++){\\n            //count is 1(l is for long) because every element is a tree in itself\\n            long count = 1l;\\n            for(int j = 0; j < i; j++){\\n                //this will check is arr[j] can be the child of arr[i] and if yes then we check if\\n                //arr[i]/arr[j] had an element in map then we can say it is the valid relation\\n                //else count is 1 only.\\n                if((arr[i] % arr[j] == 0) && (mp.containsKey(arr[i] / arr[j]) == true)){\\n                    // this line calculating count = 1 + (count of ways generating arr[j] and arr[i]/arr[j])\\n                    count += mp.get(arr[j]) * mp.get(arr[i] / arr[j]); \\n                }\\n            }\\n            mp.put(arr[i], count);\\n        }\\n        long ans = 0;\\n        //adding up all the values(counts) of the map values to get the total number of trees geneated\\n        for(Map.Entry<Integer, Long> entry: mp.entrySet()){\\n            ans += (entry.getValue() % 1000000007);\\n        }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n```\\nComment below for any kind of doubt ;)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int n = arr.length;\\n        //returning 0 if the length of the array is 0 because binary tree should is not possible.\\n        if(n == 0)\\n            return 0;\\n        //sort will help to track the elements\\n        Arrays.sort(arr);\\n        \\n        //map will remember for already occured elements\\n        HashMap<Integer, Long> mp = new HashMap<>();\\n        \\n        //i will not change so treating like a constant only\\n        int i = 0;\\n        for(; i < n; i++){\\n            //count is 1(l is for long) because every element is a tree in itself\\n            long count = 1l;\\n            for(int j = 0; j < i; j++){\\n                //this will check is arr[j] can be the child of arr[i] and if yes then we check if\\n                //arr[i]/arr[j] had an element in map then we can say it is the valid relation\\n                //else count is 1 only.\\n                if((arr[i] % arr[j] == 0) && (mp.containsKey(arr[i] / arr[j]) == true)){\\n                    // this line calculating count = 1 + (count of ways generating arr[j] and arr[i]/arr[j])\\n                    count += mp.get(arr[j]) * mp.get(arr[i] / arr[j]); \\n                }\\n            }\\n            mp.put(arr[i], count);\\n        }\\n        long ans = 0;\\n        //adding up all the values(counts) of the map values to get the total number of trees geneated\\n        for(Map.Entry<Integer, Long> entry: mp.entrySet()){\\n            ans += (entry.getValue() % 1000000007);\\n        }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403709,
                "title": "java-hashmap-optimized",
                "content": "```\\n\\tpublic int numFactoredBinaryTrees(int[] arr) {\\n\\t\\t//sort the array so that for any larger element we would already traversed \\n\\t\\t//smaller elements(maybe its factors)\\n        Arrays.sort(arr);\\n\\t\\t\\n\\t\\t//map stores elemenst and no of trees that can be formed using it as non leaf.\\n        HashMap<Integer, Long> map = new HashMap<>();\\n\\t\\t\\n\\t\\t//initialize the map with first element and count = 1 \\n        long count = 1;\\n        map.put(arr[0], count);\\n        \\n        for(int i = 1; i < arr.length; i++){\\n            long sum = 1;\\n\\t\\t\\t\\n\\t\\t\\t//for each arr[i] check if its factors exist in hashmap, \\n\\t\\t\\t//if yes then add product of no. of trees formed by keeping them as non leaf\\n            for(int num : map.keySet()){\\n                if(arr[i] % num == 0 && map.containsKey(arr[i] / num)){\\n                    sum += (map.get(arr[i]/num) * map.get(num));\\n                }\\n            }\\n\\t\\t\\t//add no. of trees formed using arr[i] i.e. sum to count and set sum against arr[i]\\n            count += sum;\\n            map.put(arr[i], sum);\\n        }\\n        return (int)(count%1000000007);\\n    }\\n\\t\\n\\t\\nConsider example [2,4]\\nInitially map = {2, 1}, for 4 we check if arr[i]%num== 0 which is true but \\nwe also need to check if the factor is present in the map so for that we are checking \\nmap.containsKey(arr[i]/num)) \\nif both conditions are true then we consider map.get(num) as no of trees formed using num as non-leaf node and \\nmap.get(arr[i]/num) as no of trees formed using arr[i]/num as non-leaf node, and \\nproduct of these two will give no of Trees can be formed using arr[i] as non-leaf. Keep adding them as you move forward.\\n\\n\\nLet\\'s take another example of [2, 10]\\nInitially map = {2, 1}\\nAgain for this 10%2 == 0 but map doesn\\'t contain 10/2 ie 5 so we can not create any other tree using 10 as non-leaf,\\nso the only valid tress will [2] and [10] so the ans would be 2 only.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int numFactoredBinaryTrees(int[] arr) {\\n\\t\\t//sort the array so that for any larger element we would already traversed \\n\\t\\t//smaller elements(maybe its factors)\\n        Arrays.sort(arr);\\n\\t\\t\\n\\t\\t//map stores elemenst and no of trees that can be formed using it as non leaf.\\n        HashMap<Integer, Long> map = new HashMap<>();\\n\\t\\t\\n\\t\\t//initialize the map with first element and count = 1 \\n        long count = 1;\\n        map.put(arr[0], count);\\n        \\n        for(int i = 1; i < arr.length; i++){\\n            long sum = 1;\\n\\t\\t\\t\\n\\t\\t\\t//for each arr[i] check if its factors exist in hashmap, \\n\\t\\t\\t//if yes then add product of no. of trees formed by keeping them as non leaf\\n            for(int num : map.keySet()){\\n                if(arr[i] % num == 0 && map.containsKey(arr[i] / num)){\\n                    sum += (map.get(arr[i]/num) * map.get(num));\\n                }\\n            }\\n\\t\\t\\t//add no. of trees formed using arr[i] i.e. sum to count and set sum against arr[i]\\n            count += sum;\\n            map.put(arr[i], sum);\\n        }\\n        return (int)(count%1000000007);\\n    }\\n\\t\\n\\t\\nConsider example [2,4]\\nInitially map = {2, 1}, for 4 we check if arr[i]%num== 0 which is true but \\nwe also need to check if the factor is present in the map so for that we are checking \\nmap.containsKey(arr[i]/num)) \\nif both conditions are true then we consider map.get(num) as no of trees formed using num as non-leaf node and \\nmap.get(arr[i]/num) as no of trees formed using arr[i]/num as non-leaf node, and \\nproduct of these two will give no of Trees can be formed using arr[i] as non-leaf. Keep adding them as you move forward.\\n\\n\\nLet\\'s take another example of [2, 10]\\nInitially map = {2, 1}\\nAgain for this 10%2 == 0 but map doesn\\'t contain 10/2 ie 5 so we can not create any other tree using 10 as non-leaf,\\nso the only valid tress will [2] and [10] so the ans would be 2 only.",
                "codeTag": "Unknown"
            },
            {
                "id": 2403426,
                "title": "concise-java-solution-o-n-2",
                "content": "class Solution {\\n\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int MOD = 1000000007;\\n        HashMap<Integer,Long> map = new HashMap<>();\\n        Arrays.sort(arr);\\n        for(int i=0; i<arr.length; i++){\\n            long count = 0;\\n            for(int j=0; j<i; j++){\\n                if(arr[i]%arr[j] == 0){\\n                    if(map.containsKey(arr[i]/arr[j])){\\n                        count += map.get(arr[i]/arr[j])*map.get(arr[j]); \\n                    }\\n                }\\n            }\\n            map.put(arr[i],count+1);\\n        }\\n        long res = 0;\\n        for(long i : map.values()){\\n            res += i;\\n        }\\n        return (int)(res%MOD);\\n    }\\n}",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int MOD = 1000000007;\\n        HashMap<Integer,Long> map = new HashMap<>();\\n        Arrays.sort(arr);\\n        for(int i=0; i<arr.length; i++){\\n            long count = 0;\\n            for(int j=0; j<i; j++){\\n                if(arr[i]%arr[j] == 0){\\n                    if(map.containsKey(arr[i]/arr[j])){\\n                        count += map.get(arr[i]/arr[j])*map.get(arr[j]); \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2403388,
                "title": "100-00-of-c-concise-hashmap-soln-clean-code",
                "content": "**If you found this solution helpful Please upvote it**\\n\\n\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        map<int , long long int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            // mp[arr[i]]=1;\\n            mp.insert({arr[i] , 1});\\n            \\n        }\\n        sort(arr.begin() , arr.end());\\n        \\n        for(int i=1;i<arr.size();i++){\\n            long long int count=0;\\n            auto it3 = mp.find(arr[i]);\\n            for(int j=0;j<i;j++){\\n                \\n                if(arr[i]%arr[j]==0){\\n                    auto it = mp.find(arr[i]/arr[j]);\\n                    auto it2 = mp.find(arr[j]);\\n                    if(it!=mp.end()){\\n                        count+=(it->second)*(it2->second);\\n                    }\\n                }\\n            }\\n            it3->second+=count;\\n        }\\n        long long int sum=0;\\n        \\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            sum+=it->second;\\n            \\n        }\\n        return sum % (1000000007);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        map<int , long long int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            // mp[arr[i]]=1;\\n            mp.insert({arr[i] , 1}",
                "codeTag": "Java"
            },
            {
                "id": 2403265,
                "title": "c-two-sum-approach-easy-and-intuitive-solution",
                "content": "# Guys! Please Upvote it\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll mod = 1e9+7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n = arr.size();\\n        sort(arr.begin(),arr.end());\\n        vector<ll> dp(n);\\n        dp[0] = 1;\\n        ll ans = 1;\\n        for(int idx = 1;idx<n;idx++)\\n        {\\n            ll target = arr[idx];\\n            int i=0,j=idx-1;\\n            ll ways = 1;\\n            while(i<=j)\\n            {\\n                ll mul = (((long)arr[i])*(arr[j]));\\n                if(mul == target)\\n                {\\n                    if(i == j)\\n                    {\\n                        ways += (dp[i]*dp[j])%mod;\\n                    }\\n                    else\\n                    {\\n                        ways += (((long)dp[i]*(long)dp[j])*2)%mod;\\n                    }\\n                    i++,j--;\\n                }\\n                else if(mul > target)\\n                {\\n                    j--;\\n                }\\n                else if(mul < target)\\n                {\\n                    i++;\\n                }\\n            }\\n            dp[idx] = ways;\\n            ans = (long)(ans + dp[idx])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll mod = 1e9+7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n = arr.size();\\n        sort(arr.begin(),arr.end());\\n        vector<ll> dp(n);\\n        dp[0] = 1;\\n        ll ans = 1;\\n        for(int idx = 1;idx<n;idx++)\\n        {\\n            ll target = arr[idx];\\n            int i=0,j=idx-1;\\n            ll ways = 1;\\n            while(i<=j)\\n            {\\n                ll mul = (((long)arr[i])*(arr[j]));\\n                if(mul == target)\\n                {\\n                    if(i == j)\\n                    {\\n                        ways += (dp[i]*dp[j])%mod;\\n                    }\\n                    else\\n                    {\\n                        ways += (((long)dp[i]*(long)dp[j])*2)%mod;\\n                    }\\n                    i++,j--;\\n                }\\n                else if(mul > target)\\n                {\\n                    j--;\\n                }\\n                else if(mul < target)\\n                {\\n                    i++;\\n                }\\n            }\\n            dp[idx] = ways;\\n            ans = (long)(ans + dp[idx])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403249,
                "title": "java-using-hashmap",
                "content": "class Solution {\\n     \\n    public int numFactoredBinaryTrees(int[] arr) {\\n          Arrays.sort(arr);\\n        Map<Integer,Long> map=new HashMap<>();//val,count\\n        long ans=0;\\n      for(int i=0;i<arr.length;i++){\\n            long count=1;\\n            for(int j=0;j<i;j++){\\n             if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j])){//found two factors as arr[j],arr[i]/arr[j]\\n                    count+=map.get(arr[j])*map.get(arr[i]/arr[j]);\\n                }\\n            }\\n            map.put(arr[i],count);\\n            ans=ans+count;//value of every key in map sum up to ans\\n        }\\n        return (int)(ans%(1000000000+7));\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n     \\n    public int numFactoredBinaryTrees(int[] arr) {\\n          Arrays.sort(arr);\\n        Map<Integer,Long> map=new HashMap<>();//val,count\\n        long ans=0;\\n      for(int i=0;i<arr.length;i++){\\n            long count=1;\\n            for(int j=0;j<i;j++){\\n             if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j])){//found two factors as arr[j],arr[i]/arr[j]\\n                    count+=map.get(arr[j])*map.get(arr[i]/arr[j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2403118,
                "title": "java-dp-tabulation-o-n-2-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            map.put(arr[i],i);\\n        }\\n        long[] dp = new long[arr.length];\\n        Arrays.fill(dp,1L);\\n        for(int i=1;i<arr.length;i++){\\n            for(int j=0;j<i;j++){\\n                if(arr[i] % arr[j] == 0){\\n                    if(map.containsKey(arr[i]/arr[j])){\\n                        dp[i] += dp[map.get(arr[i]/arr[j])] * dp[j];\\n                    }\\n                }\\n            }\\n        }\\n        int mod = 1000000007;\\n        long sum = 0;\\n        for(long val:dp){\\n            sum+=val;\\n        }\\n        return (int)(sum%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            map.put(arr[i],i);\\n        }\\n        long[] dp = new long[arr.length];\\n        Arrays.fill(dp,1L);\\n        for(int i=1;i<arr.length;i++){\\n            for(int j=0;j<i;j++){\\n                if(arr[i] % arr[j] == 0){\\n                    if(map.containsKey(arr[i]/arr[j])){\\n                        dp[i] += dp[map.get(arr[i]/arr[j])] * dp[j];\\n                    }\\n                }\\n            }\\n        }\\n        int mod = 1000000007;\\n        long sum = 0;\\n        for(long val:dp){\\n            sum+=val;\\n        }\\n        return (int)(sum%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403016,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, array: List[int]) -> int:\\n\\n        array.sort() \\n\\n        dct = dict(zip(array,range(1,len(array) + 1)))\\n        \\n        lst = [1] * len(array)\\n        \\n        exp = 10**9 + 7\\n\\n        for i in range(len(array)):\\n            for j in range(i):\\n                if array[i] % array[j] == 0 and dct.get(array[i] // array[j],0):\\n                        lst[i] = lst[i] + lst[j] * lst[dct[array[i] // array[j]]-1]\\n        return sum(lst) % exp\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, array: List[int]) -> int:\\n\\n        array.sort() \\n\\n        dct = dict(zip(array,range(1,len(array) + 1)))\\n        \\n        lst = [1] * len(array)\\n        \\n        exp = 10**9 + 7\\n\\n        for i in range(len(array)):\\n            for j in range(i):\\n                if array[i] % array[j] == 0 and dct.get(array[i] // array[j],0):\\n                        lst[i] = lst[i] + lst[j] * lst[dct[array[i] // array[j]]-1]\\n        return sum(lst) % exp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402683,
                "title": "javascript-sort-tc-o-n-2-sc-o-n",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar numFactoredBinaryTrees = function(arr) {\\n    const mod = 10 ** 9 + 7;\\n    \\n    arr.sort((a, b) => a - b);\\n    \\n    const dp = {};\\n    \\n    for (const num of arr) {\\n        dp[num] = 1;\\n    }\\n    \\n    for (let i = 1; i < arr.length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            if (arr[i] % arr[j] === 0) {\\n                const k = arr[i] / arr[j];\\n                if (dp[k]) {\\n                    dp[arr[i]] = (dp[arr[i]] + dp[arr[j]] * dp[k]) % mod;\\n                }\\n            }\\n        }\\n    }\\n    \\n    let ans = 0;\\n    Object.values(dp).forEach(v => ans += v);\\n    return ans % mod;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar numFactoredBinaryTrees = function(arr) {\\n    const mod = 10 ** 9 + 7;\\n    \\n    arr.sort((a, b) => a - b);\\n    \\n    const dp = {};\\n    \\n    for (const num of arr) {\\n        dp[num] = 1;\\n    }\\n    \\n    for (let i = 1; i < arr.length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            if (arr[i] % arr[j] === 0) {\\n                const k = arr[i] / arr[j];\\n                if (dp[k]) {\\n                    dp[arr[i]] = (dp[arr[i]] + dp[arr[j]] * dp[k]) % mod;\\n                }\\n            }\\n        }\\n    }\\n    \\n    let ans = 0;\\n    Object.values(dp).forEach(v => ans += v);\\n    return ans % mod;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2402680,
                "title": "very-easy-java-solution-t-c-o-n-2-s-c-o-n",
                "content": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n       int mod=1000000007;\\n       int N=arr.length; \\n       long dp[]=new long[N];\\n       Arrays.fill(dp,1);\\n       HashMap<Integer,Integer> map=new HashMap<>();\\n       Arrays.sort(arr);\\n       for(int i=0;i<arr.length;i++){\\n           map.put(arr[i],i);\\n       }\\n       for(int i=0;i<N;i++){\\n           for(int j=0;j<i;j++){\\n               if(arr[i]%arr[j]==0){ \\n                   //left child ( so that right is integer)\\n                int right=arr[i]/arr[j];\\n                int idx=map.getOrDefault(right,-1);\\n                if(idx!=-1) dp[i]=(dp[i]+dp[idx]*dp[j])%mod;   \\n           }\\n       } \\n    }\\n    long ans=0;\\n    for(long x:dp) ans+=x;\\n    return (int)(ans%mod);    \\n   }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n       int mod=1000000007;\\n       int N=arr.length; \\n       long dp[]=new long[N];\\n       Arrays.fill(dp,1);\\n       HashMap<Integer,Integer> map=new HashMap<>();\\n       Arrays.sort(arr);\\n       for(int i=0;i<arr.length;i++){\\n           map.put(arr[i],i);\\n       }\\n       for(int i=0;i<N;i++){\\n           for(int j=0;j<i;j++){\\n               if(arr[i]%arr[j]==0){ \\n                   //left child ( so that right is integer)\\n                int right=arr[i]/arr[j];\\n                int idx=map.getOrDefault(right,-1);\\n                if(idx!=-1) dp[i]=(dp[i]+dp[idx]*dp[j])%mod;   \\n           }\\n       } \\n    }\\n    long ans=0;\\n    for(long x:dp) ans+=x;\\n    return (int)(ans%mod);    \\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402372,
                "title": "c-solution-using-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& v) {\\n        \\n        vector<long long int>arr(v.size());\\n        int n = arr.size();\\n        \\n        for(int i=0;i<n;i++) arr[i] = v[i];\\n        \\n        long long int ans = 0 , MOD = pow(10,9) + 7;\\n        \\n        sort(arr.begin(),arr.end());\\n        set<long long int>s;\\n        \\n        for(int i=0;i<n;i++) s.insert(arr[i]);\\n        \\n        unordered_map<long long int,long long int>dp;\\n    \\n        for(int i=0;i<n;i++)\\n        {\\n            long long int ele = arr[i];\\n            \\n            //Calculate answer for arr[i] as a root.\\n            long long int cnt = 1;\\n            \\n            for(int j=0;j<i;j++)\\n            {\\n                long long int mul = arr[j]*arr[j];\\n                if(mul > ele) break;\\n                if(j > 0 && arr[j] == arr[j-1]) continue;\\n                long long int cc = ele/arr[j];\\n                \\n                if(ele%arr[j] == 0 && s.count(cc))\\n                {\\n                    if(arr[j] != cc) cnt = (cnt + 2*dp[arr[j]]*dp[cc])%MOD;\\n            \\n                    else cnt = (cnt + dp[arr[j]]*dp[cc])%MOD;\\n                }\\n            } \\n            \\n            //store answer in dp for arr[i] as a root\\n            dp[ele] = cnt;\\n            ans = (ans + cnt)%MOD;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& v) {\\n        \\n        vector<long long int>arr(v.size());\\n        int n = arr.size();\\n        \\n        for(int i=0;i<n;i++) arr[i] = v[i];\\n        \\n        long long int ans = 0 , MOD = pow(10,9) + 7;\\n        \\n        sort(arr.begin(),arr.end());\\n        set<long long int>s;\\n        \\n        for(int i=0;i<n;i++) s.insert(arr[i]);\\n        \\n        unordered_map<long long int,long long int>dp;\\n    \\n        for(int i=0;i<n;i++)\\n        {\\n            long long int ele = arr[i];\\n            \\n            //Calculate answer for arr[i] as a root.\\n            long long int cnt = 1;\\n            \\n            for(int j=0;j<i;j++)\\n            {\\n                long long int mul = arr[j]*arr[j];\\n                if(mul > ele) break;\\n                if(j > 0 && arr[j] == arr[j-1]) continue;\\n                long long int cc = ele/arr[j];\\n                \\n                if(ele%arr[j] == 0 && s.count(cc))\\n                {\\n                    if(arr[j] != cc) cnt = (cnt + 2*dp[arr[j]]*dp[cc])%MOD;\\n            \\n                    else cnt = (cnt + dp[arr[j]]*dp[cc])%MOD;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2402315,
                "title": "dp-c-modular-arithmetic",
                "content": "```\\n\\ntypedef long T;\\n\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    T modMul(T a,T b){\\n        a %= mod;\\n        b %= mod;\\n        a *=  b;\\n        a %= mod;\\n        return a;\\n    }\\n    T modAdd(T a,T b){\\n        a %= mod;\\n        b %= mod;\\n        a += b;\\n        a %= mod;\\n        return a;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size();\\n        \\n        map<T,T> mp;\\n        for(auto &x : arr){\\n            mp[x] = 1;\\n        }\\n        int i,j;\\n        T sum = 1;\\n        for(i=1;i<n;i++){\\n            for(j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    if(mp.find(arr[i]/arr[j]) != mp.end()){\\n                        // mp[ arr[i] ] =(mp[arr[i]]+mp[arr[j]] * mp[ arr[i]/arr[j] ])%mod;\\n                        mp[ arr[i] ] = modAdd( mp[arr[i]], modMul( mp[arr[j]], mp[arr[i] / arr[j] ] ) );\\n                    \\n                    }\\n                }\\n            }\\n            // sum = (sum + mp[arr[i]])%mod;\\n            sum = modAdd( sum , mp[arr[i]] );\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\ntypedef long T;\\n\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    T modMul(T a,T b){\\n        a %= mod;\\n        b %= mod;\\n        a *=  b;\\n        a %= mod;\\n        return a;\\n    }\\n    T modAdd(T a,T b){\\n        a %= mod;\\n        b %= mod;\\n        a += b;\\n        a %= mod;\\n        return a;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size();\\n        \\n        map<T,T> mp;\\n        for(auto &x : arr){\\n            mp[x] = 1;\\n        }\\n        int i,j;\\n        T sum = 1;\\n        for(i=1;i<n;i++){\\n            for(j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    if(mp.find(arr[i]/arr[j]) != mp.end()){\\n                        // mp[ arr[i] ] =(mp[arr[i]]+mp[arr[j]] * mp[ arr[i]/arr[j] ])%mod;\\n                        mp[ arr[i] ] = modAdd( mp[arr[i]], modMul( mp[arr[j]], mp[arr[i] / arr[j] ] ) );\\n                    \\n                    }\\n                }\\n            }\\n            // sum = (sum + mp[arr[i]])%mod;\\n            sum = modAdd( sum , mp[arr[i]] );\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402265,
                "title": "need-help-to-understand-why-my-code-fails",
                "content": "Hello folks need your help to understand why below written code is failing for some of the test case. Since the test case for which it is failing is very large i am not able to dry run on it to find the issue.\\n\\nPlease let me know in comment section if you want to know the thought process for below mentioned code.\\n\\n\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n        \\n\\t\\t\\n\\t\\tclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        \\n        Arrays.sort(arr);\\n        \\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        int mod = 1_000_000_007;\\n        \\n        for(int i=0; i<arr.length; i++)\\n        {\\n            hm.put(arr[i], 0);\\n        }\\n        \\n        for(int num: arr)\\n        {         \\n            for(int j=2; j<=num/2; j++)\\n            {\\n                if((num%j) == 0)\\n                {\\n                    int a = j; \\n                    int b = num/j;\\n                    \\n                    if(a!=b && hm.containsKey(a) && hm.containsKey(b))\\n                    {\\n                        hm.put(num, (hm.get(num)+(hm.get(a)*hm.get(b))%mod));\\n                    }\\n                    else if(a==b && hm.containsKey(a))\\n                    {\\n                        hm.put(num,(hm.get(num)+hm.get(a))%mod);\\n                    }\\n                }\\n                \\n            }\\n            hm.put(num, hm.get(num)+1);\\n        }\\n        \\n        long sum = 0;\\n        for(int num:arr)\\n        {\\n            sum += hm.get(num);\\n        }\\n        \\n        return (int)(sum%mod);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        \\n        Arrays.sort(arr);\\n        \\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        int mod = 1_000_000_007;\\n        \\n        for(int i=0; i<arr.length; i++)\\n        {\\n            hm.put(arr[i], 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2402227,
                "title": "c-solution-sort-dp-map",
                "content": "Let\\'s think naive solution. We pick up any number from the `arr` and make it a root. Then we iterate over all the pair of divisors of `arr[i]` and check if both the numbers are present in the array. We can identify the redundant computation. If the two divisors of `arr[i]` are present at `j` and `k` index, then we don\\'t need to compute their answer again. Their answer can be computed and stored in a `dp` vector.\\n\\nAlso, we don\\'t need to find all the divisors of `arr[i]`. Rather than that, we can traverse over all the numbers that are smaller than `arr[i]` and check if they divide `arr[i]`. To do this efficiently, we sort the array first. Lets say for `arr[i]`, there is an index `j` such that `arr[j]` divides `arr[i]`. Let `m = arr[i] / arr[j]`. Now we need to check if `m` exist in the array. Let `arr[k] = m`. Keep a map of value to index to retrieve the index `k` efficiently. Since all the numbers are unique, there would exactly be one index for any value present in the array. Then for ther are `dp[j]*dp[k]` more ways such that `arr[i]` can be root. Do this for all `j < i`. Final answer is sum of entire `dp` vector.\\n\\nSome points to consider:\\n1. `j` can be both left and right child. Then we need to add `2*dp[j]*dp[k]` to `dp[i]`. But that will be redundant since you will come across `k` as well. So always consider `j` as one of the child.\\n2. Consider the case where `m = arr[j]`. You don\\'t need to worry about adding extra to the answer to `dp[i]` if you follow point 1.\\n\\nComplexity:\\nTime => `O(n^2)`\\nSpace => `O(n)`\\n\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n = arr.size();\\n        long long int modn = 1000000007;\\n        vector<long long int> dp(n, 1);\\n        sort(arr.begin(), arr.end());\\n        unordered_map<int, int> index;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                if(arr[i] % arr[j]){\\n                    continue;\\n                }\\n                int m = arr[i] / arr[j];\\n                if(index.find(m) != index.end()){\\n                    dp[i] += 1L*dp[j]*dp[index[m]];\\n                    dp[i] %= modn;\\n                }\\n            }\\n            index[arr[i]] = i;\\n        }\\n        return accumulate(dp.begin(), dp.end(), 0L)%modn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n = arr.size();\\n        long long int modn = 1000000007;\\n        vector<long long int> dp(n, 1);\\n        sort(arr.begin(), arr.end());\\n        unordered_map<int, int> index;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                if(arr[i] % arr[j]){\\n                    continue;\\n                }\\n                int m = arr[i] / arr[j];\\n                if(index.find(m) != index.end()){\\n                    dp[i] += 1L*dp[j]*dp[index[m]];\\n                    dp[i] %= modn;\\n                }\\n            }\\n            index[arr[i]] = i;\\n        }\\n        return accumulate(dp.begin(), dp.end(), 0L)%modn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402188,
                "title": "java-dp-solution-explained",
                "content": "```\\nclass Solution {\\n    /*\\n    -> Start from node and check if how may trees are possible, by following the given conditions\\n    -> dp works as visited array, if we already counter trees from a perticular root do not calculate it again\\n    */\\n    private int MOD = (int)(1e9+7);\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        long res = 0;\\n        Set<Integer> nodes = new HashSet(); \\n        Map<Integer, Long> dp = new HashMap<>();\\n        for(int n: arr) nodes.add(n);\\n        for(int n: arr) solve(n, nodes, dp);\\n        // Finally add all the trees possible from each value as node\\n        for(Map.Entry<Integer, Long> e: dp.entrySet()){\\n            res = (res + e.getValue()%MOD) % MOD;\\n        }\\n        return (int)(res%MOD);\\n    }\\n    private long solve(int root, Set<Integer> nodes, Map<Integer, Long> dp){\\n        if(dp.containsKey(root)) return dp.get(root);\\n        long res = 1;\\n        Set<Integer> usedNodes = new HashSet<>();\\n        for(int n: nodes){\\n            if(n * (root/n) != root) continue;\\n            if(!usedNodes.contains(n) && nodes.contains(n) && nodes.contains(root/n)){\\n                long cur = solve(n, nodes, dp) * solve(root/n, nodes, dp);\\n                // if left and right child of tree are not same, the two trees are possible\\n                if(n != root/n) res+=cur*2;\\n                else res+=cur;\\n                usedNodes.add(n);\\n                usedNodes.add(root/n);\\n                res %= MOD;\\n            }\\n        }\\n        dp.put(root, res);\\n        return res;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    -> Start from node and check if how may trees are possible, by following the given conditions\\n    -> dp works as visited array, if we already counter trees from a perticular root do not calculate it again\\n    */\\n    private int MOD = (int)(1e9+7);\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        long res = 0;\\n        Set<Integer> nodes = new HashSet(); \\n        Map<Integer, Long> dp = new HashMap<>();\\n        for(int n: arr) nodes.add(n);\\n        for(int n: arr) solve(n, nodes, dp);\\n        // Finally add all the trees possible from each value as node\\n        for(Map.Entry<Integer, Long> e: dp.entrySet()){\\n            res = (res + e.getValue()%MOD) % MOD;\\n        }\\n        return (int)(res%MOD);\\n    }\\n    private long solve(int root, Set<Integer> nodes, Map<Integer, Long> dp){\\n        if(dp.containsKey(root)) return dp.get(root);\\n        long res = 1;\\n        Set<Integer> usedNodes = new HashSet<>();\\n        for(int n: nodes){\\n            if(n * (root/n) != root) continue;\\n            if(!usedNodes.contains(n) && nodes.contains(n) && nodes.contains(root/n)){\\n                long cur = solve(n, nodes, dp) * solve(root/n, nodes, dp);\\n                // if left and right child of tree are not same, the two trees are possible\\n                if(n != root/n) res+=cur*2;\\n                else res+=cur;\\n                usedNodes.add(n);\\n                usedNodes.add(root/n);\\n                res %= MOD;\\n            }\\n        }\\n        dp.put(root, res);\\n        return res;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402173,
                "title": "easy-intuition-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,long long int>m;\\n    unordered_set<int>s;\\n    \\n    long long int countTrees(int a,vector<int>&arr){\\n        \\n        if(m[a])return m[a];\\n        \\n        long long int ct=1;\\n        for(auto ele:arr){\\n            if(!(a%ele) && s.find(a/ele)!=s.end()){\\n                ct+=countTrees(ele,arr)*countTrees(a/ele,arr);\\n            }\\n        }\\n        \\n        return m[a]=ct;\\n    }\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        for(auto ele:arr){\\n            s.insert(ele);\\n        }\\n        \\n        long long int ans=0,n=1e9+7;\\n        \\n        for(auto ele:arr){\\n            ans+=countTrees(ele,arr);\\n            ans%=n;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    unordered_map<int,long long int>m;\\n    unordered_set<int>s;\\n    \\n    long long int countTrees(int a,vector<int>&arr){\\n        \\n        if(m[a])return m[a];\\n        \\n        long long int ct=1;\\n        for(auto ele:arr){\\n            if(!(a%ele) && s.find(a/ele)!=s.end()){\\n                ct+=countTrees(ele,arr)*countTrees(a/ele,arr);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2402127,
                "title": "simple-straight-cut-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        unordered_map<int,long long int> mpp;\\n        sort(arr.begin(),arr.end());\\n        for(auto it: arr){\\n            mpp.insert({it,1}); // initilizing all the values in the map as 1\\n        }\\n        for(int i=1;i<arr.size();i++){\\n            long long int count=0;\\n            for(int j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    if(mpp.find(arr[i]/arr[j])!=mpp.end()){\\n                        count+=mpp[arr[j]]*mpp[arr[i]/arr[j]]; //incrementing count\\n                    }\\n                }\\n            }\\n            mpp[arr[i]]+=count; //updating the new value in the map\\n        }\\n        long long int res=0;\\n        for(auto it: mpp){\\n            res=res+it.second;\\n        }\\n        return res%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        unordered_map<int,long long int> mpp;\\n        sort(arr.begin(),arr.end());\\n        for(auto it: arr){\\n            mpp.insert({it,1}); // initilizing all the values in the map as 1\\n        }\\n        for(int i=1;i<arr.size();i++){\\n            long long int count=0;\\n            for(int j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    if(mpp.find(arr[i]/arr[j])!=mpp.end()){\\n                        count+=mpp[arr[j]]*mpp[arr[i]/arr[j]]; //incrementing count\\n                    }\\n                }\\n            }\\n            mpp[arr[i]]+=count; //updating the new value in the map\\n        }\\n        long long int res=0;\\n        for(auto it: mpp){\\n            res=res+it.second;\\n        }\\n        return res%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402024,
                "title": "top-down-dp-c",
                "content": "```\\nint MOD =  1e9 + 7;\\n\\n\\nclass Solution\\n{\\npublic:\\n\\n\\tlong long modMul(long long a, long long b){\\n\\t\\treturn ((a%MOD) * (b%MOD))%MOD;\\n\\t}\\n\\n\\tunordered_map<int, vector<int>> mp;\\n\\tlong long dp[20][1005];\\n\\tlong long numFactoredBinaryTrees(vector<int> &arr)\\n\\t{\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\tfor(int i = 0; i<arr.size();i++){\\n\\t\\t\\tif(mp.count(arr[i]) > 0){\\n\\t\\t\\t\\tmp[arr[i]].push_back(i);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tmp[arr[i]] = {i};\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlong long tmp = 0;\\n\\t\\tfor (int j = 0; j < arr.size(); j++)\\n\\t\\t{\\n\\t\\t\\ttmp += makeTrees(arr, 0, j);\\n\\t\\t\\ttmp%=MOD;\\n\\t\\t}\\n\\n\\t\\treturn tmp;\\n\\t}\\n\\n\\tlong long makeTrees(vector<int> arr, int level, int parent)\\n\\t{\\n\\n\\t\\tif(dp[level][parent]!=-1)\\n\\t\\t\\treturn dp[level][parent];\\n\\t\\tlong long cnt = 1;\\n\\n\\n\\t\\tfor(int i = 0;i<arr.size();i++){\\n\\t\\t\\t\\n\\t\\t\\tif(arr[parent]%arr[i] !=0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\n\\t\\t\\tint target = arr[parent]/arr[i];\\n\\t\\t\\tif(mp.count(target) == 0)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tvector<int>tt = mp[target];\\n\\n\\t\\t\\tfor(int j=0;j<tt.size();j++){\\n\\t\\t\\t\\tcnt+= (modMul((makeTrees(arr, level+1, i)),(makeTrees(arr, level+1, tt[j]))));\\n\\t\\t\\t\\tcnt%=MOD;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[level][parent] = cnt;\\n\\t\\treturn cnt;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint MOD =  1e9 + 7;\\n\\n\\nclass Solution\\n{\\npublic:\\n\\n\\tlong long modMul(long long a, long long b){\\n\\t\\treturn ((a%MOD) * (b%MOD))%MOD;\\n\\t}\\n\\n\\tunordered_map<int, vector<int>> mp;\\n\\tlong long dp[20][1005];\\n\\tlong long numFactoredBinaryTrees(vector<int> &arr)\\n\\t{\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\tfor(int i = 0; i<arr.size();i++){\\n\\t\\t\\tif(mp.count(arr[i]) > 0){\\n\\t\\t\\t\\tmp[arr[i]].push_back(i);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tmp[arr[i]] = {i};\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlong long tmp = 0;\\n\\t\\tfor (int j = 0; j < arr.size(); j++)\\n\\t\\t{\\n\\t\\t\\ttmp += makeTrees(arr, 0, j);\\n\\t\\t\\ttmp%=MOD;\\n\\t\\t}\\n\\n\\t\\treturn tmp;\\n\\t}\\n\\n\\tlong long makeTrees(vector<int> arr, int level, int parent)\\n\\t{\\n\\n\\t\\tif(dp[level][parent]!=-1)\\n\\t\\t\\treturn dp[level][parent];\\n\\t\\tlong long cnt = 1;\\n\\n\\n\\t\\tfor(int i = 0;i<arr.size();i++){\\n\\t\\t\\t\\n\\t\\t\\tif(arr[parent]%arr[i] !=0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\n\\t\\t\\tint target = arr[parent]/arr[i];\\n\\t\\t\\tif(mp.count(target) == 0)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\tvector<int>tt = mp[target];\\n\\n\\t\\t\\tfor(int j=0;j<tt.size();j++){\\n\\t\\t\\t\\tcnt+= (modMul((makeTrees(arr, level+1, i)),(makeTrees(arr, level+1, tt[j]))));\\n\\t\\t\\t\\tcnt%=MOD;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[level][parent] = cnt;\\n\\t\\treturn cnt;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401791,
                "title": "c-accepted-best-approach-with-steps-explanation-easy-to-understand",
                "content": "**Read the below steps to understand the logic**\\n\\n***Upvote if you like it!!***\\n\\n**Steps**\\n1. Sort the given arr. ```sort(arr.begin(),arr.end());```\\n2. Declare map and set all element value by 1 ex: ```mp[auto num: arr]=1;```\\n3. Declare loop which will start from first index untill last index. ```for(int i=1;i<n;i++)```\\n\\t\\t* Declare nested loop inside previous loop which will start from 0\\'th untill i\\'th index for each i\\'th element.```for(int j=1;j<i;j++)``` and declare count as 0.\\n\\t\\t* Check whether arr[j] is factor of arr[i] of not, if yes then check divident value is present inside map or not, if yes than increment count by  multiply of arr[j] and divident second map value.\\n\\t\\t* after that increment map\\'s second value of arr[i] by count.\\n4.  return sum of second map\\'s values of each element of given array after taking modules. \\n\\n```\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        map<int,long long> mp;\\n        for(auto num: arr)\\n            mp[num]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            long long count=0;\\n            auto it=mp.find(arr[i]);\\n            for(int j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    auto it1 = mp.find(arr[i]/arr[j]);\\n                    auto it2=mp.find(arr[j]);\\n                    if(it1!=mp.end()){\\n                        count+=(it1->second)*(it2->second);\\n                    }\\n                }\\n            }\\n            it->second+=count;\\n        }\\n        long long  sum=0;\\n        for(auto it4=mp.begin();it4!=mp.end(); it4++){\\n            sum+= it4->second;\\n        }\\n        return sum%(1000000007);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```sort(arr.begin(),arr.end());```\n```mp[auto num: arr]=1;```\n```for(int i=1;i<n;i++)```\n```for(int j=1;j<i;j++)```\n```\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        map<int,long long> mp;\\n        for(auto num: arr)\\n            mp[num]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            long long count=0;\\n            auto it=mp.find(arr[i]);\\n            for(int j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    auto it1 = mp.find(arr[i]/arr[j]);\\n                    auto it2=mp.find(arr[j]);\\n                    if(it1!=mp.end()){\\n                        count+=(it1->second)*(it2->second);\\n                    }\\n                }\\n            }\\n            it->second+=count;\\n        }\\n        long long  sum=0;\\n        for(auto it4=mp.begin();it4!=mp.end(); it4++){\\n            sum+= it4->second;\\n        }\\n        return sum%(1000000007);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2401736,
                "title": "python-two-dynamic-programming-solutions",
                "content": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        N = len(arr)\\n        arr.sort()\\n        arr_set = defaultdict(int)\\n        for i in range(N):\\n            arr_set[arr[i]] = i\\n        \\n        dp = [1] * N\\n        for i in range(1, N):\\n            for j in range(i):\\n                left = arr[j]\\n                right = arr[i] / left\\n                if right in arr_set:\\n                    l_comb = dp[j]-1\\n                    r_comb = dp[arr_set[right]]-1\\n                    dp[i] += 1 + l_comb + r_comb + (l_comb * r_comb)\\n        \\n        return sum(dp) % 1000000007\\n```\\n\\nor using memo\\n\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:        \\n        arr.sort()\\n        arr_set = set(arr)\\n        \\n        @cache\\n        def dp(val):\\n            r = 1\\n            for i in range(len(arr)):\\n                left = arr[i]\\n                if left >= val:\\n                    break\\n                right = val / left\\n                if right in arr_set:\\n                    l_comb = dp(left)\\n                    r_comb = dp(right)\\n                    \\n                    r += 1\\n                    r += l_comb-1\\n                    r += r_comb-1\\n                    r += (l_comb-1) * (r_comb-1)\\n            return r\\n        \\n        answer = 0\\n        for n in arr:\\n            answer += dp(n)\\n        \\n        return answer % 1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        N = len(arr)\\n        arr.sort()\\n        arr_set = defaultdict(int)\\n        for i in range(N):\\n            arr_set[arr[i]] = i\\n        \\n        dp = [1] * N\\n        for i in range(1, N):\\n            for j in range(i):\\n                left = arr[j]\\n                right = arr[i] / left\\n                if right in arr_set:\\n                    l_comb = dp[j]-1\\n                    r_comb = dp[arr_set[right]]-1\\n                    dp[i] += 1 + l_comb + r_comb + (l_comb * r_comb)\\n        \\n        return sum(dp) % 1000000007\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:        \\n        arr.sort()\\n        arr_set = set(arr)\\n        \\n        @cache\\n        def dp(val):\\n            r = 1\\n            for i in range(len(arr)):\\n                left = arr[i]\\n                if left >= val:\\n                    break\\n                right = val / left\\n                if right in arr_set:\\n                    l_comb = dp(left)\\n                    r_comb = dp(right)\\n                    \\n                    r += 1\\n                    r += l_comb-1\\n                    r += r_comb-1\\n                    r += (l_comb-1) * (r_comb-1)\\n            return r\\n        \\n        answer = 0\\n        for n in arr:\\n            answer += dp(n)\\n        \\n        return answer % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401642,
                "title": "c-recursive-memomization-method",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    long long int recur(int n,vector<int> nums,map<int,long long int>& dp){\\n        if(dp.find(n)!=dp.end()) return dp[n];\\n        long long int a=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(n%nums[i]==0){\\n            vector<int>::iterator it;\\n            it=find(nums.begin(),nums.end(),n/nums[i]);\\n                if(it!=nums.end())\\n             a=a%mod+(recur(n/nums[i],nums,dp)%mod)*(recur(nums[i],nums,dp)%mod);   \\n            }\\n        }\\n        return dp[n]=a%mod;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n      sort(arr.begin(),arr.end());\\n        map<int,long long int> dp;\\n        int x=0;\\n        for(int i=0;i<arr.size();i++){\\n            x=x%mod+recur(arr[i],arr,dp)%mod;\\n        }\\n        return x%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    long long int recur(int n,vector<int> nums,map<int,long long int>& dp){\\n        if(dp.find(n)!=dp.end()) return dp[n];\\n        long long int a=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(n%nums[i]==0){\\n            vector<int>::iterator it;\\n            it=find(nums.begin(),nums.end(),n/nums[i]);\\n                if(it!=nums.end())\\n             a=a%mod+(recur(n/nums[i],nums,dp)%mod)*(recur(nums[i],nums,dp)%mod);   \\n            }\\n        }\\n        return dp[n]=a%mod;\\n    }\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n      sort(arr.begin(),arr.end());\\n        map<int,long long int> dp;\\n        int x=0;\\n        for(int i=0;i<arr.size();i++){\\n            x=x%mod+recur(arr[i],arr,dp)%mod;\\n        }\\n        return x%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401571,
                "title": "c-map-sort-easy-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int numFactoredBinaryTrees(vector<int> &arr)\\n    {\\n        map<int, long long int> m;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            m.insert({arr[i], 1});\\n        }\\n        for (int i = 1; i < arr.size(); i++)\\n        {\\n            auto it2 = m.find(arr[i]);\\n            long long int count = 0;\\n            for (int j = 0; j < i; j++)\\n            {\\n                if (arr[i] % arr[j] == 0)\\n                {\\n                    auto it = m.find(arr[i] / arr[j]);\\n                    auto it1 = m.find(arr[j]);\\n                    if (it != m.end())\\n                        count += (it->second) * (it1->second);\\n                }\\n            }\\n            it2->second += count;\\n        }\\n        long long int ans = 0;\\n        for (auto x = m.begin(); x != m.end(); x++)\\n            ans += x->second;\\n        return ans % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int numFactoredBinaryTrees(vector<int> &arr)\\n    {\\n        map<int, long long int> m;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            m.insert({arr[i], 1});\\n        }\\n        for (int i = 1; i < arr.size(); i++)\\n        {\\n            auto it2 = m.find(arr[i]);\\n            long long int count = 0;\\n            for (int j = 0; j < i; j++)\\n            {\\n                if (arr[i] % arr[j] == 0)\\n                {\\n                    auto it = m.find(arr[i] / arr[j]);\\n                    auto it1 = m.find(arr[j]);\\n                    if (it != m.end())\\n                        count += (it->second) * (it1->second);\\n                }\\n            }\\n            it2->second += count;\\n        }\\n        long long int ans = 0;\\n        for (auto x = m.begin(); x != m.end(); x++)\\n            ans += x->second;\\n        return ans % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401525,
                "title": "binary-trees-with-factors-commented-code-easy-to-understand",
                "content": "```\\nclass Solution {\\n    private static int MODULO = 1000000007;\\n    \\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        \\n        long[] dp = new long[n];\\n        \\n        // Map is used to check if any element is present which can be multiplied with the child to give the value at the parent node\\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        \\n        // It is possible to create 1 binary tree with each elements\\n        Arrays.fill(dp,1);\\n        \\n        // Add the elements along with their index in the map\\n        for(int index = 0 ; index < n ; index++) {\\n            int element = arr[index];\\n            map.put(element, index);\\n        }\\n        \\n        // It is not possible to create another binary tree \\n        // So start from i = 0;\\n        for(int i = 1 ; i < n ; i++) {\\n            // Check with the elements less than the current element \\n            for(int j = 0 ; j < i ; j++) {\\n                // arr[j] is the left child\\n                if(arr[i] % arr[j] == 0) {\\n                    // Element to be multiplied with the child to give the value at the parent node\\n                    int rightChild = arr[i] / arr[j]; \\n                    \\n                    // If map contains the element\\n                    if(map.containsKey(rightChild)) {\\n                        // No: of ways the product can be formed with the particular left and right child\\n                        int indexrightChild = map.get(rightChild);\\n                        long ways = (dp[j] * dp[indexrightChild]) % MODULO;\\n                        dp[i] = (dp[i] +  ways) % MODULO;\\n                    }\\n                }    \\n            }\\n        }\\n        \\n        long count = 0;\\n        for(long c : dp) {\\n            count += c;\\n        }\\n        \\n        int result = (int)(count % MODULO);\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private static int MODULO = 1000000007;\\n    \\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        \\n        long[] dp = new long[n];\\n        \\n        // Map is used to check if any element is present which can be multiplied with the child to give the value at the parent node\\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        \\n        // It is possible to create 1 binary tree with each elements\\n        Arrays.fill(dp,1);\\n        \\n        // Add the elements along with their index in the map\\n        for(int index = 0 ; index < n ; index++) {\\n            int element = arr[index];\\n            map.put(element, index);\\n        }\\n        \\n        // It is not possible to create another binary tree \\n        // So start from i = 0;\\n        for(int i = 1 ; i < n ; i++) {\\n            // Check with the elements less than the current element \\n            for(int j = 0 ; j < i ; j++) {\\n                // arr[j] is the left child\\n                if(arr[i] % arr[j] == 0) {\\n                    // Element to be multiplied with the child to give the value at the parent node\\n                    int rightChild = arr[i] / arr[j]; \\n                    \\n                    // If map contains the element\\n                    if(map.containsKey(rightChild)) {\\n                        // No: of ways the product can be formed with the particular left and right child\\n                        int indexrightChild = map.get(rightChild);\\n                        long ways = (dp[j] * dp[indexrightChild]) % MODULO;\\n                        dp[i] = (dp[i] +  ways) % MODULO;\\n                    }\\n                }    \\n            }\\n        }\\n        \\n        long count = 0;\\n        for(long c : dp) {\\n            count += c;\\n        }\\n        \\n        int result = (int)(count % MODULO);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401480,
                "title": "simple-using-map-and-sorting-very-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    #define MOD 1000000007\\n    #define ll long long\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr)\\n    {\\n        ll ans = 0;\\n        \\n        unordered_map<ll,ll> mp;\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            // leaf node\\n            ll curr_ans  = 1;\\n            \\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j])\\n                    continue;\\n                \\n                ll num1 = arr[j];\\n                ll num2 = arr[i]/arr[j];\\n                \\n                curr_ans = (curr_ans+(mp[num1]*mp[num2])%MOD)%MOD;\\n            }\\n            \\n            mp[arr[i]] = curr_ans;\\n            \\n            ans = (ans+curr_ans)%MOD;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define MOD 1000000007\\n    #define ll long long\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr)\\n    {\\n        ll ans = 0;\\n        \\n        unordered_map<ll,ll> mp;\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            // leaf node\\n            ll curr_ans  = 1;\\n            \\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j])\\n                    continue;\\n                \\n                ll num1 = arr[j];\\n                ll num2 = arr[i]/arr[j];\\n                \\n                curr_ans = (curr_ans+(mp[num1]*mp[num2])%MOD)%MOD;\\n            }\\n            \\n            mp[arr[i]] = curr_ans;\\n            \\n            ans = (ans+curr_ans)%MOD;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401454,
                "title": "easy-dp-tabulation",
                "content": "Time Complexity: O(N2)\\nSpace Complexity: O(N)\\n```\\nclass Solution { // 29 ms -- 98.5% Faster\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        int n=arr.length,dp[] = new int[n],i,j,res=0; long val;\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        for(i=0;i<n;i++){\\n            for(j=0,val=1;j<i;j++)\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    val=(val+(long)map.get(arr[j])*(long)map.get(arr[i]/arr[j]))%1000000007;\\n            res=(res+(dp[i]=(int)val))%1000000007;\\n            map.put(arr[i],dp[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution { // 29 ms -- 98.5% Faster\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        Arrays.sort(arr);\\n        int n=arr.length,dp[] = new int[n],i,j,res=0; long val;\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        for(i=0;i<n;i++){\\n            for(j=0,val=1;j<i;j++)\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    val=(val+(long)map.get(arr[j])*(long)map.get(arr[i]/arr[j]))%1000000007;\\n            res=(res+(dp[i]=(int)val))%1000000007;\\n            map.put(arr[i],dp[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401353,
                "title": "hashmap-c-dp-easy-solution",
                "content": "**Please upvote if u like the solution**\\n\\n\\n\\n\\nint numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n      sort(arr.begin(), arr.end());\\n        int mod=1e9+7;\\n        unordered_map<int , long>dp;\\n        \\n    long res=0;\\n        \\n        for(int i=0; i<arr.size(); i++){\\n            dp[arr[i]]=1;\\n            for(int j=0; j<i; j++){\\n                if(arr[i]%arr[j]==0){\\n               dp[arr[i]]=dp[arr[i]]+dp[arr[j]]*dp[arr[i]/arr[j]];      \\n                }\\n             \\n            }\\n           res=(res+dp[arr[i]])%mod;  \\n        }\\n        \\n        return res;\\n    }\\n\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "**Please upvote if u like the solution**\\n\\n\\n\\n\\nint numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n      sort(arr.begin(), arr.end());\\n        int mod=1e9+7;\\n        unordered_map<int , long>dp;\\n        \\n    long res=0;\\n        \\n        for(int i=0; i<arr.size(); i++){\\n            dp[arr[i]]=1;\\n            for(int j=0; j<i; j++){\\n                if(arr[i]%arr[j]==0){\\n               dp[arr[i]]=dp[arr[i]]+dp[arr[j]]*dp[arr[i]/arr[j]];      \\n                }\\n             \\n            }\\n           res=(res+dp[arr[i]])%mod;  \\n        }\\n        \\n        return res;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2401265,
                "title": "python-faster-than-91-memoization-easy-approach",
                "content": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        s=set(arr)\\n        mp={}\\n        ans=0\\n        # To minimize the traversal time\\n        arr.sort()\\n        def f(el):\\n            a=1\\n            if el in mp:\\n                return mp[el]\\n            for x in arr:\\n                if x>math.sqrt(el):\\n                    break\\n                if el/x in s :\\n                    if el/x==x:\\n                        a+=f(int(el/x))*f(x)\\n                    else:\\n                        a+=f(int(el/x))*f(x)*2\\n            mp[el]=a\\n            return a\\n        for i in range(len(arr)):\\n            ans+=f(arr[i])\\n        return (ans)%(pow(10,9)+7)                 \\n```\\n# \\uD83E\\uDD7A\\uD83E\\uDD7A Please Upvote \\uD83D\\uDC4D if it helped you \\u2764\\uFE0F .",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        s=set(arr)\\n        mp={}\\n        ans=0\\n        # To minimize the traversal time\\n        arr.sort()\\n        def f(el):\\n            a=1\\n            if el in mp:\\n                return mp[el]\\n            for x in arr:\\n                if x>math.sqrt(el):\\n                    break\\n                if el/x in s :\\n                    if el/x==x:\\n                        a+=f(int(el/x))*f(x)\\n                    else:\\n                        a+=f(int(el/x))*f(x)*2\\n            mp[el]=a\\n            return a\\n        for i in range(len(arr)):\\n            ans+=f(arr[i])\\n        return (ans)%(pow(10,9)+7)                 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401233,
                "title": "c-dp-approach-explained-with-comments-o-n2-time-o-n-space-solution",
                "content": "The first obvious hint at looking at his problem is that there is no TreeNode definition , so we don\\'t have to actually build a Tree.  Here are the observations that we should get on reading the problem\\n\\n\\t1.A tree **CAN NOT** have 1 child.\\n\\t2.No of trees possible for a Node with no children = 1\\n\\t3.No of trees possible for a Node(a) with valid children(b,c) such that(a=b*c) = no of trees(b)*no(of trees c ). \\n\\n3 gives the first condition for DP.i.e we can break into subproblems. Now we need to see if calculating in naive way , we repeat subproblems.Lets take eg of 40-\\n\\n\\t1. The factors are {2,20},{20,2},{4,10},{10,4},{5,8},{8,5}.\\n\\t2. Now for trees{20,2} = trees(20)*trees(2);\\n\\t3. notice that trees(20) is gonna calculate the subproblem trees(10) and so is the pair {4,10}. Thus we have the second condition for DP, repetition of sub problems.\\n\\nNow we need to populate 2 things for our algorithm.\\n\\t1. A hashmap for each element in the arr with a list of all pairs of factor.\\n\\t2. A dp array that stores the number of trees possible for an arr element.\\n\\nAlgorithm\\n1.  Create the Hashmap with the number as key and list of the pair of factos as the value. {a,b} and {b,a} are allowed as long as a!=b.\\n2.  For every element in arr- iterate over the possible pair of divisors(left and right child in the tree)\\n3.  if no such pair of divisors- trees[arr[i]] =1;\\n4.  otherwise for every pair - **trees[root] = trees[root]%MOD + trees[pair.first]%MOD * trees[pair.second]%MOD**. we know for sure that pair.first and pair.second have already been populated since we\\'re moving in ascending order.\\n5.  return ans%MOD.\\n\\nTime complexity = (O(nlogn +n^2 + n^2)) = O(n2)\\nSpace complexity = O(n + n) = O(n)\\n\\n![image](https://assets.leetcode.com/users/images/df9338c4-41cb-4cf4-bf16-b938392ac2df_1660031312.1613998.png)\\n\\n\\nThe code is as follows-\\n\\n```\\nclass Solution {\\npublic:\\n    // Global variables to help with MOD\\n    int MOD= pow(10,9)+7;\\n    \\n    //factor hashmap is gonna contain the pair of factors for that key\\n    unordered_map<int,vector<pair<int,int>>> factor;\\n    // DP hashmap, will contain the no of trees possible for the key\\n    unordered_map<int,long long> trees;\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        // create a set of original array for O(1) checking of the second factor\\n        unordered_set<int> s(arr.begin(),arr.end());\\n        // sorting in O(nlogn), can be done without this, but since overall complexity is O(n*n) due to divisor loop, this will not affect it.\\n        sort(arr.begin(),arr.end());\\n        \\n        // create the Divisor hashmap,\\n        for (int i=n-1;i>=0;i--){\\n            // set the possible trees to 1 for every tree, this represents the tree without any child\\n            trees[arr[i]]=1;\\n            // considering arr[i] to be the root\\n            int root = arr[i];\\n            for(int j=i-1;j>=0;j--){\\n                // A break statement can be added here to break if arr[j]<sqrt(n),in my case i dont do it, since it leads to factors like (case i) (a,b ) and (b,a ) to be populated if a!=b otherwise (case ii) (a,a) is only populated once, this is in line as case i are two different possibilities of subtree, while case ii is only 1 subtree\\n                if(root%arr[j]==0){\\n                    if(s.find(root/arr[j])!=s.end()){\\n                        if(factor.find(root)!=factor.end()){\\n                            factor[root].push_back(make_pair(arr[j],root/arr[j]));\\n                        }\\n                        else{\\n                            factor[root]={make_pair(arr[j],root/arr[j])};\\n                        }\\n                    }\\n                }\\n            }\\n            // at the end of this j loop, arr[i] has its factor in the hash table\\n        }\\n        \\n        \\n        // now the preparation is done for the meat of the solution\\n        int ans =0;\\n        for (int i=0;i<n;i++){\\n            // consider arr[i] to be root\\n            int root= arr[i];\\n            // if root does not have any factors, this code just adds 1 to the answer\\n            if(factor.find(root)==factor.end()){\\n                ans+=trees[root];\\n                continue;\\n            }\\n            // else if  we have factors, get the factors from the hasmap.\\n            vector<pair<int,int>> divisors = factor[root];\\n            // for every pair of divisor(notice here we are going in increasing order, This is necessary for DP to work as the number of trees for factors will already be populated for the larger number)\\n            for( int j=0;j<divisors.size();j++){\\n                pair<int,int> p = divisors[j];\\n\\n                // add (no of possible trees for left subtree(divisor1) multiplied by no of possible trees for right subtree(divisor2) ) + MOD is distributive over multipplciation\\n                trees[root]= trees[root]%MOD + (trees[p.first]%MOD)*(trees[p.second]%MOD);\\n            }\\n\\n            // at end of j loop we have the no of trees possible for arr[i] so add to answer\\n            ans=ans%MOD + trees[root]%MOD;\\n            \\n        }\\n        // return the answer\\n        return ans%MOD;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Global variables to help with MOD\\n    int MOD= pow(10,9)+7;\\n    \\n    //factor hashmap is gonna contain the pair of factors for that key\\n    unordered_map<int,vector<pair<int,int>>> factor;\\n    // DP hashmap, will contain the no of trees possible for the key\\n    unordered_map<int,long long> trees;\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        // create a set of original array for O(1) checking of the second factor\\n        unordered_set<int> s(arr.begin(),arr.end());\\n        // sorting in O(nlogn), can be done without this, but since overall complexity is O(n*n) due to divisor loop, this will not affect it.\\n        sort(arr.begin(),arr.end());\\n        \\n        // create the Divisor hashmap,\\n        for (int i=n-1;i>=0;i--){\\n            // set the possible trees to 1 for every tree, this represents the tree without any child\\n            trees[arr[i]]=1;\\n            // considering arr[i] to be the root\\n            int root = arr[i];\\n            for(int j=i-1;j>=0;j--){\\n                // A break statement can be added here to break if arr[j]<sqrt(n),in my case i dont do it, since it leads to factors like (case i) (a,b ) and (b,a ) to be populated if a!=b otherwise (case ii) (a,a) is only populated once, this is in line as case i are two different possibilities of subtree, while case ii is only 1 subtree\\n                if(root%arr[j]==0){\\n                    if(s.find(root/arr[j])!=s.end()){\\n                        if(factor.find(root)!=factor.end()){\\n                            factor[root].push_back(make_pair(arr[j],root/arr[j]));\\n                        }\\n                        else{\\n                            factor[root]={make_pair(arr[j],root/arr[j])};\\n                        }\\n                    }\\n                }\\n            }\\n            // at the end of this j loop, arr[i] has its factor in the hash table\\n        }\\n        \\n        \\n        // now the preparation is done for the meat of the solution\\n        int ans =0;\\n        for (int i=0;i<n;i++){\\n            // consider arr[i] to be root\\n            int root= arr[i];\\n            // if root does not have any factors, this code just adds 1 to the answer\\n            if(factor.find(root)==factor.end()){\\n                ans+=trees[root];\\n                continue;\\n            }\\n            // else if  we have factors, get the factors from the hasmap.\\n            vector<pair<int,int>> divisors = factor[root];\\n            // for every pair of divisor(notice here we are going in increasing order, This is necessary for DP to work as the number of trees for factors will already be populated for the larger number)\\n            for( int j=0;j<divisors.size();j++){\\n                pair<int,int> p = divisors[j];\\n\\n                // add (no of possible trees for left subtree(divisor1) multiplied by no of possible trees for right subtree(divisor2) ) + MOD is distributive over multipplciation\\n                trees[root]= trees[root]%MOD + (trees[p.first]%MOD)*(trees[p.second]%MOD);\\n            }\\n\\n            // at end of j loop we have the no of trees possible for arr[i] so add to answer\\n            ans=ans%MOD + trees[root]%MOD;\\n            \\n        }\\n        // return the answer\\n        return ans%MOD;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401220,
                "title": "cpp-dynamic-programming",
                "content": "```\\nint binaryTreeWithFactor(vector<int> arr) {\\n\\tmap<int, long long int> mp; // value of array --> count of binary tree with root as the value;\\n\\t//NOTE: this map will works as a storage for DP.\\n\\n\\tfor (int ele : arr) {\\n\\t\\tmp[ele] = 1;\\n\\t\\t//coz, har value ko as a root mante hue hm ek binary tree bna skte h.\\n\\t\\t//NOTE: all the values are unique in array, given in question.\\n\\t}\\n\\tsort(arr.begin(), arr.end());\\n\\tfor (int i = 1; i < arr.size(); i++) {\\n\\t\\tlong long int count = 0; //no of ways\\n\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\tif (arr[i] % arr[j] == 0) { //arr[j] is a factor of arr[i]\\n\\t\\t\\t\\t//NOTE: arr[i]/arr[j] --> gives the another factor ie, if arr[j] * arr[i]/arr[j] = arr[i] (think, simple maths)\\n\\t\\t\\t\\tauto it = mp.find(arr[i] / arr[j]);\\n\\t\\t\\t\\tif (it != mp.end()) { //found, we found the other number using which we can get the product as arr[i]\\n\\t\\t\\t\\t\\tcount += (mp[arr[j]] * it->second); //crucial part, WV\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//update the DP(map) with the new value\\n\\t\\tmp[arr[i]] += count;\\n\\t}\\n\\n\\t//add all the values(ways of forming binary trees)\\n\\tlong long int ans = 0;\\n\\tfor (auto it : mp) {\\n\\t\\tans += it.second;\\n\\t}\\n\\treturn (ans % 1000000007);\\n}\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nint binaryTreeWithFactor(vector<int> arr) {\\n\\tmap<int, long long int> mp; // value of array --> count of binary tree with root as the value;\\n\\t//NOTE: this map will works as a storage for DP.\\n\\n\\tfor (int ele : arr) {\\n\\t\\tmp[ele] = 1;\\n\\t\\t//coz, har value ko as a root mante hue hm ek binary tree bna skte h.\\n\\t\\t//NOTE: all the values are unique in array, given in question.\\n\\t}\\n\\tsort(arr.begin(), arr.end());\\n\\tfor (int i = 1; i < arr.size(); i++) {\\n\\t\\tlong long int count = 0; //no of ways\\n\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\tif (arr[i] % arr[j] == 0) { //arr[j] is a factor of arr[i]\\n\\t\\t\\t\\t//NOTE: arr[i]/arr[j] --> gives the another factor ie, if arr[j] * arr[i]/arr[j] = arr[i] (think, simple maths)\\n\\t\\t\\t\\tauto it = mp.find(arr[i] / arr[j]);\\n\\t\\t\\t\\tif (it != mp.end()) { //found, we found the other number using which we can get the product as arr[i]\\n\\t\\t\\t\\t\\tcount += (mp[arr[j]] * it->second); //crucial part, WV\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//update the DP(map) with the new value\\n\\t\\tmp[arr[i]] += count;\\n\\t}\\n\\n\\t//add all the values(ways of forming binary trees)\\n\\tlong long int ans = 0;\\n\\tfor (auto it : mp) {\\n\\t\\tans += it.second;\\n\\t}\\n\\treturn (ans % 1000000007);\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2401196,
                "title": "c-simple-solution-hashmap",
                "content": "```\\n    int mod = 1e9 + 7;\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        unordered_map<int, long long int> mp;\\n        long long int ans = arr.size();\\n        \\n        for(auto num: arr) mp[num] = 1;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i=1;i<arr.size();i++) {\\n            long long int count = 0;\\n            \\n            for(int j=0;j<i;j++) {\\n\\t\\t\\t\\n                //check arr[j] is a factor of arr[i] or not. if not then we can\\'t procced with this, \\n\\t\\t\\t\\t//because product of children will never be equal to parent.\\n                if(arr[i] % arr[j] != 0) continue;  \\n                \\n                int num = arr[i]/arr[j]; // if arr[j] is a factor of arr[i]. Then the other child value must be equal to arr[i]/ arr[j]. \\n\\t\\t\\t\\t\\n                if(mp.find(num) != mp.end()) // Check is num present or not.\\n                    count += mp[arr[j]] * mp[num];  // mutliple to find all the possible compination.\\n                \\n            }\\n            ans += count % mod;\\n            mp[arr[i]] += count;\\n        }\\n        \\n        return ans % mod;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int mod = 1e9 + 7;\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        unordered_map<int, long long int> mp;\\n        long long int ans = arr.size();\\n        \\n        for(auto num: arr) mp[num] = 1;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i=1;i<arr.size();i++) {\\n            long long int count = 0;\\n            \\n            for(int j=0;j<i;j++) {\\n\\t\\t\\t\\n                //check arr[j] is a factor of arr[i] or not. if not then we can\\'t procced with this, \\n\\t\\t\\t\\t//because product of children will never be equal to parent.\\n                if(arr[i] % arr[j] != 0) continue;  \\n                \\n                int num = arr[i]/arr[j]; // if arr[j] is a factor of arr[i]. Then the other child value must be equal to arr[i]/ arr[j]. \\n\\t\\t\\t\\t\\n                if(mp.find(num) != mp.end()) // Check is num present or not.\\n                    count += mp[arr[j]] * mp[num];  // mutliple to find all the possible compination.\\n                \\n            }\\n            ans += count % mod;\\n            mp[arr[i]] += count;\\n        }\\n        \\n        return ans % mod;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2401172,
                "title": "binary-trees-with-factors-java-solution",
                "content": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] a) {\\n        long output = 0L , mod = (long)1e9+7;\\n        Arrays.sort(a);\\n        HashMap<Integer,Long> map = new HashMap<>();\\n        for(int i=0;i<a.length;i++)\\n        {\\n            map.put(a[i],1L);\\n            for(int j=0;j<i;j++)\\n                if(a[i]%a[j]==0)\\n                    map.put(a[i],map.get(a[i])+map.get(a[j])*map.getOrDefault(a[i]/a[j],0L)%mod);\\n            output = (output+map.get(a[i]))%mod;\\n        }\\n        return (int)output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] a) {\\n        long output = 0L , mod = (long)1e9+7;\\n        Arrays.sort(a);\\n        HashMap<Integer,Long> map = new HashMap<>();\\n        for(int i=0;i<a.length;i++)\\n        {\\n            map.put(a[i],1L);\\n            for(int j=0;j<i;j++)\\n                if(a[i]%a[j]==0)\\n                    map.put(a[i],map.get(a[i])+map.get(a[j])*map.getOrDefault(a[i]/a[j],0L)%mod);\\n            output = (output+map.get(a[i]))%mod;\\n        }\\n        return (int)output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401112,
                "title": "dynamic-programming-c",
                "content": "```\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size();\\n        int mod=1e9+7;\\n        map<int,int>dp;\\n        int ans=1;  \\n        dp[arr[0]]=1;\\n        for(int i=1;i<n;i++){\\n            dp[arr[i]]=1;\\n                for(int j=0;j<i;j++){\\n                    if(arr[i]%arr[j]==0 && dp.find(arr[i]/arr[j])!=dp.end())\\n                        dp[arr[i]]=\\n                        (\\n                            (long int)dp[arr[i]]+\\n                            (long int)dp[arr[j]]*\\n                            (long int)dp[arr[i]/arr[j]]\\n                        )%mod;\\n                }\\n            ans=((long int)ans+(long int)dp[arr[i]])%mod;\\n        }\\n        return ans;\\n\\t}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size();\\n        int mod=1e9+7;\\n        map<int,int>dp;\\n        int ans=1;  \\n        dp[arr[0]]=1;\\n        for(int i=1;i<n;i++){\\n            dp[arr[i]]=1;\\n                for(int j=0;j<i;j++){\\n                    if(arr[i]%arr[j]==0 && dp.find(arr[i]/arr[j])!=dp.end())\\n                        dp[arr[i]]=\\n                        (\\n                            (long int)dp[arr[i]]+\\n                            (long int)dp[arr[j]]*\\n                            (long int)dp[arr[i]/arr[j]]\\n                        )%mod;\\n                }\\n            ans=((long int)ans+(long int)dp[arr[i]])%mod;\\n        }\\n        return ans;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2401008,
                "title": "c-solution-using-two-pointers-explained",
                "content": "Here, dp[i] signifies the number of trees with arr[i] as **root node**.\\nSort the array first.\\nInitialize the dp array with 1 since there can always be a tree with a single node.\\nFor each element in array, we just check which two elements from arr[0] till arr[i-1] multiply to give arr[i]. \\nIf the arr[start] and arr[end] are not the same, we multiply the product of the both by 2 since the two subtrees can be swapped.\\n\\n\\n```\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        sort(arr.begin(), arr.end());\\n        int n=arr.size();\\n        vector<long long> dp(n, 1);\\n        long long ans=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int start=0;\\n            int end=i-1;\\n            while(start<end)\\n            {\\n                if((long long)arr[start]*(long long)arr[end] > arr[i])\\n                    end--;\\n                else if((long long)arr[start]*(long long)arr[end] < arr[i])\\n                    start++;\\n                else\\n                {\\n                    dp[i] += (2*dp[start]*dp[end])%mod;\\n                    start++;end--;\\n                }\\n                \\n            }\\n            if(start==end && (long long)arr[start]*(long long)arr[end]==arr[i])\\n                dp[i] = ((dp[start]*dp[start])%mod + dp[i])%mod;\\n            \\n            ans = (ans + dp[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        sort(arr.begin(), arr.end());\\n        int n=arr.size();\\n        vector<long long> dp(n, 1);\\n        long long ans=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int start=0;\\n            int end=i-1;\\n            while(start<end)\\n            {\\n                if((long long)arr[start]*(long long)arr[end] > arr[i])\\n                    end--;\\n                else if((long long)arr[start]*(long long)arr[end] < arr[i])\\n                    start++;\\n                else\\n                {\\n                    dp[i] += (2*dp[start]*dp[end])%mod;\\n                    start++;end--;\\n                }\\n                \\n            }\\n            if(start==end && (long long)arr[start]*(long long)arr[end]==arr[i])\\n                dp[i] = ((dp[start]*dp[start])%mod + dp[i])%mod;\\n            \\n            ans = (ans + dp[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400975,
                "title": "c-dp-approach",
                "content": "* class Solution {\\n* public:\\n*      int numFactoredBinaryTrees(vector<int>& arr) {\\n*         long res = 0, mod = pow(10, 9) + 7;\\n*         sort(arr.begin(), arr.end());\\n*         unordered_map<int, long long int> dp;\\n*         for (int i = 0; i < arr.size(); ++i) {\\n*             dp[arr[i]] = 1;\\n*             for (int j = 0; j < i; ++j)\\n*                 if (arr[i] % arr[j] == 0)\\n*                     dp[arr[i]] = (dp[arr[i]] + dp[arr[j]] * dp[arr[i] / arr[j]]) % mod;\\n*             res = (res + dp[arr[i]]) % mod;\\n*         }\\n*         return res;\\n*     }\\n* };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n* public:\\n*      int numFactoredBinaryTrees(vector<int>& arr) {\\n*         long res = 0, mod = pow(10, 9) + 7;\\n*         sort(arr.begin(), arr.end());\\n*         unordered_map<int, long long int> dp;\\n*         for (int i = 0; i < arr.size(); ++i) {\\n*             dp[arr[i]] = 1;\\n*             for (int j = 0; j < i; ++j)\\n*                 if (arr[i] % arr[j] == 0)\\n*                     dp[arr[i]] = (dp[arr[i]] + dp[arr[j]] * dp[arr[i] / arr[j]]) % mod;\\n*             res = (res + dp[arr[i]]) % mod;\\n*         }",
                "codeTag": "Java"
            },
            {
                "id": 2400838,
                "title": "python-dict-bottom-up-dp",
                "content": "The existing solutions are too verbose to read. Here\\'s mine\\n  \\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        # time: O(n^2), space: O(n)\\n        arr.sort()\\n        dp = defaultdict(int)\\n        for num in arr:\\n            dp[num] = 1\\n            \\n        for i in range(len(arr)):\\n            for j in range(i+1): \\n                prd = arr[i]*arr[j]\\n            \\n                if prd > arr[-1]: # arr sorted. if multiple too large, break\\n                    break\\n                if dp[prd] <= 0: # prd not in arr\\n                    continue\\n                    \\n\\t\\t\\t\\t# multiply 2 to handle case when elems in a pair arent the same\\n\\t\\t\\t\\t# ie. (2,10) & (10,2)\\n                dp[prd] += dp[arr[i]]*dp[arr[j]]*(2 if arr[i] != arr[j] else 1)\\n        \\n        return sum(dp[num] for num in arr) % (10**9 + 7)\\n ```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        # time: O(n^2), space: O(n)\\n        arr.sort()\\n        dp = defaultdict(int)\\n        for num in arr:\\n            dp[num] = 1\\n            \\n        for i in range(len(arr)):\\n            for j in range(i+1): \\n                prd = arr[i]*arr[j]\\n            \\n                if prd > arr[-1]: # arr sorted. if multiple too large, break\\n                    break\\n                if dp[prd] <= 0: # prd not in arr\\n                    continue\\n                    \\n\\t\\t\\t\\t# multiply 2 to handle case when elems in a pair arent the same\\n\\t\\t\\t\\t# ie. (2,10) & (10,2)\\n                dp[prd] += dp[arr[i]]*dp[arr[j]]*(2 if arr[i] != arr[j] else 1)\\n        \\n        return sum(dp[num] for num in arr) % (10**9 + 7)\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2400793,
                "title": "easy-c-intution-explained-dp-hashmap",
                "content": "**Intution** : *sort the array and use **HashMap** to record each Integer, and the number of trees that can be formed with that Integer as root* \\n\\n*  we are initializing **dp** with **1** because each integer will always have one tree with only itself.\\n* Let\\'s suppose we want 18 as root and we have the nodes with value 3 and 6 So, `dp[18] = dp[18] + no ways of trees that can be obtained with 6 as root * 3 as root ` (here for better understanding we are taking dp[18] but actaully it is `dp[pos of 18]` )\\n* finally we sum all the number of trees that can be formed with that integer ie `for(auto x : dp)  res+=x ;`\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        long long res=0,n=arr.size();\\n        vector<long long> dp(n,1);\\n        unordered_map<long long,long long> mp;\\n        \\n        sort(arr.begin(),arr.end());\\n        for(long long i=0;i<n;i++) mp[arr[i]]=i;\\n        \\n        \\n        for(long long i=0;i<n;i++){\\n            for(long long j=i-1; j>=0; j--)\\n            {\\n                if(arr[i]%arr[j]==0)\\n                {\\n                    long long div = arr[i]/arr[j];\\n                    if(mp.count(div)) dp[i]+=(dp[j]*dp[mp[div]])%mod;\\n                }\\n            }\\n        }\\n        \\n        for(auto x : dp)  res+=x ;\\n        return res%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        long long res=0,n=arr.size();\\n        vector<long long> dp(n,1);\\n        unordered_map<long long,long long> mp;\\n        \\n        sort(arr.begin(),arr.end());\\n        for(long long i=0;i<n;i++) mp[arr[i]]=i;\\n        \\n        \\n        for(long long i=0;i<n;i++){\\n            for(long long j=i-1; j>=0; j--)\\n            {\\n                if(arr[i]%arr[j]==0)\\n                {\\n                    long long div = arr[i]/arr[j];\\n                    if(mp.count(div)) dp[i]+=(dp[j]*dp[mp[div]])%mod;\\n                }\\n            }\\n        }\\n        \\n        for(auto x : dp)  res+=x ;\\n        return res%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400720,
                "title": "java-hashmap",
                "content": "```\\npublic int numFactoredBinaryTrees(int[] arr) {\\n        int mod = 1000000007;\\n        Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>();\\n        long ans=1;\\n        map.put(arr[0],ans);\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans=ans+sum;\\n        }\\n        return (int)(ans % mod);\\n    }\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\npublic int numFactoredBinaryTrees(int[] arr) {\\n        int mod = 1000000007;\\n        Arrays.sort(arr);\\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>();\\n        long ans=1;\\n        map.put(arr[0],ans);\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            long sum=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\\n                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\\n            }\\n            map.put(arr[i],sum);\\n            ans=ans+sum;\\n        }\\n        return (int)(ans % mod);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2400638,
                "title": "c-easy-soluton-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint N = 1e9 + 7;\\n\\tint numFactoredBinaryTrees(vector<int>& a) {\\n\\t\\tsort(a.begin(), a.end());\\n\\t\\tint n = a.size();\\n\\t\\tunordered_map<int, int> m;\\n\\t\\tfor (int i = 0; i < n; ++i) m[a[i]] = 1;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tlong long ct = 0;\\n\\t\\t\\tfor (int j = 0; j < i; ++j) {\\n\\t\\t\\t\\tif (a[i] % a[j] == 0) (ct += m[a[j]] * 1LL * m[a[i] / a[j]])%= N;\\n\\t\\t\\t}\\n\\t\\t\\tm[a[i]] += ct;\\n\\t\\t}\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (auto &e : m) (ans += e.second) %= N;\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint N = 1e9 + 7;\\n\\tint numFactoredBinaryTrees(vector<int>& a) {\\n\\t\\tsort(a.begin(), a.end());\\n\\t\\tint n = a.size();\\n\\t\\tunordered_map<int, int> m;\\n\\t\\tfor (int i = 0; i < n; ++i) m[a[i]] = 1;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tlong long ct = 0;\\n\\t\\t\\tfor (int j = 0; j < i; ++j) {\\n\\t\\t\\t\\tif (a[i] % a[j] == 0) (ct += m[a[j]] * 1LL * m[a[i] / a[j]])%= N;\\n\\t\\t\\t}\\n\\t\\t\\tm[a[i]] += ct;\\n\\t\\t}\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (auto &e : m) (ans += e.second) %= N;\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400619,
                "title": "detailed-explanation-c-dp-simple-solution-accepted",
                "content": "Lets take an example [4,2,8]\\n1. As per the problem each item itself is a valid node. i.e [2],[4],[8]\\n2. And as root is always greater than its children. the smallest item cannot have anymore children node, so Binary trees with root 2 is only 1.\\nSo we need to sort the array so we can hardcode first element tree numbers and start the calculation from 2nd one.\\n![image](https://assets.leetcode.com/users/images/b3b3cb72-373f-4351-8194-dde7d57bf1df_1660022070.6698098.png)\\nand hardcoding 1 for first element, Here is the code for that\\n![image](https://assets.leetcode.com/users/images/da62428c-bb92-4d2b-a677-c162b6d93c68_1660022004.6806722.png)\\n\\n3. When 8 have 2 children nodes i.e 4 and 2. we need to see how many tree nodes can be formed with 4 so that can be computed for 8 as well.\\nso we use dictionary to keep track of computed nodes number and use them to compute different combinations for greater numbers i.e we use number of trees for root 2 and 4 to compute for root 8.\\n![image](https://assets.leetcode.com/users/images/b73f086b-cdc0-4842-9f33-239c02ecde9b_1660022395.4377546.png)\\n4. In the solution we first get one child node using **(arr[i]%key==0)** , it means one child is already in the dictioanry i.e **key** and then to find the second child we use **records[arr[i]/key]**. we got both the nodes.\\n5. Then we sum up all the values in dictionary to get the sum of binary trees.\\n ![image](https://assets.leetcode.com/users/images/f5ff006d-394c-489b-80ec-448e141ab282_1660022430.4626384.png)\\n\\nNOTE: Use long to avoid overflows\\n\\n**Please upvote if you like the explanation and solution, it means a lot**\\n\\n```\\npublic class Solution {\\n    public int NumFactoredBinaryTrees(int[] arr) {\\n        long counter = 1;\\n        long mod = 1000000007;\\n        Array.Sort(arr);\\n        Dictionary<int,long> records = new Dictionary<int,long>();\\n        records.Add(arr[0], counter);\\n        \\n        for(int i=1; i<arr.Length; i++){\\n            counter = 1;\\n            foreach(int key in records.Keys){\\n                if((arr[i]%key==0) && records.ContainsKey(arr[i]/key))\\n                    counter += (records[key] * records[arr[i]/key]);                \\n            }  \\n            records.Add(arr[i],counter);\\n        }\\n        long sum  = 0;\\n        foreach(long curvalue in records.Values)\\n            sum = (sum + curvalue)%mod;\\n        return (int)sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumFactoredBinaryTrees(int[] arr) {\\n        long counter = 1;\\n        long mod = 1000000007;\\n        Array.Sort(arr);\\n        Dictionary<int,long> records = new Dictionary<int,long>();\\n        records.Add(arr[0], counter);\\n        \\n        for(int i=1; i<arr.Length; i++){\\n            counter = 1;\\n            foreach(int key in records.Keys){\\n                if((arr[i]%key==0) && records.ContainsKey(arr[i]/key))\\n                    counter += (records[key] * records[arr[i]/key]);                \\n            }  \\n            records.Add(arr[i],counter);\\n        }\\n        long sum  = 0;\\n        foreach(long curvalue in records.Values)\\n            sum = (sum + curvalue)%mod;\\n        return (int)sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400572,
                "title": "a-simple-c-solution",
                "content": "A Simple solution with time complexity O((n^2)*lg(n))\\n```\\nclass Solution {\\npublic:\\n    int MOD=1000000007;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        map<int,long long int> mp;\\n        for(int i=0;i<arr.size();i++)\\n            mp[arr[i]]=1;\\n        for(int i=1;i<arr.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    if(binary_search(arr.begin(),arr.end(),arr[i]/arr[j])){\\n                        if(arr[i]/arr[j]>arr[j])\\n                            mp[arr[i]]=(mp[arr[i]]+mp[arr[j]]*mp[arr[i]/arr[j]]*2)%MOD;\\n                        else if(arr[i]/arr[j]==arr[j])\\n                            mp[arr[i]]=(mp[arr[i]]+mp[arr[j]]*mp[arr[j]])%MOD;\\n                    }\\n                }\\n            }\\n        }\\n        long long answer=0;\\n        for(int i=0;i<arr.size();i++)\\n            answer=(answer+mp[arr[i]])%MOD;\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD=1000000007;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        map<int,long long int> mp;\\n        for(int i=0;i<arr.size();i++)\\n            mp[arr[i]]=1;\\n        for(int i=1;i<arr.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(arr[i]%arr[j]==0){\\n                    if(binary_search(arr.begin(),arr.end(),arr[i]/arr[j])){\\n                        if(arr[i]/arr[j]>arr[j])\\n                            mp[arr[i]]=(mp[arr[i]]+mp[arr[j]]*mp[arr[i]/arr[j]]*2)%MOD;\\n                        else if(arr[i]/arr[j]==arr[j])\\n                            mp[arr[i]]=(mp[arr[i]]+mp[arr[j]]*mp[arr[j]])%MOD;\\n                    }\\n                }\\n            }\\n        }\\n        long long answer=0;\\n        for(int i=0;i<arr.size();i++)\\n            answer=(answer+mp[arr[i]])%MOD;\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400534,
                "title": "c-soluting-using-unordered-map",
                "content": "\\n   \\n\\n     class Solution {\\n     public:\\n     int mod=1e9+7;\\n      int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_map<int,long long>mpp;\\n        int ans=0;\\n        sort(arr.begin(),arr.end());\\n\\t\\t// here we are running two loops  as the size of the array is 1e3\\n\\t\\t  // so it will be passed  in 1sec\\n        for(int i=0;i<n;i++){\\n            mpp[arr[i]]=1;\\n            for(int j=0;j<i;j++){\\n                if((arr[i]%arr[j])==0){\\n                    mpp[arr[i]]+=(mpp[arr[j]])*(mpp[arr[i]/arr[j]]);\\n                    mpp[arr[i]]%=mod;\\n                }\\n            }\\n            ans=(ans+mpp[arr[i]])%mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n\\n// T.C: O(N^2)( for two loops)\\n//S.C: O(N) ( for using the map)",
                "solutionTags": [
                    "Ordered Map"
                ],
                "code": "class Solution {\\n     public:\\n     int mod=1e9+7;\\n      int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_map<int,long long>mpp;\\n        int ans=0;\\n        sort(arr.begin(),arr.end());\\n\\t\\t// here we are running two loops  as the size of the array is 1e3\\n\\t\\t  // so it will be passed  in 1sec\\n        for(int i=0;i<n;i++){\\n            mpp[arr[i]]=1;\\n            for(int j=0;j<i;j++){\\n                if((arr[i]%arr[j])==0){\\n                    mpp[arr[i]]+=(mpp[arr[j]])*(mpp[arr[i]/arr[j]]);\\n                    mpp[arr[i]]%=mod;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2400508,
                "title": "bottom-up-dp-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        long long n = arr.size(), ans = 0, mod = 1e9+7;\\n        \\n        // sorting because we can check for smaller values as factor\\n        sort(arr.begin(), arr.end());\\n        \\n        // base case -> each node will have at least 1 tree, itself as root\\n        vector<long long> dp(n, 1);\\n        \\n        // to keep track of indices\\n        unordered_map<int, int> vis;\\n        for(int i = 0; i < n; i++) vis[arr[i]] = i;\\n        \\n        // counting for current node as parent\\n        for(int parent = 0; parent < n; ++parent) {\\n            // finding a potential left child \\n            for(int left = 0; left < parent; ++left) {\\n                if(arr[parent] % arr[left] == 0) {\\n                    // if there exists a right such that arr[parent] = arr[left] * arr[right]\\n                    if(vis.find(arr[parent] / arr[left]) != vis.end()) {\\n                        int right = arr[parent] / arr[left];\\n                        // trees[parent] = trees[left] * trees[right]\\n                        dp[parent] += (dp[left] % mod * dp[vis[right]] % mod) % mod;\\n                    }\\n                }\\n            }\\n            // total trees by using current node as parent\\n            ans += dp[parent] % mod;\\n        }\\n        \\n        return ans % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        long long n = arr.size(), ans = 0, mod = 1e9+7;\\n        \\n        // sorting because we can check for smaller values as factor\\n        sort(arr.begin(), arr.end());\\n        \\n        // base case -> each node will have at least 1 tree, itself as root\\n        vector<long long> dp(n, 1);\\n        \\n        // to keep track of indices\\n        unordered_map<int, int> vis;\\n        for(int i = 0; i < n; i++) vis[arr[i]] = i;\\n        \\n        // counting for current node as parent\\n        for(int parent = 0; parent < n; ++parent) {\\n            // finding a potential left child \\n            for(int left = 0; left < parent; ++left) {\\n                if(arr[parent] % arr[left] == 0) {\\n                    // if there exists a right such that arr[parent] = arr[left] * arr[right]\\n                    if(vis.find(arr[parent] / arr[left]) != vis.end()) {\\n                        int right = arr[parent] / arr[left];\\n                        // trees[parent] = trees[left] * trees[right]\\n                        dp[parent] += (dp[left] % mod * dp[vis[right]] % mod) % mod;\\n                    }\\n                }\\n            }\\n            // total trees by using current node as parent\\n            ans += dp[parent] % mod;\\n        }\\n        \\n        return ans % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400486,
                "title": "c-code-dp-sorting-hash-table-with-intuition-and-time-complexity",
                "content": "Intution \\n1.As given one value is also a tree node root so base case will be one \\n2. If the product are present like for 12 6 and 2 or 3 or 4 is there means it is a tree \\n3. If they are the children have aslo childrens so we are multiplying them left child * right child//\\n4.And we are sorting it ro get left child and right child sub tree first then it will give us the correct value\\njust do one dry run we will understand the Intuition \\n\\nT.C. ->O(nlogn)+O(N*N) = O(N*N);\\nSC->O(N)+O(N)=O(N)\\n\\n```\\n int numFactoredBinaryTrees(vector<int>& arr) {\\n        int mod=1e9+7;\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            mp[arr[i]]=i;\\n        }\\n        \\n      long ans=0;\\n        vector<long>dp(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i!=j){\\n                    if(arr[i]%arr[j]==0){\\n                        if(mp.find(arr[i]/arr[j])!=mp.end()){\\n                            int k=mp[arr[i]/arr[j]];\\n                            dp[i]+=(dp[j]*dp[k])%mod;//left child multiply right child \\n                        }\\n                    }\\n                }\\n            }\\n            ans=(ans+dp[i])%mod;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int numFactoredBinaryTrees(vector<int>& arr) {\\n        int mod=1e9+7;\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            mp[arr[i]]=i;\\n        }\\n        \\n      long ans=0;\\n        vector<long>dp(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i!=j){\\n                    if(arr[i]%arr[j]==0){\\n                        if(mp.find(arr[i]/arr[j])!=mp.end()){\\n                            int k=mp[arr[i]/arr[j]];\\n                            dp[i]+=(dp[j]*dp[k])%mod;//left child multiply right child \\n                        }\\n                    }\\n                }\\n            }\\n            ans=(ans+dp[i])%mod;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2400456,
                "title": "90-tc-and-83-sc-easy-python-solution",
                "content": "```\\ndef numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n\\tarr.sort()\\n\\tdp = {i:1 for i in arr}\\n\\tans = 0\\n\\tfor i in range(len(arr)):\\n\\t\\tnum = arr[i]\\n\\t\\tfor j in range(i):\\n\\t\\t\\tif(num % arr[j] == 0):\\n\\t\\t\\t\\tif(num//arr[j] in dp):\\n\\t\\t\\t\\t\\tdp[num] = (dp[num] + dp[arr[j]] * dp[num//arr[j]]) % 1000000007\\n\\t\\tans += dp[num]\\n\\treturn ans % 1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n\\tarr.sort()\\n\\tdp = {i:1 for i in arr}\\n\\tans = 0\\n\\tfor i in range(len(arr)):\\n\\t\\tnum = arr[i]\\n\\t\\tfor j in range(i):\\n\\t\\t\\tif(num % arr[j] == 0):\\n\\t\\t\\t\\tif(num//arr[j] in dp):\\n\\t\\t\\t\\t\\tdp[num] = (dp[num] + dp[arr[j]] * dp[num//arr[j]]) % 1000000007\\n\\t\\tans += dp[num]\\n\\treturn ans % 1000000007\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2400284,
                "title": "o-n-counting-using-cache-from-sub-trees-dp-hash-table-recursion",
                "content": "**Main Idea**:\\n+ The total binary of a specific number comprises it, and the number of sub-trees that are created from a splitting of left and right nodes.\\n+ A valid decomposition is splitting a node with the value product of left and right nodes equal to the parent node.\\n+ The number of sub-trees generated from splitting nodes is the product of the number of left and right sub-trees.\\n+ Using hash-table to cache all the number of sub-trees (preventing calculating again)\\n\\n**Examples**:\\n```\\na = {18, 6, 3, 2}\\n2 -> {2} = 1\\n3 -> {3} = 1\\n6 -> {6} = 1\\n     {6} {2} {3} = 1 x 1  = 1\\n     {6} {3} {2} = 1 x 1 = 1\\n  -> 3\\n18 -> 18 = 1\\n      18 {6} {3} = 3 x 1 = 3\\n\\t  18 6[0] 3\\n\\t  18 6[2,3] 3\\n\\t  18 6[3,2] 3\\n\\t  18 {3} {6} = 1 x 3 = 3\\n\\t  18 3 6[0]\\n\\t  18 3 6[2,3]\\n\\t  18 3 6[3,2]\\n   -> 1 + 3 + 3 = 7 \\ncache =  {18: 7, 6: 3, 3: 1, 2: 1}\\nans = sum(cache) = 12\\n```\\n\\n**Code**:\\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        def fsol(k, n, mod):\\n            if not h.get(k):\\n                print(k, h)\\n                ret = 1\\n                for i in range(n-1, -1, -1):\\n                    if k<=a[i]: \\n                        break\\n                    t = k // a[i]\\n                    if k%a[i]==0 and t in s:\\n                        ret = ret + fsol(a[i], n, mod) * fsol(t, n, mod)\\n                        print(\"??\", k, a[i], t, ret)\\n                        \\n                h[k] = ret%mod\\n                print(\"++\", k, h, h[k])\\n            return h[k]\\n            \\n        n, a = len(arr), sorted(arr)[::-1]\\n        s = set(a)\\n        mod = 10**9 + 7\\n        print(a)\\n        \\n        h = {}\\n        ans = 0\\n        for i in range(n):\\n            ans = (ans + fsol(a[i], n, mod))%mod\\n        \\n        print(h)\\n        print(\"=\"* 20)\\n        \\n        return ans\\n    \\nprint = lambda *a,**aa: ()\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\na = {18, 6, 3, 2}\\n2 -> {2} = 1\\n3 -> {3} = 1\\n6 -> {6} = 1\\n     {6} {2} {3} = 1 x 1  = 1\\n     {6} {3} {2} = 1 x 1 = 1\\n  -> 3\\n18 -> 18 = 1\\n      18 {6} {3} = 3 x 1 = 3\\n\\t  18 6[0] 3\\n\\t  18 6[2,3] 3\\n\\t  18 6[3,2] 3\\n\\t  18 {3} {6} = 1 x 3 = 3\\n\\t  18 3 6[0]\\n\\t  18 3 6[2,3]\\n\\t  18 3 6[3,2]\\n   -> 1 + 3 + 3 = 7 \\ncache =  {18: 7, 6: 3, 3: 1, 2: 1}\\nans = sum(cache) = 12\\n```\n```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        def fsol(k, n, mod):\\n            if not h.get(k):\\n                print(k, h)\\n                ret = 1\\n                for i in range(n-1, -1, -1):\\n                    if k<=a[i]: \\n                        break\\n                    t = k // a[i]\\n                    if k%a[i]==0 and t in s:\\n                        ret = ret + fsol(a[i], n, mod) * fsol(t, n, mod)\\n                        print(\"??\", k, a[i], t, ret)\\n                        \\n                h[k] = ret%mod\\n                print(\"++\", k, h, h[k])\\n            return h[k]\\n            \\n        n, a = len(arr), sorted(arr)[::-1]\\n        s = set(a)\\n        mod = 10**9 + 7\\n        print(a)\\n        \\n        h = {}\\n        ans = 0\\n        for i in range(n):\\n            ans = (ans + fsol(a[i], n, mod))%mod\\n        \\n        print(h)\\n        print(\"=\"* 20)\\n        \\n        return ans\\n    \\nprint = lambda *a,**aa: ()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400279,
                "title": "dp-simple-tabulation-solution",
                "content": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        \\n        final int n = arr.length;\\n        final long[] dp = new long[n];\\n        final int mod = 1000_000_007;\\n        final Map<Integer, Integer> numIndex = new HashMap<>();\\n        \\n        long res = 0;\\n                \\n        Arrays.sort(arr);\\n        \\n        for (int i=0; i<n; i++) {\\n            dp[i] = 1;\\n            numIndex.put(arr[i], i);\\n            for (int j=0; j<i; j++) {\\n                if (arr[i] % arr[j] == 0) {\\n                    Integer index = numIndex.get(arr[i]/arr[j]);\\n                    if (index != null) {\\n                        dp[i] = (dp[i] + (dp[index] * dp[j])%mod)%mod;\\n                    }\\n                }\\n            }\\n            res = (res + dp[i])%mod;\\n        }\\n        \\n        return (int) res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        \\n        final int n = arr.length;\\n        final long[] dp = new long[n];\\n        final int mod = 1000_000_007;\\n        final Map<Integer, Integer> numIndex = new HashMap<>();\\n        \\n        long res = 0;\\n                \\n        Arrays.sort(arr);\\n        \\n        for (int i=0; i<n; i++) {\\n            dp[i] = 1;\\n            numIndex.put(arr[i], i);\\n            for (int j=0; j<i; j++) {\\n                if (arr[i] % arr[j] == 0) {\\n                    Integer index = numIndex.get(arr[i]/arr[j]);\\n                    if (index != null) {\\n                        dp[i] = (dp[i] + (dp[index] * dp[j])%mod)%mod;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2400152,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Dp && Hashmap***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        long long mod = 1e9 + 7;\\n        \\n        // first of all sort the array\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        // declare a dp, dp[i] will store the possible binary tree till ith index\\n        \\n        vector<int> dp(n, 1);\\n        \\n        // declare a map, {value -> index}\\n        \\n        unordered_map<int, int> mp;\\n        \\n        // store the index to corresponding element\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[arr[i]] = i;\\n        }\\n        \\n        // fill the dp\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < i; j++)\\n            {\\n                // if we found one factor\\n                \\n                if(arr[i] % arr[j] == 0)\\n                {\\n                    // check if other corresponding factor is present in arr or not\\n                    \\n                    if(mp.count(arr[i] / arr[j]))\\n                    {\\n                        // find the index of other factor\\n                        \\n                        int idx = mp[arr[i] / arr[j]];\\n                        \\n                        // update the dp[i] \\n                        \\n                        dp[i] = (dp[i] % mod + (dp[j] % mod * dp[idx] % mod)) % mod;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // at the end just sum up all the values of dp\\n        \\n        int total = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            total = (total % mod + dp[i] % mod) % mod;\\n        }\\n        \\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        long long mod = 1e9 + 7;\\n        \\n        // first of all sort the array\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        // declare a dp, dp[i] will store the possible binary tree till ith index\\n        \\n        vector<int> dp(n, 1);\\n        \\n        // declare a map, {value -> index}\\n        \\n        unordered_map<int, int> mp;\\n        \\n        // store the index to corresponding element\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[arr[i]] = i;\\n        }\\n        \\n        // fill the dp\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < i; j++)\\n            {\\n                // if we found one factor\\n                \\n                if(arr[i] % arr[j] == 0)\\n                {\\n                    // check if other corresponding factor is present in arr or not\\n                    \\n                    if(mp.count(arr[i] / arr[j]))\\n                    {\\n                        // find the index of other factor\\n                        \\n                        int idx = mp[arr[i] / arr[j]];\\n                        \\n                        // update the dp[i] \\n                        \\n                        dp[i] = (dp[i] % mod + (dp[j] % mod * dp[idx] % mod)) % mod;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // at the end just sum up all the values of dp\\n        \\n        int total = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            total = (total % mod + dp[i] % mod) % mod;\\n        }\\n        \\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400150,
                "title": "easy-dp-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int M=1000000007;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n=arr.size();\\n        set<int>st;\\n        unordered_map<int,int>mp;\\n        for(int x:arr){\\n             st.insert(x);\\n            mp[x]=1;\\n        }\\n        for(auto it:st){\\n            int p=it;\\n            for(auto i:st){\\n                if(p%i==0 && st.find(p/i)!=st.end() && i!=p){\\n                    long long int prod=1;\\n                    prod=(((prod%M*mp[i]%M)%M)*mp[p/i]%M)%M;\\n                  //  if(prod!=1) prod*=2;\\n                    mp[p]=(mp[p]%M+prod%M)%M;\\n            }\\n                }\\n            \\n        }\\n        int ans=0;\\n        for(auto it:mp){\\n            ans=(ans%M+it.second%M)%M;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nUpvote if U like the solution",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int M=1000000007;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        int n=arr.size();\\n        set<int>st;\\n        unordered_map<int,int>mp;\\n        for(int x:arr){\\n             st.insert(x);\\n            mp[x]=1;\\n        }\\n        for(auto it:st){\\n            int p=it;\\n            for(auto i:st){\\n                if(p%i==0 && st.find(p/i)!=st.end() && i!=p){\\n                    long long int prod=1;\\n                    prod=(((prod%M*mp[i]%M)%M)*mp[p/i]%M)%M;\\n                  //  if(prod!=1) prod*=2;\\n                    mp[p]=(mp[p]%M+prod%M)%M;\\n            }\\n                }\\n            \\n        }\\n        int ans=0;\\n        for(auto it:mp){\\n            ans=(ans%M+it.second%M)%M;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400134,
                "title": "c-recursive-dp-hashmap-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // dp[i] = number of binary trees with i as root\\n    const int mod = 1e9+7;\\n    \\n    // to store for each number, {a,b} such that axb = number\\n    map<int,vector<pair<int,int>>> mp;\\n    \\n    // to map values to index\\n    map<long long,int> idx;\\n    int n;\\n    \\n    int dp[1001];\\n    \\n    int rec(int val){\\n        // base case, if it cant be further extended\\n        if(mp[val].size() == 0){\\n            return 1;\\n        }\\n        if(dp[idx[val]] != -1){\\n            return dp[idx[val]];\\n        }\\n        // dont have any left or right child\\n        int ans = 1;\\n        for(auto pr:mp[val]){\\n            long long ans1 = rec(pr.first);\\n            long long ans2 = rec(pr.second);\\n            ans1*=ans2;\\n            ans1%=mod;\\n            \\n            // swap left and right\\n            if(pr.first!=pr.second)ans1*=2LL;\\n            ans1%=mod;\\n            ans+=ans1;\\n            ans%=mod;\\n        }\\n        return dp[idx[val]] = ans;\\n    }\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        n = arr.size();\\n        for(int i=0;i<n;i++) idx[arr[i]] = i;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                long long x = 1LL*arr[i]*arr[j];\\n                if(idx.find(x) != idx.end()){\\n                    mp[x].push_back({arr[i],arr[j]});\\n                }\\n            }\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            ans+=rec(arr[i]);\\n            ans%=mod;\\n        }\\n      //  for(int i=0;i<n;i++) cout<<rec(arr[i])<<\" \";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // dp[i] = number of binary trees with i as root\\n    const int mod = 1e9+7;\\n    \\n    // to store for each number, {a,b} such that axb = number\\n    map<int,vector<pair<int,int>>> mp;\\n    \\n    // to map values to index\\n    map<long long,int> idx;\\n    int n;\\n    \\n    int dp[1001];\\n    \\n    int rec(int val){\\n        // base case, if it cant be further extended\\n        if(mp[val].size() == 0){\\n            return 1;\\n        }\\n        if(dp[idx[val]] != -1){\\n            return dp[idx[val]];\\n        }\\n        // dont have any left or right child\\n        int ans = 1;\\n        for(auto pr:mp[val]){\\n            long long ans1 = rec(pr.first);\\n            long long ans2 = rec(pr.second);\\n            ans1*=ans2;\\n            ans1%=mod;\\n            \\n            // swap left and right\\n            if(pr.first!=pr.second)ans1*=2LL;\\n            ans1%=mod;\\n            ans+=ans1;\\n            ans%=mod;\\n        }\\n        return dp[idx[val]] = ans;\\n    }\\n    \\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        n = arr.size();\\n        for(int i=0;i<n;i++) idx[arr[i]] = i;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                long long x = 1LL*arr[i]*arr[j];\\n                if(idx.find(x) != idx.end()){\\n                    mp[x].push_back({arr[i],arr[j]});\\n                }\\n            }\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            ans+=rec(arr[i]);\\n            ans%=mod;\\n        }\\n      //  for(int i=0;i<n;i++) cout<<rec(arr[i])<<\" \";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2400127,
                "title": "c-unordered-map-o-n-2-easy-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint mod = 1e9+7;\\n\\t\\tint numFactoredBinaryTrees(vector<int>& arr) {\\n\\t\\t\\tint n = arr.size(), ans=0;\\n\\t\\t\\tsort(arr.begin(),arr.end());\\n\\t\\t\\tunordered_map<int,long long>mp;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmp[arr[i]] = 1;\\n\\t\\t\\t\\tfor(int j=0;j<i;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(arr[i]%arr[j] == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmp[arr[i]] += (mp[arr[j]]*mp[arr[i]/arr[j]])%mod;\\n\\t\\t\\t\\t\\t\\tmp[arr[i]] %= mod;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = (ans + mp[arr[i]])%mod;\\n\\t\\t\\t} \\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint mod = 1e9+7;\\n\\t\\tint numFactoredBinaryTrees(vector<int>& arr) {\\n\\t\\t\\tint n = arr.size(), ans=0;\\n\\t\\t\\tsort(arr.begin(),arr.end());\\n\\t\\t\\tunordered_map<int,long long>mp;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmp[arr[i]] = 1;\\n\\t\\t\\t\\tfor(int j=0;j<i;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(arr[i]%arr[j] == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmp[arr[i]] += (mp[arr[j]]*mp[arr[i]/arr[j]])%mod;\\n\\t\\t\\t\\t\\t\\tmp[arr[i]] %= mod;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2400054,
                "title": "simple-c-solution",
                "content": "```\\nint cmp(const void *a, const void *b)\\n{\\n    return *(int *)a - *(int *)b;\\n}\\n\\nint numFactoredBinaryTrees(int* arr, int arrSize){\\n    int result = 0, mod = pow(10, 9) + 7;\\n    qsort(arr, arrSize, sizeof(int), cmp);\\n    long dp[arrSize];\\n    for(int i = 0; i < arrSize; i++) \\n        dp[i] = 1;\\n    for(int i = 0; i < arrSize; i++) \\n    {\\n\\t\\tint left = 0, right = i - 1;\\n\\t\\twhile (left <= right) \\n        {\\n\\t\\t\\tif((long)arr[left] * arr[right] > arr[i])\\n\\t\\t\\t\\tright--;\\n\\t\\t\\telse if ((long)arr[left] * arr[right] < arr[i])\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\telse\\n            {\\n\\t\\t\\t\\tif (left == right)\\n\\t\\t\\t\\t\\tdp[i] += (dp[left] * dp[right]);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdp[i] += 2 * (dp[left] * dp[right]);\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult = ((result % mod) + dp[i]) % mod;   \\n\\t}\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nint cmp(const void *a, const void *b)\\n{\\n    return *(int *)a - *(int *)b;\\n}\\n\\nint numFactoredBinaryTrees(int* arr, int arrSize){\\n    int result = 0, mod = pow(10, 9) + 7;\\n    qsort(arr, arrSize, sizeof(int), cmp);\\n    long dp[arrSize];\\n    for(int i = 0; i < arrSize; i++) \\n        dp[i] = 1;\\n    for(int i = 0; i < arrSize; i++) \\n    {\\n\\t\\tint left = 0, right = i - 1;\\n\\t\\twhile (left <= right) \\n        {\\n\\t\\t\\tif((long)arr[left] * arr[right] > arr[i])\\n\\t\\t\\t\\tright--;\\n\\t\\t\\telse if ((long)arr[left] * arr[right] < arr[i])\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\telse\\n            {\\n\\t\\t\\t\\tif (left == right)\\n\\t\\t\\t\\t\\tdp[i] += (dp[left] * dp[right]);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdp[i] += 2 * (dp[left] * dp[right]);\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult = ((result % mod) + dp[i]) % mod;   \\n\\t}\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2400023,
                "title": "java-hashmap-faster-than-98-27-less-than-23-70",
                "content": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int result = 0;\\n        Arrays.sort(arr);\\n        int max = arr[arr.length-1];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : arr) map.put(num, 1);\\n        for (int i = 0; i < arr.length; i++) {\\n            long count = map.get(arr[i]);\\n            result += count;\\n            if (result > 1000000007) result %= 1000000007;            \\n            \\n            for (int j = 0; j < i; j++) {\\n                long temp = (long) arr[i]*arr[j];\\n                if (temp > max) break;\\n                int product = (int) temp;\\n                if (map.containsKey(product)) {\\n                    long newVal = 2*map.get(arr[j]);\\n                    if (newVal > 1000000007) newVal %= 1000000007;\\n                    newVal *= count;\\n                    if (newVal > 1000000007) newVal %= 1000000007;\\n                    newVal += map.get(product);\\n                    if (newVal > 1000000007) newVal %= 1000000007;\\n                    map.put(product, (int) newVal);\\n                }\\n            }\\n            \\n            long temp = (long) arr[i]*arr[i];\\n            if (temp > max) continue;\\n            int product = (int) temp;\\n            if (map.containsKey(product)) {\\n                long newVal = count*count;\\n                if (newVal > 1000000007) newVal %= 1000000007;\\n                newVal += map.get(product);\\n                if (newVal > 1000000007) newVal %= 1000000007;\\n                map.put(product, (int) newVal);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFactoredBinaryTrees(int[] arr) {\\n        int result = 0;\\n        Arrays.sort(arr);\\n        int max = arr[arr.length-1];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : arr) map.put(num, 1);\\n        for (int i = 0; i < arr.length; i++) {\\n            long count = map.get(arr[i]);\\n            result += count;\\n            if (result > 1000000007) result %= 1000000007;            \\n            \\n            for (int j = 0; j < i; j++) {\\n                long temp = (long) arr[i]*arr[j];\\n                if (temp > max) break;\\n                int product = (int) temp;\\n                if (map.containsKey(product)) {\\n                    long newVal = 2*map.get(arr[j]);\\n                    if (newVal > 1000000007) newVal %= 1000000007;\\n                    newVal *= count;\\n                    if (newVal > 1000000007) newVal %= 1000000007;\\n                    newVal += map.get(product);\\n                    if (newVal > 1000000007) newVal %= 1000000007;\\n                    map.put(product, (int) newVal);\\n                }\\n            }\\n            \\n            long temp = (long) arr[i]*arr[i];\\n            if (temp > max) continue;\\n            int product = (int) temp;\\n            if (map.containsKey(product)) {\\n                long newVal = count*count;\\n                if (newVal > 1000000007) newVal %= 1000000007;\\n                newVal += map.get(product);\\n                if (newVal > 1000000007) newVal %= 1000000007;\\n                map.put(product, (int) newVal);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399932,
                "title": "python-100-faster-dp-solution-not-short",
                "content": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        children = {num: [] for num in arr}\\n        trees = {num: 1 for num in arr}\\n        MOD = 10 ** 9 + 7\\n        \\n        for i in range(len(arr) - 1):\\n            for j in range(i, len(arr) - 1):\\n                product = arr[i] * arr[j]\\n                if product in children:\\n                    children[product].append((arr[i], arr[j]))\\n                elif product > arr[-1]:\\n                    break\\n        \\n        res = 0\\n        for num in arr:\\n            for pair in children[num]:\\n                trees[num] += (trees[pair[0]] * trees[pair[1]]\\n                               if pair[0] == pair[1]\\n                               else 2 * (trees[pair[0]] * trees[pair[1]]))\\n            trees[num] %= MOD\\n            res = (res + trees[num]) % MOD\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        children = {num: [] for num in arr}\\n        trees = {num: 1 for num in arr}\\n        MOD = 10 ** 9 + 7\\n        \\n        for i in range(len(arr) - 1):\\n            for j in range(i, len(arr) - 1):\\n                product = arr[i] * arr[j]\\n                if product in children:\\n                    children[product].append((arr[i], arr[j]))\\n                elif product > arr[-1]:\\n                    break\\n        \\n        res = 0\\n        for num in arr:\\n            for pair in children[num]:\\n                trees[num] += (trees[pair[0]] * trees[pair[1]]\\n                               if pair[0] == pair[1]\\n                               else 2 * (trees[pair[0]] * trees[pair[1]]))\\n            trees[num] %= MOD\\n            res = (res + trees[num]) % MOD\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373613,
                "title": "c-clean-solution",
                "content": "**Code** : \\n```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        sort(arr.begin(),arr.end());\\n        int n=arr.size();\\n        \\n        vector<int> dp(n,1);\\n        \\n        for(int i=1;i<n;i++){\\n            int l=0,r=i-1;\\n            while(l<=r){\\n                if(arr[l]*1LL*arr[r]==arr[i]*1LL){   \\n                    if(l!=r) dp[i]=(dp[i]+(dp[l]*1LL*dp[r]%mod*2LL%mod))%mod;\\n                    else dp[i]=(dp[i]+(dp[l]*1LL*dp[r]%mod))%mod;\\n                    l++,r--;\\n                } else if(arr[l]*1LL*arr[r]>arr[i]*1LL) r--;\\n                else l++;\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(auto i:dp) ans=(ans+i)%mod;\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity : **0(n^2)**\\nSpace Complexity : **0(n)**\\n\\nHope this helps :)\\nAny suggestions or updations are happily invited.",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        \\n        sort(arr.begin(),arr.end());\\n        int n=arr.size();\\n        \\n        vector<int> dp(n,1);\\n        \\n        for(int i=1;i<n;i++){\\n            int l=0,r=i-1;\\n            while(l<=r){\\n                if(arr[l]*1LL*arr[r]==arr[i]*1LL){   \\n                    if(l!=r) dp[i]=(dp[i]+(dp[l]*1LL*dp[r]%mod*2LL%mod))%mod;\\n                    else dp[i]=(dp[i]+(dp[l]*1LL*dp[r]%mod))%mod;\\n                    l++,r--;\\n                } else if(arr[l]*1LL*arr[r]>arr[i]*1LL) r--;\\n                else l++;\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(auto i:dp) ans=(ans+i)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180513,
                "title": "python-3-recursion-memoization-o-n-2-o-n",
                "content": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        n = len(nums)\\n        \\n        @lru_cache(None)\\n        def helper(num):\\n            trees = 1\\n            for factor in nums:\\n                if not num % factor and num // factor in nums:\\n                    trees += helper(factor) * helper(num // factor)\\n\\n            return trees\\n        \\n        return sum(helper(num) for num in nums) % (10 ** 9 + 7)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def numFactoredBinaryTrees(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        n = len(nums)\\n        \\n        @lru_cache(None)\\n        def helper(num):\\n            trees = 1\\n            for factor in nums:\\n                if not num % factor and num // factor in nums:\\n                    trees += helper(factor) * helper(num // factor)\\n\\n            return trees\\n        \\n        return sum(helper(num) for num in nums) % (10 ** 9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 2126369,
                "title": "c-easy-to-understand-commented-solution-hashmap-dp",
                "content": "Upvote if you find the code easy to understand :)\\n```\\nint numFactoredBinaryTrees(vector<int>& arr) {\\n        map<int,long long int>m;\\n        long long int ans=0;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            m[arr[i]]=1;  //1 tree always being formed, also we don\\'t care about frequency of arr[i]\\n        }\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            int root=it->first; //root of the tree\\n            for(auto it1=m.begin();it1!=it;it1++)  //iterating through all left child possibilities\\n            {\\n                if(m.find(root/it1->first)!=m.end()&&root%it1->first==0) //if and only if completely divisible\\n                {\\n                    long long int treesNumber=(it1->second*m[root/it1->first]); //left child trees*right child trees\\n                    it->second+=treesNumber;\\n                }\\n            }\\n            ans+=it->second;\\n        }\\n        return ans%1000000007;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "Upvote if you find the code easy to understand :)\\n```\\nint numFactoredBinaryTrees(vector<int>& arr) {\\n        map<int,long long int>m;\\n        long long int ans=0;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            m[arr[i]]=1;  //1 tree always being formed, also we don\\'t care about frequency of arr[i]\\n        }\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            int root=it->first; //root of the tree\\n            for(auto it1=m.begin();it1!=it;it1++)  //iterating through all left child possibilities\\n            {\\n                if(m.find(root/it1->first)!=m.end()&&root%it1->first==0) //if and only if completely divisible\\n                {\\n                    long long int treesNumber=(it1->second*m[root/it1->first]); //left child trees*right child trees\\n                    it->second+=treesNumber;\\n                }\\n            }\\n            ans+=it->second;\\n        }\\n        return ans%1000000007;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2121309,
                "title": "c-without-recursion-and-dp",
                "content": "# Using map to store factors\\n\\n\\n\\t\\t#define ll long long int\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint numFactoredBinaryTrees(vector<int>& arr) {\\n\\t\\t\\t\\tint mod = 1000000000+7;\\n\\t\\t\\t\\tsort(arr.begin(),arr.end());\\n\\t\\t\\t\\tint n = arr.size();\\n\\t\\t\\t\\tunordered_map<ll,ll> m;\\n\\t\\t\\t\\tll res = 0;\\n\\t\\t\\t\\tfor(auto i: arr){\\n\\t\\t\\t\\t\\tll cnt = 1;\\n\\t\\t\\t\\t\\tfor(auto j: arr){\\n\\t\\t\\t\\t\\t\\tif(i%j==0 and m.find(j)!=m.end() and m.find(i/j)!=m.end()){\\n\\t\\t\\t\\t\\t\\t\\tcnt += m[j]%mod*m[i/j]%mod;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tm[i]=cnt%mod;\\n\\t\\t\\t\\t\\tres += cnt%mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res%mod;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint numFactoredBinaryTrees(vector<int>& arr) {\\n\\t\\t\\t\\tint mod = 1000000000+7;\\n\\t\\t\\t\\tsort(arr.begin(),arr.end());\\n\\t\\t\\t\\tint n = arr.size();\\n\\t\\t\\t\\tunordered_map<ll,ll> m;\\n\\t\\t\\t\\tll res = 0;\\n\\t\\t\\t\\tfor(auto i: arr){\\n\\t\\t\\t\\t\\tll cnt = 1;\\n\\t\\t\\t\\t\\tfor(auto j: arr){\\n\\t\\t\\t\\t\\t\\tif(i%j==0 and m.find(j)!=m.end() and m.find(i/j)!=m.end()){\\n\\t\\t\\t\\t\\t\\t\\tcnt += m[j]%mod*m[i/j]%mod;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2121205,
                "title": "c-recursion-memoziation",
                "content": "\\t\\t#define ll long long int\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tunordered_set<ll> s;\\n\\t\\t\\tunordered_map<ll,ll> t;\\n\\t\\t\\tll m = 1000000000+7;\\n\\t\\t\\tll f(int a,vector<int>& arr){\\n\\t\\t\\t\\tif(s.find(a)==s.end())return 0;\\n\\t\\t\\t\\tif(t.find(a)!=t.end())return t[a];\\n\\n\\t\\t\\t\\tll cnt=1;\\n\\t\\t\\t\\tfor(int i=0; i<arr.size(); i++){\\n\\t\\t\\t\\t\\t//cheak if arr[i] factors are present or not\\n\\t\\t\\t\\t\\tif(a%arr[i]==0 and s.find(a/arr[i])!=s.end()){\\n\\t\\t\\t\\t\\t\\t// then recursively call their factor also\\n\\t\\t\\t\\t\\t\\tcnt += (f(arr[i],arr)%m * f(a/arr[i],arr)%m)%m;\\n\\t\\t\\t\\t\\t\\t// cnt = (cnt+k);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn t[a] = cnt;\\n\\t\\t\\t}\\n\\t\\t\\tint numFactoredBinaryTrees(vector<int>& arr) {\\n\\t\\t\\t\\ts.clear();\\n\\t\\t\\t\\tint n = arr.size();\\n\\t\\t\\t\\tll res = 0;\\n\\t\\t\\t\\tfor(auto i: arr){\\n\\t\\t\\t\\t\\ts.insert(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\t\\t//make it as root\\n\\t\\t\\t\\t\\tres += f(arr[i],arr);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res%m;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tunordered_set<ll> s;\\n\\t\\t\\tunordered_map<ll,ll> t;\\n\\t\\t\\tll m = 1000000000+7;\\n\\t\\t\\tll f(int a,vector<int>& arr){\\n\\t\\t\\t\\tif(s.find(a)==s.end())return 0;\\n\\t\\t\\t\\tif(t.find(a)!=t.end())return t[a];\\n\\n\\t\\t\\t\\tll cnt=1;\\n\\t\\t\\t\\tfor(int i=0; i<arr.size(); i++){\\n\\t\\t\\t\\t\\t//cheak if arr[i] factors are present or not\\n\\t\\t\\t\\t\\tif(a%arr[i]==0 and s.find(a/arr[i])!=s.end()){\\n\\t\\t\\t\\t\\t\\t// then recursively call their factor also\\n\\t\\t\\t\\t\\t\\tcnt += (f(arr[i],arr)%m * f(a/arr[i],arr)%m)%m;\\n\\t\\t\\t\\t\\t\\t// cnt = (cnt+k);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1814561,
                "title": "wtf-is-with-the-description",
                "content": "You can have infinite trees.\\n\\nLeaves:\\n\\n2\\n2 2\\n2 2 2\\n2 2 2 2\\n2 2 2 2 2\\n...\\n\\nI hate this stupid description. How tf do people understand what this is asking?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1638396,
                "title": "using-maps-and-sqrt-break-48-ms-faster-than-86-27-c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        int total_count = 0;\\n        int mod = 1000000007;\\n        unordered_map<int,int> keyasroot;\\n        long long int var1, var2, temp_prod;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            int factortill = pow(arr[i], 0.5);\\n            int curr_count = 1;\\n            for(int j=0;j<arr.size();j++){\\n                int num1;\\n                if(arr[j]<=factortill){\\n                    num1 = arr[j];\\n                }\\n                else{\\n                    break;\\n                }\\n                int num2 = arr[i]/num1;\\n                if(num1*num2==arr[i]){\\n                    if(num1==num2){\\n                        var1 = keyasroot[num1];\\n                        var2 = keyasroot[num2];\\n                        temp_prod = (var1*var2)%mod;\\n                        curr_count = (curr_count + temp_prod)%mod;\\n                    }\\n                    else{\\n                        var1 = keyasroot[num1];\\n                        var2 = keyasroot[num2];\\n                        temp_prod = (var1*var2)%mod;\\n                        temp_prod = (temp_prod*2)%mod;\\n                        curr_count = (curr_count + temp_prod)%mod;\\n                    }\\n                }\\n            }\\n            keyasroot[arr[i]] = curr_count;\\n            total_count = (total_count + curr_count)%mod;\\n        }\\n        return total_count;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFactoredBinaryTrees(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        int total_count = 0;\\n        int mod = 1000000007;\\n        unordered_map<int,int> keyasroot;\\n        long long int var1, var2, temp_prod;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            int factortill = pow(arr[i], 0.5);\\n            int curr_count = 1;\\n            for(int j=0;j<arr.size();j++){\\n                int num1;\\n                if(arr[j]<=factortill){\\n                    num1 = arr[j];\\n                }\\n                else{\\n                    break;\\n                }\\n                int num2 = arr[i]/num1;\\n                if(num1*num2==arr[i]){\\n                    if(num1==num2){\\n                        var1 = keyasroot[num1];\\n                        var2 = keyasroot[num2];\\n                        temp_prod = (var1*var2)%mod;\\n                        curr_count = (curr_count + temp_prod)%mod;\\n                    }\\n                    else{\\n                        var1 = keyasroot[num1];\\n                        var2 = keyasroot[num2];\\n                        temp_prod = (var1*var2)%mod;\\n                        temp_prod = (temp_prod*2)%mod;\\n                        curr_count = (curr_count + temp_prod)%mod;\\n                    }\\n                }\\n            }\\n            keyasroot[arr[i]] = curr_count;\\n            total_count = (total_count + curr_count)%mod;\\n        }\\n        return total_count;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310584,
                "title": "python3-easy-dp-solution",
                "content": "```\\ndef numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        mod=10**9+7\\n        n=len(arr)\\n        dp=[1]*(n)\\n        arr_set=set(arr)\\n        for i in range(1,n):\\n            for j in range(i):\\n                if arr[i]%arr[j]==0:\\n                    temp=arr[i]//arr[j]\\n                    if temp in arr_set:\\n                        idx=arr.index(temp)\\n                        dp[i]+=dp[j]*dp[idx]\\n        return sum(dp)%mod",
                "solutionTags": [],
                "code": "```\\ndef numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        mod=10**9+7\\n        n=len(arr)\\n        dp=[1]*(n)\\n        arr_set=set(arr)\\n        for i in range(1,n):\\n            for j in range(i):\\n                if arr[i]%arr[j]==0:\\n                    temp=arr[i]//arr[j]\\n                    if temp in arr_set:\\n                        idx=arr.index(temp)\\n                        dp[i]+=dp[j]*dp[idx]\\n        return sum(dp)%mod",
                "codeTag": "Python3"
            },
            {
                "id": 1109389,
                "title": "c-12ms-100-how-about-it-new-time-record",
                "content": "I wrote that previous version can be improved and if I have free time I write it. I did it !!! and what I have : \\n![image](https://assets.leetcode.com/users/images/713b8cb1-7be2-4b54-96af-fd5721359022_1615835234.7344735.png)\\n\\n\\nRuntime: 12 ms, faster than 100.00% of C++ online submissions for Binary Trees With Factors.\\nMemory Usage: 10.2 MB, less than 20.93% of C++ online submissions for Binary Trees With Factors.\\n```\\nclass Solution {\\npublic:\\n  int numFactoredBinaryTrees(vector<int>& arr) {\\n    int mod = 1000000007, n = arr.size();\\n    unsigned long long answer = 0;\\n\\n    sort(arr.begin(),arr.end());\\n    vector<unsigned long long> dp(n);\\n    unordered_map<int,int> mp;\\n    vector<int> squar(n, -1);\\n    vector<vector<pair<int,int>>*> table(n, NULL);\\n    \\n    for (int i = 0; i != n; i++) mp[arr[i]] = i;\\n\\n    int i = 0;\\n    while(true){\\n      if(arr[i] > 31622) break; \\n      int squared = arr[i]*arr[i];\\n      if(mp.count(squared)) squar[mp[squared]] = i;             \\n      if(squared >= arr.back()) break;\\n      \\n      int j = i + 1;\\n      while(true){\\n        unsigned long long num = (unsigned long long)(arr[i])*arr[j];\\n        if(num > arr.back()) break;\\n        if(mp.count(num)){\\n          if(table[mp[num]] == NULL)\\n            table[mp[num]] = new vector<pair<int,int>>;\\n          table[mp[num]]->push_back({i,j});\\n        }\\n        j++;\\n      }\\n      i++;\\n    }\\n    \\n    for(int i = 0; i != n; i++){\\n      dp[i] = 1;\\n      if(squar[i] != -1) dp[i] += dp[squar[i]] * dp[squar[i]];\\n      if(table[i])\\n        for(int w = 0; w != table[i]->size(); w++)\\n          dp[i] += (dp[table[i]->operator[](w).first]*dp[table[i]->operator[](w).second])<<1;\\n    }\\n                \\n    for (unsigned long long i : dp) answer += i;\\n    return (int)(answer % mod);    \\n  }\\n};\\n```\\n\\nOld version :\\n\\n\\n\\nRuntime: 16 ms, faster than 100.00% of C++ online submissions for Binary Trees With Factors.\\nMemory Usage: 10.1 MB, less than 22.48% of C++ online submissions for Binary Trees With Factors.\\n![image](https://assets.leetcode.com/users/images/1f63d3ff-702e-43ea-a799-b0d8c51b4e08_1615735880.8892975.png)\\nOn second thought sake it can be improve !!! if I have free time - I will do it.\\nGeneral idea - just only forward !!!\\nP.s This idea is different from official .\\n\\n```\\nclass Solution {\\npublic:\\n  int numFactoredBinaryTrees(vector<int>& arr) {\\n    int mod = 1000000007, n = arr.size();\\n    unsigned long long answer = 0;\\n\\n    sort(arr.begin(),arr.end());\\n    vector<unsigned long long> dp(n);\\n    unordered_map<int,int> mp;\\n    vector<vector<tuple<int,int,int>>*> table(n, NULL);\\n    \\n    for (int i = 0; i != n; i++) mp[arr[i]] = i;\\n\\n    int i = 0;\\n    while(true){\\n      if(arr[i] > 31622) break; \\n      int squared = arr[i]*arr[i];\\n      if(mp.count(squared)){\\n        if(table[mp[squared]] == NULL)\\n          table[mp[squared]] = new vector<tuple<int,int,int>>;\\n        table[mp[squared]]->push_back({i,i,0});\\n      }\\n      if(squared >= arr.back()) break;\\n      \\n      int j = i + 1;\\n      while(true){\\n        unsigned long long num = (unsigned long long)(arr[i])*arr[j];\\n        if(num > arr.back()) break;\\n        if(mp.count(num)){\\n          if(table[mp[num]] == NULL)\\n            table[mp[num]] = new vector<tuple<int,int,int>>;\\n          table[mp[num]]->push_back({i,j,1});\\n        }\\n        j++;\\n      }\\n      i++;\\n    }\\n    \\n    for(int i = 0; i != n; i++){\\n      dp[i] = 1;\\n      if(table[i])\\n        for(int w = 0; w != table[i]->size(); w++)\\n          dp[i] += (dp[get<0>(table[i]->operator[](w))]*dp[get<1>(table[i]->operator[](w))]<<\\n                   get<2>(table[i]->operator[](w)));\\n    }\\n                \\n    for (unsigned long long i : dp) answer += i;\\n    return (int)(answer % mod);    \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int numFactoredBinaryTrees(vector<int>& arr) {\\n    int mod = 1000000007, n = arr.size();\\n    unsigned long long answer = 0;\\n\\n    sort(arr.begin(),arr.end());\\n    vector<unsigned long long> dp(n);\\n    unordered_map<int,int> mp;\\n    vector<int> squar(n, -1);\\n    vector<vector<pair<int,int>>*> table(n, NULL);\\n    \\n    for (int i = 0; i != n; i++) mp[arr[i]] = i;\\n\\n    int i = 0;\\n    while(true){\\n      if(arr[i] > 31622) break; \\n      int squared = arr[i]*arr[i];\\n      if(mp.count(squared)) squar[mp[squared]] = i;             \\n      if(squared >= arr.back()) break;\\n      \\n      int j = i + 1;\\n      while(true){\\n        unsigned long long num = (unsigned long long)(arr[i])*arr[j];\\n        if(num > arr.back()) break;\\n        if(mp.count(num)){\\n          if(table[mp[num]] == NULL)\\n            table[mp[num]] = new vector<pair<int,int>>;\\n          table[mp[num]]->push_back({i,j});\\n        }\\n        j++;\\n      }\\n      i++;\\n    }\\n    \\n    for(int i = 0; i != n; i++){\\n      dp[i] = 1;\\n      if(squar[i] != -1) dp[i] += dp[squar[i]] * dp[squar[i]];\\n      if(table[i])\\n        for(int w = 0; w != table[i]->size(); w++)\\n          dp[i] += (dp[table[i]->operator[](w).first]*dp[table[i]->operator[](w).second])<<1;\\n    }\\n                \\n    for (unsigned long long i : dp) answer += i;\\n    return (int)(answer % mod);    \\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  int numFactoredBinaryTrees(vector<int>& arr) {\\n    int mod = 1000000007, n = arr.size();\\n    unsigned long long answer = 0;\\n\\n    sort(arr.begin(),arr.end());\\n    vector<unsigned long long> dp(n);\\n    unordered_map<int,int> mp;\\n    vector<vector<tuple<int,int,int>>*> table(n, NULL);\\n    \\n    for (int i = 0; i != n; i++) mp[arr[i]] = i;\\n\\n    int i = 0;\\n    while(true){\\n      if(arr[i] > 31622) break; \\n      int squared = arr[i]*arr[i];\\n      if(mp.count(squared)){\\n        if(table[mp[squared]] == NULL)\\n          table[mp[squared]] = new vector<tuple<int,int,int>>;\\n        table[mp[squared]]->push_back({i,i,0});\\n      }\\n      if(squared >= arr.back()) break;\\n      \\n      int j = i + 1;\\n      while(true){\\n        unsigned long long num = (unsigned long long)(arr[i])*arr[j];\\n        if(num > arr.back()) break;\\n        if(mp.count(num)){\\n          if(table[mp[num]] == NULL)\\n            table[mp[num]] = new vector<tuple<int,int,int>>;\\n          table[mp[num]]->push_back({i,j,1});\\n        }\\n        j++;\\n      }\\n      i++;\\n    }\\n    \\n    for(int i = 0; i != n; i++){\\n      dp[i] = 1;\\n      if(table[i])\\n        for(int w = 0; w != table[i]->size(); w++)\\n          dp[i] += (dp[get<0>(table[i]->operator[](w))]*dp[get<1>(table[i]->operator[](w))]<<\\n                   get<2>(table[i]->operator[](w)));\\n    }\\n                \\n    for (unsigned long long i : dp) answer += i;\\n    return (int)(answer % mod);    \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108180,
                "title": "python-iteration-lookup-explanation-comments-diagram",
                "content": "Approach: O(N^2) runtime O(N) space - where N=len(arr)\\nIteration + Lookup\\nThe array needs to be sorted in increasing order for this method to work.\\nIterate through the array, for each array[i], we try modding with numbers to the left one by one\\nto find the factors of array[i]. For each factor, we can use valToCount map to lookup number of binary\\ntrees so we don\\'t recompute the recursion (note that there will be recursion if the factor can be broken up into more factors, so those will also be added to factors).\\n\\nDiagram example: https://drive.google.com/file/d/1vwcfst55yrYAheA8glYI-enJSCd4S3x5/view?usp=sharing\\n```py\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        #print(\"sorted input={}\".format(arr))\\n        valToCount = {} #maps arr value to number of binary trees we can make having that value as root\\n        MOD = 10**9+7\\n        result = 0\\n        #for each arr[i] we will get the count of all possible binary trees that have arr[i] as root, and then add it to valToCount map\\n        for index,val in enumerate(arr):\\n            valResult = 1 #start off with just [arr[i]], then add more for each binary tree we can make with factors\\n            #find all factors (by checking to the left of val) and multiply the count of each pair of factors to get the combination for this factor pair\\'s orientation\\n            for factorIdx in range(index-1,-1,-1):\\n                factorCandidate = arr[factorIdx]\\n                if val % factorCandidate == 0:\\n                    #this is a factor, so get the sum of the combinations for the [thisfactor,completementfactor] orientation \\n                    #(i.e. this factor will go first, and later on when we iterate to another arr[factorIdx], we will use the other factor to go first).\\n                    factor2 = val // factorCandidate\\n                    \\n                    #print(\"factorCandidate={},factor2={}\".format(factorCandidate,factor2))\\n                    #check if factor2 exists in arr\\n                    if factor2 in valToCount:\\n                        #note that we can do lookups because any value to the left is already computed in the previous iteration of our first for loop\\n                        valResult += valToCount[factorCandidate] * valToCount[factor2]\\n                        valResult %= MOD\\n            \\n            #append val to map so we can reuse without having to recursively compute the result for value again\\n            valToCount[val] = valResult\\n            result += valResult\\n            result %= MOD\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```py\\nclass Solution:\\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\\n        arr.sort()\\n        #print(\"sorted input={}\".format(arr))\\n        valToCount = {} #maps arr value to number of binary trees we can make having that value as root\\n        MOD = 10**9+7\\n        result = 0\\n        #for each arr[i] we will get the count of all possible binary trees that have arr[i] as root, and then add it to valToCount map\\n        for index,val in enumerate(arr):\\n            valResult = 1 #start off with just [arr[i]], then add more for each binary tree we can make with factors\\n            #find all factors (by checking to the left of val) and multiply the count of each pair of factors to get the combination for this factor pair\\'s orientation\\n            for factorIdx in range(index-1,-1,-1):\\n                factorCandidate = arr[factorIdx]\\n                if val % factorCandidate == 0:\\n                    #this is a factor, so get the sum of the combinations for the [thisfactor,completementfactor] orientation \\n                    #(i.e. this factor will go first, and later on when we iterate to another arr[factorIdx], we will use the other factor to go first).\\n                    factor2 = val // factorCandidate\\n                    \\n                    #print(\"factorCandidate={},factor2={}\".format(factorCandidate,factor2))\\n                    #check if factor2 exists in arr\\n                    if factor2 in valToCount:\\n                        #note that we can do lookups because any value to the left is already computed in the previous iteration of our first for loop\\n                        valResult += valToCount[factorCandidate] * valToCount[factor2]\\n                        valResult %= MOD\\n            \\n            #append val to map so we can reuse without having to recursively compute the result for value again\\n            valToCount[val] = valResult\\n            result += valResult\\n            result %= MOD\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108099,
                "title": "javascript-dp-248ms-70",
                "content": "```\\nconst MOD = 1e9 + 7;\\nconst numFactoredBinaryTrees = (a) => {\\n    let n = a.length;\\n    let dp = new Map();\\n    a.sort((x, y) => x - y);\\n    for (let i = 0; i < n; i++) {\\n        dp.set(a[i], 1);\\n        for (let j = 0; j < i; j++) {\\n            let divide = a[i] / a[j] >> 0;\\n            let dd = dp.get(divide);\\n            let ii = dp.get(a[i]);\\n            let jj = dp.get(a[j]);\\n            if (a[i] % a[j] == 0 && dp.has(divide)) {\\n                dp.set(a[i], ii + jj * dd);\\n            }\\n        }\\n    }\\n    let res = 0;\\n    for (const [, v] of dp) res += v;\\n    return res % MOD;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst MOD = 1e9 + 7;\\nconst numFactoredBinaryTrees = (a) => {\\n    let n = a.length;\\n    let dp = new Map();\\n    a.sort((x, y) => x - y);\\n    for (let i = 0; i < n; i++) {\\n        dp.set(a[i], 1);\\n        for (let j = 0; j < i; j++) {\\n            let divide = a[i] / a[j] >> 0;\\n            let dd = dp.get(divide);\\n            let ii = dp.get(a[i]);\\n            let jj = dp.get(a[j]);\\n            if (a[i] % a[j] == 0 && dp.has(divide)) {\\n                dp.set(a[i], ii + jj * dd);\\n            }\\n        }\\n    }\\n    let res = 0;\\n    for (const [, v] of dp) res += v;\\n    return res % MOD;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1571922,
                "content": [
                    {
                        "username": "theOtherWC",
                        "content": "The question is unclear in that what children refer to.\\nIt could me \"immediate children\" or \"all descendants\". It would be very helpful if the question is explicit about this."
                    },
                    {
                        "username": "neil_paul",
                        "content": "Unless stated explicitly, children always means \"immediate children\"."
                    },
                    {
                        "username": "CAFEBABY",
                        "content": "The answer is 8. But I can only see: [2], [4], [16], [4,2,2], [16,4,4]. What are the other three?"
                    },
                    {
                        "username": "manasvegi",
                        "content": "For anyone who may read this eventually, \\nBecause these are trees, the remaining 3 are \\n[16,[4,2,2],4], [16,4,[4,2,2]], and [16,[4,2,2],[4,2,2]]"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "sometimes I realise recursion is a powerful tool"
                    }
                ]
            },
            {
                "id": 1569207,
                "content": [
                    {
                        "username": "theOtherWC",
                        "content": "The question is unclear in that what children refer to.\\nIt could me \"immediate children\" or \"all descendants\". It would be very helpful if the question is explicit about this."
                    },
                    {
                        "username": "neil_paul",
                        "content": "Unless stated explicitly, children always means \"immediate children\"."
                    },
                    {
                        "username": "CAFEBABY",
                        "content": "The answer is 8. But I can only see: [2], [4], [16], [4,2,2], [16,4,4]. What are the other three?"
                    },
                    {
                        "username": "manasvegi",
                        "content": "For anyone who may read this eventually, \\nBecause these are trees, the remaining 3 are \\n[16,[4,2,2],4], [16,4,[4,2,2]], and [16,[4,2,2],[4,2,2]]"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "sometimes I realise recursion is a powerful tool"
                    }
                ]
            },
            {
                "id": 1965541,
                "content": [
                    {
                        "username": "theOtherWC",
                        "content": "The question is unclear in that what children refer to.\\nIt could me \"immediate children\" or \"all descendants\". It would be very helpful if the question is explicit about this."
                    },
                    {
                        "username": "neil_paul",
                        "content": "Unless stated explicitly, children always means \"immediate children\"."
                    },
                    {
                        "username": "CAFEBABY",
                        "content": "The answer is 8. But I can only see: [2], [4], [16], [4,2,2], [16,4,4]. What are the other three?"
                    },
                    {
                        "username": "manasvegi",
                        "content": "For anyone who may read this eventually, \\nBecause these are trees, the remaining 3 are \\n[16,[4,2,2],4], [16,4,[4,2,2]], and [16,[4,2,2],[4,2,2]]"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "sometimes I realise recursion is a powerful tool"
                    }
                ]
            }
        ]
    }
]