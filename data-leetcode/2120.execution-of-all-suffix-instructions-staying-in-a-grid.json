[
    {
        "title": "Execution of All Suffix Instructions Staying in a Grid",
        "question_content": "There is an n x n grid, with the top-left cell at (0, 0) and the bottom-right cell at (n - 1, n - 1). You are given the integer n and an integer array startPos where startPos = [startrow, startcol] indicates that a robot is initially at cell (startrow, startcol).\nYou are also given a 0-indexed string s of length m where s[i] is the ith instruction for the robot: 'L' (move left), 'R' (move right), 'U' (move up), and 'D' (move down).\nThe robot can begin executing from any ith instruction in s. It executes the instructions one by one towards the end of s but it stops if either of these conditions is met:\n\n\tThe next instruction will move the robot off the grid.\n\tThere are no more instructions left to execute.\n\nReturn an array answer of length m where answer[i] is the number of instructions the robot can execute if the robot begins executing from the ith instruction in s.\n&nbsp;\nExample 1:\n\nInput: n = 3, startPos = [0,1], s = \"RRDDLU\"\nOutput: [1,5,4,3,1,0]\nExplanation: Starting from startPos and beginning execution from the ith instruction:\n- 0th: \"RRDDLU\". Only one instruction \"R\" can be executed before it moves off the grid.\n- 1st:  \"RDDLU\". All five instructions can be executed while it stays in the grid and ends at (1, 1).\n- 2nd:   \"DDLU\". All four instructions can be executed while it stays in the grid and ends at (1, 0).\n- 3rd:    \"DLU\". All three instructions can be executed while it stays in the grid and ends at (0, 0).\n- 4th:     \"LU\". Only one instruction \"L\" can be executed before it moves off the grid.\n- 5th:      \"U\". If moving up, it would move off the grid.\n\nExample 2:\n\nInput: n = 2, startPos = [1,1], s = \"LURD\"\nOutput: [4,1,0,0]\nExplanation:\n- 0th: \"LURD\".\n- 1st:  \"URD\".\n- 2nd:   \"RD\".\n- 3rd:    \"D\".\n\nExample 3:\n\nInput: n = 1, startPos = [0,0], s = \"LRUD\"\nOutput: [0,0,0,0]\nExplanation: No matter which instruction the robot begins execution from, it would move off the grid.\n\n&nbsp;\nConstraints:\n\n\tm == s.length\n\t1 <= n, m <= 500\n\tstartPos.length == 2\n\t0 <= startrow, startcol < n\n\ts consists of 'L', 'R', 'U', and 'D'.",
        "solutions": [
            {
                "id": 1647617,
                "title": "python-o-m-solution-with-detailed-explanation",
                "content": "m is the length of command. \\nIf we want O(m^2) solution, that is quite stright forward,  and interviewer may not be satisfied.  Thus,  we need to do more.\\n\\nFirst let us think,  how do we know when will the robot move out of the boundary if the robot start at current step?\\nWe know the start position of robot,   say,  (x,y) means row x and col y , this is quite different than Cartesian coordinate, please get used to it.\\nIf the robot move out of boundary,  one of the four situation must happen:\\n1,  it move up for x+1 steps\\n2,  it move down for n-x steps\\n3,  it move left for y+1 steps\\n4,  it move right for n-y steps\\n\\nThen,  let us trace back from last command to first command\\nWe assume that the if the robot operate all the commands to the end (whenever it starts),  the final position is (0,0),  notice that this is virtual position,  not real,  just for easy understanding. \\n\\nSuppose we have the command \"LURD\",  at time t=4,  the location will be (0,0)\\nIf the robot start at t=3,  and the command will be \"D\",   what is the initial virtual position? \\n(-1,0).  In other words,  at time t=3,  the position will be (-1,0)\\nIf the robot start at t=2,  and the command will be \"RD\",  what is the initial virtual position?   (-1,-1).   At time t=2,  the position will be (-1,-1)\\n.....\\nWe can find each  virtual position at time t when the final position without bound is (0,0),  we keep track of each initial vertical   and horizontal position  and record them in separate dictionary.  \\nThen we can judge if we can walk until the end?\\nPreviouly,  I declare,  in the future, if the robot walk up (x+1) steps, down (n-x) steps,  left (y+1) steps,  right (n-y) steps,  it will stop.\\nIn other words,  suppose (row,col) is the position at time t,   if  row-(x+1),  row+(n-x) appears in the horizonal dictionary,   or col-(y+1),  col+(n-y) appears in vertical dictionary,  it will stop at that time.   If multiple answer exists,  find the most recent time since it happens first, and the answer will be difference between most recent dictionary time and current time.\\nIf there is no stop time, congratulations,  it will walk till final.\\nThis is a one-pass solution,  with time complexity O(m),   no matter how big n is. Time is 109ms,  beat 100% currently.  \\n\\n```\\nclass Solution(object):\\n    def executeInstructions(self, n, startPos, s):\\n        \"\"\"\\n        :type n: int\\n        :type startPos: List[int]\\n        :type s: str\\n        :rtype: List[int]\\n        \"\"\"\\n        m = len(s)\\n        direc = {\\'U\\':[-1,0],\\'D\\':[1,0],\\'L\\':[0,-1],\\'R\\':[0,1]}\\n        upmost = startPos[0] + 1\\n        downmost = n - startPos[0]\\n        leftmost = startPos[1] + 1\\n        rightmost = n - startPos[1]\\n        curr_row,curr_col = 0,0    \\n        next_row,next_col = {0:m}, {0:m}\\n        ans = []\\n        \\n        for i in range(m-1,-1,-1):\\n            curr_row -= direc[s[i]][0]\\n            curr_col -= direc[s[i]][1]\\n            maxstep = m-i\\n            if curr_row - upmost in next_row:  \\n                maxstep = min(maxstep,  next_row[curr_row - upmost] - i - 1 )\\n            if curr_row + downmost in next_row:  \\n                maxstep = min(maxstep,  next_row[curr_row + downmost] - i - 1 )\\n            if curr_col - leftmost in next_col:  \\n                maxstep = min(maxstep,  next_col[curr_col - leftmost] - i - 1 )\\n            if curr_col + rightmost in next_col: \\n                maxstep = min(maxstep,  next_col[curr_col + rightmost] - i - 1 )\\n            next_row[curr_row] = i\\n            next_col[curr_col] = i\\n            ans.append(maxstep)\\n            \\n        return ans[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def executeInstructions(self, n, startPos, s):\\n        \"\"\"\\n        :type n: int\\n        :type startPos: List[int]\\n        :type s: str\\n        :rtype: List[int]\\n        \"\"\"\\n        m = len(s)\\n        direc = {\\'U\\':[-1,0],\\'D\\':[1,0],\\'L\\':[0,-1],\\'R\\':[0,1]}\\n        upmost = startPos[0] + 1\\n        downmost = n - startPos[0]\\n        leftmost = startPos[1] + 1\\n        rightmost = n - startPos[1]\\n        curr_row,curr_col = 0,0    \\n        next_row,next_col = {0:m}, {0:m}\\n        ans = []\\n        \\n        for i in range(m-1,-1,-1):\\n            curr_row -= direc[s[i]][0]\\n            curr_col -= direc[s[i]][1]\\n            maxstep = m-i\\n            if curr_row - upmost in next_row:  \\n                maxstep = min(maxstep,  next_row[curr_row - upmost] - i - 1 )\\n            if curr_row + downmost in next_row:  \\n                maxstep = min(maxstep,  next_row[curr_row + downmost] - i - 1 )\\n            if curr_col - leftmost in next_col:  \\n                maxstep = min(maxstep,  next_col[curr_col - leftmost] - i - 1 )\\n            if curr_col + rightmost in next_col: \\n                maxstep = min(maxstep,  next_col[curr_col + rightmost] - i - 1 )\\n            next_row[curr_row] = i\\n            next_col[curr_col] = i\\n            ans.append(maxstep)\\n            \\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647526,
                "title": "o-m-g-vs-brute-force",
                "content": "Because `m` is limited to 1000, a brute-force solution (see approach 2) would work.\\n\\nHowever, the O(n) solution is like OMG - as short as brute-force but very hard to comprehend (I am still trying). The C++ runtime for these solutions is 0ms vs. 28ms. \\n\\n#### Approach 1: O(n)\\nHere we use arrays instead of hashmap - for two reasons (besides the obvious performance boost). It simplifies the calculations - so it\\'s easier to follow the logic. And also, it helps visualize what\\'s going on, step-by-step.\\n\\nMy first question was whether an O(n) solution is even possible. I think it is possible because the robot can only move one step at a time. Therefore, we can always catch it on the border. If the robot could jump over multiple steps, the best we could do is a linearithmic solution. \\n\\n**C++**\\n```cpp\\nvector<int> executeInstructions(int n, vector<int>& st, string s) {\\n    int m = s.size(), h = m + n, v = m + n;\\n    vector<int> hor((m + n) * 2, m), ver((m + n) * 2, m), res(m);\\n    for (int i = m - 1; i >= 0; --i) {\\n        hor[h] = ver[v] = i;\\n        h += s[i] == \\'L\\' ? 1 : s[i] == \\'R\\' ? -1 : 0;\\n        v += s[i] == \\'U\\' ? 1 : s[i] == \\'D\\' ? -1 : 0;\\n        res[i] = min({m, hor[h - st[1] - 1], hor[h - st[1] + n], ver[v - st[0] - 1], ver[v - st[0] + n]}) - i;\\n    }\\n    return res;\\n}    \\n```\\n\\nI am still trying to comprehend why it works, and I drew the illustration below to help debugging the `[0,1] \"RRDDLU\"` test case. We go backward starting from the \"center\" cell, and sort of track our limits in `hor` and `ver`. If the robot boundaries (blue arrows) overlap with the limits, it means that the robot will go off the grid at the step recorded in that limit.\\n\\n![image](https://assets.leetcode.com/users/images/c2dd23fe-e5e7-4f5f-ba82-93a2ca7b11a7_1640562125.7951396.png)\\n\\n#### Approach 2: Brute-Force\\nThe complexity is O(m ^ 2), where `m` is the size of the path.\\n\\n**C++**\\n```cpp\\nvector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n    vector<int> res;\\n    for (int k = 0, i = 0; k < s.size(); ++k) {\\n        int h = startPos[1], v = startPos[0];\\n        for (i = k; i < s.size() && min(h, v) >= 0 && max(h, v) < n; ++i) {\\n            h += s[i] == \\'L\\' ? -1 : s[i] == \\'R\\' ? 1 : 0;\\n            v += s[i] == \\'U\\' ? -1 : s[i] == \\'D\\' ? 1 : 0;\\n        }\\n        res.push_back(i - k - 1 + (min(h, v) >= 0 && max(h, v) < n));\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> executeInstructions(int n, vector<int>& st, string s) {\\n    int m = s.size(), h = m + n, v = m + n;\\n    vector<int> hor((m + n) * 2, m), ver((m + n) * 2, m), res(m);\\n    for (int i = m - 1; i >= 0; --i) {\\n        hor[h] = ver[v] = i;\\n        h += s[i] == \\'L\\' ? 1 : s[i] == \\'R\\' ? -1 : 0;\\n        v += s[i] == \\'U\\' ? 1 : s[i] == \\'D\\' ? -1 : 0;\\n        res[i] = min({m, hor[h - st[1] - 1], hor[h - st[1] + n], ver[v - st[0] - 1], ver[v - st[0] + n]}) - i;\\n    }\\n    return res;\\n}    \\n```\n```cpp\\nvector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n    vector<int> res;\\n    for (int k = 0, i = 0; k < s.size(); ++k) {\\n        int h = startPos[1], v = startPos[0];\\n        for (i = k; i < s.size() && min(h, v) >= 0 && max(h, v) < n; ++i) {\\n            h += s[i] == \\'L\\' ? -1 : s[i] == \\'R\\' ? 1 : 0;\\n            v += s[i] == \\'U\\' ? -1 : s[i] == \\'D\\' ? 1 : 0;\\n        }\\n        res.push_back(i - k - 1 + (min(h, v) >= 0 && max(h, v) < n));\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1647654,
                "title": "python-back-tracking-o-m-solution",
                "content": "\\n# **Solution 1: Brute force**\\nHelper fucntion `test(i)` to check the the number of instructions the robot can execute,\\nif the robot begins executing from the `i`th instruction in s.\\n\\nTime `O(m^2)`\\nSpace `O(1)`\\n\\n**Python**\\n```py\\n    def executeInstructions(self, n, start, s):\\n        na = len(s)\\n        def test(i):\\n            res = 0\\n            x,y = start\\n            for j in xrange(i, na):\\n                o = s[j]\\n                if o == \\'L\\': y -= 1\\n                if o == \\'R\\': y += 1\\n                if o == \\'U\\': x -= 1\\n                if o == \\'D\\': x += 1\\n                if not (0 <= x < n and 0 <= y < n):\\n                    return j - i\\n            return na - i\\n        return map(test, range(na))\\n```\\n<br>\\n\\n# **Solution 2: Multiplication**\\nShared by @OOTTF:\\nFor every start point `i`,\\nrecord the position after 2^k steps,\\nand extrene position in the 4 directions.\\n\\nTime `O(mlogm)`\\nSpace `O(mlogm)`\\n<br>\\n\\n# **Solution 3: O(m) solution**\\nStarting from the first order,\\nfind the difference on x-axis and y-axis\\n\\n`count` reocrd the postion with start index.\\nFor example,\\n`count[x0, None].add(0)`, means that at index `0`, we are at x-axis `x0`.\\n`count[None, y0].add(0)`, means that at index `0`, we are at x-axis `y0`.\\n\\nThe tricky and the difficult point for this solution is that,\\nstarting at `(x0,y0)` and excute from `s[i]`,\\nis same as\\nstarting at `(x0 - x, y0 - y)` and excute from `s[0]`.\\nThis process has a sense of backtracking.\\n\\nNow at step `s[i]` we have delta `(x, y)`,\\nif `x > 0`, we have moved down, and making points starting as x-axis `n-x` off the grid.\\nif `y > 0`, we have moved down, and making points starting as x-axis `n-y` off the grid.\\nif `x < 0`, we have moved down, and making points starting as x-axis `-x-1` off the grid.\\nif `y < 0`, we have moved down, and making points starting as x-axis `-y-1` off the grid.\\n\\nAt the end of each step, we clean all starting point already off the grid.\\nThe ensures the whole solution is `O(m)`, where we add only once and clean only once.\\n\\nTime `O(m)`\\nSpace `O(m)`\\n<br>\\n\\n\\n**Python**\\n```py\\n    def executeInstructions(self, n, start, s):\\n        ns = len(s)\\n        (x0, y0), (x, y) = start, (0, 0)\\n        res = range(ns, 0, -1)\\n        count = collections.defaultdict(set)\\n        count[x0, None].add(0)\\n        count[None, y0].add(0)\\n        for i in xrange(ns):\\n            if s[i] == \\'L\\': y -= 1\\n            if s[i] == \\'R\\': y += 1\\n            if s[i] == \\'U\\': x -= 1\\n            if s[i] == \\'D\\': x += 1\\n            count[x0 - x, None].add(i + 1)\\n            count[None, y0 - y].add(i + 1)\\n            for key in [(n-x, None), (None, n-y), (-x-1, None), (None, -y-1)]:\\n                for j in count[key]:\\n                    if res[j] > i - j:\\n                        res[j] = i - j\\n                count[key] = set()\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n    def executeInstructions(self, n, start, s):\\n        na = len(s)\\n        def test(i):\\n            res = 0\\n            x,y = start\\n            for j in xrange(i, na):\\n                o = s[j]\\n                if o == \\'L\\': y -= 1\\n                if o == \\'R\\': y += 1\\n                if o == \\'U\\': x -= 1\\n                if o == \\'D\\': x += 1\\n                if not (0 <= x < n and 0 <= y < n):\\n                    return j - i\\n            return na - i\\n        return map(test, range(na))\\n```\n```py\\n    def executeInstructions(self, n, start, s):\\n        ns = len(s)\\n        (x0, y0), (x, y) = start, (0, 0)\\n        res = range(ns, 0, -1)\\n        count = collections.defaultdict(set)\\n        count[x0, None].add(0)\\n        count[None, y0].add(0)\\n        for i in xrange(ns):\\n            if s[i] == \\'L\\': y -= 1\\n            if s[i] == \\'R\\': y += 1\\n            if s[i] == \\'U\\': x -= 1\\n            if s[i] == \\'D\\': x += 1\\n            count[x0 - x, None].add(i + 1)\\n            count[None, y0 - y].add(i + 1)\\n            for key in [(n-x, None), (None, n-y), (-x-1, None), (None, -y-1)]:\\n                for j in count[key]:\\n                    if res[j] > i - j:\\n                        res[j] = i - j\\n                count[key] = set()\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1647467,
                "title": "c-with-comments-easy-to-understand",
                "content": "Just do whatever is asked.\\nFollow the instructions starting from the 0th index.\\n**Time Complexity:**-O(m^2)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& start, string s) {\\n        int size=s.size();\\n        vector<int>ans(size,0);\\n\\t\\t// for finding answer iterate over all points one by one\\n        for(int i=0;i<size;i++)\\n           ans[i]= findSteps(n,s,start[0],start[1],i);\\n        return ans; \\n    }\\n\\t// check how many steps you can go\\n    int findSteps(int &n,string &s,int row,int col,int pos){\\n       int ans=0;\\n        for(int i=pos;i<s.size();i++){\\n            if(s[i]==\\'L\\')\\n                col--;\\n            else if(s[i]==\\'R\\')\\n                col++;\\n            else if(s[i]==\\'U\\')\\n                row--;\\n            else\\n                row++;\\n\\t\\t\\t\\t// if it is true then this move is invalid,return ans\\n            if(row<0 || col<0 || row>=n || col>=n)\\n                return ans;\\n\\t\\t\\t\\t// else go to next move.\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& start, string s) {\\n        int size=s.size();\\n        vector<int>ans(size,0);\\n\\t\\t// for finding answer iterate over all points one by one\\n        for(int i=0;i<size;i++)\\n           ans[i]= findSteps(n,s,start[0],start[1],i);\\n        return ans; \\n    }\\n\\t// check how many steps you can go\\n    int findSteps(int &n,string &s,int row,int col,int pos){\\n       int ans=0;\\n        for(int i=pos;i<s.size();i++){\\n            if(s[i]==\\'L\\')\\n                col--;\\n            else if(s[i]==\\'R\\')\\n                col++;\\n            else if(s[i]==\\'U\\')\\n                row--;\\n            else\\n                row++;\\n\\t\\t\\t\\t// if it is true then this move is invalid,return ans\\n            if(row<0 || col<0 || row>=n || col>=n)\\n                return ans;\\n\\t\\t\\t\\t// else go to next move.\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647461,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    int fun(int n,int ind,int pos[],char arr[])\\n    {\\n        if(ind==arr.length)\\n            return 0;\\n        if(arr[ind]==\\'R\\'&&pos[1]+1<n)\\n            return 1+fun(n,ind+1,new int[]{pos[0],pos[1]+1},arr);\\n        else if(arr[ind]==\\'L\\'&&pos[1]-1>=0)\\n            return 1+fun(n,ind+1,new int[]{pos[0],pos[1]-1},arr);\\n        else if(arr[ind]==\\'U\\'&&pos[0]-1>=0)\\n            return 1+fun(n,ind+1,new int[]{pos[0]-1,pos[1]},arr);\\n        else if(arr[ind]==\\'D\\'&&pos[0]+1<n)\\n            return 1+fun(n,ind+1,new int[]{pos[0]+1,pos[1]},arr);\\n        else\\n            return 0;\\n    }\\n    public int[] executeInstructions(int n, int[] pos, String s) {\\n        \\n        int i,j,len=s.length();\\n        int ans[]=new int[len];\\n        for(i=0;i<len;i++)\\n            ans[i]=fun(n,0,pos,s.substring(i,len).toCharArray());\\n        return ans;\\n    }\\n}\\n````\\n\\nIf you guys get it then please upvote it:))",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int fun(int n,int ind,int pos[],char arr[])\\n    {\\n        if(ind==arr.length)\\n            return 0;\\n        if(arr[ind]==\\'R\\'&&pos[1]+1<n)\\n            return 1+fun(n,ind+1,new int[]{pos[0],pos[1]+1},arr);\\n        else if(arr[ind]==\\'L\\'&&pos[1]-1>=0)\\n            return 1+fun(n,ind+1,new int[]{pos[0],pos[1]-1},arr);\\n        else if(arr[ind]==\\'U\\'&&pos[0]-1>=0)\\n            return 1+fun(n,ind+1,new int[]{pos[0]-1,pos[1]},arr);\\n        else if(arr[ind]==\\'D\\'&&pos[0]+1<n)\\n            return 1+fun(n,ind+1,new int[]{pos[0]+1,pos[1]},arr);\\n        else\\n            return 0;\\n    }\\n    public int[] executeInstructions(int n, int[] pos, String s) {\\n        \\n        int i,j,len=s.length();\\n        int ans[]=new int[len];\\n        for(i=0;i<len;i++)\\n            ans[i]=fun(n,0,pos,s.substring(i,len).toCharArray());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458199,
                "title": "o-m-solution-using-prefix-sum-and-hashmap",
                "content": "First, consider a 1D version of the problem, where we can only have L/R motion. So we have a list of cells from 0 to n-1 where we start from cell p.\\n\\nThe main observation is that the moment we go out of the grid is when we \"reach\" cell -1 or cell n. So if we can efficiently find for each starting point the number of moves to reach one of these two cells, we are done.\\n\\nWe do this by taking the prefix sum of the array. Treat L in the string as -1 and R as +1, and take the prefix sum, call it S. Then if we start at cell p and evaluate the commands from i to j, we will end at position p + S[j] - S[i-1].\\n\\nThis means that for each i, we want to answer the following question efficiently: Find the smallest j\\u2265i (if it exists) such that p + S[j] - S[i-1] is n or -1\\n\\nWe can do this by scanning from right to left and storing positions in a hashmap. Essentially:\\n\\n* Loop from i = m-1 to 0\\n   * Set hashmap[S[i]] = i\\n   * Initialise answer[i] to m-i\\n   * for b = n and -1:\\n     * If b-p+S[i-1] exists in the hashmap, set answer[i] = min(answer[i], hashmap[b-p+S[i-1]] - i)\\n\\nModifying this code for dealing with both x and y coordinates is not too difficult. Here is my C++ code that got accepted.\\n\\n```\\nvector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n  int m = s.size(), p1s = startPos[0], p2s = startPos[1];\\n  vector<int> p1vec(m + 1), p2vec(m + 1);\\n  for (int i = 0, curp1 = 0, curp2 = 0; i < m; ++i) {\\n    if (s[i] == \\'L\\')\\n      --curp2;\\n    else if (s[i] == \\'R\\')\\n      ++curp2;\\n    else if (s[i] == \\'U\\')\\n      --curp1;\\n    else\\n      ++curp1;\\n    p1vec[i + 1] = curp1;\\n    p2vec[i + 1] = curp2;\\n  }\\n\\n  unordered_map<int, int> p1seen, p2seen;\\n  vector<int> ret(m);\\n  for (int i = m - 1; i >= 0; --i) {\\n    int& cur = ret[i];\\n    cur = m - i;\\n\\n    p1seen[p1vec[i + 1]] = i;\\n    p2seen[p2vec[i + 1]] = i;\\n\\n    if (p1seen.count(n - p1s + p1vec[i]))\\n      cur = min(cur, p1seen[n - p1s + p1vec[i]] - i);\\n    if (p1seen.count(-1 - p1s + p1vec[i]))\\n      cur = min(cur, p1seen[-1 - p1s + p1vec[i]] - i);\\n    if (p2seen.count(n - p2s + p2vec[i]))\\n      cur = min(cur, p2seen[n - p2s + p2vec[i]] - i);\\n    if (p2seen.count(-1 - p2s + p2vec[i]))\\n      cur = min(cur, p2seen[-1 - p2s + p2vec[i]] - i);\\n  }\\n\\n  return ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nvector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n  int m = s.size(), p1s = startPos[0], p2s = startPos[1];\\n  vector<int> p1vec(m + 1), p2vec(m + 1);\\n  for (int i = 0, curp1 = 0, curp2 = 0; i < m; ++i) {\\n    if (s[i] == \\'L\\')\\n      --curp2;\\n    else if (s[i] == \\'R\\')\\n      ++curp2;\\n    else if (s[i] == \\'U\\')\\n      --curp1;\\n    else\\n      ++curp1;\\n    p1vec[i + 1] = curp1;\\n    p2vec[i + 1] = curp2;\\n  }\\n\\n  unordered_map<int, int> p1seen, p2seen;\\n  vector<int> ret(m);\\n  for (int i = m - 1; i >= 0; --i) {\\n    int& cur = ret[i];\\n    cur = m - i;\\n\\n    p1seen[p1vec[i + 1]] = i;\\n    p2seen[p2vec[i + 1]] = i;\\n\\n    if (p1seen.count(n - p1s + p1vec[i]))\\n      cur = min(cur, p1seen[n - p1s + p1vec[i]] - i);\\n    if (p1seen.count(-1 - p1s + p1vec[i]))\\n      cur = min(cur, p1seen[-1 - p1s + p1vec[i]] - i);\\n    if (p2seen.count(n - p2s + p2vec[i]))\\n      cur = min(cur, p2seen[n - p2s + p2vec[i]] - i);\\n    if (p2seen.count(-1 - p2s + p2vec[i]))\\n      cur = min(cur, p2seen[-1 - p2s + p2vec[i]] - i);\\n  }\\n\\n  return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1647525,
                "title": "c-iterative-bfs-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(int row,int col,int n){\\n        return (row >= 0 && row < n && col >= 0 && col < n);\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int len = s.length();\\n        vector<int> ans;\\n        int row = startPos[0];\\n        int col = startPos[1];\\n        int currRow = row;\\n        int currCol = col;\\n        \\n        for(int i=0; i<len; i++){\\n            currRow = row;\\n            currCol = col;\\n            int currAns = 0;\\n            for(int j=i; j<len; j++){\\n                \\n                if(s[j] == \\'R\\') currCol++;\\n                else if(s[j] == \\'L\\') currCol--;\\n                else if(s[j] == \\'U\\') currRow--;\\n                else currRow++;\\n                \\n                if(isValid(currRow,currCol,n))\\n                    currAns++;\\n                else\\n                    break;\\n            }\\n            ans.push_back(currAns);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int row,int col,int n){\\n        return (row >= 0 && row < n && col >= 0 && col < n);\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int len = s.length();\\n        vector<int> ans;\\n        int row = startPos[0];\\n        int col = startPos[1];\\n        int currRow = row;\\n        int currCol = col;\\n        \\n        for(int i=0; i<len; i++){\\n            currRow = row;\\n            currCol = col;\\n            int currAns = 0;\\n            for(int j=i; j<len; j++){\\n                \\n                if(s[j] == \\'R\\') currCol++;\\n                else if(s[j] == \\'L\\') currCol--;\\n                else if(s[j] == \\'U\\') currRow--;\\n                else currRow++;\\n                \\n                if(isValid(currRow,currCol,n))\\n                    currAns++;\\n                else\\n                    break;\\n            }\\n            ans.push_back(currAns);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950816,
                "title": "o-m-solution-explained-clearly-c",
                "content": "\\n**Pls upvote(\\uD83E\\uDD7A\\uD83D\\uDE48\\uD83D\\uDE0C). If you found it useful,\\nplease comment for any doubts, will be happy to reply**\\n\\nI didnt come up with the solution, i checked out the solution of @hxu10 and first i was perplexed, confused and honestly frustrated at myself for not understanding the solution, after putting 1-2 hours and lots of chai :0 in to reading his code, i got what he was doing and i was amazed. Here the approach is explained clearly in the comments. Take a look and feel free to ask questions :) \\n\\nSo basically the core ideas is, we can move the grid anywhere in to the co-ordinate system and do the problem, we need to only check if the bounds(right,left,up,down) are violated, this core idea helps us to do the journey in reverse and do it in O(m). to do this we store the indexes of our journey with respective co-ordinates in reverse and at each step we check if by taking the current direction(L or R or U or D), did any of our previous co-ordinates in the reverse path violate the bounds we set.\\n\\nWe do the journey in reverse because that way we dont need to recalculate for every new index which we do while we do the journey straight(See brute force solutions) if we do L<-U<-R<-D , then by the time we reach L, we already took all the directions in the journey, \\n \\n so if say in L<-U<-R<-D path Lcol - leftviolation == Rcol(means Lcol-Rcol = leftviolation), then LU is the only valid \\n directions, because the direction R crossed the grid(the bounds we set) and it doesnt matter where D    \\ntakes us as R crossed the grid already while we are doing L->U->R->D (but we do this in reverse)\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string path) {\\n        \\n        unordered_map<char,pair<int,int>> dir = {{\\'L\\',{0,-1}},{\\'R\\',{0,1}},{\\'U\\',{-1,0}},{\\'D\\',{1,0}}};\\n        int m = path.length();\\n         // If ever these limits below are broken that means the robot is out of the grid\\n        // only these bounds matter as virtually you can move the n x n grid throughout the coordinate system\\n\\t\\t// and place it anywhere and do the problem.\\n        //basically if current_row_path_index - anypreviousrow_path_index >= up_violation\\n        //That means from the current_row_path_index to prev_row_path_index-1, where prev_row_path_index means\\n\\t\\t//index in the path where this  bound is exactly violated is the answer( current_row_path_index - anypreviousrow_path_index == up_violation)\\n\\t\\t//hence we need to store the indexes of our journey in the map.\\n\\t\\t//Here only one violation is explained(up_violation), we have to take minimum of all violations.\\n        int up_violation = startPos[0]+1; // U can only take startPos[1] net Up directions, startPos[1]+1 net Up\\'s means you are out of the grid.\\n        int btm_violation = n - startPos[0];\\n        int lft_violation = startPos[1]+1;\\n        int rt_violation = n - startPos[1];\\n        //can be any co-ordinate as it was said before only bounds matter, try chaninging the values, u should get an OC :),\\n\\t\\t//make sure you change the initializations in map down below also\\n        //These are initializations only, but these keep track of our co-ordinates in the path\\n\\t\\t //remember these are our final coordinates after doing any journey i.e., suppose path = \"LUURRD\",\\n\\t\\t//these initial values(3,2) are our final coordinates for every path we take, like\\n        //D, RD, RRD, URRD, etc....as we are doing this in reverse\\n        int curr_row = 3, curr_col = 2;\\n        //maps to store the position of directions for each co-ordinate in our path.\\n        unordered_map<int,int> row_pathIdx;\\n        unordered_map<int,int> col_pathIdx;\\n        \\n       \\n        row_pathIdx[3] = m;\\n        col_pathIdx[2] = m;\\n        vector<int> ans;\\n        for(int i = m-1; i>= 0; i--){\\n            //here - sign helps us invert our directions, i.e, D become U, L becomes R and vice verse, because we are doing reverse(i.e, back tracking)\\n            curr_row-=dir[path[i]].first;\\n            curr_col-=dir[path[i]].second;\\n            int min_valid_path_length = m - i;\\n            //Checking for violations of bounds;\\n\\t\\t\\t//We are not using else if\\'s bcz any bound can be violated and we get the minimum path length out of all bounds violated\\n            if(row_pathIdx.count(curr_row-up_violation)){\\n                // This part sets the valid length to 2 if in LURD, the current one is L and violation is found at R\\n                min_valid_path_length = min(valid_path_length , row_pathIdx[curr_row-up_violation] - i - 1)\\n            }\\n            if(row_pathIdx.count(curr_row+btm_violation)){\\n                min_valid_path_length = min(valid_path_length , row_pathIdx[curr_row+btm_violation] - i - 1);\\n                \\n            }\\n            if(col_pathIdx.count(curr_col-lft_violation)){\\n                min_valid_path_length = min(valid_path_length , col_pathIdx[curr_col-lft_violation] - i - 1);\\n                \\n            }\\n            if(col_pathIdx.count(curr_col+rt_violation)){\\n                min_valid_path_length = min(valid_path_length , col_pathIdx[curr_col+rt_violation] - i - 1);\\n            }\\n            \\n            ans.push_back(min_valid_path_length);\\n            //mapping path_idx to co-ordinates\\n            row_pathIdx[curr_row] = i;\\n            col_pathIdx[curr_col] = i;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string path) {\\n        \\n        unordered_map<char,pair<int,int>> dir = {{\\'L\\',{0,-1}},{\\'R\\',{0,1}},{\\'U\\',{-1,0}},{\\'D\\',{1,0}}};\\n        int m = path.length();\\n         // If ever these limits below are broken that means the robot is out of the grid\\n        // only these bounds matter as virtually you can move the n x n grid throughout the coordinate system\\n\\t\\t// and place it anywhere and do the problem.\\n        //basically if current_row_path_index - anypreviousrow_path_index >= up_violation\\n        //That means from the current_row_path_index to prev_row_path_index-1, where prev_row_path_index means\\n\\t\\t//index in the path where this  bound is exactly violated is the answer( current_row_path_index - anypreviousrow_path_index == up_violation)\\n\\t\\t//hence we need to store the indexes of our journey in the map.\\n\\t\\t//Here only one violation is explained(up_violation), we have to take minimum of all violations.\\n        int up_violation = startPos[0]+1; // U can only take startPos[1] net Up directions, startPos[1]+1 net Up\\'s means you are out of the grid.\\n        int btm_violation = n - startPos[0];\\n        int lft_violation = startPos[1]+1;\\n        int rt_violation = n - startPos[1];\\n        //can be any co-ordinate as it was said before only bounds matter, try chaninging the values, u should get an OC :),\\n\\t\\t//make sure you change the initializations in map down below also\\n        //These are initializations only, but these keep track of our co-ordinates in the path\\n\\t\\t //remember these are our final coordinates after doing any journey i.e., suppose path = \"LUURRD\",\\n\\t\\t//these initial values(3,2) are our final coordinates for every path we take, like\\n        //D, RD, RRD, URRD, etc....as we are doing this in reverse\\n        int curr_row = 3, curr_col = 2;\\n        //maps to store the position of directions for each co-ordinate in our path.\\n        unordered_map<int,int> row_pathIdx;\\n        unordered_map<int,int> col_pathIdx;\\n        \\n       \\n        row_pathIdx[3] = m;\\n        col_pathIdx[2] = m;\\n        vector<int> ans;\\n        for(int i = m-1; i>= 0; i--){\\n            //here - sign helps us invert our directions, i.e, D become U, L becomes R and vice verse, because we are doing reverse(i.e, back tracking)\\n            curr_row-=dir[path[i]].first;\\n            curr_col-=dir[path[i]].second;\\n            int min_valid_path_length = m - i;\\n            //Checking for violations of bounds;\\n\\t\\t\\t//We are not using else if\\'s bcz any bound can be violated and we get the minimum path length out of all bounds violated\\n            if(row_pathIdx.count(curr_row-up_violation)){\\n                // This part sets the valid length to 2 if in LURD, the current one is L and violation is found at R\\n                min_valid_path_length = min(valid_path_length , row_pathIdx[curr_row-up_violation] - i - 1)\\n            }\\n            if(row_pathIdx.count(curr_row+btm_violation)){\\n                min_valid_path_length = min(valid_path_length , row_pathIdx[curr_row+btm_violation] - i - 1);\\n                \\n            }\\n            if(col_pathIdx.count(curr_col-lft_violation)){\\n                min_valid_path_length = min(valid_path_length , col_pathIdx[curr_col-lft_violation] - i - 1);\\n                \\n            }\\n            if(col_pathIdx.count(curr_col+rt_violation)){\\n                min_valid_path_length = min(valid_path_length , col_pathIdx[curr_col+rt_violation] - i - 1);\\n            }\\n            \\n            ans.push_back(min_valid_path_length);\\n            //mapping path_idx to co-ordinates\\n            row_pathIdx[curr_row] = i;\\n            col_pathIdx[curr_col] = i;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652161,
                "title": "detailed-easy-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        //Make array of length equal to string length\\n        int ans[]=new int[s.length()];\\n        \\n        //Now use two for loops \\n        for(int i=0;i<s.length();i++){\\n            //countmoves will keep on counting the valid moves from i to s.length \\n            int countMoves=0;\\n            int yIndex=startPos[0];\\n            int xIndex=startPos[1];\\n            for(int j=i;j<s.length();j++){\\n                \\n                if(s.charAt(j)==\\'R\\'){\\n                    xIndex++;\\n                }\\n                if(s.charAt(j)==\\'L\\'){\\n                       xIndex--; \\n                }\\n               if(s.charAt(j)==\\'U\\'){\\n                        yIndex--;\\n                }\\n                if(s.charAt(j)==\\'D\\'){\\n                    yIndex++;\\n                }\\n                if(xIndex<0 || xIndex>=n || yIndex<0 || yIndex>=n){\\n                    break;\\n                }\\n                else{\\n                    countMoves++;\\n                }\\n            }\\n            \\n            ans[i]=countMoves;\\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        //Make array of length equal to string length\\n        int ans[]=new int[s.length()];\\n        \\n        //Now use two for loops \\n        for(int i=0;i<s.length();i++){\\n            //countmoves will keep on counting the valid moves from i to s.length \\n            int countMoves=0;\\n            int yIndex=startPos[0];\\n            int xIndex=startPos[1];\\n            for(int j=i;j<s.length();j++){\\n                \\n                if(s.charAt(j)==\\'R\\'){\\n                    xIndex++;\\n                }\\n                if(s.charAt(j)==\\'L\\'){\\n                       xIndex--; \\n                }\\n               if(s.charAt(j)==\\'U\\'){\\n                        yIndex--;\\n                }\\n                if(s.charAt(j)==\\'D\\'){\\n                    yIndex++;\\n                }\\n                if(xIndex<0 || xIndex>=n || yIndex<0 || yIndex>=n){\\n                    break;\\n                }\\n                else{\\n                    countMoves++;\\n                }\\n            }\\n            \\n            ans[i]=countMoves;\\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1761343,
                "title": "my-straightforward-n-2-approach-in-java-by-just-simulating-the-given-process",
                "content": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        if (s == null || s.length() == 0) {\\n            return new int []{};\\n        }\\n        int length = s.length();\\n        int [] possibleMove = new int [length];\\n        for (int i = 0; i < length; i++) {\\n            int countOfPossibleMove = 0;\\n            int startingRow = startPos[0];\\n            int startingCol = startPos[1];\\n            for (int j = i; j < length; j++) {\\n                char ch = s.charAt(j);\\n                if (ch == \\'R\\') {\\n                    if (startingCol + 1 >= n) {\\n                        break;\\n                    }\\n                    startingCol += 1;\\n                }\\n                else if (ch == \\'L\\') {\\n                    if (startingCol - 1 < 0) {\\n                        break;\\n                    }\\n                    startingCol -= 1;\\n                }\\n                else if (ch == \\'U\\') {\\n                    if (startingRow - 1 < 0) {\\n                        break;\\n                    }\\n                    startingRow -= 1;\\n                }\\n                else if (ch == \\'D\\') {\\n                    if (startingRow + 1 >= n) {\\n                        break;\\n                    }\\n                    startingRow += 1;\\n                }\\n                countOfPossibleMove += 1;\\n            }\\n            possibleMove[i] = countOfPossibleMove;\\n        }\\n        return possibleMove;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        if (s == null || s.length() == 0) {\\n            return new int []{};\\n        }\\n        int length = s.length();\\n        int [] possibleMove = new int [length];\\n        for (int i = 0; i < length; i++) {\\n            int countOfPossibleMove = 0;\\n            int startingRow = startPos[0];\\n            int startingCol = startPos[1];\\n            for (int j = i; j < length; j++) {\\n                char ch = s.charAt(j);\\n                if (ch == \\'R\\') {\\n                    if (startingCol + 1 >= n) {\\n                        break;\\n                    }\\n                    startingCol += 1;\\n                }\\n                else if (ch == \\'L\\') {\\n                    if (startingCol - 1 < 0) {\\n                        break;\\n                    }\\n                    startingCol -= 1;\\n                }\\n                else if (ch == \\'U\\') {\\n                    if (startingRow - 1 < 0) {\\n                        break;\\n                    }\\n                    startingRow -= 1;\\n                }\\n                else if (ch == \\'D\\') {\\n                    if (startingRow + 1 >= n) {\\n                        break;\\n                    }\\n                    startingRow += 1;\\n                }\\n                countOfPossibleMove += 1;\\n            }\\n            possibleMove[i] = countOfPossibleMove;\\n        }\\n        return possibleMove;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163516,
                "title": "98-faster-brute-force-c-easy-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& v, string s) {\\n        int b = (s.length()),x,y,z,j;\\n        vector<int> ans(b);\\n        for(int i = 0; i < b; i++){\\n            x = v[0],y = v[1],z=0;\\n            for(j = i; j<b; j++){\\n                if(s[j]==\\'L\\'){\\n                    y--;\\n                }else if(s[j]==\\'R\\'){\\n                    y++;\\n                }else if(s[j]==\\'U\\'){\\n                    x--;\\n                }else{\\n                    x++;\\n                }\\n                if(x<0||y<0||x>=n||y>=n)break;\\n                z++;\\n            }\\n            ans[i] = z;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& v, string s) {\\n        int b = (s.length()),x,y,z,j;\\n        vector<int> ans(b);\\n        for(int i = 0; i < b; i++){\\n            x = v[0],y = v[1],z=0;\\n            for(j = i; j<b; j++){\\n                if(s[j]==\\'L\\'){\\n                    y--;\\n                }else if(s[j]==\\'R\\'){\\n                    y++;\\n                }else if(s[j]==\\'U\\'){\\n                    x--;\\n                }else{\\n                    x++;\\n                }\\n                if(x<0||y<0||x>=n||y>=n)break;\\n                z++;\\n            }\\n            ans[i] = z;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838969,
                "title": "python-straight-forward-o-n-2-solution-still-fast-85",
                "content": "# Complexity\\n- Time complexity:\\nO(N ^ 2)\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```python []\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: list[int], s: str) -> list[int]:\\n\\n        def num_of_valid_instructions(s, pos, start, end):\\n            row, colon = pos\\n            k = 0\\n            for i in range(start, end):\\n                cur = s[i]\\n                row += (cur == \\'D\\') - (cur == \\'U\\')\\n                colon += (cur == \\'R\\') - (cur == \\'L\\')\\n                if not (0 <= row < n and 0 <= colon < n):\\n                    return k\\n                k += 1\\n            return k\\n\\n        ans = []\\n        for i in range(len(s)):\\n            ans.append(num_of_valid_instructions(s, startPos, i, len(s)))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Simulation"
                ],
                "code": "```python []\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: list[int], s: str) -> list[int]:\\n\\n        def num_of_valid_instructions(s, pos, start, end):\\n            row, colon = pos\\n            k = 0\\n            for i in range(start, end):\\n                cur = s[i]\\n                row += (cur == \\'D\\') - (cur == \\'U\\')\\n                colon += (cur == \\'R\\') - (cur == \\'L\\')\\n                if not (0 <= row < n and 0 <= colon < n):\\n                    return k\\n                k += 1\\n            return k\\n\\n        ans = []\\n        for i in range(len(s)):\\n            ans.append(num_of_valid_instructions(s, startPos, i, len(s)))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131223,
                "title": "scala-solution",
                "content": "```\\n\\ndef executeInstructions(n: Int, startPos: Array[Int], s: String): Array[Int] = {\\n    def help(i: Int):Int ={\\n      s.substring(i).foldLeft((startPos(0), startPos(1), 0))((acc, cur)=>{\\n        cur match {\\n          case \\'L\\' if acc._2 - 1 >= 0 => (acc._1, acc._2 - 1, acc._3 + 1)\\n          case \\'R\\' if acc._2 + 1 < n  => (acc._1, acc._2 + 1, acc._3 + 1)\\n          case \\'U\\' if acc._1 - 1 >= 0 => (acc._1 - 1, acc._2, acc._3 + 1)\\n          case \\'D\\' if acc._1 + 1 < n  => (acc._1 + 1, acc._2, acc._3 + 1)\\n          case _ => return acc._3\\n        }\\n      })._3\\n    }\\n    (0 until s.length).map(help(_)).toArray\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n\\ndef executeInstructions(n: Int, startPos: Array[Int], s: String): Array[Int] = {\\n    def help(i: Int):Int ={\\n      s.substring(i).foldLeft((startPos(0), startPos(1), 0))((acc, cur)=>{\\n        cur match {\\n          case \\'L\\' if acc._2 - 1 >= 0 => (acc._1, acc._2 - 1, acc._3 + 1)\\n          case \\'R\\' if acc._2 + 1 < n  => (acc._1, acc._2 + 1, acc._3 + 1)\\n          case \\'U\\' if acc._1 - 1 >= 0 => (acc._1 - 1, acc._2, acc._3 + 1)\\n          case \\'D\\' if acc._1 + 1 < n  => (acc._1 + 1, acc._2, acc._3 + 1)\\n          case _ => return acc._3\\n        }\\n      })._3\\n    }\\n    (0 until s.length).map(help(_)).toArray\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1669923,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n   vector<int> executeInstructions(int n, vector<int> &st, string s)\\n{\\n    vector<int> res;\\n    int i1 = st[0], j1 = st[1];\\n    int a=i1,b=j1;\\n    ///  cout<<i1<<\" \"<<j1<<endl;\\n    for (int j = 0; j < s.size(); j++)\\n    {\\n        int c = 0;\\n        for (int i = j; i < s.size(); i++)\\n        {\\n            if (s[i] == \\'U\\')\\n            {\\n                if (i1 - 1 >= 0)\\n                   i1--, c++;\\n                 else\\n                    break;\\n            }\\n            else if (s[i] == \\'R\\')\\n            {\\n                if (j1 + 1 < n)\\n                    j1++,c++;\\n                else\\n                    break;\\n            }\\n            else if (s[i] == \\'D\\')\\n            {\\n                if (i1 + 1 <n)\\n                  i1++, c++;\\n                 else\\n                    break;\\n            }\\n            else if (s[i] == \\'L\\')\\n            {\\n                if (j1 - 1 >= 0)\\n                   j1--, c++;\\n                 else\\n                    break;\\n            }\\n            else\\n                break;\\n        }\\n        res.push_back(c);\\n        i1=a,j1=b;\\n    }\\n    return res;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n   vector<int> executeInstructions(int n, vector<int> &st, string s)\\n{\\n    vector<int> res;\\n    int i1 = st[0], j1 = st[1];\\n    int a=i1,b=j1;\\n    ///  cout<<i1<<\" \"<<j1<<endl;\\n    for (int j = 0; j < s.size(); j++)\\n    {\\n        int c = 0;\\n        for (int i = j; i < s.size(); i++)\\n        {\\n            if (s[i] == \\'U\\')\\n            {\\n                if (i1 - 1 >= 0)\\n                   i1--, c++;\\n                 else\\n                    break;\\n            }\\n            else if (s[i] == \\'R\\')\\n            {\\n                if (j1 + 1 < n)\\n                    j1++,c++;\\n                else\\n                    break;\\n            }\\n            else if (s[i] == \\'D\\')\\n            {\\n                if (i1 + 1 <n)\\n                  i1++, c++;\\n                 else\\n                    break;\\n            }\\n            else if (s[i] == \\'L\\')\\n            {\\n                if (j1 - 1 >= 0)\\n                   j1--, c++;\\n                 else\\n                    break;\\n            }\\n            else\\n                break;\\n        }\\n        res.push_back(c);\\n        i1=a,j1=b;\\n    }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3349530,
                "title": "python3-clean-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        row,col,res=startPos[0],startPos[1],[]\\n        for i in range(len(s)):\\n            startPos[0],startPos[1],arr,count=row,col,s[i:],0\\n            for j in arr:\\n                if j==\"R\":\\n                    if startPos[1]+1==n:break\\n                    else:\\n                        startPos[1]+=1\\n                        count+=1\\n                elif j==\"L\":\\n                    if startPos[1]-1==-1:break\\n                    else:\\n                        startPos[1]-=1\\n                        count+=1\\n                elif j==\"U\":\\n                    if startPos[0]-1==-1:break\\n                    else:\\n                        startPos[0]-=1\\n                        count+=1\\n                elif j==\"D\":\\n                    if startPos[0]+1==n:break\\n                    else:\\n                        startPos[0]+=1\\n                        count+=1\\n            res.append(count)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        row,col,res=startPos[0],startPos[1],[]\\n        for i in range(len(s)):\\n            startPos[0],startPos[1],arr,count=row,col,s[i:],0\\n            for j in arr:\\n                if j==\"R\":\\n                    if startPos[1]+1==n:break\\n                    else:\\n                        startPos[1]+=1\\n                        count+=1\\n                elif j==\"L\":\\n                    if startPos[1]-1==-1:break\\n                    else:\\n                        startPos[1]-=1\\n                        count+=1\\n                elif j==\"U\":\\n                    if startPos[0]-1==-1:break\\n                    else:\\n                        startPos[0]-=1\\n                        count+=1\\n                elif j==\"D\":\\n                    if startPos[0]+1==n:break\\n                    else:\\n                        startPos[0]+=1\\n                        count+=1\\n            res.append(count)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861005,
                "title": "easy-to-understand-js-brute-force-solution",
                "content": "Starting from every index, simulate the Robot\\'s movements. At the end of each move, check if Robot is out of grid. Break out to start new iteration if out of grid else increment the `res` for `ith` index and continue the process\\n```\\nvar executeInstructions = function(n, startPos, s) {\\n    let res = Array(s.length).fill(0)\\n    for(let i = 0; i < s.length; i++){\\n        let [currX, currY] = startPos;\\n        for(let j = i; j < s.length; j++){\\n            switch(s[j]){\\n                case \\'L\\':{\\n                    currY -= 1;\\n                }\\n                    break;\\n                case \\'R\\':{\\n                    currY += 1;\\n                }\\n                    break;\\n                case \\'U\\':{\\n                    currX -= 1;\\n                }\\n                    break;\\n                case \\'D\\':{\\n                    currX += 1;\\n                }\\n                    break;\\n            }\\n            if(currX < 0 || currY < 0 || currX >= n || currY >= n)\\n                break;\\n            res[i] += 1;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Simulation"
                ],
                "code": "```\\nvar executeInstructions = function(n, startPos, s) {\\n    let res = Array(s.length).fill(0)\\n    for(let i = 0; i < s.length; i++){\\n        let [currX, currY] = startPos;\\n        for(let j = i; j < s.length; j++){\\n            switch(s[j]){\\n                case \\'L\\':{\\n                    currY -= 1;\\n                }\\n                    break;\\n                case \\'R\\':{\\n                    currY += 1;\\n                }\\n                    break;\\n                case \\'U\\':{\\n                    currX -= 1;\\n                }\\n                    break;\\n                case \\'D\\':{\\n                    currX += 1;\\n                }\\n                    break;\\n            }\\n            if(currX < 0 || currY < 0 || currX >= n || currY >= n)\\n                break;\\n            res[i] += 1;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2792871,
                "title": "java-solution-intuitive-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        \\n        int []execute = new int [s.length()];\\n\\n        for(int i=0;i<s.length();i++){\\n            int []nextBox = new int []{startPos[0],startPos[1]};\\n            for(int j=i;j<s.length();j++){\\n                nextBox = boxNumber(s.charAt(j),nextBox);\\n                if(nextBox[0]<0|| nextBox[0] == n||nextBox[1]<0||nextBox[1]==n){\\n                    break;\\n                }\\n                execute[i]++;\\n            }\\n        }\\n        return execute;\\n    }\\n    private int []boxNumber(char letter, int []cbox){\\n\\n        if(letter == \\'R\\'){\\n            cbox[1]++;\\n        }\\n        else if (letter == \\'L\\'){\\n            cbox[1]--;\\n        }\\n        else if(letter == \\'U\\'){\\n            cbox[0]--;\\n        }\\n        else{\\n            cbox[0]++;\\n        }\\n        return cbox;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        \\n        int []execute = new int [s.length()];\\n\\n        for(int i=0;i<s.length();i++){\\n            int []nextBox = new int []{startPos[0],startPos[1]};\\n            for(int j=i;j<s.length();j++){\\n                nextBox = boxNumber(s.charAt(j),nextBox);\\n                if(nextBox[0]<0|| nextBox[0] == n||nextBox[1]<0||nextBox[1]==n){\\n                    break;\\n                }\\n                execute[i]++;\\n            }\\n        }\\n        return execute;\\n    }\\n    private int []boxNumber(char letter, int []cbox){\\n\\n        if(letter == \\'R\\'){\\n            cbox[1]++;\\n        }\\n        else if (letter == \\'L\\'){\\n            cbox[1]--;\\n        }\\n        else if(letter == \\'U\\'){\\n            cbox[0]--;\\n        }\\n        else{\\n            cbox[0]++;\\n        }\\n        return cbox;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647478,
                "title": "brute-forces-approach-very-easy-to-understand-100",
                "content": "# Intuition\\nIterate through the each s[i] and check weather it fulfil the condition or not;\\n\\n# Approach\\nBruteforce approach\\n\\n# Complexity\\n- Time complexity:\\nO(s.length*2)\\n\\n- Space complexity: O(s.lenght);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n\\n        vector<int>ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int count = 0;\\n            int row = startPos[0];\\n            int col = startPos[1];\\n            for(int j=i;j<s.size();j++)\\n            {\\n                if(s[j]==\\'L\\') col--;\\n                if(s[j]==\\'R\\') col++;\\n                if(s[j]==\\'D\\') row++;\\n                if(s[j]==\\'U\\') row--;\\n\\n                if(col<0 || row<0 || col>=n || row>=n)\\n                    break;\\n                else\\n                    count++;\\n            }\\n            ans.push_back(count);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n\\n        vector<int>ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int count = 0;\\n            int row = startPos[0];\\n            int col = startPos[1];\\n            for(int j=i;j<s.size();j++)\\n            {\\n                if(s[j]==\\'L\\') col--;\\n                if(s[j]==\\'R\\') col++;\\n                if(s[j]==\\'D\\') row++;\\n                if(s[j]==\\'U\\') row--;\\n\\n                if(col<0 || row<0 || col>=n || row>=n)\\n                    break;\\n                else\\n                    count++;\\n            }\\n            ans.push_back(count);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696798,
                "title": "python-brute-force",
                "content": "```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        d = {\\'U\\':(-1, 0),\\'D\\':(1, 0), \\'R\\':(0, 1), \\'L\\':(0, -1)}\\n        m = len(s)\\n        ans = [0]*m\\n        \\n        def isBounded(start, end):\\n            return (0<= start < n and 0<= end < n)\\n                \\n        for i in range(m):\\n            x, y = startPos\\n            for j in range(i, m):\\n                dx, dy = d[s[j]]\\n                x += dx; y += dy\\n                \\n                if not isBounded(x, y):\\n                    break\\n                ans[i] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        d = {\\'U\\':(-1, 0),\\'D\\':(1, 0), \\'R\\':(0, 1), \\'L\\':(0, -1)}\\n        m = len(s)\\n        ans = [0]*m\\n        \\n        def isBounded(start, end):\\n            return (0<= start < n and 0<= end < n)\\n                \\n        for i in range(m):\\n            x, y = startPos\\n            for j in range(i, m):\\n                dx, dy = d[s[j]]\\n                x += dx; y += dy\\n                \\n                if not isBounded(x, y):\\n                    break\\n                ans[i] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652439,
                "title": "easiest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int x,y,i,j,k,nn=s.length();\\n        vector<int> v;\\n        for(i=0;i<nn;i++){\\n            k=0;\\n            x=startPos[1];\\n            y=startPos[0];\\n            for(j=i;j<nn;j++){\\n                if(s[j]==\\'R\\')\\n                    x++;\\n                if(s[j]==\\'L\\')\\n                    x--;\\n                if(s[j]==\\'U\\')\\n                    y--;\\n                if(s[j]==\\'D\\')\\n                    y++;\\n                \\n                if(x<0 or x>=n or y<0 or y>=n)\\n                    break;\\n                else\\n                    k++;\\n            }\\n            v.push_back(k);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int x,y,i,j,k,nn=s.length();\\n        vector<int> v;\\n        for(i=0;i<nn;i++){\\n            k=0;\\n            x=startPos[1];\\n            y=startPos[0];\\n            for(j=i;j<nn;j++){\\n                if(s[j]==\\'R\\')\\n                    x++;\\n                if(s[j]==\\'L\\')\\n                    x--;\\n                if(s[j]==\\'U\\')\\n                    y--;\\n                if(s[j]==\\'D\\')\\n                    y++;\\n                \\n                if(x<0 or x>=n or y<0 or y>=n)\\n                    break;\\n                else\\n                    k++;\\n            }\\n            v.push_back(k);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647998,
                "title": "simple-brute-force-solution-c-clean-code",
                "content": "**Idea :**\\n\\n* Approach is pretty straightforward. Starting from each index of string, we need to check till how much steps we can move.\\n* If we cannot move further then stop checking further and break out. And start with next index.\\n# Code :\\n\\n```\\nstatic int X[4] = {0,0,-1,1};\\nstatic int Y[4] = {1,-1,0,0};\\nstatic unordered_map<char, int> mp = {\\n    {\\'R\\', 0},\\n    {\\'L\\', 1},\\n    {\\'U\\', 2},\\n    {\\'D\\', 3}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        \\n        int m = s.size();\\n        vector<int> res(m);\\n\\t\\t\\n        for(int i=0; i<m; i++) {\\n            int j=i, cnt = 0;\\n            int x = startPos[0], y = startPos[1];\\n            while(j<m) {\\n                x += X[mp[s[j]]];\\n                y += Y[mp[s[j]]];\\n                \\n                if(x >= 0 && x < n && y >= 0 && y < n) {\\n\\t\\t\\t\\t\\tcnt++, j++;\\n\\t\\t\\t\\t}\\n                else break;\\n            }\\n            res[i] = cnt;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(m*m)`, m is size of string `s`\\n* Space : `O(1)`",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstatic int X[4] = {0,0,-1,1};\\nstatic int Y[4] = {1,-1,0,0};\\nstatic unordered_map<char, int> mp = {\\n    {\\'R\\', 0},\\n    {\\'L\\', 1},\\n    {\\'U\\', 2},\\n    {\\'D\\', 3}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        \\n        int m = s.size();\\n        vector<int> res(m);\\n\\t\\t\\n        for(int i=0; i<m; i++) {\\n            int j=i, cnt = 0;\\n            int x = startPos[0], y = startPos[1];\\n            while(j<m) {\\n                x += X[mp[s[j]]];\\n                y += Y[mp[s[j]]];\\n                \\n                if(x >= 0 && x < n && y >= 0 && y < n) {\\n\\t\\t\\t\\t\\tcnt++, j++;\\n\\t\\t\\t\\t}\\n                else break;\\n            }\\n            res[i] = cnt;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647693,
                "title": "binary-search-easy-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int bs(int st,int mid,string &s,int x,int y,int n)\\n    {\\n        for(int i=st;i<=mid;i++)\\n        {\\n            if(s[i]==\\'D\\')\\n            {\\n                x+=1;\\n            }\\n            else if(s[i]==\\'U\\')\\n            {\\n                x-=1;\\n            }\\n            else if(s[i]==\\'L\\')\\n            {\\n                y-=1;\\n            }\\n            else\\n            {\\n                y+=1;\\n            }\\n            \\n            if(x<0 or y<0 or x>=n or y>=n)\\n                return i;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    \\n    \\n    vector<int> executeInstructions(int n, vector<int>& Pos, string s) {\\n        int low,mid,high,i,j,sz=s.size();\\n        \\n        vector<int>ans(sz,0);\\n        \\n        for(i=0;i<sz;i++)\\n        {\\n            low=i;\\n            high=sz-1;\\n            int anss=-1;\\n            \\n            while(low<=high)\\n            {\\n                mid=low+(high-low)/2;\\n                \\n                if(bs(i,mid,s,Pos[0],Pos[1],n)==-1)\\n                {\\n                    anss=mid;\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    high=mid-1;\\n                }\\n            }\\n            \\n            if(anss!=-1)\\n                ans[i]=anss-i+1;\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int bs(int st,int mid,string &s,int x,int y,int n)\\n    {\\n        for(int i=st;i<=mid;i++)\\n        {\\n            if(s[i]==\\'D\\')\\n            {\\n                x+=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1647612,
                "title": "brute-force-recursion-java-solution",
                "content": "Changes MADE:\\nstartPos -> strPos\\n\\n\\npublic int[] executeInstructions(int n, int[] strPos, String s)\\n{\\n\\n\\t\\tint a[] =new int[s.length()];\\n        for (int i = 0; i < s.length(); i++) {\\n            int counter = 0;\\n            a[i] = find(strPos[0],strPos[1],n,s.substring(i),counter);\\n        }\\n        return a;\\n    }\\n\\n    public static int find(int r, int c,int n,String s,int counter) {\\n        if (counter < s.length())\\n        {\\n            if (s.charAt(counter) == \\'L\\' && c - 1 < n && c - 1 >= 0 && r < n && r >= 0) {\\n                return find(r, c - 1, n, s, counter + 1);\\n            }\\n        if (s.charAt(counter) == \\'R\\' && c + 1 < n && c + 1 >= 0 && r < n && r >= 0) {\\n            return find(r, c + 1, n, s, counter + 1);\\n        }\\n        if (s.charAt(counter) == \\'U\\' && r - 1 < n && r - 1 >= 0 && c < n && c >= 0) {\\n            return find(r - 1, c, n, s, counter + 1);\\n        }\\n        if (s.charAt(counter) == \\'D\\' && r + 1 < n && r + 1 >= 0 && c < n && c >= 0) {\\n            return find(r + 1, c, n, s, counter + 1);\\n        }\\n    }\\n        return counter;\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "Changes MADE:\\nstartPos -> strPos\\n\\n\\npublic int[] executeInstructions(int n, int[] strPos, String s)\\n{\\n\\n\\t\\tint a[] =new int[s.length()];\\n        for (int i = 0; i < s.length(); i++) {\\n            int counter = 0;\\n            a[i] = find(strPos[0],strPos[1],n,s.substring(i),counter);\\n        }\\n        return a;\\n    }\\n\\n    public static int find(int r, int c,int n,String s,int counter) {\\n        if (counter < s.length())\\n        {\\n            if (s.charAt(counter) == \\'L\\' && c - 1 < n && c - 1 >= 0 && r < n && r >= 0) {\\n                return find(r, c - 1, n, s, counter + 1);\\n            }\\n        if (s.charAt(counter) == \\'R\\' && c + 1 < n && c + 1 >= 0 && r < n && r >= 0) {\\n            return find(r, c + 1, n, s, counter + 1);\\n        }\\n        if (s.charAt(counter) == \\'U\\' && r - 1 < n && r - 1 >= 0 && c < n && c >= 0) {\\n            return find(r - 1, c, n, s, counter + 1);\\n        }\\n        if (s.charAt(counter) == \\'D\\' && r + 1 < n && r + 1 >= 0 && c < n && c >= 0) {\\n            return find(r + 1, c, n, s, counter + 1);\\n        }\\n    }\\n        return counter;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1647511,
                "title": "just-follow-the-path",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int m = s.length(), moves, j, x, y;\\n        vector<int> res(m, 0);\\n        for (int i = 0; i < m; i++) {\\n            x = startPos[0], y = startPos[1], j = i, moves = 0;\\n            while (j < m) {\\n                if (s[j] == \\'L\\') y--;\\n                else if (s[j] == \\'R\\') y++;\\n                else if (s[j] == \\'U\\') x--;\\n                else if (s[j] == \\'D\\') x++;\\n                if (!inbounds(x, y, n)) break;\\n                moves++, j++;\\n            }\\n            res[i] = moves;\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    bool inbounds(int &x, int &y, int &n) {\\n        return x >= 0 && x < n && y >= 0 && y < n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int m = s.length(), moves, j, x, y;\\n        vector<int> res(m, 0);\\n        for (int i = 0; i < m; i++) {\\n            x = startPos[0], y = startPos[1], j = i, moves = 0;\\n            while (j < m) {\\n                if (s[j] == \\'L\\') y--;\\n                else if (s[j] == \\'R\\') y++;\\n                else if (s[j] == \\'U\\') x--;\\n                else if (s[j] == \\'D\\') x++;\\n                if (!inbounds(x, y, n)) break;\\n                moves++, j++;\\n            }\\n            res[i] = moves;\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    bool inbounds(int &x, int &y, int &n) {\\n        return x >= 0 && x < n && y >= 0 && y < n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493815,
                "title": "c-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n    vector<int> ans(s.length());\\n    int index = 0;\\n\\n    int row = startPos[0];\\n    int col = startPos[1];\\n\\n    for(int i = 0; i < s.length(); i++) {\\n        int count = 0;\\n        for(int j = i; j < s.length(); j++) {\\n            if(s[j] == \\'L\\') {\\n                col -= 1;\\n            } else if(s[j] == \\'R\\') {\\n                col += 1;\\n            } else if(s[j] == \\'U\\') {\\n                row -= 1;\\n            } else {\\n                row += 1;\\n            }\\n\\n            if(row >= 0 && row < n && col >=0 && col < n) {\\n                count++;\\n            } else {\\n                break;\\n            }\\n        }\\n            \\n        row = startPos[0];\\n        col = startPos[1];\\n        ans[index++] = count;\\n    }\\n    return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n    vector<int> ans(s.length());\\n    int index = 0;\\n\\n    int row = startPos[0];\\n    int col = startPos[1];\\n\\n    for(int i = 0; i < s.length(); i++) {\\n        int count = 0;\\n        for(int j = i; j < s.length(); j++) {\\n            if(s[j] == \\'L\\') {\\n                col -= 1;\\n            } else if(s[j] == \\'R\\') {\\n                col += 1;\\n            } else if(s[j] == \\'U\\') {\\n                row -= 1;\\n            } else {\\n                row += 1;\\n            }\\n\\n            if(row >= 0 && row < n && col >=0 && col < n) {\\n                count++;\\n            } else {\\n                break;\\n            }\\n        }\\n            \\n        row = startPos[0];\\n        col = startPos[1];\\n        ans[index++] = count;\\n    }\\n    return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473785,
                "title": "c",
                "content": "# Intuition\\nsimulate\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsimulate and brute force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:?\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution\\n        {\\n            public int[] ExecuteInstructions(int n, int[] startPos, string s)\\n            {\\n                int[] result = new int[s.Length];\\n\\n                for(int i = 0;i<s.Length ;i++)\\n                {\\n                    int row = startPos[0];\\n                    int col = startPos[1];\\n                    int count = 0;\\n\\n                    foreach(char c in s.Substring(i, s.Length-i))\\n                    {\\n                        if (c == \\'R\\')\\n                            col++;\\n                        else if (c == \\'L\\')\\n                            col--;\\n                        else if (c == \\'U\\')\\n                            row--;                        \\n                        else if (c == \\'D\\')\\n                            row++;                        \\n\\n                        if (row >= n || row < 0 || col >= n || col < 0)\\n                            break;\\n                        count++;                        \\n                    }\\n                    result[i] = count;\\n                }\\n                return result;\\n            }\\n            \\n        }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n        {\\n            public int[] ExecuteInstructions(int n, int[] startPos, string s)\\n            {\\n                int[] result = new int[s.Length];\\n\\n                for(int i = 0;i<s.Length ;i++)\\n                {\\n                    int row = startPos[0];\\n                    int col = startPos[1];\\n                    int count = 0;\\n\\n                    foreach(char c in s.Substring(i, s.Length-i))\\n                    {\\n                        if (c == \\'R\\')\\n                            col++;\\n                        else if (c == \\'L\\')\\n                            col--;\\n                        else if (c == \\'U\\')\\n                            row--;                        \\n                        else if (c == \\'D\\')\\n                            row++;                        \\n\\n                        if (row >= n || row < 0 || col >= n || col < 0)\\n                            break;\\n                        count++;                        \\n                    }\\n                    result[i] = count;\\n                }\\n                return result;\\n            }\\n            \\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344476,
                "title": "java-solution-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int[] arr = new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            arr[i] = execution(s.substring(i),n,startPos);\\n        }\\n        return arr;\\n    }\\n    \\n    private int execution(String str,int n,int[] arr){\\n        int move = 0;\\n         int row = arr[0];\\n         int col = arr[1];\\n        for(int i=0;i<str.length();i++){\\n            if(str.charAt(i)==\\'R\\'){\\n                if(col < n-1){\\n                     move++;\\n                     col++;\\n                }\\n                else return move;\\n            }\\n\\n            else if(str.charAt(i)==\\'D\\'){\\n                if(row < n-1){\\n                     move++;\\n                     row++;\\n                }\\n                else return move;\\n            }\\n\\n            else if(str.charAt(i)==\\'L\\'){\\n                if(col > 0){\\n                     move++;\\n                     col--;\\n                }\\n                else return move;\\n            }\\n\\n            else if(str.charAt(i)==\\'U\\'){\\n                if(row > 0){\\n                     move++;\\n                     row--;\\n                }\\n                else return move;\\n            }\\n        }\\n        return move;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int[] arr = new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            arr[i] = execution(s.substring(i),n,startPos);\\n        }\\n        return arr;\\n    }\\n    \\n    private int execution(String str,int n,int[] arr){\\n        int move = 0;\\n         int row = arr[0];\\n         int col = arr[1];\\n        for(int i=0;i<str.length();i++){\\n            if(str.charAt(i)==\\'R\\'){\\n                if(col < n-1){\\n                     move++;\\n                     col++;\\n                }\\n                else return move;\\n            }\\n\\n            else if(str.charAt(i)==\\'D\\'){\\n                if(row < n-1){\\n                     move++;\\n                     row++;\\n                }\\n                else return move;\\n            }\\n\\n            else if(str.charAt(i)==\\'L\\'){\\n                if(col > 0){\\n                     move++;\\n                     col--;\\n                }\\n                else return move;\\n            }\\n\\n            else if(str.charAt(i)==\\'U\\'){\\n                if(row > 0){\\n                     move++;\\n                     row--;\\n                }\\n                else return move;\\n            }\\n        }\\n        return move;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240779,
                "title": "easiest-detailed-solution-100-faster-brute-force",
                "content": "```\\nclass Solution {\\n    \\n    bool left(int i,int j)\\n    {\\n        j--;\\n        if(j<0)\\n            return false;\\n        return true;\\n    }\\n    bool right(int i,int j,int &n)\\n    {\\n        j++;\\n        if(j==n)\\n            return false;\\n        return true;\\n    }\\n    bool up(int i,int j)\\n    {\\n        i--;\\n        if(i<0)\\n            return false;\\n        return true;\\n    }\\n    bool down(int i,int j,int n)\\n    {\\n        i++;\\n        if(i==n)\\n            return false;\\n        return true;\\n    }\\n    \\n    vector<int>check(int n,string s,int m,int k)\\n    {\\n        vector<int>vec(s.size());\\n     for(int i=0;i<s.size();i++)\\n     {\\n         int a=m;\\n         int b=k;\\n         int count=0;\\n         for(int j=i;j<s.size();j++)\\n         {\\n             if(s[j]==\\'R\\')\\n             {\\n                 if(right(a,b,n))\\n                 {\\n                     count++;\\n                     b++;\\n                 }\\n                 else break;\\n             }\\n              if(s[j]==\\'L\\')\\n             {\\n                 if(left(a,b))\\n                 {\\n                     count++;\\n                     b--;\\n                 }\\n               else break;\\n\\n             }\\n              if(s[j]==\\'U\\')\\n             {\\n                 if(up(a,b))\\n                 {\\n                     count++;\\n                     a--;\\n                 }\\n              else break;\\n             }\\n              if(s[j]==\\'D\\')\\n             {\\n                 if(down(a,b,n))\\n                 {\\n                     count++;\\n                     a++;\\n                 }\\n                else break;\\n             }\\n         }\\n         vec[i]=count;\\n     }\\n        return vec;\\n    }\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int i=startPos[0];\\n        int j=startPos[1];\\n        \\n        vector<int>ans=check(n,s,i,j);\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    \\n    bool left(int i,int j)\\n    {\\n        j--;\\n        if(j<0)\\n            return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3208538,
                "title": "easy-effecient-approach-82-beats-in-time",
                "content": "# Intuition\\nTraverse across and find the limits\\n\\n# Approach\\nFor each iteration consider each start of instruction\\nCheck the boundaries\\nCheck for all the instructions\\nBreak if overboundry/complete all the instructions\\nAdd the result to vector and return\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> res;\\n        int row = startPos[0];\\n        int col = startPos[1];\\n        int count = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            count = 0;\\n            row = startPos[0];\\n            col = startPos[1];\\n            for(int j = i; j < s.size(); j++)\\n                if(s[j] == \\'R\\')\\n                    if(col < n - 1){\\n                        count++;\\n                        col++;\\n                    }\\n                    else                        break;\\n                else if(s[j] == \\'L\\')\\n                    if(col > 0){                        \\n                        count++;\\n                        col--;\\n                    }\\n                    else                        break;\\n                else if(s[j] == \\'D\\')\\n                    if(row < n - 1){                        \\n                        count++;\\n                        row++;\\n                    }\\n                    else                        break;\\n                else\\n                    if(row > 0){                        \\n                        count++;\\n                        row--;\\n                    }\\n                    else                        break;\\n            res.push_back(count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> res;\\n        int row = startPos[0];\\n        int col = startPos[1];\\n        int count = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            count = 0;\\n            row = startPos[0];\\n            col = startPos[1];\\n            for(int j = i; j < s.size(); j++)\\n                if(s[j] == \\'R\\')\\n                    if(col < n - 1){\\n                        count++;\\n                        col++;\\n                    }\\n                    else                        break;\\n                else if(s[j] == \\'L\\')\\n                    if(col > 0){                        \\n                        count++;\\n                        col--;\\n                    }\\n                    else                        break;\\n                else if(s[j] == \\'D\\')\\n                    if(row < n - 1){                        \\n                        count++;\\n                        row++;\\n                    }\\n                    else                        break;\\n                else\\n                    if(row > 0){                        \\n                        count++;\\n                        row--;\\n                    }\\n                    else                        break;\\n            res.push_back(count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054450,
                "title": "simple-easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countInstructions(int n,vector<int>&startPos,string s,int i){\\n        int cnt=0;\\n        int r=startPos[0],c=startPos[1];\\n        for(int p=i;p<s.length();p++){\\n            if(s[p]==\\'R\\'){\\n                if(c+1<n){\\n                    cnt++;\\n                    c++;\\n                }\\n                else break;\\n            }\\n            else if(s[p]==\\'L\\'){\\n                if(c-1>=0){\\n                    cnt++;\\n                    c--;\\n                }\\n                else break;\\n            }\\n            else if(s[p]==\\'U\\'){\\n                if(r-1>=0){\\n                    cnt++;\\n                    r--;\\n                }\\n                else break;\\n            }\\n            else{\\n                if(r+1<n){\\n                    r++;\\n                    cnt++;\\n                }\\n                else break;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int>res;\\n        for(int i=0;i<s.length();i++){\\n            res.push_back(countInstructions(n,startPos,s,i));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countInstructions(int n,vector<int>&startPos,string s,int i){\\n        int cnt=0;\\n        int r=startPos[0],c=startPos[1];\\n        for(int p=i;p<s.length();p++){\\n            if(s[p]==\\'R\\'){\\n                if(c+1<n){\\n                    cnt++;\\n                    c++;\\n                }\\n                else break;\\n            }\\n            else if(s[p]==\\'L\\'){\\n                if(c-1>=0){\\n                    cnt++;\\n                    c--;\\n                }\\n                else break;\\n            }\\n            else if(s[p]==\\'U\\'){\\n                if(r-1>=0){\\n                    cnt++;\\n                    r--;\\n                }\\n                else break;\\n            }\\n            else{\\n                if(r+1<n){\\n                    r++;\\n                    cnt++;\\n                }\\n                else break;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int>res;\\n        for(int i=0;i<s.length();i++){\\n            res.push_back(countInstructions(n,startPos,s,i));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962090,
                "title": "iterative-solution-easy-to-understand-java-solution-step-by-step-explanation",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N * (string length)!)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ for answer\\n\\n# Code\\n```\\nclass Solution {\\n    //method to count possible moving direction \\n    public int findDir(String s,int i,int j,int n,int cnt){\\n        for(int k = 0;k < s.length();k ++) {\\n            char c = s.charAt(k);\\n            //All condition about the possible direction if yes count it or stop it\\n            if(c == \\'L\\'){\\n                if(j - 1 >= 0) {\\n                    j = j - 1;\\n                    cnt++;\\n                }else break;\\n            }else if(c == \\'R\\') {\\n                if(j + 1 < n) {\\n                    j = j + 1;\\n                    cnt++;\\n                }else break;\\n            }else if(c == \\'D\\') {\\n                if(i + 1 < n) {\\n                    i = i + 1;\\n                    cnt++;\\n                }else break;\\n            }else{\\n                if(i - 1 >= 0) {\\n                    i = i - 1;\\n                    cnt++;\\n                }else break;    \\n            }\\n\\n        }\\n        return cnt;\\n    }\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int[][] grid = new int[n][n];\\n        int i = startPos[0];\\n        int j = startPos[1];\\n        int[]  ans = new int[s.length()];\\n        for(int k = 0;k < s.length();k ++) {\\n//we need to find from current to end possible direction \\n//by sending substring of the current to end for reducing time complexity\\n            int countPossible = findDir(s.substring(k,s.length()),i,j,n,0);\\n            ans[k] = countPossible;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //method to count possible moving direction \\n    public int findDir(String s,int i,int j,int n,int cnt){\\n        for(int k = 0;k < s.length();k ++) {\\n            char c = s.charAt(k);\\n            //All condition about the possible direction if yes count it or stop it\\n            if(c == \\'L\\'){\\n                if(j - 1 >= 0) {\\n                    j = j - 1;\\n                    cnt++;\\n                }else break;\\n            }else if(c == \\'R\\') {\\n                if(j + 1 < n) {\\n                    j = j + 1;\\n                    cnt++;\\n                }else break;\\n            }else if(c == \\'D\\') {\\n                if(i + 1 < n) {\\n                    i = i + 1;\\n                    cnt++;\\n                }else break;\\n            }else{\\n                if(i - 1 >= 0) {\\n                    i = i - 1;\\n                    cnt++;\\n                }else break;    \\n            }\\n\\n        }\\n        return cnt;\\n    }\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int[][] grid = new int[n][n];\\n        int i = startPos[0];\\n        int j = startPos[1];\\n        int[]  ans = new int[s.length()];\\n        for(int k = 0;k < s.length();k ++) {\\n//we need to find from current to end possible direction \\n//by sending substring of the current to end for reducing time complexity\\n            int countPossible = findDir(s.substring(k,s.length()),i,j,n,0);\\n            ans[k] = countPossible;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873584,
                "title": "easy-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nint val;\\nbool is_valid(int n,int r,int c, string &s,int index)\\n{\\n    if(r>=n||c>=n||r<0||c<0||index>=s.size())\\n     return false;\\n     return true;\\n}\\nvoid dfs(int n,int r,int c, string &s,int index)\\n{\\n    if(r>=n||c>=n||r<0||c<0||index>=s.size())\\n     return;\\n    \\n      if(s[index]==\\'R\\'&&is_valid(n,r,c+1,s,index))//check if present index is valid and then go for +1 index\\n      {\\n           val++;\\n         dfs(n,r,c+1,s,index+1);\\n      }\\n      if(s[index]==\\'D\\'&&is_valid(n,r+1,c,s,index))\\n      {\\n           val++;\\n         dfs(n,r+1,c,s,index+1);\\n      }\\n      if(s[index]==\\'L\\'&&is_valid(n,r,c-1,s,index))\\n      {\\n           val++;\\n         dfs(n,r,c-1,s,index+1);\\n      }\\n      if(s[index]==\\'U\\'&&is_valid(n,r-1,c,s,index))\\n      {\\n           val++;\\n         dfs(n,r-1,c,s,index+1);\\n      }\\n}\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int>ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            val=0;\\n            dfs(n,startPos[0],startPos[1],s,i);\\n            ans.push_back(val);//since val will be incre 1 time extra even if the next cell is valid\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint val;\\nbool is_valid(int n,int r,int c, string &s,int index)\\n{\\n    if(r>=n||c>=n||r<0||c<0||index>=s.size())\\n     return false;\\n     return true;\\n}\\nvoid dfs(int n,int r,int c, string &s,int index)\\n{\\n    if(r>=n||c>=n||r<0||c<0||index>=s.size())\\n     return;\\n    \\n      if(s[index]==\\'R\\'&&is_valid(n,r,c+1,s,index))//check if present index is valid and then go for +1 index\\n      {\\n           val++;\\n         dfs(n,r,c+1,s,index+1);\\n      }\\n      if(s[index]==\\'D\\'&&is_valid(n,r+1,c,s,index))\\n      {\\n           val++;\\n         dfs(n,r+1,c,s,index+1);\\n      }\\n      if(s[index]==\\'L\\'&&is_valid(n,r,c-1,s,index))\\n      {\\n           val++;\\n         dfs(n,r,c-1,s,index+1);\\n      }\\n      if(s[index]==\\'U\\'&&is_valid(n,r-1,c,s,index))\\n      {\\n           val++;\\n         dfs(n,r-1,c,s,index+1);\\n      }\\n}\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int>ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            val=0;\\n            dfs(n,startPos[0],startPos[1],s,i);\\n            ans.push_back(val);//since val will be incre 1 time extra even if the next cell is valid\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705847,
                "title": "bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(int xx,int yy, int n)\\n    {\\n        if(xx>=0 && yy>=0 && xx<n && yy <n)\\n            return true;\\n        return false;\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        \\n        unordered_map<char,pair<int,int>> mp{\\n            { \\'U\\',{-1,0}},\\n            {\\'D\\',{1,0}},\\n            {\\'R\\', {0,1}},\\n            {\\'L\\',{0,-1}}\\n        };\\n        \\n        int m = s.size();\\n        vector<int> res(m);\\n        for(int i=0;i<m;i++)\\n        {\\n            int len = 0;\\n            int x =  startPos[0];\\n            int y =  startPos[1];\\n            \\n            for(int j=i;j<m;j++){\\n                x+=mp[s[j]].first;\\n                y+=mp[s[j]].second;\\n                if(check(x,y,n))\\n                    len++;\\n                else\\n                    break;\\n            }\\n            res[i] = len;\\n            \\n        }\\n        \\n     return res;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(int xx,int yy, int n)\\n    {\\n        if(xx>=0 && yy>=0 && xx<n && yy <n)\\n            return true;\\n        return false;\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        \\n        unordered_map<char,pair<int,int>> mp{\\n            { \\'U\\',{-1,0}},\\n            {\\'D\\',{1,0}},\\n            {\\'R\\', {0,1}},\\n            {\\'L\\',{0,-1}}\\n        };\\n        \\n        int m = s.size();\\n        vector<int> res(m);\\n        for(int i=0;i<m;i++)\\n        {\\n            int len = 0;\\n            int x =  startPos[0];\\n            int y =  startPos[1];\\n            \\n            for(int j=i;j<m;j++){\\n                x+=mp[s[j]].first;\\n                y+=mp[s[j]].second;\\n                if(check(x,y,n))\\n                    len++;\\n                else\\n                    break;\\n            }\\n            res[i] = len;\\n            \\n        }\\n        \\n     return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627261,
                "title": "c-easy-brute-force-soln-beats-96-soln-by-time",
                "content": "```\\nvector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        // Create a vector of m size and initialise to 0 \\n        int m = s.size();\\n        vector<int> v(m,0);\\n\\t\\t// Iterate over the vector\\n        for(int i=0;i<m;i++){\\n            int ans = 0; int x = startPos[0], y = startPos[1];\\n\\t\\t\\t// Check for the string operations if they are valid\\n            for(int j=i;j<m;j++){\\n                if(s[j]==\\'R\\') y++;\\n                else if(s[j]==\\'L\\') y--;\\n                else if(s[j]==\\'U\\') x--;\\n                else x++;\\n\\t\\t\\t\\t// Check whether if it stays in the grid then increase the count\\n                if(x>=0 && x<n && y>=0 && y<n) ans++;\\n                else break;\\n            }\\n\\t\\t\\t// Update the value at the required index \\n            v[i] = ans;\\n        }\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        // Create a vector of m size and initialise to 0 \\n        int m = s.size();\\n        vector<int> v(m,0);\\n\\t\\t// Iterate over the vector\\n        for(int i=0;i<m;i++){\\n            int ans = 0; int x = startPos[0], y = startPos[1];\\n\\t\\t\\t// Check for the string operations if they are valid\\n            for(int j=i;j<m;j++){\\n                if(s[j]==\\'R\\') y++;\\n                else if(s[j]==\\'L\\') y--;\\n                else if(s[j]==\\'U\\') x--;\\n                else x++;\\n\\t\\t\\t\\t// Check whether if it stays in the grid then increase the count\\n                if(x>=0 && x<n && y>=0 && y<n) ans++;\\n                else break;\\n            }\\n\\t\\t\\t// Update the value at the required index \\n            v[i] = ans;\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2606515,
                "title": "very-clear-self-explanatory-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<char, pair<int, int>> mp {\\n        {\\'L\\', {0, -1}},\\n        {\\'R\\', {0, 1}},\\n        {\\'U\\', {-1, 0}},\\n        {\\'D\\', {1, 0}}\\n    };\\n    \\n    bool isSafe(int n, int r, int c) {\\n        return r >= 0 && r < n && c >= 0 && c < n;    \\n    }\\n    \\n    vector<int> executeInstructions(int n, vector<int>& startPos, string &s) {\\n        int m = s.length();\\n        vector<int> ans(m);\\n        for(int i=0; i<m; i++) {\\n            int len = 0;\\n            int r = startPos[0], c = startPos[1];\\n            for(int j=i; j<m; j++) {\\n                r = r + mp[s[j]].first, c = c + mp[s[j]].second;\\n                if(isSafe(n, r, c))\\n                    len++;\\n                else\\n                    break;\\n            }\\n            ans[i] = len;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<char, pair<int, int>> mp {\\n        {\\'L\\', {0, -1}},\\n        {\\'R\\', {0, 1}},\\n        {\\'U\\', {-1, 0}},\\n        {\\'D\\', {1, 0}}\\n    };\\n    \\n    bool isSafe(int n, int r, int c) {\\n        return r >= 0 && r < n && c >= 0 && c < n;    \\n    }\\n    \\n    vector<int> executeInstructions(int n, vector<int>& startPos, string &s) {\\n        int m = s.length();\\n        vector<int> ans(m);\\n        for(int i=0; i<m; i++) {\\n            int len = 0;\\n            int r = startPos[0], c = startPos[1];\\n            for(int j=i; j<m; j++) {\\n                r = r + mp[s[j]].first, c = c + mp[s[j]].second;\\n                if(isSafe(n, r, c))\\n                    len++;\\n                else\\n                    break;\\n            }\\n            ans[i] = len;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419364,
                "title": "c-straightforward-easy-code",
                "content": "![image](https://assets.leetcode.com/users/images/a8b2eeac-067b-420c-9885-9bb72fd4b338_1660389613.2288911.png)\\n\\n**T->O(m^2) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> executeInstructions(int n, vector<int>& start, string s) {\\n\\t\\t\\tint m=s.size();\\n\\t\\t\\tvector<int> ans(m);\\n\\t\\t\\tfor(int l=0;l<m;l++){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tint i=start[0],j=start[1];\\n\\t\\t\\t\\tfor(int k=l;k<m;k++){\\n\\t\\t\\t\\t\\tif(s[k]==\\'L\\'){\\n\\t\\t\\t\\t\\t\\tif(j-1>=0){\\n\\t\\t\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse break;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(s[k]==\\'R\\'){\\n\\t\\t\\t\\t\\t\\tif(j+1<n){\\n\\t\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse break;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(s[k]==\\'U\\'){\\n\\t\\t\\t\\t\\t\\tif(i-1>=0){\\n\\t\\t\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse break;\\n\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tif(i+1<n){\\n\\t\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse break;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans[l]=count;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> executeInstructions(int n, vector<int>& start, string s) {\\n\\t\\t\\tint m=s.size();\\n\\t\\t\\tvector<int> ans(m);\\n\\t\\t\\tfor(int l=0;l<m;l++){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tint i=start[0],j=start[1];\\n\\t\\t\\t\\tfor(int k=l;k<m;k++){\\n\\t\\t\\t\\t\\tif(s[k]==\\'L\\'){\\n\\t\\t\\t\\t\\t\\tif(j-1>=0){\\n\\t\\t\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2286258,
                "title": "c-solution-easy-to-understand-brute-force",
                "content": "```C#\\npublic class Solution {\\n    public int[] ExecuteInstructions(int n, int[] startPos, string s) {\\n        int[] ans = new int[s.Length];\\n        for (int i = 0; i < s.Length; i++) {\\n            int opsCount = 0;\\n            int row = startPos[0], col = startPos[1];\\n            while (row >= 0 && row < n && col >= 0 && col < n && i + opsCount < s.Length) {\\n                char opChar = s[i + opsCount];\\n                if (opChar == \\'L\\') col--;\\n                else if (opChar == \\'R\\') col++;\\n                else if (opChar == \\'U\\') row--;\\n                else if (opChar == \\'D\\') row++;\\n                \\n                if (row >= 0 && row < n && col >= 0 && col < n) opsCount++;\\n            }\\n            \\n            ans[i] = opsCount;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```C#\\npublic class Solution {\\n    public int[] ExecuteInstructions(int n, int[] startPos, string s) {\\n        int[] ans = new int[s.Length];\\n        for (int i = 0; i < s.Length; i++) {\\n            int opsCount = 0;\\n            int row = startPos[0], col = startPos[1];\\n            while (row >= 0 && row < n && col >= 0 && col < n && i + opsCount < s.Length) {\\n                char opChar = s[i + opsCount];\\n                if (opChar == \\'L\\') col--;\\n                else if (opChar == \\'R\\') col++;\\n                else if (opChar == \\'U\\') row--;\\n                else if (opChar == \\'D\\') row++;\\n                \\n                if (row >= 0 && row < n && col >= 0 && col < n) opsCount++;\\n            }\\n            \\n            ans[i] = opsCount;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279399,
                "title": "javascript-solution-faster-than-87-t-o-n-2",
                "content": "```\\n//     Time: O(n^2)\\nvar executeInstructions = function(n, startPos, s) {\\n    let answers = []; \\n    for (i = 0; i < s.length; i++) { \\n        let movement = 0;\\n        let [row, col] = startPos;\\n        for (j = i; j < s.length; j++) { \\n            if (s[j] == \"R\") col++;\\n            else if (s[j] == \"L\") col--;\\n            else if (s[j] == \"D\") row++;\\n            else row--;\\n            if(row>n-1 || col > n-1 || row < 0 || col < 0) {\\n                break;\\n            }\\n            movement++;\\n        }\\n        answers[i] = movement;\\n    }\\n    return answers;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//     Time: O(n^2)\\nvar executeInstructions = function(n, startPos, s) {\\n    let answers = []; \\n    for (i = 0; i < s.length; i++) { \\n        let movement = 0;\\n        let [row, col] = startPos;\\n        for (j = i; j < s.length; j++) { \\n            if (s[j] == \"R\") col++;\\n            else if (s[j] == \"L\") col--;\\n            else if (s[j] == \"D\") row++;\\n            else row--;\\n            if(row>n-1 || col > n-1 || row < 0 || col < 0) {\\n                break;\\n            }\\n            movement++;\\n        }\\n        answers[i] = movement;\\n    }\\n    return answers;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2248973,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int execute(int n, int[] startPos, String s) {\\n        int initialX = startPos[0];\\n        int initialY = startPos[1];\\n        int ans = 0;\\n        for(int i=0;i<s.length();i++) {\\n            if(s.charAt(i) == \\'R\\')\\n                initialY++;\\n            if(s.charAt(i) == \\'L\\')\\n                initialY--;\\n            if(s.charAt(i) == \\'U\\')\\n                initialX--;\\n            if(s.charAt(i) == \\'D\\')\\n                initialX++;\\n            if(initialX < 0 || initialX >= n)\\n                return ans;\\n            if(initialY < 0 || initialY >= n)\\n                return ans;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int[] res = new int[s.length()];\\n        \\n        for(int i=0;i<s.length();i++) {\\n            String str = s.substring(i);\\n            \\n            res[i] = execute(n,startPos,str);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int execute(int n, int[] startPos, String s) {\\n        int initialX = startPos[0];\\n        int initialY = startPos[1];\\n        int ans = 0;\\n        for(int i=0;i<s.length();i++) {\\n            if(s.charAt(i) == \\'R\\')\\n                initialY++;\\n            if(s.charAt(i) == \\'L\\')\\n                initialY--;\\n            if(s.charAt(i) == \\'U\\')\\n                initialX--;\\n            if(s.charAt(i) == \\'D\\')\\n                initialX++;\\n            if(initialX < 0 || initialX >= n)\\n                return ans;\\n            if(initialY < 0 || initialY >= n)\\n                return ans;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int[] res = new int[s.length()];\\n        \\n        for(int i=0;i<s.length();i++) {\\n            String str = s.substring(i);\\n            \\n            res[i] = execute(n,startPos,str);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206750,
                "title": "c-python-kotlin-easy-explained-solution-o-n-2",
                "content": "![image](https://assets.leetcode.com/users/images/4cd060e8-aaff-4d48-a0f2-6db961b1bf90_1656360433.7701964.png)\\n\\n\\u200E\\n**C++ :**\\n```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> ans; //To save movements we have done in all iteration\\n        int count = 0; //To save movements we have done\\n        int ini = startPos[0]; //Saving initial i\\n        int inj = startPos[1]; //Saving initial j\\n        for(int  i = 0; i < s.length(); i++){\\n            for(int  j = i; j < s.length(); j++){ //Iterating over every element with starting index +1 in every iteration\\n                if(s[j] == \\'R\\') startPos[1]++; //If we encounter R move to right i.e. incrementing j value\\n                else if(s[j] == \\'L\\') startPos[1]--;\\n                else if(s[j] == \\'U\\') startPos[0]--;\\n                else if(s[j] == \\'D\\') startPos[0]++;\\n                \\n                if(startPos[1] > -1 && startPos[1] < n && startPos[0] > -1 && startPos[0] < n) count++; //Breaking loop if we encounter any position outside of grid\\n                else j = INT_MAX-1; //-1 becasue while looping again it will make j++ than compare and break loop\\n            }\\n            ans.push_back(count); //Pushing count in ans because all iterations are done for this condition\\n            count = 0; //Ready to count again\\n            startPos = {ini, inj}; //Ready at given position\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\u200E\\n**Python :**\\n```\\nclass Solution(object):\\n    def executeInstructions(self, n, startPos, s):\\n        li = []\\n        count = 0;\\n        ini = startPos[0]\\n        inj = startPos[1]\\n        for i in range(len(s)):\\n            for j in range(i, len(s)):\\n                if s[j] == \\'R\\' : startPos[1] += 1\\n                elif s[j] == \\'L\\' : startPos[1] -= 1\\n                elif s[j] == \\'U\\' : startPos[0] -= 1\\n                elif s[j] == \\'D\\' : startPos[0] += 1\\n                \\n                if (startPos[1] > -1 and startPos[1] < n and startPos[0] > -1 and startPos[0] < n) : count += 1\\n                else : startPos = [-1,-1] \\n            startPos = [ini, inj]\\n            li.append(count)\\n            count = 0\\n        return li\\n```\\n\\u200E\\n**Kotlin :**\\n```\\nclass Solution {\\n    fun executeInstructions(n: Int, startPos: IntArray, s: String): IntArray {\\n        var li = IntArray(s.length)\\n        var count = 0\\n        var ini = startPos[0]\\n        var inj = startPos[1]\\n        \\n        var currPosition = startPos\\n        \\n        for (i in 0..s.length-1){\\n            for(j in i..s.length-1){\\n                \\n                if (s[j] == \\'R\\') {inj += 1}\\n                else if (s[j] == \\'L\\') {inj -= 1}\\n                else if (s[j] == \\'U\\') {ini -= 1}\\n                else if (s[j] == \\'D\\') {ini += 1}\\n                \\n                if (inj > -1 && inj < n && ini > -1 && ini < n) count += 1\\n                else {\\n                    ini = -1\\n                    inj = -1\\n                }\\n            }\\n            ini = startPos[0]\\n            inj = startPos[1]\\n            li[i] = count\\n            count = 0\\n        }\\n        return li\\n    }\\n}\\n```\\n\\u200E\\nIf you think this post was ***helpful***, I will be happy if you give a ***upvote***. Any questions or discussions are welcome! **Thanks a lot.** \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> ans; //To save movements we have done in all iteration\\n        int count = 0; //To save movements we have done\\n        int ini = startPos[0]; //Saving initial i\\n        int inj = startPos[1]; //Saving initial j\\n        for(int  i = 0; i < s.length(); i++){\\n            for(int  j = i; j < s.length(); j++){ //Iterating over every element with starting index +1 in every iteration\\n                if(s[j] == \\'R\\') startPos[1]++; //If we encounter R move to right i.e. incrementing j value\\n                else if(s[j] == \\'L\\') startPos[1]--;\\n                else if(s[j] == \\'U\\') startPos[0]--;\\n                else if(s[j] == \\'D\\') startPos[0]++;\\n                \\n                if(startPos[1] > -1 && startPos[1] < n && startPos[0] > -1 && startPos[0] < n) count++; //Breaking loop if we encounter any position outside of grid\\n                else j = INT_MAX-1; //-1 becasue while looping again it will make j++ than compare and break loop\\n            }\\n            ans.push_back(count); //Pushing count in ans because all iterations are done for this condition\\n            count = 0; //Ready to count again\\n            startPos = {ini, inj}; //Ready at given position\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def executeInstructions(self, n, startPos, s):\\n        li = []\\n        count = 0;\\n        ini = startPos[0]\\n        inj = startPos[1]\\n        for i in range(len(s)):\\n            for j in range(i, len(s)):\\n                if s[j] == \\'R\\' : startPos[1] += 1\\n                elif s[j] == \\'L\\' : startPos[1] -= 1\\n                elif s[j] == \\'U\\' : startPos[0] -= 1\\n                elif s[j] == \\'D\\' : startPos[0] += 1\\n                \\n                if (startPos[1] > -1 and startPos[1] < n and startPos[0] > -1 and startPos[0] < n) : count += 1\\n                else : startPos = [-1,-1] \\n            startPos = [ini, inj]\\n            li.append(count)\\n            count = 0\\n        return li\\n```\n```\\nclass Solution {\\n    fun executeInstructions(n: Int, startPos: IntArray, s: String): IntArray {\\n        var li = IntArray(s.length)\\n        var count = 0\\n        var ini = startPos[0]\\n        var inj = startPos[1]\\n        \\n        var currPosition = startPos\\n        \\n        for (i in 0..s.length-1){\\n            for(j in i..s.length-1){\\n                \\n                if (s[j] == \\'R\\') {inj += 1}\\n                else if (s[j] == \\'L\\') {inj -= 1}\\n                else if (s[j] == \\'U\\') {ini -= 1}\\n                else if (s[j] == \\'D\\') {ini += 1}\\n                \\n                if (inj > -1 && inj < n && ini > -1 && ini < n) count += 1\\n                else {\\n                    ini = -1\\n                    inj = -1\\n                }\\n            }\\n            ini = startPos[0]\\n            inj = startPos[1]\\n            li[i] = count\\n            count = 0\\n        }\\n        return li\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200267,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& a, string s) {\\n        vector<int>v;\\n        int count,x,y;\\n        int m=s.size();\\n        for(int j=0;j<m;j++){\\n            count=0;\\n             x=a[0],y=a[1];\\n            for(int i=j;i<m;i++){\\n               if(s[i]==\\'R\\')\\n                   y++;\\n              else if(s[i]==\\'L\\')\\n                   y--;\\n               else if(s[i]==\\'U\\')\\n                    x--;\\n                else\\n                    x++;\\n                if(x>=0 && x<n && y>=0 && y<n)\\n                    count++;\\n                else\\n                    break;\\n            }\\n            v.push_back(count);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& a, string s) {\\n        vector<int>v;\\n        int count,x,y;\\n        int m=s.size();\\n        for(int j=0;j<m;j++){\\n            count=0;\\n             x=a[0],y=a[1];\\n            for(int i=j;i<m;i++){\\n               if(s[i]==\\'R\\')\\n                   y++;\\n              else if(s[i]==\\'L\\')\\n                   y--;\\n               else if(s[i]==\\'U\\')\\n                    x--;\\n                else\\n                    x++;\\n                if(x>=0 && x<n && y>=0 && y<n)\\n                    count++;\\n                else\\n                    break;\\n            }\\n            v.push_back(count);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054827,
                "title": "2120-execution-of-all-suffix-staying-in-a-grid",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> answer;\\n        int x,y,count;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            x=startPos[1];\\n            y=startPos[0];\\n            count=0;\\n            for(int j=i;j<s.size();j++)\\n            {\\n                switch(s[j])\\n                {\\n                    case \\'L\\' :\\n                    {\\n                        x--;\\n                    }\\n                    break;\\n                    case \\'R\\' :\\n                    {\\n                        x++;\\n                    }\\n                    break;\\n                    case \\'U\\' :\\n                    {\\n                        y--;\\n                    }\\n                    break;\\n                    case \\'D\\' :\\n                    {\\n                        y++;\\n                    }\\n                    break;\\n                }\\n                if(x>=0 && x<=n-1 && y>=0 && y<=n-1)\\n                {\\n                    count++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            answer.push_back(count);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> answer;\\n        int x,y,count;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            x=startPos[1];\\n            y=startPos[0];\\n            count=0;\\n            for(int j=i;j<s.size();j++)\\n            {\\n                switch(s[j])\\n                {\\n                    case \\'L\\' :\\n                    {\\n                        x--;\\n                    }\\n                    break;\\n                    case \\'R\\' :\\n                    {\\n                        x++;\\n                    }\\n                    break;\\n                    case \\'U\\' :\\n                    {\\n                        y--;\\n                    }\\n                    break;\\n                    case \\'D\\' :\\n                    {\\n                        y++;\\n                    }\\n                    break;\\n                }\\n                if(x>=0 && x<=n-1 && y>=0 && y<=n-1)\\n                {\\n                    count++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            answer.push_back(count);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980481,
                "title": "intuitive-o-m-solutions-in-c-and-python-based-on-hxu10-s-algorithm",
                "content": "### Intuitive O(m) Solutions in C++ and Python based on hxu10\\'s algorithm\\n\\n* This is a refactoring of [hxu10\\'s O(m) Solution](https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/discuss/1647617/python-O(m)-solution-with-detailed-explanation.).\\n* The refactoring makes it more intuitive and easy-to-understand.\\n\\t* avoided the negation of `upmost` and `leftmost` which is counter-intuitive.\\n\\t* added the reasoning about why we should look up the pos such `curr_row_pos + up_too_far` in the dictionary.\\n\\nPlease see the detailed comments in the code. \\n\\n### C++17\\n```\\nclass Solution {\\npublic:\\n    // Linear time solution: scanning backward. fzh-to-review-recite.\\n    vector<int>\\n    executeInstructions(const int n, const vector<int>& startPos, const string commands) {\\n        const int m = commands.size();\\n        vector<int> res(m);\\n        if (n == 1) {\\n            return res;\\n        }\\n        const int startRow = startPos[0], startCol = startPos[1];\\n\\n        // row delta means the change in row positions\\n        // if the row delta equals `up_too_far`, the robot goes too far upward.\\n        const int upTooFar = -startRow - 1;\\n        // if the row delta equals `downTooFar`, the robot goes too far downward.\\n        const int downTooFar = n - startRow;\\n        // if the col delta equals `leftTooFar`, the robot goes too far leftward.\\n        const int leftTooFar = -startCol - 1;\\n        // if the col delta equals `rightTooFar`, the robot goes too far rightward.\\n        const int rightTooFar = n - startCol;\\n        // the current row/col positions of the robot in the virtual coordinate system.\\n        int currRowPos = 0, currColPos = 0;\\n\\n        // here `command` is synonymous with `instruction`.\\n        // u_map futRowToCmdId maps the future row positions to the command id.\\n        // futColToCmdId does the same thing for future col positions.\\n        unordered_map<int, int> futRowToCmdId{{0, m}};\\n        unordered_map<int, int> futColToCmdId{{0, m}};\\n\\n        for (int i = m - 1; i >= 0; --i) {\\n            // since we\\'re running the simulation in reverse order,\\n            // the pos would increment whereas in forward order it should decrement.\\n            switch (commands[i]) { // the current command\\n            case \\'L\\':\\n                ++currColPos;\\n                break;\\n            case \\'R\\':\\n                --currColPos;\\n                break;\\n            case \\'U\\':\\n                ++currRowPos;\\n                break;\\n            case \\'D\\':\\n                --currRowPos;\\n                break;\\n            }\\n            int maxSteps = m - i;\\n\\n            // let\\'s suppose there might be a future row pos `fut_row_pos` that make the robot goes\\n            // too far upward, then we\\'ll have: the delta in row pos (i.e. fut_row_pos -\\n            // curr_row_pos) equals to `up_too_far`:\\n            //       fut_row_pos - curr_row_pos == up_too_far\\n            // the equation is equivalent to:\\n            // ==> fut_row_pos == curr_row_pos + up_too_far.\\n            // that means, the fut_row_pos, if exists, should be `curr_row_pos + up_too_far`.\\n            // So, if that value do exist in the future row pos dictionary, the robot\\n            // will go too far upward at that command id. (we discount the last command because it\\'s\\n            // not allowed.)\\n            if (futRowToCmdId.count(currRowPos + upTooFar)) {\\n                maxSteps = min(maxSteps, futRowToCmdId[currRowPos + upTooFar] - i - 1);\\n            }\\n\\n            // let\\'s suppose there might be a future row pos `fut_row_pos` that make the robot goes\\n            // too far downward, then we\\'ll have: the delta in row pos (i.e. fut_row_pos -\\n            // curr_row_pos) equals to `down_too_far`:\\n            //       fut_row_pos - curr_row_pos == down_too_far\\n            // the equation is equivalent to:\\n            // ==> fut_row_pos == curr_row_pos + down_too_far.\\n            // that means, the fut_row_pos, if exists, should be `curr_row_pos + down_too_far`.\\n            // So, if that value do exist in the future row pos dictionary, the robot\\n            // will go too far downward at that command id. (we discount the last command because\\n            // it\\'s not allowed.)\\n            if (futRowToCmdId.count(currRowPos + downTooFar)) {\\n                maxSteps = min(maxSteps, futRowToCmdId[currRowPos + downTooFar] - i - 1);\\n            }\\n\\n            // for col pos, the reasoning are the same as the row pos\\n            if (futColToCmdId.count(currColPos + leftTooFar)) {\\n                maxSteps = min(maxSteps, futColToCmdId[currColPos + leftTooFar] - i - 1);\\n            }\\n            if (futColToCmdId.count(currColPos + rightTooFar)) {\\n                maxSteps = min(maxSteps, futColToCmdId[currColPos + rightTooFar] - i - 1);\\n            }\\n\\n            res[i] = maxSteps;\\n\\n            // If the robot goes too far multiple times in the future, we care\\n            // only about the occurrence that is closest to the scanline at `i` that is moving to\\n            // the left. so we\\'ll overwrite the entry in the future row pos dictionary if the entry\\n            // already exists.\\n            futRowToCmdId[currRowPos] = i;\\n            futColToCmdId[currColPos] = i;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n### Python3\\n```\\n# LC 2120. Execution of All Suffix Instructions Staying in a Grid.\\nclass Solution(object):\\n    def executeInstructions(self, n: int, startPos: List[int], cmds: str) -> List[int]:\\n        \"\"\"\\n        compute how many steps/instructions can the robot execute if it starts\\n        executing at s[i].\\n        :param n: the grid is an n * n grid\\n        :param startPos: [row, col] of the starting position\\n        :param cmds: string form of the commands/instructions\\n        :return: a list of integers indicating the number of steps if the robot starting at i-th instruction.\\n        \"\"\"\\n        m = len(cmds)  # instructions\\n        direc = {  #\\n            \\'U\\': [-1, 0],\\n            \\'D\\': [1, 0],\\n            \\'L\\': [0, -1],\\n            \\'R\\': [0, 1],\\n        }\\n        ROW_IDX, COL_IDX = 0, 1\\n\\n\\t\\t# row delta means the change in row positions\\n        # if the row delta equals `up_too_far`, the robot goes too far upward.\\n        up_too_far = -startPos[ROW_IDX] - 1\\n        up_too_far_negated = startPos[ROW_IDX] + 1\\n        # if the row delta equals `down_too_far`, the robot goes too far downward.\\n        down_too_far = n - startPos[ROW_IDX]\\n        # if the col delta equals `left_too_far`, the robot goes too far leftward.\\n        left_too_far = -startPos[COL_IDX] - 1\\n        left_too_far_negated = startPos[COL_IDX] + 1\\n        # if the col delta equals `right_too_far`, the robot goes too far rightward.\\n        right_too_far = n - startPos[COL_IDX]\\n        # the current row/col positions of the robot in the virtual coordinate system.\\n        curr_row_pos, curr_col_pos = 0, 0\\n        # here `command` is synonymous with `instruction`.\\n        # dict fut_row_to_cmd_id maps the future row positions to the command id.\\n        # fut_col_to_cmd_id do the same thing for future col positions.\\n        fut_row_to_cmd_id, fut_col_to_cmd_id = {0: m}, {0: m}\\n        ans = []\\n\\n        for i in range(m - 1, -1, -1):  # reverse iterating\\n            action = cmds[i]\\n            # since we\\'re going backward, we minus the step deltas\\n            curr_row_pos -= direc[action][0]\\n            curr_col_pos -= direc[action][1]\\n            maxstep = m - i  # this is the ideal situation where the robot never goes too far.\\n\\n            # let\\'s suppose there might be a future row pos `fut_row_pos` that make the robot goes too far upward,\\n            # then we\\'ll have: the delta in row pos (i.e. fut_row_pos - curr_row_pos) equals to `up_too_far`:\\n            #       fut_row_pos - curr_row_pos == up_too_far\\n            # the equation is equivalent to:\\n            # ==> fut_row_pos == curr_row_pos + up_too_far.\\n            # that means, the fut_row_pos, if exists, should be `curr_row_pos + up_too_far`.\\n            # So, if that value do exist in the future row pos dictionary, the robot\\n            # will go too far upward at that command id. (we discount the last command because it\\'s not allowed.)\\n            if curr_row_pos + up_too_far in fut_row_to_cmd_id:\\n                maxstep = min(maxstep, fut_row_to_cmd_id[curr_row_pos + up_too_far] - i - 1)\\n            # let\\'s suppose there might be a future row pos `fut_row_pos` that make the robot goes too far downward,\\n            # then we\\'ll have: the delta in row pos (i.e. fut_row_pos - curr_row_pos) equals to `down_too_far`:\\n            #       fut_row_pos - curr_row_pos == down_too_far\\n            # the equation is equivalent to:\\n            # ==> fut_row_pos == curr_row_pos + down_too_far.\\n            # that means, the fut_row_pos, if exists, should be `curr_row_pos + down_too_far`.\\n            # So, if that value do exist in the future row pos dictionary, the robot\\n            # will go too far downward at that command id. (we discount the last command because it\\'s not allowed.)\\n            if curr_row_pos + down_too_far in fut_row_to_cmd_id:\\n                maxstep = min(maxstep, fut_row_to_cmd_id[curr_row_pos + down_too_far] - i - 1)\\n\\n            # the reasoning here is the same as for `up_too_far`.\\n            if curr_col_pos + left_too_far in fut_col_to_cmd_id:\\n                maxstep = min(maxstep, fut_col_to_cmd_id[curr_col_pos + left_too_far] - i - 1)\\n            # the reasoning here is the same as for `down_too_far`.\\n            if curr_col_pos + right_too_far in fut_col_to_cmd_id:\\n                maxstep = min(maxstep, fut_col_to_cmd_id[curr_col_pos + right_too_far] - i - 1)\\n\\n            ans.append(maxstep)\\n\\n            # If the robot go too far multiple times in the future, we care\\n            # only about the occurrence that is closest to the scanline that is moving to the left.\\n            # so we\\'ll overwrite the entry in the future row pos dictionary if the entry already exists.\\n            fut_row_to_cmd_id[curr_row_pos] = i\\n            fut_col_to_cmd_id[curr_col_pos] = i\\n\\n        return ans[::-1]  # reverse the list\\n\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Linear time solution: scanning backward. fzh-to-review-recite.\\n    vector<int>\\n    executeInstructions(const int n, const vector<int>& startPos, const string commands) {\\n        const int m = commands.size();\\n        vector<int> res(m);\\n        if (n == 1) {\\n            return res;\\n        }\\n        const int startRow = startPos[0], startCol = startPos[1];\\n\\n        // row delta means the change in row positions\\n        // if the row delta equals `up_too_far`, the robot goes too far upward.\\n        const int upTooFar = -startRow - 1;\\n        // if the row delta equals `downTooFar`, the robot goes too far downward.\\n        const int downTooFar = n - startRow;\\n        // if the col delta equals `leftTooFar`, the robot goes too far leftward.\\n        const int leftTooFar = -startCol - 1;\\n        // if the col delta equals `rightTooFar`, the robot goes too far rightward.\\n        const int rightTooFar = n - startCol;\\n        // the current row/col positions of the robot in the virtual coordinate system.\\n        int currRowPos = 0, currColPos = 0;\\n\\n        // here `command` is synonymous with `instruction`.\\n        // u_map futRowToCmdId maps the future row positions to the command id.\\n        // futColToCmdId does the same thing for future col positions.\\n        unordered_map<int, int> futRowToCmdId{{0, m}};\\n        unordered_map<int, int> futColToCmdId{{0, m}};\\n\\n        for (int i = m - 1; i >= 0; --i) {\\n            // since we\\'re running the simulation in reverse order,\\n            // the pos would increment whereas in forward order it should decrement.\\n            switch (commands[i]) { // the current command\\n            case \\'L\\':\\n                ++currColPos;\\n                break;\\n            case \\'R\\':\\n                --currColPos;\\n                break;\\n            case \\'U\\':\\n                ++currRowPos;\\n                break;\\n            case \\'D\\':\\n                --currRowPos;\\n                break;\\n            }\\n            int maxSteps = m - i;\\n\\n            // let\\'s suppose there might be a future row pos `fut_row_pos` that make the robot goes\\n            // too far upward, then we\\'ll have: the delta in row pos (i.e. fut_row_pos -\\n            // curr_row_pos) equals to `up_too_far`:\\n            //       fut_row_pos - curr_row_pos == up_too_far\\n            // the equation is equivalent to:\\n            // ==> fut_row_pos == curr_row_pos + up_too_far.\\n            // that means, the fut_row_pos, if exists, should be `curr_row_pos + up_too_far`.\\n            // So, if that value do exist in the future row pos dictionary, the robot\\n            // will go too far upward at that command id. (we discount the last command because it\\'s\\n            // not allowed.)\\n            if (futRowToCmdId.count(currRowPos + upTooFar)) {\\n                maxSteps = min(maxSteps, futRowToCmdId[currRowPos + upTooFar] - i - 1);\\n            }\\n\\n            // let\\'s suppose there might be a future row pos `fut_row_pos` that make the robot goes\\n            // too far downward, then we\\'ll have: the delta in row pos (i.e. fut_row_pos -\\n            // curr_row_pos) equals to `down_too_far`:\\n            //       fut_row_pos - curr_row_pos == down_too_far\\n            // the equation is equivalent to:\\n            // ==> fut_row_pos == curr_row_pos + down_too_far.\\n            // that means, the fut_row_pos, if exists, should be `curr_row_pos + down_too_far`.\\n            // So, if that value do exist in the future row pos dictionary, the robot\\n            // will go too far downward at that command id. (we discount the last command because\\n            // it\\'s not allowed.)\\n            if (futRowToCmdId.count(currRowPos + downTooFar)) {\\n                maxSteps = min(maxSteps, futRowToCmdId[currRowPos + downTooFar] - i - 1);\\n            }\\n\\n            // for col pos, the reasoning are the same as the row pos\\n            if (futColToCmdId.count(currColPos + leftTooFar)) {\\n                maxSteps = min(maxSteps, futColToCmdId[currColPos + leftTooFar] - i - 1);\\n            }\\n            if (futColToCmdId.count(currColPos + rightTooFar)) {\\n                maxSteps = min(maxSteps, futColToCmdId[currColPos + rightTooFar] - i - 1);\\n            }\\n\\n            res[i] = maxSteps;\\n\\n            // If the robot goes too far multiple times in the future, we care\\n            // only about the occurrence that is closest to the scanline at `i` that is moving to\\n            // the left. so we\\'ll overwrite the entry in the future row pos dictionary if the entry\\n            // already exists.\\n            futRowToCmdId[currRowPos] = i;\\n            futColToCmdId[currColPos] = i;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\n# LC 2120. Execution of All Suffix Instructions Staying in a Grid.\\nclass Solution(object):\\n    def executeInstructions(self, n: int, startPos: List[int], cmds: str) -> List[int]:\\n        \"\"\"\\n        compute how many steps/instructions can the robot execute if it starts\\n        executing at s[i].\\n        :param n: the grid is an n * n grid\\n        :param startPos: [row, col] of the starting position\\n        :param cmds: string form of the commands/instructions\\n        :return: a list of integers indicating the number of steps if the robot starting at i-th instruction.\\n        \"\"\"\\n        m = len(cmds)  # instructions\\n        direc = {  #\\n            \\'U\\': [-1, 0],\\n            \\'D\\': [1, 0],\\n            \\'L\\': [0, -1],\\n            \\'R\\': [0, 1],\\n        }\\n        ROW_IDX, COL_IDX = 0, 1\\n\\n\\t\\t# row delta means the change in row positions\\n        # if the row delta equals `up_too_far`, the robot goes too far upward.\\n        up_too_far = -startPos[ROW_IDX] - 1\\n        up_too_far_negated = startPos[ROW_IDX] + 1\\n        # if the row delta equals `down_too_far`, the robot goes too far downward.\\n        down_too_far = n - startPos[ROW_IDX]\\n        # if the col delta equals `left_too_far`, the robot goes too far leftward.\\n        left_too_far = -startPos[COL_IDX] - 1\\n        left_too_far_negated = startPos[COL_IDX] + 1\\n        # if the col delta equals `right_too_far`, the robot goes too far rightward.\\n        right_too_far = n - startPos[COL_IDX]\\n        # the current row/col positions of the robot in the virtual coordinate system.\\n        curr_row_pos, curr_col_pos = 0, 0\\n        # here `command` is synonymous with `instruction`.\\n        # dict fut_row_to_cmd_id maps the future row positions to the command id.\\n        # fut_col_to_cmd_id do the same thing for future col positions.\\n        fut_row_to_cmd_id, fut_col_to_cmd_id = {0: m}, {0: m}\\n        ans = []\\n\\n        for i in range(m - 1, -1, -1):  # reverse iterating\\n            action = cmds[i]\\n            # since we\\'re going backward, we minus the step deltas\\n            curr_row_pos -= direc[action][0]\\n            curr_col_pos -= direc[action][1]\\n            maxstep = m - i  # this is the ideal situation where the robot never goes too far.\\n\\n            # let\\'s suppose there might be a future row pos `fut_row_pos` that make the robot goes too far upward,\\n            # then we\\'ll have: the delta in row pos (i.e. fut_row_pos - curr_row_pos) equals to `up_too_far`:\\n            #       fut_row_pos - curr_row_pos == up_too_far\\n            # the equation is equivalent to:\\n            # ==> fut_row_pos == curr_row_pos + up_too_far.\\n            # that means, the fut_row_pos, if exists, should be `curr_row_pos + up_too_far`.\\n            # So, if that value do exist in the future row pos dictionary, the robot\\n            # will go too far upward at that command id. (we discount the last command because it\\'s not allowed.)\\n            if curr_row_pos + up_too_far in fut_row_to_cmd_id:\\n                maxstep = min(maxstep, fut_row_to_cmd_id[curr_row_pos + up_too_far] - i - 1)\\n            # let\\'s suppose there might be a future row pos `fut_row_pos` that make the robot goes too far downward,\\n            # then we\\'ll have: the delta in row pos (i.e. fut_row_pos - curr_row_pos) equals to `down_too_far`:\\n            #       fut_row_pos - curr_row_pos == down_too_far\\n            # the equation is equivalent to:\\n            # ==> fut_row_pos == curr_row_pos + down_too_far.\\n            # that means, the fut_row_pos, if exists, should be `curr_row_pos + down_too_far`.\\n            # So, if that value do exist in the future row pos dictionary, the robot\\n            # will go too far downward at that command id. (we discount the last command because it\\'s not allowed.)\\n            if curr_row_pos + down_too_far in fut_row_to_cmd_id:\\n                maxstep = min(maxstep, fut_row_to_cmd_id[curr_row_pos + down_too_far] - i - 1)\\n\\n            # the reasoning here is the same as for `up_too_far`.\\n            if curr_col_pos + left_too_far in fut_col_to_cmd_id:\\n                maxstep = min(maxstep, fut_col_to_cmd_id[curr_col_pos + left_too_far] - i - 1)\\n            # the reasoning here is the same as for `down_too_far`.\\n            if curr_col_pos + right_too_far in fut_col_to_cmd_id:\\n                maxstep = min(maxstep, fut_col_to_cmd_id[curr_col_pos + right_too_far] - i - 1)\\n\\n            ans.append(maxstep)\\n\\n            # If the robot go too far multiple times in the future, we care\\n            # only about the occurrence that is closest to the scanline that is moving to the left.\\n            # so we\\'ll overwrite the entry in the future row pos dictionary if the entry already exists.\\n            fut_row_to_cmd_id[curr_row_pos] = i\\n            fut_col_to_cmd_id[curr_col_pos] = i\\n\\n        return ans[::-1]  # reverse the list\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971469,
                "title": "python-solution-easy-implementation-easy-to-understand-fast",
                "content": "```class Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        result = []\\n        for i in range (0,len(s)):\\n             ch= s [i:]\\n             actualPos = copy.copy(startPos)\\n             numberSteps=0\\n             for step in ch :\\n                    if step == \\'U\\':\\n                        actualPos[0]-=1\\n                    elif step == \\'D\\':\\n                        actualPos[0] +=1\\n                    elif step == \\'R\\':\\n                        actualPos[1]+=1\\n                    elif step ==\\'L\\':\\n                        actualPos[1]-=1\\n                        \\n                    ## Condition of leaving the grid \\n                    if actualPos[0]<0 or actualPos[1]<0 or actualPos[0]>n-1 or actualPos[1]> n-1 :\\n                        break\\n                    else: \\n                        numberSteps +=1\\n                        \\n                   \\n             result.append (numberSteps)\\n                    \\n        return result ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        result = []\\n        for i in range (0,len(s)):\\n             ch= s [i:]\\n             actualPos = copy.copy(startPos)\\n             numberSteps=0\\n             for step in ch :\\n                    if step == \\'U\\':\\n                        actualPos[0]-=1\\n                    elif step == \\'D\\':\\n                        actualPos[0] +=1\\n                    elif step == \\'R\\':\\n                        actualPos[1]+=1\\n                    elif step ==\\'L\\':\\n                        actualPos[1]-=1\\n                        \\n                    ## Condition of leaving the grid \\n                    if actualPos[0]<0 or actualPos[1]<0 or actualPos[0]>n-1 or actualPos[1]> n-1 :\\n                        break\\n                    else: \\n                        numberSteps +=1\\n                        \\n                   \\n             result.append (numberSteps)\\n                    \\n        return result ```",
                "codeTag": "Java"
            },
            {
                "id": 1768691,
                "title": "java-simulation",
                "content": "\\n**Code:**\\n\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        \\n        int[] ans = new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            int count = 0;\\n            int[] curr = {startPos[0], startPos[1]};\\n            \\n            for(int j=i;j<s.length();j++){\\n                switch(s.charAt(j)){\\n                    case \\'L\\':\\n                        curr[1] = curr[1]-1; break;\\n                    case \\'R\\':\\n                        curr[1] = curr[1]+1; break;\\n                    case \\'U\\':\\n                        curr[0] = curr[0]-1; break;\\n                    case \\'D\\':\\n                        curr[0] = curr[0]+1; break;\\n                }\\n                if(curr[0]<0||curr[0]==n||curr[1]<0||curr[1]==n)\\n                    break;\\n                count++;\\n            }\\n            ans[i] = count;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n**Code:**\\n\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        \\n        int[] ans = new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            int count = 0;\\n            int[] curr = {startPos[0], startPos[1]};\\n            \\n            for(int j=i;j<s.length();j++){\\n                switch(s.charAt(j)){\\n                    case \\'L\\':\\n                        curr[1] = curr[1]-1; break;\\n                    case \\'R\\':\\n                        curr[1] = curr[1]+1; break;\\n                    case \\'U\\':\\n                        curr[0] = curr[0]-1; break;\\n                    case \\'D\\':\\n                        curr[0] = curr[0]+1; break;\\n                }\\n                if(curr[0]<0||curr[0]==n||curr[1]<0||curr[1]==n)\\n                    break;\\n                count++;\\n            }\\n            ans[i] = count;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1730846,
                "title": "beginner-friendly-java-solution",
                "content": "**Time Complexity : O(n*n)**\\n```java []\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int arr[] = new int[s.length()];\\n        for(int i=0; i<s.length(); i++){\\n            int xid = startPos[1], yid = startPos[0], count = 0;\\n            for(int j=i; j<s.length(); j++){\\n                if(s.charAt(j) == \\'R\\')  xid++;\\n                if(s.charAt(j) == \\'L\\')  xid--;\\n                if(s.charAt(j) == \\'D\\')  yid++;\\n                if(s.charAt(j) == \\'U\\')  yid--;\\n                if(xid < 0 || yid < 0 || xid >= n || yid >= n)  break;\\n                else count++;\\n            }\\n            arr[i] = count;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int arr[] = new int[s.length()];\\n        for(int i=0; i<s.length(); i++){\\n            int xid = startPos[1], yid = startPos[0], count = 0;\\n            for(int j=i; j<s.length(); j++){\\n                if(s.charAt(j) == \\'R\\')  xid++;\\n                if(s.charAt(j) == \\'L\\')  xid--;\\n                if(s.charAt(j) == \\'D\\')  yid++;\\n                if(s.charAt(j) == \\'U\\')  yid--;\\n                if(xid < 0 || yid < 0 || xid >= n || yid >= n)  break;\\n                else count++;\\n            }\\n            arr[i] = count;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729621,
                "title": "60-fast-c-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int count=0;\\n        vector<int> answer;\\n        int y=startPos[0],x=startPos[1];\\n        for(int i=0;i<s.length();i++){\\n            count=0;\\n            y=startPos[0],x=startPos[1];\\n            for(int j=i;j<s.length();j++){\\n                if(s[j]==\\'R\\'){x++;}\\n                else if(s[j]==\\'L\\'){x--;}\\n                else if(s[j]==\\'U\\'){y--;}\\n                else{y++;}\\n                \\n                if((x<n&&x>=0)&&(y<n&&y>=0)){count++;}\\n                else{break;}\\n            }\\n            answer.push_back(count);\\n        }\\n        return answer;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int count=0;\\n        vector<int> answer;\\n        int y=startPos[0],x=startPos[1];\\n        for(int i=0;i<s.length();i++){\\n            count=0;\\n            y=startPos[0],x=startPos[1];\\n            for(int j=i;j<s.length();j++){\\n                if(s[j]==\\'R\\'){x++;}",
                "codeTag": "Java"
            },
            {
                "id": 1699643,
                "title": "java-userfriendly-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        \\n        int m=s.length();\\n        int ans[]=new int[m];\\n        \\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            int x=startPos[0];\\n            int y=startPos[1];\\n            int count=0;\\n            for(int j=i;j<m;j++)\\n            {\\n                if(s.charAt(j)==\\'L\\')\\n                    y--;\\n                else if(s.charAt(j)==\\'R\\')\\n                    y++;\\n                else if(s.charAt(j)==\\'U\\')\\n                    x--;\\n                else \\n                    x++;\\n                \\n                if((x>=0 && x<n) && (y>=0 && y<n))\\n                    count++;\\n                else \\n                    break;\\n            }\\n            ans[i]=count;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        \\n        int m=s.length();\\n        int ans[]=new int[m];\\n        \\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            int x=startPos[0];\\n            int y=startPos[1];\\n            int count=0;\\n            for(int j=i;j<m;j++)\\n            {\\n                if(s.charAt(j)==\\'L\\')\\n                    y--;\\n                else if(s.charAt(j)==\\'R\\')\\n                    y++;\\n                else if(s.charAt(j)==\\'U\\')\\n                    x--;\\n                else \\n                    x++;\\n                \\n                if((x>=0 && x<n) && (y>=0 && y<n))\\n                    count++;\\n                else \\n                    break;\\n            }\\n            ans[i]=count;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657037,
                "title": "c-basic-easy-understanding-brute-force-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int i, int j,int n){\\n         return (i>=0 && j>=0 && i <n && j<n);\\n    }  \\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int x = startPos[0];\\n        int y = startPos[1];\\n        vector<int> ans;\\n        for(int i = 0;i<s.size();i++){\\n           int x = startPos[0];\\n           \\n           int y = startPos[1];\\n           int count = 0;\\n           for(int j=i;j<s.size();j++){\\n      \\n               if(s[j] == \\'L\\'){\\n                   if(check(x,y-1,n)){\\n                       x = x;\\n                       y = y-1;\\n                       count++;\\n                       \\n                   }\\n                   else {\\n                       break;\\n                       count = 0;\\n                   }\\n               }\\n               if(s[j] == \\'U\\'){\\n                   \\n                   if(check(x-1,y,n)){\\n                       x = x-1;\\n                       y = y;\\n                       count++;\\n                   }\\n                   else {\\n                       break;\\n                       count = 0;\\n                   }\\n               }\\n               if(s[j] == \\'R\\'){\\n                   if(check(x,y+1,n)){\\n                       x = x;\\n                       y = y+1;\\n                       count++;\\n                   }\\n                   else {\\n                       break;\\n                       count = 0;\\n                   }\\n               }\\n               if(s[j] == \\'D\\'){\\n                   if(check(x+1,y,n)){\\n                       x = x+1;\\n                       y = y;\\n                       count++;\\n                   }\\n                   else {\\n                       break;\\n                       count = 0;\\n                   }\\n               }\\n               \\n               \\n           }\\n            ans.push_back(count);\\n        } return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int i, int j,int n){\\n         return (i>=0 && j>=0 && i <n && j<n);\\n    }  \\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int x = startPos[0];\\n        int y = startPos[1];\\n        vector<int> ans;\\n        for(int i = 0;i<s.size();i++){\\n           int x = startPos[0];\\n           \\n           int y = startPos[1];\\n           int count = 0;\\n           for(int j=i;j<s.size();j++){\\n      \\n               if(s[j] == \\'L\\'){\\n                   if(check(x,y-1,n)){\\n                       x = x;\\n                       y = y-1;\\n                       count++;\\n                       \\n                   }\\n                   else {\\n                       break;\\n                       count = 0;\\n                   }\\n               }\\n               if(s[j] == \\'U\\'){\\n                   \\n                   if(check(x-1,y,n)){\\n                       x = x-1;\\n                       y = y;\\n                       count++;\\n                   }\\n                   else {\\n                       break;\\n                       count = 0;\\n                   }\\n               }\\n               if(s[j] == \\'R\\'){\\n                   if(check(x,y+1,n)){\\n                       x = x;\\n                       y = y+1;\\n                       count++;\\n                   }\\n                   else {\\n                       break;\\n                       count = 0;\\n                   }\\n               }\\n               if(s[j] == \\'D\\'){\\n                   if(check(x+1,y,n)){\\n                       x = x+1;\\n                       y = y;\\n                       count++;\\n                   }\\n                   else {\\n                       break;\\n                       count = 0;\\n                   }\\n               }\\n               \\n               \\n           }\\n            ans.push_back(count);\\n        } return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654968,
                "title": "c-easy-to-understand-faster-than-85",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int l=s.length();\\n        int x, y;\\n        int counter;\\n        vector<int> ans;\\n        for(int i=0;i<l;i++)\\n        {\\n            counter=0;\\n            x=startPos[1];\\n            y=startPos[0];\\n            for(int j=i;j<l;j++)\\n            {\\n                if(s[j]==\\'R\\')\\n                    x++;\\n                if(s[j]==\\'L\\')\\n                    x--;\\n                if(s[j]==\\'U\\')\\n                    y--;\\n                if(s[j]==\\'D\\')\\n                    y++;\\n                if(x<0 || y<0 || x>=n || y>=n)\\n                    break;\\n                else\\n                    counter++;\\n            }\\n            ans.push_back(counter);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int l=s.length();\\n        int x, y;\\n        int counter;\\n        vector<int> ans;\\n        for(int i=0;i<l;i++)\\n        {\\n            counter=0;\\n            x=startPos[1];\\n            y=startPos[0];\\n            for(int j=i;j<l;j++)\\n            {\\n                if(s[j]==\\'R\\')\\n                    x++;\\n                if(s[j]==\\'L\\')\\n                    x--;\\n                if(s[j]==\\'U\\')\\n                    y--;\\n                if(s[j]==\\'D\\')\\n                    y++;\\n                if(x<0 || y<0 || x>=n || y>=n)\\n                    break;\\n                else\\n                    counter++;\\n            }\\n            ans.push_back(counter);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650420,
                "title": "brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        \\n        \\n        \\n        vector<int> ans;\\n        \\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n            int x = startPos[0];\\n            int y = startPos[1];\\n            int j=i;\\n            int count=0;\\n            \\n            while(true){\\n                \\n                if(x>=n || x<0 || y>=n || y<0) break;\\n                if(s.size()==j) break;\\n                \\n                if(s[j]==\\'L\\'){\\n                    y-=1;\\n                }\\n                else if(s[j]==\\'R\\'){\\n                    y+=1;\\n                }\\n                else if(s[j]==\\'U\\'){\\n                    x-=1;\\n                }\\n                else if(s[j]==\\'D\\'){\\n                    x+=1;\\n                }\\n                \\n                j+=1;\\n                if(x<n and x>=0 and y<n and y>=0){\\n                     count+=1;\\n                }\\n            }\\n            \\n            \\n            ans.push_back(count);\\n        }\\n        \\n         \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        \\n        \\n        \\n        vector<int> ans;\\n        \\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n            int x = startPos[0];\\n            int y = startPos[1];\\n            int j=i;\\n            int count=0;\\n            \\n            while(true){\\n                \\n                if(x>=n || x<0 || y>=n || y<0) break;\\n                if(s.size()==j) break;\\n                \\n                if(s[j]==\\'L\\'){\\n                    y-=1;\\n                }\\n                else if(s[j]==\\'R\\'){\\n                    y+=1;\\n                }\\n                else if(s[j]==\\'U\\'){\\n                    x-=1;\\n                }\\n                else if(s[j]==\\'D\\'){\\n                    x+=1;\\n                }\\n                \\n                j+=1;\\n                if(x<n and x>=0 and y<n and y>=0){\\n                     count+=1;\\n                }\\n            }\\n            \\n            \\n            ans.push_back(count);\\n        }\\n        \\n         \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649474,
                "title": "python-solution-quite-clean",
                "content": "```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        x = startPos[0]\\n        y = startPos[1]\\n        result = []\\n        def factory(order,x,y):\\n            if order == \"R\":\\n                x,y = right(x,y)\\n            elif order == \"L\":\\n                x,y = left(x,y)\\n            elif order == \"U\":\\n                x,y = up(x,y)\\n            elif order == \"D\":\\n                x,y = down(x,y)\\n            else:\\n                print(\"something is wrong\")\\n            return x,y\\n        #if x >= n or y >= n or x < 0 or y<0 -> stop\\n        def checker(x,y,n):\\n            if x >= n or y >= n or x<0 or y<0:\\n                return False\\n            else:\\n                return True\\n            \\n        def right(x,y):\\n            x += 1\\n            return x,y \\n        def left(x,y):\\n            x -= 1\\n            return x,y\\n        def up(x,y):\\n            y -= 1\\n            return x,y\\n        def down(x,y):\\n            y += 1\\n            return x,y\\n        for i in range(0,len(s)):\\n            x = startPos[1]\\n            y = startPos[0]\\n            count = 0\\n            for order in s[i:]:\\n                x,y = factory(order,x,y)\\n                if checker(x,y,n):\\n                    count += 1\\n                else:\\n                    \\n                    break\\n            result.append(count)\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        x = startPos[0]\\n        y = startPos[1]\\n        result = []\\n        def factory(order,x,y):\\n            if order == \"R\":\\n                x,y = right(x,y)\\n            elif order == \"L\":\\n                x,y = left(x,y)\\n            elif order == \"U\":\\n                x,y = up(x,y)\\n            elif order == \"D\":\\n                x,y = down(x,y)\\n            else:\\n                print(\"something is wrong\")\\n            return x,y\\n        #if x >= n or y >= n or x < 0 or y<0 -> stop\\n        def checker(x,y,n):\\n            if x >= n or y >= n or x<0 or y<0:\\n                return False\\n            else:\\n                return True\\n            \\n        def right(x,y):\\n            x += 1\\n            return x,y \\n        def left(x,y):\\n            x -= 1\\n            return x,y\\n        def up(x,y):\\n            y -= 1\\n            return x,y\\n        def down(x,y):\\n            y += 1\\n            return x,y\\n        for i in range(0,len(s)):\\n            x = startPos[1]\\n            y = startPos[0]\\n            count = 0\\n            for order in s[i:]:\\n                x,y = factory(order,x,y)\\n                if checker(x,y,n):\\n                    count += 1\\n                else:\\n                    \\n                    break\\n            result.append(count)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649231,
                "title": "java-recursion",
                "content": "```\\npublic int[] executeInstructions(int n, int[] startPos, String s) {\\n        int [] result = new int[s.length()];\\n        int sum = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            sum = executionCount(n, startPos[0], startPos[1], s.substring(i, s.length()), 0);\\n            result[i] = sum;\\n            sum = 0;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public int executionCount(int n, int i, int j, String s, int index) {\\n        if (i < 0 || i > n - 1 || j < 0 || j > n - 1) return -1;\\n        if (index == s.length()) return 0;\\n        \\n        char ch = s.charAt(index);\\n        index++;\\n               \\n        if (ch == \\'R\\') j++;\\n        if (ch == \\'L\\') j--;\\n        if (ch == \\'U\\') i--;\\n        if (ch == \\'D\\') i++;\\n\\n        return 1 + executionCount(n, i, j, s, index);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] executeInstructions(int n, int[] startPos, String s) {\\n        int [] result = new int[s.length()];\\n        int sum = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            sum = executionCount(n, startPos[0], startPos[1], s.substring(i, s.length()), 0);\\n            result[i] = sum;\\n            sum = 0;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public int executionCount(int n, int i, int j, String s, int index) {\\n        if (i < 0 || i > n - 1 || j < 0 || j > n - 1) return -1;\\n        if (index == s.length()) return 0;\\n        \\n        char ch = s.charAt(index);\\n        index++;\\n               \\n        if (ch == \\'R\\') j++;\\n        if (ch == \\'L\\') j--;\\n        if (ch == \\'U\\') i--;\\n        if (ch == \\'D\\') i++;\\n\\n        return 1 + executionCount(n, i, j, s, index);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1649200,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        res = []\\n        rows = cols = n\\n        \\n        for i in range(len(s)):\\n            steps = 0; row, col = startPos; j = i\\n            \\n            while j < len(s):\\n                if s[j] == \\'L\\':\\n                    col -= 1\\n                elif s[j] == \\'R\\':\\n                    col += 1\\n                elif s[j] == \\'U\\':\\n                    row -= 1\\n                else:\\n                    row += 1\\n                    \\n                j += 1\\n                if 0 <= row < rows and 0 <= col < cols:\\n                    steps += 1\\n                else:\\n                    break\\n                \\n            res.append(steps)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        res = []\\n        rows = cols = n\\n        \\n        for i in range(len(s)):\\n            steps = 0; row, col = startPos; j = i\\n            \\n            while j < len(s):\\n                if s[j] == \\'L\\':\\n                    col -= 1\\n                elif s[j] == \\'R\\':\\n                    col += 1\\n                elif s[j] == \\'U\\':\\n                    row -= 1\\n                else:\\n                    row += 1\\n                    \\n                j += 1\\n                if 0 <= row < rows and 0 <= col < cols:\\n                    steps += 1\\n                else:\\n                    break\\n                \\n            res.append(steps)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649022,
                "title": "python-dfs-easy-read",
                "content": "\\n     class Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        dir_check = {\\n            \\'R\\': [0, 1],\\n            \\'L\\': [0, -1],\\n            \\'U\\': [-1,0],\\n            \\'D\\': [1,0]\\n        }\\n        \\n        def dfs(curr_x, curr_y, res, i):\\n            if i < len(s):\\n                dir_x, dir_y = dir_check[s[i]]\\n\\t\\t\\t\\t\\n                new_dir_x = dir_x + curr_x\\n                new_dir_y = dir_y + curr_y\\n\\n                if new_dir_x >= 0 and new_dir_x < n and new_dir_y >= 0 and new_dir_y < n:\\n                    res += 1\\n                    res = dfs(new_dir_x, new_dir_y, res, i + 1)    \\n            return res \\n\\t\\t\\t\\n        ans = []\\n        for i in range(len(s)):\\n            ans.append(dfs(startPos[0], startPos[1], 0, i))\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        dir_check = {\\n            \\'R\\': [0, 1],\\n            \\'L\\': [0, -1],\\n            \\'U\\': [-1,0],\\n            \\'D\\': [1,0]\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1648366,
                "title": "c-simulation-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n         vector<int> ans;\\n        \\n           for(int i=0; i<s.size(); i++){\\n               int sr = startPos[0];\\n               int sc = startPos[1];\\n               int cnt = 0;\\n               bool flag = false;\\n               for(int j = i; j<s.size(); j++){\\n                                   \\n                   char ch = s[j];\\n                   if(ch == \\'L\\'){\\n                          if(sc > 0 ) {cnt++; sc-=1;}\\n                          else {flag = true ;break;}\\n                   }\\n                   if(ch == \\'R\\'){\\n                          if(sc < n-1) {cnt++; sc+=1;}\\n                          else {flag = true ;break;}\\n                   }\\n                   if(ch == \\'U\\'){\\n                          if(sr > 0 ) {cnt++; sr-=1;}\\n                          else {flag = true ;break;}\\n                   }\\n                   if(ch == \\'D\\'){\\n                          if(sr < n-1 ) {cnt++; sr+=1;}\\n                          else {flag = true ;break;}\\n                   }\\n                   \\n               }\\n               if(!flag) ans.push_back(s.size() - i);\\n                   else ans.push_back(cnt);\\n                  \\n           }\\n              return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n         vector<int> ans;\\n        \\n           for(int i=0; i<s.size(); i++){\\n               int sr = startPos[0];\\n               int sc = startPos[1];\\n               int cnt = 0;\\n               bool flag = false;\\n               for(int j = i; j<s.size(); j++){\\n                                   \\n                   char ch = s[j];\\n                   if(ch == \\'L\\'){\\n                          if(sc > 0 ) {cnt++; sc-=1;}",
                "codeTag": "Java"
            },
            {
                "id": 1648068,
                "title": "c-easy-to-understand",
                "content": "```\\nvoid findInstructionsNo(int n,int row,int col,string &s,vector<int>& res,int count,int index)\\n    {\\n        if(row>=n || col>=n || row<0 || col<0 )\\n        {\\n            count--;\\n            res.push_back(count);\\n            return;\\n        }\\n        \\n        if(index>=s.length())\\n        {\\n            res.push_back(count);\\n            return;\\n        }\\n        \\n        \\n        int c=s[index];\\n        if(c==\\'U\\')\\n            findInstructionsNo(n,row-1,col,s,res,count+1,index+1);\\n        if(c==\\'D\\')\\n            findInstructionsNo(n,row+1,col,s,res,count+1,index+1);\\n        if(c==\\'L\\')\\n            findInstructionsNo(n,row,col-1,s,res,count+1,index+1);\\n        if(c==\\'R\\')\\n            findInstructionsNo(n,row,col+1,s,res,count+1,index+1);\\n    }\\n    \\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) \\n    {\\n        vector<int> res;\\n        while(s.length()>0)\\n        {\\n            findInstructionsNo(n,startPos[0],startPos[1],s,res,0,0);\\n            s=s.substr(1);\\n        }\\n            return res;\\n    }",
                "solutionTags": [],
                "code": "```\\nvoid findInstructionsNo(int n,int row,int col,string &s,vector<int>& res,int count,int index)\\n    {\\n        if(row>=n || col>=n || row<0 || col<0 )\\n        {\\n            count--;\\n            res.push_back(count);\\n            return;\\n        }\\n        \\n        if(index>=s.length())\\n        {\\n            res.push_back(count);\\n            return;\\n        }\\n        \\n        \\n        int c=s[index];\\n        if(c==\\'U\\')\\n            findInstructionsNo(n,row-1,col,s,res,count+1,index+1);\\n        if(c==\\'D\\')\\n            findInstructionsNo(n,row+1,col,s,res,count+1,index+1);\\n        if(c==\\'L\\')\\n            findInstructionsNo(n,row,col-1,s,res,count+1,index+1);\\n        if(c==\\'R\\')\\n            findInstructionsNo(n,row,col+1,s,res,count+1,index+1);\\n    }\\n    \\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) \\n    {\\n        vector<int> res;\\n        while(s.length()>0)\\n        {\\n            findInstructionsNo(n,startPos[0],startPos[1],s,res,0,0);\\n            s=s.substr(1);\\n        }\\n            return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1647904,
                "title": "simple-without-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        // can do with dfs by making direction grid but lets go with an easy way\\n        int d=s.size();\\n        vector<int>ans(d,0);\\n           int x=startPos[0];\\n        int y=startPos[1];\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            ans[i]=valuekyahai(n,x,y,s,i);\\n            \\n        }\\n        return ans;\\n    }\\n    int count;\\n    int valuekyahai(int n,int row,int col,string s,int pos)\\n    {\\n        count=0;\\n        for(int i=pos;i<s.size();i++)\\n        {\\n            if(s[i]==\\'L\\')\\n            {\\n                col--;\\n            }\\n            else if(s[i]==\\'R\\')\\n            {\\n                col++;\\n            }\\n            else if(s[i]==\\'U\\')\\n            {\\n                row--;\\n            }\\n            else if(s[i]==\\'D\\')\\n            {\\n                row++;\\n            }\\n            // lets check for the base case\\n            if(row<0 || col<0 ||row>=n || col>=n)\\n                break;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        // can do with dfs by making direction grid but lets go with an easy way\\n        int d=s.size();\\n        vector<int>ans(d,0);\\n           int x=startPos[0];\\n        int y=startPos[1];\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            ans[i]=valuekyahai(n,x,y,s,i);\\n            \\n        }\\n        return ans;\\n    }\\n    int count;\\n    int valuekyahai(int n,int row,int col,string s,int pos)\\n    {\\n        count=0;\\n        for(int i=pos;i<s.size();i++)\\n        {\\n            if(s[i]==\\'L\\')\\n            {\\n                col--;\\n            }\\n            else if(s[i]==\\'R\\')\\n            {\\n                col++;\\n            }\\n            else if(s[i]==\\'U\\')\\n            {\\n                row--;\\n            }\\n            else if(s[i]==\\'D\\')\\n            {\\n                row++;\\n            }\\n            // lets check for the base case\\n            if(row<0 || col<0 ||row>=n || col>=n)\\n                break;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647834,
                "title": "can-anyone-please-explain-this-o-n-6ms-100-java-code",
                "content": "I found this solution from **Accepted Solutions Runtime Distribution** on **Submission Detail** page. It is a sample 6 ms submission.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8b530df6-5b2e-40d2-b325-f7e4d790f0e9_1640498675.6954873.png)\\n\\n\\n``` java\\nclass Solution {\\n    public int[] executeInstructions(int m, int[] startPos, String s) {\\n        int [] hor = new int [2001];\\n        int [] ver = new int [2001];\\n        \\n        Arrays.fill(hor, s.length());\\n        Arrays.fill(ver, s.length());\\n        \\n        int h = 1000;\\n        int v = 1000;\\n        \\n        int lB = startPos[1] + 1;\\n        int rB = m - startPos[1];\\n        int uB = startPos[0] + 1;\\n        int dB = m - startPos[0];\\n        \\n        int [] result = new int [s.length()];\\n        int res;\\n        \\n        char c;\\n        \\n        for (int i = s.length() - 1; i >= 0; --i){\\n            c = s.charAt(i);\\n            \\n            if (c == \\'U\\')\\n                ver[v++] = i; \\n            else if (c == \\'D\\')\\n                ver[v--] = i;\\n            else if (c == \\'R\\')\\n                hor[h--] = i;\\n            else\\n                hor[h++] = i;\\n            \\n            \\n            res = s.length();\\n            res = Math.min(res, hor[h - lB] );\\n            res = Math.min(res, hor[h + rB] );\\n            res = Math.min(res, ver[v - uB]);\\n            res = Math.min(res, ver[v + dB]);\\n            \\n            result[i] = res - i;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass Solution {\\n    public int[] executeInstructions(int m, int[] startPos, String s) {\\n        int [] hor = new int [2001];\\n        int [] ver = new int [2001];\\n        \\n        Arrays.fill(hor, s.length());\\n        Arrays.fill(ver, s.length());\\n        \\n        int h = 1000;\\n        int v = 1000;\\n        \\n        int lB = startPos[1] + 1;\\n        int rB = m - startPos[1];\\n        int uB = startPos[0] + 1;\\n        int dB = m - startPos[0];\\n        \\n        int [] result = new int [s.length()];\\n        int res;\\n        \\n        char c;\\n        \\n        for (int i = s.length() - 1; i >= 0; --i){\\n            c = s.charAt(i);\\n            \\n            if (c == \\'U\\')\\n                ver[v++] = i; \\n            else if (c == \\'D\\')\\n                ver[v--] = i;\\n            else if (c == \\'R\\')\\n                hor[h--] = i;\\n            else\\n                hor[h++] = i;\\n            \\n            \\n            res = s.length();\\n            res = Math.min(res, hor[h - lB] );\\n            res = Math.min(res, hor[h + rB] );\\n            res = Math.min(res, ver[v - uB]);\\n            res = Math.min(res, ver[v + dB]);\\n            \\n            result[i] = res - i;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647829,
                "title": "most-clear-java-solution",
                "content": "```\\n public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int [] result = new int [s.length()];\\n        int move = 0;\\n        for (int i = 0; i < s.length(); i++){\\n            int x = startPos[0];\\n            int y = startPos[1];\\n            for (int j = i; j < s.length(); j++){\\n                char ch = s.charAt(j);\\n                if (ch == \\'L\\')\\n                    y--;\\n                else if (ch == \\'R\\')\\n                    y++;\\n                else if (ch == \\'D\\')\\n                    x++;\\n                else if (ch == \\'U\\')\\n                    x--;\\n                if (x < 0 || y < 0 || x >= n || y >= n)\\n                    break;\\n                move++;\\n            }\\n            result[i] = move;\\n            move = 0;\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int [] result = new int [s.length()];\\n        int move = 0;\\n        for (int i = 0; i < s.length(); i++){\\n            int x = startPos[0];\\n            int y = startPos[1];\\n            for (int j = i; j < s.length(); j++){\\n                char ch = s.charAt(j);\\n                if (ch == \\'L\\')\\n                    y--;\\n                else if (ch == \\'R\\')\\n                    y++;\\n                else if (ch == \\'D\\')\\n                    x++;\\n                else if (ch == \\'U\\')\\n                    x--;\\n                if (x < 0 || y < 0 || x >= n || y >= n)\\n                    break;\\n                move++;\\n            }\\n            result[i] = move;\\n            move = 0;\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1647602,
                "title": "python-simple-solution-brute-force-clean-and-easy-to-understand",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n```\\nclass Solution(object):\\n    def executeInstructions(self, n, startPos, s):\\n        d = {\\'R\\': (0, 1), \\'D\\': (1, 0), \\'L\\': (0, -1), \\'U\\': (-1, 0)}\\n        ans = [0] * len(s)\\n        for i in range(len(s)):\\n            [x, y] = startPos\\n            for j in range(i, len(s)):\\n                x += d[s[j]][0]\\n                y += d[s[j]][1]\\n                if 0 <= x < n and 0 <= y < n:\\n                    ans[i] += 1\\n                else:\\n                    break\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def executeInstructions(self, n, startPos, s):\\n        d = {\\'R\\': (0, 1), \\'D\\': (1, 0), \\'L\\': (0, -1), \\'U\\': (-1, 0)}\\n        ans = [0] * len(s)\\n        for i in range(len(s)):\\n            [x, y] = startPos\\n            for j in range(i, len(s)):\\n                x += d[s[j]][0]\\n                y += d[s[j]][1]\\n                if 0 <= x < n and 0 <= y < n:\\n                    ans[i] += 1\\n                else:\\n                    break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647581,
                "title": "python-interval-tree-time-o-m-log-2-m",
                "content": "First, simulate all the moves once, assuming the robot starts at the top left. Then, create interval trees for the row and column positions. The interval tree nodes are in the form of `(min_val, max_val)`.\\nWith this, we can query the interval tree to find the ranges of rows and column movements of the robot for any subarray of commands.\\nFinally, for each element of the answer, we use binary search to find the last command which does not move the robot outside of the grid.\\n\\n```\\ndef f(a, b):\\n    return (min(a[0], b[0]), max(a[1], b[1]))\\n\\n\\nclass IntervalTree:\\n    def __init__(self, t):\\n        pow2 = 1\\n        n = len(t)\\n        while pow2 < n:\\n            pow2 <<= 1\\n        self.first_leaf = pow2 - 1\\n        self.t = [None] * self.first_leaf\\n        self.t.extend(t)\\n        self.t.extend((0, 0) for _ in range(pow2 - n))\\n        for i in reversed(range(self.first_leaf)):\\n            self.t[i] = f(self.t[2 * i + 1], self.t[2 * i + 2])\\n    \\n    def query(self, lpos, rpos):\\n        l = lpos + self.first_leaf\\n        r = rpos + self.first_leaf\\n        res = f(self.t[l], self.t[r])\\n        while (l - 1) // 2 < (r - 1) // 2:\\n            if l & 1:\\n                res = f(res, self.t[l + 1])\\n            if not r & 1:\\n                res = f(self.t[r - 1], res)\\n            l = (l - 1) // 2\\n            r = (r - 1) // 2\\n        return res\\n    \\n    def get(self, pos):\\n        i = pos + self.first_leaf\\n        return self.t[i]\\n    \\n    \\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        r, c = 0, 0\\n        rs = []\\n        cs = []\\n        for ch in s:\\n            if ch == \\'L\\':\\n                c -= 1\\n            elif ch == \\'R\\':\\n                c += 1\\n            elif ch == \\'U\\':\\n                r -= 1\\n            else:\\n                r += 1\\n            rs.append((r, r))\\n            cs.append((c, c))\\n        rit = IntervalTree(rs)\\n        cit = IntervalTree(cs)\\n        \\n        answer = []\\n        \\n        for i in range(len(s)):\\n            lx, rx = i, len(s)\\n            while lx < rx:\\n                mx = lx + (rx - lx) // 2\\n                rr = rit.query(i, mx)\\n                cc = cit.query(i, mx)\\n                if i:\\n                    rstart = rit.get(i - 1)[0]\\n                    cstart = cit.get(i - 1)[0]\\n                else:\\n                    rstart, cstart = 0, 0\\n                if startPos[0] + rr[0] - rstart in range(n) and startPos[0] + rr[1] - rstart in range(n) and \\\\\\n                    startPos[1] + cc[0] - cstart in range(n) and startPos[1] + cc[1] - cstart in range(n):\\n                    lx = mx + 1\\n                else:\\n                    rx = mx\\n            answer.append(lx - i)\\n        \\n        return answer\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef f(a, b):\\n    return (min(a[0], b[0]), max(a[1], b[1]))\\n\\n\\nclass IntervalTree:\\n    def __init__(self, t):\\n        pow2 = 1\\n        n = len(t)\\n        while pow2 < n:\\n            pow2 <<= 1\\n        self.first_leaf = pow2 - 1\\n        self.t = [None] * self.first_leaf\\n        self.t.extend(t)\\n        self.t.extend((0, 0) for _ in range(pow2 - n))\\n        for i in reversed(range(self.first_leaf)):\\n            self.t[i] = f(self.t[2 * i + 1], self.t[2 * i + 2])\\n    \\n    def query(self, lpos, rpos):\\n        l = lpos + self.first_leaf\\n        r = rpos + self.first_leaf\\n        res = f(self.t[l], self.t[r])\\n        while (l - 1) // 2 < (r - 1) // 2:\\n            if l & 1:\\n                res = f(res, self.t[l + 1])\\n            if not r & 1:\\n                res = f(self.t[r - 1], res)\\n            l = (l - 1) // 2\\n            r = (r - 1) // 2\\n        return res\\n    \\n    def get(self, pos):\\n        i = pos + self.first_leaf\\n        return self.t[i]\\n    \\n    \\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        r, c = 0, 0\\n        rs = []\\n        cs = []\\n        for ch in s:\\n            if ch == \\'L\\':\\n                c -= 1\\n            elif ch == \\'R\\':\\n                c += 1\\n            elif ch == \\'U\\':\\n                r -= 1\\n            else:\\n                r += 1\\n            rs.append((r, r))\\n            cs.append((c, c))\\n        rit = IntervalTree(rs)\\n        cit = IntervalTree(cs)\\n        \\n        answer = []\\n        \\n        for i in range(len(s)):\\n            lx, rx = i, len(s)\\n            while lx < rx:\\n                mx = lx + (rx - lx) // 2\\n                rr = rit.query(i, mx)\\n                cc = cit.query(i, mx)\\n                if i:\\n                    rstart = rit.get(i - 1)[0]\\n                    cstart = cit.get(i - 1)[0]\\n                else:\\n                    rstart, cstart = 0, 0\\n                if startPos[0] + rr[0] - rstart in range(n) and startPos[0] + rr[1] - rstart in range(n) and \\\\\\n                    startPos[1] + cc[0] - cstart in range(n) and startPos[1] + cc[1] - cstart in range(n):\\n                    lx = mx + 1\\n                else:\\n                    rx = mx\\n            answer.append(lx - i)\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647537,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>dir={{-1,0},{1,0},{0,1},{0,-1}};\\n    int find(string s,int n,int x,int y)\\n    {\\n        auto is_safe=[&](int nx,int ny)\\n        {\\n            if(nx>=0&&ny>=0&&nx<n&&ny<n)\\n            {\\n                return true;\\n            }\\n            return false;\\n        };\\n        int count=0;\\n        int nx=x;\\n        int ny=y;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'L\\')\\n            {\\n                nx+=dir[3].first;\\n                ny+=dir[3].second;\\n            }\\n            else if(s[i]==\\'R\\')\\n            {\\n                 nx+=dir[2].first;\\n                ny+=dir[2].second;\\n            }\\n            else if(s[i]==\\'U\\')\\n            {\\n                 nx+=dir[0].first;\\n                ny+=dir[0].second;\\n            }\\n            else if(s[i]==\\'D\\')\\n            {\\n                 nx+=dir[1].first;\\n                ny+=dir[1].second;\\n            }\\n            // cout<<nx<<\"  \"<<ny<<\"    \";\\n              if(is_safe(nx,ny))\\n                {\\n                    count++;\\n                }\\n                else\\n                {\\n                    return count;\\n                }\\n           \\n        }\\n        return count;\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& nums, string s) \\n    {\\n        vector<int>ans(s.size(),0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int count=find(s.substr(i),n,nums[0],nums[1]);\\n                ans[i]=count;\\n            // cout<<\"new\"<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>dir={{-1,0},{1,0},{0,1},{0,-1}};\\n    int find(string s,int n,int x,int y)\\n    {\\n        auto is_safe=[&](int nx,int ny)\\n        {\\n            if(nx>=0&&ny>=0&&nx<n&&ny<n)\\n            {\\n                return true;\\n            }\\n            return false;\\n        };\\n        int count=0;\\n        int nx=x;\\n        int ny=y;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'L\\')\\n            {\\n                nx+=dir[3].first;\\n                ny+=dir[3].second;\\n            }\\n            else if(s[i]==\\'R\\')\\n            {\\n                 nx+=dir[2].first;\\n                ny+=dir[2].second;\\n            }\\n            else if(s[i]==\\'U\\')\\n            {\\n                 nx+=dir[0].first;\\n                ny+=dir[0].second;\\n            }\\n            else if(s[i]==\\'D\\')\\n            {\\n                 nx+=dir[1].first;\\n                ny+=dir[1].second;\\n            }\\n            // cout<<nx<<\"  \"<<ny<<\"    \";\\n              if(is_safe(nx,ny))\\n                {\\n                    count++;\\n                }\\n                else\\n                {\\n                    return count;\\n                }\\n           \\n        }\\n        return count;\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& nums, string s) \\n    {\\n        vector<int>ans(s.size(),0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int count=find(s.substr(i),n,nums[0],nums[1]);\\n                ans[i]=count;\\n            // cout<<\"new\"<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1647532,
                "title": "python-java-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n\\t\\t\\tdirections = {\"L\": (0, -1), \"R\": (0, 1), \"U\": (-1, 0), \"D\": (1, 0)}\\n\\t\\t\\tres = []\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tx, y = startPos\\n\\t\\t\\t\\tcnt = 0\\n\\t\\t\\t\\tfor j in range(i, len(s)):\\n\\t\\t\\t\\t\\tx += directions[s[j]][0]\\n\\t\\t\\t\\t\\ty += directions[s[j]][1]\\n\\t\\t\\t\\t\\tif 0 <= x < n and 0 <= y < n:\\n\\t\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tres.append(cnt)\\n\\t\\t\\treturn res\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tpublic int[] executeInstructions(int n, int[] startPos, String s) {\\n\\t\\t\\tMap<Character, int[]> directions = new HashMap<>();\\n\\t\\t\\tdirections.put(\\'L\\', new int[] {0, -1});\\n\\t\\t\\tdirections.put(\\'R\\', new int[] {0, 1});\\n\\t\\t\\tdirections.put(\\'U\\', new int[] {-1, 0});\\n\\t\\t\\tdirections.put(\\'D\\', new int[] {1, 0});\\n\\t\\t\\tint[] res = new int[s.length()];\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tfor (int j = 0; j < s.length(); j ++) {\\n\\t\\t\\t\\tint x = startPos[0];\\n\\t\\t\\t\\tint y = startPos[1];\\n\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\tfor (int k = j; k < s.length(); k ++) {\\n\\t\\t\\t\\t\\tx += directions.get(s.charAt(k))[0];\\n\\t\\t\\t\\t\\ty += directions.get(s.charAt(k))[1];\\n\\t\\t\\t\\t\\tif (0 <= x && x < n && 0 <= y && y < n) {\\n\\t\\t\\t\\t\\t\\tcnt ++;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres[i] = cnt;\\n\\t\\t\\t\\ti ++;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n\\t\\t\\tdirections = {\"L\": (0, -1), \"R\": (0, 1), \"U\": (-1, 0), \"D\": (1, 0)}",
                "codeTag": "Java"
            },
            {
                "id": 1647502,
                "title": "c-easy-solution",
                "content": "Time Complexity : O(n^2)\\n```\\nvector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int t1,t2,c=0;\\n        vector<int> res(s.size());\\n        for(int i=0;i<s.size();i++)\\n        {\\n            t1=startPos[0];\\n            t2=startPos[1];\\n            c=0;\\n            for(int j=i;j<s.size();j++)\\n\\t\\t\\t{\\n\\t\\t\\t    if(s[j]==\\'L\\')\\n                {  \\n                      t2--;\\n                      if(t1>=0 && t1<=n-1 && t2>=0 && t2<=n-1)\\n                            c++;\\n                      else\\n                            break;\\n                 }\\n            \\n                 else if(s[j]==\\'R\\')\\n                 {\\n                      t2++;\\n                      if(t1>=0 && t1<=n-1 && t2>=0 && t2<=n-1)\\n                          c++;\\n                      else\\n                          break;\\n                 }\\n                else if(s[j]==\\'U\\')\\n                {\\n                      t1--;\\n                      if(t1>=0 && t1<=n-1 && t2>=0 && t2<=n-1)\\n                           c++;\\n                      else\\n                           break;\\n                }\\n                else if(s[j]==\\'D\\')\\n                {\\n                     t1++;\\n                     if(t1>=0 && t1<=n-1 && t2>=0 && t2<=n-1)\\n                          c++;\\n                     else\\n                         break;\\n                }\\n            }\\n            res[i]=c;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int t1,t2,c=0;\\n        vector<int> res(s.size());\\n        for(int i=0;i<s.size();i++)\\n        {\\n            t1=startPos[0];\\n            t2=startPos[1];\\n            c=0;\\n            for(int j=i;j<s.size();j++)\\n\\t\\t\\t{\\n\\t\\t\\t    if(s[j]==\\'L\\')\\n                {  \\n                      t2--;\\n                      if(t1>=0 && t1<=n-1 && t2>=0 && t2<=n-1)\\n                            c++;\\n                      else\\n                            break;\\n                 }\\n            \\n                 else if(s[j]==\\'R\\')\\n                 {\\n                      t2++;\\n                      if(t1>=0 && t1<=n-1 && t2>=0 && t2<=n-1)\\n                          c++;\\n                      else\\n                          break;\\n                 }\\n                else if(s[j]==\\'U\\')\\n                {\\n                      t1--;\\n                      if(t1>=0 && t1<=n-1 && t2>=0 && t2<=n-1)\\n                           c++;\\n                      else\\n                           break;\\n                }\\n                else if(s[j]==\\'D\\')\\n                {\\n                     t1++;\\n                     if(t1>=0 && t1<=n-1 && t2>=0 && t2<=n-1)\\n                          c++;\\n                     else\\n                         break;\\n                }\\n            }\\n            res[i]=c;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1647496,
                "title": "java-o-m-2",
                "content": "```\\n\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int m = s.length();\\n        int[] result = new int[m];\\n        for(int i = 0; i < m; i++) {\\n            result[i] = (getLastInstructionPosition(n, startPos[0], startPos[1], s, i) - i);\\n        }\\n        return result;\\n    }\\n\\n    private int getLastInstructionPosition(int n, int row, int col, String s, int pos) {\\n        int m = s.length();\\n        if(m == pos) {\\n            return pos;\\n        }\\n        char ch = s.charAt(pos);\\n        switch(ch) {\\n            case \\'R\\' :\\n                if(!isValidCell(n, row, (col + 1))) {\\n                    return pos;\\n                }\\n                return getLastInstructionPosition(n, row, (col + 1), s, (pos + 1));\\n            case \\'L\\' :\\n                if(!isValidCell(n, row, (col - 1))) {\\n                    return pos;\\n                }\\n                return getLastInstructionPosition(n, row, (col - 1), s, (pos + 1));\\n            case \\'U\\' :\\n                if(!isValidCell(n, (row - 1), col)) {\\n                    return pos;\\n                }\\n                return getLastInstructionPosition(n, (row - 1), col, s, (pos + 1));\\n            default :\\n                if(!isValidCell(n, (row + 1), col)) {\\n                    return pos;\\n                }\\n                return getLastInstructionPosition(n, (row + 1), col, s, (pos + 1));\\n        }\\n    }\\n\\n    private boolean isValidCell(int n, int row, int col) {\\n        return (row >= 0 && row < n && col >= 0 && col < n);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int m = s.length();\\n        int[] result = new int[m];\\n        for(int i = 0; i < m; i++) {\\n            result[i] = (getLastInstructionPosition(n, startPos[0], startPos[1], s, i) - i);\\n        }\\n        return result;\\n    }\\n\\n    private int getLastInstructionPosition(int n, int row, int col, String s, int pos) {\\n        int m = s.length();\\n        if(m == pos) {\\n            return pos;\\n        }\\n        char ch = s.charAt(pos);\\n        switch(ch) {\\n            case \\'R\\' :\\n                if(!isValidCell(n, row, (col + 1))) {\\n                    return pos;\\n                }\\n                return getLastInstructionPosition(n, row, (col + 1), s, (pos + 1));\\n            case \\'L\\' :\\n                if(!isValidCell(n, row, (col - 1))) {\\n                    return pos;\\n                }\\n                return getLastInstructionPosition(n, row, (col - 1), s, (pos + 1));\\n            case \\'U\\' :\\n                if(!isValidCell(n, (row - 1), col)) {\\n                    return pos;\\n                }\\n                return getLastInstructionPosition(n, (row - 1), col, s, (pos + 1));\\n            default :\\n                if(!isValidCell(n, (row + 1), col)) {\\n                    return pos;\\n                }\\n                return getLastInstructionPosition(n, (row + 1), col, s, (pos + 1));\\n        }\\n    }\\n\\n    private boolean isValidCell(int n, int row, int col) {\\n        return (row >= 0 && row < n && col >= 0 && col < n);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647490,
                "title": "java-simple-loop",
                "content": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int out [] = new int [s.length()];\\n        \\n        for(int i=0;i<s.length();i++){\\n            int c = 0;\\n            int x = startPos[0];\\n            int y = startPos[1];\\n            for(int j=i;j<s.length();j++){\\n                if(s.charAt(j) == \\'R\\'){\\n                    if(y < n-1){\\n                        c++;\\n                        y++;\\n                    }else {\\n                        break;\\n                    }\\n                }else if(s.charAt(j) == \\'L\\'){\\n                    if(y > 0){\\n                        c++;\\n                        y--;\\n                    }else {\\n                        break;\\n                    }\\n                }else if(s.charAt(j) == \\'U\\'){\\n                    if(x > 0){\\n                        c++;\\n                        x--;\\n                    }else {\\n                        break;\\n                    }\\n                }else {\\n                    if(x < n-1){\\n                        c++;\\n                        x++;\\n                    }else {\\n                        break;\\n                    }\\n                }                    \\n            }\\n            out[i] = c;\\n        }\\n        return out;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int out [] = new int [s.length()];\\n        \\n        for(int i=0;i<s.length();i++){\\n            int c = 0;\\n            int x = startPos[0];\\n            int y = startPos[1];\\n            for(int j=i;j<s.length();j++){\\n                if(s.charAt(j) == \\'R\\'){\\n                    if(y < n-1){\\n                        c++;\\n                        y++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1647470,
                "title": "python3-brute-force",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/338b3e50d12cc0067b8b85e8e27c1b0c10fd91c6) for solutions of weely 273. \\n\\n```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        ans = []\\n        for k in range(len(s)): \\n            i, j = startPos\\n            val = 0 \\n            for kk in range(k, len(s)): \\n                if s[kk] == \\'L\\': j -= 1\\n                elif s[kk] == \\'R\\': j += 1\\n                elif s[kk] == \\'U\\': i -= 1\\n                else: i += 1\\n                if 0 <= i < n and 0 <= j < n: val += 1\\n                else: break \\n            ans.append(val)\\n        return ans \\n```\\n\\n```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        \\n        @cache\\n        def fn(i, j, k): \\n            \"\"\"Return valid number of instructions at (i, j) starting from kth.\"\"\"\\n            if k == len(s): return 0 \\n            if s[k] == \\'L\\': j -= 1\\n            elif s[k] == \\'R\\': j += 1\\n            elif s[k] == \\'U\\': i -= 1\\n            else: i += 1\\n            if 0 <= i < n and 0 <= j < n: return 1 + fn(i, j, k+1)\\n            return 0 \\n        \\n        return [fn(*startPos, k) for k in range(len(s))]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        ans = []\\n        for k in range(len(s)): \\n            i, j = startPos\\n            val = 0 \\n            for kk in range(k, len(s)): \\n                if s[kk] == \\'L\\': j -= 1\\n                elif s[kk] == \\'R\\': j += 1\\n                elif s[kk] == \\'U\\': i -= 1\\n                else: i += 1\\n                if 0 <= i < n and 0 <= j < n: val += 1\\n                else: break \\n            ans.append(val)\\n        return ans \\n```\n```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        \\n        @cache\\n        def fn(i, j, k): \\n            \"\"\"Return valid number of instructions at (i, j) starting from kth.\"\"\"\\n            if k == len(s): return 0 \\n            if s[k] == \\'L\\': j -= 1\\n            elif s[k] == \\'R\\': j += 1\\n            elif s[k] == \\'U\\': i -= 1\\n            else: i += 1\\n            if 0 <= i < n and 0 <= j < n: return 1 + fn(i, j, k+1)\\n            return 0 \\n        \\n        return [fn(*startPos, k) for k in range(len(s))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084471,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[]} startPos\\n * @param {string} s\\n * @return {number[]}\\n */\\nvar executeInstructions = function(n, startPos, s) {\\n  let [positionX, positionY] = startPos;\\n  let moves = [];\\n\\n\\n  for (let index = 0; index < s.length; index++) {\\n    const movesRes = checkHowManyMovesCanBe(positionX, positionY, s.slice(index), n);\\n    moves.push(movesRes);\\n\\n  }\\n\\n\\n  return moves;\\n};\\n\\nfunction checkHowManyMovesCanBe(x, y, s, n) {\\n  let result = 0;\\n  let xcopy = x;\\n  let ycopy = y;\\n\\n  for (let index = 0; index < s.length; index++) {\\n    const letter = s[index];\\n\\n    switch (letter) {\\n      case \"L\":\\n        ycopy = ycopy - 1;\\n        \\n        break;\\n      case \"R\":\\n        ycopy = ycopy + 1;\\n          \\n        break;\\n      case \"U\":\\n        xcopy = xcopy - 1;\\n          \\n        break;\\n      case \"D\":\\n        xcopy = xcopy + 1;\\n          \\n        break;\\n    \\n      default:\\n        break;\\n    }\\n\\n\\n    if (xcopy > n - 1  || xcopy < 0 || ycopy > n - 1 || ycopy < 0) {\\n      break;\\n    }\\n\\n    result = result + 1;\\n  }\\n\\n  return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} startPos\\n * @param {string} s\\n * @return {number[]}\\n */\\nvar executeInstructions = function(n, startPos, s) {\\n  let [positionX, positionY] = startPos;\\n  let moves = [];\\n\\n\\n  for (let index = 0; index < s.length; index++) {\\n    const movesRes = checkHowManyMovesCanBe(positionX, positionY, s.slice(index), n);\\n    moves.push(movesRes);\\n\\n  }\\n\\n\\n  return moves;\\n};\\n\\nfunction checkHowManyMovesCanBe(x, y, s, n) {\\n  let result = 0;\\n  let xcopy = x;\\n  let ycopy = y;\\n\\n  for (let index = 0; index < s.length; index++) {\\n    const letter = s[index];\\n\\n    switch (letter) {\\n      case \"L\":\\n        ycopy = ycopy - 1;\\n        \\n        break;\\n      case \"R\":\\n        ycopy = ycopy + 1;\\n          \\n        break;\\n      case \"U\":\\n        xcopy = xcopy - 1;\\n          \\n        break;\\n      case \"D\":\\n        xcopy = xcopy + 1;\\n          \\n        break;\\n    \\n      default:\\n        break;\\n    }\\n\\n\\n    if (xcopy > n - 1  || xcopy < 0 || ycopy > n - 1 || ycopy < 0) {\\n      break;\\n    }\\n\\n    result = result + 1;\\n  }\\n\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4066331,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& v, string s) {\\n        int x=n-1;int y=n-1;int a;int b;vector<int>k;\\n        for(int i=0;i<s.length();i++)\\n            {\\n                a=v[0];\\n                b=v[1];int c=0;\\n                for(int j=i;j<s.length();j++)\\n                {\\n                    if(s[j]==\\'R\\')\\n                    {\\n                        b++;\\n                    }\\n                    else if(s[j]==\\'L\\')\\n                    {\\n                        b--;\\n                    }\\n                    else if(s[j]==\\'U\\')\\n                    {\\n                        a--;\\n                    }\\n                    else if(s[j]==\\'D\\')\\n                    {\\n                        a++;\\n                    }\\n                    if(a<=x&&b<=y&&a>=0&&b>=0)\\n                    {\\n                        c++;\\n                    }\\n                    else{\\n                        \\n                        break;\\n                    }\\n                    \\n                }\\n            k.push_back(c);\\n            }\\n            return k;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& v, string s) {\\n        int x=n-1;int y=n-1;int a;int b;vector<int>k;\\n        for(int i=0;i<s.length();i++)\\n            {\\n                a=v[0];\\n                b=v[1];int c=0;\\n                for(int j=i;j<s.length();j++)\\n                {\\n                    if(s[j]==\\'R\\')\\n                    {\\n                        b++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 4063160,
                "title": "python-simple-approach-beats-60-simple-explanation-included",
                "content": "# Approach\\nSolved by Brute Force:\\n1. Get the chunks of operations using for loop.\\n2. Process each chunk into a movement simulation. If it met the constraints, we break the process. If not, we simulate the movement and increment the operation counts.\\n3. Append the total count to the answer list. Repeat the process, until all chunks has been simulate. Finally, return the answer list.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def executeInstructions(self, n, startPos, s):\\n        answer = []\\n        for chunks in range(0, len(s)):\\n            temp = s[chunks:len(s)]\\n            pos = startPos[:] # Copy the list using slicing\\n            count = 0\\n            for oper in temp:\\n                # Proceed the movement simulation\\n                if oper in (\"L\",\"R\"):\\n                    pos[1] += 1 if oper == \"R\" else -1\\n                else:\\n                    pos[0] += 1 if oper == \"D\" else -1\\n                # Validation process of the movement\\n                if (0 <= pos[0] < n) and (0 <= pos[1] < n):\\n                    count += 1\\n                else: break\\n            answer.append(count)\\n\\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def executeInstructions(self, n, startPos, s):\\n        answer = []\\n        for chunks in range(0, len(s)):\\n            temp = s[chunks:len(s)]\\n            pos = startPos[:] # Copy the list using slicing\\n            count = 0\\n            for oper in temp:\\n                # Proceed the movement simulation\\n                if oper in (\"L\",\"R\"):\\n                    pos[1] += 1 if oper == \"R\" else -1\\n                else:\\n                    pos[0] += 1 if oper == \"D\" else -1\\n                # Validation process of the movement\\n                if (0 <= pos[0] < n) and (0 <= pos[1] < n):\\n                    count += 1\\n                else: break\\n            answer.append(count)\\n\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030296,
                "title": "simple-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int m=s.length();\\n        int answer[]=new int[m];\\n        int count=0;\\n        int x=startPos[0];\\n        int y=startPos[1];\\n\\n     \\n        for(int i=0;i<s.length();i++)\\n        {\\n            int j=i;\\n            startPos[0]=x;\\n            startPos[1]=y;\\n            while(j<m)\\n            {\\n            if(s.charAt(j)==\\'L\\')\\n            {\\n                if(startPos[1]>0){\\n                startPos[1]=startPos[1]-1;\\n                count++;\\n                }\\n                else\\n                break;\\n                \\n            }\\n            else if(s.charAt(j)==\\'R\\')\\n            {\\n                if(startPos[1]<n-1){\\n                startPos[1]=startPos[1]+1;\\n                count++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            else if(s.charAt(j)==\\'U\\')\\n            {\\n                if(startPos[0]>0){\\n                startPos[0]=startPos[0]-1;\\n                count++;}\\n                else\\n                break;\\n            }\\n            else if(s.charAt(j)==\\'D\\')\\n            {\\n                if(startPos[0]<n-1){\\n                startPos[0]=startPos[0]+1;\\n                count++;\\n                }\\n                else\\n                break;\\n            }\\n            j++;\\n            }\\n            answer[i]=count;\\n            count=0;\\n\\n        }\\n        return answer;\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int m=s.length();\\n        int answer[]=new int[m];\\n        int count=0;\\n        int x=startPos[0];\\n        int y=startPos[1];\\n\\n     \\n        for(int i=0;i<s.length();i++)\\n        {\\n            int j=i;\\n            startPos[0]=x;\\n            startPos[1]=y;\\n            while(j<m)\\n            {\\n            if(s.charAt(j)==\\'L\\')\\n            {\\n                if(startPos[1]>0){\\n                startPos[1]=startPos[1]-1;\\n                count++;\\n                }\\n                else\\n                break;\\n                \\n            }\\n            else if(s.charAt(j)==\\'R\\')\\n            {\\n                if(startPos[1]<n-1){\\n                startPos[1]=startPos[1]+1;\\n                count++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            else if(s.charAt(j)==\\'U\\')\\n            {\\n                if(startPos[0]>0){\\n                startPos[0]=startPos[0]-1;\\n                count++;}\\n                else\\n                break;\\n            }\\n            else if(s.charAt(j)==\\'D\\')\\n            {\\n                if(startPos[0]<n-1){\\n                startPos[0]=startPos[0]+1;\\n                count++;\\n                }\\n                else\\n                break;\\n            }\\n            j++;\\n            }\\n            answer[i]=count;\\n            count=0;\\n\\n        }\\n        return answer;\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011746,
                "title": "python3-intuitive-easy-to-understand-simulation-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        #destructure sr and sc! \\n        sr, sc = startPos \\n        #n = # instructions total! \\n        countInstr = len(s)\\n        #helper to return max instructions robot can execute if robot begins executing from ith instruction!\\n        #Robot will always start from (sr, sc)\\n        def getMaxInstructions(i): \\n            cur_row, cur_col = sr, sc \\n            ans = 0 \\n            #while we still have instruction left \\n            while i < countInstr: \\n                curInstruction = s[i]\\n                if curInstruction == \"L\" and cur_col == 0:\\n                    break \\n                if curInstruction == \"R\" and cur_col == n - 1:\\n                    break\\n                if curInstruction == \"U\" and cur_row == 0: \\n                    break\\n                if curInstruction == \"D\" and cur_row == n-1:\\n                    break\\n                if curInstruction == \"U\":\\n                    cur_row -= 1 \\n                if curInstruction == \"D\":\\n                    cur_row += 1 \\n                if curInstruction == \"L\":\\n                    cur_col -= 1 \\n                if curInstruction == \"R\":\\n                    cur_col += 1 \\n                ans += 1 \\n                i += 1 \\n            return ans \\n        \\n        ans = []\\n        for i in range(0, countInstr): \\n            curMax = getMaxInstructions(i)\\n            ans.append(curMax)\\n        return ans \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        #destructure sr and sc! \\n        sr, sc = startPos \\n        #n = # instructions total! \\n        countInstr = len(s)\\n        #helper to return max instructions robot can execute if robot begins executing from ith instruction!\\n        #Robot will always start from (sr, sc)\\n        def getMaxInstructions(i): \\n            cur_row, cur_col = sr, sc \\n            ans = 0 \\n            #while we still have instruction left \\n            while i < countInstr: \\n                curInstruction = s[i]\\n                if curInstruction == \"L\" and cur_col == 0:\\n                    break \\n                if curInstruction == \"R\" and cur_col == n - 1:\\n                    break\\n                if curInstruction == \"U\" and cur_row == 0: \\n                    break\\n                if curInstruction == \"D\" and cur_row == n-1:\\n                    break\\n                if curInstruction == \"U\":\\n                    cur_row -= 1 \\n                if curInstruction == \"D\":\\n                    cur_row += 1 \\n                if curInstruction == \"L\":\\n                    cur_col -= 1 \\n                if curInstruction == \"R\":\\n                    cur_col += 1 \\n                ans += 1 \\n                i += 1 \\n            return ans \\n        \\n        ans = []\\n        for i in range(0, countInstr): \\n            curMax = getMaxInstructions(i)\\n            ans.append(curMax)\\n        return ans \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010879,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int follow(int row, int col, string s, int idx, int n)\\n    {\\n        int steps = 0;\\n        for(int i=idx; i<s.length(); i++)\\n        {\\n            if(s[i] == \\'R\\') ++col;\\n            if(s[i] == \\'L\\') --col;\\n            if(s[i] == \\'U\\') --row;\\n            if(s[i] == \\'D\\') ++row;\\n            if(row < 0 or row >= n or col < 0 or col >= n) return steps;\\n            ++steps;\\n        }\\n        return steps;\\n    }\\n\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) \\n    {\\n        vector<int> ans;\\n\\n        for(int i=0; i<s.length(); i++)\\n            ans.push_back(follow(startPos[0], startPos[1], s, i, n));\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int follow(int row, int col, string s, int idx, int n)\\n    {\\n        int steps = 0;\\n        for(int i=idx; i<s.length(); i++)\\n        {\\n            if(s[i] == \\'R\\') ++col;\\n            if(s[i] == \\'L\\') --col;\\n            if(s[i] == \\'U\\') --row;\\n            if(s[i] == \\'D\\') ++row;\\n            if(row < 0 or row >= n or col < 0 or col >= n) return steps;\\n            ++steps;\\n        }\\n        return steps;\\n    }\\n\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) \\n    {\\n        vector<int> ans;\\n\\n        for(int i=0; i<s.length(); i++)\\n            ans.push_back(follow(startPos[0], startPos[1], s, i, n));\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003740,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[]} startPos\\n * @param {string} s\\n * @return {number[]}\\n */\\nvar executeInstructions = function(n, startPos, s) {\\n    let answer = []\\n    \\n    let stringLen = s.length\\n    \\n    for(let i = 0; i < stringLen ; i++){\\n        let steps = 0\\n        let pos = [...startPos]\\n        for(let j = i ; j <= stringLen; j++){\\n            if(j === s.length){\\n                answer.push(steps)\\n            }else if(s[j] === \\'U\\' && pos[0] - 1 >= 0){\\n                pos[0] -= 1\\n                steps ++\\n            }\\n            else if(s[j] === \\'D\\' && pos[0] + 1 < n){\\n                pos[0] += 1\\n                steps ++\\n            }\\n            else if(s[j] === \\'L\\' && pos[1] - 1 >= 0){\\n                pos[1] -= 1\\n                steps ++\\n            }\\n            else if(s[j] === \\'R\\' && pos[1] + 1 < n ){\\n                pos[1] += 1\\n                steps ++\\n            }else{\\n                answer.push(steps)\\n                break\\n            }\\n        }\\n    }\\n\\n    return answer\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} startPos\\n * @param {string} s\\n * @return {number[]}\\n */\\nvar executeInstructions = function(n, startPos, s) {\\n    let answer = []\\n    \\n    let stringLen = s.length\\n    \\n    for(let i = 0; i < stringLen ; i++){\\n        let steps = 0\\n        let pos = [...startPos]\\n        for(let j = i ; j <= stringLen; j++){\\n            if(j === s.length){\\n                answer.push(steps)\\n            }else if(s[j] === \\'U\\' && pos[0] - 1 >= 0){\\n                pos[0] -= 1\\n                steps ++\\n            }\\n            else if(s[j] === \\'D\\' && pos[0] + 1 < n){\\n                pos[0] += 1\\n                steps ++\\n            }\\n            else if(s[j] === \\'L\\' && pos[1] - 1 >= 0){\\n                pos[1] -= 1\\n                steps ++\\n            }\\n            else if(s[j] === \\'R\\' && pos[1] + 1 < n ){\\n                pos[1] += 1\\n                steps ++\\n            }else{\\n                answer.push(steps)\\n                break\\n            }\\n        }\\n    }\\n\\n    return answer\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3975743,
                "title": "easy-cpp-solution-beats-89-97-in-runtime-naive-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/c36615d9-be0e-4a11-9f86-00da9dedd766_1693303894.9615855.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int cnt = 0;\\n        int sr = startPos[0], sc = startPos[1];\\n        vector<int> ans;\\n\\n        for(int i=0; i<s.length(); i++){\\n            int tr = sr, tc = sc;\\n            int ind = i;\\n            cnt = 0;\\n            while(true){\\n                if(s[ind] == \\'R\\'){\\n                    tc++;\\n                }\\n                else if(s[ind] == \\'L\\'){\\n                    tc--;\\n                }\\n                else if(s[ind] == \\'U\\'){\\n                    tr--;\\n                }\\n                else{\\n                    tr++;\\n                }\\n                if(tr >= 0 && tr < n && tc >= 0 && tc < n && ind < s.length()){\\n                    ind++;\\n                    cnt++;\\n                }\\n                else break;\\n            }\\n            ans.push_back(cnt);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int cnt = 0;\\n        int sr = startPos[0], sc = startPos[1];\\n        vector<int> ans;\\n\\n        for(int i=0; i<s.length(); i++){\\n            int tr = sr, tc = sc;\\n            int ind = i;\\n            cnt = 0;\\n            while(true){\\n                if(s[ind] == \\'R\\'){\\n                    tc++;\\n                }\\n                else if(s[ind] == \\'L\\'){\\n                    tc--;\\n                }\\n                else if(s[ind] == \\'U\\'){\\n                    tr--;\\n                }\\n                else{\\n                    tr++;\\n                }\\n                if(tr >= 0 && tr < n && tc >= 0 && tc < n && ind < s.length()){\\n                    ind++;\\n                    cnt++;\\n                }\\n                else break;\\n            }\\n            ans.push_back(cnt);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963652,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int r=startPos[0];\\n        int c=startPos[1];\\n        vector<int> ans;\\n        int size=s.size();\\n        for(int i=0;i<size;i++){\\n            int count=0;\\n            int j=i;\\n            while(r<n && c<n &&r>=0&&c>=0 && j<size){\\n                if(s[j]==\\'R\\')\\n                c++;\\n                else if(s[j]==\\'D\\')\\n                r++;\\n                else if(s[j]==\\'L\\')\\n                c--;\\n                else\\n                r--;\\n                if(r<0 || c<0 || r>=n || c>=n)\\n                break;\\n                count++;\\n                j++;\\n            }\\n            r=startPos[0];\\n            c=startPos[1];\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int r=startPos[0];\\n        int c=startPos[1];\\n        vector<int> ans;\\n        int size=s.size();\\n        for(int i=0;i<size;i++){\\n            int count=0;\\n            int j=i;\\n            while(r<n && c<n &&r>=0&&c>=0 && j<size){\\n                if(s[j]==\\'R\\')\\n                c++;\\n                else if(s[j]==\\'D\\')\\n                r++;\\n                else if(s[j]==\\'L\\')\\n                c--;\\n                else\\n                r--;\\n                if(r<0 || c<0 || r>=n || c>=n)\\n                break;\\n                count++;\\n                j++;\\n            }\\n            r=startPos[0];\\n            c=startPos[1];\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961866,
                "title": "python-beginner-friendly-solution-beats-89-solutions-2120-executeinstructions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def executeInstructions(self, n, startPos, s):\\n        result = []\\n    \\n        for cmdStart in range(len(s)):\\n            x, y = startPos[1], startPos[0]\\n            # print(x,y)\\n    \\n            count = 0\\n            path = s[cmdStart:]\\n            # print(path)\\n    \\n            for cmd in path:\\n                if cmd == \"R\":\\n                    x += 1\\n                elif cmd == \"L\":\\n                    x -= 1\\n                elif cmd == \"U\":\\n                    y -= 1\\n                elif cmd == \"D\":\\n                    y += 1\\n                \\n                if (x>=0 and x < n) and (y>=0 and y < n):\\n                    # print(f\"Valid : {x,y}\")\\n                    count += 1\\n                else:\\n                    # print(f\"Exit : {x,y}\")\\n                    break\\n                \\n            result.append(count)\\n            # print(result)\\n            # print(\"_______\")\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def executeInstructions(self, n, startPos, s):\\n        result = []\\n    \\n        for cmdStart in range(len(s)):\\n            x, y = startPos[1], startPos[0]\\n            # print(x,y)\\n    \\n            count = 0\\n            path = s[cmdStart:]\\n            # print(path)\\n    \\n            for cmd in path:\\n                if cmd == \"R\":\\n                    x += 1\\n                elif cmd == \"L\":\\n                    x -= 1\\n                elif cmd == \"U\":\\n                    y -= 1\\n                elif cmd == \"D\":\\n                    y += 1\\n                \\n                if (x>=0 and x < n) and (y>=0 and y < n):\\n                    # print(f\"Valid : {x,y}\")\\n                    count += 1\\n                else:\\n                    # print(f\"Exit : {x,y}\")\\n                    break\\n                \\n            result.append(count)\\n            # print(result)\\n            # print(\"_______\")\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937259,
                "title": "2120-execution-of-all-suffix-instructions-staying-in-a-grid",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> ans;\\n\\n        for(int i = 0 ; i < s.length() ; i++){\\n            int row = startPos[0];\\n            int col = startPos[1];\\n            int count = 0;\\n            for(int j = i ; j < s.length() ; j++){\\n\\n                if(s[j] == \\'L\\') \\n                    col--;\\n                if(s[j] == \\'R\\')\\n                    col++;\\n                if(s[j] == \\'U\\')\\n                    row--;\\n                if(s[j] == \\'D\\')\\n                    row++;\\n\\n\\n                if(col < 0 || col >= n || row < 0 || row >= n){\\n                    break;\\n                }\\n                else\\n                    count++;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> ans;\\n\\n        for(int i = 0 ; i < s.length() ; i++){\\n            int row = startPos[0];\\n            int col = startPos[1];\\n            int count = 0;\\n            for(int j = i ; j < s.length() ; j++){\\n\\n                if(s[j] == \\'L\\') \\n                    col--;\\n                if(s[j] == \\'R\\')\\n                    col++;\\n                if(s[j] == \\'U\\')\\n                    row--;\\n                if(s[j] == \\'D\\')\\n                    row++;\\n\\n\\n                if(col < 0 || col >= n || row < 0 || row >= n){\\n                    break;\\n                }\\n                else\\n                    count++;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936565,
                "title": "c-dfs-simulation-beats-90-easiest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid f(int a,int b,int &ct,string &s,int n,int m,int i)\\n{\\n    //cout<<i<<a<<b<<endl;\\n    if(a<0||a>=n||b<0||b>=n) return;\\n    if(i==m) {\\n        ct++; return;\\n    }\\n    else\\n    {\\n        ct++;\\n        if(s[i]==\\'R\\')\\n        f(a,b+1,ct,s,n,m,i+1);\\n        else if(s[i]==\\'L\\')\\n        f(a,b-1,ct,s,n,m,i+1);\\n        else if(s[i]==\\'U\\')\\n        f(a-1,b,ct,s,n,m,i+1);\\n        else\\n        f(a+1,b,ct,s,n,m,i+1);\\n    }\\n}\\n    vector<int> executeInstructions(int n, vector<int>& spos, string s) {\\n        int m=s.length(),i,j;\\n        vector<int> ans(m);\\n        for(i=0;i<m;i++)\\n        {\\n            int ct=-1;\\n            f(spos[0],spos[1],ct,s,n,m,i);\\n            ans[i]=ct;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Depth-First Search",
                    "Recursion",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid f(int a,int b,int &ct,string &s,int n,int m,int i)\\n{\\n    //cout<<i<<a<<b<<endl;\\n    if(a<0||a>=n||b<0||b>=n) return;\\n    if(i==m) {\\n        ct++; return;\\n    }\\n    else\\n    {\\n        ct++;\\n        if(s[i]==\\'R\\')\\n        f(a,b+1,ct,s,n,m,i+1);\\n        else if(s[i]==\\'L\\')\\n        f(a,b-1,ct,s,n,m,i+1);\\n        else if(s[i]==\\'U\\')\\n        f(a-1,b,ct,s,n,m,i+1);\\n        else\\n        f(a+1,b,ct,s,n,m,i+1);\\n    }\\n}\\n    vector<int> executeInstructions(int n, vector<int>& spos, string s) {\\n        int m=s.length(),i,j;\\n        vector<int> ans(m);\\n        for(i=0;i<m;i++)\\n        {\\n            int ct=-1;\\n            f(spos[0],spos[1],ct,s,n,m,i);\\n            ans[i]=ct;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3923465,
                "title": "java-faster-than-95-best-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![4.jfif](https://assets.leetcode.com/users/images/c5451ddd-3e00-4e2c-aaaf-526c4dab646d_1692291341.8611705.jpeg)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int [] ans=new int[s.length()];\\n       char [] ch=s.toCharArray();\\n         int rr=startPos[0];\\n         int rc=startPos[1];\\n        for(int x=0;x<ans.length;x++){\\n            int count=0;\\n            int i=x;\\n         for(;i<ch.length;i++){\\n            if(ch[i]==\\'R\\') rc++;\\n            if(ch[i]==\\'L\\') rc--;\\n            if(ch[i]==\\'U\\') rr--;\\n            if(ch[i]==\\'D\\') rr++;\\n            if(rc>n-1 || rc < 0 || rr>n-1 || rr < 0){\\n                 rr=startPos[0];\\n                rc=startPos[1];\\n                 break;\\n            } \\n                count++;\\n           \\n            }\\n             if(i==s.length()){\\n                 rr=startPos[0];\\n                rc=startPos[1];\\n            }\\n           \\n            ans[x]=count;\\n        }\\n        return ans;\\n//PLEASE UPVOTE ME\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int [] ans=new int[s.length()];\\n       char [] ch=s.toCharArray();\\n         int rr=startPos[0];\\n         int rc=startPos[1];\\n        for(int x=0;x<ans.length;x++){\\n            int count=0;\\n            int i=x;\\n         for(;i<ch.length;i++){\\n            if(ch[i]==\\'R\\') rc++;\\n            if(ch[i]==\\'L\\') rc--;\\n            if(ch[i]==\\'U\\') rr--;\\n            if(ch[i]==\\'D\\') rr++;\\n            if(rc>n-1 || rc < 0 || rr>n-1 || rr < 0){\\n                 rr=startPos[0];\\n                rc=startPos[1];\\n                 break;\\n            } \\n                count++;\\n           \\n            }\\n             if(i==s.length()){\\n                 rr=startPos[0];\\n                rc=startPos[1];\\n            }\\n           \\n            ans[x]=count;\\n        }\\n        return ans;\\n//PLEASE UPVOTE ME\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920915,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int result[]=new int[s.length()];\\n        int row=startPos[0];\\n        int col=startPos[1];\\n        // int count=0;\\n        for(int i=0;i<s.length();i++){\\n            int currcol=col;\\n            int currrow=row;\\n            int currcount=0;\\n            for(int j=i;j<s.length();j++){\\n                char c=s.charAt(j);\\n                if(c==\\'R\\'){\\n                    currcol++;\\n                    if(currcol<n)currcount++;\\n                    else break;\\n                }\\n                else if(c==\\'L\\'){\\n                    currcol--;\\n                    if(currcol>=0)currcount++;\\n                    else break;\\n\\n                }\\n\\n                else if(c==\\'D\\'){\\n                    currrow++;\\n                    if(currrow<n)currcount++;\\n                    else break;\\n\\n                }\\n                else{\\n                    currrow--;\\n                    if(currrow>=0)currcount++;\\n                    else break;\\n                }\\n            }\\n            result[i]=currcount;\\n\\n\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int result[]=new int[s.length()];\\n        int row=startPos[0];\\n        int col=startPos[1];\\n        // int count=0;\\n        for(int i=0;i<s.length();i++){\\n            int currcol=col;\\n            int currrow=row;\\n            int currcount=0;\\n            for(int j=i;j<s.length();j++){\\n                char c=s.charAt(j);\\n                if(c==\\'R\\'){\\n                    currcol++;\\n                    if(currcol<n)currcount++;\\n                    else break;\\n                }\\n                else if(c==\\'L\\'){\\n                    currcol--;\\n                    if(currcol>=0)currcount++;\\n                    else break;\\n\\n                }\\n\\n                else if(c==\\'D\\'){\\n                    currrow++;\\n                    if(currrow<n)currcount++;\\n                    else break;\\n\\n                }\\n                else{\\n                    currrow--;\\n                    if(currrow>=0)currcount++;\\n                    else break;\\n                }\\n            }\\n            result[i]=currcount;\\n\\n\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914992,
                "title": "binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        res = [0] * len(s)\\n        if n <= 1:\\n            return res\\n        \\n        def isValidMove(startPos, start, end, s, n):\\n            x, y = startPos[0], startPos[1]\\n            for j in range(start, end + 1):\\n                c = s[j]\\n                if c == \\'L\\':\\n                    y -= 1\\n                elif c == \\'R\\':\\n                    y += 1\\n                elif c == \\'U\\':\\n                    x -= 1\\n                elif c == \\'D\\':\\n                    x += 1\\n                if 0 <= x < n and 0 <= y < n:\\n                    continue\\n                else:\\n                    return False\\n            return True\\n        \\n        for i in range(len(s)):\\n            count = 0\\n            x, y = startPos[0], startPos[1]\\n            left, right = i, len(s) - 1\\n            while left < right:\\n                mid = left + (right - left) // 2\\n                if isValidMove(startPos, i, mid, s, n):\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n            if isValidMove(startPos, i, left, s, n):\\n                res[i] = left - i + 1\\n            else:\\n                res[i] = left - i\\n        \\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        res = [0] * len(s)\\n        if n <= 1:\\n            return res\\n        \\n        def isValidMove(startPos, start, end, s, n):\\n            x, y = startPos[0], startPos[1]\\n            for j in range(start, end + 1):\\n                c = s[j]\\n                if c == \\'L\\':\\n                    y -= 1\\n                elif c == \\'R\\':\\n                    y += 1\\n                elif c == \\'U\\':\\n                    x -= 1\\n                elif c == \\'D\\':\\n                    x += 1\\n                if 0 <= x < n and 0 <= y < n:\\n                    continue\\n                else:\\n                    return False\\n            return True\\n        \\n        for i in range(len(s)):\\n            count = 0\\n            x, y = startPos[0], startPos[1]\\n            left, right = i, len(s) - 1\\n            while left < right:\\n                mid = left + (right - left) // 2\\n                if isValidMove(startPos, i, mid, s, n):\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n            if isValidMove(startPos, i, left, s, n):\\n                res[i] = left - i + 1\\n            else:\\n                res[i] = left - i\\n        \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847470,
                "title": "simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool val(int r , int c , int n){\\n        return (r>=0 && r<n && c>=0 && c<n);\\n    }\\n    vector<int> executeInstructions(int n , vector<int>&v , string s){\\n        vector<int>ans;\\n        for(int i=0; i<s.size(); i++){\\n            int r=v[0] , c=v[1] , co=0;\\n            for(int j=i; j<s.size(); j++){\\n                if(s[j]==\\'R\\'){\\n                    c++;\\n                }\\n                else if(s[j]==\\'L\\'){\\n                    c--;\\n                }\\n                else if(s[j]==\\'U\\'){\\n                    r--;\\n                }\\n                else{\\n                    r++;\\n                }\\n                if(val(r , c , n)){\\n                    co++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            ans.push_back(co);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool val(int r , int c , int n){\\n        return (r>=0 && r<n && c>=0 && c<n);\\n    }\\n    vector<int> executeInstructions(int n , vector<int>&v , string s){\\n        vector<int>ans;\\n        for(int i=0; i<s.size(); i++){\\n            int r=v[0] , c=v[1] , co=0;\\n            for(int j=i; j<s.size(); j++){\\n                if(s[j]==\\'R\\'){\\n                    c++;\\n                }\\n                else if(s[j]==\\'L\\'){\\n                    c--;\\n                }\\n                else if(s[j]==\\'U\\'){\\n                    r--;\\n                }\\n                else{\\n                    r++;\\n                }\\n                if(val(r , c , n)){\\n                    co++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            ans.push_back(co);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841977,
                "title": "java-faster-than-98-compact-than-90-easy-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        \\n        int x =0, y = 0, j = 0;\\n        char[] arr = s.toCharArray(); // faster than charAt function\\n        int[] ans = new int[s.length()];\\n        \\n        for(int i=0; i<arr.length; i++){\\n        \\n            x =startPos[1]; y = startPos[0];\\n        \\n            for(j=i; j<s.length(); j++){\\n                if(arr[j]==\\'R\\') {\\n                    if(++x>=n) break;\\n                }\\n                else if(arr[j]==\\'L\\') {\\n                    if(--x<0) break;\\n                }\\n                else if(arr[j]==\\'U\\') {\\n                    if(--y<0) break;\\n                }\\n                else {\\n                    if(++y>=n) break;\\n                }\\n            }\\n        \\n            ans[i]=j-i;\\n        \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        \\n        int x =0, y = 0, j = 0;\\n        char[] arr = s.toCharArray(); // faster than charAt function\\n        int[] ans = new int[s.length()];\\n        \\n        for(int i=0; i<arr.length; i++){\\n        \\n            x =startPos[1]; y = startPos[0];\\n        \\n            for(j=i; j<s.length(); j++){\\n                if(arr[j]==\\'R\\') {\\n                    if(++x>=n) break;\\n                }\\n                else if(arr[j]==\\'L\\') {\\n                    if(--x<0) break;\\n                }\\n                else if(arr[j]==\\'U\\') {\\n                    if(--y<0) break;\\n                }\\n                else {\\n                    if(++y>=n) break;\\n                }\\n            }\\n        \\n            ans[i]=j-i;\\n        \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831960,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> answer(s.length());\\n\\n        for (int i=0 ; i<s.length() ; i++){\\n            int sum = 0;\\n            int x = startPos[0];\\n            int y = startPos[1];\\n            \\n            for (int j=i ; j<s.length() ; j++){\\n                if (s[j] == \\'L\\')\\n                    y--;\\n                else if (s[j] == \\'R\\')\\n                    y++;\\n                else if (s[j] == \\'U\\')\\n                    x--;\\n                else\\n                    x++;\\n                \\n                sum++;\\n                \\n                if (x > n-1 || x < 0 || y < 0 || y > n-1){\\n                    sum--;\\n                    break;\\n                }\\n            }\\n            answer[i] = sum;\\n        }   \\n        return answer; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> answer(s.length());\\n\\n        for (int i=0 ; i<s.length() ; i++){\\n            int sum = 0;\\n            int x = startPos[0];\\n            int y = startPos[1];\\n            \\n            for (int j=i ; j<s.length() ; j++){\\n                if (s[j] == \\'L\\')\\n                    y--;\\n                else if (s[j] == \\'R\\')\\n                    y++;\\n                else if (s[j] == \\'U\\')\\n                    x--;\\n                else\\n                    x++;\\n                \\n                sum++;\\n                \\n                if (x > n-1 || x < 0 || y < 0 || y > n-1){\\n                    sum--;\\n                    break;\\n                }\\n            }\\n            answer[i] = sum;\\n        }   \\n        return answer; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828589,
                "title": "java-solution-beats-87-of-others-solutions",
                "content": "\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int[] answer = new int[s.length()];\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            int x = startPos[0],y = startPos[1];\\n            int steps = 0;\\n            for (int j = i; j < s.length(); j++) {\\n                if (s.charAt(j) == \\'R\\'){\\n                    y += 1;\\n                } else if (s.charAt(j) == \\'L\\') {\\n                    y -= 1;\\n                } else if (s.charAt(j) == \\'U\\') {\\n                    x -= 1;\\n                }\\n                else {\\n                    x += 1;\\n                }\\n                if (x < 0 || x >= n || y < 0 || y >= n){\\n                    break;\\n                }\\n                steps++;\\n            }\\n            answer[i] = steps;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int[] answer = new int[s.length()];\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            int x = startPos[0],y = startPos[1];\\n            int steps = 0;\\n            for (int j = i; j < s.length(); j++) {\\n                if (s.charAt(j) == \\'R\\'){\\n                    y += 1;\\n                } else if (s.charAt(j) == \\'L\\') {\\n                    y -= 1;\\n                } else if (s.charAt(j) == \\'U\\') {\\n                    x -= 1;\\n                }\\n                else {\\n                    x += 1;\\n                }\\n                if (x < 0 || x >= n || y < 0 || y >= n){\\n                    break;\\n                }\\n                steps++;\\n            }\\n            answer[i] = steps;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823052,
                "title": "easy-to-understand-java-solution-with-89-of-beats",
                "content": "# Approach\\nMove the cell \"R\",\"L\",\"U\",\"D\" with the startPos[0] & startPos[1] and check the conditions to count . Finally add the count in the IntegerArray .\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int arr[] = new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            int c=0,l=startPos[0],r=startPos[1];\\n            for(int j=i;j<s.length();j++){\\n                char ch = s.charAt(j);\\n                if(ch==\\'R\\'){\\n                    r++;\\n                }\\n                if(ch==\\'L\\'){\\n                    r--;\\n                }\\n                if(ch==\\'U\\'){\\n                    l--;\\n                }\\n                if(ch==\\'D\\'){\\n                    l++;\\n                }\\n                if(r>n-1 || r<0 || l>n-1 || l<0)\\n                    break;\\n                else\\n                    c++;\\n            }\\n            arr[i]=c;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int arr[] = new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            int c=0,l=startPos[0],r=startPos[1];\\n            for(int j=i;j<s.length();j++){\\n                char ch = s.charAt(j);\\n                if(ch==\\'R\\'){\\n                    r++;\\n                }\\n                if(ch==\\'L\\'){\\n                    r--;\\n                }\\n                if(ch==\\'U\\'){\\n                    l--;\\n                }\\n                if(ch==\\'D\\'){\\n                    l++;\\n                }\\n                if(r>n-1 || r<0 || l>n-1 || l<0)\\n                    break;\\n                else\\n                    c++;\\n            }\\n            arr[i]=c;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817703,
                "title": "brute-force",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] st, String s) {\\n        int m = s.length();\\n        int [] ans = new int[m];\\n            int inst;int col,row;\\n        for(int i=0;i<m;i++){\\n            inst = 0;row=st[0];col=st[1];\\n        for(int j=i;j<m;j++){\\n            char ch = s.charAt(j);\\n            if(ch ==\\'R\\'&& ++col< n){\\n                inst++;\\n            }\\n            else if(ch ==\\'L\\' && --col>=0){\\n                inst++;\\n            }\\n            else if(ch ==\\'U\\'&& --row>=0){\\n                inst++;\\n            }\\n            else if(ch ==\\'D\\' && ++row <n){\\n                inst++;\\n            }\\n            else break;\\n        }\\n        ans[i]=inst;\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] st, String s) {\\n        int m = s.length();\\n        int [] ans = new int[m];\\n            int inst;int col,row;\\n        for(int i=0;i<m;i++){\\n            inst = 0;row=st[0];col=st[1];\\n        for(int j=i;j<m;j++){\\n            char ch = s.charAt(j);\\n            if(ch ==\\'R\\'&& ++col< n){\\n                inst++;\\n            }\\n            else if(ch ==\\'L\\' && --col>=0){\\n                inst++;\\n            }\\n            else if(ch ==\\'U\\'&& --row>=0){\\n                inst++;\\n            }\\n            else if(ch ==\\'D\\' && ++row <n){\\n                inst++;\\n            }\\n            else break;\\n        }\\n        ans[i]=inst;\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812824,
                "title": "python-easy-to-understand-simple-solution",
                "content": "\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        ans = []\\n        matrix = [[[] for i in range(n)] for k in range(n)]\\n\\n        for k in  range(0,len(s)):\\n            i, j = startPos[0], startPos[1]\\n            count = 0\\n            for h in s[k:]:\\n                if h == \"R\" : j += 1\\n                if h == \"L\" : j -= 1\\n                if h == \"U\" : i -= 1\\n                if h == \"D\" : i += 1\\n                if i < 0 or j < 0 or i == n or j == n:\\n                    break\\n                count += 1\\n\\n            ans.append(count)\\n\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        ans = []\\n        matrix = [[[] for i in range(n)] for k in range(n)]\\n\\n        for k in  range(0,len(s)):\\n            i, j = startPos[0], startPos[1]\\n            count = 0\\n            for h in s[k:]:\\n                if h == \"R\" : j += 1\\n                if h == \"L\" : j -= 1\\n                if h == \"U\" : i -= 1\\n                if h == \"D\" : i += 1\\n                if i < 0 or j < 0 or i == n or j == n:\\n                    break\\n                count += 1\\n\\n            ans.append(count)\\n\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 3812787,
                "title": "python-simple-solution",
                "content": "\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        ans = []\\n        matrix = [[[] for i in range(n)] for k in range(n)]\\n\\n        while s:\\n            i, j = startPos[0], startPos[1]\\n            count = 0\\n            for h in s:\\n                if h == \"R\" : j += 1\\n                if h == \"L\" : j -= 1\\n                if h == \"U\" : i -= 1\\n                if h == \"D\" : i += 1\\n                if i < 0 or j < 0 or i == n or j == n:\\n                    break\\n                matrix[i][j]\\n                count += 1\\n\\n            s = s.removeprefix(s[0])\\n            ans.append(count)\\n\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        ans = []\\n        matrix = [[[] for i in range(n)] for k in range(n)]\\n\\n        while s:\\n            i, j = startPos[0], startPos[1]\\n            count = 0\\n            for h in s:\\n                if h == \"R\" : j += 1\\n                if h == \"L\" : j -= 1\\n                if h == \"U\" : i -= 1\\n                if h == \"D\" : i += 1\\n                if i < 0 or j < 0 or i == n or j == n:\\n                    break\\n                matrix[i][j]\\n                count += 1\\n\\n            s = s.removeprefix(s[0])\\n            ans.append(count)\\n\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 3810079,
                "title": "97-9-easy-to-understand-python-solution",
                "content": ">> Please, UPVOTE, if you like the code \\u26A1\\n\\n\\n# Complexity\\n- **Time complexity:** **O(n^2)**\\n\\n- **Space complexity:** **O(n)**\\n\\n# Code\\n```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        res = []\\n        for i in range(len(s)):\\n            count = 0\\n            row, col = startPos[0], startPos[1]\\n            for j in range(i, len(s)):\\n                if s[j] == \\'L\\' and col - 1 >= 0:\\n                    col = col - 1\\n                    count += 1\\n                elif s[j] == \\'R\\' and col + 1 <= n - 1:\\n                    col = col + 1\\n                    count += 1\\n                elif s[j] == \\'D\\' and row + 1 <= n - 1:\\n                    row = row + 1\\n                    count += 1\\n                elif s[j] == \\'U\\' and row - 1 >= 0:\\n                    row = row - 1\\n                    count += 1\\n                else:\\n                    break\\n            res.append(count)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        res = []\\n        for i in range(len(s)):\\n            count = 0\\n            row, col = startPos[0], startPos[1]\\n            for j in range(i, len(s)):\\n                if s[j] == \\'L\\' and col - 1 >= 0:\\n                    col = col - 1\\n                    count += 1\\n                elif s[j] == \\'R\\' and col + 1 <= n - 1:\\n                    col = col + 1\\n                    count += 1\\n                elif s[j] == \\'D\\' and row + 1 <= n - 1:\\n                    row = row + 1\\n                    count += 1\\n                elif s[j] == \\'U\\' and row - 1 >= 0:\\n                    row = row - 1\\n                    count += 1\\n                else:\\n                    break\\n            res.append(count)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789474,
                "title": "solution-with-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction executeInstructions(n: number, startPos: number[], s: string): number[] {\\n    let res: number[] = [];\\n    first:\\n    for(let i = 0; i < s.length; i++){\\n        let y = startPos[0];\\n        let x = startPos[1];\\n        let counter: number = 0;\\n        second:\\n        for(let j = i; j < s.length; j++){\\n            if(s[j] === \"L\") x--;\\n            if(s[j] === \"R\") x++;\\n            if(s[j] === \"D\") y++;\\n            if(s[j] === \"U\") y--;\\n            if(x === n || y === n || x === -1 || y === -1) break second;\\n            else counter++\\n        };\\n        res.push(counter);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction executeInstructions(n: number, startPos: number[], s: string): number[] {\\n    let res: number[] = [];\\n    first:\\n    for(let i = 0; i < s.length; i++){\\n        let y = startPos[0];\\n        let x = startPos[1];\\n        let counter: number = 0;\\n        second:\\n        for(let j = i; j < s.length; j++){\\n            if(s[j] === \"L\") x--;\\n            if(s[j] === \"R\") x++;\\n            if(s[j] === \"D\") y++;\\n            if(s[j] === \"U\") y--;\\n            if(x === n || y === n || x === -1 || y === -1) break second;\\n            else counter++\\n        };\\n        res.push(counter);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3787844,
                "title": "easy-iterative-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> ans;\\n        int len=s.length();\\n        int x,y;\\n\\n        for(int i=0;i<len;i++){\\n            x=startPos[0],y=startPos[1];\\n            int count=0;\\n            for(int j=i;j<len;j++){\\n                if(s[j]==\\'L\\') y--;\\n                if(s[j]==\\'R\\') y++;\\n                if(s[j]==\\'U\\') x--;\\n                if(s[j]==\\'D\\') x++;\\n\\n                if(x<0||x>=n||y<0||y>=n){\\n                    break;\\n                }\\n\\n                count++;\\n            }\\n            ans.push_back(count);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> ans;\\n        int len=s.length();\\n        int x,y;\\n\\n        for(int i=0;i<len;i++){\\n            x=startPos[0],y=startPos[1];\\n            int count=0;\\n            for(int j=i;j<len;j++){\\n                if(s[j]==\\'L\\') y--;\\n                if(s[j]==\\'R\\') y++;\\n                if(s[j]==\\'U\\') x--;\\n                if(s[j]==\\'D\\') x++;\\n\\n                if(x<0||x>=n||y<0||y>=n){\\n                    break;\\n                }\\n\\n                count++;\\n            }\\n            ans.push_back(count);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773699,
                "title": "easy-c-solution-90-faster-beginner-friendly",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool isValid(int i,int j,int n){\\n        if(i<0 || j<0 || i>=n || j>=n)\\n            return false;\\n        return true;\\n    }\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& sp, string s) {\\n        int m=s.size();\\n        vector<int> v(m);\\n        for(int i=0;i<m;i++){\\n            int a=sp[0],b=sp[1];\\n            int c=0;\\n            for(int j=i;j<m;j++){\\n                if(s[j]==\\'R\\')\\n                    b++;\\n                else if(s[j]==\\'L\\')\\n                    b--;\\n                else if(s[j]==\\'U\\')\\n                    a--;\\n                else if(s[j]==\\'D\\')\\n                    a++;\\n                    \\n                if(isValid(a,b,n))\\n                    c++;\\n                else{\\n                    break;\\n                }\\n            }\\n            v[i]=c;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    bool isValid(int i,int j,int n){\\n        if(i<0 || j<0 || i>=n || j>=n)\\n            return false;\\n        return true;\\n    }\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& sp, string s) {\\n        int m=s.size();\\n        vector<int> v(m);\\n        for(int i=0;i<m;i++){\\n            int a=sp[0],b=sp[1];\\n            int c=0;\\n            for(int j=i;j<m;j++){\\n                if(s[j]==\\'R\\')\\n                    b++;\\n                else if(s[j]==\\'L\\')\\n                    b--;\\n                else if(s[j]==\\'U\\')\\n                    a--;\\n                else if(s[j]==\\'D\\')\\n                    a++;\\n                    \\n                if(isValid(a,b,n))\\n                    c++;\\n                else{\\n                    break;\\n                }\\n            }\\n            v[i]=c;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766353,
                "title": "python-medium",
                "content": "```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        M = len(s)\\n\\n        res = []\\n\\n        for i in range(M):\\n            start = startPos.copy()\\n            count = 0\\n\\n            for j in range(i, M):\\n                if s[j] == \"R\":\\n                    start[1] += 1\\n\\n                elif s[j] == \"L\":\\n                    start[1] -= 1\\n\\n                if s[j] == \"U\":\\n                    start[0] -= 1\\n\\n                elif s[j] == \"D\":\\n                    start[0] += 1\\n\\n                if not (0 <= start[0] < n and 0 <= start[1] < n):\\n                    break\\n\\n                count += 1\\n            \\n            res.append(count)\\n\\n\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        M = len(s)\\n\\n        res = []\\n\\n        for i in range(M):\\n            start = startPos.copy()\\n            count = 0\\n\\n            for j in range(i, M):\\n                if s[j] == \"R\":\\n                    start[1] += 1\\n\\n                elif s[j] == \"L\":\\n                    start[1] -= 1\\n\\n                if s[j] == \"U\":\\n                    start[0] -= 1\\n\\n                elif s[j] == \"D\":\\n                    start[0] += 1\\n\\n                if not (0 <= start[0] < n and 0 <= start[1] < n):\\n                    break\\n\\n                count += 1\\n            \\n            res.append(count)\\n\\n\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751817,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBruteforce\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int m = s.length();\\n        int[] arr = new int[m];\\n\\n        for(int i = 0; i < m; i++){\\n            arr[i] = count(s, i, startPos[0], startPos[1], n);\\n        }\\n        return arr;\\n    }\\n\\n    public static int count(String s, int l, int x, int y, int n){\\n        int count = 0;\\n        int m = s.length();\\n        for(int i = l; i < m; i++){\\n            if(s.charAt(i) == \\'L\\'){\\n                y--;\\n            }\\n            else if(s.charAt(i) == \\'R\\'){\\n                y++;\\n            }\\n            else if(s.charAt(i) == \\'U\\'){\\n                x--;\\n            }\\n            else if(s.charAt(i) == \\'D\\'){\\n                x++;\\n            }\\n            if(x < 0 || x == n || y < 0 || y == n){\\n                break;\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int m = s.length();\\n        int[] arr = new int[m];\\n\\n        for(int i = 0; i < m; i++){\\n            arr[i] = count(s, i, startPos[0], startPos[1], n);\\n        }\\n        return arr;\\n    }\\n\\n    public static int count(String s, int l, int x, int y, int n){\\n        int count = 0;\\n        int m = s.length();\\n        for(int i = l; i < m; i++){\\n            if(s.charAt(i) == \\'L\\'){\\n                y--;\\n            }\\n            else if(s.charAt(i) == \\'R\\'){\\n                y++;\\n            }\\n            else if(s.charAt(i) == \\'U\\'){\\n                x--;\\n            }\\n            else if(s.charAt(i) == \\'D\\'){\\n                x++;\\n            }\\n            if(x < 0 || x == n || y < 0 || y == n){\\n                break;\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731616,
                "title": "coding-this-problem-at-war",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n         int x = startPos[1];\\n    int y = startPos[0];\\n    int moves = 0;\\n    int[] ans = new int[s.length()];\\n    n--;\\n\\n    for (int j = 0; j < ans.length; j++) {\\n    //   System.out.println(s);\\n\\n      for (int i = 0; i < s.length(); i++) {\\n        if ((s.charAt(i) == \\'L\\')) {\\n          if (x == 0) break;\\n          x--;\\n        }\\n        if ((s.charAt(i) == \\'R\\')) {\\n          if (x == n) break;\\n          x++;\\n        }\\n\\n        if ((s.charAt(i) == \\'U\\')) {\\n          if (y == 0) break;\\n          y--;\\n        }\\n        if ((s.charAt(i) == \\'D\\')) {\\n          if (y == n) break;\\n          y++;\\n        }\\n        moves++;\\n\\n        // System.out.println(x + \" \" + y + \"  -  \" + moves);\\n      }\\n\\n      ans[j] = moves;\\n      moves = 0;\\n      x = startPos[1];\\n      y = startPos[0];\\n      s = s.substring(1);\\n    }\\n    // System.out.println(moves);\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n         int x = startPos[1];\\n    int y = startPos[0];\\n    int moves = 0;\\n    int[] ans = new int[s.length()];\\n    n--;\\n\\n    for (int j = 0; j < ans.length; j++) {\\n    //   System.out.println(s);\\n\\n      for (int i = 0; i < s.length(); i++) {\\n        if ((s.charAt(i) == \\'L\\')) {\\n          if (x == 0) break;\\n          x--;\\n        }\\n        if ((s.charAt(i) == \\'R\\')) {\\n          if (x == n) break;\\n          x++;\\n        }\\n\\n        if ((s.charAt(i) == \\'U\\')) {\\n          if (y == 0) break;\\n          y--;\\n        }\\n        if ((s.charAt(i) == \\'D\\')) {\\n          if (y == n) break;\\n          y++;\\n        }\\n        moves++;\\n\\n        // System.out.println(x + \" \" + y + \"  -  \" + moves);\\n      }\\n\\n      ans[j] = moves;\\n      moves = 0;\\n      x = startPos[1];\\n      y = startPos[0];\\n      s = s.substring(1);\\n    }\\n    // System.out.println(moves);\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717621,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int>res;\\n        for(int i=0; i<s.size(); i++){\\n            int row=startPos[0],col=startPos[1];\\n            int tot=0;\\n            for(int j=i; j<s.size(); j++){\\n                if(s[j]==\\'L\\')\\n                    col--;\\n                else if(s[j]==\\'R\\')\\n                    col++;\\n                else if(s[j]==\\'U\\')\\n                    row--;\\n                else\\n                    row++;\\n                if(row>=n||row<0||col>=n||col<0)\\n                    break;\\n                tot++;\\n            }\\n            res.push_back(tot);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int>res;\\n        for(int i=0; i<s.size(); i++){\\n            int row=startPos[0],col=startPos[1];\\n            int tot=0;\\n            for(int j=i; j<s.size(); j++){\\n                if(s[j]==\\'L\\')\\n                    col--;\\n                else if(s[j]==\\'R\\')\\n                    col++;\\n                else if(s[j]==\\'U\\')\\n                    row--;\\n                else\\n                    row++;\\n                if(row>=n||row<0||col>=n||col<0)\\n                    break;\\n                tot++;\\n            }\\n            res.push_back(tot);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712121,
                "title": "clean-recursive",
                "content": "1\\uFE0F\\u20E3 The problem involves executing a series of instructions on a grid. Each instruction represents a movement in a specific direction (L, R, U, D).\\n\\n2\\uFE0F\\u20E3 The recursive function \"CountMoves\" takes the current position (row and column) on the grid, the instruction string, the current index in the string, and the number of moves made so far.\\n\\n3\\uFE0F\\u20E3 The base cases are checked first: if the position is out of bounds, the function returns the number of moves minus one, indicating an invalid move. If the index reaches the end of the string, the function returns the total number of moves.\\n\\n4\\uFE0F\\u20E3 Based on the current instruction character, the function recursively calls itself with the updated position and index, and increments the number of moves.\\n\\n5\\uFE0F\\u20E3 In the \"executeInstructions\" function, for each character in the instruction string, the \"CountMoves\" function is called with the starting position and the current character index, and the result is stored in the output array.\\n\\n6\\uFE0F\\u20E3 Finally, the output array is returned, containing the number of moves for each instruction in the order they were given.\\n\\nOverall, the solution uses a recursive approach to simulate the movement on the grid according to the given instructions.\\n\\n# Complexity\\n- Time complexity: O(N!)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int CountMoves(int n,int row, int column, string &s, int index, int num_moves){\\n        // Base Case\\n        // if grid is out of bounds\\n        if(row < 0 || row >= n || column < 0 || column >= n){\\n            return num_moves - 1;\\n        }\\n        // if index has reached the end\\n        else if(index >= s.size()){\\n            return num_moves;\\n        }\\n\\n        // \\'L\\'\\n        if(s[index] == \\'L\\'){\\n            return CountMoves(n, row, column - 1, s, index + 1, num_moves + 1);\\n        }\\n        // \\'R\\'\\n        else if(s[index] == \\'R\\'){\\n            return CountMoves(n, row, column + 1, s, index + 1, num_moves + 1);\\n        }\\n\\n        // \\'U\\'\\n        else if(s[index] == \\'U\\'){\\n            return CountMoves(n, row - 1, column , s, index + 1, num_moves + 1);\\n        }\\n\\n        // \\'D\\'\\n        else if(s[index] == \\'D\\'){\\n            return CountMoves(n, row + 1, column , s, index + 1, num_moves + 1);\\n        }\\n\\n        return 0;\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> OutputArr;\\n        for(int i=0; i<s.size(); i++){\\n            OutputArr.push_back(CountMoves(n,startPos[0], startPos[1], s, i, 0));\\n        }\\n\\n        return OutputArr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Recursion",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int CountMoves(int n,int row, int column, string &s, int index, int num_moves){\\n        // Base Case\\n        // if grid is out of bounds\\n        if(row < 0 || row >= n || column < 0 || column >= n){\\n            return num_moves - 1;\\n        }\\n        // if index has reached the end\\n        else if(index >= s.size()){\\n            return num_moves;\\n        }\\n\\n        // \\'L\\'\\n        if(s[index] == \\'L\\'){\\n            return CountMoves(n, row, column - 1, s, index + 1, num_moves + 1);\\n        }\\n        // \\'R\\'\\n        else if(s[index] == \\'R\\'){\\n            return CountMoves(n, row, column + 1, s, index + 1, num_moves + 1);\\n        }\\n\\n        // \\'U\\'\\n        else if(s[index] == \\'U\\'){\\n            return CountMoves(n, row - 1, column , s, index + 1, num_moves + 1);\\n        }\\n\\n        // \\'D\\'\\n        else if(s[index] == \\'D\\'){\\n            return CountMoves(n, row + 1, column , s, index + 1, num_moves + 1);\\n        }\\n\\n        return 0;\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> OutputArr;\\n        for(int i=0; i<s.size(); i++){\\n            OutputArr.push_back(CountMoves(n,startPos[0], startPos[1], s, i, 0));\\n        }\\n\\n        return OutputArr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709142,
                "title": "c-solution-well-commented-o-m-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    TC = O(m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    TC = O(m)\\n# Code\\n```\\nclass Solution {\\n    // Here I have taken only k in the dp state, as i and j are not independent, they are dependent on k\\n    // so we will not include i and j in our dp state that will cause redundancy nothing else\\n    // k --> index of string s\\npublic:\\n    int dp[501];\\n    int helper(int i, int j, int k, int n, string &s){\\n        if(k>=s.size()) return 0;\\n        if(dp[k]!=-1) return dp[k];\\n        int steps=0;\\n        if(s[k]==\\'L\\' && j-1>=0) steps = 1+helper(i, j-1, k+1, n, s);\\n        if(s[k]==\\'R\\' && j+1<n) steps = 1+helper(i, j+1, k+1, n, s);\\n        if(s[k]==\\'U\\' && i-1>=0) steps = 1+helper(i-1, j, k+1, n, s);\\n        if(s[k]==\\'D\\' && i+1<n) steps = 1+helper(i+1, j, k+1, n, s);\\n        return dp[k] = steps;\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int i = startPos[0];\\n        int j = startPos[1];\\n        int m = s.size();\\n        vector<int>res(m);\\n        // starting from every possible indexx in s\\n        for(int k=0; k<m; k++){\\n            memset(dp, -1, sizeof(dp));\\n            res[k] = helper(i, j, k, n, s);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    // Here I have taken only k in the dp state, as i and j are not independent, they are dependent on k\\n    // so we will not include i and j in our dp state that will cause redundancy nothing else\\n    // k --> index of string s\\npublic:\\n    int dp[501];\\n    int helper(int i, int j, int k, int n, string &s){\\n        if(k>=s.size()) return 0;\\n        if(dp[k]!=-1) return dp[k];\\n        int steps=0;\\n        if(s[k]==\\'L\\' && j-1>=0) steps = 1+helper(i, j-1, k+1, n, s);\\n        if(s[k]==\\'R\\' && j+1<n) steps = 1+helper(i, j+1, k+1, n, s);\\n        if(s[k]==\\'U\\' && i-1>=0) steps = 1+helper(i-1, j, k+1, n, s);\\n        if(s[k]==\\'D\\' && i+1<n) steps = 1+helper(i+1, j, k+1, n, s);\\n        return dp[k] = steps;\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int i = startPos[0];\\n        int j = startPos[1];\\n        int m = s.size();\\n        vector<int>res(m);\\n        // starting from every possible indexx in s\\n        for(int k=0; k<m; k++){\\n            memset(dp, -1, sizeof(dp));\\n            res[k] = helper(i, j, k, n, s);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702919,
                "title": "very-simple-solution",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n\\n        int m = s.size();\\n        int i=0,j=0;\\n        vector<int> ans(m);\\n\\n        for(i=0; i<m; i++)\\n        {\\n            int x = startPos[0], y = startPos[1];\\n            int count = 0;\\n\\n            for(j=i; j<m; j++)\\n            {\\n                if(s[j] == \\'L\\')\\n                    y--;\\n\\n                else if(s[j] == \\'R\\')\\n                    y++;\\n\\n                else if(s[j] == \\'U\\')\\n                    x--;\\n\\n                else\\n                    x++;\\n\\n                if((x<0 || x>n-1 ) || (y<0 || y>n-1)){\\n                    ans[i] = count;\\n                    break;\\n                }\\n\\n                count++;\\n            }\\n            if(j == m)\\n                ans[i] = count;\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/d4fc4cd9-cc85-463f-911b-7d5900329120_1688192106.1894977.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n\\n        int m = s.size();\\n        int i=0,j=0;\\n        vector<int> ans(m);\\n\\n        for(i=0; i<m; i++)\\n        {\\n            int x = startPos[0], y = startPos[1];\\n            int count = 0;\\n\\n            for(j=i; j<m; j++)\\n            {\\n                if(s[j] == \\'L\\')\\n                    y--;\\n\\n                else if(s[j] == \\'R\\')\\n                    y++;\\n\\n                else if(s[j] == \\'U\\')\\n                    x--;\\n\\n                else\\n                    x++;\\n\\n                if((x<0 || x>n-1 ) || (y<0 || y>n-1)){\\n                    ans[i] = count;\\n                    break;\\n                }\\n\\n                count++;\\n            }\\n            if(j == m)\\n                ans[i] = count;\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702643,
                "title": "java-solution-simple-solution-easy",
                "content": "# Complexity\\n- Time complexity:\\nO(m*m)\\nWhere m is the length of string \\'s\\'.\\n\\n- Space complexity:\\nO(m)\\nWhere m is the length of string \\'s\\'.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int[] steps = new int[s.length()];\\n\\n        for(int i = 0; i < s.length(); i++){\\n            int posX = startPos[1];\\n            int posY = startPos[0];\\n            int count = 0;\\n            int sIn = i;\\n            Boolean bool = true;\\n\\n            while(posX < n && posY < n && sIn < s.length() && posX >= 0 && posY >= 0){\\n                if(s.charAt(sIn) == \\'R\\'){\\n                    count++;\\n                    posX++;\\n                    sIn++;\\n                }\\n                else if(s.charAt(sIn) == \\'L\\'){\\n                    count++;\\n                    posX--;\\n                    sIn++;\\n                }\\n                else if(s.charAt(sIn) == \\'U\\'){\\n                    count++;\\n                    posY--;\\n                    sIn++;\\n                }\\n                else if(s.charAt(sIn) == \\'D\\'){\\n                    count++;\\n                    posY++;\\n                    sIn++;\\n                }\\n\\n                if(sIn == s.length() && posX < n && posY < n && posX >= 0 && posY >= 0)\\n                    bool = false;\\n            }\\n\\n            if(!bool)\\n                steps[i] = count;\\n            else\\n                steps[i] = count-1;\\n        }\\n\\n        return steps;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int[] steps = new int[s.length()];\\n\\n        for(int i = 0; i < s.length(); i++){\\n            int posX = startPos[1];\\n            int posY = startPos[0];\\n            int count = 0;\\n            int sIn = i;\\n            Boolean bool = true;\\n\\n            while(posX < n && posY < n && sIn < s.length() && posX >= 0 && posY >= 0){\\n                if(s.charAt(sIn) == \\'R\\'){\\n                    count++;\\n                    posX++;\\n                    sIn++;\\n                }\\n                else if(s.charAt(sIn) == \\'L\\'){\\n                    count++;\\n                    posX--;\\n                    sIn++;\\n                }\\n                else if(s.charAt(sIn) == \\'U\\'){\\n                    count++;\\n                    posY--;\\n                    sIn++;\\n                }\\n                else if(s.charAt(sIn) == \\'D\\'){\\n                    count++;\\n                    posY++;\\n                    sIn++;\\n                }\\n\\n                if(sIn == s.length() && posX < n && posY < n && posX >= 0 && posY >= 0)\\n                    bool = false;\\n            }\\n\\n            if(!bool)\\n                steps[i] = count;\\n            else\\n                steps[i] = count-1;\\n        }\\n\\n        return steps;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697512,
                "title": "c-easy",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] ExecuteInstructions(int n, int[] startPos, string s) {\\n            int[] res = new int[s.Length];\\n            int countMoves = 0;\\n            int moved = 0;\\n            \\n            for (int i = 0; i < s.Length; i++)\\n            {\\n                int[] tmpStartPos = (int[])startPos.Clone();\\n\\n                for (int j = 0; j < s.Length - i; j++)\\n                {\\n                    switch (s[j + i])\\n                    {\\n                        case (\\'R\\'):\\n                            if (tmpStartPos[1] + 1 < n)\\n                            {\\n                                countMoves++;\\n                                tmpStartPos[1]++;\\n                                moved++;\\n                            }\\n                            break;\\n                        case (\\'L\\'):\\n                            if (tmpStartPos[1] - 1 < n && tmpStartPos[1] - 1 >= 0)\\n                            {\\n                                countMoves++;\\n                                tmpStartPos[1]--;\\n                                moved++;\\n                            }\\n                            break;\\n                        case (\\'D\\'):\\n                            if (tmpStartPos[0] + 1 < n)\\n                            {\\n                                countMoves++;\\n                                tmpStartPos[0]++;\\n                                moved++;\\n                            }\\n                            break;\\n                        case (\\'U\\'):\\n                            if (tmpStartPos[0] - 1 < n && tmpStartPos[0] - 1 >= 0)\\n                            {\\n                                countMoves++;\\n                                tmpStartPos[0]--;\\n                                moved++;\\n                            }\\n                            break;\\n\\n                    }\\n\\n                    if (moved > 0)\\n                    {\\n                        moved = 0;\\n                        continue;\\n                    }\\n\\n                    break;\\n                   \\n                }\\n\\n                res[i] = countMoves;\\n                countMoves = 0;\\n\\n            }\\n\\n            return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] ExecuteInstructions(int n, int[] startPos, string s) {\\n            int[] res = new int[s.Length];\\n            int countMoves = 0;\\n            int moved = 0;\\n            \\n            for (int i = 0; i < s.Length; i++)\\n            {\\n                int[] tmpStartPos = (int[])startPos.Clone();\\n\\n                for (int j = 0; j < s.Length - i; j++)\\n                {\\n                    switch (s[j + i])\\n                    {\\n                        case (\\'R\\'):\\n                            if (tmpStartPos[1] + 1 < n)\\n                            {\\n                                countMoves++;\\n                                tmpStartPos[1]++;\\n                                moved++;\\n                            }\\n                            break;\\n                        case (\\'L\\'):\\n                            if (tmpStartPos[1] - 1 < n && tmpStartPos[1] - 1 >= 0)\\n                            {\\n                                countMoves++;\\n                                tmpStartPos[1]--;\\n                                moved++;\\n                            }\\n                            break;\\n                        case (\\'D\\'):\\n                            if (tmpStartPos[0] + 1 < n)\\n                            {\\n                                countMoves++;\\n                                tmpStartPos[0]++;\\n                                moved++;\\n                            }\\n                            break;\\n                        case (\\'U\\'):\\n                            if (tmpStartPos[0] - 1 < n && tmpStartPos[0] - 1 >= 0)\\n                            {\\n                                countMoves++;\\n                                tmpStartPos[0]--;\\n                                moved++;\\n                            }\\n                            break;\\n\\n                    }\\n\\n                    if (moved > 0)\\n                    {\\n                        moved = 0;\\n                        continue;\\n                    }\\n\\n                    break;\\n                   \\n                }\\n\\n                res[i] = countMoves;\\n                countMoves = 0;\\n\\n            }\\n\\n            return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676921,
                "title": "simple-but-beginner-friendly-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int[] ans = new int[s.length()];\\n        map=new HashMap<>();\\n        map.put(\\'R\\',new int[]{0,1});\\n        map.put(\\'L\\',new int[]{0,-1});\\n        map.put(\\'U\\',new int[]{-1,0});\\n        map.put(\\'D\\',new int[]{1,0});\\n        for(int i=0;i<s.length();i++){\\n            ans[i]=dfs(startPos[0],startPos[1],n,s,i);\\n        }\\n        return ans;\\n    }\\n    private HashMap<Character,int[]> map;\\n    public int dfs(int r,int c,int n,String s,int idx){\\n        int m=s.length();\\n        int res=0;\\n        for(int i=idx;i<m;i++){\\n            int[] d=map.get(s.charAt(i));\\n            r=d[0]+r;\\n            c=d[1]+c;\\n            if(!isValid(r,c,n))return res;\\n            res++;\\n        }\\n        return res;\\n    }\\n    public boolean isValid(int r,int c,int n){\\n        if(r<0 || c<0 || r>=n || c>=n)return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int[] ans = new int[s.length()];\\n        map=new HashMap<>();\\n        map.put(\\'R\\',new int[]{0,1});\\n        map.put(\\'L\\',new int[]{0,-1});\\n        map.put(\\'U\\',new int[]{-1,0});\\n        map.put(\\'D\\',new int[]{1,0});\\n        for(int i=0;i<s.length();i++){\\n            ans[i]=dfs(startPos[0],startPos[1],n,s,i);\\n        }\\n        return ans;\\n    }\\n    private HashMap<Character,int[]> map;\\n    public int dfs(int r,int c,int n,String s,int idx){\\n        int m=s.length();\\n        int res=0;\\n        for(int i=idx;i<m;i++){\\n            int[] d=map.get(s.charAt(i));\\n            r=d[0]+r;\\n            c=d[1]+c;\\n            if(!isValid(r,c,n))return res;\\n            res++;\\n        }\\n        return res;\\n    }\\n    public boolean isValid(int r,int c,int n){\\n        if(r<0 || c<0 || r>=n || c>=n)return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676844,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    boolean isValidPath(int [][]matrix,int n,int x,int y,char step)\\n    {\\n        if(step==\\'R\\')\\n        {\\n            y=y+1;\\n        }\\n        else if(step==\\'L\\')\\n        {\\n            y=y-1;\\n        }\\n        else if(step==\\'U\\')\\n        {\\n            x=x-1;\\n        }\\n        else\\n        {\\n            x=x+1;\\n        }\\n        if(x>=0 && x<=n-1 && y>=0 && y<=n-1)\\n            return true;\\n        return false;\\n    }\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int [][]matrix=new int[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[i][j]=0;\\n            }\\n        }\\n        int l=s.length();\\n        int[] answer=new int[l];\\n        for(int i=0;i<l;i++)\\n        {\\n            int walk=0;\\n            int x=startPos[0],y=startPos[1];\\n\\n            for(int j=i;j<l;j++)\\n            {\\n                if(isValidPath(matrix,n,x,y,s.charAt(j)))\\n                {\\n                    walk++;\\n                    if(s.charAt(j)==\\'R\\')\\n                        y=y+1;\\n                    else if(s.charAt(j)==\\'L\\')\\n                        y=y-1;\\n                    else if(s.charAt(j)==\\'U\\')\\n                        x=x-1;\\n                    else\\n                        x=x+1;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            answer[i]=walk;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    boolean isValidPath(int [][]matrix,int n,int x,int y,char step)\\n    {\\n        if(step==\\'R\\')\\n        {\\n            y=y+1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3666913,
                "title": "easy-implementation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidStep(int & n, int & x, int & y, char c){\\n        int left = 0;\\n        int right = n-1;\\n        int top = 0;\\n        int bottom = n-1;\\n\\n        if(c == \\'R\\')\\n            y++;\\n        else if(c==\\'L\\')\\n            y--;\\n        else if(c==\\'U\\')\\n            x--;\\n        else if(c == \\'D\\')\\n            x++;\\n        \\n        return (x>=left && x<= right \\n                && y>=top && y<=bottom);\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int>result;\\n        int x = startPos[0];\\n        int y = startPos[1];\\n        while(!s.empty()){\\n            int validSteps = 0;\\n            for(auto c : s){\\n                if(isValidStep(n, x, y, c))\\n                    validSteps++;\\n                else\\n                    break;\\n            }\\n            result.push_back(validSteps);\\n            x = startPos[0];\\n            y = startPos[1];\\n            s.erase(s.begin());\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidStep(int & n, int & x, int & y, char c){\\n        int left = 0;\\n        int right = n-1;\\n        int top = 0;\\n        int bottom = n-1;\\n\\n        if(c == \\'R\\')\\n            y++;\\n        else if(c==\\'L\\')\\n            y--;\\n        else if(c==\\'U\\')\\n            x--;\\n        else if(c == \\'D\\')\\n            x++;\\n        \\n        return (x>=left && x<= right \\n                && y>=top && y<=bottom);\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int>result;\\n        int x = startPos[0];\\n        int y = startPos[1];\\n        while(!s.empty()){\\n            int validSteps = 0;\\n            for(auto c : s){\\n                if(isValidStep(n, x, y, c))\\n                    validSteps++;\\n                else\\n                    break;\\n            }\\n            result.push_back(validSteps);\\n            x = startPos[0];\\n            y = startPos[1];\\n            s.erase(s.begin());\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658711,
                "title": "straightforward-match-case-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        res = []\\n        for i in range(len(s)):\\n            moves = s[i:]\\n            counter = 0\\n            curPos = startPos[:]\\n            for move in moves:\\n                match move:\\n                    case \"R\":\\n                        curPos[1] += 1\\n                    case \"L\":\\n                        curPos[1] -= 1\\n                    case \"U\":\\n                        curPos[0] -= 1\\n                    case \"D\":\\n                        curPos[0] += 1\\n                    case _:\\n                        raise Exception()\\n                if not 0 <= curPos[0] < n or not 0 <= curPos[1] < n:\\n                    break\\n                counter += 1\\n            res.append(counter)\\n        return res\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        res = []\\n        for i in range(len(s)):\\n            moves = s[i:]\\n            counter = 0\\n            curPos = startPos[:]\\n            for move in moves:\\n                match move:\\n                    case \"R\":\\n                        curPos[1] += 1\\n                    case \"L\":\\n                        curPos[1] -= 1\\n                    case \"U\":\\n                        curPos[0] -= 1\\n                    case \"D\":\\n                        curPos[0] += 1\\n                    case _:\\n                        raise Exception()\\n                if not 0 <= curPos[0] < n or not 0 <= curPos[1] < n:\\n                    break\\n                counter += 1\\n            res.append(counter)\\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658238,
                "title": "easy-solution-using-loops-and-switch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int[] executeInstructions(int n, int[] startPos, String s) {\\n        int col = startPos[0];\\n        int row = startPos[1];\\n        int[] arr = new int[s.length()];\\n        for(int i = 0; i < s.length(); i++) {\\n            col = startPos[0];\\n            row = startPos[1];\\n          loop:  for(int j = i; j < s.length(); j++) {\\n                switch(s.charAt(j)) {\\n                    case \\'U\\' -> {\\n                        if(col > 0) {\\n                            col--;\\n                        }\\n                        else break loop;\\n                    }\\n                    case \\'D\\' -> {\\n                        if(col < n-1) {\\n                            col++;\\n                        }\\n                        else break loop;\\n                    }\\n                    case \\'L\\' -> {\\n                        if(row > 0) {\\n                            row--;\\n                        }\\n                        else break loop;\\n                    }\\n                    case \\'R\\' ->  {\\n                        if(row < n-1) {\\n                            row++;\\n                        }\\n                        else break loop;\\n                    }\\n                }\\n                arr[i]++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] executeInstructions(int n, int[] startPos, String s) {\\n        int col = startPos[0];\\n        int row = startPos[1];\\n        int[] arr = new int[s.length()];\\n        for(int i = 0; i < s.length(); i++) {\\n            col = startPos[0];\\n            row = startPos[1];\\n          loop:  for(int j = i; j < s.length(); j++) {\\n                switch(s.charAt(j)) {\\n                    case \\'U\\' -> {\\n                        if(col > 0) {\\n                            col--;\\n                        }\\n                        else break loop;\\n                    }\\n                    case \\'D\\' -> {\\n                        if(col < n-1) {\\n                            col++;\\n                        }\\n                        else break loop;\\n                    }\\n                    case \\'L\\' -> {\\n                        if(row > 0) {\\n                            row--;\\n                        }\\n                        else break loop;\\n                    }\\n                    case \\'R\\' ->  {\\n                        if(row < n-1) {\\n                            row++;\\n                        }\\n                        else break loop;\\n                    }\\n                }\\n                arr[i]++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649956,
                "title": "elixir-solution-use-enum-reduce-while",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 574ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 64.9MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec execute_instructions(n :: integer, start_pos :: [integer], s :: String.t) :: [integer]\\n  def execute_instructions(n, start_pos, s) do\\n    execute_instructions(n, Enum.at(start_pos, 1), Enum.at(start_pos, 0), String.codepoints(s), []) |> Enum.reverse()\\n  end\\n\\n  @spec execute_instructions(n :: integer, x :: integer, y :: integer, s :: [char], res :: [integer]) :: [integer]\\n  def execute_instructions(_, _, _, s, res) when s == [] do\\n    res\\n  end\\n\\n  def execute_instructions(n, x, y, s, res) do\\n    execute_instructions(n, x, y, s |> tl, [helper(n, x, y, s) | res])\\n  end\\n\\n  @spec helper(n :: integer, x :: integer, y :: integer, s :: [char]) :: integer\\n  def helper(n, x, y, s) do\\n    Enum.reduce_while(s, {x, y, 0}, fn inst, {x, y, cnt} ->\\n      {x, y} =\\n        cond do\\n          inst == \"L\" ->\\n            {x - 1, y}\\n          inst == \"R\" ->\\n            {x + 1, y}\\n          inst == \"U\" ->\\n            {x, y - 1}\\n          inst == \"D\" ->\\n            {x, y + 1}\\n        end\\n      if x < 0 or y < 0 or x == n or y == n do\\n        {:halt, {x, y, cnt}}\\n      else\\n        {:cont, {x, y, cnt + 1}}\\n      end\\n    end) |> elem(2)\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec execute_instructions(n :: integer, start_pos :: [integer], s :: String.t) :: [integer]\\n  def execute_instructions(n, start_pos, s) do\\n    execute_instructions(n, Enum.at(start_pos, 1), Enum.at(start_pos, 0), String.codepoints(s), []) |> Enum.reverse()\\n  end\\n\\n  @spec execute_instructions(n :: integer, x :: integer, y :: integer, s :: [char], res :: [integer]) :: [integer]\\n  def execute_instructions(_, _, _, s, res) when s == [] do\\n    res\\n  end\\n\\n  def execute_instructions(n, x, y, s, res) do\\n    execute_instructions(n, x, y, s |> tl, [helper(n, x, y, s) | res])\\n  end\\n\\n  @spec helper(n :: integer, x :: integer, y :: integer, s :: [char]) :: integer\\n  def helper(n, x, y, s) do\\n    Enum.reduce_while(s, {x, y, 0}, fn inst, {x, y, cnt} ->\\n      {x, y} =\\n        cond do\\n          inst == \"L\" ->\\n            {x - 1, y}\\n          inst == \"R\" ->\\n            {x + 1, y}\\n          inst == \"U\" ->\\n            {x, y - 1}\\n          inst == \"D\" ->\\n            {x, y + 1}\\n        end\\n      if x < 0 or y < 0 or x == n or y == n do\\n        {:halt, {x, y, cnt}}\\n      else\\n        {:cont, {x, y, cnt + 1}}\\n      end\\n    end) |> elem(2)\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3618378,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sr;\\n    int sc;\\n    vector<int> executeInstructions(int n, vector<int>&arr, string s) {\\n        sr=arr[0];\\n        sc=arr[1];\\n        vector<int>ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            ans.push_back(fun(s,i,n));\\n        }\\n        return ans;\\n    }\\n    int fun(string &s,int idx,int n)\\n    {\\n        int row=sr;\\n        int col=sc;\\n        int ans=0;\\n        while(idx<s.length() and isvalid(row,col,n))\\n        {\\n            if(s[idx]==\\'R\\')\\n            {\\n                col+=1;\\n            }\\n            else if(s[idx]==\\'L\\')\\n            {\\n                col-=1;\\n            }\\n            else if(s[idx]==\\'U\\')\\n            {\\n                row-=1;\\n            }\\n            else if(s[idx]==\\'D\\')\\n            {\\n                row+=1;\\n            }\\n            idx++;\\n            if(isvalid(row,col,n))\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool isvalid(int &r,int &c,int &n)\\n    {\\n        if(r<0 or c<0 or r>=n or c>=n)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sr;\\n    int sc;\\n    vector<int> executeInstructions(int n, vector<int>&arr, string s) {\\n        sr=arr[0];\\n        sc=arr[1];\\n        vector<int>ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            ans.push_back(fun(s,i,n));\\n        }\\n        return ans;\\n    }\\n    int fun(string &s,int idx,int n)\\n    {\\n        int row=sr;\\n        int col=sc;\\n        int ans=0;\\n        while(idx<s.length() and isvalid(row,col,n))\\n        {\\n            if(s[idx]==\\'R\\')\\n            {\\n                col+=1;\\n            }\\n            else if(s[idx]==\\'L\\')\\n            {\\n                col-=1;\\n            }\\n            else if(s[idx]==\\'U\\')\\n            {\\n                row-=1;\\n            }\\n            else if(s[idx]==\\'D\\')\\n            {\\n                row+=1;\\n            }\\n            idx++;\\n            if(isvalid(row,col,n))\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool isvalid(int &r,int &c,int &n)\\n    {\\n        if(r<0 or c<0 or r>=n or c>=n)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613037,
                "title": "java-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        Map<Character, Pair> map = new HashMap<>();\\n        map.put(\\'U\\', new Pair(-1, 0));\\n        map.put(\\'D\\', new Pair(1,0));\\n        map.put(\\'L\\', new Pair(0,-1));\\n        map.put(\\'R\\', new Pair(0,1));\\n        int[] res = new int[s.length()];\\n        for(int i=0; i<s.length(); i++) {\\n            int x = startPos[0];\\n            int y = startPos[1];\\n            int count = 0;\\n            res[i] = checkExecution(s, x, y, map, i, n, count);\\n        }\\n        return res;\\n\\n    }\\n\\n    int checkExecution(String s, int x, int y, Map<Character, Pair> map, int i, int n, int count) {\\n        if(x < 0 || y < 0 || x >= n || y >= n) {\\n            return count-1;\\n        } else if(i >= s.length()) {\\n            return count;\\n        }\\n        char c = s.charAt(i);\\n        Pair turn = map.get(c);\\n        x += turn.x;\\n        y += turn.y;\\n        count++;\\n        i++;\\n        \\n        return checkExecution(s, x, y, map, i, n, count);\\n    }\\n}\\n\\nclass Pair {\\n    int x;\\n    int y;\\n\\n    public Pair(int x, int y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        Map<Character, Pair> map = new HashMap<>();\\n        map.put(\\'U\\', new Pair(-1, 0));\\n        map.put(\\'D\\', new Pair(1,0));\\n        map.put(\\'L\\', new Pair(0,-1));\\n        map.put(\\'R\\', new Pair(0,1));\\n        int[] res = new int[s.length()];\\n        for(int i=0; i<s.length(); i++) {\\n            int x = startPos[0];\\n            int y = startPos[1];\\n            int count = 0;\\n            res[i] = checkExecution(s, x, y, map, i, n, count);\\n        }\\n        return res;\\n\\n    }\\n\\n    int checkExecution(String s, int x, int y, Map<Character, Pair> map, int i, int n, int count) {\\n        if(x < 0 || y < 0 || x >= n || y >= n) {\\n            return count-1;\\n        } else if(i >= s.length()) {\\n            return count;\\n        }\\n        char c = s.charAt(i);\\n        Pair turn = map.get(c);\\n        x += turn.x;\\n        y += turn.y;\\n        count++;\\n        i++;\\n        \\n        return checkExecution(s, x, y, map, i, n, count);\\n    }\\n}\\n\\nclass Pair {\\n    int x;\\n    int y;\\n\\n    public Pair(int x, int y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592902,
                "title": "solution-in-python-easy-to-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def executeInstructions(self, n, startPos, s):\\n        \"\"\"\\n        :type n: int\\n        :type startPos: List[int]\\n        :type s: str\\n        :rtype: List[int]\\n        \"\"\"\\n        l=[]\\n        for i in range(len(s)):\\n            r=0\\n            x=startPos[0]\\n            y=startPos[1]\\n            for j in range(i,len(s)):\\n                if s[j]==\\'D\\':\\n                    if x<n-1:\\n                        x=x+1\\n                        r=r+1\\n                    else:\\n                        break    \\n                elif s[j]==\\'U\\':\\n                    if x>0:\\n                        x=x-1\\n                        r=r+1\\n                    else:\\n                        break\\n                elif s[j]==\\'R\\':\\n                    if y<n-1:\\n                        y=y+1\\n                        r=r+1\\n                    else:\\n                        break \\n                else:\\n                    if y>0:\\n                        y=y-1\\n                        r=r+1\\n                    else:\\n                        break\\n            l.append(r)\\n        return l                                                   \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def executeInstructions(self, n, startPos, s):\\n        \"\"\"\\n        :type n: int\\n        :type startPos: List[int]\\n        :type s: str\\n        :rtype: List[int]\\n        \"\"\"\\n        l=[]\\n        for i in range(len(s)):\\n            r=0\\n            x=startPos[0]\\n            y=startPos[1]\\n            for j in range(i,len(s)):\\n                if s[j]==\\'D\\':\\n                    if x<n-1:\\n                        x=x+1\\n                        r=r+1\\n                    else:\\n                        break    \\n                elif s[j]==\\'U\\':\\n                    if x>0:\\n                        x=x-1\\n                        r=r+1\\n                    else:\\n                        break\\n                elif s[j]==\\'R\\':\\n                    if y<n-1:\\n                        y=y+1\\n                        r=r+1\\n                    else:\\n                        break \\n                else:\\n                    if y>0:\\n                        y=y-1\\n                        r=r+1\\n                    else:\\n                        break\\n            l.append(r)\\n        return l                                                   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591402,
                "title": "java-soln-simulation",
                "content": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int m = s.length();\\n        int[] executions = new int[m];\\n        int startX = startPos[0], startY = startPos[1];\\n        for(int i = 0; i < m; i++) {\\n            String curInstruction = s.substring(i);\\n            int curExec = 0;\\n            int[] curPos = new int[] {startX, startY};\\n            while(curExec < curInstruction.length()) {\\n                switch (curInstruction.charAt(curExec))  {\\n                    case \\'R\\' :\\n                        curPos[1] += 1;\\n                        break;\\n                    case \\'D\\' :\\n                        curPos[0] += 1;\\n                        break;\\n                    case \\'L\\' :\\n                        curPos[1] -= 1;\\n                        break;\\n                    case \\'U\\' :\\n                        curPos[0] -= 1;\\n                        break;\\n                }\\n                if(curPos[0] < 0 || curPos[0] >= n || curPos[1] < 0 || curPos[1] >= n) {\\n                    break;\\n                }\\n                curExec++;\\n            }\\n            \\n            executions[i] = curExec;\\n        }\\n        \\n        return executions;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int m = s.length();\\n        int[] executions = new int[m];\\n        int startX = startPos[0], startY = startPos[1];\\n        for(int i = 0; i < m; i++) {\\n            String curInstruction = s.substring(i);\\n            int curExec = 0;\\n            int[] curPos = new int[] {startX, startY};\\n            while(curExec < curInstruction.length()) {\\n                switch (curInstruction.charAt(curExec))  {\\n                    case \\'R\\' :\\n                        curPos[1] += 1;\\n                        break;\\n                    case \\'D\\' :\\n                        curPos[0] += 1;\\n                        break;\\n                    case \\'L\\' :\\n                        curPos[1] -= 1;\\n                        break;\\n                    case \\'U\\' :\\n                        curPos[0] -= 1;\\n                        break;\\n                }\\n                if(curPos[0] < 0 || curPos[0] >= n || curPos[1] < 0 || curPos[1] >= n) {\\n                    break;\\n                }\\n                curExec++;\\n            }\\n            \\n            executions[i] = curExec;\\n        }\\n        \\n        return executions;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579809,
                "title": "alternative-solution-java",
                "content": "Alternative solution\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n\\n         int[] currentPos = startPos.clone();\\n     \\n         int[] answer = new int[s.length()];\\n\\n\\n        char[] charArray = s.toCharArray();\\n\\n        System.out.println(Arrays.toString(charArray));\\n        int counter = 0;\\n        int tester = 0;\\n        while(charArray[charArray.length-1]!=\\'x\\'){\\n            for (int i = 0; i < charArray.length; i++) {\\n\\n                if (charArray[i]==\\'R\\'){\\n                        currentPos[1]++;\\n                        if(currentPos[1]>n-1 || currentPos[1]<0){\\n                            answer[tester] = counter;\\n                            charArray[tester] = \\'x\\';\\n                            currentPos = startPos.clone();\\n                            counter=0;\\n                            tester++;\\n                            break;\\n                        }else if(i == charArray.length-1) {\\n                            counter++;\\n                            answer[tester] = counter;\\n                            charArray[tester] = \\'x\\';\\n                            currentPos = startPos.clone();\\n                            counter=0;\\n                            tester++;\\n                            break;\\n                    }\\n                    counter++;\\n                    }\\n\\n                    if (charArray[i]==\\'L\\'){\\n                        currentPos[1]--;\\n                        if(currentPos[1]>n-1 || currentPos[1]<0){\\n                            answer[tester] = counter;\\n                            charArray[tester] = \\'x\\';\\n                            currentPos = startPos.clone();\\n                            counter=0;\\n                            tester++;\\n                            break;\\n                        }else if(i == charArray.length-1) {\\n                            counter++;\\n                            answer[tester] = counter;\\n                            charArray[tester] = \\'x\\';\\n                            currentPos = startPos.clone();\\n                            counter=0;\\n                            tester++;\\n                            break;\\n                        }\\n                        counter++;\\n                    }\\n                    if (charArray[i]==\\'U\\'){\\n                        currentPos[0]--;\\n                        if(currentPos[0]>n-1 || currentPos[0]<0){\\n                            answer[tester] = counter;\\n                            charArray[tester] = \\'x\\';\\n                            currentPos = startPos.clone();\\n                            counter=0;\\n                            tester++;\\n                            break;\\n                        }else if(i == charArray.length-1) {\\n                            counter++;\\n                            answer[tester] = counter;\\n                            charArray[tester] = \\'x\\';\\n                            currentPos = startPos.clone();\\n                            counter=0;\\n                            tester++;\\n                            break;\\n                        }\\n                        counter++;\\n                    }\\n\\n                    if (charArray[i]==\\'D\\'){\\n                        currentPos[0]++;\\n                        if(currentPos[0]>n-1 || currentPos[0]<0){\\n                            answer[tester] = counter;\\n                            charArray[tester] = \\'x\\';\\n                            currentPos = startPos.clone();\\n                            counter=0;\\n                            tester++;\\n                            break;\\n                        }else if(i == charArray.length-1) {\\n                            counter++;\\n                            answer[tester] = counter;\\n                            charArray[tester] = \\'x\\';\\n                            currentPos = startPos.clone();\\n                            counter=0;\\n                            tester++;\\n                            break;\\n                        }\\n                        counter++;\\n                    }\\n\\n            }\\n        }\\n\\n       return answer;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n\\n         int[] currentPos = startPos.clone();\\n     \\n         int[] answer = new int[s.length()];\\n\\n\\n        char[] charArray = s.toCharArray();\\n\\n        System.out.println(Arrays.toString(charArray));\\n        int counter = 0;\\n        int tester = 0;\\n        while(charArray[charArray.length-1]!=\\'x\\'){\\n            for (int i = 0; i < charArray.length; i++) {\\n\\n                if (charArray[i]==\\'R\\'){\\n                        currentPos[1]++;\\n                        if(currentPos[1]>n-1 || currentPos[1]<0){\\n                            answer[tester] = counter;\\n                            charArray[tester] = \\'x\\';\\n                            currentPos = startPos.clone();\\n                            counter=0;\\n                            tester++;\\n                            break;\\n                        }else if(i == charArray.length-1) {\\n                            counter++;\\n                            answer[tester] = counter;\\n                            charArray[tester] = \\'x\\';\\n                            currentPos = startPos.clone();\\n                            counter=0;\\n                            tester++;\\n                            break;\\n                    }\\n                    counter++;\\n                    }\\n\\n                    if (charArray[i]==\\'L\\'){\\n                        currentPos[1]--;\\n                        if(currentPos[1]>n-1 || currentPos[1]<0){\\n                            answer[tester] = counter;\\n                            charArray[tester] = \\'x\\';\\n                            currentPos = startPos.clone();\\n                            counter=0;\\n                            tester++;\\n                            break;\\n                        }else if(i == charArray.length-1) {\\n                            counter++;\\n                            answer[tester] = counter;\\n                            charArray[tester] = \\'x\\';\\n                            currentPos = startPos.clone();\\n                            counter=0;\\n                            tester++;\\n                            break;\\n                        }\\n                        counter++;\\n                    }\\n                    if (charArray[i]==\\'U\\'){\\n                        currentPos[0]--;\\n                        if(currentPos[0]>n-1 || currentPos[0]<0){\\n                            answer[tester] = counter;\\n                            charArray[tester] = \\'x\\';\\n                            currentPos = startPos.clone();\\n                            counter=0;\\n                            tester++;\\n                            break;\\n                        }else if(i == charArray.length-1) {\\n                            counter++;\\n                            answer[tester] = counter;\\n                            charArray[tester] = \\'x\\';\\n                            currentPos = startPos.clone();\\n                            counter=0;\\n                            tester++;\\n                            break;\\n                        }\\n                        counter++;\\n                    }\\n\\n                    if (charArray[i]==\\'D\\'){\\n                        currentPos[0]++;\\n                        if(currentPos[0]>n-1 || currentPos[0]<0){\\n                            answer[tester] = counter;\\n                            charArray[tester] = \\'x\\';\\n                            currentPos = startPos.clone();\\n                            counter=0;\\n                            tester++;\\n                            break;\\n                        }else if(i == charArray.length-1) {\\n                            counter++;\\n                            answer[tester] = counter;\\n                            charArray[tester] = \\'x\\';\\n                            currentPos = startPos.clone();\\n                            counter=0;\\n                            tester++;\\n                            break;\\n                        }\\n                        counter++;\\n                    }\\n\\n            }\\n        }\\n\\n       return answer;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579803,
                "title": "bruteforce-solution-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n\\n        answer = []\\n        for fr, _ in enumerate(s):\\n            i, j = startPos\\n            counter = 0\\n            for cur_i in range(fr, len(s)):\\n                cur_ch = s[cur_i]\\n                if cur_ch == \"R\":\\n                    if j+1 < n:\\n                        j += 1\\n                        counter += 1\\n                    else:\\n                        answer.append(counter)\\n                        break\\n                if cur_ch == \"L\":\\n                    if j-1 >= 0:\\n                        j -= 1\\n                        counter += 1\\n                    else:\\n                        answer.append(counter)\\n                        break\\n                if cur_ch == \"U\":\\n                    if i-1 >= 0:\\n                        i -= 1\\n                        counter += 1\\n                    else:\\n                        answer.append(counter)\\n                        break\\n                if cur_ch == \"D\":\\n                    if i+1 < n:\\n                        i += 1\\n                        counter += 1\\n                    else:\\n                        answer.append(counter)\\n                        break\\n            else:\\n                answer.append(counter)\\n            \\n\\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n\\n        answer = []\\n        for fr, _ in enumerate(s):\\n            i, j = startPos\\n            counter = 0\\n            for cur_i in range(fr, len(s)):\\n                cur_ch = s[cur_i]\\n                if cur_ch == \"R\":\\n                    if j+1 < n:\\n                        j += 1\\n                        counter += 1\\n                    else:\\n                        answer.append(counter)\\n                        break\\n                if cur_ch == \"L\":\\n                    if j-1 >= 0:\\n                        j -= 1\\n                        counter += 1\\n                    else:\\n                        answer.append(counter)\\n                        break\\n                if cur_ch == \"U\":\\n                    if i-1 >= 0:\\n                        i -= 1\\n                        counter += 1\\n                    else:\\n                        answer.append(counter)\\n                        break\\n                if cur_ch == \"D\":\\n                    if i+1 < n:\\n                        i += 1\\n                        counter += 1\\n                    else:\\n                        answer.append(counter)\\n                        break\\n            else:\\n                answer.append(counter)\\n            \\n\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530616,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        const int r = startPos[0];\\n        const int c = startPos[1];\\n        const int N = s.length();\\n        vector<int> ans(N, 0);\\n        \\n        for(int i = 0; i < N; ++i) {\\n            int y = r;\\n            int x = c;\\n            int j = i;\\n            for(; j < N; ++j) {\\n                switch(s[j]) {\\n                case \\'L\\':\\n                    x -= 1;\\n                    break;\\n                case \\'R\\':\\n                    x += 1;\\n                    break;\\n                case \\'U\\':\\n                    y -= 1;\\n                    break;\\n                case \\'D\\':\\n                    y += 1;\\n                    break;\\n                }\\n                if(x < 0 || y < 0 || x >= n || y >= n)\\n                    break;\\n            }\\n            ans[i] = j - i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        const int r = startPos[0];\\n        const int c = startPos[1];\\n        const int N = s.length();\\n        vector<int> ans(N, 0);\\n        \\n        for(int i = 0; i < N; ++i) {\\n            int y = r;\\n            int x = c;\\n            int j = i;\\n            for(; j < N; ++j) {\\n                switch(s[j]) {\\n                case \\'L\\':\\n                    x -= 1;\\n                    break;\\n                case \\'R\\':\\n                    x += 1;\\n                    break;\\n                case \\'U\\':\\n                    y -= 1;\\n                    break;\\n                case \\'D\\':\\n                    y += 1;\\n                    break;\\n                }\\n                if(x < 0 || y < 0 || x >= n || y >= n)\\n                    break;\\n            }\\n            ans[i] = j - i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526874,
                "title": "execution-of-all-suffix-instructions-easy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) \\n    {\\n        int m = s.size();\\n        vector<int>ans(m,0);\\n\\n        for(int i = 0; i<m; i++)\\n        {\\n            int a = startPos[0];\\n            int b = startPos[1];\\n            int j = i;\\n            int as = 0;\\n            while(a<n and b<n and a>=0 and b>=0 and j<m )\\n            {\\n                if(s[j]==\\'R\\' and b!=n-1)\\n                {\\n                    b++;\\n                    as++;\\n                }\\n                else if(s[j] == \\'L\\' and b!=0)\\n                {\\n                    b--;\\n                    as++;\\n                }\\n                else if(s[j] == \\'U\\' and a!=0)\\n                {\\n                    a--;\\n                    as++;\\n                }\\n                else if(s[j] == \\'D\\' and a!=n-1)\\n                {\\n                    a++;\\n                    as++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n                j++;\\n            }\\n            ans[i] = as;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) \\n    {\\n        int m = s.size();\\n        vector<int>ans(m,0);\\n\\n        for(int i = 0; i<m; i++)\\n        {\\n            int a = startPos[0];\\n            int b = startPos[1];\\n            int j = i;\\n            int as = 0;\\n            while(a<n and b<n and a>=0 and b>=0 and j<m )\\n            {\\n                if(s[j]==\\'R\\' and b!=n-1)\\n                {\\n                    b++;\\n                    as++;\\n                }\\n                else if(s[j] == \\'L\\' and b!=0)\\n                {\\n                    b--;\\n                    as++;\\n                }\\n                else if(s[j] == \\'U\\' and a!=0)\\n                {\\n                    a--;\\n                    as++;\\n                }\\n                else if(s[j] == \\'D\\' and a!=n-1)\\n                {\\n                    a++;\\n                    as++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n                j++;\\n            }\\n            ans[i] = as;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516777,
                "title": "javascript-90-runtime",
                "content": "```\\nconst executeInstructions = (n, ini, s) =>\\n  new Array(s.length).fill(0).map((steps, i) => {\\n    let pos = [...ini];\\n    for (let j = i; j < s.length; j++) {\\n      const move = s[j];\\n      if (move === \"U\") pos[0]--;\\n      if (move === \"R\") pos[1]++;\\n      if (move === \"D\") pos[0]++;\\n      if (move === \"L\") pos[1]--;\\n      if (pos[0] > n - 1 || pos[0] < 0 || pos[1] > n - 1 || pos[1] < 0) break;\\n      steps++;\\n    }\\n    return steps;\\n  });\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst executeInstructions = (n, ini, s) =>\\n  new Array(s.length).fill(0).map((steps, i) => {\\n    let pos = [...ini];\\n    for (let j = i; j < s.length; j++) {\\n      const move = s[j];\\n      if (move === \"U\") pos[0]--;\\n      if (move === \"R\") pos[1]++;\\n      if (move === \"D\") pos[0]++;\\n      if (move === \"L\") pos[1]--;\\n      if (pos[0] > n - 1 || pos[0] < 0 || pos[1] > n - 1 || pos[1] < 0) break;\\n      steps++;\\n    }\\n    return steps;\\n  });\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3509684,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int x;\\n        int y;\\n        int c=0;\\n        int arr[]=new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            x=startPos[0];\\n            y=startPos[1];\\n            c=0;\\n            for(int j=i;j<s.length();j++){\\n                if(s.charAt(j)==\\'R\\'){\\n                    y+=1;\\n                    if(y>=n){\\n                        break;\\n                    }\\n                }\\n                else if(s.charAt(j)==\\'D\\')\\n                {\\n                    x+=1;\\n                    if(x>=n){\\n                        break;\\n                    }\\n                }\\n                else if(s.charAt(j)==\\'L\\'){\\n                    y-=1;\\n                    if(y<0){\\n                        break;\\n                    }\\n                }\\n                else if(s.charAt(j)==\\'U\\'){\\n                    x-=1;\\n                    if(x<0){\\n                        break;\\n                    }\\n                }\\n                c+=1;\\n            }\\n            arr[i]=c;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int x;\\n        int y;\\n        int c=0;\\n        int arr[]=new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            x=startPos[0];\\n            y=startPos[1];\\n            c=0;\\n            for(int j=i;j<s.length();j++){\\n                if(s.charAt(j)==\\'R\\'){\\n                    y+=1;\\n                    if(y>=n){\\n                        break;\\n                    }\\n                }\\n                else if(s.charAt(j)==\\'D\\')\\n                {\\n                    x+=1;\\n                    if(x>=n){\\n                        break;\\n                    }\\n                }\\n                else if(s.charAt(j)==\\'L\\'){\\n                    y-=1;\\n                    if(y<0){\\n                        break;\\n                    }\\n                }\\n                else if(s.charAt(j)==\\'U\\'){\\n                    x-=1;\\n                    if(x<0){\\n                        break;\\n                    }\\n                }\\n                c+=1;\\n            }\\n            arr[i]=c;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498319,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        List<Integer> ans = new ArrayList<>();\\n        int sLen = s.length();\\n\\n        for (int k = 0; k < sLen; k++)\\n            ans.add(getInstructions(n, startPos, s.substring(k, sLen)));\\n\\n        return ans.stream().mapToInt(l -> l).toArray();\\n    }\\n\\n    private int getInstructions(int n, int[] startPos, String str) {\\n        int count = 0;\\n        int i = startPos[0];\\n        int j = startPos[1];\\n\\n        for (char ch: str.toCharArray()) {\\n            if (ch == \\'R\\')\\n                j++;\\n            \\n            else if (ch == \\'U\\')\\n                i--;\\n            \\n            else if (ch == \\'L\\')\\n                j--;\\n            \\n            else if (ch == \\'D\\')\\n                i++;\\n            \\n            if (i < 0 || j < 0 || i >= n || j >= n)\\n                return count;\\n            \\n            count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        List<Integer> ans = new ArrayList<>();\\n        int sLen = s.length();\\n\\n        for (int k = 0; k < sLen; k++)\\n            ans.add(getInstructions(n, startPos, s.substring(k, sLen)));\\n\\n        return ans.stream().mapToInt(l -> l).toArray();\\n    }\\n\\n    private int getInstructions(int n, int[] startPos, String str) {\\n        int count = 0;\\n        int i = startPos[0];\\n        int j = startPos[1];\\n\\n        for (char ch: str.toCharArray()) {\\n            if (ch == \\'R\\')\\n                j++;\\n            \\n            else if (ch == \\'U\\')\\n                i--;\\n            \\n            else if (ch == \\'L\\')\\n                j--;\\n            \\n            else if (ch == \\'D\\')\\n                i++;\\n            \\n            if (i < 0 || j < 0 || i >= n || j >= n)\\n                return count;\\n            \\n            count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494216,
                "title": "java-easy-to-understand-beats-80",
                "content": "# Intuition\\nJAVA\\n\\n# Approach\\nEasy To Understand\\n\\n# Complexity\\n- Time complexity: O(N\\u2217(stringlength)!)\\n\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int[] ans = new int[s.length()];\\n\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            int count=0, row = startPos[0], col = startPos[1];\\n            for(int j=i; j<s.length(); j++)\\n            {\\n                if(s.charAt(j)==\\'R\\' & col+1<=n-1)\\n                {\\n                    count++;\\n                    col++;\\n                }\\n                else if (s.charAt(j)==\\'L\\' & col-1>=0)\\n                {\\n                    count++;\\n                    col += -1;\\n                }\\n                else if (s.charAt(j)==\\'D\\' & row+1<=n-1)\\n                {\\n                    count++;\\n                    row += 1;\\n                }\\n                else if (s.charAt(j)==\\'U\\' & row-1>=0)\\n                {\\n                    count++;\\n                    row += -1;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n\\n            }\\n            ans[i]=count; \\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int[] ans = new int[s.length()];\\n\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            int count=0, row = startPos[0], col = startPos[1];\\n            for(int j=i; j<s.length(); j++)\\n            {\\n                if(s.charAt(j)==\\'R\\' & col+1<=n-1)\\n                {\\n                    count++;\\n                    col++;\\n                }\\n                else if (s.charAt(j)==\\'L\\' & col-1>=0)\\n                {\\n                    count++;\\n                    col += -1;\\n                }\\n                else if (s.charAt(j)==\\'D\\' & row+1<=n-1)\\n                {\\n                    count++;\\n                    row += 1;\\n                }\\n                else if (s.charAt(j)==\\'U\\' & row-1>=0)\\n                {\\n                    count++;\\n                    row += -1;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n\\n            }\\n            ans[i]=count; \\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492365,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int[] ans = new int[s.length()];\\n        int index = 0;\\n\\n        int row = startPos[0];\\n        int col = startPos[1];\\n\\n        for(int i = 0; i < s.length(); i++) {\\n            int count = 0;\\n            for(int j = i; j < s.length(); j++) {\\n                if(s.charAt(j) == \\'L\\') {\\n                    col -= 1;\\n                } else if(s.charAt(j) == \\'R\\') {\\n                    col += 1;\\n                } else if(s.charAt(j) == \\'U\\') {\\n                    row -= 1;\\n                } else {\\n                    row += 1;\\n                }\\n\\n                if(row >= 0 && row < n && col >=0 && col < n) {\\n                    count++;\\n                } else {\\n                    break;\\n                }\\n            }\\n            \\n            row = startPos[0];\\n            col = startPos[1];\\n            ans[index++] = count;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int[] ans = new int[s.length()];\\n        int index = 0;\\n\\n        int row = startPos[0];\\n        int col = startPos[1];\\n\\n        for(int i = 0; i < s.length(); i++) {\\n            int count = 0;\\n            for(int j = i; j < s.length(); j++) {\\n                if(s.charAt(j) == \\'L\\') {\\n                    col -= 1;\\n                } else if(s.charAt(j) == \\'R\\') {\\n                    col += 1;\\n                } else if(s.charAt(j) == \\'U\\') {\\n                    row -= 1;\\n                } else {\\n                    row += 1;\\n                }\\n\\n                if(row >= 0 && row < n && col >=0 && col < n) {\\n                    count++;\\n                } else {\\n                    break;\\n                }\\n            }\\n            \\n            row = startPos[0];\\n            col = startPos[1];\\n            ans[index++] = count;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492179,
                "title": "simple-straight-forward-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> ans;\\n        for(int i=0;i<s.length();i++){\\n            int j=i;\\n            bool insideGrid = true;\\n            int r = startPos[0];\\n            int c = startPos[1];\\n            int count=0;\\n            while(insideGrid && j<s.length()){\\n                if(s[j]==\\'R\\'){\\n                    c++;\\n                }\\n                 else if(s[j]==\\'L\\'){\\n                    c--;\\n                }\\n                else if(s[j]==\\'U\\'){\\n                    r--;\\n                }\\n                 else{\\n                    r++;\\n                }\\n\\n                if(r>=n || c>=n || r<0 || c < 0){\\n                    ans.push_back(count);\\n                    insideGrid = false;\\n                    break;\\n                }\\n                if(insideGrid){\\n                    count++;\\n                }\\n                if(j==s.length()-1){\\n                    ans.push_back(count);\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> ans;\\n        for(int i=0;i<s.length();i++){\\n            int j=i;\\n            bool insideGrid = true;\\n            int r = startPos[0];\\n            int c = startPos[1];\\n            int count=0;\\n            while(insideGrid && j<s.length()){\\n                if(s[j]==\\'R\\'){\\n                    c++;\\n                }\\n                 else if(s[j]==\\'L\\'){\\n                    c--;\\n                }\\n                else if(s[j]==\\'U\\'){\\n                    r--;\\n                }\\n                 else{\\n                    r++;\\n                }\\n\\n                if(r>=n || c>=n || r<0 || c < 0){\\n                    ans.push_back(count);\\n                    insideGrid = false;\\n                    break;\\n                }\\n                if(insideGrid){\\n                    count++;\\n                }\\n                if(j==s.length()-1){\\n                    ans.push_back(count);\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471203,
                "title": "execution-of-all-suffix-instructions-staying-in-a-grid",
                "content": "# Code\\n```\\nclass Solution:\\n    def executeInstructions(self, n: int, p: List[int], s: str) -> List[int]:\\n        t = []\\n        for i in range(len(s)):\\n            b = s[i:]    \\n            count = 0\\n            c = p[0]\\n            d = p[1]\\n            for j in b:\\n                if j==\"R\":\\n                    d+=1\\n                    if d<= n-1 and d>=0:\\n                        count+=1\\n                    else:\\n                        break\\n                elif j==\"L\":\\n                    d-=1\\n                    if d<= n-1 and d>=0:\\n                        count+=1\\n                    else:\\n                        break\\n                elif j==\"U\":\\n                    c -=1\\n                    if c<= n-1 and c>=0:\\n                        count+=1\\n                    else:\\n                        break\\n                elif j==\"D\":\\n                    c  +=1 \\n                    if c<= n-1 and c>=0:\\n                        count+=1\\n                    else:\\n                        break\\n            t.append(count)\\n        return (t)     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def executeInstructions(self, n: int, p: List[int], s: str) -> List[int]:\\n        t = []\\n        for i in range(len(s)):\\n            b = s[i:]    \\n            count = 0\\n            c = p[0]\\n            d = p[1]\\n            for j in b:\\n                if j==\"R\":\\n                    d+=1\\n                    if d<= n-1 and d>=0:\\n                        count+=1\\n                    else:\\n                        break\\n                elif j==\"L\":\\n                    d-=1\\n                    if d<= n-1 and d>=0:\\n                        count+=1\\n                    else:\\n                        break\\n                elif j==\"U\":\\n                    c -=1\\n                    if c<= n-1 and c>=0:\\n                        count+=1\\n                    else:\\n                        break\\n                elif j==\"D\":\\n                    c  +=1 \\n                    if c<= n-1 and c>=0:\\n                        count+=1\\n                    else:\\n                        break\\n            t.append(count)\\n        return (t)     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469956,
                "title": "python-solve-for-single-axis-easiest-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry to solve for simpler cases dealing with single axis.\\nfor eg. \"LLR\" or \"DDU\"\\nnow merge both solution by keeping track of thier corresponding indices.\\n\\nNot concise but here my solution\\n# Code\\n```\\nclass Solution:\\n    def executeInstructions(self, n: int, sp: List[int], S: str) -> List[int]:\\n        def axis(s,x0): # solve for single axis, using prefix sum\\n            m = len(s)\\n            dx = 0\\n            hor = defaultdict(lambda :m+1)\\n            hor[0] = m\\n            res = [0]*m\\n            for i in range(m-1,-1,-1):\\n                dx += 1 if s[i]==\\'P\\' else -1\\n                hor[dx] = i\\n                j = min(hor[dx-n+x0],hor[dx+x0+1]) # smallest j where out of bound occurs\\n                res[i] = j-1 # save the index \\n            return res\\n        sx,sy= \"\",\"\" # deviding into two problems for both axis\\n        mx,my = [],[] # map for correct indices later used for merging\\n        m = len(S)\\n        for i in range(m):\\n            if S[i] in \\'LR\\':\\n                sx += \\'N\\' if S[i] == \\'L\\' else \"P\"\\n                mx.append(i)\\n            else:\\n                sy += \\'N\\' if S[i] == \\'U\\' else \"P\"\\n                my.append(i)\\n        mx.append(m); \\n        my.append(m)\\n        y,x = axis(sy,sp[0]),axis(sx,sp[1])\\n        res = [0]*m # merge both ans to get final ans\\n        mmx,mmy = m,m\\n        for i in range(m-1,-1,-1):\\n            if S[i] in \\'LR\\': mmx = mx[x.pop()] # choose lowest index causing out of bound\\n            else: mmy = my[y.pop()]\\n            res[i] = min(mmx,mmy) - i\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def executeInstructions(self, n: int, sp: List[int], S: str) -> List[int]:\\n        def axis(s,x0): # solve for single axis, using prefix sum\\n            m = len(s)\\n            dx = 0\\n            hor = defaultdict(lambda :m+1)\\n            hor[0] = m\\n            res = [0]*m\\n            for i in range(m-1,-1,-1):\\n                dx += 1 if s[i]==\\'P\\' else -1\\n                hor[dx] = i\\n                j = min(hor[dx-n+x0],hor[dx+x0+1]) # smallest j where out of bound occurs\\n                res[i] = j-1 # save the index \\n            return res\\n        sx,sy= \"\",\"\" # deviding into two problems for both axis\\n        mx,my = [],[] # map for correct indices later used for merging\\n        m = len(S)\\n        for i in range(m):\\n            if S[i] in \\'LR\\':\\n                sx += \\'N\\' if S[i] == \\'L\\' else \"P\"\\n                mx.append(i)\\n            else:\\n                sy += \\'N\\' if S[i] == \\'U\\' else \"P\"\\n                my.append(i)\\n        mx.append(m); \\n        my.append(m)\\n        y,x = axis(sy,sp[0]),axis(sx,sp[1])\\n        res = [0]*m # merge both ans to get final ans\\n        mmx,mmy = m,m\\n        for i in range(m-1,-1,-1):\\n            if S[i] in \\'LR\\': mmx = mx[x.pop()] # choose lowest index causing out of bound\\n            else: mmy = my[y.pop()]\\n            res[i] = min(mmx,mmy) - i\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451748,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int [] d = new int[4] ,sol =new int [s.length()]; // U D R L in this order\\n        d[0] = startPos[0];// how many U can in s more than D\\n        d[1] = n-d[0]-1;\\n        d[2] = n-startPos[1]-1;\\n        d[3] = startPos[1];\\n        for (int i=0;i<s.length();i++){\\n            int L=0,R=0,D=0,U=0,iter=0;\\n            while (i+iter<s.length()){\\n                char c= s.charAt(i+iter++);\\n                if (c==\\'U\\') {U++;D--;}\\n                else if (c==\\'D\\') {U--;D++;}\\n                else if (c==\\'R\\') {R++;L--;}\\n                else if (c==\\'L\\') {L++;R--;}\\n                if (U>d[0]||D>d[1]||R>d[2]||L>d[3]) {\\n                    sol[i]=--iter;\\n                    break;\\n                }\\n            }\\n            if (i+iter==s.length()) sol[i]=iter;\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int [] d = new int[4] ,sol =new int [s.length()]; // U D R L in this order\\n        d[0] = startPos[0];// how many U can in s more than D\\n        d[1] = n-d[0]-1;\\n        d[2] = n-startPos[1]-1;\\n        d[3] = startPos[1];\\n        for (int i=0;i<s.length();i++){\\n            int L=0,R=0,D=0,U=0,iter=0;\\n            while (i+iter<s.length()){\\n                char c= s.charAt(i+iter++);\\n                if (c==\\'U\\') {U++;D--;}\\n                else if (c==\\'D\\') {U--;D++;}\\n                else if (c==\\'R\\') {R++;L--;}\\n                else if (c==\\'L\\') {L++;R--;}\\n                if (U>d[0]||D>d[1]||R>d[2]||L>d[3]) {\\n                    sol[i]=--iter;\\n                    break;\\n                }\\n            }\\n            if (i+iter==s.length()) sol[i]=iter;\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444125,
                "title": "easy-to-understand-simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] st, String s) {\\n        int l=s.length();\\n        int[] a=new int[l];\\n        for(int i=0;i<l;i++)\\n        {\\n            int c=0;\\n            int x=st[0],y=st[1];\\n            for(int j=i;j<l;j++)\\n            {\\n              char ch=s.charAt(j);\\n              if(ch==\\'R\\')\\n              {\\n                  if(y+1<n)\\n                  {\\n                  c++;\\n                  y=y+1;\\n                  }\\n                  else\\n                  break;\\n              }\\n              else if(ch==\\'L\\')\\n              {\\n                  if(y-1>=0)\\n                  {\\n                  c++;\\n                  y--;\\n                  }\\n                  else\\n                  break;\\n              }\\n              else if(ch==\\'U\\')\\n              {\\n                  if(x-1>=0)\\n                  {\\n                  c++;\\n                  x--;\\n                  }\\n                  else\\n                  break;\\n              }\\n              else\\n              {\\n                  if(x+1<n)\\n                  {\\n                  c++;\\n                  x++;\\n                  }\\n                  else\\n                  break;\\n              }\\n            }\\n            a[i]=c;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] st, String s) {\\n        int l=s.length();\\n        int[] a=new int[l];\\n        for(int i=0;i<l;i++)\\n        {\\n            int c=0;\\n            int x=st[0],y=st[1];\\n            for(int j=i;j<l;j++)\\n            {\\n              char ch=s.charAt(j);\\n              if(ch==\\'R\\')\\n              {\\n                  if(y+1<n)\\n                  {\\n                  c++;\\n                  y=y+1;\\n                  }\\n                  else\\n                  break;\\n              }\\n              else if(ch==\\'L\\')\\n              {\\n                  if(y-1>=0)\\n                  {\\n                  c++;\\n                  y--;\\n                  }\\n                  else\\n                  break;\\n              }\\n              else if(ch==\\'U\\')\\n              {\\n                  if(x-1>=0)\\n                  {\\n                  c++;\\n                  x--;\\n                  }\\n                  else\\n                  break;\\n              }\\n              else\\n              {\\n                  if(x+1<n)\\n                  {\\n                  c++;\\n                  x++;\\n                  }\\n                  else\\n                  break;\\n              }\\n            }\\n            a[i]=c;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435795,
                "title": "c-solution-easy",
                "content": "# Runtime:\\n**47 ms**, beats **60%** of **C** submissions of Execution of All Suffix Instructions Staying in a Grid.\\n# Memory:\\n**8.5 MB**, beats **90%** of **C** submissions of Execution of All Suffix Instructions Staying in a Grid.\\n\\n---\\n# Code\\n```\\nint* executeInstructions(int n, int* startPos, int startPosSize, char * s, int* returnSize){\\n    int *answer=malloc(strlen(s)*sizeof(int));\\n    for(int i=0; s[i]!=\\'\\\\0\\'; i++){\\n        int count=0, flag=0, x=startPos[0], y=startPos[1];\\n        for(int j=i; s[j]!=\\'\\\\0\\'; j++){\\n            switch(s[j]){\\n                case \\'L\\':\\n                    y--;\\n                    if(y<0)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n                case \\'R\\':\\n                    y++;\\n                    if(y>n-1)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n                case \\'U\\':\\n                    x--;\\n                    if(x<0)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n                case \\'D\\':\\n                    x++;\\n                    if(x>n-1)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n            }\\n            if(flag==1)\\n                break;\\n        }\\n        answer[i]=count;\\n    }\\n    *returnSize=strlen(s);\\n    return answer;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nint* executeInstructions(int n, int* startPos, int startPosSize, char * s, int* returnSize){\\n    int *answer=malloc(strlen(s)*sizeof(int));\\n    for(int i=0; s[i]!=\\'\\\\0\\'; i++){\\n        int count=0, flag=0, x=startPos[0], y=startPos[1];\\n        for(int j=i; s[j]!=\\'\\\\0\\'; j++){\\n            switch(s[j]){\\n                case \\'L\\':\\n                    y--;\\n                    if(y<0)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n                case \\'R\\':\\n                    y++;\\n                    if(y>n-1)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n                case \\'U\\':\\n                    x--;\\n                    if(x<0)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n                case \\'D\\':\\n                    x++;\\n                    if(x>n-1)\\n                        flag++;\\n                    else\\n                        count++;\\n                    break;\\n            }\\n            if(flag==1)\\n                break;\\n        }\\n        answer[i]=count;\\n    }\\n    *returnSize=strlen(s);\\n    return answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433696,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& st, string s) {\\n        vector<int>ans;\\n        \\n        for(int i=0;i<s.length();i++){\\n            int r=st[0],c=st[1];\\n            string temp=s.substr(i);\\n            int cnt=0;\\n            for(auto j:temp){\\n                if(j==\\'R\\' && (c+1)<n){\\n                    cnt+=1,c+=1;\\n                }\\n                else if(j==\\'L\\' && (c-1)>=0){\\n                    cnt+=1,c-=1;\\n                }\\n                else if(j==\\'U\\' && (r-1)>=0){\\n                    cnt+=1,r-=1;\\n                }\\n                else if(j==\\'D\\' && (r+1)<n){\\n                    cnt+=1,r+=1;\\n                }\\n                else break;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& st, string s) {\\n        vector<int>ans;\\n        \\n        for(int i=0;i<s.length();i++){\\n            int r=st[0],c=st[1];\\n            string temp=s.substr(i);\\n            int cnt=0;\\n            for(auto j:temp){\\n                if(j==\\'R\\' && (c+1)<n){\\n                    cnt+=1,c+=1;\\n                }\\n                else if(j==\\'L\\' && (c-1)>=0){\\n                    cnt+=1,c-=1;\\n                }\\n                else if(j==\\'U\\' && (r-1)>=0){\\n                    cnt+=1,r-=1;\\n                }\\n                else if(j==\\'D\\' && (r+1)<n){\\n                    cnt+=1,r+=1;\\n                }\\n                else break;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415833,
                "title": "java-simple-only-using-loop-and-if-else",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int len = s.length();\\n        char[] arr = s.toCharArray();\\n        int[] ans = new int[len];\\n        for (int i = 0; i < len; i++) {\\n            int left = startPos[0];\\n            int right = startPos[1];\\n            int temp = 0;\\n            int j = i;\\n            while (j < len) {\\n                if (arr[j] == \\'R\\' && right + 1 < n) {\\n                    right++;\\n                    temp++;\\n                } else if (arr[j] == \\'L\\' && right - 1 >= 0) {\\n                    right--;\\n                    temp++;\\n                } else if (arr[j] == \\'U\\' && left - 1 >= 0) {\\n                    left--;\\n                    temp++;\\n                } else if (arr[j] == \\'D\\' && left + 1 < n) {\\n                    left++;\\n                    temp++;\\n                } else {\\n                    ans[i] = temp;\\n                    break;\\n                }\\n                j++;\\n                if (j == len) {\\n                    ans[i] = temp;\\n                }\\n            }\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int len = s.length();\\n        char[] arr = s.toCharArray();\\n        int[] ans = new int[len];\\n        for (int i = 0; i < len; i++) {\\n            int left = startPos[0];\\n            int right = startPos[1];\\n            int temp = 0;\\n            int j = i;\\n            while (j < len) {\\n                if (arr[j] == \\'R\\' && right + 1 < n) {\\n                    right++;\\n                    temp++;\\n                } else if (arr[j] == \\'L\\' && right - 1 >= 0) {\\n                    right--;\\n                    temp++;\\n                } else if (arr[j] == \\'U\\' && left - 1 >= 0) {\\n                    left--;\\n                    temp++;\\n                } else if (arr[j] == \\'D\\' && left + 1 < n) {\\n                    left++;\\n                    temp++;\\n                } else {\\n                    ans[i] = temp;\\n                    break;\\n                }\\n                j++;\\n                if (j == len) {\\n                    ans[i] = temp;\\n                }\\n            }\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413476,
                "title": "brute-force-c-easy-readable-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStarting from 0th instruction, try all instructions from 0 --> n and store how many were valid in the ith index of the result array. Do this n times.\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] ExecuteInstructions(int n, int[] startPos, string s) {\\n        int[] ans = new int[s.Length];\\n\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            int[] pos = new int[] {startPos[0], startPos[1]};\\n            int count = 0;\\n\\n            for(int j = i; j < s.Length; j++)\\n            {\\n                if(IsValidMove(pos,s[j] + \"\", n))\\n                {\\n                    Move(pos, s[j] + \"\");\\n                    count++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            ans[i] = count;\\n        }\\n        return ans;\\n    }\\n\\n    public bool IsValidMove(int[] pos, string move, int n)\\n    {\\n        if(move == \"U\")        \\n            return pos[0] != 0;\\n        \\n        if(move == \"D\")\\n            return pos[0] != n-1;\\n\\n        if(move == \"L\")\\n            return pos[1] != 0;\\n        \\n        if(move == \"R\")\\n            return pos[1] != n-1;\\n        \\n        return true;\\n    }\\n\\n    private void Move(int[] pos, string move)\\n    {\\n        if(move == \"U\")        \\n            pos[0]--;\\n        \\n        if(move == \"D\")\\n            pos[0]++;\\n\\n        if(move == \"L\")\\n            pos[1]--;\\n        \\n        if(move == \"R\")\\n            pos[1]++;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] ExecuteInstructions(int n, int[] startPos, string s) {\\n        int[] ans = new int[s.Length];\\n\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            int[] pos = new int[] {startPos[0], startPos[1]};\\n            int count = 0;\\n\\n            for(int j = i; j < s.Length; j++)\\n            {\\n                if(IsValidMove(pos,s[j] + \"\", n))\\n                {\\n                    Move(pos, s[j] + \"\");\\n                    count++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            ans[i] = count;\\n        }\\n        return ans;\\n    }\\n\\n    public bool IsValidMove(int[] pos, string move, int n)\\n    {\\n        if(move == \"U\")        \\n            return pos[0] != 0;\\n        \\n        if(move == \"D\")\\n            return pos[0] != n-1;\\n\\n        if(move == \"L\")\\n            return pos[1] != 0;\\n        \\n        if(move == \"R\")\\n            return pos[1] != n-1;\\n        \\n        return true;\\n    }\\n\\n    private void Move(int[] pos, string move)\\n    {\\n        if(move == \"U\")        \\n            pos[0]--;\\n        \\n        if(move == \"D\")\\n            pos[0]++;\\n\\n        if(move == \"L\")\\n            pos[1]--;\\n        \\n        if(move == \"R\")\\n            pos[1]++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385103,
                "title": "java-no-space-consuming-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n**O(n + s.length())**\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\n    private String s;\\n    private int n;\\n    \\n\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        this.s = s;\\n        this.n = n;\\n\\n        final int[] answer = new int[s.length()];\\n        for (int i = 0; i < s.length(); i++) {\\n            answer[i] = performCommand(startPos[0], startPos[1], i);\\n        }\\n        return answer;\\n    }\\n\\n    private int performCommand(int i, int j, int startCommandIndex) {\\n        int result = 0;\\n        while (startCommandIndex < s.length()) {\\n            switch(s.charAt(startCommandIndex)) {\\n                case \\'R\\':\\n                    j++;\\n                    break;\\n                case \\'L\\':\\n                    j--;\\n                    break;\\n                case \\'U\\':\\n                    i--;\\n                    break;\\n                case \\'D\\':\\n                    i++;  \\n                    break;         \\n            }\\n            if (i < 0 || i >= n || j < 0 || j >= n) {\\n                return result;\\n            }\\n            result++;\\n            startCommandIndex++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private String s;\\n    private int n;\\n    \\n\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        this.s = s;\\n        this.n = n;\\n\\n        final int[] answer = new int[s.length()];\\n        for (int i = 0; i < s.length(); i++) {\\n            answer[i] = performCommand(startPos[0], startPos[1], i);\\n        }\\n        return answer;\\n    }\\n\\n    private int performCommand(int i, int j, int startCommandIndex) {\\n        int result = 0;\\n        while (startCommandIndex < s.length()) {\\n            switch(s.charAt(startCommandIndex)) {\\n                case \\'R\\':\\n                    j++;\\n                    break;\\n                case \\'L\\':\\n                    j--;\\n                    break;\\n                case \\'U\\':\\n                    i--;\\n                    break;\\n                case \\'D\\':\\n                    i++;  \\n                    break;         \\n            }\\n            if (i < 0 || i >= n || j < 0 || j >= n) {\\n                return result;\\n            }\\n            result++;\\n            startCommandIndex++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384526,
                "title": "detailed-step-wise-solution",
                "content": "# Here\\'s the step wise explanation!!\\n\\nThe executeInstructions method is called with the parameters n, startPos, and s.\\n\\nThe method initializes an integer array called \"result\" with the length of the input string s.\\n\\nThe method starts a loop that continues until the length of the input string s becomes zero.\\n\\nInside the loop, the method calls the static method \"oneLoop\" with the parameters startPos[0], startPos[1], s, and n.\\n\\nThe oneLoop method executes a loop over the characters of the input string s.\\n\\nFor each character, it updates the player\\'s position on the grid according to the instructions represented by the character.\\n\\nIt then checks if the player has hit the boundary of the grid. If the player has hit the boundary, it breaks out of the loop.\\n\\nOtherwise, it increments a counter variable.\\n\\nAt the end of the loop, the oneLoop method returns the counter variable, which represents the number of steps taken by the player before hitting the boundary of the grid.\\n\\nThe executeInstructions method adds the returned value to the result array at the current index, increments the index, and removes the first character of the input string s.\\n\\nThe loop in executeInstructions continues until the length of the input string s becomes zero.\\n\\nOnce the loop is finished, the executeInstructions method returns the result array\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) \\n    {\\n        \\n        int[] result = new int[s.length()];\\n        int x=0;\\n        while(s.length()>0)\\n        {\\n            result[x]=oneLoop(startPos[0],startPos[1],s,n);\\n            x++;\\n            s=s.substring(1);\\n            // k++;\\n        }\\n        return result;\\n        \\n    }\\n    static int oneLoop(int ph,int pv,String s,int n)\\n    {\\n        int counter=0;\\n        for(int i=0;i<s.length();i++)\\n            {\\n                \\n                char ch=s.charAt(i);\\n                switch(ch)\\n                {\\n                    case \\'R\\':\\n                    ++pv;\\n                    break;\\n                    case \\'L\\':\\n                    --pv;\\n                    break;\\n                    case \\'U\\':\\n                    --ph;\\n                    break;\\n                    case \\'D\\':\\n                    ++ph;\\n                    break;\\n                }\\n                if(ph>=n || ph<0 ||pv>=n ||pv<0)\\n                {\\n                    break;\\n                }\\n                else counter++;\\n            }\\n            return counter;\\n    }\\n    \\n}\\n\\n\\n\\n// int k=1;\\n//         while(s.length()>0)\\n//         {\\n//             arr.add(oneLoop(start,end,s,n));\\n//             s=s.substring(k);\\n//         }\\n//         int[] result = new int[arr.size()];\\n//          for(int i=0;i<result.length;i++)\\n//          {\\n//              result[i] = arr.get(i);\\n//          }\\n//          return result;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) \\n    {\\n        \\n        int[] result = new int[s.length()];\\n        int x=0;\\n        while(s.length()>0)\\n        {\\n            result[x]=oneLoop(startPos[0],startPos[1],s,n);\\n            x++;\\n            s=s.substring(1);\\n            // k++;\\n        }\\n        return result;\\n        \\n    }\\n    static int oneLoop(int ph,int pv,String s,int n)\\n    {\\n        int counter=0;\\n        for(int i=0;i<s.length();i++)\\n            {\\n                \\n                char ch=s.charAt(i);\\n                switch(ch)\\n                {\\n                    case \\'R\\':\\n                    ++pv;\\n                    break;\\n                    case \\'L\\':\\n                    --pv;\\n                    break;\\n                    case \\'U\\':\\n                    --ph;\\n                    break;\\n                    case \\'D\\':\\n                    ++ph;\\n                    break;\\n                }\\n                if(ph>=n || ph<0 ||pv>=n ||pv<0)\\n                {\\n                    break;\\n                }\\n                else counter++;\\n            }\\n            return counter;\\n    }\\n    \\n}\\n\\n\\n\\n// int k=1;\\n//         while(s.length()>0)\\n//         {\\n//             arr.add(oneLoop(start,end,s,n));\\n//             s=s.substring(k);\\n//         }\\n//         int[] result = new int[arr.size()];\\n//          for(int i=0;i<result.length;i++)\\n//          {\\n//              result[i] = arr.get(i);\\n//          }\\n//          return result;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376961,
                "title": "c-solution-using-one-for-loop-and-a-helper-function-that-can-be-called-recursively",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWith the same starting postion for each loop that iterates through the remainder of the string input, this problem can be solved with two parts - 1. a simple for loop to iterate through the input **s** string and 2. a helper function that can be called recursively to check each move input and see how many valid moves can be made.\\n\\nFor the helper function which is named **checkMove** in this solution, the first validation is the string s index whether the end is reached or not.  If the string index is valid, then check what the move is - using **switch** statement - and validate whether it can be made or not.  If yes, increment the count by one and then check for the remainder of the s input, if any - by recursively calling the helper function.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Instantiate int[] **ans** with the same array length as s.Length\\n2. Create a for loop - for each index i, have a helper function that validates if a given move is valid or not. Assign the value of **ans[i] =** *helper function*.\\n3. The helper function takes three parameters - an int value for row position, another int value for col position, and the index of character in s.\\n4. The s[index] which is a char can be handled using switch- case statement.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] ExecuteInstructions(int n, int[] startPos, string s) {\\n\\n        var ans = new int[s.Length];\\n\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            ans[i] = checkMove(startPos[0], startPos[1], i);\\n        }\\n\\n        return ans;\\n\\n        // helper for validating moves\\n        int checkMove(int row,  int col, int index)\\n        {\\n            if (index >= s.Length) return 0;\\n\\n            switch(s[index])\\n            {\\n                case(\\'D\\'):\\n                    if (row + 1 >= n) return 0;\\n                    else return 1 + \\n                    checkMove(row + 1, col, index+1);  \\n                    break;\\n                case(\\'U\\'):\\n                    if (row - 1 < 0 ) return 0;\\n                    else return 1 + \\n                    checkMove(row - 1, col, index+1); \\n                    break; \\n                case(\\'L\\'):\\n                    if (col - 1 < 0) return 0;\\n                    else return 1 + \\n                    checkMove(row, col - 1, index+1);\\n                    break;  \\n                case(\\'R\\'):\\n                    if (col + 1 >= n) return 0;\\n                    else return 1 + \\n                    checkMove(row, col + 1, index+1);  \\n                    break;\\n                default:\\n                    return 0;\\n                    break;\\n            }\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] ExecuteInstructions(int n, int[] startPos, string s) {\\n\\n        var ans = new int[s.Length];\\n\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            ans[i] = checkMove(startPos[0], startPos[1], i);\\n        }\\n\\n        return ans;\\n\\n        // helper for validating moves\\n        int checkMove(int row,  int col, int index)\\n        {\\n            if (index >= s.Length) return 0;\\n\\n            switch(s[index])\\n            {\\n                case(\\'D\\'):\\n                    if (row + 1 >= n) return 0;\\n                    else return 1 + \\n                    checkMove(row + 1, col, index+1);  \\n                    break;\\n                case(\\'U\\'):\\n                    if (row - 1 < 0 ) return 0;\\n                    else return 1 + \\n                    checkMove(row - 1, col, index+1); \\n                    break; \\n                case(\\'L\\'):\\n                    if (col - 1 < 0) return 0;\\n                    else return 1 + \\n                    checkMove(row, col - 1, index+1);\\n                    break;  \\n                case(\\'R\\'):\\n                    if (col + 1 >= n) return 0;\\n                    else return 1 + \\n                    checkMove(row, col + 1, index+1);  \\n                    break;\\n                default:\\n                    return 0;\\n                    break;\\n            }\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374985,
                "title": "rust-elixir-o-m-with-hashmap",
                "content": "# Intuition\\nGiven the grid size `n` and `start_pos`, for each cardinal direction, we can calculate the distance needed to move out of the grid from `start_pos`.\\n\\nIgnoring the grid bounds, and let `pos[x]` be the position after executing x operations. We can determine when the robot begins with j-th operation, whether it will move out of grid at i-th operation, where j <= i, using the \"*x-coord and y-coord relative differences*\" between `pos[i + 1]` and `pos[j]`.\\n\\n# Approach\\nFor every `i` we need to find efficiently all the beginning `j` indices which have the robot moving out of the grid. Therefore two HashMaps are used for saving all `pos[j]` \"inversely\", i.e. with keys being the row / column and values being a `Vec` of `j`.\\n\\n# Complexity\\n- Time complexity: O(m)\\n\\n- Space complexity: O(m)\\n\\n# Code\\n```Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn execute_instructions(n: i32, start_pos: Vec<i32>, s: String) -> Vec<i32> {\\n        let mut row_map: HashMap<i32, Vec<i32>> = HashMap::new();\\n        let mut col_map: HashMap<i32, Vec<i32>> = HashMap::new();\\n        row_map.insert(0, vec![0]);\\n        col_map.insert(0, vec![0]);\\n        let mut x = 0;\\n        let mut y = 0;\\n        let mut ans = vec![i32::MIN; s.len()];\\n        for i in 0..=s.len() {\\n            let v = if i == s.len() {\\n                row_map.drain()\\n                    .chain(col_map.drain())\\n                    .flat_map(|(_, v)| v)\\n                    .collect()\\n            }\\n            else {\\n                match s.as_bytes()[i] {\\n                    b\\'U\\' => {\\n                        x -= 1;\\n                        row_map.remove(&(x + start_pos[0] + 1)).unwrap_or(Vec::new())\\n                    }\\n                    b\\'D\\' => {\\n                        x += 1;\\n                        row_map.remove(&(x + start_pos[0] - n)).unwrap_or(Vec::new())\\n                    }\\n                    b\\'L\\' => {\\n                        y -= 1;\\n                        col_map.remove(&(y + start_pos[1] + 1)).unwrap_or(Vec::new())\\n                    }\\n                    b\\'R\\' => {\\n                        y += 1;\\n                        col_map.remove(&(y + start_pos[1] - n)).unwrap_or(Vec::new())\\n                    }\\n                    _ => unreachable!(),\\n                }\\n            };\\n            if i < s.len() - 1 {\\n                row_map.entry(x).or_insert(Vec::new()).push(i as i32 + 1);\\n                col_map.entry(y).or_insert(Vec::new()).push(i as i32 + 1);\\n            }\\n            for j in v.into_iter() {\\n                if ans[j as usize] == i32::MIN {\\n                    ans[j as usize] = i as i32 - j;\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\\n```Elixir []\\ndefmodule Solution do\\n  @spec execute_instructions(n :: integer, start_pos :: [integer], s :: String.t) :: [integer]\\n  def execute_instructions(n, [x0, y0], s) do\\n    String.to_charlist(s)\\n    |> Stream.concat([?$])\\n    |> Enum.with_index()\\n    |> Enum.reduce({[0, 0], %{0 => [0]}, %{0 => [0]}, %{}}, fn {ch, i}, {[x, y], row_map, col_map, ans} ->\\n      {[x, y], list, row_map, col_map} = case ch do\\n        ?U ->\\n          {list, row_map} = Map.pop(row_map, x + x0, [])\\n          {[x - 1, y], list, row_map, col_map}\\n        ?D ->\\n          {list, row_map} = Map.pop(row_map, x + x0 - n + 1, [])\\n          {[x + 1, y], list, row_map, col_map}\\n        ?L ->\\n          {list, col_map} = Map.pop(col_map, y + y0, [])\\n          {[x, y - 1], list, row_map, col_map}\\n        ?R ->\\n          {list, col_map} = Map.pop(col_map, y + y0 - n + 1, [])\\n          {[x, y + 1], list, row_map, col_map}\\n        _ ->\\n          list = Enum.concat(flatten(row_map), flatten(col_map))\\n          {[i, 0], list, %{}, %{}}\\n      end\\n      row_map = Map.update(row_map, x, [i + 1], &([i + 1 | &1]))\\n      col_map = Map.update(col_map, y, [i + 1], &([i + 1 | &1]))\\n      ans = Enum.reduce(list, ans, fn j, ans ->\\n        Map.put_new(ans, j, i - j)\\n      end)\\n      {[x, y], row_map, col_map, ans}\\n    end)\\n    |> then(fn {[n, _], _, _, ans} ->\\n      Enum.map(0..n - 1, &(Map.get(ans, &1)))\\n    end)\\n  end\\n\\n  defp flatten(map) do\\n    Map.values(map)\\n    |> Enum.concat()\\n  end\\nend\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir",
                    "Hash Table"
                ],
                "code": "```Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn execute_instructions(n: i32, start_pos: Vec<i32>, s: String) -> Vec<i32> {\\n        let mut row_map: HashMap<i32, Vec<i32>> = HashMap::new();\\n        let mut col_map: HashMap<i32, Vec<i32>> = HashMap::new();\\n        row_map.insert(0, vec![0]);\\n        col_map.insert(0, vec![0]);\\n        let mut x = 0;\\n        let mut y = 0;\\n        let mut ans = vec![i32::MIN; s.len()];\\n        for i in 0..=s.len() {\\n            let v = if i == s.len() {\\n                row_map.drain()\\n                    .chain(col_map.drain())\\n                    .flat_map(|(_, v)| v)\\n                    .collect()\\n            }\\n            else {\\n                match s.as_bytes()[i] {\\n                    b\\'U\\' => {\\n                        x -= 1;\\n                        row_map.remove(&(x + start_pos[0] + 1)).unwrap_or(Vec::new())\\n                    }\\n                    b\\'D\\' => {\\n                        x += 1;\\n                        row_map.remove(&(x + start_pos[0] - n)).unwrap_or(Vec::new())\\n                    }\\n                    b\\'L\\' => {\\n                        y -= 1;\\n                        col_map.remove(&(y + start_pos[1] + 1)).unwrap_or(Vec::new())\\n                    }\\n                    b\\'R\\' => {\\n                        y += 1;\\n                        col_map.remove(&(y + start_pos[1] - n)).unwrap_or(Vec::new())\\n                    }\\n                    _ => unreachable!(),\\n                }\\n            };\\n            if i < s.len() - 1 {\\n                row_map.entry(x).or_insert(Vec::new()).push(i as i32 + 1);\\n                col_map.entry(y).or_insert(Vec::new()).push(i as i32 + 1);\\n            }\\n            for j in v.into_iter() {\\n                if ans[j as usize] == i32::MIN {\\n                    ans[j as usize] = i as i32 - j;\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\n```Elixir []\\ndefmodule Solution do\\n  @spec execute_instructions(n :: integer, start_pos :: [integer], s :: String.t) :: [integer]\\n  def execute_instructions(n, [x0, y0], s) do\\n    String.to_charlist(s)\\n    |> Stream.concat([?$])\\n    |> Enum.with_index()\\n    |> Enum.reduce({[0, 0], %{0 => [0]}, %{0 => [0]}, %{}}, fn {ch, i}, {[x, y], row_map, col_map, ans} ->\\n      {[x, y], list, row_map, col_map} = case ch do\\n        ?U ->\\n          {list, row_map} = Map.pop(row_map, x + x0, [])\\n          {[x - 1, y], list, row_map, col_map}\\n        ?D ->\\n          {list, row_map} = Map.pop(row_map, x + x0 - n + 1, [])\\n          {[x + 1, y], list, row_map, col_map}\\n        ?L ->\\n          {list, col_map} = Map.pop(col_map, y + y0, [])\\n          {[x, y - 1], list, row_map, col_map}\\n        ?R ->\\n          {list, col_map} = Map.pop(col_map, y + y0 - n + 1, [])\\n          {[x, y + 1], list, row_map, col_map}\\n        _ ->\\n          list = Enum.concat(flatten(row_map), flatten(col_map))\\n          {[i, 0], list, %{}, %{}}\\n      end\\n      row_map = Map.update(row_map, x, [i + 1], &([i + 1 | &1]))\\n      col_map = Map.update(col_map, y, [i + 1], &([i + 1 | &1]))\\n      ans = Enum.reduce(list, ans, fn j, ans ->\\n        Map.put_new(ans, j, i - j)\\n      end)\\n      {[x, y], row_map, col_map, ans}\\n    end)\\n    |> then(fn {[n, _], _, _, ans} ->\\n      Enum.map(0..n - 1, &(Map.get(ans, &1)))\\n    end)\\n  end\\n\\n  defp flatten(map) do\\n    Map.values(map)\\n    |> Enum.concat()\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3374297,
                "title": "c-easy-understanding-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    long long helper(int i,int row,int col,string s,int n){\\n        \\n        long long count=0;\\n        for(int j=i;j<s.size();j++){\\n            \\n            if(s[j]==\\'U\\'){\\n                row--;\\n                if(row<0){\\n                    break;\\n                }\\n            }\\n            else if(s[j]==\\'D\\'){\\n                row++;\\n                if(row>=n){\\n                    break;\\n                }\\n            }\\n            else if(s[j]==\\'R\\'){\\n                col++;\\n                if(col>=n){\\n                    break;\\n                }\\n            }\\n            else if(s[j]==\\'L\\'){\\n                col--;\\n                if(col<0){\\n                    break;\\n                }\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& startpos, string s) {\\n        \\n        int m=s.size();\\n        vector<int> ans(m);\\n        int startrow=startpos[0];\\n        int startcol=startpos[1];\\n        for(int i=0;i<s.size();i++){\\n            \\n            int index=i;\\n            long long int count=helper(index,startrow,startcol,s,n);\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    long long helper(int i,int row,int col,string s,int n){\\n        \\n        long long count=0;\\n        for(int j=i;j<s.size();j++){\\n            \\n            if(s[j]==\\'U\\'){\\n                row--;\\n                if(row<0){\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3366177,
                "title": "well-described-solution",
                "content": "# Intuition\\n **Given** \\n     n*n grid, Where start and end position will be given\\n\\nString s length m where s[i] is the instruction where it will    move \\'L\\' \\'R\\' \\'U\\' \\'D\\'\\n   \\nIt can start execution from any instruction  it will execute till end \\n     \\nIt will stop if \\n         1. next instruction is out of grid \\n         2. there is no more instruction left \\n\\n  Output \\n      An array of length m where  arr[i] will be the number of steps it will take from s[i];\\n\\n\\n\\n\\n# Approach\\n\\n    how it will move \\n        If startPos (i,j)\\n            left   i,j-1\\n            right  i,j+1\\n            top    i+1,j\\n            bottom i-1,j\\n\\n        When it will stop\\n            when it will cross row or coloumn\\n                row ->  i<0 || i>=n\\n                col ->  j<0 || j>=n\\n\\n  When it will take one step that step is legit then we will Count answer as +1\\n\\n# Complexity\\n- Time complexity:\\n O(n2)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        \\n        int sLen = s.length();\\n        int ans[]= new int [sLen];\\n        for(int i=0;i<sLen;i++){\\n           ans[i]=f(startPos,i,n,sLen,s);\\n        }\\n        return ans;\\n    }\\n     public int f(int[] startPos , int strIdx , int n , int sLen, String s ){\\n           \\n           int i=startPos[0],j=startPos[1];\\n           int count =0;\\n           for(int idx=strIdx;idx<sLen;idx++){\\n               if(i<0 || i==n || j<0 || j==n){\\n                    return count ;\\n                }\\n                \\n                char dir=s.charAt(idx); //   dir is direction \\n                if(dir==\\'L\\'){\\n                   --j;\\n                }else if(dir==\\'R\\'){\\n                   ++j;\\n                }else if(dir==\\'U\\'){\\n                    --i;\\n                }else {\\n                    ++i;\\n                }\\n                 if(i<0 || i==n || j<0 || j==n){\\n                    return count ;\\n                }\\n                ++count;\\n                \\n               \\n          }\\n          return count;\\n\\n     }\\n}\\n// Given \\n   // n*n grid where start and end position will be given\\n   // String s length m where s[i] is the instruction where it will move \\'L\\' \\'R\\' \\'U\\' \\'D\\'\\n   //  It can start execution from any instruction  it will execute till end \\n   //  It will stop if \\n         //next instruction is out of grid \\n         //there is no more instruction left \\n\\n// Output \\n   //   An array of length m where  arr[i] will be the number of steps it will take from s[i];\\n\\n\\n// solution \\n   //  how it will move \\n       //   startPos (i,j)\\n            //  left   i,j-1\\n            //  right  i,j+1\\n            //  top    i+1,j\\n            //  bottom i-1,j\\n\\n    //  when it will stop\\n           //  when it will cross row or coloumn\\n               //  row ->  i<0 || i>=n\\n               //  col ->  j<0 || j>=n\\n\\n       \\n\\n  \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        \\n        int sLen = s.length();\\n        int ans[]= new int [sLen];\\n        for(int i=0;i<sLen;i++){\\n           ans[i]=f(startPos,i,n,sLen,s);\\n        }\\n        return ans;\\n    }\\n     public int f(int[] startPos , int strIdx , int n , int sLen, String s ){\\n           \\n           int i=startPos[0],j=startPos[1];\\n           int count =0;\\n           for(int idx=strIdx;idx<sLen;idx++){\\n               if(i<0 || i==n || j<0 || j==n){\\n                    return count ;\\n                }\\n                \\n                char dir=s.charAt(idx); //   dir is direction \\n                if(dir==\\'L\\'){\\n                   --j;\\n                }else if(dir==\\'R\\'){\\n                   ++j;\\n                }else if(dir==\\'U\\'){\\n                    --i;\\n                }else {\\n                    ++i;\\n                }\\n                 if(i<0 || i==n || j<0 || j==n){\\n                    return count ;\\n                }\\n                ++count;\\n                \\n               \\n          }\\n          return count;\\n\\n     }\\n}\\n// Given \\n   // n*n grid where start and end position will be given\\n   // String s length m where s[i] is the instruction where it will move \\'L\\' \\'R\\' \\'U\\' \\'D\\'\\n   //  It can start execution from any instruction  it will execute till end \\n   //  It will stop if \\n         //next instruction is out of grid \\n         //there is no more instruction left \\n\\n// Output \\n   //   An array of length m where  arr[i] will be the number of steps it will take from s[i];\\n\\n\\n// solution \\n   //  how it will move \\n       //   startPos (i,j)\\n            //  left   i,j-1\\n            //  right  i,j+1\\n            //  top    i+1,j\\n            //  bottom i-1,j\\n\\n    //  when it will stop\\n           //  when it will cross row or coloumn\\n               //  row ->  i<0 || i>=n\\n               //  col ->  j<0 || j>=n\\n\\n       \\n\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365902,
                "title": "java-solution-o-n2-time-complexity",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int m = s.length();\\n        int[][] dp = new int[n][n];\\n        int[] arr = new int[m];\\n        for(int i = 0; i < m; i++){\\n            int x = startPos[0];\\n            int y = startPos[1];\\n            int count = 0;\\n            for(int j = i; j < m; j++){\\n                if(s.charAt(j)==\\'R\\' && y+1>=0 && y+1<=n-1){\\n                    count++;\\n                    y++;\\n                }\\n                else if(s.charAt(j)==\\'L\\' && y-1>=0 && y-1 <= n-1){\\n                    count++;\\n                    y--;\\n                }\\n                else if(s.charAt(j)==\\'U\\' && x-1>=0 && x-1 <= n-1){\\n                    count++;\\n                    x--;\\n                }\\n                else if(s.charAt(j)==\\'D\\' && x+1 >= 0 && x+1 <= n-1){\\n                    count++;\\n                    x++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            arr[i] = count;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int m = s.length();\\n        int[][] dp = new int[n][n];\\n        int[] arr = new int[m];\\n        for(int i = 0; i < m; i++){\\n            int x = startPos[0];\\n            int y = startPos[1];\\n            int count = 0;\\n            for(int j = i; j < m; j++){\\n                if(s.charAt(j)==\\'R\\' && y+1>=0 && y+1<=n-1){\\n                    count++;\\n                    y++;\\n                }\\n                else if(s.charAt(j)==\\'L\\' && y-1>=0 && y-1 <= n-1){\\n                    count++;\\n                    y--;\\n                }\\n                else if(s.charAt(j)==\\'U\\' && x-1>=0 && x-1 <= n-1){\\n                    count++;\\n                    x--;\\n                }\\n                else if(s.charAt(j)==\\'D\\' && x+1 >= 0 && x+1 <= n-1){\\n                    count++;\\n                    x++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            arr[i] = count;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352386,
                "title": "beginner-friendly-easy-to-understand-beats-97",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere I have tried to simulate the whole peoblem by initialising two pointers k and l to startPos[0] and startPos[1] respectively. we increment or decrement them as we get s[i] value accordingly.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int startI = startPos[0] ;\\n        int startJ = startPos[1] ;\\n        int m=s.length() ;\\n        vector<int> ans(m) ;\\n        for(int i=0;i<m;i++){\\n            int curr = 0 ;\\n            int k=startI ;\\n            int l=startJ ;\\n            for(int j=i;j<m;j++){\\n                if(s[j] == \\'L\\'){\\n                    l-- ;\\n                }\\n                else if(s[j] == \\'R\\'){\\n                    l++ ;\\n                }\\n                else if(s[j] == \\'U\\'){\\n                    k-- ;\\n                }\\n                else k++ ;\\n                curr++ ;\\n                if(l < 0){\\n                    curr-- ;\\n                    break ;\\n                }\\n                else if(l >= n){\\n                    curr-- ;\\n                    break ;\\n                }\\n                else if(k < 0){\\n                    curr-- ;\\n                    break ;\\n                }\\n                else if(k >= n){\\n                    curr-- ;\\n                    break ;\\n                }\\n            }\\n            ans[i] = curr ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        int startI = startPos[0] ;\\n        int startJ = startPos[1] ;\\n        int m=s.length() ;\\n        vector<int> ans(m) ;\\n        for(int i=0;i<m;i++){\\n            int curr = 0 ;\\n            int k=startI ;\\n            int l=startJ ;\\n            for(int j=i;j<m;j++){\\n                if(s[j] == \\'L\\'){\\n                    l-- ;\\n                }\\n                else if(s[j] == \\'R\\'){\\n                    l++ ;\\n                }\\n                else if(s[j] == \\'U\\'){\\n                    k-- ;\\n                }\\n                else k++ ;\\n                curr++ ;\\n                if(l < 0){\\n                    curr-- ;\\n                    break ;\\n                }\\n                else if(l >= n){\\n                    curr-- ;\\n                    break ;\\n                }\\n                else if(k < 0){\\n                    curr-- ;\\n                    break ;\\n                }\\n                else if(k >= n){\\n                    curr-- ;\\n                    break ;\\n                }\\n            }\\n            ans[i] = curr ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350082,
                "title": "easy-bruteforce-approach-in-c-also-applied-to-java-python-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n\\n\\nint ispossible(int* temp,int n)\\n{\\n    if(temp[1]>=n || temp[1]<0)\\n        return 0;\\n    else if(temp[0]<0 || temp[0]>=n)\\n        return 0;\\n    return 1;\\n    \\n}\\nint* executeInstructions(int n, int* startPos, int startPosSize, char * s, int* returnSize){\\n    int possible_move=0;\\n    int temp[2] = {startPos[0],startPos[1]};    \\n    *returnSize = strlen(s);\\n    int p =0;\\n    int *arr = malloc(strlen(s)*sizeof(int));\\n\\n    for(int i=0;i<strlen(s);i++)\\n    {\\n        possible_move = 0;\\n        for(int j=i;j<strlen(s);j++)\\n        {\\n            if(s[j]==\\'L\\')\\n            {\\n                temp[1]--;\\n                int k =ispossible(temp,n); \\n                if(k==1)\\n                    possible_move++;\\n                else\\n                    break;               \\n            }                \\n            else if(s[j]==\\'R\\')\\n            {\\n                temp[1]++;\\n                int k=ispossible(temp,n);\\n                if(k==1)\\n                    possible_move++;\\n                else\\n                    break;\\n            }\\n            else if(s[j]==\\'U\\')\\n            {\\n                temp[0]--;\\n                int k=ispossible(temp,n);\\n                if(k==1)\\n                    possible_move++;\\n                else\\n                    break;\\n            }\\n            else if(s[j]==\\'D\\')\\n            {\\n                temp[0]++;\\n                int k=ispossible(temp,n);\\n                if(k==1)\\n                    possible_move++;\\n                else\\n                    break;\\n            }\\n            \\n        }\\n        temp[0] =startPos[0];\\n        temp[1]= startPos[1];\\n        arr[p] = possible_move;\\n        p++;\\n    }\\n    return arr;\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n\\n\\nint ispossible(int* temp,int n)\\n{\\n    if(temp[1]>=n || temp[1]<0)\\n        return 0;\\n    else if(temp[0]<0 || temp[0]>=n)\\n        return 0;\\n    return 1;\\n    \\n}\\nint* executeInstructions(int n, int* startPos, int startPosSize, char * s, int* returnSize){\\n    int possible_move=0;\\n    int temp[2] = {startPos[0],startPos[1]};    \\n    *returnSize = strlen(s);\\n    int p =0;\\n    int *arr = malloc(strlen(s)*sizeof(int));\\n\\n    for(int i=0;i<strlen(s);i++)\\n    {\\n        possible_move = 0;\\n        for(int j=i;j<strlen(s);j++)\\n        {\\n            if(s[j]==\\'L\\')\\n            {\\n                temp[1]--;\\n                int k =ispossible(temp,n); \\n                if(k==1)\\n                    possible_move++;\\n                else\\n                    break;               \\n            }                \\n            else if(s[j]==\\'R\\')\\n            {\\n                temp[1]++;\\n                int k=ispossible(temp,n);\\n                if(k==1)\\n                    possible_move++;\\n                else\\n                    break;\\n            }\\n            else if(s[j]==\\'U\\')\\n            {\\n                temp[0]--;\\n                int k=ispossible(temp,n);\\n                if(k==1)\\n                    possible_move++;\\n                else\\n                    break;\\n            }\\n            else if(s[j]==\\'D\\')\\n            {\\n                temp[0]++;\\n                int k=ispossible(temp,n);\\n                if(k==1)\\n                    possible_move++;\\n                else\\n                    break;\\n            }\\n            \\n        }\\n        temp[0] =startPos[0];\\n        temp[1]= startPos[1];\\n        arr[p] = possible_move;\\n        p++;\\n    }\\n    return arr;\\n\\n\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3338543,
                "title": "c-easy-if-else-o-n-2-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& pos, string s) {\\n\\n        vector<int>ans;\\n        int m = s.size();\\n\\n        for(int i = 0;i<m;i++){\\n            int j = i;\\n            int cnt = 0;\\n            int x = pos[1];\\n            int y = pos[0];\\n\\n            while(j<m){\\n\\n                if(s[j]==\\'R\\'){\\n                    x++;\\n                    //cout<<\"right\"<<endl;\\n                }\\n                else if(s[j]==\\'L\\'){\\n                    x--;\\n                   // cout<<\"left\"<<endl;\\n                }\\n\\n                else if(s[j]==\\'U\\'){\\n                    y--;\\n                  //  cout<<\"Upper\"<<endl;\\n                }\\n\\n                else {\\n                    y++;\\n                    //cout<<\"Lower\"<<endl;\\n                }\\n                 j++;\\n\\n                if(y>=0 and y<n and x>=0 and x<n){\\n                    cnt++;\\n                   // cout<<cnt<<endl;\\n                }\\n\\n                else {\\n                    cout<<cnt<<endl;\\n                    x = pos[1];\\n                    y = pos[0];\\n                    break;\\n                }\\n            }\\n             ans.push_back(cnt);\\n\\n            //cout<<\"break\"<<endl;\\n           \\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> executeInstructions(int n, vector<int>& pos, string s) {\\n\\n        vector<int>ans;\\n        int m = s.size();\\n\\n        for(int i = 0;i<m;i++){\\n            int j = i;\\n            int cnt = 0;\\n            int x = pos[1];\\n            int y = pos[0];\\n\\n            while(j<m){\\n\\n                if(s[j]==\\'R\\'){\\n                    x++;\\n                    //cout<<\"right\"<<endl;\\n                }\\n                else if(s[j]==\\'L\\'){\\n                    x--;\\n                   // cout<<\"left\"<<endl;\\n                }\\n\\n                else if(s[j]==\\'U\\'){\\n                    y--;\\n                  //  cout<<\"Upper\"<<endl;\\n                }\\n\\n                else {\\n                    y++;\\n                    //cout<<\"Lower\"<<endl;\\n                }\\n                 j++;\\n\\n                if(y>=0 and y<n and x>=0 and x<n){\\n                    cnt++;\\n                   // cout<<cnt<<endl;\\n                }\\n\\n                else {\\n                    cout<<cnt<<endl;\\n                    x = pos[1];\\n                    y = pos[0];\\n                    break;\\n                }\\n            }\\n             ans.push_back(cnt);\\n\\n            //cout<<\"break\"<<endl;\\n           \\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3334970,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int m = s.length();\\n        int ans[] = new int[m];\\n        for(int i=0; i<m; i++)\\n        {\\n            int x=startPos[0], y=startPos[1];\\n            int j;\\n            for(j=i; j<m; j++)\\n            {\\n                switch(s.charAt(j))\\n                {\\n                    case \\'U\\': x--; break;\\n                    case \\'D\\': x++; break;\\n                    case \\'R\\': y++; break;\\n                    case \\'L\\': y--; break;\\n                }\\n                if(x<0 || x>=n || y<0 || y>=n)\\n                    break;\\n            }\\n            ans[i] = j-i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        int m = s.length();\\n        int ans[] = new int[m];\\n        for(int i=0; i<m; i++)\\n        {\\n            int x=startPos[0], y=startPos[1];\\n            int j;\\n            for(j=i; j<m; j++)\\n            {\\n                switch(s.charAt(j))\\n                {\\n                    case \\'U\\': x--; break;\\n                    case \\'D\\': x++; break;\\n                    case \\'R\\': y++; break;\\n                    case \\'L\\': y--; break;\\n                }\\n                if(x<0 || x>=n || y<0 || y>=n)\\n                    break;\\n            }\\n            ans[i] = j-i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324372,
                "title": "straightforward-ruby-solution",
                "content": "```\\n# @param {Integer} n\\n# @param {Integer[]} start_pos\\n# @param {String} s\\n# @return {Integer[]}\\ndef execute_instructions(n, start_pos, s)\\n  (0...s.size).map do |j|\\n    subs = s[j..]\\n    y, x = start_pos\\n    \\n    count = 0\\n    subs.size.times do |i|\\n      case subs[i]\\n        when \\'U\\' then y -= 1\\n        when \\'D\\' then y += 1\\n        when \\'R\\' then x += 1\\n        when \\'L\\' then x -= 1\\n      end\\n      break if x >= n || y >= n || x < 0 || y < 0\\n\\n      count += 1\\n    end\\n    count\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} n\\n# @param {Integer[]} start_pos\\n# @param {String} s\\n# @return {Integer[]}\\ndef execute_instructions(n, start_pos, s)\\n  (0...s.size).map do |j|\\n    subs = s[j..]\\n    y, x = start_pos\\n    \\n    count = 0\\n    subs.size.times do |i|\\n      case subs[i]\\n        when \\'U\\' then y -= 1\\n        when \\'D\\' then y += 1\\n        when \\'R\\' then x += 1\\n        when \\'L\\' then x -= 1\\n      end\\n      break if x >= n || y >= n || x < 0 || y < 0\\n\\n      count += 1\\n    end\\n    count\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3313111,
                "title": "python-solution",
                "content": "```\\ndef executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        \\n        ans = [0]*len(s)\\n        \\n        def checkBound(r, c):\\n            max_row = n - 1\\n            max_col = n - 1\\n            if r < 0 or r > max_row or c < 0 or c > max_col:\\n                return False\\n            return True\\n        for i in range(len(s)):\\n            \\n            row, col = startPos\\n            for direction in s[i:]:\\n                if direction == \\'R\\':col = col + 1\\n                if direction == \\'L\\':col = col - 1\\n                if direction == \\'D\\':row = row + 1\\n                if direction == \\'U\\':row = row - 1\\n                \\n                \\n                if checkBound(row, col):\\n                    \\n                    ans[i] += 1\\n                else:\\n                    break\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n        \\n        ans = [0]*len(s)\\n        \\n        def checkBound(r, c):\\n            max_row = n - 1\\n            max_col = n - 1\\n            if r < 0 or r > max_row or c < 0 or c > max_col:\\n                return False\\n            return True\\n        for i in range(len(s)):\\n            \\n            row, col = startPos\\n            for direction in s[i:]:\\n                if direction == \\'R\\':col = col + 1\\n                if direction == \\'L\\':col = col - 1\\n                if direction == \\'D\\':row = row + 1\\n                if direction == \\'U\\':row = row - 1\\n                \\n                \\n                if checkBound(row, col):\\n                    \\n                    ans[i] += 1\\n                else:\\n                    break\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3310189,
                "title": "c-recursion-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int r,int c,int n,int m)\\n    {\\n        if(r>=0 && r<n && c>=0 && c<m)\\n        return true;\\n        return false;\\n    }\\n    int solve(int r,int c,int n,int idx,string& s)\\n    {\\n        if(!isValid(r,c,n,n))\\n        return -1;\\n        if(idx==s.size())\\n        return 0;\\n        int res = 0;\\n        if(s[idx]==\\'L\\')\\n        {\\n            res = 1+solve(r,c-1,n,idx+1,s);\\n        }\\n        if(s[idx]==\\'R\\')\\n        {\\n            res = 1+solve(r,c+1,n,idx+1,s);\\n        }\\n        if(s[idx]==\\'U\\')\\n        {\\n            res = 1+solve(r-1,c,n,idx+1,s);\\n        }\\n        if(s[idx]==\\'D\\')\\n        {\\n            res = 1+solve(r+1,c,n,idx+1,s);\\n        }\\n        return res;\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) \\n    {\\n        vector<int> ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int r = startPos[0];\\n            int c = startPos[1];\\n            int tmp = solve(r,c,n,i,s);\\n            ans.push_back(tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int r,int c,int n,int m)\\n    {\\n        if(r>=0 && r<n && c>=0 && c<m)\\n        return true;\\n        return false;\\n    }\\n    int solve(int r,int c,int n,int idx,string& s)\\n    {\\n        if(!isValid(r,c,n,n))\\n        return -1;\\n        if(idx==s.size())\\n        return 0;\\n        int res = 0;\\n        if(s[idx]==\\'L\\')\\n        {\\n            res = 1+solve(r,c-1,n,idx+1,s);\\n        }\\n        if(s[idx]==\\'R\\')\\n        {\\n            res = 1+solve(r,c+1,n,idx+1,s);\\n        }\\n        if(s[idx]==\\'U\\')\\n        {\\n            res = 1+solve(r-1,c,n,idx+1,s);\\n        }\\n        if(s[idx]==\\'D\\')\\n        {\\n            res = 1+solve(r+1,c,n,idx+1,s);\\n        }\\n        return res;\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) \\n    {\\n        vector<int> ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int r = startPos[0];\\n            int c = startPos[1];\\n            int tmp = solve(r,c,n,i,s);\\n            ans.push_back(tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306828,
                "title": "python3-python-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)^2$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n\\n        res = []\\n        \\n        for i in range(len(s)):\\n            x = startPos[1]\\n            y = startPos[0]\\n            count = 0\\n            for ch in s[i:]:\\n                \\n                if ch == \\'U\\':\\n                    y-=1\\n                    if y >= 0:\\n                        count += 1\\n                    else:\\n                        break\\n                if ch == \\'D\\':\\n                    y += 1\\n                    if y <= n-1:\\n                        count += 1\\n                    else:\\n                        break\\n                if ch == \\'L\\':\\n                    x -= 1\\n                    if x >= 0:\\n                        count += 1\\n                    else:\\n                        break\\n                if ch == \\'R\\':\\n                    x += 1\\n                    if x <= n -1:\\n                        count += 1\\n                    else:\\n                        break\\n            res.append(count)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def executeInstructions(self, n: int, startPos: List[int], s: str) -> List[int]:\\n\\n        res = []\\n        \\n        for i in range(len(s)):\\n            x = startPos[1]\\n            y = startPos[0]\\n            count = 0\\n            for ch in s[i:]:\\n                \\n                if ch == \\'U\\':\\n                    y-=1\\n                    if y >= 0:\\n                        count += 1\\n                    else:\\n                        break\\n                if ch == \\'D\\':\\n                    y += 1\\n                    if y <= n-1:\\n                        count += 1\\n                    else:\\n                        break\\n                if ch == \\'L\\':\\n                    x -= 1\\n                    if x >= 0:\\n                        count += 1\\n                    else:\\n                        break\\n                if ch == \\'R\\':\\n                    x += 1\\n                    if x <= n -1:\\n                        count += 1\\n                    else:\\n                        break\\n            res.append(count)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302202,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] ExecuteInstructions(int n, int[] startPos, string s) {\\n        int[] result = new int[s.Length];\\n        int fullSLength = s.Length;\\n\\n        for(int i=0; i<fullSLength; i++)\\n        {\\n            int[] currentPos = startPos.ToArray();\\n            int currentResult = 0;\\n\\n            for(int j=0; j<s.Length; j++)\\n            {\\n                if(s[j] == \\'L\\')\\n                {\\n                    if(currentPos[1] == 0)\\n                    {\\n                        break;\\n                    }\\n\\n                    currentResult++;\\n                    currentPos[1]--;\\n                }\\n                else if(s[j] == \\'R\\')\\n                {\\n                    if(currentPos[1] == n - 1)\\n                    {\\n                        break;\\n                    }\\n\\n                    currentResult++;\\n                    currentPos[1]++;\\n                }\\n                else if(s[j] == \\'U\\')\\n                {\\n                    if(currentPos[0] == 0)\\n                    {\\n                        break;\\n                    }\\n\\n                    currentResult++;\\n                    currentPos[0]--;\\n                }\\n                else if(s[j] == \\'D\\')\\n                {\\n                    if(currentPos[0] == n - 1)\\n                    {\\n                        break;\\n                    }\\n\\n                    currentResult++;\\n                    currentPos[0]++;\\n                }\\n            }\\n\\n            result[i] = currentResult;\\n\\n            s = s.Substring(1, s.Length-1);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] ExecuteInstructions(int n, int[] startPos, string s) {\\n        int[] result = new int[s.Length];\\n        int fullSLength = s.Length;\\n\\n        for(int i=0; i<fullSLength; i++)\\n        {\\n            int[] currentPos = startPos.ToArray();\\n            int currentResult = 0;\\n\\n            for(int j=0; j<s.Length; j++)\\n            {\\n                if(s[j] == \\'L\\')\\n                {\\n                    if(currentPos[1] == 0)\\n                    {\\n                        break;\\n                    }\\n\\n                    currentResult++;\\n                    currentPos[1]--;\\n                }\\n                else if(s[j] == \\'R\\')\\n                {\\n                    if(currentPos[1] == n - 1)\\n                    {\\n                        break;\\n                    }\\n\\n                    currentResult++;\\n                    currentPos[1]++;\\n                }\\n                else if(s[j] == \\'U\\')\\n                {\\n                    if(currentPos[0] == 0)\\n                    {\\n                        break;\\n                    }\\n\\n                    currentResult++;\\n                    currentPos[0]--;\\n                }\\n                else if(s[j] == \\'D\\')\\n                {\\n                    if(currentPos[0] == n - 1)\\n                    {\\n                        break;\\n                    }\\n\\n                    currentResult++;\\n                    currentPos[0]++;\\n                }\\n            }\\n\\n            result[i] = currentResult;\\n\\n            s = s.Substring(1, s.Length-1);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296717,
                "title": "easy-to-understand-clean-code-c",
                "content": "```\\nvector<int>ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int cnt=0;\\n            int x=startPos[0];\\n            int y=startPos[1];\\n            for(int j=i;j<s.length();j++)\\n            {\\n                if(s[j]==\\'L\\')\\n                {\\n                    y--;\\n                }\\n                if(s[j]==\\'R\\')\\n                {\\n                    y++;\\n                }\\n                if(s[j]==\\'U\\')\\n                {\\n                    x--;\\n                }\\n                if(s[j]==\\'D\\')\\n                {\\n                    x++;\\n                }\\n                if(x<0 || y<0 || x>=n || y>=n )\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int>ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int cnt=0;\\n            int x=startPos[0];\\n            int y=startPos[1];\\n            for(int j=i;j<s.length();j++)\\n            {\\n                if(s[j]==\\'L\\')\\n                {\\n                    y--;\\n                }\\n                if(s[j]==\\'R\\')\\n                {\\n                    y++;\\n                }\\n                if(s[j]==\\'U\\')\\n                {\\n                    x--;\\n                }\\n                if(s[j]==\\'D\\')\\n                {\\n                    x++;\\n                }\\n                if(x<0 || y<0 || x>=n || y>=n )\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    cnt++;\\n                }\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3293478,
                "title": "simplest-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        if(n == 1){\\n            return new int[s.length()];\\n        }\\n        char[] ca = s.toCharArray();\\n        int[] res = new int[s.length()];\\n        int r,c;\\n        for(int i=0;i<s.length();i++){\\n            int count = 0;\\n            r = startPos[0];\\n            c = startPos[1];\\n            int j=i;\\n            for(;j<s.length();j++){\\n                if(ca[j] == \\'U\\'){\\n                    r--;\\n                    if(r<0){\\n                        break;\\n                    }\\n                    continue;\\n                }else if(ca[j] == \\'D\\'){\\n                    r++;\\n                    if(r>=n){\\n                        break;\\n                    }\\n                     continue;\\n                }else if(ca[j] == \\'R\\'){\\n                    c++;\\n                    if(c>=n){\\n                        break;\\n                    }\\n                     continue;\\n                }else if(ca[j] == \\'L\\'){\\n                    c--;\\n                    if(c<0){\\n                        break;\\n                    }\\n                     continue;\\n\\n                }\\n\\n            }\\n            res[i] = j-i;   \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] executeInstructions(int n, int[] startPos, String s) {\\n        if(n == 1){\\n            return new int[s.length()];\\n        }\\n        char[] ca = s.toCharArray();\\n        int[] res = new int[s.length()];\\n        int r,c;\\n        for(int i=0;i<s.length();i++){\\n            int count = 0;\\n            r = startPos[0];\\n            c = startPos[1];\\n            int j=i;\\n            for(;j<s.length();j++){\\n                if(ca[j] == \\'U\\'){\\n                    r--;\\n                    if(r<0){\\n                        break;\\n                    }\\n                    continue;\\n                }else if(ca[j] == \\'D\\'){\\n                    r++;\\n                    if(r>=n){\\n                        break;\\n                    }\\n                     continue;\\n                }else if(ca[j] == \\'R\\'){\\n                    c++;\\n                    if(c>=n){\\n                        break;\\n                    }\\n                     continue;\\n                }else if(ca[j] == \\'L\\'){\\n                    c--;\\n                    if(c<0){\\n                        break;\\n                    }\\n                     continue;\\n\\n                }\\n\\n            }\\n            res[i] = j-i;   \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565417,
                "content": [
                    {
                        "username": "enzesunca",
                        "content": "I didn\\'t came up with an O(m) solution. \\nJust want to add some pictures with **[hxu10\\'s explanation,](https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/discuss/1647617/python-O(m)-solution-with-detailed-explanation.)** maybe it\\'s useful for that ppl like me who can\\'t get the point at the very beginning.\\n\\nAs huxe10 said, \\n(x,y) means row x and col y , and we have a n*n grid, so if the robot at (x,y), it can only visit the coordinates which **inside** of the below grid:\\n1, it move up for x+1 steps----up bound\\n2, it move down for n-x steps----down bound\\n3, it move left for y+1 steps----left bound\\n4, it move right for n-y steps---- right bound\\n\\nLike huxe10\\'s solution, deal the commands from last to first and set the final position is (0,0), thus we can get the robot\\'s location where before every command has been excute.\\n\\nAnd we already know the bound grid of robot can visit, so we can come up following pictures.![image](https://assets.leetcode.com/users/images/a48a8698-0215-4744-a979-028017a6223a_1640552723.5564506.jpeg)\\n\\n\\nPlease read **[hxu10\\'s explanation,](https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/discuss/1647617/python-O(m)-solution-with-detailed-explanation.)**  for detail code and explanation. His solution is brilliant, maybe combine with the picture you could get a better comprehension of his code.\\n\\nWish you guys merry christmas and happy new year.\\n\\n\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Thanks for the explanation and belated HNY!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "There is no point of this question if it gets solved by brute force. The constraints should be tighter."
                    },
                    {
                        "username": "yutaaa",
                        "content": "Well, is there any way other than brute force in this? \\nbecause the commands depend on the previously executed commands so iterating through them must result in O(m) TC"
                    },
                    {
                        "username": "satyam47",
                        "content": "my 500th problem :)"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "\\uD83C\\uDF89"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "WHY IS IT GIVING RUNTIME ERROR ?\\n\\n\\nclass Solution {\\npublic:\\n    int solve(int row,int col, string s,int curr,int n){\\n        if(curr >= s.length() || row>n || row<0 || col >n || col <0)\\n        return 0;\\n        int nrow = row;\\n        int ncol = col;\\n\\n        if(s[curr]==\\'L\\') ncol--;\\n        if(s[curr]==\\'R\\') ncol++;\\n        else if(s[curr]==\\'U\\') nrow--;\\n        else if(s[curr]==\\'D\\') nrow++;\\n\\n        return 1 + solve(nrow,ncol,s,curr++,n);\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> res(n+1);\\n        for(int i=0;i<s.length();i++){\\n            res[i] = solve(startPos[0],startPos[1],s,i,n);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Similar approach only loops in java ..may be helpful [here](https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/solutions/3817703/brute-force/)"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Is there any approach better than the brute force ? help!"
                    }
                ]
            },
            {
                "id": 1842953,
                "content": [
                    {
                        "username": "enzesunca",
                        "content": "I didn\\'t came up with an O(m) solution. \\nJust want to add some pictures with **[hxu10\\'s explanation,](https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/discuss/1647617/python-O(m)-solution-with-detailed-explanation.)** maybe it\\'s useful for that ppl like me who can\\'t get the point at the very beginning.\\n\\nAs huxe10 said, \\n(x,y) means row x and col y , and we have a n*n grid, so if the robot at (x,y), it can only visit the coordinates which **inside** of the below grid:\\n1, it move up for x+1 steps----up bound\\n2, it move down for n-x steps----down bound\\n3, it move left for y+1 steps----left bound\\n4, it move right for n-y steps---- right bound\\n\\nLike huxe10\\'s solution, deal the commands from last to first and set the final position is (0,0), thus we can get the robot\\'s location where before every command has been excute.\\n\\nAnd we already know the bound grid of robot can visit, so we can come up following pictures.![image](https://assets.leetcode.com/users/images/a48a8698-0215-4744-a979-028017a6223a_1640552723.5564506.jpeg)\\n\\n\\nPlease read **[hxu10\\'s explanation,](https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/discuss/1647617/python-O(m)-solution-with-detailed-explanation.)**  for detail code and explanation. His solution is brilliant, maybe combine with the picture you could get a better comprehension of his code.\\n\\nWish you guys merry christmas and happy new year.\\n\\n\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Thanks for the explanation and belated HNY!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "There is no point of this question if it gets solved by brute force. The constraints should be tighter."
                    },
                    {
                        "username": "yutaaa",
                        "content": "Well, is there any way other than brute force in this? \\nbecause the commands depend on the previously executed commands so iterating through them must result in O(m) TC"
                    },
                    {
                        "username": "satyam47",
                        "content": "my 500th problem :)"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "\\uD83C\\uDF89"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "WHY IS IT GIVING RUNTIME ERROR ?\\n\\n\\nclass Solution {\\npublic:\\n    int solve(int row,int col, string s,int curr,int n){\\n        if(curr >= s.length() || row>n || row<0 || col >n || col <0)\\n        return 0;\\n        int nrow = row;\\n        int ncol = col;\\n\\n        if(s[curr]==\\'L\\') ncol--;\\n        if(s[curr]==\\'R\\') ncol++;\\n        else if(s[curr]==\\'U\\') nrow--;\\n        else if(s[curr]==\\'D\\') nrow++;\\n\\n        return 1 + solve(nrow,ncol,s,curr++,n);\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> res(n+1);\\n        for(int i=0;i<s.length();i++){\\n            res[i] = solve(startPos[0],startPos[1],s,i,n);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Similar approach only loops in java ..may be helpful [here](https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/solutions/3817703/brute-force/)"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Is there any approach better than the brute force ? help!"
                    }
                ]
            },
            {
                "id": 1931450,
                "content": [
                    {
                        "username": "enzesunca",
                        "content": "I didn\\'t came up with an O(m) solution. \\nJust want to add some pictures with **[hxu10\\'s explanation,](https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/discuss/1647617/python-O(m)-solution-with-detailed-explanation.)** maybe it\\'s useful for that ppl like me who can\\'t get the point at the very beginning.\\n\\nAs huxe10 said, \\n(x,y) means row x and col y , and we have a n*n grid, so if the robot at (x,y), it can only visit the coordinates which **inside** of the below grid:\\n1, it move up for x+1 steps----up bound\\n2, it move down for n-x steps----down bound\\n3, it move left for y+1 steps----left bound\\n4, it move right for n-y steps---- right bound\\n\\nLike huxe10\\'s solution, deal the commands from last to first and set the final position is (0,0), thus we can get the robot\\'s location where before every command has been excute.\\n\\nAnd we already know the bound grid of robot can visit, so we can come up following pictures.![image](https://assets.leetcode.com/users/images/a48a8698-0215-4744-a979-028017a6223a_1640552723.5564506.jpeg)\\n\\n\\nPlease read **[hxu10\\'s explanation,](https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/discuss/1647617/python-O(m)-solution-with-detailed-explanation.)**  for detail code and explanation. His solution is brilliant, maybe combine with the picture you could get a better comprehension of his code.\\n\\nWish you guys merry christmas and happy new year.\\n\\n\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Thanks for the explanation and belated HNY!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "There is no point of this question if it gets solved by brute force. The constraints should be tighter."
                    },
                    {
                        "username": "yutaaa",
                        "content": "Well, is there any way other than brute force in this? \\nbecause the commands depend on the previously executed commands so iterating through them must result in O(m) TC"
                    },
                    {
                        "username": "satyam47",
                        "content": "my 500th problem :)"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "\\uD83C\\uDF89"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "WHY IS IT GIVING RUNTIME ERROR ?\\n\\n\\nclass Solution {\\npublic:\\n    int solve(int row,int col, string s,int curr,int n){\\n        if(curr >= s.length() || row>n || row<0 || col >n || col <0)\\n        return 0;\\n        int nrow = row;\\n        int ncol = col;\\n\\n        if(s[curr]==\\'L\\') ncol--;\\n        if(s[curr]==\\'R\\') ncol++;\\n        else if(s[curr]==\\'U\\') nrow--;\\n        else if(s[curr]==\\'D\\') nrow++;\\n\\n        return 1 + solve(nrow,ncol,s,curr++,n);\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> res(n+1);\\n        for(int i=0;i<s.length();i++){\\n            res[i] = solve(startPos[0],startPos[1],s,i,n);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Similar approach only loops in java ..may be helpful [here](https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/solutions/3817703/brute-force/)"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Is there any approach better than the brute force ? help!"
                    }
                ]
            },
            {
                "id": 1986290,
                "content": [
                    {
                        "username": "enzesunca",
                        "content": "I didn\\'t came up with an O(m) solution. \\nJust want to add some pictures with **[hxu10\\'s explanation,](https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/discuss/1647617/python-O(m)-solution-with-detailed-explanation.)** maybe it\\'s useful for that ppl like me who can\\'t get the point at the very beginning.\\n\\nAs huxe10 said, \\n(x,y) means row x and col y , and we have a n*n grid, so if the robot at (x,y), it can only visit the coordinates which **inside** of the below grid:\\n1, it move up for x+1 steps----up bound\\n2, it move down for n-x steps----down bound\\n3, it move left for y+1 steps----left bound\\n4, it move right for n-y steps---- right bound\\n\\nLike huxe10\\'s solution, deal the commands from last to first and set the final position is (0,0), thus we can get the robot\\'s location where before every command has been excute.\\n\\nAnd we already know the bound grid of robot can visit, so we can come up following pictures.![image](https://assets.leetcode.com/users/images/a48a8698-0215-4744-a979-028017a6223a_1640552723.5564506.jpeg)\\n\\n\\nPlease read **[hxu10\\'s explanation,](https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/discuss/1647617/python-O(m)-solution-with-detailed-explanation.)**  for detail code and explanation. His solution is brilliant, maybe combine with the picture you could get a better comprehension of his code.\\n\\nWish you guys merry christmas and happy new year.\\n\\n\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Thanks for the explanation and belated HNY!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "There is no point of this question if it gets solved by brute force. The constraints should be tighter."
                    },
                    {
                        "username": "yutaaa",
                        "content": "Well, is there any way other than brute force in this? \\nbecause the commands depend on the previously executed commands so iterating through them must result in O(m) TC"
                    },
                    {
                        "username": "satyam47",
                        "content": "my 500th problem :)"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "\\uD83C\\uDF89"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "WHY IS IT GIVING RUNTIME ERROR ?\\n\\n\\nclass Solution {\\npublic:\\n    int solve(int row,int col, string s,int curr,int n){\\n        if(curr >= s.length() || row>n || row<0 || col >n || col <0)\\n        return 0;\\n        int nrow = row;\\n        int ncol = col;\\n\\n        if(s[curr]==\\'L\\') ncol--;\\n        if(s[curr]==\\'R\\') ncol++;\\n        else if(s[curr]==\\'U\\') nrow--;\\n        else if(s[curr]==\\'D\\') nrow++;\\n\\n        return 1 + solve(nrow,ncol,s,curr++,n);\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> res(n+1);\\n        for(int i=0;i<s.length();i++){\\n            res[i] = solve(startPos[0],startPos[1],s,i,n);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Similar approach only loops in java ..may be helpful [here](https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/solutions/3817703/brute-force/)"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Is there any approach better than the brute force ? help!"
                    }
                ]
            },
            {
                "id": 1974607,
                "content": [
                    {
                        "username": "enzesunca",
                        "content": "I didn\\'t came up with an O(m) solution. \\nJust want to add some pictures with **[hxu10\\'s explanation,](https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/discuss/1647617/python-O(m)-solution-with-detailed-explanation.)** maybe it\\'s useful for that ppl like me who can\\'t get the point at the very beginning.\\n\\nAs huxe10 said, \\n(x,y) means row x and col y , and we have a n*n grid, so if the robot at (x,y), it can only visit the coordinates which **inside** of the below grid:\\n1, it move up for x+1 steps----up bound\\n2, it move down for n-x steps----down bound\\n3, it move left for y+1 steps----left bound\\n4, it move right for n-y steps---- right bound\\n\\nLike huxe10\\'s solution, deal the commands from last to first and set the final position is (0,0), thus we can get the robot\\'s location where before every command has been excute.\\n\\nAnd we already know the bound grid of robot can visit, so we can come up following pictures.![image](https://assets.leetcode.com/users/images/a48a8698-0215-4744-a979-028017a6223a_1640552723.5564506.jpeg)\\n\\n\\nPlease read **[hxu10\\'s explanation,](https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/discuss/1647617/python-O(m)-solution-with-detailed-explanation.)**  for detail code and explanation. His solution is brilliant, maybe combine with the picture you could get a better comprehension of his code.\\n\\nWish you guys merry christmas and happy new year.\\n\\n\\n"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Thanks for the explanation and belated HNY!"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "There is no point of this question if it gets solved by brute force. The constraints should be tighter."
                    },
                    {
                        "username": "yutaaa",
                        "content": "Well, is there any way other than brute force in this? \\nbecause the commands depend on the previously executed commands so iterating through them must result in O(m) TC"
                    },
                    {
                        "username": "satyam47",
                        "content": "my 500th problem :)"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "\\uD83C\\uDF89"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "WHY IS IT GIVING RUNTIME ERROR ?\\n\\n\\nclass Solution {\\npublic:\\n    int solve(int row,int col, string s,int curr,int n){\\n        if(curr >= s.length() || row>n || row<0 || col >n || col <0)\\n        return 0;\\n        int nrow = row;\\n        int ncol = col;\\n\\n        if(s[curr]==\\'L\\') ncol--;\\n        if(s[curr]==\\'R\\') ncol++;\\n        else if(s[curr]==\\'U\\') nrow--;\\n        else if(s[curr]==\\'D\\') nrow++;\\n\\n        return 1 + solve(nrow,ncol,s,curr++,n);\\n    }\\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\\n        vector<int> res(n+1);\\n        for(int i=0;i<s.length();i++){\\n            res[i] = solve(startPos[0],startPos[1],s,i,n);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Similar approach only loops in java ..may be helpful [here](https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/solutions/3817703/brute-force/)"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Is there any approach better than the brute force ? help!"
                    }
                ]
            }
        ]
    }
]