[
    {
        "title": "Keep Multiplying Found Values by Two",
        "question_content": "You are given an array of integers nums. You are also given an integer original which is the first number that needs to be searched for in nums.\nYou then do the following steps:\n\n\tIf original is found in nums, multiply it by two (i.e., set original = 2 * original).\n\tOtherwise, stop the process.\n\tRepeat this process with the new number as long as you keep finding the number.\n\nReturn the final value of original.\n&nbsp;\nExample 1:\n\nInput: nums = [5,3,6,1,12], original = 3\nOutput: 24\nExplanation: \n- 3 is found in nums. 3 is multiplied by 2 to obtain 6.\n- 6 is found in nums. 6 is multiplied by 2 to obtain 12.\n- 12 is found in nums. 12 is multiplied by 2 to obtain 24.\n- 24 is not found in nums. Thus, 24 is returned.\n\nExample 2:\n\nInput: nums = [2,7,9], original = 4\nOutput: 4\nExplanation:\n- 4 is not found in nums. Thus, 4 is returned.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 1000\n\t1 <= nums[i], original <= 1000",
        "solutions": [
            {
                "id": 1730223,
                "title": "easy-c-hash-3-lines-o-n",
                "content": "**Logic:** Hash the given array and keep finding until ``o*2`` isn\\'t present.\\n\\n**Complexity:** Time: O(n)\\nSpace: O(1001) i.e O(constant)\\n\\n``Using Array:``\\n```\\nint findFinalValue(vector<int>& nums, int o) {\\n        int h[1001]={};\\n        for(auto i:nums) h[i]++;\\n\\t\\t\\n        while(o<=1000 && h[o])\\n            o*=2;\\n        \\n        return o;\\n    }\\n```\\n\\n**Bonus: Time Approximation**\\nThis snippet is from Guide to Competitive Programming\\n- Sorting has little advantage over set.\\n- Array has little advantage over map.\\n- This advantage grows as size of input grows.\\n\\nSet vs Sorting | Array vs Map\\n![image](https://assets.leetcode.com/users/images/62bec9a8-12ca-4aac-a190-067286375ef4_1643527785.29411.jpeg)\\n\\nPlease upvote, if find helpful! Suggestions are welcomed :)\\nFind me on https://coderaky.com\\n",
                "solutionTags": [],
                "code": "```\\nint findFinalValue(vector<int>& nums, int o) {\\n        int h[1001]={};\\n        for(auto i:nums) h[i]++;\\n\\t\\t\\n        while(o<=1000 && h[o])\\n            o*=2;\\n        \\n        return o;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1748678,
                "title": "easy-c-find-func-3-lines-o-n-logn-fast",
                "content": "**2154. Keep Multiplying Found Values by Two**\\n*KNOCKCAT*\\n```\\n1.Easy C++\\n2.find() function.\\n3.explanation in comments with code.\\n4.If it helps plz upvote\\u2B06\\uFE0F\\n5.Link to my Github Profile contains a repository of Leetcode with all my Solutions below\\u2B07\\uFE0F\\n```\\n[https://github.com/knockcat/Leetcode](http://)\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n****what find() function do?****\\n```\\nfind function searches an element in the vector ,if the element is present in the vector it return an iterator or we say a pointer to that location and if the element is not found it returns an iterator to the last element i.e nums.end()\\n\\nSo, using the condition if(find(nums.begin(),nums.end(),original) != nums.end()) // simply means that if element find than execute the block of statements inside if or otherwise the if condition got false, as find() has returned iterator to the last element which made the if returned false.\\n```\\n**CODE**\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n = 1;\\n        for(int i = 0; i<n;++i)\\n        {\\n            if(find(nums.begin(),nums.end(),original) != nums.end())    //find func detailled explanation above\\n            {\\n                original *= 2;\\n                n += 1; //n is incremented by one beacuse questions want us to perform the operation again if element is found again after its double.\\n            }\\n        }\\n        return original;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n1.Easy C++\\n2.find() function.\\n3.explanation in comments with code.\\n4.If it helps plz upvote\\u2B06\\uFE0F\\n5.Link to my Github Profile contains a repository of Leetcode with all my Solutions below\\u2B07\\uFE0F\\n```\n```\\nfind function searches an element in the vector ,if the element is present in the vector it return an iterator or we say a pointer to that location and if the element is not found it returns an iterator to the last element i.e nums.end()\\n\\nSo, using the condition if(find(nums.begin(),nums.end(),original) != nums.end()) // simply means that if element find than execute the block of statements inside if or otherwise the if condition got false, as find() has returned iterator to the last element which made the if returned false.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730224,
                "title": "boolean-array-vs-set",
                "content": "#### Boolean Array\\n**C++**\\n```cpp\\nint findFinalValue(vector<int>& nums, int original) {\\n    bool m[1001] = {};\\n    for (int n : nums)\\n        m[n] = true;\\n    while (original <= 1000 && m[original])\\n        original *= 2;\\n    return original;\\n}\\n```\\n#### Set\\n**C++**\\n```c++\\nint findFinalValue(vector<int>& nums, int original) {\\n    unordered_set s(begin(nums), end(nums));\\n    while (s.count(original))\\n        original *= 2;\\n    return original;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint findFinalValue(vector<int>& nums, int original) {\\n    bool m[1001] = {};\\n    for (int n : nums)\\n        m[n] = true;\\n    while (original <= 1000 && m[original])\\n        original *= 2;\\n    return original;\\n}\\n```\n```c++\\nint findFinalValue(vector<int>& nums, int original) {\\n    unordered_set s(begin(nums), end(nums));\\n    while (s.count(original))\\n        original *= 2;\\n    return original;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730154,
                "title": "sorting-vs-hashing-vs-brute-force-with-intuition",
                "content": "**Intuition**:\\nIndirectly we are told to check if a number is present in the array or not.\\n# It\\'s only possible in three ways:\\n1. `I can check every time from starting`.\\n2. `I sort the numbers from left to right` , I will always get `cnt*2 in forward direction and not backward`.\\n3. `I can use lookup for storing numbers and just see if present or not`.\\n\\n\\nThe last one is more efficient in terms of time.\\n\\n# Useful Trick:\\n`Wherever we see there is a need of lookup, we using hashing`.\\nLike in this Question we are told to check if cnt is present or not.\\n     \\n**Lookup**:\\n   \\n    int findFinalValue(vector<int>& nums, int cnt){\\n        unordered_set<int> s(begin(nums),end(nums));   \\n        for(;true;)\\n            if(s.count(cnt)) cnt*=2;\\n            else break;    \\n        return cnt;\\n    }\\n**Time** - `O(N)`\\n**Space**- `O(N)`\\n\\n**Sorting**:\\n \\n\\tint findFinalValue(vector<int>& nums, int cnt){\\n       sort(begin(nums),end(nums));\\n       for(auto i:nums) if(i==cnt) cnt*=2;\\n       return cnt;\\n    }    \\n**Time Com**  -  `O(NlogN)`\\n**Space Co..**  - `O(1) { Ignoring Space in sorting }`\\n\\n**Brute Force**:\\n\\n    int findFinalValue(vector<int>& nums, int cnt){\\n       for(auto i=0;i<nums.size();i++)\\n           if(nums[i]==cnt) cnt*=2,i=-1;\\n       return cnt;\\n    }\\n**Time Com**  -  `O(N*no. of times count found)`\\n**Space Co..**  - `O(1)`\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "**Intuition**:\\nIndirectly we are told to check if a number is present in the array or not.\\n# It\\'s only possible in three ways:\\n1. `I can check every time from starting`.\\n2. `I sort the numbers from left to right` , I will always get `cnt*2 in forward direction and not backward`.\\n3. `I can use lookup for storing numbers and just see if present or not`.\\n\\n\\nThe last one is more efficient in terms of time.\\n\\n# Useful Trick:\\n`Wherever we see there is a need of lookup, we using hashing`.\\nLike in this Question we are told to check if cnt is present or not.\\n     \\n**Lookup**:\\n   \\n    int findFinalValue(vector<int>& nums, int cnt){\\n        unordered_set<int> s(begin(nums),end(nums));   \\n        for(;true;)\\n            if(s.count(cnt)) cnt*=2;\\n            else break;    \\n        return cnt;\\n    }\\n**Time** - `O(N)`\\n**Space**- `O(N)`\\n\\n**Sorting**:\\n \\n\\tint findFinalValue(vector<int>& nums, int cnt){\\n       sort(begin(nums),end(nums));\\n       for(auto i:nums) if(i==cnt) cnt*=2;\\n       return cnt;\\n    }    \\n**Time Com**  -  `O(NlogN)`\\n**Space Co..**  - `O(1) { Ignoring Space in sorting }`\\n\\n**Brute Force**:\\n\\n    int findFinalValue(vector<int>& nums, int cnt){\\n       for(auto i=0;i<nums.size();i++)\\n           if(nums[i]==cnt) cnt*=2,i=-1;\\n       return cnt;\\n    }\\n**Time Com**  -  `O(N*no. of times count found)`\\n**Space Co..**  - `O(1)`\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1730125,
                "title": "java-hashset",
                "content": "```\\nclass Solution\\n{\\n    public int findFinalValue(int[] nums, int original)\\n    {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i : nums)\\n            if(i >= original)\\n                set.add(i);\\n        while(true)\\n            if(set.contains(original))\\n                original *= 2;\\n            else\\n                break;\\n        return original;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int findFinalValue(int[] nums, int original)\\n    {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i : nums)\\n            if(i >= original)\\n                set.add(i);\\n        while(true)\\n            if(set.contains(original))\\n                original *= 2;\\n            else\\n                break;\\n        return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730243,
                "title": "javascript-direct-way-3-lines-64ms",
                "content": "```\\nconst findFinalValue = (a, x) => {\\n   let se = new Set(a);\\n   while (se.has(x)) x *= 2;\\n   return x;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findFinalValue = (a, x) => {\\n   let se = new Set(a);\\n   while (se.has(x)) x *= 2;\\n   return x;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1731752,
                "title": "python3-simple-using-set",
                "content": "Doesn\\'t get much simpler than this\\n\\n```python\\ndef findFinalValue(self, nums: List[int], original: int) -> int:\\n        nums = set(nums)\\n        while original in nums:\\n            original *= 2\\n        return original\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```python\\ndef findFinalValue(self, nums: List[int], original: int) -> int:\\n        nums = set(nums)\\n        while original in nums:\\n            original *= 2\\n        return original\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2307600,
                "title": "java-runtime-1-ms-faster-than-92-80",
                "content": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==original){\\n                original=original*2;\\n                i=-1;\\n            }\\n        }\\n        return original;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==original){\\n                original=original*2;\\n                i=-1;\\n            }\\n        }\\n        return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740037,
                "title": "easy-to-understand",
                "content": "```\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        \\n        int start  = 0;\\n        int last = nums.length-1;\\n        \\n        while(start<=last) {\\n            int mid = start + (last-start)/2;\\n            if(nums[mid]==original) {\\n                original*=2;\\n                start = mid+1;\\n                last = nums.length-1;\\n            }else if(nums[mid]>original) last = mid-1;\\n            else start = mid+1;\\n        }\\n        \\n        return original;\\n    }\\n```\\n\\n\\nIf you really like the code kindly upvote it.\\nThank you.",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        \\n        int start  = 0;\\n        int last = nums.length-1;\\n        \\n        while(start<=last) {\\n            int mid = start + (last-start)/2;\\n            if(nums[mid]==original) {\\n                original*=2;\\n                start = mid+1;\\n                last = nums.length-1;\\n            }else if(nums[mid]>original) last = mid-1;\\n            else start = mid+1;\\n        }\\n        \\n        return original;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730144,
                "title": "sorting-and-recursive-java-solution",
                "content": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        return find(nums, original, 0);\\n    }\\n    \\n    private int find(int[] nums, int val, int i){\\n        if(i >= nums.length)\\n            return val;\\n        if(nums[i] == val)\\n            return find(nums, val*2, i+1);\\n        return find(nums, val, i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        return find(nums, original, 0);\\n    }\\n    \\n    private int find(int[] nums, int val, int i){\\n        if(i >= nums.length)\\n            return val;\\n        if(nums[i] == val)\\n            return find(nums, val*2, i+1);\\n        return find(nums, val, i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730138,
                "title": "c-code-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        bool b = true;\\n        while(b){\\n            int i = 0;\\n            for(i = 0; i<nums.size(); i++){\\n                if(nums[i] == original){ original *= 2; break;}\\n            }\\n            if(i == nums.size())\\n            b = false;\\n        }\\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        bool b = true;\\n        while(b){\\n            int i = 0;\\n            for(i = 0; i<nums.size(); i++){\\n                if(nums[i] == original){ original *= 2; break;}\\n            }\\n            if(i == nums.size())\\n            b = false;\\n        }\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161330,
                "title": "c-solution-2-approaches-recursion-and-brute-force-easy-understanding",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int ans = original ; \\n        sort (nums.begin(), nums.end()) ;\\n        for (int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (ans == nums[i])\\n            {\\n                ans *= 2;\\n            }\\n        }\\n        return ans ; \\n    }\\n};\\n```\\n\\n# Code - 2 \\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int ans)\\n    {\\n        sort (nums.begin(), nums.end()) ; \\n\\n        for (auto i : nums)\\n        {\\n            if (ans == i)\\n            {\\n                return solve (nums, ans*2);\\n            }\\n        }\\n        return ans ; \\n    }\\n\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int ans = original ; \\n        int result = solve (nums, ans) ; \\n\\n        return result ; \\n    }\\n};\\n```\\n\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/109c1b14-80e5-4d90-8f6a-5256dc3d2d12_1675877589.0914087.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int ans = original ; \\n        sort (nums.begin(), nums.end()) ;\\n        for (int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (ans == nums[i])\\n            {\\n                ans *= 2;\\n            }\\n        }\\n        return ans ; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int ans)\\n    {\\n        sort (nums.begin(), nums.end()) ; \\n\\n        for (auto i : nums)\\n        {\\n            if (ans == i)\\n            {\\n                return solve (nums, ans*2);\\n            }\\n        }\\n        return ans ; \\n    }\\n\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int ans = original ; \\n        int result = solve (nums, ans) ; \\n\\n        return result ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544391,
                "title": "c-solution-easy",
                "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        \\n        int i=0;\\n        int n=nums.size();\\n        while(i<n)\\n        {\\n            if(original==nums[i])\\n            { original*=2; i=0; }\\n            else i++;\\n        }\\n        return original;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        \\n        int i=0;\\n        int n=nums.size();\\n        while(i<n)\\n        {\\n            if(original==nums[i])\\n            { original*=2; i=0; }",
                "codeTag": "Java"
            },
            {
                "id": 1730323,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n         int num=original;\\n         HashSet<Integer> set=new HashSet();\\n         for(int a:nums)\\n             set.add(a);\\n         while(set.contains(num))\\n             num*=2;\\n         return num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n         int num=original;\\n         HashSet<Integer> set=new HashSet();\\n         for(int a:nums)\\n             set.add(a);\\n         while(set.contains(num))\\n             num*=2;\\n         return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259641,
                "title": "simple-java-recursive-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        if(found(nums, original))\\n        return findFinalValue(nums, original * 2);\\n        \\n        else\\n        return original;\\n    }\\n    boolean found(int nums[], int x)\\n    {\\n        for(int i: nums)\\n        if(i==x)\\n        return true;\\n\\n        return false;\\n    }\\n}\\n```\\n![sq-upvote.jpeg](https://assets.leetcode.com/users/images/47507243-9204-45fd-873b-e8e794a1cb87_1678009738.6261604.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        if(found(nums, original))\\n        return findFinalValue(nums, original * 2);\\n        \\n        else\\n        return original;\\n    }\\n    boolean found(int nums[], int x)\\n    {\\n        for(int i: nums)\\n        if(i==x)\\n        return true;\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257501,
                "title": "marvellous-logic-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        for i in range(len(nums)):\\n            if original in nums:\\n                original*=2\\n        else:\\n            return original\\n#please upvote me it would encourage alot\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        for i in range(len(nums)):\\n            if original in nums:\\n                original*=2\\n        else:\\n            return original\\n#please upvote me it would encourage alot\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257468,
                "title": "three-lines-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    o(n)-->complexity\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# consider upvoting.\\n# Code\\n```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums:\\n            original*=2\\n        return original\\n    #please do upvote if found helpful.\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums:\\n            original*=2\\n        return original\\n    #please do upvote if found helpful.\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157127,
                "title": "easy-to-understand-c-solution-with-0ms-run-time",
                "content": "![image.png](https://assets.leetcode.com/users/images/a3673a20-2957-45e9-b919-2e2858fa3a46_1675792852.7664597.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        while(find(nums.begin(), nums.end(), original) != nums.end())\\n            original *= 2;\\n        return original;\\n    }\\n};\\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        while(find(nums.begin(), nums.end(), original) != nums.end())\\n            original *= 2;\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954269,
                "title": "python-100-fast",
                "content": "# Intuition\\nBasic Looping\\n# Approach\\nSearching\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while(original  in nums):\\n            original=original*2\\n        return original\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while(original  in nums):\\n            original=original*2\\n        return original\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723582,
                "title": "java-solution-hashset-arraylist",
                "content": "### **Please Upvote** :D\\nYou can use an HashSet as well.\\n```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int i : nums) list.add(i);\\n        \\n        while (list.contains(original)) {\\n            original *= 2;\\n        }\\n        \\n        return original;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int i : nums) list.add(i);\\n        \\n        while (list.contains(original)) {\\n            original *= 2;\\n        }\\n        \\n        return original;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294192,
                "title": "java-two-solutions-set-and-sorting-array",
                "content": "**Sorting Array**\\n\\nWithout using Set - by sort and iterate the array\\n\\n```\\npublic int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] == original) original *= 2;\\n            else if(nums[i]>original) break;\\n        }\\n        return original;\\n    }\\n```\\n\\n--------------------------------------------------------------------\\n\\n**Set**\\n\\nUsing Set - Convert to set and while contains do the operation\\n\\n```\\npublic int findFinalValue(int[] nums, int original) {\\n        Set<Integer> s = new HashSet<Integer>();\\n        for(int i : nums){\\n            s.add(i);\\n\\t\\t}\\n        while(s.contains(original)){\\n            original *= 2;\\n        }\\n        return original;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] == original) original *= 2;\\n            else if(nums[i]>original) break;\\n        }\\n        return original;\\n    }\\n```\n```\\npublic int findFinalValue(int[] nums, int original) {\\n        Set<Integer> s = new HashSet<Integer>();\\n        for(int i : nums){\\n            s.add(i);\\n\\t\\t}\\n        while(s.contains(original)){\\n            original *= 2;\\n        }\\n        return original;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2221177,
                "title": "c-easy-and-simple-solution-linear-o-n-using-for-loop",
                "content": "```\\n  int findFinalValue(vector<int>& nums, int original) {\\n        int key=original;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==key){\\n                key=key*2;\\n                i=-1;\\n            }\\n        }\\n        \\n        return key;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  int findFinalValue(vector<int>& nums, int original) {\\n        int key=original;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==key){\\n                key=key*2;\\n                i=-1;\\n            }\\n        }\\n        \\n        return key;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1740155,
                "title": "python3-o-n-solution",
                "content": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        container = collections.Counter(nums)\\n        while container.get(original, 0):\\n            original *= 2\\n        return original\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        container = collections.Counter(nums)\\n        while container.get(original, 0):\\n            original *= 2\\n        return original\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732507,
                "title": "javascript-o-n-time-o-1-space",
                "content": "Just for fun. Obviously this is making the problem harder than it needs to be, but this strategy is used for harder problems as well.\\n\\nWe can determine if the current number in the array is an eventual value. The general formula for each is **num = original * 2<sup>n</sup>**, so we can reverse that with **n = log<sub>2</sub>(num / original)**, then we get which position in the sequence that number is.\\n\\nSo for nums ```[4, 8, 16, 32]```, with ```original = 4```, running  ```Math.log2(nums[i] / original)``` on each gives us ```[0, 1, 2, 3]```. So we run this formula on each element of ```nums```, and if we get a number in the sequence we\\'ll mark its position in ```nums``` by making it negative.\\n\\nThen we run through nums again and the first non-negative is the power of 2 for our answer, or ```len(nums)``` if they\\'re all negative.\\n\\nProblem example\\n```nums = [5,3,6,1,12], original = 3```, we run through ```nums``` once and get ```[-5,-3,-6,1,12]```, signifying that we found the first 3 values in the sequence (3, 6 and 12). Our first non-negative is at index 3, so our answer is **3 * 2<sup>3</sup> = 24**\\n\\nEdge cases:\\n- Maybe JavaScript doesn\\'t care, but we should avoid considering numbers that result in an index outside the range of ```len(nums)``` like ```[4, 8, 128], original = 4```\\n- Watch for duplicates, just make sure we don\\'t make a number negative twice and unmark it\\n\\n```\\nvar findFinalValue = function(nums, original) {\\n  const len = nums.length;\\n  for (let i = 0; i < len; i += 1) {\\n    const idx = Math.log2(Math.abs(nums[i]) / original);\\n    if (\\n      idx % 1 !== 0\\n      || idx >= len\\n      || nums[idx] < 0\\n    ) continue;\\n\\n    nums[idx] = -nums[idx];\\n  }\\n  \\n  for (let i = 0; i < len; i += 1) {\\n    if (nums[i] > 0) return 2 ** i * original;\\n  }\\n  \\n  return 2 ** len * original;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```[4, 8, 16, 32]```\n```original = 4```\n```Math.log2(nums[i] / original)```\n```[0, 1, 2, 3]```\n```nums```\n```nums```\n```len(nums)```\n```nums = [5,3,6,1,12], original = 3```\n```nums```\n```[-5,-3,-6,1,12]```\n```len(nums)```\n```[4, 8, 128], original = 4```\n```\\nvar findFinalValue = function(nums, original) {\\n  const len = nums.length;\\n  for (let i = 0; i < len; i += 1) {\\n    const idx = Math.log2(Math.abs(nums[i]) / original);\\n    if (\\n      idx % 1 !== 0\\n      || idx >= len\\n      || nums[idx] < 0\\n    ) continue;\\n\\n    nums[idx] = -nums[idx];\\n  }\\n  \\n  for (let i = 0; i < len; i += 1) {\\n    if (nums[i] > 0) return 2 ** i * original;\\n  }\\n  \\n  return 2 ** len * original;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683497,
                "title": "2154-keep-multiplying-found-values-by-two-100-easy-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        \\n        int n = nums.length-1;\\n\\t    \\n\\t    while(n>=0){\\n\\t        if(nums[n] == original){\\n\\t           original *=2;\\n\\t           n = nums.length;\\n\\t        }\\n\\t        n--;\\n\\t    }\\n        return original;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        \\n        int n = nums.length-1;\\n\\t    \\n\\t    while(n>=0){\\n\\t        if(nums[n] == original){\\n\\t           original *=2;\\n\\t           n = nums.length;\\n\\t        }\\n\\t        n--;\\n\\t    }\\n        return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444086,
                "title": "easy-java-solution-using-set-fastest-solution-for-beginners-explained",
                "content": "# Approach\\n- create a set and add all elements of nums into it.\\n- check if set contains original.\\n- if yes, original = original * 2.\\n- if not, return original.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        \\n        Arrays.sort(nums);\\n\\n        HashSet<Integer> set = new HashSet<>();\\n\\n        for(int i = 0; i < nums.length; i++){\\n\\n            set.add(nums[i]);\\n\\n        }\\n\\n        boolean valid = true;\\n\\n        while (valid == true){\\n\\n            if (set.contains(original) == true){\\n\\n                valid = true;\\n                original = 2 * original;\\n                continue;\\n\\n            }else{\\n\\n                valid = false;\\n\\n            }\\n\\n        }\\n\\n        return original;\\n\\n    }\\n}\\n```\\n\\n![images.jpeg](https://assets.leetcode.com/users/images/ba09a236-35db-497e-bfed-441d1f9f5a3b_1682168205.2494264.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        \\n        Arrays.sort(nums);\\n\\n        HashSet<Integer> set = new HashSet<>();\\n\\n        for(int i = 0; i < nums.length; i++){\\n\\n            set.add(nums[i]);\\n\\n        }\\n\\n        boolean valid = true;\\n\\n        while (valid == true){\\n\\n            if (set.contains(original) == true){\\n\\n                valid = true;\\n                original = 2 * original;\\n                continue;\\n\\n            }else{\\n\\n                valid = false;\\n\\n            }\\n\\n        }\\n\\n        return original;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355917,
                "title": "3-line-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==original){\\n                original = 2 * original;\\n            }\\n            continue;\\n        }\\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==original){\\n                original = 2 * original;\\n            }\\n            continue;\\n        }\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861182,
                "title": "beats-99-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        for i in range(0, len(nums) + 1):\\n            if original in nums:\\n                original = original * 2\\n            else:\\n                return original \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        for i in range(0, len(nums) + 1):\\n            if original in nums:\\n                original = original * 2\\n            else:\\n                return original \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796213,
                "title": "python-3-lines-99-49-faster-o-n-solution-using-sets",
                "content": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        s=set(nums)\\n        while original in s: original*=2\\n        return original\\n```\\n\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        s=set(nums)\\n        while original in s: original*=2\\n        return original\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796176,
                "title": "python-3-line-solution",
                "content": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums:\\n            original=original*2\\n        return original\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums:\\n            original=original*2\\n        return original\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697475,
                "title": "easy",
                "content": "```\\nint findFinalValue(vector<int>& nums, int original) {\\n        map<int, bool>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]=true;\\n        }\\n        while(mp[original]){\\n            original*=2;\\n            if(!mp[original]){\\n                return original;\\n            }\\n        }\\n        return original;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint findFinalValue(vector<int>& nums, int original) {\\n        map<int, bool>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]=true;\\n        }\\n        while(mp[original]){\\n            original*=2;\\n            if(!mp[original]){\\n                return original;\\n            }\\n        }\\n        return original;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2590909,
                "title": "javascript",
                "content": "```\\nvar findFinalValue = function(nums, original) {\\n    while(nums.includes(original)) original *= 2\\n    \\n    return original\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findFinalValue = function(nums, original) {\\n    while(nums.includes(original)) original *= 2\\n    \\n    return original\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2531625,
                "title": "python-super-easy",
                "content": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        ans = original\\n        while original in nums:\\n            ans*=2\\n            original*=2\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        ans = original\\n        while original in nums:\\n            ans*=2\\n            original*=2\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2531609,
                "title": "python-solution-simple-faster-than-80-less-memory-than-99",
                "content": "\\tclass Solution:\\n\\n\\t def findFinalValue(self, nums: List[int], original: int) -> int:\\n\\t\\n        while original in nums:\\n\\t\\t\\n            original *= 2\\n\\t\\t\\t\\n        return original\\n\\t\\t\\n\\t\\t\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\n\\t def findFinalValue(self, nums: List[int], original: int) -> int:\\n\\t\\n        while original in nums:\\n\\t\\t\\n            original *= 2\\n\\t\\t\\t\\n        return original\\n\\t\\t\\n\\t\\t\\n",
                "codeTag": "Java"
            },
            {
                "id": 2481657,
                "title": "go-for-loop-solution",
                "content": "```\\nfunc findFinalValue(nums []int, original int) int {\\n    var numSet [1001]int\\n    \\n    for _, num := range nums {\\n        numSet[num]++\\n    }\\n    \\n    for {\\n        if original > 1001 || numSet[original] == 0 {\\n            break\\n        }\\n        \\n        numSet[original] = original*2\\n        original = original*2\\n    }\\n    \\n    return original\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findFinalValue(nums []int, original int) int {\\n    var numSet [1001]int\\n    \\n    for _, num := range nums {\\n        numSet[num]++\\n    }\\n    \\n    for {\\n        if original > 1001 || numSet[original] == 0 {\\n            break\\n        }\\n        \\n        numSet[original] = original*2\\n        original = original*2\\n    }\\n    \\n    return original\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2479533,
                "title": "python-solution-easy",
                "content": "# For Loop\\n```\\nclass Solution:\\n    def findFinalValue(self, n: List[int], o: int) -> int:\\n        n = sorted(n)\\n        for i in range(len(n)) :\\n            if o == n[i]:\\n                o *= 2\\n        return o\\n```\\n# While Loop\\n```\\nclass Solution:\\n    def findFinalValue(self, n: List[int], o: int) -> int:\\n        while o in n:\\n            o *= 2\\n        return o\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findFinalValue(self, n: List[int], o: int) -> int:\\n        n = sorted(n)\\n        for i in range(len(n)) :\\n            if o == n[i]:\\n                o *= 2\\n        return o\\n```\n```\\nclass Solution:\\n    def findFinalValue(self, n: List[int], o: int) -> int:\\n        while o in n:\\n            o *= 2\\n        return o\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479525,
                "title": "python-while-loop",
                "content": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n            while original in nums:\\n                original=original*2\\n            return original\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n            while original in nums:\\n                original=original*2\\n            return original\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452385,
                "title": "2-lines-of-code-c-easy-to-understand",
                "content": "Search for the original in the given vector every time you are multiplying with 2.\\n```\\nint findFinalValue(vector<int>& nums, int original) {\\n        while(find(nums.begin(),nums.end(),original)!=nums.end()) original*=2;\\n        return original;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findFinalValue(vector<int>& nums, int original) {\\n        while(find(nums.begin(),nums.end(),original)!=nums.end()) original*=2;\\n        return original;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2376589,
                "title": "c-2-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        while(find(nums.begin(), nums.end(), original)!=nums.end()) original*=2;\\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        while(find(nums.begin(), nums.end(), original)!=nums.end()) original*=2;\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186423,
                "title": "c-easy-explained-multiple-approaches",
                "content": "**Approaches:**\\n\\n**1) Sorting:** Sort the array, if a double of the original exists then it will be found along the way as we traverse the array.\\ne.g -> [-2,4,0,16,8,2,10]\\nafter sorting:[-2,0,2,4,8,10,16]\\noriginal -> 2->4->8->16->32\\noriginal keeps multiplying by 2 as we keep finding the changed original while traversing the array.\\n\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(),nums.end());\\n        for(auto num:nums)\\n            if(num==original)\\n                original*=2;\\n        return original;\\n    }\\n};\\n```\\n\\n**2) Hashing:** Store the values of the array in a hash table. With a while loop check if original exists in the hash table while multiplying original by 2 as it is found on each lookup.\\n\\n ```\\n class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        unordered_set<int> hash;\\n        for(auto num:nums)\\n            if(hash.find(num)==hash.end())\\n                hash.insert(num);\\n        while(hash.find(original)!=hash.end())\\n            original*=2;\\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(),nums.end());\\n        for(auto num:nums)\\n            if(num==original)\\n                original*=2;\\n        return original;\\n    }\\n};\\n```\n```\\n class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        unordered_set<int> hash;\\n        for(auto num:nums)\\n            if(hash.find(num)==hash.end())\\n                hash.insert(num);\\n        while(hash.find(original)!=hash.end())\\n            original*=2;\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181583,
                "title": "javascript-solution",
                "content": "\\nsimple while loop\\n\\n```\\nvar findFinalValue = function(nums, original) {\\n    while (nums.includes(original)) {\\n        original = original * 2\\n    }\\n    \\n    return original\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findFinalValue = function(nums, original) {\\n    while (nums.includes(original)) {\\n        original = original * 2\\n    }\\n    \\n    return original\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2151522,
                "title": "c-resursion",
                "content": "```\\npublic class Solution {\\n    public int FindFinalValue(int[] nums, int original) {\\n        for(int i = 0; i< nums.Length;i++){\\n            if(nums[i] == original){\\n                original = FindFinalValue(nums,original*2);\\n            }\\n        }\\n        return original;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int FindFinalValue(int[] nums, int original) {\\n        for(int i = 0; i< nums.Length;i++){\\n            if(nums[i] == original){\\n                original = FindFinalValue(nums,original*2);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2122068,
                "title": "easy-c-3-different-solution",
                "content": "**Solution 1: using set and set.find()**\\n```\\nint findFinalValue(vector<int>& nums, int original) {\\n        unordered_set<int>s (nums.begin(), nums.end());\\n        while (s.find(original) != s.end())\\n        {\\n            original *= 2;\\n        }\\n        return original;\\n    }\\n```\\n**Solution 2: using vector.find()**\\n```\\n int findFinalValue(vector<int>& nums, int original) {\\n        while (find(nums.begin(), nums.end(), original) != nums.end())\\n        {\\n            original *= 2;\\n        }\\n        return original;\\n    } \\n```\\n**Solution 3: check every element using nested loop**\\n```\\n int findFinalValue(vector<int>& nums, int original) {\\n        bool f = true;\\n        while (f)\\n        {\\n            f = false;\\n           for (int i = 0; i < nums.size(); i++)\\n           {\\n               if(nums[i] == original) {\\n                   original *= 2;\\n                   f = true;\\n                   break;\\n               }\\n           }\\n           \\n        }\\n        return original;\\n    }\\n```\\n\\nUpvote if any of these solution helped you...",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint findFinalValue(vector<int>& nums, int original) {\\n        unordered_set<int>s (nums.begin(), nums.end());\\n        while (s.find(original) != s.end())\\n        {\\n            original *= 2;\\n        }\\n        return original;\\n    }\\n```\n```\\n int findFinalValue(vector<int>& nums, int original) {\\n        while (find(nums.begin(), nums.end(), original) != nums.end())\\n        {\\n            original *= 2;\\n        }\\n        return original;\\n    } \\n```\n```\\n int findFinalValue(vector<int>& nums, int original) {\\n        bool f = true;\\n        while (f)\\n        {\\n            f = false;\\n           for (int i = 0; i < nums.size(); i++)\\n           {\\n               if(nums[i] == original) {\\n                   original *= 2;\\n                   f = true;\\n                   break;\\n               }\\n           }\\n           \\n        }\\n        return original;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2075189,
                "title": "simple-java-code-faster-than-100",
                "content": "***If you have any questions regard to my solution, then you can ask any time. I am always available to response.***\\n\\n```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        return org(nums, original);\\n    }\\n    \\n    public int org(int[] nums, int original){\\n        int count=0;\\n        for(int i: nums){\\n            if(i == original){\\n                original *= 2;\\n                count++;\\n                break;\\n            }\\n        }\\n        \\n        if(count == 0)\\n            return original;\\n        \\n        return org(nums, original);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        return org(nums, original);\\n    }\\n    \\n    public int org(int[] nums, int original){\\n        int count=0;\\n        for(int i: nums){\\n            if(i == original){\\n                original *= 2;\\n                count++;\\n                break;\\n            }\\n        }\\n        \\n        if(count == 0)\\n            return original;\\n        \\n        return org(nums, original);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047115,
                "title": "easy-java-o-n",
                "content": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n            if(nums[i]==original)\\n                original*=2;\\n        \\n        return original;\\n       \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n            if(nums[i]==original)\\n                original*=2;\\n        \\n        return original;\\n       \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1775055,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        unordered_set<int>dict(nums.begin(),nums.end());\\n        while(dict.find(original)!=dict.end()) {\\n            original*=2;\\n        }\\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        unordered_set<int>dict(nums.begin(),nums.end());\\n        while(dict.find(original)!=dict.end()) {\\n            original*=2;\\n        }\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756388,
                "title": "java-easy-efficient-recursive-solution",
                "content": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        int num = 0;\\n        for(int i: nums){\\n            if(i == original){\\n                num = findFinalValue(nums, original*2);\\n            }\\n        }\\n        if(num == 0)return original;\\n        return num;\\n    }\\n}\\n```\\nPlease **UPVOTE** if you find this solution helpful.\\nHappy Coding : )",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        int num = 0;\\n        for(int i: nums){\\n            if(i == original){\\n                num = findFinalValue(nums, original*2);\\n            }\\n        }\\n        if(num == 0)return original;\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730657,
                "title": "easy-c-vector-solution",
                "content": "**C++ Vector Find() Approach**\\n1. This problem can be solved by using STL find()\\n2. We need to traverse the vector elements and find if the given original element is present in the vector or not.\\n3. If present than we need to double the original value and find that value in the given vector again and so on.\\n4. If the original value is not present in the vector than we need to return the present original value.\\n\\n```\\nint findFinalValue(vector<int>& nums, int original) {\\n        int n = nums.size();      \\n        for(int i=0;i<n;i++){\\n            auto it = find(nums.begin(), nums.end(), original);\\n            if(it!=nums.end()){\\n                original=original*2;\\n            }\\n            else\\n                return original;\\n        }\\n        return original;\\n    }\\n```\\n\\n**Time Complexity - O(N)**\\n**Space Complexity - O(N)**\\n\\n**Please upvote if you liked the solution!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint findFinalValue(vector<int>& nums, int original) {\\n        int n = nums.size();      \\n        for(int i=0;i<n;i++){\\n            auto it = find(nums.begin(), nums.end(), original);\\n            if(it!=nums.end()){\\n                original=original*2;\\n            }\\n            else\\n                return original;\\n        }\\n        return original;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730372,
                "title": "recursive-iterative-approach-3-lines-4ms",
                "content": "**Recursive approach:** \\n```\\n    int findFinalValue(vector<int>& nums, int original) {\\n        if(find(nums.begin(), nums.end(), original)!=nums.end()) \\n\\t\\t\\treturn findFinalValue(nums,original*2);\\n        return original;\\n    }\\n```\\n\\n\\n**Brute Force approach:** \\n```\\n    int findFinalValue(vector<int>& nums, int original) {\\n        while(find(nums.begin(),nums.end(),original)!=nums.end())\\n             original=original*2;\\n        return original;\\n    }\\n```\\n**Dry run:**\\n*nums = [5,3,6,1,12], original = 3*\\n1. 3 found in nums, so original = original*2 = 6\\n2. 6 found in nums, original = 6*2 = 12\\n3. 12 found in nums, original = 12*2 = 24\\n4. 24 not found, so return, original, 24.\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n    int findFinalValue(vector<int>& nums, int original) {\\n        if(find(nums.begin(), nums.end(), original)!=nums.end()) \\n\\t\\t\\treturn findFinalValue(nums,original*2);\\n        return original;\\n    }\\n```\n```\\n    int findFinalValue(vector<int>& nums, int original) {\\n        while(find(nums.begin(),nums.end(),original)!=nums.end())\\n             original=original*2;\\n        return original;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730212,
                "title": "c-solution-tc-o-n-sc-o-n",
                "content": "```\\nint FindFinalValue(int[] nums, int original) {        \\n        var hs = new HashSet<int>(nums);        \\n        while(hs.Contains(original))        \\n            original *= 2;        \\n\\t\\t\\t\\n        return original;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint FindFinalValue(int[] nums, int original) {        \\n        var hs = new HashSet<int>(nums);        \\n        while(hs.Contains(original))        \\n            original *= 2;        \\n\\t\\t\\t\\n        return original;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730168,
                "title": "simple-3-lines-code-c-no-extra-data-structure-used",
                "content": "Simply we need to search updated value of \\'original\\' in vector and if it\\'s not present, then we need to return it.\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        while (find(nums.begin(), nums.end(), original) != nums.end())\\n            original <<= 1;\\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        while (find(nums.begin(), nums.end(), original) != nums.end())\\n            original <<= 1;\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730166,
                "title": "simple-c-solution-iterative-approach",
                "content": "Time Complexity : O(n)\\nSpace Complexity : O(1)\\n\\n    int findFinalValue(vector<int>& a, int l) \\n    {\\n        sort(a.begin(), a.end());\\n        int n=a.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(a[i] == l)\\n            {\\n                l*=2;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n",
                "solutionTags": [],
                "code": "Time Complexity : O(n)\\nSpace Complexity : O(1)\\n\\n    int findFinalValue(vector<int>& a, int l) \\n    {\\n        sort(a.begin(), a.end());\\n        int n=a.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(a[i] == l)\\n            {\\n                l*=2;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1730151,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int ans=original;\\n        unordered_set<int>s;\\n        for(int  i=0;i<nums.size();i++){\\n            s.insert(nums[i]);\\n           while(s.find(original)!=s.end())\\n                original=original*2;\\n            }\\n        \\n        return original;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int ans=original;\\n        unordered_set<int>s;\\n        for(int  i=0;i<nums.size();i++){\\n            s.insert(nums[i]);\\n           while(s.find(original)!=s.end())\\n                original=original*2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4048624,
                "title": "faster-easy-3-languages-solution-with-desciption",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n##### I did different solutions in different languages, I posted my fastest results to you\\n\\nLanguages | Time\\n--- | ---\\nJava | 0 m.s\\nC++ | 4 m.s\\nKotlin | cpp\\n\\n# Code\\n\\n- # Java\\n```java\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        while (true) {\\n            // if the orginal*2 is found we continue to double it\\n            if (find(nums, original)) \\n                original = original * 2;\\n            else \\n                return original;\\n        }\\n    }\\n\\n    boolean find(int[] arr, int original) {\\n        for (int i = 0; i < arr.length; i++) {\\n            // we look for original*2 in the array \\n            if (arr[i] == original) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n- # Kotlin\\n```\\nclass Solution {\\n    fun findFinalValue(nums: IntArray, original: Int): Int {\\n        var org = original;\\n        while (true) {\\n            if (find(nums, org))\\n                org *= 2\\n            else \\n                return org;\\n        }\\n    }\\n\\n    fun find(arr: IntArray, original: Int): Boolean {\\n        for (i in arr) {\\n            if (i == original) \\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n- # C++\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==original){\\n                original=2*original;\\n            }\\n            \\n        }\\n        return original;\\n    }\\n};\\n```\\n\\n# Please upvote me if you found it useful\\n",
                "solutionTags": [
                    "Java",
                    "Kotlin"
                ],
                "code": "```java\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        while (true) {\\n            // if the orginal*2 is found we continue to double it\\n            if (find(nums, original)) \\n                original = original * 2;\\n            else \\n                return original;\\n        }\\n    }\\n\\n    boolean find(int[] arr, int original) {\\n        for (int i = 0; i < arr.length; i++) {\\n            // we look for original*2 in the array \\n            if (arr[i] == original) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun findFinalValue(nums: IntArray, original: Int): Int {\\n        var org = original;\\n        while (true) {\\n            if (find(nums, org))\\n                org *= 2\\n            else \\n                return org;\\n        }\\n    }\\n\\n    fun find(arr: IntArray, original: Int): Boolean {\\n        for (i in arr) {\\n            if (i == original) \\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==original){\\n                original=2*original;\\n            }\\n            \\n        }\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033831,
                "title": "very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==original)\\n            original*=2;\\n        }\\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==original)\\n            original*=2;\\n        }\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778772,
                "title": "java-easy-solution-recursion",
                "content": "# Intuition\\nHere, we need to find a number which is double of it\\'s original.\\n\\n# Approach\\n1- first iterate the original array.\\n2- Check if nums[i] == original :\\n    a- if number present then multiply original number with 2 and return the same function, mean use recursion.\\n    b- otheriwse return just, original number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        for(int i =0; i < nums.length; i++){\\n            if(nums[i] == original){\\n             original = 2 * original;\\n             return  findFinalValue(nums, original);  \\n            }\\n        }\\n        return original;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        for(int i =0; i < nums.length; i++){\\n            if(nums[i] == original){\\n             original = 2 * original;\\n             return  findFinalValue(nums, original);  \\n            }\\n        }\\n        return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768680,
                "title": "simple-java-solution",
                "content": "\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        Set<Integer> set = new HashSet<>();\\n        int ans = original;\\n\\n        for(int i : nums){\\n            set.add(i);\\n        }\\n\\n        while(set.contains(ans)){\\n             if(!set.contains(ans))\\n                break;\\n               ans *= 2;\\n        }\\n      \\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        Set<Integer> set = new HashSet<>();\\n        int ans = original;\\n\\n        for(int i : nums){\\n            set.add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3566863,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nevery time we are looking for element which is equal to original value and multiply it after that i = -1 to start this process from the scratch;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if(nums[i] == original) {\\n              original *= 2;\\n              i = -1;\\n            }\\n        }\\n        return original;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if(nums[i] == original) {\\n              original *= 2;\\n              i = -1;\\n            }\\n        }\\n        return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431977,
                "title": "c",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int FindFinalValue(int[] nums, int original) \\n    {\\n        var set = nums.ToHashSet();\\n\\n        while (set.Contains(original))\\n            original *= 2;\\n\\n        return original;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int FindFinalValue(int[] nums, int original) \\n    {\\n        var set = nums.ToHashSet();\\n\\n        while (set.Contains(original))\\n            original *= 2;\\n\\n        return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416884,
                "title": "made-very-easy-c-hash-table",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n### Explained inside the code itself for better understanding.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original){\\n        vector<int> hash(1001,0);\\n\\n        //Intialise hash\\n        for(auto i:nums)\\n        {\\n            hash[i]++;\\n        }\\n\\n        //check whether original is present is in hash.\\n        while(original<=1000 && hash[original])\\n        {\\n            //keep multiplying by 2.\\n            original *= 2;\\n        }\\n\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return original;\\n    }\\n};\\n```\\n\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/10b331c9-1c63-41a0-82d5-cc3c289035f6_1681487274.5422037.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original){\\n        vector<int> hash(1001,0);\\n\\n        //Intialise hash\\n        for(auto i:nums)\\n        {\\n            hash[i]++;\\n        }\\n\\n        //check whether original is present is in hash.\\n        while(original<=1000 && hash[original])\\n        {\\n            //keep multiplying by 2.\\n            original *= 2;\\n        }\\n\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413095,
                "title": "c-nlogn-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(), nums.end());\\n        for(auto i : nums) {\\n            if(original == i) original *= 2;\\n        }\\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(), nums.end());\\n        for(auto i : nums) {\\n            if(original == i) original *= 2;\\n        }\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413081,
                "title": "c-brute-force",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int i = 0;\\n        while(i != nums.size()) {\\n            if(nums[i] == original) {\\n                i = 0;\\n                original *= 2;\\n            }\\n            else i++;\\n        }\\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int i = 0;\\n        while(i != nums.size()) {\\n            if(nums[i] == original) {\\n                i = 0;\\n                original *= 2;\\n            }\\n            else i++;\\n        }\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407599,
                "title": "100-faster-c-solution-4-approach-1-hashing-2-sorting-3-binary-search-4-noob",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbrute force ( noob approach )\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(N logn)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(), nums.end());\\n\\n        for(int i=0; i<nums.size(); i++)  {\\n            if(nums[i] == original)\\n            original *= 2;\\n        }\\n\\n        return original;\\n    }\\n};\\n```\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbinary search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(N logn)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findElement(vector<int>& nums, int s, int e, int target)    {\\n        while(s <= e)   {\\n            int mid = s + (e - s) / 2;\\n            if(nums[mid] == target) return mid;\\n            if(nums[mid] > target)  e = mid - 1;\\n            else    s = mid + 1;\\n        }\\n        return -1;\\n    }\\n\\n    int findFinalValue(vector<int>& nums, int target) {\\n        int s = 0, e = nums.size()-1;\\n        sort(nums.begin(), nums.end());\\n        while(true) {\\n            int x = findElement(nums, s, e, target);\\n            if(x == -1) return target;\\n            target *= 2;\\n            s = x;\\n        }\\n        return target;\\n    }\\n};\\n\\n```\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsorting and searching\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(N logn)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(), nums.end());\\n        for(auto it : nums)  \\n            if(it == original)  original *= 2;\\n        return original;\\n    }\\n};\\n\\n```\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhashing (100% faster) (best approach)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(N)***  \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        vector<bool> h(1005, false);\\n        for(auto it : nums) h[it] = true;\\n        while(original < 1005 && h[original])   original *= 2;\\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(), nums.end());\\n\\n        for(int i=0; i<nums.size(); i++)  {\\n            if(nums[i] == original)\\n            original *= 2;\\n        }\\n\\n        return original;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findElement(vector<int>& nums, int s, int e, int target)    {\\n        while(s <= e)   {\\n            int mid = s + (e - s) / 2;\\n            if(nums[mid] == target) return mid;\\n            if(nums[mid] > target)  e = mid - 1;\\n            else    s = mid + 1;\\n        }\\n        return -1;\\n    }\\n\\n    int findFinalValue(vector<int>& nums, int target) {\\n        int s = 0, e = nums.size()-1;\\n        sort(nums.begin(), nums.end());\\n        while(true) {\\n            int x = findElement(nums, s, e, target);\\n            if(x == -1) return target;\\n            target *= 2;\\n            s = x;\\n        }\\n        return target;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(), nums.end());\\n        for(auto it : nums)  \\n            if(it == original)  original *= 2;\\n        return original;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        vector<bool> h(1005, false);\\n        for(auto it : nums) h[it] = true;\\n        while(original < 1005 && h[original])   original *= 2;\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391140,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        while(1>0){\\n            \\n                if(found(nums,original)){\\n                    original*=2;\\n                }\\n                else{\\n                    return original;\\n                }\\n\\n            \\n        }\\n\\n       \\n        \\n    }\\n\\n    boolean found(int[] nums,int original ){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==original){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        while(1>0){\\n            \\n                if(found(nums,original)){\\n                    original*=2;\\n                }\\n                else{\\n                    return original;\\n                }\\n\\n            \\n        }\\n\\n       \\n        \\n    }\\n\\n    boolean found(int[] nums,int original ){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==original){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300565,
                "title": "keep-multiplying-found-values-by-two-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int i;\\n        sort(nums.begin(), nums.end());\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==original)\\n            {\\n                original *= 2;\\n            }\\n        }\\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int i;\\n        sort(nums.begin(), nums.end());\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==original)\\n            {\\n                original *= 2;\\n            }\\n        }\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179433,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        \\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        if(nums[i]==original)\\n        {\\n            original = 2 * original;\\n        }\\n        else\\n        {\\n            for (int j =  0; j < nums.size(); j++)\\n            {\\n                if (nums[j] == original)\\n                {\\n                    original = 2 * original;\\n                }\\n            }\\n        }\\n    }\\n    return original;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        \\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        if(nums[i]==original)\\n        {\\n            original = 2 * original;\\n        }\\n        else\\n        {\\n            for (int j =  0; j < nums.size(); j++)\\n            {\\n                if (nums[j] == original)\\n                {\\n                    original = 2 * original;\\n                }\\n            }\\n        }\\n    }\\n    return original;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097025,
                "title": "python-shortest-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def findFinalValue(self, nums, original):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type original: int\\n        :rtype: int\\n        \"\"\"\\n        while True:\\n            if original not in nums:\\n                return original\\n            original*=2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findFinalValue(self, nums, original):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type original: int\\n        :rtype: int\\n        \"\"\"\\n        while True:\\n            if original not in nums:\\n                return original\\n            original*=2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992177,
                "title": "easy-approach-1ms-simple-java-solution",
                "content": "# Intuition\\nThe array is not sorted so you need to apply **linear search** to find **original**. Then increase its value by **2times**.Again find **original** (increased) in that array(0 to n - 1).Thus if you can\\'t find original then return it.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimple linear search will be applicable to it.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        int n = nums.length, i = 0;\\n        while(i < n){\\n            if(nums[i] == original){\\n                original *= 2;\\n                i = 0;\\n            }\\n            else\\n                i++;\\n        }\\n        return original;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        int n = nums.length, i = 0;\\n        while(i < n){\\n            if(nums[i] == original){\\n                original *= 2;\\n                i = 0;\\n            }\\n            else\\n                i++;\\n        }\\n        return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944687,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        int result=original;\\n        for(int i=0;i<nums.length;){\\n            if(result==nums[i]){\\n                result*=2;\\n                i=0;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        int result=original;\\n        for(int i=0;i<nums.length;){\\n            if(result==nums[i]){\\n                result*=2;\\n                i=0;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847992,
                "title": "c-easy-solution-god-speed",
                "content": "```\\nint find(int *p,int n,int original);\\nint findFinalValue(int* nums, int numsSize, int original){\\nint x=find(nums,numsSize,original);\\n    return x;\\n}\\nint find(int *p,int n,int original){\\n    for(int i=0;i<n;i++){\\n        if(p[i]==original){\\n            original=original*2;\\n            return find(p,n,original);\\n        }\\n    }\\n            return original;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint find(int *p,int n,int original);\\nint findFinalValue(int* nums, int numsSize, int original){\\nint x=find(nums,numsSize,original);\\n    return x;\\n}\\nint find(int *p,int n,int original){\\n    for(int i=0;i<n;i++){\\n        if(p[i]==original){\\n            original=original*2;\\n            return find(p,n,original);\\n        }\\n    }\\n            return original;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2796164,
                "title": "java-simple-function-solution",
                "content": "```\\nclass Solution {\\n    public boolean isFound(int[] nums,int original){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==original){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int findFinalValue(int[] nums, int original) {\\n        while(true){\\n            if(isFound(nums,original)){\\n                original=original*2;\\n            }\\n            else{\\n                return original;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isFound(int[] nums,int original){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==original){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int findFinalValue(int[] nums, int original) {\\n        while(true){\\n            if(isFound(nums,original)){\\n                original=original*2;\\n            }\\n            else{\\n                return original;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763487,
                "title": "python-while-loop-easiest",
                "content": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        a = True\\n        while a:\\n            if original in nums:\\n                original = original * 2\\n            else:\\n                a = False\\n        return original\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        a = True\\n        while a:\\n            if original in nums:\\n                original = original * 2\\n            else:\\n                a = False\\n        return original\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739979,
                "title": "q2154-accepted-c-sol-using-hashmap-easy-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n        unordered_map <int,int> mp;\\n        for(int i=0;i<n;i++)\\n            mp[nums[i]]++;\\n        \\n        while(1)\\n            if(mp[original]==0)\\n                return original;\\n            else\\n                if(mp[original]>0)\\n                    original=original*2;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n        unordered_map <int,int> mp;\\n        for(int i=0;i<n;i++)\\n            mp[nums[i]]++;\\n        \\n        while(1)\\n            if(mp[original]==0)\\n                return original;\\n            else\\n                if(mp[original]>0)\\n                    original=original*2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689842,
                "title": "java-1-ms-faster-than-98",
                "content": "```\\nclass Solution {\\n    \\n    public int findFinalValue(int[] nums, int original) {\\n        if(linearSearch(nums,original)) return findFinalValue(nums,original*2);\\n        return original;\\n    }\\n    \\n    boolean linearSearch(int[] nums,int target){\\n        for(int num : nums){\\n            if(num == target) return true;\\n        }\\n        return false;\\n        \\n     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int findFinalValue(int[] nums, int original) {\\n        if(linearSearch(nums,original)) return findFinalValue(nums,original*2);\\n        return original;\\n    }\\n    \\n    boolean linearSearch(int[] nums,int target){\\n        for(int num : nums){\\n            if(num == target) return true;\\n        }\\n        return false;\\n        \\n     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682419,
                "title": "java-faster-o-2n-hashset-easy-and-elegant-solution",
                "content": "```\\nHashSet<Integer> has= new HashSet<>(nums.length);\\nfor (int i=0;i<=nums.length-1;i++)\\n\\thas.add(nums[i]);\\nfor (int i=0;i<=nums.length-1;i++) {\\n\\tif (!has.contains(original))\\n\\t\\tbreak;\\n\\toriginal = original * 2;\\n}\\nreturn original; \\n```\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE !**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nHashSet<Integer> has= new HashSet<>(nums.length);\\nfor (int i=0;i<=nums.length-1;i++)\\n\\thas.add(nums[i]);\\nfor (int i=0;i<=nums.length-1;i++) {\\n\\tif (!has.contains(original))\\n\\t\\tbreak;\\n\\toriginal = original * 2;\\n}\\nreturn original; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2667135,
                "title": "easiest-approach-using-hash-set-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        unordered_set<int> s;\\n        for(int i=0;i<nums.size();i++){\\n            s.insert(nums[i]);\\n        }\\n        while(s.find(original)!=s.end()){\\n            original*=2;\\n        }\\n        return original;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        unordered_set<int> s;\\n        for(int i=0;i<nums.size();i++){\\n            s.insert(nums[i]);\\n        }\\n        while(s.find(original)!=s.end()){\\n            original*=2;\\n        }\\n        return original;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641223,
                "title": "swift-3-lines-of-code",
                "content": "```\\nclass Solution {\\n    func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\\n        var target = original\\n        while nums.contains(target) { target *= 2 }\\n        return target\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\\n        var target = original\\n        while nums.contains(target) { target *= 2 }\\n        return target\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634661,
                "title": "c-easy-and-readable-solution",
                "content": "![image](https://assets.leetcode.com/users/images/85cf7041-1d70-4f85-9168-45b8c8e18ba2_1664369612.9293044.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int FindFinalValue(int[] nums, int original) {\\n        \\n        int newOriginal  = original;\\n        List<int> numsList = nums.ToList();\\n        int i =  0;\\n        \\n        numsList.Sort();\\n        \\n        while (i < numsList.Count)\\n        {\\n            if  (numsList[i] == newOriginal)\\n                newOriginal *= 2;\\n            i++;\\n        }\\n        \\n        return newOriginal;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindFinalValue(int[] nums, int original) {\\n        \\n        int newOriginal  = original;\\n        List<int> numsList = nums.ToList();\\n        int i =  0;\\n        \\n        numsList.Sort();\\n        \\n        while (i < numsList.Count)\\n        {\\n            if  (numsList[i] == newOriginal)\\n                newOriginal *= 2;\\n            i++;\\n        }\\n        \\n        return newOriginal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631256,
                "title": "easiest-solution-in-c-using-sorting",
                "content": "\"\\'\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==original)\\n                original*=2;\\n        }\\n        return original;\\n    }\\n};\\n\"\\'",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==original)\\n                original*=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2585775,
                "title": "java-binary-search-recursion",
                "content": "* **Return Case :**\\n**1.** If Original value isn\\'t there in the array , return that value .\\n**2.** If Original value is found in the array then multiply it by 2 and check again wheather it is present in the array or not.\\n**3.** If present then carry on (multiply 2).\\n**4.** Such element found that is not in the array then return that element .\\nHere , step 1 and 4 are preety much same  ... on the other hand step 2 and 3 are also equal . \\nso , wrap this up in a recursive function :\\n**helper**(nums , target)\\n{\\n       if(target is not found)\\n\\t            return target;\\n\\t\\treturn helper(nums , 2*target);\\n}\\n**If we want to use Binary search , we just have to sort the array .\\nFull procedure is given below ::**\\n```\\nclass Solution {\\n    static boolean bin_search(int[] num , int target){\\n        int s = 0;\\n        int l = num.length - 1;\\n        while(s <= l){\\n            int mid = s +(l-s)/2;\\n            if(num[mid] == target)\\n                return true;\\n            if(target < num[mid])\\n                l = mid - 1;\\n            else\\n                s = mid + 1;\\n        }\\n        return false;\\n    }\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        if(bin_search(nums , original) == false)\\n            return original;\\n        original = original*2;\\n        return findFinalValue(nums , original);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    static boolean bin_search(int[] num , int target){\\n        int s = 0;\\n        int l = num.length - 1;\\n        while(s <= l){\\n            int mid = s +(l-s)/2;\\n            if(num[mid] == target)\\n                return true;\\n            if(target < num[mid])\\n                l = mid - 1;\\n            else\\n                s = mid + 1;\\n        }\\n        return false;\\n    }\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        if(bin_search(nums , original) == false)\\n            return original;\\n        original = original*2;\\n        return findFinalValue(nums , original);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557291,
                "title": "c-o-n-solution-using-unordered-set",
                "content": "\"\\nint findFinalValue(vector<int>& nums, int original) {\\n        unordered_map<int,int>mp;\\n        for(auto i:nums){\\n            mp[i]++;\\n        }\\n        while(1){\\n            if(mp[original]>0){\\n                original=2*original;\\n            }else break;\\n        }\\n        return original;\\n    }\\n\"",
                "solutionTags": [],
                "code": "\"\\nint findFinalValue(vector<int>& nums, int original) {\\n        unordered_map<int,int>mp;\\n        for(auto i:nums){\\n            mp[i]++;\\n        }\\n        while(1){\\n            if(mp[original]>0){\\n                original=2*original;\\n            }else break;\\n        }\\n        return original;\\n    }\\n\"",
                "codeTag": "Unknown"
            },
            {
                "id": 2482501,
                "title": "java-1ms-easy-understanding-without-sort",
                "content": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==original){\\n                original=2*original;\\n                i=-1;\\n            }\\n        }\\n        return original;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==original){\\n                original=2*original;\\n                i=-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2435349,
                "title": "1ms-java-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n        int[] ans = new int[1001];\\n\\n        for (int i: nums) ans[i]++;\\n\\n        while (original < 1001){\\n            if (ans[original] > 0) original *= 2;\\n            else break;\\n        }\\n\\n        return original;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2429384,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) \\n    {\\n        HashSet<Integer> set = new HashSet<>();\\n        \\n        for(Integer i: nums)\\n        {\\n            set.add(i);\\n        }\\n        \\n        while(true)\\n        {\\n            if(set.contains(original))\\n                original = original*2;\\n            \\n            else\\n                break;\\n        }\\n         return original;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) \\n    {\\n        HashSet<Integer> set = new HashSet<>();\\n        \\n        for(Integer i: nums)\\n        {\\n            set.add(i);\\n        }\\n        \\n        while(true)\\n        {\\n            if(set.contains(original))\\n                original = original*2;\\n            \\n            else\\n                break;\\n        }\\n         return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394230,
                "title": "java-best-solution-o-nlogn",
                "content": "class Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        int n = nums.length;\\n        \\n        int i=0;\\n        Arrays.sort(nums);\\n        while(i<n){\\n            if(original == nums[i++]){\\n                original *= 2;\\n            }\\n        }\\n        \\n        return original;\\n    }\\n}",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        int n = nums.length;\\n        \\n        int i=0;\\n        Arrays.sort(nums);\\n        while(i<n){\\n            if(original == nums[i++]){\\n                original *= 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2359623,
                "title": "short-and-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==original){\\n                original=original*2; \\n                i=-1;  } }\\n        return original;  }};\\n```\\n\\n\\n**Another Solution**\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        while(find(nums.begin(), nums.end(), original)!=nums.end()) original*=2;\\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==original){\\n                original=original*2; \\n                i=-1;  } }\\n        return original;  }};\\n```\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        while(find(nums.begin(), nums.end(), original)!=nums.end()) original*=2;\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340554,
                "title": "simple-cpp-solution",
                "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n        sort(nums.begin(), nums.end());\\n        int n=nums.size();\\n        for(int i=0; i<n; i++){\\n            if(original==nums[i])\\n                original*=2;\\n        }\\n        return original;\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n        sort(nums.begin(), nums.end());\\n        int n=nums.size();\\n        for(int i=0; i<n; i++){\\n            if(original==nums[i])\\n                original*=2;\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 2337520,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length; i++){\\n            if(original==nums[i]){\\n                original*=2;\\n            }\\n        }\\n        return original;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length; i++){\\n            if(original==nums[i]){\\n                original*=2;\\n            }\\n        }\\n        return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299489,
                "title": "simple-java-solution-without-hashset-o-n-0-ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        \\n        boolean flag[]=new boolean[1001];\\n        for(int i : nums)\\n            flag[i]=true;\\n        \\n        while(original<=1000 && flag[original]==true)\\n            original*=2;\\n        \\n        return original;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        \\n        boolean flag[]=new boolean[1001];\\n        for(int i : nums)\\n            flag[i]=true;\\n        \\n        while(original<=1000 && flag[original]==true)\\n            original*=2;\\n        \\n        return original;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2294355,
                "title": "java-0ms-faster-than-100-o-n-simple-approach",
                "content": "[https://leetcode.com/submissions/detail/749264815/](https://leetcode.com/submissions/detail/749264815/)\\n\\n```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        boolean[] arr = new boolean[2002];\\n        for(int n: nums) {\\n            arr[n] = true;\\n        }\\n        \\n        while(arr[original]) {\\n            original *= 2;\\n        }\\n        return original;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        boolean[] arr = new boolean[2002];\\n        for(int n: nums) {\\n            arr[n] = true;\\n        }\\n        \\n        while(arr[original]) {\\n            original *= 2;\\n        }\\n        return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252024,
                "title": "c-4-line-code-easiest-solution",
                "content": "Please upvote if you like my solution .\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int ori) {\\n        set<int> s;\\n        for(auto x:nums) s.insert(x);\\n        while(s.find(ori) != s.end()) ori *= 2;\\n        return ori;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int ori) {\\n        set<int> s;\\n        for(auto x:nums) s.insert(x);\\n        while(s.find(ori) != s.end()) ori *= 2;\\n        return ori;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229433,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        for(int i = 0; i<nums.length; i++){\\n            if(nums[i] == original){\\n                original *= 2;\\n            }\\n        }\\n        return original;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        for(int i = 0; i<nums.length; i++){\\n            if(nums[i] == original){\\n                original *= 2;\\n            }\\n        }\\n        return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193687,
                "title": "simple-python3-solution",
                "content": "```\\n\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums:\\n            original*=2\\n        return original\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums:\\n            original*=2\\n        return original\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158829,
                "title": "javascript-while-loop-easy-approach",
                "content": "```\\n    while(nums.includes(original)){\\n        original*=2\\n    }\\n    return original\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n    while(nums.includes(original)){\\n        original*=2\\n    }\\n    return original\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2150045,
                "title": "keep-multiplying-found-values-by-two",
                "content": "for(int i=0;i<nums.length;i++){\\n          if (nums[i]==original){\\n           original=2*original; \\n        }\\n        else {\\n            original=original;\\n        }\\n    }\\n      return original;  \\n    \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "for(int i=0;i<nums.length;i++){\\n          if (nums[i]==original){\\n           original=2*original; \\n        }\\n        else {\\n            original=original;\\n        }\\n    }\\n      return original;  \\n    \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2099735,
                "title": "java-solution-very-easy",
                "content": "```\\nclass Solution {\\n\\n    public int findFinalValue(int[] nums, int original) {\\n        List<Integer> val = new ArrayList();\\n        for (int i = 0; i < nums.length; i++) val.add(nums[i]);\\n        while (val.contains(original)) original *= 2;\\n\\n        return original;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int findFinalValue(int[] nums, int original) {\\n        List<Integer> val = new ArrayList();\\n        for (int i = 0; i < nums.length; i++) val.add(nums[i]);\\n        while (val.contains(original)) original *= 2;\\n\\n        return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084428,
                "title": "simple-c-solution-using-stl-find-function",
                "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            auto it=find(nums.begin(),nums.end(),original);\\n            if(it!=nums.end())\\n            {\\n                original=*it*2;\\n            }\\n        }\\n        return original;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            auto it=find(nums.begin(),nums.end(),original);\\n            if(it!=nums.end())\\n            {\\n                original=*it*2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2045552,
                "title": "java-solution-using-binary-search-very-easy",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n         while(binarySearch(nums,original)!=-1){\\n             original*=2;\\n         }\\n        return original;\\n    }\\n    int binarySearch(int[] arr,int target){\\n        int start = 0;\\n        int end = arr.length-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(target<arr[mid]){\\n                end =mid - 1;\\n            }else if(target>arr[mid]){\\n                start = mid+1;\\n            }else{\\n                return arr[mid];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n         while(binarySearch(nums,original)!=-1){\\n             original*=2;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2032387,
                "title": "simple-java-solution-using-only-one-for-loops-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == original) {\\n                original *= 2;\\n            }\\n        }\\n        return original;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == original) {\\n                original *= 2;\\n            }\\n        }\\n        return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013083,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) \\n    {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==original)\\n                original*=2;\\n        }\\n        return original;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int findFinalValue(int[] nums, int original) \\n    {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==original)\\n                original*=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1961180,
                "title": "c-3-lines-sorted",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(), nums.end());\\n        for( int i = 0; i < size(nums); i++ ) if ( nums[i] == original ) original*=2;\\n        return original;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(), nums.end());\\n        for( int i = 0; i < size(nums); i++ ) if ( nums[i] == original ) original*=2;\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1952310,
                "title": "2-simple-javascript-solution",
                "content": "Two Js Solutions:\\n```\\n// using while loop\\nvar findFinalValue = function(nums, original) {\\n    while(nums.includes(original)) {\\n        original *= 2;\\n    }\\n    return original;\\n};\\n```\\n\\n```\\n// using recursion\\nvar findFinalValue = function(nums, original) {\\n    if(!nums.includes(original)) return original;\\n    return findFinalValue(nums, original*2);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n// using while loop\\nvar findFinalValue = function(nums, original) {\\n    while(nums.includes(original)) {\\n        original *= 2;\\n    }\\n    return original;\\n};\\n```\n```\\n// using recursion\\nvar findFinalValue = function(nums, original) {\\n    if(!nums.includes(original)) return original;\\n    return findFinalValue(nums, original*2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1924216,
                "title": "c-solution-simple-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        while(std::find(nums.begin(), nums.end(), original)!=nums.end()){\\n            original *= 2;\\n        }\\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        while(std::find(nums.begin(), nums.end(), original)!=nums.end()){\\n            original *= 2;\\n        }\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892434,
                "title": "java-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        boolean[] values = new boolean[1001];\\n        for(int i =0; i<= nums.length-1; i++){\\n            values[nums[i]] = true;;\\n        }\\n        int lastOriginal = original;\\n        while(lastOriginal <= 1000 && values[lastOriginal]){\\n            lastOriginal = lastOriginal<<1;\\n            \\n        }\\n        return lastOriginal;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        boolean[] values = new boolean[1001];\\n        for(int i =0; i<= nums.length-1; i++){\\n            values[nums[i]] = true;;\\n        }\\n        int lastOriginal = original;\\n        while(lastOriginal <= 1000 && values[lastOriginal]){\\n            lastOriginal = lastOriginal<<1;\\n            \\n        }\\n        return lastOriginal;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889045,
                "title": "c-solution-faster-than-97-users-very-easy-solution",
                "content": "```\\n   int findFinalValue(vector<int>& a, int t) {\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(t==a[i])\\n            {\\n              t*=2;\\n              i=-1;\\n            } \\n        }\\n        return t;\\n    }\\n```\\n``` If you like my approach then please upvote me.```",
                "solutionTags": [],
                "code": "```\\n   int findFinalValue(vector<int>& a, int t) {\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(t==a[i])\\n            {\\n              t*=2;\\n              i=-1;\\n            } \\n        }\\n        return t;\\n    }\\n```\n``` If you like my approach then please upvote me.```",
                "codeTag": "Unknown"
            },
            {
                "id": 1885490,
                "title": "easy-java-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        HashSet<Integer>hm=new HashSet<>();\\n        for(int i:nums)\\n            hm.add(i);\\n        while(hm.contains(original))\\n        {\\n            original*=2;\\n        }\\n        return original;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        HashSet<Integer>hm=new HashSet<>();\\n        for(int i:nums)\\n            hm.add(i);\\n        while(hm.contains(original))\\n        {\\n            original*=2;\\n        }\\n        return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875880,
                "title": "c-easiest-solution",
                "content": "O(n) runtime and o(1) space complexity\\n\\nPlease give me an upvote if you find this helpful, I need upvotes to show my gf that I\\'m the man of the house. If you need help understanding anything comment down below, I will reply asap!\\n\\n```\\nstd::sort(nums.begin(), nums.end());\\n        int count = original;\\n        for(int i = 0; i < nums.size(); ++i)\\n        {\\n            if (nums[i] == original)\\n                original *= 2; // original <<= 1 works better since bit manipulation is faster\\n            \\n            if (nums[nums.size() - 1] < original)\\n                return original;\\n        }\\n        \\n        return original;\\n```",
                "solutionTags": [],
                "code": "```\\nstd::sort(nums.begin(), nums.end());\\n        int count = original;\\n        for(int i = 0; i < nums.size(); ++i)\\n        {\\n            if (nums[i] == original)\\n                original *= 2; // original <<= 1 works better since bit manipulation is faster\\n            \\n            if (nums[nums.size() - 1] < original)\\n                return original;\\n        }\\n        \\n        return original;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1859301,
                "title": "4-ms-faster-than-97-46-of-c-online-submissions-for-keep-multiplying-found-values-by-two",
                "content": "```\\n\\n\\nint findFinalValue(int* nums, int numsSize, int original){\\n    \\n    int i = 0;\\n    while (i < numsSize) {      \\n        if (nums[i] == original){\\n            original *= 2;\\n            i = 0;\\n            continue;\\n        }\\n        i++;\\n    }\\n    \\n    return original;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\nint findFinalValue(int* nums, int numsSize, int original){\\n    \\n    int i = 0;\\n    while (i < numsSize) {      \\n        if (nums[i] == original){\\n            original *= 2;\\n            i = 0;\\n            continue;\\n        }\\n        i++;\\n    }\\n    \\n    return original;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1846100,
                "title": "easy-faster-92-less-memory-usage-than-92",
                "content": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums:\\n            original *= 2\\n        return original",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums:\\n            original *= 2\\n        return original",
                "codeTag": "Java"
            },
            {
                "id": 1831031,
                "title": "fastest-javascript-solution-using-recursion",
                "content": "```\\nvar findFinalValue = function(nums, original) {\\n     const index = nums.indexOf(original)\\n    \\n    if(index === -1 ) {\\n        return original;\\n    } else {\\n       original = 2 * original\\n       return findFinalValue(nums, original)\\n   \\n    }\\n\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nvar findFinalValue = function(nums, original) {\\n     const index = nums.indexOf(original)\\n    \\n    if(index === -1 ) {\\n        return original;\\n    } else {\\n       original = 2 * original\\n       return findFinalValue(nums, original)\\n   \\n    }\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1827285,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        int i=0;\\n        while(i<nums.length)\\n        {\\n            if(nums[i]==original)\\n            {\\n                original=2*original;\\n                i=0;\\n            }\\n            else\\n            i++;\\n        }\\n        return original;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        int i=0;\\n        while(i<nums.length)\\n        {\\n            if(nums[i]==original)\\n            {\\n                original=2*original;\\n                i=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1788278,
                "title": "c-loop-with-dictionary",
                "content": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        set<int> m;\\n        for (int i = 0; i < nums.size(); i++) m.insert(nums[i]);\\n        while (m.count(original) == 1) original *= 2;\\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        set<int> m;\\n        for (int i = 0; i < nums.size(); i++) m.insert(nums[i]);\\n        while (m.count(original) == 1) original *= 2;\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781523,
                "title": "c-solution-simplest-approach-beginners-friendly-o-n-time",
                "content": "```\\nint findFinalValue(vector<int>& nums, int original) {\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==original){\\n                original=original*2;\\n                i=-1;\\n            }\\n        }\\n        return original;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint findFinalValue(vector<int>& nums, int original) {\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==original){\\n                original=original*2;\\n                i=-1;\\n            }\\n        }\\n        return original;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1770497,
                "title": "simple-solution",
                "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==original)\\n            {\\n                original=2*nums[i];\\n            }\\n        }\\n        return original;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==original)\\n            {\\n                original=2*nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1769116,
                "title": "using-set-o-n-solution",
                "content": "```\\nclass Solution(object):\\n    def findFinalValue(self, nums, original):\\n        \\n        s = set(nums)\\n        \\n        while original in s:\\n            original *=2\\n            \\n        return original\\n        \\n       \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def findFinalValue(self, nums, original):\\n        \\n        s = set(nums)\\n        \\n        while original in s:\\n            original *=2\\n            \\n        return original\\n        \\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764651,
                "title": "rust-boolean-array-or-hashset",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl1/lc2154)\\n\\n```\\nuse std::collections::HashSet;\\n/// @author: Leon\\n/// https://leetcode.com/problems/keep-multiplying-found-values-by-two/\\n/// Time Complexity:    O(`_len_n`)\\n/// Space Complexity:   O(`_len_n`)\\nimpl Solution {\\n    pub fn find_final_value(nums: Vec<i32>, original: i32) -> i32 {\\n        let _len_n: usize = nums.len();\\n        let num_set: HashSet<i32> = nums.into_iter().collect();\\n        let mut num = original;\\n        while num_set.contains(&num) {\\n            num *= 2;\\n        }\\n        num\\n    }\\n}\\n```\\n\\n```\\n/// @author: Leon\\n/// https://leetcode.com/problems/keep-multiplying-found-values-by-two/\\n/// Time Complexity:    O(`RANGE`)\\n/// Space Complexity:   O(`RANGE`)\\nimpl Solution {\\n    pub fn find_final_value(nums: Vec<i32>, original: i32) -> i32 {\\n        let _len_n: usize = nums.len();\\n        const RANGE: u16 = 1000 + 1;\\n        let exists: Vec<bool> = {\\n            let mut exists: Vec<bool> = vec![false; RANGE as usize];\\n            for num in nums {\\n                exists[num as usize] = true;\\n            }\\n            exists\\n        };\\n        let mut num: u16 = original as u16;\\n        while num < RANGE && exists[num as usize] {\\n            num *= 2\\n        }\\n        num as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\n/// @author: Leon\\n/// https://leetcode.com/problems/keep-multiplying-found-values-by-two/\\n/// Time Complexity:    O(`_len_n`)\\n/// Space Complexity:   O(`_len_n`)\\nimpl Solution {\\n    pub fn find_final_value(nums: Vec<i32>, original: i32) -> i32 {\\n        let _len_n: usize = nums.len();\\n        let num_set: HashSet<i32> = nums.into_iter().collect();\\n        let mut num = original;\\n        while num_set.contains(&num) {\\n            num *= 2;\\n        }\\n        num\\n    }\\n}\\n```\n```\\n/// @author: Leon\\n/// https://leetcode.com/problems/keep-multiplying-found-values-by-two/\\n/// Time Complexity:    O(`RANGE`)\\n/// Space Complexity:   O(`RANGE`)\\nimpl Solution {\\n    pub fn find_final_value(nums: Vec<i32>, original: i32) -> i32 {\\n        let _len_n: usize = nums.len();\\n        const RANGE: u16 = 1000 + 1;\\n        let exists: Vec<bool> = {\\n            let mut exists: Vec<bool> = vec![false; RANGE as usize];\\n            for num in nums {\\n                exists[num as usize] = true;\\n            }\\n            exists\\n        };\\n        let mut num: u16 = original as u16;\\n        while num < RANGE && exists[num as usize] {\\n            num *= 2\\n        }\\n        num as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1759609,
                "title": "js-easy-fast-and-simple-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} original\\n * @return {number}\\n */\\nvar findFinalValue = function(nums, original) {\\n    let map = {};\\n    for(let n of nums){\\n        map[n] = 1;\\n    }\\n    while(typeof map[original] != \\'undefined\\'){\\n        original *= 2;\\n    }\\n    return original;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} original\\n * @return {number}\\n */\\nvar findFinalValue = function(nums, original) {\\n    let map = {};\\n    for(let n of nums){\\n        map[n] = 1;\\n    }\\n    while(typeof map[original] != \\'undefined\\'){\\n        original *= 2;\\n    }\\n    return original;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1747871,
                "title": "recursive-c-faster-than-75-easy-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n\\n       bool iff = searchi(nums,original); // search on the value \\n        \\n\\t\\t// if found we re-execute the function to search about val*2 \\n        if(iff) return findFinalValue(nums,original*2); \\n        return original; // else return where you left off\\n    }\\n    bool searchi (vector<int>& nums,int val)\\n    {\\n        for(int i=0;i<nums.size();i++) { // O(N) seach -- can be optimized by applying binary search\\n            if(nums[i]==val) return true;\\n        }\\n        return false; \\n    }\\n};",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n\\n       bool iff = searchi(nums,original); // search on the value \\n        \\n\\t\\t// if found we re-execute the function to search about val*2 \\n        if(iff) return findFinalValue(nums,original*2); \\n        return original; // else return where you left off\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1746406,
                "title": "kotlin-recursive-solution",
                "content": "```\\nclass Solution {\\n    fun findFinalValue(nums: IntArray, original: Int): Int =\\n        findNum(original, nums.toSet())\\n    \\n    private tailrec fun findNum(num: Int, set: Set<Int>): Int =\\n        if (!set.contains(num)) num else findNum(num * 2, set)\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    fun findFinalValue(nums: IntArray, original: Int): Int =\\n        findNum(original, nums.toSet())\\n    \\n    private tailrec fun findNum(num: Int, set: Set<Int>): Int =\\n        if (!set.contains(num)) num else findNum(num * 2, set)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744758,
                "title": "efficient-python-solution-with-explanation",
                "content": "**Approach**:\\n1. Create a flag for ```while``` loop.\\n2. Create a ```for``` loop in range of ```nums```.\\n3. Use ```if``` statement for validating condition and if conditions is true, increase original by 2 and break ```for``` loop.\\n4. Use ```else``` with for loop and return original.\\n```python\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        flag = True\\n        while flag:\\n            for i in range(len(nums)):\\n                if nums[i] == original:\\n                    original *= 2\\n                    break\\n            else:\\n                return original\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```while```\n```for```\n```nums```\n```if```\n```for```\n```else```\n```python\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        flag = True\\n        while flag:\\n            for i in range(len(nums)):\\n                if nums[i] == original:\\n                    original *= 2\\n                    break\\n            else:\\n                return original\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744091,
                "title": "beginner-friendly-javascript-solution",
                "content": "**Time Complexity : O(n)**\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} original\\n * @return {number}\\n */\\nvar findFinalValue = function(nums, original) {\\n    while(nums.includes(original)){\\n        original *= 2;\\n    }\\n    return original;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} original\\n * @return {number}\\n */\\nvar findFinalValue = function(nums, original) {\\n    while(nums.includes(original)){\\n        original *= 2;\\n    }\\n    return original;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1743657,
                "title": "python-set",
                "content": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        s = set(nums)\\n        while original in s:\\n            original *= 2\\n        return original\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        s = set(nums)\\n        while original in s:\\n            original *= 2\\n        return original\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739992,
                "title": "javascript-with-es6",
                "content": "```\\nvar findFinalValue = function(nums, original) {\\n    let result = original\\n    while(nums.includes(result)){\\n        result*=2;\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findFinalValue = function(nums, original) {\\n    let result = original\\n    while(nums.includes(result)){\\n        result*=2;\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1738432,
                "title": "easy-c-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i] == original)\\n                original *= 2;\\n        }\\n    \\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i] == original)\\n                original *= 2;\\n        }\\n    \\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736658,
                "title": "very-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] == original ){\\n                original *= 2 ;\\n            }\\n        }\\n        return original;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] == original ){\\n                original *= 2 ;\\n            }\\n        }\\n        return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736621,
                "title": "java-binary-search",
                "content": "\\t\\tpublic int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        boolean c = isP(nums, original);\\n        while(c == true){\\n            original = original*2;\\n            c = isP(nums, original);\\n        }\\n        return original;\\n    }\\n    \\n    public static boolean isP(int [] arr, int n){\\n        int lo = 0;\\n        int hi = arr.length-1;\\n        while(lo<=hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(n==arr[mid]){\\n                return true;\\n            }\\n            else if(arr[mid]< n){\\n                lo = mid + 1;\\n            }\\n            else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n\\t\\n\\t",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "\\t\\tpublic int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        boolean c = isP(nums, original);\\n        while(c == true){\\n            original = original*2;\\n            c = isP(nums, original);\\n        }\\n        return original;\\n    }\\n    \\n    public static boolean isP(int [] arr, int n){\\n        int lo = 0;\\n        int hi = arr.length-1;\\n        while(lo<=hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(n==arr[mid]){\\n                return true;\\n            }\\n            else if(arr[mid]< n){\\n                lo = mid + 1;\\n            }\\n            else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1734361,
                "title": "two-golang-solutions-with-quick-explanation",
                "content": "The idea of both of these solutions is to add `nums` elements to a map, and then just keep checking whether `original *= 2` is in the map.\\n\\nInstead of `original *= 2` I am doing `original <<= 1` for better time.\\n\\n***\\n\\nIn the first solution I am only adding elements that are multiples of `original` to the map.\\n\\n``` go\\nfunc findFinalValue(nums []int, original int) int {\\n    m := make(map[int] bool)\\n    \\n    for _, n := range nums {\\n        if n % original == 0 {\\n            m[n] = true\\n        }\\n    }\\n    \\n    for m[original] {\\n        original <<= 1\\n    }\\n    \\n    return original\\n}\\n```\\n\\n***\\n\\nIn the second solution I am adding all elements from `nums` to the map. Note that this solution has a little worse average space complexity. In the worst case they will both have the same complexity.\\n\\n``` go\\nfunc findFinalValue(nums []int, original int) int {\\n    m := make(map[int] bool)\\n    \\n    for _, n := range nums {\\n        m[n] = true\\n    }\\n    \\n    for m[original] {\\n        original <<= 1\\n    }\\n    \\n    return original\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc findFinalValue(nums []int, original int) int {\\n    m := make(map[int] bool)\\n    \\n    for _, n := range nums {\\n        if n % original == 0 {\\n            m[n] = true\\n        }\\n    }\\n    \\n    for m[original] {\\n        original <<= 1\\n    }\\n    \\n    return original\\n}\\n```\n``` go\\nfunc findFinalValue(nums []int, original int) int {\\n    m := make(map[int] bool)\\n    \\n    for _, n := range nums {\\n        m[n] = true\\n    }\\n    \\n    for m[original] {\\n        original <<= 1\\n    }\\n    \\n    return original\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1734062,
                "title": "java-binary-search-solution-o-nlogn-complexity",
                "content": "The logic here is initially sorting the array so as to use binary search algorithm.\\nThen we may continue looping till the number is not found.\\n```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        boolean notfound = true;\\n        while(notfound == true)\\n        {\\n            int i=0, j=nums.length-1;\\n            int dup = original;\\n            while(i<=j)\\n            {\\n                int mid = i + (j-i)/2;\\n                if(nums[mid] == original)\\n                {\\n                    original *= 2;\\n                    break;\\n                }\\n                else if(nums[mid] > original)\\n                {\\n                    j = mid-1;\\n                }\\n                else\\n                {\\n                    i = mid+1;\\n                }\\n            }\\n            if(dup == original)\\n            {\\n                break;\\n            }\\n        }\\n        return original;\\n    }\\n}\\n```\\n**Time Complexity: O(N logN)**\\n**Space Complexity: O(1)**\\n\\n\\n***Please upvote if you like the solution.***",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        Arrays.sort(nums);\\n        boolean notfound = true;\\n        while(notfound == true)\\n        {\\n            int i=0, j=nums.length-1;\\n            int dup = original;\\n            while(i<=j)\\n            {\\n                int mid = i + (j-i)/2;\\n                if(nums[mid] == original)\\n                {\\n                    original *= 2;\\n                    break;\\n                }\\n                else if(nums[mid] > original)\\n                {\\n                    j = mid-1;\\n                }\\n                else\\n                {\\n                    i = mid+1;\\n                }\\n            }\\n            if(dup == original)\\n            {\\n                break;\\n            }\\n        }\\n        return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732701,
                "title": "1-liner-python-javascript",
                "content": "**Python**\\n```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], og: int) -> int:\\n        return og if og not in nums else self.findFinalValue(nums, 2 * og)\\n```\\n\\n**JavaScript**\\n```\\nconst findFinalValue = (nums, og) => ( nums.includes(og) ? findFinalValue(nums, 2 * og) : og )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findFinalValue(self, nums: List[int], og: int) -> int:\\n        return og if og not in nums else self.findFinalValue(nums, 2 * og)\\n```\n```\\nconst findFinalValue = (nums, og) => ( nums.includes(og) ? findFinalValue(nums, 2 * og) : og )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732458,
                "title": "c-solution-hashset",
                "content": "**Complexity**\\n- Time: O(n)\\n- Space: O(n)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public int FindFinalValue(int[] nums, int original) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            throw new ArgumentException(\"Invaid Input.\");\\n        \\n        HashSet<int> set = new HashSet<int>(nums);\\n        while(set.Contains(original))\\n        {\\n            original *= 2;\\n        }\\n        \\n        return original;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindFinalValue(int[] nums, int original) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            throw new ArgumentException(\"Invaid Input.\");\\n        \\n        HashSet<int> set = new HashSet<int>(nums);\\n        while(set.Contains(original))\\n        {\\n            original *= 2;\\n        }\\n        \\n        return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731937,
                "title": "c-easy-approach-only-sort-and-search",
                "content": "First step is to sort the array.\\nFind the element if the element exist in array then\\nits double exist,right in the array.\\n\\n**CODE**\\n\\nsort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==o)\\n            {\\n                o=o*2;\\n            }\\n        }\\n        return o;",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "First step is to sort the array.\\nFind the element if the element exist in array then\\nits double exist,right in the array.\\n\\n**CODE**\\n\\nsort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==o)\\n            {\\n                o=o*2;\\n            }\\n        }\\n        return o;",
                "codeTag": "Unknown"
            },
            {
                "id": 1731897,
                "title": "two-line-javascript-solution-faster-than-99-of-submissions",
                "content": "```\\nconst findFinalValue = (nums, original) => {\\n\\n    while(nums.includes(original)) original = original * 2\\n\\t\\n    return original\\n};\\n```\\nFound this solution helpful? Consider showing support by upvoting this post.\\nIf there are any questions, kindly leave a comment below.\\nThank you!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findFinalValue = (nums, original) => {\\n\\n    while(nums.includes(original)) original = original * 2\\n\\t\\n    return original\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1731587,
                "title": "c",
                "content": "```\\nint findFinalValue(vector<int>& nums, int o) {\\n        unordered_map<int,int> m;\\n        for(auto i:nums){\\n            m[i]=1;\\n        }\\n        for(auto i:m){\\n            if(m.find(o)!=m.end()){\\n                o*=2;\\n            }\\n            else break;\\n        }\\n        return o;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint findFinalValue(vector<int>& nums, int o) {\\n        unordered_map<int,int> m;\\n        for(auto i:nums){\\n            m[i]=1;\\n        }\\n        for(auto i:m){\\n            if(m.find(o)!=m.end()){\\n                o*=2;\\n            }\\n            else break;\\n        }\\n        return o;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1731501,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int org) {\\n        sort(nums.begin(),nums.end()) ;\\n        while(true){\\n            if(binary_search(nums.begin(),nums.end(),org)){\\n                org = 2*org ;\\n            }\\n            else{\\n                return org ;\\n            }\\n        }\\n        return org ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int org) {\\n        sort(nums.begin(),nums.end()) ;\\n        while(true){\\n            if(binary_search(nums.begin(),nums.end(),org)){\\n                org = 2*org ;\\n            }\\n            else{\\n                return org ;\\n            }\\n        }\\n        return org ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731334,
                "title": "java-easy-to-understand",
                "content": "```\\n    public int findFinalValue(int[] nums, int original)\\n\\t{\\n          while(found(nums, original))\\n        {\\n            original*=2;\\n        }\\n        return original;\\n    }\\n   public boolean found(int[] n, int val)\\n    {\\n        for(int i=0;i<n.length;i++)\\n        {\\n            if(n[i]==val)\\n                return true;\\n\\t\\t}\\n        return false;\\n   }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int findFinalValue(int[] nums, int original)\\n\\t{\\n          while(found(nums, original))\\n        {\\n            original*=2;\\n        }\\n        return original;\\n    }\\n   public boolean found(int[] n, int val)\\n    {\\n        for(int i=0;i<n.length;i++)\\n        {\\n            if(n[i]==val)\\n                return true;\\n\\t\\t}\\n        return false;\\n   }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1731241,
                "title": "simple-java-solution-with-explaination",
                "content": "1 take a boolean array of size 1001 as this is the max value possible.\\n2 iterate array and make values of element present in nums true.\\n3. now  start from i=original and keep on checking if it is present in map. if yes update i=i * 2 and repeat the process\\n```\\npublic int findFinalValue(int[] nums, int original) {\\n\\t\\tboolean[] map = new boolean[1001];\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tmap[nums[i]] = true;\\n\\t\\t}\\n\\t\\tint i = original;\\n\\t\\twhile (i < 1001 && map[i]) {\\n\\t\\t\\ti=i*2;\\n\\t\\t}\\n\\t\\treturn i;\\n\\t}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findFinalValue(int[] nums, int original) {\\n\\t\\tboolean[] map = new boolean[1001];\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tmap[nums[i]] = true;\\n\\t\\t}\\n\\t\\tint i = original;\\n\\t\\twhile (i < 1001 && map[i]) {\\n\\t\\t\\ti=i*2;\\n\\t\\t}\\n\\t\\treturn i;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1731044,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn find_final_value(nums: Vec<i32>, original: i32) -> i32 {\\n        let mut powers = [false; 11];\\n        nums.iter().filter(|&&x| x % original == 0).for_each(|&x| {\\n            let n = (x / original) as u32;\\n            if n & (n - 1) == 0 {\\n                powers[n.trailing_zeros() as usize] = true;\\n            }\\n        });\\n        original * (1 << (powers.iter().position(|&x| !x).unwrap_or_default()))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_final_value(nums: Vec<i32>, original: i32) -> i32 {\\n        let mut powers = [false; 11];\\n        nums.iter().filter(|&&x| x % original == 0).for_each(|&x| {\\n            let n = (x / original) as u32;\\n            if n & (n - 1) == 0 {\\n                powers[n.trailing_zeros() as usize] = true;\\n            }\\n        });\\n        original * (1 << (powers.iter().position(|&x| !x).unwrap_or_default()))\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730806,
                "title": "c-binary-search-solution",
                "content": "Time: O(nlgn)\\nSpace: O(1)\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        std::sort(nums.begin(),nums.end());\\n        while(true){\\n            int pos = binary_search(nums,original);\\n            if(nums[pos]!=original) break;\\n            original = original * 2;\\n        }\\n        return original;\\n    }\\n    int binary_search(const std::vector<int>&arr,const int& target){\\n        int begin = 0;\\n        int end = (int)arr.size()-1;\\n        int mid = 0;\\n        while(begin<end){\\n            mid = begin + (end - begin)/2;\\n            if(arr[mid] == target) return mid;\\n            else if(target < arr[mid]) end = mid;\\n            else begin = mid +1;\\n        }\\n        return begin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        std::sort(nums.begin(),nums.end());\\n        while(true){\\n            int pos = binary_search(nums,original);\\n            if(nums[pos]!=original) break;\\n            original = original * 2;\\n        }\\n        return original;\\n    }\\n    int binary_search(const std::vector<int>&arr,const int& target){\\n        int begin = 0;\\n        int end = (int)arr.size()-1;\\n        int mid = 0;\\n        while(begin<end){\\n            mid = begin + (end - begin)/2;\\n            if(arr[mid] == target) return mid;\\n            else if(target < arr[mid]) end = mid;\\n            else begin = mid +1;\\n        }\\n        return begin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730789,
                "title": "javascript-o-n-time-space-beat-100-faster-solution",
                "content": "```\\nvar findFinalValue = function(nums, original) {\\n    const map = {};\\n    for(let i = 0; i < nums.length; i++){\\n        const curr = nums[i];\\n        if(!map[curr]) map[curr] = i+1;\\n    }\\n    let res = original;\\n    while(map[res]){\\n        res = res*2;\\n        if(res > 1000) break;\\n    }\\n    return res;\\n};\\n```\\n",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nvar findFinalValue = function(nums, original) {\\n    const map = {};\\n    for(let i = 0; i < nums.length; i++){\\n        const curr = nums[i];\\n        if(!map[curr]) map[curr] = i+1;\\n    }\\n    let res = original;\\n    while(map[res]){\\n        res = res*2;\\n        if(res > 1000) break;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730652,
                "title": "java-set-by-array-0ms",
                "content": "```\\nclass Solution {\\n\\tpublic int findFinalValue(int[] nums, int original) {\\n        int [] store = new int[1001];\\n        for (int i = 0; i < nums.length; i++) {\\n            store[nums[i]]++;\\n        }\\n        int ans = original;\\n        while (store[ans] >= 1) {\\n            store[ans] = 0;\\n            ans *= 2;\\n            if (ans > 1000) break;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Iterator",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int findFinalValue(int[] nums, int original) {\\n        int [] store = new int[1001];\\n        for (int i = 0; i < nums.length; i++) {\\n            store[nums[i]]++;\\n        }\\n        int ans = original;\\n        while (store[ans] >= 1) {\\n            store[ans] = 0;\\n            ans *= 2;\\n            if (ans > 1000) break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730593,
                "title": "java-solutions-multiple-approaches-very-simple-100-faster",
                "content": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        \\n//         TC - O(n log n) and SC - O(1)\\n//         Arrays.sort(nums);\\n//         int length = nums.length;\\n//         int idx = 0;\\n        \\n//         while (idx < length) {\\n//             if (nums[idx] == original) {\\n//                 original = 2 * original;\\n//             }\\n//             idx++;\\n//         }\\n//         return original;\\n        \\n\\n//         TC - O(n) and SC - O(n)\\n        boolean[] indexMap = new boolean[1001];\\n        int length = nums.length;\\n        for (int i = 0; i < length; i++) {\\n            indexMap[nums[i]] = true;\\n        }\\n        while (original <= 1000 && indexMap[original]) {\\n            original = 2 * original;\\n        }\\n        return original;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        \\n//         TC - O(n log n) and SC - O(1)\\n//         Arrays.sort(nums);\\n//         int length = nums.length;\\n//         int idx = 0;\\n        \\n//         while (idx < length) {\\n//             if (nums[idx] == original) {\\n//                 original = 2 * original;\\n//             }\\n//             idx++;\\n//         }\\n//         return original;\\n        \\n\\n//         TC - O(n) and SC - O(n)\\n        boolean[] indexMap = new boolean[1001];\\n        int length = nums.length;\\n        for (int i = 0; i < length; i++) {\\n            indexMap[nums[i]] = true;\\n        }\\n        while (original <= 1000 && indexMap[original]) {\\n            original = 2 * original;\\n        }\\n        return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730579,
                "title": "java-o-n-or-o-2n-hashset-explanation",
                "content": "**Example of worst case**\\n`nums : [32, 16, 8, 4, 2] `\\n`original : 2`\\n___\\n\\n![image](https://assets.leetcode.com/users/images/b9ea9873-0aa8-4ab3-8562-7c5804167b95_1643521437.2034056.jpeg)\\n\\n___\\n```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int dig) {\\n        HashSet<Integer> set = new HashSet();\\n        for(int num : nums){\\n            set.add(num);   //adding values as we iterate through the array\\n            // if(set.contains(dig)){   //this will skip the future possible checks, refer example\\n            //     dig = dig * 2;\\n            // }\\n            while(set.contains(dig)){   //we will keep updating \\'dig\\', till there is possible values in our set\\n                dig = dig * 2;\\n            }\\n        }\\n        return dig;\\n    }\\n}\\n```\\n**Time complexity : O(2N)**\\n**Space complexity : O(N)**\\n\\nWhy time complexity is `O(2N)` *[For worst case]*.\\nConsider the case I have mentioned in example, O(N) for `for` loop iteration, and another `O(N)` for `while` loop, as all the values in the set at the end will be `true` for our `while` condition.\\n\\nFeel free to suggest your implementation, or confusion.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int dig) {\\n        HashSet<Integer> set = new HashSet();\\n        for(int num : nums){\\n            set.add(num);   //adding values as we iterate through the array\\n            // if(set.contains(dig)){   //this will skip the future possible checks, refer example\\n            //     dig = dig * 2;\\n            // }\\n            while(set.contains(dig)){   //we will keep updating \\'dig\\', till there is possible values in our set\\n                dig = dig * 2;\\n            }\\n        }\\n        return dig;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730518,
                "title": "easy-c-solution-stl-vector-find",
                "content": "**if you like the solution plz upvote.**\\n\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int k=original;\\n        for(int i=0;i<nums.size();i++){ \\n            if(find(nums.begin(), nums.end(), k)!= nums.end()){\\n                cout<<k<<endl;\\n            }\\n            else{\\n                return k;\\n            }\\n            k = k*2;\\n        }\\n        return k;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int k=original;\\n        for(int i=0;i<nums.size();i++){ \\n            if(find(nums.begin(), nums.end(), k)!= nums.end()){\\n                cout<<k<<endl;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 1730417,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        List<Integer> ls = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            ls.add(nums[i]);\\n        }\\n        while (ls.contains(original)) {\\n            original = original * 2;\\n        }\\n        return original;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        List<Integer> ls = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            ls.add(nums[i]);\\n        }\\n        while (ls.contains(original)) {\\n            original = original * 2;\\n        }\\n        return original;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730375,
                "title": "easy-c-solution-two-approach",
                "content": "**time complexity = O(n)**\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n = nums.size();\\n         unordered_set<int> s;\\n          for(int i=0; i<n; i++)\\n          {\\n                  s.insert(nums[i]);\\n          }\\n          while(s.find(original) != s.end())\\n          {\\n                  original = 2*original;\\n          }\\n          return original;\\n    }\\n};\\n```\\n\\n**time complexity = O(n)**\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            if(original==nums[i]){\\n                original=2*original;\\n            }\\n        }\\n        return original;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n = nums.size();\\n         unordered_set<int> s;\\n          for(int i=0; i<n; i++)\\n          {\\n                  s.insert(nums[i]);\\n          }\\n          while(s.find(original) != s.end())\\n          {\\n                  original = 2*original;\\n          }\\n          return original;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            if(original==nums[i]){\\n                original=2*original;\\n            }\\n        }\\n        return original;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730350,
                "title": "simple-and-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        unordered_map<int,int>mp;\\n        for(int i:nums) mp[i]=1;\\n        while(mp[original]==1) original*=2;\\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        unordered_map<int,int>mp;\\n        for(int i:nums) mp[i]=1;\\n        while(mp[original]==1) original*=2;\\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730303,
                "title": "java-linear-search-simple-approach",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        // LINEAR SEARCH APPROACH\\n        \\n        Arrays.sort(nums);\\n        \\n        int res = 0;\\n        \\n        while(res == 0)\\n        {\\n            res = 1;\\n            \\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i] == original)\\n                {\\n                    original = nums[i];\\n                    original = original * 2;\\n                    res = 0;\\n                }\\n            }   \\n        }\\n        \\n        return original;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n        // LINEAR SEARCH APPROACH\\n        \\n        Arrays.sort(nums);\\n        \\n        int res = 0;\\n        \\n        while(res == 0)\\n        {\\n            res = 1;\\n            \\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i] == original)\\n                {\\n                    original = nums[i];\\n                    original = original * 2;\\n                    res = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1730296,
                "title": "c-two-approaches-brute-force-and-recursive-easy-to-undersrand",
                "content": "**Two Approaches :**\\n\\n**Approach 1: (Brute-Force)**\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        while(find(nums.begin(),nums.end(),original)!=nums.end())\\n             original=original*2;\\n        return original;\\n    }\\n};\\n```\\n\\n**Approach 2: (Using Recursion)**\\n\\n```\\nclass Solution {\\npublic:\\n    int res;\\n    int findFinalValue(vector<int>& nums, int original) {\\n        if (find(nums.begin(),nums.end(),original)==nums.end()){\\n            res=original;\\n            return res;\\n        }\\n        else    findFinalValue(nums,original*2);\\n        return res;\\n    }\\n};\\n```\\n\\nIf you liked the solution, then please upvote \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        while(find(nums.begin(),nums.end(),original)!=nums.end())\\n             original=original*2;\\n        return original;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int res;\\n    int findFinalValue(vector<int>& nums, int original) {\\n        if (find(nums.begin(),nums.end(),original)==nums.end()){\\n            res=original;\\n            return res;\\n        }\\n        else    findFinalValue(nums,original*2);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730292,
                "title": "java-binary-search-simple-approach",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n\\n        // Any search problem, can be solved with binary search - in less time complexity\\n        \\n        \\n        Arrays.sort(nums);\\n        \\n        int res;\\n        do\\n        {\\n            res = -1;\\n            res = binarySearch(nums, original);\\n            //System.out.println(res);\\n            if(res!= -1)\\n            {\\n                original = original*2;\\n            }\\n            \\n        }while(res!=-1);    //this loop will run till we don\\'t find anymore numbers in the array\\n        \\n        return original;\\n    }\\n    \\n    public int binarySearch(int[] nums, int target)\\n    {\\n        int start = 0;\\n        int end = nums.length-1;\\n        \\n        while(start<=end)\\n        {\\n            int mid = start + (end-start)/2;\\n            \\n            if(nums[mid] > target)\\n            {\\n                end = mid - 1;\\n            }\\n            else if(nums[mid] < target)\\n            {\\n                start = mid + 1;\\n            }\\n            else\\n            {\\n                return nums[mid];\\n            }\\n        }\\n        \\n        return -1;  //if we are not able to find the number in the array\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int findFinalValue(int[] nums, int original) {\\n\\n        // Any search problem, can be solved with binary search - in less time complexity\\n        \\n        \\n        Arrays.sort(nums);\\n        \\n        int res;\\n        do\\n        {\\n            res = -1;\\n            res = binarySearch(nums, original);\\n            //System.out.println(res);\\n            if(res!= -1)\\n            {\\n                original = original*2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1730284,
                "title": "my-accepted-java-code-easy-to-understand-java-code",
                "content": "\\tclass Solution {\\n\\t\\tpublic int findFinalValue(int[] nums, int original) {\\n\\t\\t\\tint n = nums.length;\\n\\t\\t\\t// Array.sort(nums,0,n-1);\\n\\t\\t\\tint sum = original;\\n\\n\\t\\t\\tfor (int i = 0; i < nums.length; i++) {    // sorting the nums array\\n\\t\\t\\t\\tfor (int j = i + 1; j < nums.length; j++) {\\n\\t\\t\\t\\tint tmp = 0;\\n\\t\\t\\t\\tif (nums[i] > nums[j]) {\\n\\t\\t\\t\\t\\ttmp = nums[i];\\n\\t\\t\\t\\t\\tnums[i] = nums[j];\\n\\t\\t\\t\\t\\tnums[j] = tmp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\tfor(int i=0;i<=n-1;i++){\\n\\t\\t\\t\\tif(nums[i]==sum)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t sum = 2*sum;   \\n\\t\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\t\\tpublic int findFinalValue(int[] nums, int original) {\\n\\t\\t\\tint n = nums.length;\\n\\t\\t\\t// Array.sort(nums,0,n-1);\\n\\t\\t\\tint sum = original;\\n\\n\\t\\t\\tfor (int i = 0; i < nums.length; i++) {    // sorting the nums array\\n\\t\\t\\t\\tfor (int j = i + 1; j < nums.length; j++) {\\n\\t\\t\\t\\tint tmp = 0;\\n\\t\\t\\t\\tif (nums[i] > nums[j]) {\\n\\t\\t\\t\\t\\ttmp = nums[i];\\n\\t\\t\\t\\t\\tnums[i] = nums[j];\\n\\t\\t\\t\\t\\tnums[j] = tmp;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1772403,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 1751860,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 2035725,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 1991430,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 1908792,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 1858581,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 1843336,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 1832585,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 1776599,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 1759670,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 1772403,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 1751860,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 2035725,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 1991430,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 1908792,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 1858581,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 1843336,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 1832585,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 1776599,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            },
            {
                "id": 1759670,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def findFinalValue(self, nums: List[int], original: int) -> int:\\n        while original in nums: \\n            original*=2\\n        return original"
                    },
                    {
                        "username": "sasha2k1",
                        "content": "C++. Fast\n\n\n`class Solution {\npublic:\n    int findFinalValue(vector<int>& ns, int k) {\n        while(find(ns.begin(), ns.end(), k)!=ns.end())        \n            k*=2;            \n        return k;\n    }\n};`\n\n"
                    },
                    {
                        "username": "NoNameAfterThat",
                        "content": "why didn't work?\n\npublic int FindFinalValue(int[] nums, int original)\n        {             \n            for (int i = 0; i < nums.Length; i++)\n            {\n                if (nums[i] == original)\n                {\n                    original *= 2;\n                }               \n            }\n            return original;            \n        }\n\nnums = [8,19,4,2,15,3]\noriginal = 2\n\nUse Testcase\nOutput\n4\nExpected\n16\n"
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "because you\\'re trying to just comparing the value original with all elements in array and it will match at index 3.  "
                    },
                    {
                        "username": "Rohit_chiki",
                        "content": "`This problem can be solved using 3 approaches.`\\n\\n1.  Run a loop on nums array until the original number is not present and each time you find a number multiply it with 2.\\n\\n2. Create a hashmap/hashset of nums array and run a loop until the original number is present in hashmap/hashset and each time you find a number multiply it with 2.\\n\\n3. Sort the nums array first and run a binary search on array whenever you will be going to search for the original number inside array."
                    },
                    {
                        "username": "Mamun429",
                        "content": "its simple \\n1. just check original found or not in nums array. if found then go to 2. if not then return original.\\n2. then original = original *2\\nthen repeat 1."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public int findFinalValue(int[] nums, int original) {\n        HashSet<Integer> set = new HashSet<>();\n        int result=original;\n        for(int i=0;i<nums.length;i++){\n            set.add(nums[i]);\n        }\n        while(set.contains(result)){\n            result = result*2; \n        } \n        return result;\n    }\n"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int n=nums.size();\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(nums[j]==original) {original*=2;}\\n            }\\n\\n        }\\n\\n        return original;\\n    }\\n};"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you're searching O(N) time & O(1) space, one pass solution without any sorting, but with bitwise tricks, it's [here](https://leetcode.com/problems/keep-multiplying-found-values-by-two/solutions/3298006/python-o-n-time-o-1-space-1-pass-bitwise-tricks-bit-manipulation/)."
                    },
                    {
                        "username": "MarceloZ",
                        "content": "I recommend sorting the input vector before you do anything else."
                    },
                    {
                        "username": "darkmatter404",
                        "content": "Hint: \n\n***********\nIt is ok to use two separate loops for O(N) solution if you are using hash table. \n\nYou won't need two loops if you consider using sorting but in that case your time complexity changes to O(NlogN)\n\n***********\nYou can also consider using a Set."
                    }
                ]
            }
        ]
    }
]