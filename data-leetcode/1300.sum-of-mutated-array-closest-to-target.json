[
    {
        "title": "Groups of Special-Equivalent Strings",
        "question_content": "You are given an array of strings of the same length words.\nIn one move, you can swap any two even indexed characters or any two odd indexed characters of a string words[i].\nTwo strings words[i] and words[j] are special-equivalent if after any number of moves, words[i] == words[j].\n\n\tFor example, words[i] = \"zzxy\" and words[j] = \"xyzz\" are special-equivalent because we may make the moves \"zzxy\" -> \"xzzy\" -> \"xyzz\".\n\nA group of special-equivalent strings from words is a non-empty subset of words such that:\n\n\tEvery pair of strings in the group are special equivalent, and\n\tThe group is the largest size possible (i.e., there is not a string words[i] not in the group such that words[i] is special-equivalent to every string in the group).\n\nReturn the number of groups of special-equivalent strings from words.\n&nbsp;\nExample 1:\n\nInput: words = [\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]\nOutput: 3\nExplanation: \nOne group is [\"abcd\", \"cdab\", \"cbad\"], since they are all pairwise special equivalent, and none of the other strings is all pairwise special equivalent to these.\nThe other two groups are [\"xyzz\", \"zzxy\"] and [\"zzyx\"].\nNote that in particular, \"zzxy\" is not special equivalent to \"zzyx\".\n\nExample 2:\n\nInput: words = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\nOutput: 3\n\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 1000\n\t1 <= words[i].length <= 20\n\twords[i] consist of lowercase English letters.\n\tAll the strings are of the same length.",
        "solutions": [
            {
                "id": 163413,
                "title": "java-concise-set-solution",
                "content": "For each String, we generate it\\'s corresponding signature, and add it to the set.\\nIn the end, we return the size of the set.\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set= new HashSet<>();\\n        for (String s: A){\\n            int[] odd= new int[26];\\n            int[] even= new int[26];\\n            for (int i=0; i<s.length(); i++){\\n                if (i%2==1) odd[s.charAt(i)-\\'a\\']++;\\n                else even[s.charAt(i)-\\'a\\']++;\\n            }\\n            String sig= Arrays.toString(odd)+Arrays.toString(even);\\n            set.add(sig);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set= new HashSet<>();\\n        for (String s: A){\\n            int[] odd= new int[26];\\n            int[] even= new int[26];\\n            for (int i=0; i<s.length(); i++){\\n                if (i%2==1) odd[s.charAt(i)-\\'a\\']++;\\n                else even[s.charAt(i)-\\'a\\']++;\\n            }\\n            String sig= Arrays.toString(odd)+Arrays.toString(even);\\n            set.add(sig);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163547,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A):\\n        return len(set(\"\".join(sorted(s[0::2])) + \"\".join(sorted(s[1::2])) for s in A))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A):\\n        return len(set(\"\".join(sorted(s[0::2])) + \"\".join(sorted(s[1::2])) for s in A))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163412,
                "title": "c-simple-solution",
                "content": "**General Idea:**\\n\\n1. Split strings in two to substrings, 1 with even indexed characters, and 1 with odd\\n2. Sort the two substrings (We do this because if you can swap on string with another, when sorted they will equal each other because they must have the same characters)\\n3. Insert your pair of strings into set, this will keep track of the unique \"groups\"\\n4. Rerturn the size of your set\\n\\nCheck out the video solution and explanation (for C++, Java, Python and BASH) here: https://youtu.be/WJ4NtyrakT0\\n```\\nint numSpecialEquivGroups(vector<string>& A) {\\n    set<pair<string,string>> s;\\n    for (const auto& w : A) {\\n        pair<string,string> p;\\n        for (int i = 0; i < w.size (); ++i) {\\n            if (i % 2) p.first  += w[i];\\n            else       p.second += w[i];\\n        }\\n        sort (p.first.begin  (), p.first.end ());\\n        sort (p.second.begin (), p.second.end ());\\n        s.insert (p);\\n    }\\n    return s.size ();\\n}",
                "solutionTags": [],
                "code": "**General Idea:**\\n\\n1. Split strings in two to substrings, 1 with even indexed characters, and 1 with odd\\n2. Sort the two substrings (We do this because if you can swap on string with another, when sorted they will equal each other because they must have the same characters)\\n3. Insert your pair of strings into set, this will keep track of the unique \"groups\"\\n4. Rerturn the size of your set\\n\\nCheck out the video solution and explanation (for C++, Java, Python and BASH) here: https://youtu.be/WJ4NtyrakT0\\n```\\nint numSpecialEquivGroups(vector<string>& A) {\\n    set<pair<string,string>> s;\\n    for (const auto& w : A) {\\n        pair<string,string> p;\\n        for (int i = 0; i < w.size (); ++i) {\\n            if (i % 2) p.first  += w[i];\\n            else       p.second += w[i];\\n        }\\n        sort (p.first.begin  (), p.first.end ());\\n        sort (p.second.begin (), p.second.end ());\\n        s.insert (p);\\n    }\\n    return s.size ();\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 358795,
                "title": "python3-detail-explanation-of-special-equivalent",
                "content": "* The point here is to understand the following requirement:\\nA move consists of choosing two indices i and j with i % 2 == j % 2, and swapping S[i] with S[j].\\nDon\\'t trap your thoughts by the word \\'swap\\'.\\nYour goal is how to identify the equivalent strings. \\n* There are two possible outcomes of i%2: 1 or 0. i is the index of the input string.\\n\\tif i % 2 ==1: i = 1,3,5,7 ... in other words, i is odd number. In other words, the order of the odd index\\'s value doesn\\'t matter here. You can swap them.\\n\\tif i % 2 ==0: i = 0,2,4,6 ... in other words, i is even number. In other words, the order of the even index\\'s value doesn\\'t matter here. You can swap them.\\n*  So sort the string\\'s odd index elements, and sort the string\\'s even index elements and combine them to create a new string called \"sort_string.\" If two string has the same \"sort_string,\" they are the special-equivalent strings.\\n```\\nA = [\"abcd\",\"cdab\",\"adcb\",\"cbad\"]\\n      ### sort odd index element      | sort even index element\\n\"abcd\" :              bd              |               ac\\n\"cbad\" :              bd              |               ac\\n\"adcb\" :              bd              |               ac\\n\"cdab\" :              bd              |               ac\\n# so they are equivalent strings\\n```\\n\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        res = set()\\n        for s in A:\\n            sort_odd_even = \\'\\'.join(sorted(s[1::2]) + sorted(s[::2]))\\n            res.add(sort_odd_even)\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nA = [\"abcd\",\"cdab\",\"adcb\",\"cbad\"]\\n      ### sort odd index element      | sort even index element\\n\"abcd\" :              bd              |               ac\\n\"cbad\" :              bd              |               ac\\n\"adcb\" :              bd              |               ac\\n\"cdab\" :              bd              |               ac\\n# so they are equivalent strings\\n```\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        res = set()\\n        for s in A:\\n            sort_odd_even = \\'\\'.join(sorted(s[1::2]) + sorted(s[::2]))\\n            res.add(sort_odd_even)\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163471,
                "title": "python-extremely-simple-solution",
                "content": "```\\nclass Solution:\\n\\tdef numSpecialEquivGroups(self, A):\\n\\t\\td = collections.defaultdict(int)\\n\\t\\tfor w in A:\\n\\t\\t\\teven = \\'\\'.join(sorted(w[0::2]))\\n\\t\\t\\todd = \\'\\'.join(sorted(w[1::2]))\\n\\t\\t\\td[(even, odd)] += 1\\n\\t\\t\\n\\t\\treturn len(d)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\tdef numSpecialEquivGroups(self, A):\\n\\t\\td = collections.defaultdict(int)\\n\\t\\tfor w in A:\\n\\t\\t\\teven = \\'\\'.join(sorted(w[0::2]))\\n\\t\\t\\todd = \\'\\'.join(sorted(w[1::2]))\\n\\t\\t\\td[(even, odd)] += 1\\n\\t\\t\\n\\t\\treturn len(d)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163767,
                "title": "straightforward-java-solution",
                "content": "map1 - the distribution of counts of the characters at even positions\\nmap2 - the distribution of counts of the characters at odd positions\\nset - how many unique distributions\\n\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : A) {\\n            int[] map1 = new int[256];\\n            int[] map2 = new int[256];\\n            for (int i = 0; i < s.length(); i++) {\\n                if (i % 2 == 0) {\\n                    map1[s.charAt(i)]++;\\n                } else {\\n                    map2[s.charAt(i)]++;\\n                }\\n            }\\n            set.add(Arrays.toString(map1) + \" \" + Arrays.toString(map2));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : A) {\\n            int[] map1 = new int[256];\\n            int[] map2 = new int[256];\\n            for (int i = 0; i < s.length(); i++) {\\n                if (i % 2 == 0) {\\n                    map1[s.charAt(i)]++;\\n                } else {\\n                    map2[s.charAt(i)]++;\\n                }\\n            }\\n            set.add(Arrays.toString(map1) + \" \" + Arrays.toString(map2));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536199,
                "title": "python-o-n-k-lg-k-sol-by-signature-90-w-hint",
                "content": "Python sol. by signature. \\n\\n---\\n\\n**Hint**:\\n\\nThink of the concept for  **anagram** judgement.\\n\\nWhat we need in this challenge is to verify the so-called \"**special equivalent**\", \\nwhich means even-indexed substring of input is anagram and odd-indexed substring of input is another anagram.\\n\\nWe can verify by signature checking.\\n\\nDefine **signature** as the **sorted even-indexed substring and odd-indexed substring** in alphabetic order.\\n\\nIf signature( s1 ) == signature( s2 ),\\nthen s1 and s2 are special equivalent.\\n\\n---\\n\\nFor example:\\ns1 = \\'**a**b**c**d\\', and s2 = \\'**c**d**a**b\\'\\n\\nThen, signature( s1 ) is \\'acbd\\', and signature( s2 ) is the same.\\nTherefore, s1 and s2 are special equivalent.\\n\\n---\\n\\n**Algorithm**:\\n\\nRearrange each input string into the form of signature.\\n\\nThe **number of unique signature** is the **number of grouping** for special equivalent.\\n\\n---\\n\\n**Implementation**:\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        \\n        signature = set()\\n        \\n        # Use pair of sorted even substring and odd substring as unique key\\n        \\n        for idx, s in enumerate(A):\\n            signature.add( \\'\\'.join( sorted( s[::2] ) ) + \\'\\'.join( sorted( s[1::2] ) )  )\\n        \\n        return len( signature )\\n```\\n\\n---\\n\\nRelated challenge:\\n\\n[Leetcode #49 Group Anagrms](https://leetcode.com/problems/group-anagrams/)\\n\\n[Leetcode #242 Valid Anagram](https://leetcode.com/problems/valid-anagram/)\\n\\n[Leetcode #438 Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about hash-set: set()](https://docs.python.org/3/tutorial/datastructures.html#sets)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        \\n        signature = set()\\n        \\n        # Use pair of sorted even substring and odd substring as unique key\\n        \\n        for idx, s in enumerate(A):\\n            signature.add( \\'\\'.join( sorted( s[::2] ) ) + \\'\\'.join( sorted( s[1::2] ) )  )\\n        \\n        return len( signature )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164481,
                "title": "python-1-liner-beats-100-of-other-submissions",
                "content": "The idea is to convert all strings to some sort of canonical representation. Since all characters at even and odd position can be shuffled in any way, sorting them will produce the desired result - strings like `cba` will be converted to `abc` and `dcba` to `badc`. Having all strings converted to their canonical form, a set can be used to remove the duplicates and its length will produce the desired result.\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        return len({tuple(sorted(s[0::2]) + sorted(s[1::2])) for s in A})\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        return len({tuple(sorted(s[0::2]) + sorted(s[1::2])) for s in A})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163891,
                "title": "c-create-a-signature-for-each-string",
                "content": "We can quickly notice that by grouping odd and even position, sorting them and concatenating them, all the special - equivalent string will have the same signature. We can then use a hash set to capture the signature (which automatically de-duplicates) and we can return the hashset size.\\nThe constraints of the problem easily allow this.\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> st;\\n        for(auto &w : A) {\\n            string odd, even;\\n            for(int i=0;i<w.size();i+=2) even.push_back(w[i]);\\n            for(int i=1;i<w.size();i+=2) odd.push_back(w[i]);\\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            st.insert(even + odd);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> st;\\n        for(auto &w : A) {\\n            string odd, even;\\n            for(int i=0;i<w.size();i+=2) even.push_back(w[i]);\\n            for(int i=1;i<w.size();i+=2) odd.push_back(w[i]);\\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            st.insert(even + odd);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431332,
                "title": "c-set-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words)\\n    {    \\n        set<pair<string,string>> s;\\n        for(auto &w:words)\\n        {\\n            string p,q;\\n            for(int i=0;i<w.size();i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    p+=w[i];\\n                }\\n                else\\n                {\\n                    q+=w[i];\\n                }\\n            }\\n            sort(p.begin(),p.end());\\n            sort(q.begin(),q.end());\\n            s.insert({p,q});\\n        }\\n        return s.size();\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words)\\n    {    \\n        set<pair<string,string>> s;\\n        for(auto &w:words)\\n        {\\n            string p,q;\\n            for(int i=0;i<w.size();i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    p+=w[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 512294,
                "title": "javascript-easy-solution",
                "content": "```javascript\\n/**\\n * @param {string[]} A\\n * @return {number}\\n */\\nvar numSpecialEquivGroups = function(A) {\\n  const groupSet = new Set();\\n  A.forEach(a => groupSet.add(transform(a)));\\n  return groupSet.size;\\n};\\n\\nconst transform = S => {\\n  const even = S.split(\\'\\').filter((_, i) => i % 2 === 0);\\n  const odd = S.split(\\'\\').filter((_, i) => i % 2 === 1);\\n  even.sort();\\n  odd.sort();\\n  return `${even.join(\\'\\')}${odd.join(\\'\\')}`;\\n};\\n```\\n\\n* 36/36 cases passed (64 ms)\\n* Your runtime beats 100 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (37.5 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string[]} A\\n * @return {number}\\n */\\nvar numSpecialEquivGroups = function(A) {\\n  const groupSet = new Set();\\n  A.forEach(a => groupSet.add(transform(a)));\\n  return groupSet.size;\\n};\\n\\nconst transform = S => {\\n  const even = S.split(\\'\\').filter((_, i) => i % 2 === 0);\\n  const odd = S.split(\\'\\').filter((_, i) => i % 2 === 1);\\n  even.sort();\\n  odd.sort();\\n  return `${even.join(\\'\\')}${odd.join(\\'\\')}`;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359733,
                "title": "bug-in-leetcode-itself-check-it-out-lol",
                "content": "![image](https://assets.leetcode.com/users/ssemichev/image_1565936717.png)\\n![image](https://assets.leetcode.com/users/ssemichev/image_1565936718.png)\\nSubmission tab gives wrong answer and output 5. But Debug tab (and my IDE) has correct answer 1. \\n\\nSolution:\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] input) {\\n        int[] inx = new int[input.length];\\n        int group = 1;\\n        for(int i = 0; i < input.length; i++){\\n          if(inx[i] != 0) continue;\\n          inx[i] = group++;\\n          for(int j = i + 1; j < input.length; j++ ) {\\n            if (j != 0 && eq(input[i], input[j])) {\\n              inx[i] = group;\\n              inx[j] = group;\\n            }\\n          }\\n        }\\n        return group - 1;\\n    }\\n    \\n    private boolean eq(String a, String b){\\n        if(a.equals(b)) return true;\\n        \\n        char[] buff = b.toCharArray();\\n        for(int i = 0; i < buff.length; i++){\\n          int j = i + 2;\\n          while(j < buff.length && (i % 2 != j % 2)) j++;\\n          if(j < buff.length){\\n            if(buff[i] == a.charAt(i) && buff[j] == a.charAt(j)) continue;\\n            char t = buff[i];\\n            buff[i] = buff[j];\\n            buff[j] = t;\\n            if(a.equals(new String(buff)))\\n              return true;\\n          }\\n        }\\n        return false;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] input) {\\n        int[] inx = new int[input.length];\\n        int group = 1;\\n        for(int i = 0; i < input.length; i++){\\n          if(inx[i] != 0) continue;\\n          inx[i] = group++;\\n          for(int j = i + 1; j < input.length; j++ ) {\\n            if (j != 0 && eq(input[i], input[j])) {\\n              inx[i] = group;\\n              inx[j] = group;\\n            }\\n          }\\n        }\\n        return group - 1;\\n    }\\n    \\n    private boolean eq(String a, String b){\\n        if(a.equals(b)) return true;\\n        \\n        char[] buff = b.toCharArray();\\n        for(int i = 0; i < buff.length; i++){\\n          int j = i + 2;\\n          while(j < buff.length && (i % 2 != j % 2)) j++;\\n          if(j < buff.length){\\n            if(buff[i] == a.charAt(i) && buff[j] == a.charAt(j)) continue;\\n            char t = buff[i];\\n            buff[i] = buff[j];\\n            buff[j] = t;\\n            if(a.equals(new String(buff)))\\n              return true;\\n          }\\n        }\\n        return false;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173803,
                "title": "c-using-counting-sort-since-string-contains-english-letters",
                "content": "Sept. 23, 2018\\nIt is an easy level string algorithm. The swap of letters should be restricted to odd index or even index two groups. All letters in odd index can be swapped, likewise as even index. \\n\\n```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] A)\\n        {\\n            if (A == null)\\n                return 0;\\n\\n            var keys = new HashSet<string>(); \\n\\n            foreach(var item in A)\\n            {\\n                var countLetterEven = new int[26];\\n                var countLetterOdd  = new int[26];\\n\\n                for (int i = 0; i < item.Length; i++ )\\n                {\\n                    var current = item[i];\\n                    var isEven = i % 2 == 0;\\n                    if (isEven)\\n                    {\\n                        countLetterEven[current - \\'a\\']++;\\n                    }\\n                    else\\n                        countLetterOdd[current - \\'a\\']++;                    \\n                }\\n\\n                var key = createKey(countLetterEven, countLetterOdd);\\n                if (!keys.Contains(key))\\n                    keys.Add(key);\\n            }\\n\\n            return keys.Count; \\n        }\\n\\n        private static string createKey(int[] even, int[] odd)\\n        {\\n            var key = \"\";\\n            for(int i = 0; i < 26; i++)\\n            {\\n                key += even[i] + \" \" + odd[i] +\";\";\\n            }\\n\\n            return key; \\n        }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] A)\\n        {\\n            if (A == null)\\n                return 0;\\n\\n            var keys = new HashSet<string>(); \\n\\n            foreach(var item in A)\\n            {\\n                var countLetterEven = new int[26];\\n                var countLetterOdd  = new int[26];\\n\\n                for (int i = 0; i < item.Length; i++ )\\n                {\\n                    var current = item[i];\\n                    var isEven = i % 2 == 0;\\n                    if (isEven)\\n                    {\\n                        countLetterEven[current - \\'a\\']++;\\n                    }\\n                    else\\n                        countLetterOdd[current - \\'a\\']++;                    \\n                }\\n\\n                var key = createKey(countLetterEven, countLetterOdd);\\n                if (!keys.Contains(key))\\n                    keys.Add(key);\\n            }\\n\\n            return keys.Count; \\n        }\\n\\n        private static string createKey(int[] even, int[] odd)\\n        {\\n            var key = \"\";\\n            for(int i = 0; i < 26; i++)\\n            {\\n                key += even[i] + \" \" + odd[i] +\";\";\\n            }\\n\\n            return key; \\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162198,
                "title": "c-893-groups-of-special-equivalent-strings",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> seen; \\n        for (auto word : A) {\\n            string even, odd; \\n            for (int i = 0; i < word.size(); ++i) {\\n                if (i&1) odd.push_back(word[i]); \\n                else even.push_back(word[i]); \\n            }\\n            sort(even.begin(), even.end()); \\n            sort(odd.begin(), odd.end()); \\n            seen.insert(even+odd); \\n        }\\n        return seen.size(); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> seen; \\n        for (auto word : A) {\\n            string even, odd; \\n            for (int i = 0; i < word.size(); ++i) {\\n                if (i&1) odd.push_back(word[i]); \\n                else even.push_back(word[i]); \\n            }\\n            sort(even.begin(), even.end()); \\n            sort(odd.begin(), odd.end()); \\n            seen.insert(even+odd); \\n        }\\n        return seen.size(); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860173,
                "title": "typescript-javascript-o-n-solution-w-detailed-comments-explanation",
                "content": "Forget what the problem is asking for a second. I\\'ll dumb it down. It took me too long and I overthought way too hard.\\n*Shout out to Fisher Coder (on youtube) for explaining the problem statement. He\\'s a legendary beast.*\\n\\nThe problem is **simply** asking how many strings are distinct, given you can swap any even-indexed characters, and swap any odd-indexed characters.\\n\\nExample: if you have **\"axbycz\"** and **\"czbyax\"**, these ARE specially EQUIVALENT. here is the reasoning: for odd index, we have counts {a: 1, b: 1, c:1} in both of them, and for even index we have {x: 1, y: 1, z: 1} for both of them.\\n\\n**solution:**\\n```\\nfunction numSpecialEquivGroups(A: string[]): number {\\n    // set to keep track of unique special equivalents\\n    const set: Set<string> = new Set();\\n    // iterate thru A\\n    for (let i = 0; i < A.length; i++) {\\n        // even and odd char counts\\n        const counts = [new Uint8Array(26), new Uint8Array(26)];\\n        // iterate thru this string, and fill counts\\n        for (let j = 0; j < A[i].length; j++) {\\n            // fill count on whether even or odd (0 index is even 1 is odd)\\n            counts[j % 2][A[i].charCodeAt(j) - 97]++;\\n        }\\n        // add to set as concatenation of both counts arrays\\n        set.add(counts[0].join(\\'\\') + counts[1].join(\\'\\'));\\n    }\\n\\n    // result is just size of set (number of unique special equivalents)\\n    return set.size;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction numSpecialEquivGroups(A: string[]): number {\\n    // set to keep track of unique special equivalents\\n    const set: Set<string> = new Set();\\n    // iterate thru A\\n    for (let i = 0; i < A.length; i++) {\\n        // even and odd char counts\\n        const counts = [new Uint8Array(26), new Uint8Array(26)];\\n        // iterate thru this string, and fill counts\\n        for (let j = 0; j < A[i].length; j++) {\\n            // fill count on whether even or odd (0 index is even 1 is odd)\\n            counts[j % 2][A[i].charCodeAt(j) - 97]++;\\n        }\\n        // add to set as concatenation of both counts arrays\\n        set.add(counts[0].join(\\'\\') + counts[1].join(\\'\\'));\\n    }\\n\\n    // result is just size of set (number of unique special equivalents)\\n    return set.size;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 425999,
                "title": "java-easy-to-understand-solution",
                "content": "```\\npublic int numSpecialEquivGroups(String[] A) {\\n\\tHashSet<String> s = new HashSet<>();\\n\\tfor(String a : A) {\\n\\t\\tint[] odd = new int[26], even = new int[26];\\n\\t\\tfor(int i=0; i<a.length(); i++) {\\n\\t\\t\\tif(i%2==0)\\n\\t\\t\\t\\teven[a.charAt(i)-\\'a\\']++;\\n\\t\\t\\telse\\n\\t\\t\\t\\todd[a.charAt(i)-\\'a\\']++;\\n\\t\\t}\\n\\t\\ts.add(Arrays.toString(odd)+Arrays.toString(even));\\n\\t}\\n\\treturn s.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numSpecialEquivGroups(String[] A) {\\n\\tHashSet<String> s = new HashSet<>();\\n\\tfor(String a : A) {\\n\\t\\tint[] odd = new int[26], even = new int[26];\\n\\t\\tfor(int i=0; i<a.length(); i++) {\\n\\t\\t\\tif(i%2==0)\\n\\t\\t\\t\\teven[a.charAt(i)-\\'a\\']++;\\n\\t\\t\\telse\\n\\t\\t\\t\\todd[a.charAt(i)-\\'a\\']++;\\n\\t\\t}\\n\\t\\ts.add(Arrays.toString(odd)+Arrays.toString(even));\\n\\t}\\n\\treturn s.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2937150,
                "title": "python-3-5-lines-w-example-t-m-88-27",
                "content": "\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n                                                            #  Example: \\n        wSet = set()                                        #   words = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\n\\n        for word in words:                                  #           sorted((enu-   \\n            word = tuple(sorted((enumerate(word)),          #  word     merate word)         wSet\\n                           key = lambda x: (x[0]%2,x[1])))  #  \\u2013\\u2013\\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013         \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n            print(wSet)                                     #   abc     ((0,a),(2,c),(1,b))  {(a,c,b)}\\n            wSet.add(list(zip(*word))[1])                   #   acb     ((0,a),(2,b),(1,c))  {(a,c,b), (a,b,c)}\\n                                                            #   bac     ((0,b),(2,c),(1,a))  {(a,c,b), (a,b,c), (b,c,a)}\\n        return len(wSet)                                    #   bca     ((2,a),(0,b),(1,c))  {(a,c,b), (a,b,c), (b,c,a)}\\n                                                            #   cab     ((2,b),(0,c),(1,a))  {(a,c,b), (a,b,c), (b,c,a)}\\n                                                            #   cba     ((2,a),(0,c),(1,b))  {(a,c,b), (a,b,c), (b,c,a)}\\n```\\n[https://leetcode.com/problems/groups-of-special-equivalent-strings/submissions/863479817/](http://)\\n\\n\\nI could be wrong, but I think that time is *O*(*NlogN*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n                                                            #  Example: \\n        wSet = set()                                        #   words = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\n\\n        for word in words:                                  #           sorted((enu-   \\n            word = tuple(sorted((enumerate(word)),          #  word     merate word)         wSet\\n                           key = lambda x: (x[0]%2,x[1])))  #  \\u2013\\u2013\\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013         \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n            print(wSet)                                     #   abc     ((0,a),(2,c),(1,b))  {(a,c,b)}\\n            wSet.add(list(zip(*word))[1])                   #   acb     ((0,a),(2,b),(1,c))  {(a,c,b), (a,b,c)}\\n                                                            #   bac     ((0,b),(2,c),(1,a))  {(a,c,b), (a,b,c), (b,c,a)}\\n        return len(wSet)                                    #   bca     ((2,a),(0,b),(1,c))  {(a,c,b), (a,b,c), (b,c,a)}\\n                                                            #   cab     ((2,b),(0,c),(1,a))  {(a,c,b), (a,b,c), (b,c,a)}\\n                                                            #   cba     ((2,a),(0,c),(1,b))  {(a,c,b), (a,b,c), (b,c,a)}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791670,
                "title": "c-easy-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int numSpecialEquivGroups(vector<string>& A) {\\n    set<pair<string,string>> s;\\n    for (const auto& w : A) {\\n        pair<string,string> p;\\n        for (int i = 0; i < w.size (); ++i) {\\n            if (i % 2) p.first  += w[i];\\n            else       p.second += w[i];\\n        }\\n        sort (p.first.begin  (), p.first.end ());\\n        sort (p.second.begin (), p.second.end ());\\n        s.insert (p);\\n    }\\n    return s.size ();\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int numSpecialEquivGroups(vector<string>& A) {\\n    set<pair<string,string>> s;\\n    for (const auto& w : A) {\\n        pair<string,string> p;\\n        for (int i = 0; i < w.size (); ++i) {\\n            if (i % 2) p.first  += w[i];\\n            else       p.second += w[i];\\n        }\\n        sort (p.first.begin  (), p.first.end ());\\n        sort (p.second.begin (), p.second.end ());\\n        s.insert (p);\\n    }\\n    return s.size ();\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176722,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int n = words.size();\\n        unordered_map<string, int> um;\\n        for(string &word : words)\\n        {\\n            vector<int> even(26,0);\\n            vector<int> odd(26,0);\\n            for(int i = 0; i < word.size(); i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    even[word[i]-\\'a\\']++;\\n                }\\n                else\\n                {\\n                    odd[word[i]-\\'a\\']++;\\n                }\\n            }\\n            string str = \"\";\\n            for(int i = 0; i < 26; i++)\\n            {\\n                str += to_string(even[i]);\\n            }\\n            for(int i = 0; i < 26; i++)\\n            {\\n                str += to_string(odd[i]);\\n            }\\n            um[str]++;\\n        }\\n        return um.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int n = words.size();\\n        unordered_map<string, int> um;\\n        for(string &word : words)\\n        {\\n            vector<int> even(26,0);\\n            vector<int> odd(26,0);\\n            for(int i = 0; i < word.size(); i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    even[word[i]-\\'a\\']++;\\n                }\\n                else\\n                {\\n                    odd[word[i]-\\'a\\']++;\\n                }\\n            }\\n            string str = \"\";\\n            for(int i = 0; i < 26; i++)\\n            {\\n                str += to_string(even[i]);\\n            }\\n            for(int i = 0; i < 26; i++)\\n            {\\n                str += to_string(odd[i]);\\n            }\\n            um[str]++;\\n        }\\n        return um.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074463,
                "title": "easy-fast-python-solution",
                "content": "```class Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        dic={}\\n        for i in range(len(A)):\\n            x = \\'\\'.join(sorted(A[i][0::2]))\\n            y = \\'\\'.join(sorted(A[i][1::2]))     \\n            if (x+y) not in dic:\\n                dic[x+y]=1\\n            else:\\n                dic[x+y]+=1\\n        return len(dic)\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        dic={}",
                "codeTag": "Java"
            },
            {
                "id": 962274,
                "title": "python-3-use-defaultdict-40ms-88-5",
                "content": "\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        #\\n        helper = defaultdict(int)\\n        for string in A:\\n            key = \"\".join(sorted(string[0::2])+sorted(string[1::2]))\\n            helper[key] += 1\\n        return len(helper)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        #\\n        helper = defaultdict(int)\\n        for string in A:\\n            key = \"\".join(sorted(string[0::2])+sorted(string[1::2]))\\n            helper[key] += 1\\n        return len(helper)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765248,
                "title": "simple-cpp-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\\n        unordered_set<string>mp;\\n        for(int i=0;i<A.size();i++)\\n        {\\n        string o=\"\";\\n        string e=\"\";\\n            for(int j=0;j<A[i].size();j++)\\n            {\\n                if(j%2==0)\\n                    e+=A[i][j];\\n                else\\n                    o+=A[i][j];\\n            }\\n            sort(o.begin(),o.end());\\n            sort(e.begin(),e.end());\\n            mp.insert(e+o);\\n        }\\n        return mp.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\\n        unordered_set<string>mp;\\n        for(int i=0;i<A.size();i++)\\n        {\\n        string o=\"\";\\n        string e=\"\";\\n            for(int j=0;j<A[i].size();j++)\\n            {\\n                if(j%2==0)\\n                    e+=A[i][j];\\n                else\\n                    o+=A[i][j];\\n            }\\n            sort(o.begin(),o.end());\\n            sort(e.begin(),e.end());\\n            mp.insert(e+o);\\n        }\\n        return mp.size();\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 641006,
                "title": "python-1-liner-and-5-liner-for-readability-explained",
                "content": "Since any even index can be switched with any other even index, and the same is true for any odd index pair, as long as two words share the same multiset of even-indexed letters and the same multiset of odd-indexed letters, then they are special-equivalent.  \\n\\nThat said, we can represent any multiset by the sorted even indexed letters concatenated with the sorted odd indexed letters:\\n\\n    \\'adcb\\' and \\'cdab\\'  represented by \\'bd\\' + \\'ac\\'  = \\'bdac\\'\\n\\t\\'abdc\\' respresented by \\'bc\\' + \\'ad\\' = \\'bcad\\'\\n\\nEncode each word (using the method above) and add it to a set.  The length of the set will then be equal the number of special equivalent families in A.\\n\\n### 5 Liner (for readability)\\n\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        codes = set()\\n        for word in A:\\n            code = \\'\\'.join(sorted(word[::2])) + \\'\\'.join(sorted(word[1::2]))\\n            codes.add(code)\\n        return len(codes)\\n```\\n\\n### One Liner\\n\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len(set([\\'\\'.join(sorted(word[::2])) + \\'\\'.join(sorted(word[1::2])) for word in A]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        codes = set()\\n        for word in A:\\n            code = \\'\\'.join(sorted(word[::2])) + \\'\\'.join(sorted(word[1::2]))\\n            codes.add(code)\\n        return len(codes)\\n```\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len(set([\\'\\'.join(sorted(word[::2])) + \\'\\'.join(sorted(word[1::2])) for word in A]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474747,
                "title": "runtime-8-ms-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_map<string, int> count;\\n        for(auto s : A)\\n        {\\n            string even = \"\", odd = \"\";\\n            for(int i = 0; i < s.size(); i++)\\n            {\\n                if(i % 2 == 0)\\n                    even += s[i];\\n                else odd += s[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            string key = even + odd;\\n            count[key]++;\\n        }\\n        return count.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_map<string, int> count;\\n        for(auto s : A)\\n        {\\n            string even = \"\", odd = \"\";\\n            for(int i = 0; i < s.size(); i++)\\n            {\\n                if(i % 2 == 0)\\n                    even += s[i];\\n                else odd += s[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            string key = even + odd;\\n            count[key]++;\\n        }\\n        return count.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377831,
                "title": "java-2ms-solution-with-hashset-with-explanation",
                "content": "/*\\nJava Solution Beat 100% runtime and 100% memory\\n\\nit is kind of anagram problem.\\ntwo strings can only be Special-Equivalent when BOTH their odd letters  AND even letters are anagrams.\\n\\nso based on above logic, \\n1. we build hash value for each string, we sort odd position letters, even position letters of each string , since string is short, here only use simple O(n^2) compare logic to sort them.\\n2. the odd and even sorted string will be the hash of the string.\\n3. we add the hash into HashSet.  (HashSet.add(value) will return true if it is added, and return falsle is already has the value  in HashSet ), count how many values we added.\\n4. return the count.\\n*/\\n\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        HashSet<String> set = new HashSet<>();\\n        int result = 0;\\n        for(String str: A){            \\n            if(set.add(getHashBySwap(str.toCharArray()))) {\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private String getHashBySwap(char[] chars){\\n        for(int i=0; i<chars.length;i++){            \\n            for(int j=i+2;j<chars.length;){\\n                if(chars[i] > chars[j]) {\\n                    char temp = chars[j];\\n                    chars[j] = chars[i];  \\n                    chars[i] = temp;\\n                }\\n                j+=2;\\n            }\\n        }\\n        \\n        return String.valueOf(chars);        \\n    }   \\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        HashSet<String> set = new HashSet<>();\\n        int result = 0;\\n        for(String str: A){            \\n            if(set.add(getHashBySwap(str.toCharArray()))) {\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private String getHashBySwap(char[] chars){\\n        for(int i=0; i<chars.length;i++){            \\n            for(int j=i+2;j<chars.length;){\\n                if(chars[i] > chars[j]) {\\n                    char temp = chars[j];\\n                    chars[j] = chars[i];  \\n                    chars[i] = temp;\\n                }\\n                j+=2;\\n            }\\n        }\\n        \\n        return String.valueOf(chars);        \\n    }   \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345036,
                "title": "python-solution",
                "content": "\\n```\\ndef numSpecialEquivGroups(self, A):\\n\\t\"\"\"\\n\\t:type A: List[str]\\n\\t:rtype: int\\n\\t\"\"\"\\n\\tres = set()\\n\\tfor s in A:\\n\\t\\ts = \\'\\'.join(sorted(s[::2]) + sorted(s[1::2]))\\n\\t\\tres.add(s)\\n\\treturn len(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef numSpecialEquivGroups(self, A):\\n\\t\"\"\"\\n\\t:type A: List[str]\\n\\t:rtype: int\\n\\t\"\"\"\\n\\tres = set()\\n\\tfor s in A:\\n\\t\\ts = \\'\\'.join(sorted(s[::2]) + sorted(s[1::2]))\\n\\t\\tres.add(s)\\n\\treturn len(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 271486,
                "title": "java-6ms-solution-easy-to-understand-with-explanation",
                "content": "The basic idea is putting the signature of each string to a set, then the size of set is the number of groups.\\nSince each string only contains lowercase letters, we can use two arrays ```odd[26]``` and ```even[26]``` to represents the frequency of 26 lowercase letters on odd place and even place of a string repectively. \\nThe signature of a string is apparently ```Arrays.toString(odd) + Arrays.toString(even)```.\\nThe code is as following:\\n```\\npublic int numSpecialEquivGroups(String[] A) {\\n\\tSet<String> group = new HashSet<String>();\\n\\tfor(int i = 0; i < A.length; i++) \\n\\t\\tgroup.add(getSignature(A[i]));\\n\\treturn group.size();\\n}\\n\\npublic String getSignature(String s) {\\n\\tint odd[] = new int[26];\\n\\tint even[] = new int[26];\\n\\tfor(int i = 0; i < s.length(); i += 2) \\n\\t\\teven[s.charAt(i) - \\'a\\']++;\\n\\tfor(int i = 1; i < s.length(); i += 2)\\n\\t\\todd[s.charAt(i) - \\'a\\']++;\\n\\tStringBuilder sb = new StringBuilder(\"\");\\n\\tfor(int i = 0; i < 26; i++)\\n\\t\\tsb.append(odd[i]);\\n\\tfor(int i = 0; i < 26; i++)\\n\\t\\tsb.append(even[i]);\\n\\treturn sb.toString();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```odd[26]```\n```even[26]```\n```Arrays.toString(odd) + Arrays.toString(even)```\n```\\npublic int numSpecialEquivGroups(String[] A) {\\n\\tSet<String> group = new HashSet<String>();\\n\\tfor(int i = 0; i < A.length; i++) \\n\\t\\tgroup.add(getSignature(A[i]));\\n\\treturn group.size();\\n}\\n\\npublic String getSignature(String s) {\\n\\tint odd[] = new int[26];\\n\\tint even[] = new int[26];\\n\\tfor(int i = 0; i < s.length(); i += 2) \\n\\t\\teven[s.charAt(i) - \\'a\\']++;\\n\\tfor(int i = 1; i < s.length(); i += 2)\\n\\t\\todd[s.charAt(i) - \\'a\\']++;\\n\\tStringBuilder sb = new StringBuilder(\"\");\\n\\tfor(int i = 0; i < 26; i++)\\n\\t\\tsb.append(odd[i]);\\n\\tfor(int i = 0; i < 26; i++)\\n\\t\\tsb.append(even[i]);\\n\\treturn sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 192733,
                "title": "my-c-solution",
                "content": "s1 is the substring containing only characters on odd position\\ns2 is the substring containing only characters on even position\\nsort s1 and s2, use s1 + s2 as the key of that string\\ncompare the key of each string\\n```\\n#include <unordered_set>\\n#include <algorithm>\\nusing std::unordered_set;\\nclass Solution {\\npublic:\\n    string key(string s)\\n    {\\n        string s1 = \"\";\\n        string s2 = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(i % 2)\\n                s1 += s[i];\\n            else\\n                s2 += s[i];\\n        }\\n        std::sort(s1.begin(),s1.end());\\n        std::sort(s2.begin(),s2.end());\\n        return s1 + s2;\\n    }\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> sset;\\n        for(string s : A)\\n            sset.insert(key(s));\\n        return sset.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <unordered_set>\\n#include <algorithm>\\nusing std::unordered_set;\\nclass Solution {\\npublic:\\n    string key(string s)\\n    {\\n        string s1 = \"\";\\n        string s2 = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(i % 2)\\n                s1 += s[i];\\n            else\\n                s2 += s[i];\\n        }\\n        std::sort(s1.begin(),s1.end());\\n        std::sort(s2.begin(),s2.end());\\n        return s1 + s2;\\n    }\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> sset;\\n        for(string s : A)\\n            sset.insert(key(s));\\n        return sset.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3227290,
                "title": "python-solution-run-time-77",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        lst=[]\\n        for i in words:\\n            evn=\\'\\'\\n            odd=\\'\\'\\n            for j in range(len(i)):\\n                if j%2==0:\\n                    evn+=i[j]\\n                else:\\n                    odd+=i[j]\\n            str=sorted(evn)+sorted(odd)\\n            lst.append(\"\".join(str))\\n        return len(Counter(lst))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        lst=[]\\n        for i in words:\\n            evn=\\'\\'\\n            odd=\\'\\'\\n            for j in range(len(i)):\\n                if j%2==0:\\n                    evn+=i[j]\\n                else:\\n                    odd+=i[j]\\n            str=sorted(evn)+sorted(odd)\\n            lst.append(\"\".join(str))\\n        return len(Counter(lst))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141695,
                "title": "c-solution-using-set-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<string>s;    // declare set of strings\\n        for(auto i:words){   \\n            string q=\"\";\\n            string w=\"\";\\n            for(int j=0;j<i.size();j++){\\n                if(j%2==0){\\n                    q+=i[j]; // form a string of even indices \\n                }\\n                else {\\n                    w+=i[j]; //form a string of odd indices \\n                }\\n            }\\n            sort(q.begin(),q.end()); // sort both strings separately\\n            sort(w.begin(),w.end());\\n            q+=w; // add them to form single string\\n            s.insert(q); // insert the added string to set \\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<string>s;    // declare set of strings\\n        for(auto i:words){   \\n            string q=\"\";\\n            string w=\"\";\\n            for(int j=0;j<i.size();j++){\\n                if(j%2==0){\\n                    q+=i[j]; // form a string of even indices \\n                }\\n                else {\\n                    w+=i[j]; //form a string of odd indices \\n                }\\n            }\\n            sort(q.begin(),q.end()); // sort both strings separately\\n            sort(w.begin(),w.end());\\n            q+=w; // add them to form single string\\n            s.insert(q); // insert the added string to set \\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249225,
                "title": "c-sol-using-set",
                "content": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> s;\\n        for(const auto& w : words){\\n            string odd, even;\\n            for(int i=0;i<w.length();i++){\\n                \\n                if(i%2!=0) odd += w[i];\\n                even += w[i];}\\n                sort(even.begin(), even.end());\\n                sort(odd.begin(), odd.end());\\n                s.insert(even+odd);\\n            \\n        }\\n        return s.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> s;\\n        for(const auto& w : words){\\n            string odd, even;\\n            for(int i=0;i<w.length();i++){\\n                \\n                if(i%2!=0) odd += w[i];\\n                even += w[i];}",
                "codeTag": "Java"
            },
            {
                "id": 1072832,
                "title": "easy-fast-understandable-c-solution",
                "content": "UPVOTE IF THE SOLUTION MAKES SENSE TO YOU\\n-> Solution to this problem as per this approach points to simple principle of dividing the string in to two parts - \\n - One string with characters from odd indexes.\\n - One string with characters from even indexes.\\n \\n Once we have these two individual parts, sort specific parts, combine them in to one and check for its existence in the hash map. If found increase frequency in hashmap else insert in hashmap.\\n\\n- Size of hashmap gives us the result to the problem.\\n- -> Alternatively we can just use a set since we just need number of unique strings.\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        int l = A.size();\\n\\t\\tunordered_map<string, int> map;               //  initialize hashmap\\n        for(int i=0;i<l;i++){\\n\\t\\t\\tstring cur = A[i];                                        // take current string from array\\n            int slen = cur.length();\\n            string os = \"\";\\n            string es = \"\";\\n            for(int j=0;j<slen;j++){\\n                if(j%2==0){                                         // check index is even or odd\\n                    os+=cur[j];\\n                }else{\\n                    es+=cur[j];\\n                }\\n            }\\n            sort(os.begin(),os.end());                       // sort by parts\\n            sort(es.begin(),es.end());\\n            cur = os+es;\\n            if(map.count(cur)>0){\\n                map[cur]+=1;\\n            }else{\\n                map[cur]=1;\\n            }\\n        }\\n        return map.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        int l = A.size();\\n\\t\\tunordered_map<string, int> map;               //  initialize hashmap\\n        for(int i=0;i<l;i++){\\n\\t\\t\\tstring cur = A[i];                                        // take current string from array\\n            int slen = cur.length();\\n            string os = \"\";\\n            string es = \"\";\\n            for(int j=0;j<slen;j++){\\n                if(j%2==0){                                         // check index is even or odd\\n                    os+=cur[j];\\n                }else{\\n                    es+=cur[j];\\n                }\\n            }\\n            sort(os.begin(),os.end());                       // sort by parts\\n            sort(es.begin(),es.end());\\n            cur = os+es;\\n            if(map.count(cur)>0){\\n                map[cur]+=1;\\n            }else{\\n                map[cur]=1;\\n            }\\n        }\\n        return map.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069262,
                "title": "python3-one-liner-solution-faster-than-69",
                "content": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len({\\'\\'.join(sorted(a[::2]) + sorted(a[1::2])) for a in A})\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len({\\'\\'.join(sorted(a[::2]) + sorted(a[1::2])) for a in A})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717549,
                "title": "c-4-ms-without-sorting-beats-100-time-99-space",
                "content": "In this problem, it is understood that for a string if we maintain 2 hashsets for count of characters in odd and even places, and if both these hashsets match (corresponding) for 2 given strings, then both the strings can be grouped together i.e. are equivalent.\\n\\nBut to maintain a set of hashsets is a tedious job.\\n\\nSo to overcome that we maintain a unique identifier for these strings.( Example - we could have taken the sum of character values)\\n\\nBut then a simple sum wouldn\\'t give us a unique identifier. Eg -  \\'abad\\' and \\'acac\\' would map to same values i.e (0+0,1+3) = (0+0,2+2) i.e. (0,4)\\n\\nSo we look for a solution where sum of any 2 characters should not be equal to any other 2 characters.\\n\\nHence instead of labelling the characters from 0 to 25, we label them from 1 to 2^25.\\n```\\nint numSpecialEquivGroups(vector<string>& A) {\\n        set<pair<long long, long long>> s;\\n        int arr[26];\\n        arr[0] = 1;\\n        for(int i=1;i<26;i++)\\n            arr[i] = 2*arr[i-1];\\n        for(int i=0;i<A.size();i++)\\n        {\\n            long long a = 0;\\n            long long b = 0;\\n            for(int j=0;j<A[i].length();j++)\\n            {\\n                if(j%2==0)\\n                    a += arr[A[i][j]-\\'a\\'];\\n                else\\n                    b += arr[A[i][j]-\\'a\\'];\\n            }\\n            s.insert(make_pair(a,b));\\n        }\\n        return s.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint numSpecialEquivGroups(vector<string>& A) {\\n        set<pair<long long, long long>> s;\\n        int arr[26];\\n        arr[0] = 1;\\n        for(int i=1;i<26;i++)\\n            arr[i] = 2*arr[i-1];\\n        for(int i=0;i<A.size();i++)\\n        {\\n            long long a = 0;\\n            long long b = 0;\\n            for(int j=0;j<A[i].length();j++)\\n            {\\n                if(j%2==0)\\n                    a += arr[A[i][j]-\\'a\\'];\\n                else\\n                    b += arr[A[i][j]-\\'a\\'];\\n            }\\n            s.insert(make_pair(a,b));\\n        }\\n        return s.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 702121,
                "title": "ruby-solution-represent-word-as-array-of-52-elements-with-2-histograms-in-it",
                "content": "#### Leetcode: 893. Groups of Special-Equivalent Strings.\\n\\n\\n\\n##### Simplified approach.\\n\\n`thnx @quantumlexa`  \\n\\nTwo strings are special equivalent if their histograms for even and odd indices are equal. Histogram for a word can be represented as 52 elments array, 26 for even 26 for odd symbols. Array mapped from array of words to array of histograms. Then make array contain only uniq values and return it\\'s size.\\n\\nRuby code: \\n```Ruby\\n# Leetcode: 893. Groups of Special-Equivalent Strings.\\n# https://leetcode.com/problems/groups-of-special-equivalent-strings/\\n# thnx @quantumlexa\\n# Runtime: 92 ms, faster than 10.00% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# Memory Usage: 10.3 MB, less than 66.67% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# @param {String[]} a\\n# @return {Integer}\\ndef num_special_equiv_groups(arr)\\n    arr.map!{|x|\\n        h = Array.new(52,0)\\n        (0...x.size).each do |i|\\n            h[26*(i%2) + x[i].ord - ?a.ord] += 1\\n        end\\n        h\\n    }.uniq.size\\nend\\n```\\n\\n##### Initial accepted approach.\\n\\nTwo strings are special equivalent if their histograms for even indexed chars and odd indexed chars are equal. Because there are only 26 different chars in this task, the both histograms could be represented as array of 52 elements. First map array of strings to array of histograms. Than create array name used to mark words that already in groups, and compare all words with each other by two loops external and internal one. External one iterates over all indexes, and internal start iteration from index after external one. Skip indexes already in groups for both arrays. When pointing on new index in external array if it is not used new group is started, during internal loop mark all words in this group as used. So on next iteration of external loop indices of this group will be skipped.\\n\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 893. Groups of Special-Equivalent Strings.\\n# https://leetcode.com/problems/groups-of-special-equivalent-strings/\\n# Runtime: 260 ms, faster than 10.00% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# Memory Usage: 10.1 MB, less than 66.67% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# @param {String[]} a\\n# @return {Integer}\\ndef num_special_equiv_groups(arr)\\n    arr.map!{|x|\\n        h = Array.new(52,0)\\n        (0...x.size).each do |i|\\n            h[26*(i%2) + x[i].ord - ?a.ord] += 1\\n        end\\n        h\\n    }\\n    groups = 0\\n    used = Array.new(arr.size,false)\\n    (0...arr.size).each do |i|\\n        next if used[i]\\n        used[i] = true\\n        groups += 1\\n        (i+1...arr.size).each do |j|\\n            next if used[j]\\n            used[j] = true if arr[i] == arr[j] \\n        end\\n    end\\n    groups\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 893. Groups of Special-Equivalent Strings.\\n# https://leetcode.com/problems/groups-of-special-equivalent-strings/\\n# thnx @quantumlexa\\n# Runtime: 92 ms, faster than 10.00% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# Memory Usage: 10.3 MB, less than 66.67% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# @param {String[]} a\\n# @return {Integer}\\ndef num_special_equiv_groups(arr)\\n    arr.map!{|x|\\n        h = Array.new(52,0)\\n        (0...x.size).each do |i|\\n            h[26*(i%2) + x[i].ord - ?a.ord] += 1\\n        end\\n        h\\n    }.uniq.size\\nend\\n```\n```Ruby\\n# Leetcode: 893. Groups of Special-Equivalent Strings.\\n# https://leetcode.com/problems/groups-of-special-equivalent-strings/\\n# Runtime: 260 ms, faster than 10.00% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# Memory Usage: 10.1 MB, less than 66.67% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# @param {String[]} a\\n# @return {Integer}\\ndef num_special_equiv_groups(arr)\\n    arr.map!{|x|\\n        h = Array.new(52,0)\\n        (0...x.size).each do |i|\\n            h[26*(i%2) + x[i].ord - ?a.ord] += 1\\n        end\\n        h\\n    }\\n    groups = 0\\n    used = Array.new(arr.size,false)\\n    (0...arr.size).each do |i|\\n        next if used[i]\\n        used[i] = true\\n        groups += 1\\n        (i+1...arr.size).each do |j|\\n            next if used[j]\\n            used[j] = true if arr[i] == arr[j] \\n        end\\n    end\\n    groups\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 574377,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        l=[]\\n        for s in A:\\n            even=\"\"\\n            odd=\"\"\\n            for i in range(len(s)):\\n                if i%2!=0:\\n                    odd+=s[i]\\n                    \\n                else:\\n                    even+=s[i]\\n                    \\n            odd = \\'\\'.join(sorted(odd))\\n            even = \\'\\'.join(sorted(even)) \\n            # odd=sorted(odd)\\n            # even=sorted(even)\\n            \\n            l.append(str(odd)+str(even))\\n            \\n        # print(l)    \\n            \\n        return len(set(l))     \\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        l=[]\\n        for s in A:\\n            even=\"\"\\n            odd=\"\"\\n            for i in range(len(s)):\\n                if i%2!=0:\\n                    odd+=s[i]\\n                    \\n                else:\\n                    even+=s[i]\\n                    \\n            odd = \\'\\'.join(sorted(odd))\\n            even = \\'\\'.join(sorted(even)) \\n            # odd=sorted(odd)\\n            # even=sorted(even)\\n            \\n            l.append(str(odd)+str(even))\\n            \\n        # print(l)    \\n            \\n        return len(set(l))     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 512298,
                "title": "python3-group-strings-by-sorting-characters-at-even-odd-indices",
                "content": "Algorithm:\\nHere, we need a way to group strings so that each group is a special-equivalent group. Counting is one way as suggested by the Solution. Here, I\\'ve used sorting-based approach. For a given string, sort the characters at even and odd indices respectively and join them. \\n\\n(36ms, 96.54%): \\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        fn = lambda s: \"\".join(sorted(s[::2]) + sorted(s[1::2]))\\n        return len(set(fn(s) for s in A))\\n```\\n\\nAnalysis:\\nTime complexity `O(NlogN)`\\nSpace complexity `O(N)`\\n\\nComment: Even though the time complexity is `O(NlogN)` in this approach, given `1 <= A[i].length <= 20`, it is still competative in terms of performance.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        fn = lambda s: \"\".join(sorted(s[::2]) + sorted(s[1::2]))\\n        return len(set(fn(s) for s in A))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508798,
                "title": "go-0ms-map-solution",
                "content": "```go\\nfunc numSpecialEquivGroups(A []string) int {\\n    m := map[[52]int]interface{}{}\\n    for _, s := range A {\\n        array := [52]int{}\\n        for i, c := range s {\\n            if i % 2 == 0 {\\n                array[c-\\'a\\']++\\n            } else {\\n                array[c-\\'a\\'+26]++\\n            }\\n        }\\n        m[array] = nil\\n    }\\n    return len(m)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc numSpecialEquivGroups(A []string) int {\\n    m := map[[52]int]interface{}{}\\n    for _, s := range A {\\n        array := [52]int{}\\n        for i, c := range s {\\n            if i % 2 == 0 {\\n                array[c-\\'a\\']++\\n            } else {\\n                array[c-\\'a\\'+26]++\\n            }\\n        }\\n        m[array] = nil\\n    }\\n    return len(m)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 289642,
                "title": "java-4ms-customized-hashing-algorithm-easy-to-understand",
                "content": "customized a hashing algorithm that:\\n1.split the string into 2 parts by index , the odd part and the even part\\n2.count each char (a ~ z) in each part\\n3.combine the count result into a hashing string\\n4.just add hashing string into a set\\n5.return the size of this set\\n```\\nclass Solution {\\n    \\n    private String hash(String a){\\n        char[][] count = new char[2][26];\\n        \\n        Arrays.fill(count[0],\\'a\\');\\n        Arrays.fill(count[1],\\'a\\');  \\n        \\n        int index =0;\\n        \\n        for(char c : a.toCharArray()){\\n            count[index%2][c-\\'a\\']++;\\n            index++;\\n        }\\n       return (new String(count[0]))+\"_\"+(new String(count[1]));\\n    }\\n    \\n    public int numSpecialEquivGroups(String[] A) {\\n        HashSet<String> set = new HashSet<>();\\n        for(String aString: A){\\n            set.add(hash(aString));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private String hash(String a){\\n        char[][] count = new char[2][26];\\n        \\n        Arrays.fill(count[0],\\'a\\');\\n        Arrays.fill(count[1],\\'a\\');  \\n        \\n        int index =0;\\n        \\n        for(char c : a.toCharArray()){\\n            count[index%2][c-\\'a\\']++;\\n            index++;\\n        }\\n       return (new String(count[0]))+\"_\"+(new String(count[1]));\\n    }\\n    \\n    public int numSpecialEquivGroups(String[] A) {\\n        HashSet<String> set = new HashSet<>();\\n        for(String aString: A){\\n            set.add(hash(aString));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287734,
                "title": "python-easy-to-understand-1-liner-other-faster-solution",
                "content": "In the one liner, you just return the length of the set of tuples. Each tuple contain (sorted letters of even indexed letters, sorted letters of odd indexed letters). This should be O(N*klogk), with k being the length of each word.\\n\\n`return len(set(tuple(sorted(word[::2])+sorted(word[1::2])) for word in A))`\\n\\nThis is the second solution, which is technically O(N*k), because each tup can only be length of 52, no matter how long k or N is. \\n\\nThey both run in 36 ms though, so a great example of when big O is not super helpful. \\n\\n```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        uniqueSet = set()\\n        for word in A:\\n            tup = [0]*52\\n            for i in range(len(word)):\\n                tup[(ord(word[i])-ord(\\'a\\')) + 26*(i %2)] += 1 \\n            uniqueSet.add(tuple(tup))\\n        return len(uniqueSet)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        uniqueSet = set()\\n        for word in A:\\n            tup = [0]*52\\n            for i in range(len(word)):\\n                tup[(ord(word[i])-ord(\\'a\\')) + 26*(i %2)] += 1 \\n            uniqueSet.add(tuple(tup))\\n        return len(uniqueSet)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190844,
                "title": "python3-one-liner",
                "content": "```\\n    def numSpecialEquivGroups(self, A):\\n        return len({\\'\\'.join(sorted(word[::2]))+\\'\\'.join(sorted(word[1::2])) for word in A})\\n```\\nuses letters at even positions, sorted, and letters at odd positions, also sorted, and combines them into a single string used as they key for a set, then returns the length of that set, e.g. the number of different unique keys. Each keys is a group.",
                "solutionTags": [],
                "code": "```\\n    def numSpecialEquivGroups(self, A):\\n        return len({\\'\\'.join(sorted(word[::2]))+\\'\\'.join(sorted(word[1::2])) for word in A})\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 169447,
                "title": "possible-javascript-solution-with-map-and-sort",
                "content": "```\\nvar numSpecialEquivGroups = function(A) {\\n    var odd;\\n    var even;\\n    var key;\\n    var count = 0;\\n    var map = Object.create(null);\\n    for (var i = 0; i < A.length; i++) {\\n        odd = [];\\n        even = [];\\n        for (var j = 0; j < A[i].length; j++) {\\n            if (j % 2 === 0) {\\n                even.push(A[i][j]);\\n            } else {\\n                odd.push(A[i][j]);\\n            }\\n        }\\n        \\n        even.sort();\\n        odd.sort();\\n        \\n        key = even.join(\"\") + odd.join(\"\");\\n        if (!map[key]) {\\n            map[key] = true;\\n            count++;\\n        }\\n    }\\n        \\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numSpecialEquivGroups = function(A) {\\n    var odd;\\n    var even;\\n    var key;\\n    var count = 0;\\n    var map = Object.create(null);\\n    for (var i = 0; i < A.length; i++) {\\n        odd = [];\\n        even = [];\\n        for (var j = 0; j < A[i].length; j++) {\\n            if (j % 2 === 0) {\\n                even.push(A[i][j]);\\n            } else {\\n                odd.push(A[i][j]);\\n            }\\n        }\\n        \\n        even.sort();\\n        odd.sort();\\n        \\n        key = even.join(\"\") + odd.join(\"\");\\n        if (!map[key]) {\\n            map[key] = true;\\n            count++;\\n        }\\n    }\\n        \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164161,
                "title": "c-solution-beats-100",
                "content": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        set<string> s;\\n        \\n        for (auto &a : A) {\\n            string s1;\\n            string s2;\\n            for (int i = 0; i < a.size(); i++) {\\n                if (i % 2 == 0)\\n                    s1 += a[i];\\n                else\\n                    s2 += a[i];\\n            }\\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            s.insert(s1 + s2);\\n        }\\n            \\n        return s.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        set<string> s;\\n        \\n        for (auto &a : A) {\\n            string s1;\\n            string s2;\\n            for (int i = 0; i < a.size(); i++) {\\n                if (i % 2 == 0)\\n                    s1 += a[i];\\n                else\\n                    s2 += a[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3888784,
                "title": "set-easy-c-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter **sorting** the **even and odd Position characters** of a string put it into a **unordered set** and finally return the **size** of the set.\\n\\n# Complexity\\n- Time complexity:O(N * 20 * 10 * Log(10))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        unordered_set<string> st;\\n        for(int i = 0;i<w.size();i++)\\n        {\\n            string even = \"\",odd = \"\";\\n            for(int j = 0;j<w[i].size();j++)\\n            {\\n                if(j%2) odd+=w[i][j];\\n                else even+=w[i][j];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n            st.insert(even+odd);\\n        }\\n        return st.size();\\n        \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/a09140aa-537b-4890-9c3c-1f7ab2a60bab_1691642025.638834.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        unordered_set<string> st;\\n        for(int i = 0;i<w.size();i++)\\n        {\\n            string even = \"\",odd = \"\";\\n            for(int j = 0;j<w[i].size();j++)\\n            {\\n                if(j%2) odd+=w[i][j];\\n                else even+=w[i][j];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n            st.insert(even+odd);\\n        }\\n        return st.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511728,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> st;\\n        for (auto& w : words) {\\n            string odd, even;\\n            for (int i = 0; i < w.size(); i++) {\\n                if (i % 2) even += w[i];\\n                else odd += w[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            st.insert(even + odd);\\n        }\\n        return st.size();\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        res = set()\\n        for s in A:\\n            sort_odd_even = \\'\\'.join(sorted(s[1::2]) + sorted(s[::2]))\\n            res.add(sort_odd_even)\\n        return len(res)\\n```\\n\\n```Java []\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<Integer> uniques = new HashSet<>();\\n        for (String word : words) uniques.add(customHash(word));\\n        return uniques.size();\\n    }\\n    private int customHash(String word) {\\n        int[] evenFreqs = new int[26], oddFreqs = new int[26];\\n        byte[] chars = word.getBytes();\\n\\n        int n = chars.length;\\n        for (int i = 0, limit = n / 2 * 2; i < limit; i += 2) {\\n            ++evenFreqs[chars[i] - \\'a\\'];\\n            ++oddFreqs[chars[i + 1] - \\'a\\'];\\n        }\\n        if (n % 2 == 1) ++evenFreqs[chars[n - 1] - \\'a\\'];\\n        int acc = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            acc = 31 * acc + evenFreqs[i];\\n            acc = 31 * acc + oddFreqs[i];\\n        }\\n        return acc;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> st;\\n        for (auto& w : words) {\\n            string odd, even;\\n            for (int i = 0; i < w.size(); i++) {\\n                if (i % 2) even += w[i];\\n                else odd += w[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            st.insert(even + odd);\\n        }\\n        return st.size();\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        res = set()\\n        for s in A:\\n            sort_odd_even = \\'\\'.join(sorted(s[1::2]) + sorted(s[::2]))\\n            res.add(sort_odd_even)\\n        return len(res)\\n```\n```Java []\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<Integer> uniques = new HashSet<>();\\n        for (String word : words) uniques.add(customHash(word));\\n        return uniques.size();\\n    }\\n    private int customHash(String word) {\\n        int[] evenFreqs = new int[26], oddFreqs = new int[26];\\n        byte[] chars = word.getBytes();\\n\\n        int n = chars.length;\\n        for (int i = 0, limit = n / 2 * 2; i < limit; i += 2) {\\n            ++evenFreqs[chars[i] - \\'a\\'];\\n            ++oddFreqs[chars[i + 1] - \\'a\\'];\\n        }\\n        if (n % 2 == 1) ++evenFreqs[chars[n - 1] - \\'a\\'];\\n        int acc = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            acc = 31 * acc + evenFreqs[i];\\n            acc = 31 * acc + oddFreqs[i];\\n        }\\n        return acc;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183359,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n       HashSet<String> h=new HashSet<>();\\n       for(String str:words){\\n           int[] odd=new int[26];\\n           int [] even=new int[26];\\n           for(int i=0;i<str.length();i++){\\n               if(i%2==0){\\n                   even[str.charAt(i)-\\'a\\']++;\\n               }else{\\n                   odd[str.charAt(i)-\\'a\\']++;\\n               }}\\n               String key=Arrays.toString(odd)+Arrays.toString(even);\\n               h.add(key);\\n           \\n       }\\n       return h.size(); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n       HashSet<String> h=new HashSet<>();\\n       for(String str:words){\\n           int[] odd=new int[26];\\n           int [] even=new int[26];\\n           for(int i=0;i<str.length();i++){\\n               if(i%2==0){\\n                   even[str.charAt(i)-\\'a\\']++;\\n               }else{\\n                   odd[str.charAt(i)-\\'a\\']++;\\n               }}\\n               String key=Arrays.toString(odd)+Arrays.toString(even);\\n               h.add(key);\\n           \\n       }\\n       return h.size(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117083,
                "title": "pyton3-easy-to-understand-solution",
                "content": "# Approach\\nSort the odd indices and even indices of the word seperately. Then combine those 2 to get the key value which is the same for special equivalent strings.\\n\\n\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        d = defaultdict(list)\\n        for word in words:\\n            odd , even = \"\",\\'\\'\\n            for idx,char in enumerate(word):\\n                if idx%2 == 0:\\n                    even += char\\n                else:\\n                    odd+= char\\n\\n            odd = sorted(odd)\\n            even = sorted(even)\\n            final = \"\".join(odd+even)\\n            \\n            d[final].append(word)\\n\\n        \\n        return len(d.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        d = defaultdict(list)\\n        for word in words:\\n            odd , even = \"\",\\'\\'\\n            for idx,char in enumerate(word):\\n                if idx%2 == 0:\\n                    even += char\\n                else:\\n                    odd+= char\\n\\n            odd = sorted(odd)\\n            even = sorted(even)\\n            final = \"\".join(odd+even)\\n            \\n            d[final].append(word)\\n\\n        \\n        return len(d.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008213,
                "title": "general-approach",
                "content": "# Intuition\\nOdd index characters should be same and even index characters should be same for 2 different strings\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2*(20+20log20)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        int n=a.size();\\n        vector<bool>check(n,false);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(check[i]) continue;\\n            string odda=\"\";\\n            string evena=\"\";\\n            for(int k=0;k<a[i].size();k++){\\n                if(k%2) odda+=a[i][k];\\n                else evena+=a[i][k];\\n            }\\n            sort(begin(odda),end(odda));\\n            sort(begin(evena),end(evena));\\n            ans++;\\n            check[i]=true;\\n            for(int j=i+1;j<n;j++){\\n                if(check[j]) continue;\\n                string oddb=\"\";\\n                string evenb=\"\";\\n                for(int k=0;k<a[i].size();k++){\\n                    if(k%2) oddb+=a[j][k];\\n                    else evenb+=a[j][k];\\n                }\\n                sort(begin(oddb),end(oddb));\\n                sort(begin(evenb),end(evenb));\\n                if(odda==oddb&&evena==evenb){\\n                    check[j]=true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        int n=a.size();\\n        vector<bool>check(n,false);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(check[i]) continue;\\n            string odda=\"\";\\n            string evena=\"\";\\n            for(int k=0;k<a[i].size();k++){\\n                if(k%2) odda+=a[i][k];\\n                else evena+=a[i][k];\\n            }\\n            sort(begin(odda),end(odda));\\n            sort(begin(evena),end(evena));\\n            ans++;\\n            check[i]=true;\\n            for(int j=i+1;j<n;j++){\\n                if(check[j]) continue;\\n                string oddb=\"\";\\n                string evenb=\"\";\\n                for(int k=0;k<a[i].size();k++){\\n                    if(k%2) oddb+=a[j][k];\\n                    else evenb+=a[j][k];\\n                }\\n                sort(begin(oddb),end(oddb));\\n                sort(begin(evenb),end(evenb));\\n                if(odda==oddb&&evena==evenb){\\n                    check[j]=true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931040,
                "title": "java-92-time-94-memory-solution",
                "content": "# Approach\\n1. To define groups I need to find smth common between strings, which belong to one group. So, I create 2 arrays with size of 26 (alph -> alphabet). Inside findAlphabet() I go through evenly indexed letters and increment the relevant index in the first alph array. The same applied to letters with odd indices.\\n2. Then I will use String as a key. For that I concatenate all numbers from both alph arrays. Then I use these strings to define uniqueness and put into the set.\\n3. Finally, just return the size of that set.\\n\\nCheers! \\n\\n# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        if (words.length == 1) return 1;\\n        Set<String> set = new HashSet<>();\\n        for (int i = 0; i < words.length; i++) {\\n            set.add(findAlphabet(words[i]));\\n        }\\n        return set.size();\\n    }\\n\\n    private static String findAlphabet(String word) {\\n        byte[][] alph = new byte[2][26];\\n        for (int i = 0; i < word.length(); i+=2) {\\n            alph[0][word.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 1; i < word.length(); i+=2) {\\n            alph[1][word.charAt(i) - \\'a\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++) {\\n            sb.append(alph[0][i]);\\n            sb.append(alph[1][i]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        if (words.length == 1) return 1;\\n        Set<String> set = new HashSet<>();\\n        for (int i = 0; i < words.length; i++) {\\n            set.add(findAlphabet(words[i]));\\n        }\\n        return set.size();\\n    }\\n\\n    private static String findAlphabet(String word) {\\n        byte[][] alph = new byte[2][26];\\n        for (int i = 0; i < word.length(); i+=2) {\\n            alph[0][word.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 1; i < word.length(); i+=2) {\\n            alph[1][word.charAt(i) - \\'a\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++) {\\n            sb.append(alph[0][i]);\\n            sb.append(alph[1][i]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760511,
                "title": "solution-runtime-16-ms-faster-than-63-18-and-memory-8-8-mb-less-than-68-16-of-c-submissions",
                "content": "The idea is really very naive \\uD83D\\uDE05\\uD83D\\uDE05 .....the thought was if i create a unique key for a single group of equivalent strings\\n\\n-> Take even poisitioned characters and add them to form a string, then take odd poisitioned characters and add them to form a string.\\n-> Now, sort both the strings as the question mentioned only odd poisitioned characters can be swapped with odd poistioned characters (same for even ones) if we sort them they must be equal\\n->Append both the strings to form a key and put it into a map\\n->Size of the map is our anwser\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        map<string,int> mp;\\n        for(int i=0;i<w.size();i++)\\n            {\\n                string e=\"\",o=\"\",s=w[i];\\n                for(int j=0;j<s.size();j++)\\n                {\\n                    if(j%2==0)\\n                        e+=s[j];\\n                    else\\n                        o+=s[j];\\n                }\\n                sort(e.begin(),e.end());\\n                sort(o.begin(),o.end());\\n                mp[e+o]++;\\n            }\\n   return mp.size(); }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        map<string,int> mp;\\n        for(int i=0;i<w.size();i++)\\n            {\\n                string e=\"\",o=\"\",s=w[i];\\n                for(int j=0;j<s.size();j++)\\n                {\\n                    if(j%2==0)\\n                        e+=s[j];\\n                    else\\n                        o+=s[j];\\n                }\\n                sort(e.begin(),e.end());\\n                sort(o.begin(),o.end());\\n                mp[e+o]++;\\n            }\\n   return mp.size(); }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491195,
                "title": "c-easy-solution-using-sets-and-hashmaps",
                "content": "\\n\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int n=words.size();\\n        vector<pair<string,string>>v;\\n        \\n        for(auto it:words)\\n        {\\n            string even=\"\";\\n            string odd=\"\";\\n            for(int i=0;i<it.size();i+=2)even+=it[i];\\n            for(int i=1;i<it.size();i+=2)odd+=it[i];\\n             sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            \\n            even+=odd;\\n            v.push_back({it,even});\\n        }\\n        \\n        map<string,int>m;\\n        for(auto it:v)\\n            m[it.second]++;\\n        \\n        for(auto it: m)\\n            cout<<it.first<<\" \";\\n        \\n        return m.size();\\n    }\\n    \\n};",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int n=words.size();\\n        vector<pair<string,string>>v;\\n        \\n        for(auto it:words)\\n        {\\n            string even=\"\";\\n            string odd=\"\";\\n            for(int i=0;i<it.size();i+=2)even+=it[i];\\n            for(int i=1;i<it.size();i+=2)odd+=it[i];\\n             sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            \\n            even+=odd;\\n            v.push_back({it,even}",
                "codeTag": "Java"
            },
            {
                "id": 2488710,
                "title": "python-o-n-m-hashmap-83-04",
                "content": "```\\ndef numSpecialEquivGroups(self, words: List[str]) -> int:\\n        d = {}\\n        for word in words:\\n            even = [0] * 26\\n            odd = [0] * 26\\n            for i, c in enumerate(word):\\n                if i % 2 == 0:\\n                    even[ord(c) - ord(\\'a\\')] += 1\\n                else:\\n                    odd[ord(c) - ord(\\'a\\')] += 1\\n            hsh = tuple(even) + tuple(odd)\\n            if hsh not in d:\\n                d[hsh] = set()\\n            d[hsh].add(word)\\n        return len(d)\\n```",
                "solutionTags": [
                    "Python",
                    "Counting Sort"
                ],
                "code": "```\\ndef numSpecialEquivGroups(self, words: List[str]) -> int:\\n        d = {}\\n        for word in words:\\n            even = [0] * 26\\n            odd = [0] * 26\\n            for i, c in enumerate(word):\\n                if i % 2 == 0:\\n                    even[ord(c) - ord(\\'a\\')] += 1\\n                else:\\n                    odd[ord(c) - ord(\\'a\\')] += 1\\n            hsh = tuple(even) + tuple(odd)\\n            if hsh not in d:\\n                d[hsh] = set()\\n            d[hsh].add(word)\\n        return len(d)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2434743,
                "title": "python-1-line",
                "content": "```\\nreturn len(Counter(\\'\\'.join(sorted(w[::2])+sorted(w[1::2])) for w in words))\\n```",
                "solutionTags": [],
                "code": "```\\nreturn len(Counter(\\'\\'.join(sorted(w[::2])+sorted(w[1::2])) for w in words))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1927968,
                "title": "a-sort-and-simple-solution-in-c",
                "content": "```\\n\\t\\t\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        \\n        set<string> s;\\n        \\n        for(int i=0;i<words.size();i++){\\n            \\n            string st = words[i];\\n            string odd = \"\";\\n            string even = \"\";\\n            \\n            for(int j=0;j<st.size();j++){\\n                if(j%2==0)\\n                    even=even+st[j];\\n                else\\n                    odd=odd+st[j];\\n            }\\n            \\n            sort(odd.begin(),odd.end());\\n            sort(even.begin(),even.end());\\n            string t=even+odd;\\n            s.insert(t);\\n        }\\n        return s.size();\\n    }",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        \\n        set<string> s;\\n        \\n        for(int i=0;i<words.size();i++){\\n            \\n            string st = words[i];\\n            string odd = \"\";\\n            string even = \"\";\\n            \\n            for(int j=0;j<st.size();j++){\\n                if(j%2==0)\\n                    even=even+st[j];\\n                else\\n                    odd=odd+st[j];\\n            }\\n            \\n            sort(odd.begin(),odd.end());\\n            sort(even.begin(),even.end());\\n            string t=even+odd;\\n            s.insert(t);\\n        }\\n        return s.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1615905,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // This function stores the character frequency of the odd and even positions of a string\\n    void filler(string &str,vector<int>&odd,vector<int>&even) {\\n        for(int i=0;i<str.length();i++) {\\n            if(i%2==0) {\\n                even[str[i]-\\'a\\']++;\\n            }\\n            else {\\n                odd[str[i]-\\'a\\']++;\\n            }\\n        }\\n    }\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int n=words.size();\\n        \\n        // set is for grouping the strings.\\n        // The first element of pair is odd frequency\\n        // The second element of pair is even frequency\\n        set<pair<vector<int>,vector<int>>>dict;\\n        \\n        // odd vector stores the frequency at the odd positions of all the strings \\n        vector<vector<int>>odd(n,vector<int>(26,0));\\n        \\n        // even vector stores the frequency at the even positions of all the strings \\n        vector<vector<int>>even(n,vector<int>(26,0));\\n        for(int i=0;i<words.size();i++) {\\n            // calculate the frequency\\n            filler(words[i],odd[i],even[i]);\\n            \\n            // group the string \\n            dict.insert({odd[i],even[i]});\\n        }\\n        \\n        // finally set size will the group size\\n        return dict.size();\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // This function stores the character frequency of the odd and even positions of a string\\n    void filler(string &str,vector<int>&odd,vector<int>&even) {\\n        for(int i=0;i<str.length();i++) {\\n            if(i%2==0) {\\n                even[str[i]-\\'a\\']++;\\n            }\\n            else {\\n                odd[str[i]-\\'a\\']++;\\n            }\\n        }\\n    }\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int n=words.size();\\n        \\n        // set is for grouping the strings.\\n        // The first element of pair is odd frequency\\n        // The second element of pair is even frequency\\n        set<pair<vector<int>,vector<int>>>dict;\\n        \\n        // odd vector stores the frequency at the odd positions of all the strings \\n        vector<vector<int>>odd(n,vector<int>(26,0));\\n        \\n        // even vector stores the frequency at the even positions of all the strings \\n        vector<vector<int>>even(n,vector<int>(26,0));\\n        for(int i=0;i<words.size();i++) {\\n            // calculate the frequency\\n            filler(words[i],odd[i],even[i]);\\n            \\n            // group the string \\n            dict.insert({odd[i],even[i]});\\n        }\\n        \\n        // finally set size will the group size\\n        return dict.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413780,
                "title": "java-hashset-very-easy",
                "content": "```\\n public int numSpecialEquivGroups(String[] words) {\\n         HashSet<String> record = new HashSet<>();\\n        for (String str: words) {\\n            int[] even = new int[26];\\n            int[] odd = new int[26];\\n            for (int i = 0; i < str.length(); i++) {\\n                if (i % 2 == 0) {\\n                    even[str.charAt(i) - \\'a\\']++;\\n                } else {\\n                    odd[str.charAt(i) - \\'a\\']++;\\n                }\\n            }\\n            record.add(Arrays.toString(even) + Arrays.toString(odd));\\n        }\\n        \\n        return record.size();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int numSpecialEquivGroups(String[] words) {\\n         HashSet<String> record = new HashSet<>();\\n        for (String str: words) {\\n            int[] even = new int[26];\\n            int[] odd = new int[26];\\n            for (int i = 0; i < str.length(); i++) {\\n                if (i % 2 == 0) {\\n                    even[str.charAt(i) - \\'a\\']++;\\n                } else {\\n                    odd[str.charAt(i) - \\'a\\']++;\\n                }\\n            }\\n            record.add(Arrays.toString(even) + Arrays.toString(odd));\\n        }\\n        \\n        return record.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1387210,
                "title": "python3-hashset",
                "content": "TIME COMPLEXITY - O ( n * len ( word[ i ] ) )\\nSPACE COMPLEXITY - O(N) in worst case\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        hset=set()\\n        for i in range(len(words)):\\n            even=[0]*26\\n            odd=[0]*26\\n            for j in range(len(words[i])):\\n                if j%2==0:\\n                    even[ord(words[i][j])-ord(\\'a\\')]+=1\\n                else:\\n                    odd[ord(words[i][j])-ord(\\'a\\')]+=1\\n            hset.add(\"\".join([str(even[i]) for i in range(len(even))])+\"\".join([str(odd[i]) for i in range(len(odd))]))\\n        return len(hset)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        hset=set()\\n        for i in range(len(words)):\\n            even=[0]*26\\n            odd=[0]*26\\n            for j in range(len(words[i])):\\n                if j%2==0:\\n                    even[ord(words[i][j])-ord(\\'a\\')]+=1\\n                else:\\n                    odd[ord(words[i][j])-ord(\\'a\\')]+=1\\n            hset.add(\"\".join([str(even[i]) for i in range(len(even))])+\"\".join([str(odd[i]) for i in range(len(odd))]))\\n        return len(hset)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369289,
                "title": "java-straight-forward-with-explanation-and-example",
                "content": "\\nQuestion is super convoluted. You just want the max number of string pair where if you can switch any even index char and/or odd index char, they match.\\n\\nUsing the given example, this is the mental mapping you want: \\n```\\n[\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]\\nabcd -> ac | bd\\ncbad -> ac | bd\\nxyzz -> xz | yz\\nzzxy -> xz | yz\\nzzyz -> yz | xz\\n```\\n\\nApproach:\\n1. for each string, group the characters in the even index\\n2. group the characters in the odd index\\n3. sort the group from step 1 and 2\\n4. combine the sorted values from 3 `(e.g. (sorted chars from 1) | (sorted chars from 2)`\\n5. use a map to count the groups you encountered, and increment by 1\\n\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            \\n            StringBuilder odd = new StringBuilder();\\n            StringBuilder even = new StringBuilder();\\n            \\n            String word = words[i];\\n            for (int j = 0; j < word.length(); j++) {\\n                if (j % 2 == 0) even.append(word.charAt(j));\\n                else odd.append(word.charAt(j));\\n            }\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(sortString(odd.toString()));\\n            sb.append(sortString(even.toString()));\\n            map.put(sb.toString(), map.getOrDefault(sb.toString(), 0));\\n        }\\n        \\n        return map.size();\\n    }\\n    \\n    private String sortString(String str) {\\n        char[] chars = str.toCharArray();\\n        Arrays.sort(chars);\\n        return new String(chars);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n[\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]\\nabcd -> ac | bd\\ncbad -> ac | bd\\nxyzz -> xz | yz\\nzzxy -> xz | yz\\nzzyz -> yz | xz\\n```\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            \\n            StringBuilder odd = new StringBuilder();\\n            StringBuilder even = new StringBuilder();\\n            \\n            String word = words[i];\\n            for (int j = 0; j < word.length(); j++) {\\n                if (j % 2 == 0) even.append(word.charAt(j));\\n                else odd.append(word.charAt(j));\\n            }\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(sortString(odd.toString()));\\n            sb.append(sortString(even.toString()));\\n            map.put(sb.toString(), map.getOrDefault(sb.toString(), 0));\\n        }\\n        \\n        return map.size();\\n    }\\n    \\n    private String sortString(String str) {\\n        char[] chars = str.toCharArray();\\n        Arrays.sort(chars);\\n        return new String(chars);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366209,
                "title": "c-very-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_map<string, bool> umap;\\n        int ans = 0;\\n        for(int i=0; i<words.size(); i++){\\n            string odd = \"\";\\n            string even = \"\";\\n            for(int j=0; j<words[i].length(); j++){\\n                if(j%2) odd += words[i][j];\\n                else even += words[i][j];\\n            }\\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            string s = odd + even;\\n            if(umap[s] == 0){\\n                umap[s] = 1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_map<string, bool> umap;\\n        int ans = 0;\\n        for(int i=0; i<words.size(); i++){\\n            string odd = \"\";\\n            string even = \"\";\\n            for(int j=0; j<words[i].length(); j++){\\n                if(j%2) odd += words[i][j];\\n                else even += words[i][j];\\n            }\\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            string s = odd + even;\\n            if(umap[s] == 0){\\n                umap[s] = 1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315604,
                "title": "java-90-faster",
                "content": "```\\nclass Solution {\\n    String sortString(String str) {\\n        char []arr = str.toCharArray();\\n        Arrays.sort(arr);\\n        return (String.valueOf(arr));\\n    }\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        for(String s:words){\\n            StringBuilder curr = new StringBuilder();\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0;i<s.length();i+=2){\\n                sb.append(s.charAt(i));\\n            }\\n            curr.append(sortString(sb.toString()));\\n            sb = new StringBuilder();\\n            for(int i=1;i<s.length();i+=2){\\n                sb.append(s.charAt(i));\\n            }\\n            curr.append(sortString(sb.toString()));\\n            set.add(curr.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    String sortString(String str) {\\n        char []arr = str.toCharArray();\\n        Arrays.sort(arr);\\n        return (String.valueOf(arr));\\n    }\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        for(String s:words){\\n            StringBuilder curr = new StringBuilder();\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0;i<s.length();i+=2){\\n                sb.append(s.charAt(i));\\n            }\\n            curr.append(sortString(sb.toString()));\\n            sb = new StringBuilder();\\n            for(int i=1;i<s.length();i+=2){\\n                sb.append(s.charAt(i));\\n            }\\n            curr.append(sortString(sb.toString()));\\n            set.add(curr.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312111,
                "title": "poor-description",
                "content": "This question has a simple solution. but it took alot of time to just understand the question\\n\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n            int len=words[0].length();\\n            int max=0;\\n            Map<String, Integer> map=new HashMap();\\n            for(String s:words)\\n            {\\n                 StringBuilder sb=new StringBuilder();\\n                 for(int i=0;i<len;i+=2)\\n                 {\\n                    sb.append(s.charAt(i));\\n                 }\\n                 char[] c=sb.toString().toCharArray();\\n                 StringBuilder sb1=new StringBuilder();\\n                 for(int i=1;i<len;i+=2)\\n                 {\\n                    sb1.append(s.charAt(i));\\n                    \\n                 }\\n                 char[] b=sb1.toString().toCharArray();\\n                 Arrays.sort(c);\\n                 Arrays.sort(b);\\n                 String temp=new String(b)+\"#\"+new String(c);\\n                 map.put(temp,map.getOrDefault(temp,0)+1);\\n                 max=Math.max(max,map.get(temp));\\n            }\\n            return map.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n            int len=words[0].length();\\n            int max=0;\\n            Map<String, Integer> map=new HashMap();\\n            for(String s:words)\\n            {\\n                 StringBuilder sb=new StringBuilder();\\n                 for(int i=0;i<len;i+=2)\\n                 {\\n                    sb.append(s.charAt(i));\\n                 }\\n                 char[] c=sb.toString().toCharArray();\\n                 StringBuilder sb1=new StringBuilder();\\n                 for(int i=1;i<len;i+=2)\\n                 {\\n                    sb1.append(s.charAt(i));\\n                    \\n                 }\\n                 char[] b=sb1.toString().toCharArray();\\n                 Arrays.sort(c);\\n                 Arrays.sort(b);\\n                 String temp=new String(b)+\"#\"+new String(c);\\n                 map.put(temp,map.getOrDefault(temp,0)+1);\\n                 max=Math.max(max,map.get(temp));\\n            }\\n            return map.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285114,
                "title": "c-simple-aesy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n    int i=0,n=words.size();\\n    vector<vector<string>> res;\\n\\n    while(i<n){\\n        int j=0,m=words[i].length();\\n        string strt=words[i],t1=\"\",t2=\"\";\\n        while(j<m){\\n\\n            if(j%2==0){\\n                t1+=strt[j];\\n            }else{\\n                t2+=strt[j];\\n            }\\n            j++;\\n        }\\n        sort(t1.begin(),t1.end());\\n        sort(t2.begin(),t2.end());\\n        vector<string> temp;\\n        temp.push_back(t1);\\n        temp.push_back(t2);\\n        res.push_back(temp);\\n        temp.clear();\\n        i++;\\n    }\\n   \\n    i=0;\\n    sort(res.begin(),res.end());\\n    \\n    i=0;\\n    int r=0;\\n    while(i<n){\\n        vector<string> t=res[i];\\n        i++;\\n        while(i<n && res[i]==t){\\n            i++;\\n        }\\n        cout<<\" yes \"<<i;\\n        r++;\\n\\n    }\\n    return r;\\n\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n    int i=0,n=words.size();\\n    vector<vector<string>> res;\\n\\n    while(i<n){\\n        int j=0,m=words[i].length();\\n        string strt=words[i],t1=\"\",t2=\"\";\\n        while(j<m){\\n\\n            if(j%2==0){\\n                t1+=strt[j];\\n            }else{\\n                t2+=strt[j];\\n            }\\n            j++;\\n        }\\n        sort(t1.begin(),t1.end());\\n        sort(t2.begin(),t2.end());\\n        vector<string> temp;\\n        temp.push_back(t1);\\n        temp.push_back(t2);\\n        res.push_back(temp);\\n        temp.clear();\\n        i++;\\n    }\\n   \\n    i=0;\\n    sort(res.begin(),res.end());\\n    \\n    i=0;\\n    int r=0;\\n    while(i<n){\\n        vector<string> t=res[i];\\n        i++;\\n        while(i<n && res[i]==t){\\n            i++;\\n        }\\n        cout<<\" yes \"<<i;\\n        r++;\\n\\n    }\\n    return r;\\n\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1274117,
                "title": "c-4ms-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n  int numSpecialEquivGroups(std::vector<std::string>& words) {\\n    std::set<std::string> normed;\\n    for (auto && word : words) {\\n      sortStr(word);\\n      normed.insert(word);\\n    }\\n    return normed.size();\\n  }\\n\\n  void sortStr(std::string& word) {\\n    using std::swap;\\n    for (int i = 0; i < word.size(); i += 2) {\\n      for (int j = i + 2; j < word.size(); j += 2) {\\n        if (!(word[i] < word[j])) {\\n          swap(word[i], word[j]);\\n        }\\n      }\\n    }\\n    for (int i = 1; i < word.size(); i += 2) {\\n      for (int j = i + 2; j < word.size(); j += 2) {\\n        if (word[i] < word[j]) {\\n          swap(word[i], word[j]);\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int numSpecialEquivGroups(std::vector<std::string>& words) {\\n    std::set<std::string> normed;\\n    for (auto && word : words) {\\n      sortStr(word);\\n      normed.insert(word);\\n    }\\n    return normed.size();\\n  }\\n\\n  void sortStr(std::string& word) {\\n    using std::swap;\\n    for (int i = 0; i < word.size(); i += 2) {\\n      for (int j = i + 2; j < word.size(); j += 2) {\\n        if (!(word[i] < word[j])) {\\n          swap(word[i], word[j]);\\n        }\\n      }\\n    }\\n    for (int i = 1; i < word.size(); i += 2) {\\n      for (int j = i + 2; j < word.size(); j += 2) {\\n        if (word[i] < word[j]) {\\n          swap(word[i], word[j]);\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266077,
                "title": "with-explanation-python-40-ms-faster-than-80-and-easy-solution-and-one-liner-as-well",
                "content": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        result = set()\\n        for i in words:\\n            i = \\'\\'.join(sorted(i[::2]) + sorted(i[1::2]))\\n            result.add(i)\\n        return (len(result))\\n\\n```\\n\\'\\'\\'\\t\\t\\nThe list indices which we have used ([::2]) and ([1::2]) ,\\nthis will give us odd and even elements respectively . \\nAnd as we have declared result = set() when we add result.add(i), \\nthe same elements won\\'t repeat and we will get the len. \\n\\n you can also use set at the return statement, however you are comfortable with. \\n Thank you please upvote if it helped :) \\n \\'\\'\\'\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        return len(set(\\'\\'.join(sorted(s[0::2]))+\\'\\'.join(sorted(s[1::2])) for s in words))\\n\\t\\t\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        result = set()\\n        for i in words:\\n            i = \\'\\'.join(sorted(i[::2]) + sorted(i[1::2]))\\n            result.add(i)\\n        return (len(result))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216068,
                "title": "share-two-java-solutions",
                "content": "```java\\n// \\u65B9\\u6CD5\\u4E8C\\uFF1A\\u5F97\\u5230\\u6BCF\\u4E2A\\u5B57\\u7B26\\u4E32\\u7684\\u5947\\u6570\\u4F4D\\u548C\\u5076\\u6570\\u4F4D\\u7EDF\\u8BA1\\u60C5\\u51B5\\u4EE5\\u540E\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u7279\\u5F81\\u5B57\\u7B26\\u4E32\\u5B58\\u5165 set\\uFF0C\\u7528 set \\u53BB\\u91CD\\n// AC: Runtime: 13 ms, faster than 55.72% of Java online submissions for Groups of Special-Equivalent Strings.\\n// Memory Usage: 38.7 MB, less than 80.98% of Java online submissions for Groups of Special-Equivalent Strings.\\n// \\u7565\\n// T:O(words.length * len(words[i])), S:O(words.length * len(words[i]))\\n//\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> record = new HashSet<>();\\n        for (String str: words) {\\n            int[] even = new int[26];\\n            int[] odd = new int[26];\\n            for (int i = 0; i < str.length(); i++) {\\n                if (i % 2 == 0) {\\n                    even[str.charAt(i) - \\'a\\']++;\\n                } else {\\n                    odd[str.charAt(i) - \\'a\\']++;\\n                }\\n            }\\n            record.add(Arrays.toString(even) + Arrays.toString(odd));\\n        }\\n        \\n        return record.size();\\n    }\\n}\\n\\n// \\u65B9\\u6CD5\\u4E00\\uFF1A\\u76F4\\u63A5\\u904D\\u5386\\uFF0C\\u9010\\u4E2A\\u5224\\u65AD\\u4E24\\u4E24\\u5B57\\u7B26\\u4E32\\u662F\\u5426\\u5947\\u6570\\u4F4D\\u548C\\u5076\\u6570\\u4F4D\\u7EC4\\u6210\\u76F8\\u540C\\u3002\\n// AC: Runtime: 672 ms, faster than 5.05% of Java online submissions for Groups of Special-Equivalent Strings.\\n// Memory Usage: 39.8 MB, less than 6.57% of Java online submissions for Groups of Special-Equivalent Strings.\\n// T:O(words.length ^ 2 * len(words[i])), S:O(words.length * len(words[i]))\\n// \\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        int size = words.length;\\n        List<HashSet<String>> record = new LinkedList<>();\\n        HashSet<Integer> used = new HashSet<>();\\n        for (int i = 0; i < size; i++) {\\n            if (used.contains(i)) {\\n                continue;\\n            }\\n            HashSet<String> temp = new HashSet<>();\\n            temp.add(words[i]);\\n            for (int j = i + 1; j < size; j++) {\\n                if (check(words[i], words[j])) {\\n                    temp.add(words[j]);\\n                    used.add(j);\\n                }\\n            }\\n            record.add(temp);\\n        }\\n\\n        return record.size();\\n    }\\n\\n    private boolean check(String s1, String s2) {\\n        HashMap<Character, Integer> even1 = new HashMap<>();\\n        HashMap<Character, Integer> even2 = new HashMap<>();\\n        HashMap<Character, Integer> odd1 = new HashMap<>();\\n        HashMap<Character, Integer> odd2 = new HashMap<>();\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (i % 2 == 0) {\\n                even1.merge(s1.charAt(i), 1, Integer::sum);\\n                even2.merge(s2.charAt(i), 1, Integer::sum);\\n            } else {\\n                odd1.merge(s1.charAt(i), 1, Integer::sum);\\n                odd2.merge(s2.charAt(i), 1, Integer::sum);\\n            }\\n        }\\n        for (char c: even1.keySet()) {\\n            if (even2.get(c) == null || even1.get(c).intValue() != even2.get(c).intValue()) {\\n                return false;\\n            }\\n        }\\n        for (char c: odd1.keySet()) {\\n            if (odd2.get(c) == null || odd1.get(c).intValue() != odd2.get(c).intValue()) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n// \\u65B9\\u6CD5\\u4E8C\\uFF1A\\u5F97\\u5230\\u6BCF\\u4E2A\\u5B57\\u7B26\\u4E32\\u7684\\u5947\\u6570\\u4F4D\\u548C\\u5076\\u6570\\u4F4D\\u7EDF\\u8BA1\\u60C5\\u51B5\\u4EE5\\u540E\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u7279\\u5F81\\u5B57\\u7B26\\u4E32\\u5B58\\u5165 set\\uFF0C\\u7528 set \\u53BB\\u91CD\\n// AC: Runtime: 13 ms, faster than 55.72% of Java online submissions for Groups of Special-Equivalent Strings.\\n// Memory Usage: 38.7 MB, less than 80.98% of Java online submissions for Groups of Special-Equivalent Strings.\\n// \\u7565\\n// T:O(words.length * len(words[i])), S:O(words.length * len(words[i]))\\n//\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> record = new HashSet<>();\\n        for (String str: words) {\\n            int[] even = new int[26];\\n            int[] odd = new int[26];\\n            for (int i = 0; i < str.length(); i++) {\\n                if (i % 2 == 0) {\\n                    even[str.charAt(i) - \\'a\\']++;\\n                } else {\\n                    odd[str.charAt(i) - \\'a\\']++;\\n                }\\n            }\\n            record.add(Arrays.toString(even) + Arrays.toString(odd));\\n        }\\n        \\n        return record.size();\\n    }\\n}\\n\\n// \\u65B9\\u6CD5\\u4E00\\uFF1A\\u76F4\\u63A5\\u904D\\u5386\\uFF0C\\u9010\\u4E2A\\u5224\\u65AD\\u4E24\\u4E24\\u5B57\\u7B26\\u4E32\\u662F\\u5426\\u5947\\u6570\\u4F4D\\u548C\\u5076\\u6570\\u4F4D\\u7EC4\\u6210\\u76F8\\u540C\\u3002\\n// AC: Runtime: 672 ms, faster than 5.05% of Java online submissions for Groups of Special-Equivalent Strings.\\n// Memory Usage: 39.8 MB, less than 6.57% of Java online submissions for Groups of Special-Equivalent Strings.\\n// T:O(words.length ^ 2 * len(words[i])), S:O(words.length * len(words[i]))\\n// \\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        int size = words.length;\\n        List<HashSet<String>> record = new LinkedList<>();\\n        HashSet<Integer> used = new HashSet<>();\\n        for (int i = 0; i < size; i++) {\\n            if (used.contains(i)) {\\n                continue;\\n            }\\n            HashSet<String> temp = new HashSet<>();\\n            temp.add(words[i]);\\n            for (int j = i + 1; j < size; j++) {\\n                if (check(words[i], words[j])) {\\n                    temp.add(words[j]);\\n                    used.add(j);\\n                }\\n            }\\n            record.add(temp);\\n        }\\n\\n        return record.size();\\n    }\\n\\n    private boolean check(String s1, String s2) {\\n        HashMap<Character, Integer> even1 = new HashMap<>();\\n        HashMap<Character, Integer> even2 = new HashMap<>();\\n        HashMap<Character, Integer> odd1 = new HashMap<>();\\n        HashMap<Character, Integer> odd2 = new HashMap<>();\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (i % 2 == 0) {\\n                even1.merge(s1.charAt(i), 1, Integer::sum);\\n                even2.merge(s2.charAt(i), 1, Integer::sum);\\n            } else {\\n                odd1.merge(s1.charAt(i), 1, Integer::sum);\\n                odd2.merge(s2.charAt(i), 1, Integer::sum);\\n            }\\n        }\\n        for (char c: even1.keySet()) {\\n            if (even2.get(c) == null || even1.get(c).intValue() != even2.get(c).intValue()) {\\n                return false;\\n            }\\n        }\\n        for (char c: odd1.keySet()) {\\n            if (odd2.get(c) == null || odd1.get(c).intValue() != odd2.get(c).intValue()) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115008,
                "title": "java",
                "content": "class Solution {\\n    public static int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n\\n        for (String s : A) {\\n            int[] even = new int[26];\\n            int[] odd = new int[26];\\n\\n            for (int i=0; i<s.length(); i++) {\\n                if (i%2 == 0) {\\n                    even[s.charAt(i) - \\'a\\']++;\\n                }\\n                else {\\n                    odd[s.charAt(i) - \\'a\\']++;\\n                }\\n            }\\n\\n            set.add(Arrays.toString(even) + \"|\" + Arrays.toString(odd));\\n        }\\n\\n        return set.size();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n\\n        for (String s : A) {\\n            int[] even = new int[26];\\n            int[] odd = new int[26];\\n\\n            for (int i=0; i<s.length(); i++) {\\n                if (i%2 == 0) {\\n                    even[s.charAt(i) - \\'a\\']++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1041031,
                "title": "c-solution",
                "content": "```\\nint numSpecialEquivGroups(vector<string>& A) {\\n\\tset<string> sWords;\\n\\tfor (string w : A) {\\n\\t\\tstring even = \"\", odd = \"\";\\n\\t\\tfor (int i = 0; i < w.size(); i += 2) {\\n\\t\\t\\teven += w[i];\\n\\t\\t\\todd += w[i + 1];\\n\\t\\t}\\n\\t\\tsort(begin(even), end(even));\\n\\t\\tsort(begin(odd), end(odd));\\n\\t\\tw = even + odd;\\n\\t\\tsWords.insert(w);\\n\\t}\\n\\treturn sWords.size();\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint numSpecialEquivGroups(vector<string>& A) {\\n\\tset<string> sWords;\\n\\tfor (string w : A) {\\n\\t\\tstring even = \"\", odd = \"\";\\n\\t\\tfor (int i = 0; i < w.size(); i += 2) {\\n\\t\\t\\teven += w[i];\\n\\t\\t\\todd += w[i + 1];\\n\\t\\t}\\n\\t\\tsort(begin(even), end(even));\\n\\t\\tsort(begin(odd), end(odd));\\n\\t\\tw = even + odd;\\n\\t\\tsWords.insert(w);\\n\\t}\\n\\treturn sWords.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 992322,
                "title": "c-100-fast-simple-solution",
                "content": "```\\nclass Solution{\\n    public:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        //00 sort the letter in strings in A:\\n        for(auto& word : A) {\\n            string s1, s2;\\n            for(int i = 0; i < word.size(); i += 2) {\\n                s1 += word[i];\\n                s2 += word[i + 1];\\n            }\\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            word = s1 + s2;\\n        }\\n        //01 sort the strings in A:\\n        sort(A.begin(), A.end());\\n        //02 count the group of strings:\\n        int cnt = 1;\\n        string temp = A[0];\\n        for(int i = 1; i < A.size(); ++i) {\\n            if(temp != A[i]) {\\n                ++cnt;\\n                temp = A[i];\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    public:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        //00 sort the letter in strings in A:\\n        for(auto& word : A) {\\n            string s1, s2;\\n            for(int i = 0; i < word.size(); i += 2) {\\n                s1 += word[i];\\n                s2 += word[i + 1];\\n            }\\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            word = s1 + s2;\\n        }\\n        //01 sort the strings in A:\\n        sort(A.begin(), A.end());\\n        //02 count the group of strings:\\n        int cnt = 1;\\n        string temp = A[0];\\n        for(int i = 1; i < A.size(); ++i) {\\n            if(temp != A[i]) {\\n                ++cnt;\\n                temp = A[i];\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971744,
                "title": "c-straightforward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> groups;\\n        \\n        for (auto& s: A) {\\n            string odd, even;\\n            for (int i = 0; i < s.size(); ++i)\\n                if (i%2)\\n                    odd.push_back(s[i]);\\n                else\\n                    even.push_back(s[i]);\\n            \\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            groups.insert(odd + even);\\n        }\\n        \\n        return groups.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> groups;\\n        \\n        for (auto& s: A) {\\n            string odd, even;\\n            for (int i = 0; i < s.size(); ++i)\\n                if (i%2)\\n                    odd.push_back(s[i]);\\n                else\\n                    even.push_back(s[i]);\\n            \\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            groups.insert(odd + even);\\n        }\\n        \\n        return groups.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 949096,
                "title": "c-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(const vector<string>& A) {\\n        unordered_set<string> us;\\n        for(const auto& s:A) {\\n            string s1,s2;\\n            for(int i=0; i<s.size(); ++++i) s1+=s[i];\\n            sort(s1.begin(),s1.end());\\n            for(int i=1; i<s.size(); ++++i) s2+=s[i];\\n            sort(s2.begin(),s2.end());\\n            us.insert(s1+s2);\\n        }\\n        return us.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(const vector<string>& A) {\\n        unordered_set<string> us;\\n        for(const auto& s:A) {\\n            string s1,s2;\\n            for(int i=0; i<s.size(); ++++i) s1+=s[i];\\n            sort(s1.begin(),s1.end());\\n            for(int i=1; i<s.size(); ++++i) s2+=s[i];\\n            sort(s2.begin(),s2.end());\\n            us.insert(s1+s2);\\n        }\\n        return us.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948159,
                "title": "easy-clean-javascript",
                "content": "```\\nconst numSpecialEquivGroups = A => {\\n   \\n  const sortChars = str => {\\n    const odd = [...str].filter((_,i) => i%2);\\n    const even = [...str].filter((_,i) => !(i%2));\\n    return `${odd.sort().join(\\'\\')}${even.sort().join(\\'\\')}`\\n  };\\n  \\n  const set = new Set();\\n  A.forEach(str => set.add(sortChars(str)));\\n  return set.size;\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nconst numSpecialEquivGroups = A => {\\n   \\n  const sortChars = str => {\\n    const odd = [...str].filter((_,i) => i%2);\\n    const even = [...str].filter((_,i) => !(i%2));\\n    return `${odd.sort().join(\\'\\')}${even.sort().join(\\'\\')}`\\n  };\\n  \\n  const set = new Set();\\n  A.forEach(str => set.add(sortChars(str)));\\n  return set.size;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947018,
                "title": "java-1-line",
                "content": "```\\npublic int numSpecialEquivGroups(String[] array) {\\n\\treturn Arrays.stream(array).map(s -> IntStream.range(0, s.length()).boxed().collect(Collectors.toMap(i -> s.charAt(i) + 26 * (i & 1), i -> 1, Integer::sum)).entrySet().stream().sorted(Map.Entry.comparingByKey()).map(Object::toString).collect(Collectors.joining())).collect(Collectors.toSet()).size();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numSpecialEquivGroups(String[] array) {\\n\\treturn Arrays.stream(array).map(s -> IntStream.range(0, s.length()).boxed().collect(Collectors.toMap(i -> s.charAt(i) + 26 * (i & 1), i -> 1, Integer::sum)).entrySet().stream().sorted(Map.Entry.comparingByKey()).map(Object::toString).collect(Collectors.joining())).collect(Collectors.toSet()).size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 915840,
                "title": "easy-python-3",
                "content": "\\tclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        ls=[]\\n        for i in A:\\n            odd=i[0::2]\\n            even=i[1::2]\\n            ls.append(tuple(sorted(odd)+sorted(even)))\\n\\n        return len(set(ls))",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        ls=[]\\n        for i in A:\\n            odd=i[0::2]\\n            even=i[1::2]\\n            ls.append(tuple(sorted(odd)+sorted(even)))\\n\\n        return len(set(ls))",
                "codeTag": "Java"
            },
            {
                "id": 904284,
                "title": "easiest-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        unordered_set<string>s1;\\n        for(int i=0;i<a.size();i++){\\n            string s=a[i];\\n            string odd=\"\",even=\"\";\\n            for(int i=0;i<s.length();i++){\\n                if(i%2==0)\\n                    even+=s[i];\\n                else\\n                    odd+=s[i];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n            s1.insert(even+odd);\\n            \\n        }\\n        return s1.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        unordered_set<string>s1;\\n        for(int i=0;i<a.size();i++){\\n            string s=a[i];\\n            string odd=\"\",even=\"\";\\n            for(int i=0;i<s.length();i++){\\n                if(i%2==0)\\n                    even+=s[i];\\n                else\\n                    odd+=s[i];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n            s1.insert(even+odd);\\n            \\n        }\\n        return s1.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868195,
                "title": "well-prime-numbers-helped",
                "content": "```\\npublic int numSpecialEquivGroups(String[] A) {\\n        int len = A.length;\\n        int[] firstTwentySixPrimes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\\n        Set<String> result = new HashSet<>();\\n        for(int i=0;i<len;i++) {\\n            int strLen = A[i].length();\\n            int oddIndicesNum = 1;\\n            int evenIndicesNum = 1;\\n            for(int j=0;j<strLen;j++) {\\n                char ch = A[i].charAt(j);\\n                if (j%2 != 0) oddIndicesNum *= firstTwentySixPrimes[ch-\\'a\\'];\\n                else evenIndicesNum *= firstTwentySixPrimes[ch-\\'a\\'];\\n            }\\n            result.add(\"\"+oddIndicesNum+\"-\"+evenIndicesNum);\\n        }\\n        return result.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numSpecialEquivGroups(String[] A) {\\n        int len = A.length;\\n        int[] firstTwentySixPrimes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\\n        Set<String> result = new HashSet<>();\\n        for(int i=0;i<len;i++) {\\n            int strLen = A[i].length();\\n            int oddIndicesNum = 1;\\n            int evenIndicesNum = 1;\\n            for(int j=0;j<strLen;j++) {\\n                char ch = A[i].charAt(j);\\n                if (j%2 != 0) oddIndicesNum *= firstTwentySixPrimes[ch-\\'a\\'];\\n                else evenIndicesNum *= firstTwentySixPrimes[ch-\\'a\\'];\\n            }\\n            result.add(\"\"+oddIndicesNum+\"-\"+evenIndicesNum);\\n        }\\n        return result.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 815059,
                "title": "java-o-26-n",
                "content": "```\\nclass Solution {\\n    private String evenOdd(String str){\\n        int n = str.length();\\n        int [] even = new int[26];\\n        int [] odd = new int[26];\\n        for(int i=0;i<n;i++){\\n            char c = str.charAt(i);\\n            if(i%2==0){\\n                even[c-\\'a\\']++;\\n            }else{\\n                odd[c-\\'a\\']++;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int x:even)sb.append(x);\\n        for(int x:odd)sb.append(x);\\n        return sb.toString();\\n    }\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<String>();\\n        for(String str : A){\\n            String key = evenOdd(str);\\n            set.add(key);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private String evenOdd(String str){\\n        int n = str.length();\\n        int [] even = new int[26];\\n        int [] odd = new int[26];\\n        for(int i=0;i<n;i++){\\n            char c = str.charAt(i);\\n            if(i%2==0){\\n                even[c-\\'a\\']++;\\n            }else{\\n                odd[c-\\'a\\']++;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int x:even)sb.append(x);\\n        for(int x:odd)sb.append(x);\\n        return sb.toString();\\n    }\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<String>();\\n        for(String str : A){\\n            String key = evenOdd(str);\\n            set.add(key);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 675000,
                "title": "easy-understanding-c-using-set-and-count-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string>s;\\n        for(int i=0;i<A.size();i++)\\n            s.insert(createhash(A[i]));\\n        return s.size();\\n    }\\n    static string createhash(string a)\\n    {\\n        string res=\"\";\\n        vector<int>even(26,0);\\n        vector<int>odd(26,0);\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(i%2==0)\\n            {\\n                even[a[i]-\\'a\\']++;\\n            }\\n            else\\n            {\\n                odd[a[i]-\\'a\\']++;\\n            }\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            while(even[i])\\n            {\\n                res+=to_string(i+\\'a\\');\\n                even[i]--;\\n            }\\n        }\\n        res+=\\'.\\';\\n         for(int i=0;i<26;i++)\\n        {\\n            while(odd[i])\\n            {\\n                res+=to_string(i+\\'a\\');\\n                odd[i]--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string>s;\\n        for(int i=0;i<A.size();i++)\\n            s.insert(createhash(A[i]));\\n        return s.size();\\n    }\\n    static string createhash(string a)\\n    {\\n        string res=\"\";\\n        vector<int>even(26,0);\\n        vector<int>odd(26,0);\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(i%2==0)\\n            {\\n                even[a[i]-\\'a\\']++;\\n            }\\n            else\\n            {\\n                odd[a[i]-\\'a\\']++;\\n            }\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            while(even[i])\\n            {\\n                res+=to_string(i+\\'a\\');\\n                even[i]--;\\n            }\\n        }\\n        res+=\\'.\\';\\n         for(int i=0;i<26;i++)\\n        {\\n            while(odd[i])\\n            {\\n                res+=to_string(i+\\'a\\');\\n                odd[i]--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633433,
                "title": "python-soln",
                "content": "```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        #https://leetcode.com/problems/groups-of-special-equivalent-strings/discuss/358795/python3-detail-explanation-of-special-equivalent\\n        \\n        if len(A) == 1:\\n            return 1\\n        \\n        res = set()\\n        for string in A:\\n            even_indexed_string = string[0::2]\\n            sorted_even_indexed_string = \"\".join(sorted(even_indexed_string))\\n            \\n            odd_indexed_string = string[1::2]\\n            sorted_odd_indexed_string = \"\".join(sorted(odd_indexed_string))\\n            \\n            sorted_odd_even = sorted_even_indexed_string + sorted_odd_indexed_string\\n            res.add(sorted_odd_even)\\n\\n        return len(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        #https://leetcode.com/problems/groups-of-special-equivalent-strings/discuss/358795/python3-detail-explanation-of-special-equivalent\\n        \\n        if len(A) == 1:\\n            return 1\\n        \\n        res = set()\\n        for string in A:\\n            even_indexed_string = string[0::2]\\n            sorted_even_indexed_string = \"\".join(sorted(even_indexed_string))\\n            \\n            odd_indexed_string = string[1::2]\\n            sorted_odd_indexed_string = \"\".join(sorted(odd_indexed_string))\\n            \\n            sorted_odd_even = sorted_even_indexed_string + sorted_odd_indexed_string\\n            res.add(sorted_odd_even)\\n\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633140,
                "title": "groups-of-special-equivalent-strings",
                "content": "```\\n    // Runtime: 6 ms, faster than 82.18% of Java online submissions for Groups of Special-Equivalent Strings.\\n    // Memory Usage: 39.3 MB, less than 7.69% of Java online submissions for Groups of Special-Equivalent Strings.\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> uniqueSet = new HashSet<>();\\n\\n        for (String str : A) {\\n            StringBuilder evenIndStr = new StringBuilder();\\n            StringBuilder oddIndStr = new StringBuilder();\\n\\n            for (int i = 0; i < str.length(); ++i) {\\n                if (i % 2 == 0) \\n                    evenIndStr.append(str.charAt(i));\\n                else \\n                    oddIndStr.append(str.charAt(i));\\n            }\\n            char[] evenStr = evenIndStr.toString().toCharArray();\\n            char[] oddStr = oddIndStr.toString().toCharArray();\\n            Arrays.sort(evenStr);\\n            Arrays.sort(oddStr);\\n\\n            uniqueSet.add(new String(evenStr) + new String(oddStr));\\n        }\\n\\n        return uniqueSet.size(); \\n    }",
                "solutionTags": [],
                "code": "```\\n    // Runtime: 6 ms, faster than 82.18% of Java online submissions for Groups of Special-Equivalent Strings.\\n    // Memory Usage: 39.3 MB, less than 7.69% of Java online submissions for Groups of Special-Equivalent Strings.\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> uniqueSet = new HashSet<>();\\n\\n        for (String str : A) {\\n            StringBuilder evenIndStr = new StringBuilder();\\n            StringBuilder oddIndStr = new StringBuilder();\\n\\n            for (int i = 0; i < str.length(); ++i) {\\n                if (i % 2 == 0) \\n                    evenIndStr.append(str.charAt(i));\\n                else \\n                    oddIndStr.append(str.charAt(i));\\n            }\\n            char[] evenStr = evenIndStr.toString().toCharArray();\\n            char[] oddStr = oddIndStr.toString().toCharArray();\\n            Arrays.sort(evenStr);\\n            Arrays.sort(oddStr);\\n\\n            uniqueSet.add(new String(evenStr) + new String(oddStr));\\n        }\\n\\n        return uniqueSet.size(); \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 568323,
                "title": "python3-solution-sort",
                "content": "class Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n\\n        # sort string by index  \\n        def F(s):\\n            odd, even = \"\", \"\"\\n            for i in range(len(s)):\\n                if i % 2 == 0: even += s[i]\\n                else: odd += s[i]\\n            return \"\".join(sorted(even) + sorted(odd))\\n        \\n        return len(set([F(s) for s in A]))",
                "solutionTags": [],
                "code": "class Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n\\n        # sort string by index  \\n        def F(s):\\n            odd, even = \"\", \"\"\\n            for i in range(len(s)):\\n                if i % 2 == 0: even += s[i]\\n                else: odd += s[i]\\n            return \"\".join(sorted(even) + sorted(odd))\\n        \\n        return len(set([F(s) for s in A]))",
                "codeTag": "Java"
            },
            {
                "id": 541107,
                "title": "swift-character-counting",
                "content": "```\\nclass Solution {\\n    func numSpecialEquivGroups(_ A: [String]) -> Int {\\n        var set:Set<String> = Set()\\n        for item in A{\\n            let chars = Array(item)\\n            var arr:[Character] = Array(repeating: \"0\", count: 52)\\n            for i in 0..<chars.count{\\n                if i % 2 == 0{\\n                    let val = Int(String(arr[Int(chars[i].asciiValue!) - 97]))! + 1\\n                    arr[Int(chars[i].asciiValue!) - 97] = Character(val.description)\\n                }else{\\n                    let val = Int(String(arr[Int(chars[i].asciiValue!) - 97 + 26]))! + 1\\n                    arr[Int(chars[i].asciiValue!) - 97 + 26] = Character(val.description)                \\n                }\\n            }\\n            set.insert(String(arr))\\n        }\\n        return set.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numSpecialEquivGroups(_ A: [String]) -> Int {\\n        var set:Set<String> = Set()\\n        for item in A{\\n            let chars = Array(item)\\n            var arr:[Character] = Array(repeating: \"0\", count: 52)\\n            for i in 0..<chars.count{\\n                if i % 2 == 0{\\n                    let val = Int(String(arr[Int(chars[i].asciiValue!) - 97]))! + 1\\n                    arr[Int(chars[i].asciiValue!) - 97] = Character(val.description)\\n                }else{\\n                    let val = Int(String(arr[Int(chars[i].asciiValue!) - 97 + 26]))! + 1\\n                    arr[Int(chars[i].asciiValue!) - 97 + 26] = Character(val.description)                \\n                }\\n            }\\n            set.insert(String(arr))\\n        }\\n        return set.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486870,
                "title": "python3-simple-solution",
                "content": "If two strings are special-equivalent,\\nthey share the following tuple:\\n\\n(sorted string made of characters of the original strings of even indices,\\nsorted str. made of chars. of the orig. strs. of odd indices)\\n\\nTherefore, if we make such tuples from each string and put into a set,\\nthe length of the set is the answer. \\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        ans = set()\\n        ln = len(A[0])\\n        ceven, codd = [], []\\n        \\n        for i in A:\\n            for j in range(ln):\\n                if j % 2 == 0:\\n                    ceven.append(i[j])\\n                \\n                else:\\n                    codd.append(i[j])\\n                    \\n            ceven.sort()\\n            codd.sort()\\n            ans.add((\\'\\'.join(ceven), \\'\\'.join(codd)))\\n            ceven.clear()\\n            codd.clear()\\n            \\n        return len(ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        ans = set()\\n        ln = len(A[0])\\n        ceven, codd = [], []\\n        \\n        for i in A:\\n            for j in range(ln):\\n                if j % 2 == 0:\\n                    ceven.append(i[j])\\n                \\n                else:\\n                    codd.append(i[j])\\n                    \\n            ceven.sort()\\n            codd.sort()\\n            ans.add((\\'\\'.join(ceven), \\'\\'.join(codd)))\\n            ceven.clear()\\n            codd.clear()\\n            \\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465857,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set=new HashSet();\\n        for(String s:A){\\n            int[] evenChars=new int[26];\\n            int[] oddChars=new int[26];\\n            for(int i=0;i<s.length();i++){\\n                if(i%2==0){\\n                    evenChars[s.charAt(i)-\\'a\\']++;\\n                }\\n                else{\\n                    oddChars[s.charAt(i)-\\'a\\']++;\\n                }\\n            }\\n            set.add(Arrays.toString(evenChars)+Arrays.toString(oddChars));\\n        }\\n        return set.size();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set=new HashSet();\\n        for(String s:A){\\n            int[] evenChars=new int[26];\\n            int[] oddChars=new int[26];\\n            for(int i=0;i<s.length();i++){\\n                if(i%2==0){\\n                    evenChars[s.charAt(i)-\\'a\\']++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 458813,
                "title": "c-solution-with-linq",
                "content": "```\\npublic int NumSpecialEquivGroups(string[] A) {\\n\\treturn A.Select(Order).Distinct().Count();\\n\\n\\tstring Order(string s) {\\n\\t\\tvar chars = s.Select((c, i) => (i, c)).ToArray();\\n\\t\\tvar evens = chars.Where(t => t.i % 2 == 0).Select(t => t.c).OrderBy(c => c);\\n\\t\\tvar odds = chars.Where(t => t.i % 2 == 1).Select(t => t.c).OrderBy(c => c);\\n\\n\\t\\treturn new string(evens.Concat(odds).ToArray());\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumSpecialEquivGroups(string[] A) {\\n\\treturn A.Select(Order).Distinct().Count();\\n\\n\\tstring Order(string s) {\\n\\t\\tvar chars = s.Select((c, i) => (i, c)).ToArray();\\n\\t\\tvar evens = chars.Where(t => t.i % 2 == 0).Select(t => t.c).OrderBy(c => c);\\n\\t\\tvar odds = chars.Where(t => t.i % 2 == 1).Select(t => t.c).OrderBy(c => c);\\n\\n\\t\\treturn new string(evens.Concat(odds).ToArray());\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 433339,
                "title": "count-the-characters-at-even-and-odd-positions",
                "content": "```csharp\\npublic int NumSpecialEquivGroups(string[] A)\\n{\\n\\tHashSet<string> groupCount = new HashSet<string>();\\n\\n\\tforeach (var a in A)\\n\\t{\\n\\t\\tint[] frequency = new int[26 * 2];\\n\\t\\tfor (int i = 0; i < a.Length; i++)\\n\\t\\t{\\n\\t\\t\\tif (i % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfrequency[a[i] - \\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfrequency[26 + a[i] - \\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring key = string.Join(\",\", frequency);\\n\\t\\tgroupCount.Add(key);\\n\\t}\\n\\n\\treturn groupCount.Count;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int NumSpecialEquivGroups(string[] A)\\n{\\n\\tHashSet<string> groupCount = new HashSet<string>();\\n\\n\\tforeach (var a in A)\\n\\t{\\n\\t\\tint[] frequency = new int[26 * 2];\\n\\t\\tfor (int i = 0; i < a.Length; i++)\\n\\t\\t{\\n\\t\\t\\tif (i % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfrequency[a[i] - \\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfrequency[26 + a[i] - \\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring key = string.Join(\",\", frequency);\\n\\t\\tgroupCount.Add(key);\\n\\t}\\n\\n\\treturn groupCount.Count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410934,
                "title": "brute-force-and-optimized-solution-in-cpp",
                "content": "Here we have to sort substrings so nlogn!\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        map<string,vector<string>>m;\\n        int count=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string odd=\"\";\\n            string even=\"\";\\n            for(int j=0;j<a[i].length();j++)\\n            {\\n                if(j%2==0)\\n                    even=even+a[i][j];\\n                else\\n                    odd=odd+a[i][j];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n            string res=even+odd;\\n            m[res].push_back(a[i]);\\n        }\\n        return m.size();\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        set<vector<int>>s;\\n        int count=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>count(52,0);\\n            for(int j=0;j<a[i].length();j++)\\n            {\\n                if(j%2==0)\\n                    count[a[i][j]-\\'a\\']++;\\n                else\\n                    count[a[i][j]-\\'a\\'+26]++;\\n            }\\n          s.insert(count);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        map<string,vector<string>>m;\\n        int count=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string odd=\"\";\\n            string even=\"\";\\n            for(int j=0;j<a[i].length();j++)\\n            {\\n                if(j%2==0)\\n                    even=even+a[i][j];\\n                else\\n                    odd=odd+a[i][j];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n            string res=even+odd;\\n            m[res].push_back(a[i]);\\n        }\\n        return m.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        set<vector<int>>s;\\n        int count=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>count(52,0);\\n            for(int j=0;j<a[i].length();j++)\\n            {\\n                if(j%2==0)\\n                    count[a[i][j]-\\'a\\']++;\\n                else\\n                    count[a[i][j]-\\'a\\'+26]++;\\n            }\\n          s.insert(count);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353519,
                "title": "go-golang-clean-solution",
                "content": "Runtime: 4 ms, faster than 71.43% of Go online submissions for Groups of Special-Equivalent Strings.\\nMemory Usage: 4.3 MB, less than 100.00% of Go online submissions for Groups of Special-Equivalent Strings.\\n\\n```go\\nfunc numSpecialEquivGroups(A []string) int {\\n\\n\\ttmp := make(map[string]int)\\n    \\n\\tfor _, v := range A {\\n\\n\\t\\todd, even := []rune{}, []rune{}\\n\\n\\t\\tfor I, V := range v {\\n\\n\\t\\t\\tif I%2 == 0 {\\n\\t\\t\\t\\teven = append(even, V)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\todd = append(odd, V)\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tsort.Slice(even, func(i int, j int) bool { return even[i] < even[j] })\\n\\t\\tsort.Slice(odd, func(i int, j int) bool { return odd[i] < odd[j] })\\n\\t\\ttemp := append(even, odd...)\\n\\t\\ttmp[string(temp)]++\\n\\t}\\n\\n\\treturn len(tmp)\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc numSpecialEquivGroups(A []string) int {\\n\\n\\ttmp := make(map[string]int)\\n    \\n\\tfor _, v := range A {\\n\\n\\t\\todd, even := []rune{}, []rune{}\\n\\n\\t\\tfor I, V := range v {\\n\\n\\t\\t\\tif I%2 == 0 {\\n\\t\\t\\t\\teven = append(even, V)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\todd = append(odd, V)\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tsort.Slice(even, func(i int, j int) bool { return even[i] < even[j] })\\n\\t\\tsort.Slice(odd, func(i int, j int) bool { return odd[i] < odd[j] })\\n\\t\\ttemp := append(even, odd...)\\n\\t\\ttmp[string(temp)]++\\n\\t}\\n\\n\\treturn len(tmp)\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 346580,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len(set(\\'\\'.join(sorted(w[::2]) + sorted(w[1::2])) for w in A))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len(set(\\'\\'.join(sorted(w[::2]) + sorted(w[1::2])) for w in A))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336981,
                "title": "js-simple-solution-with-explanation",
                "content": "We can calculate the *signature* of each word in the word array, and see how many distinct *word signature* there are, which would be the result. The *signature* is defined as:\\n* extract all even-indexed chars and sort them\\n* extract all odd-indexed chars and sort them\\n* combine the above two\\n\\nTake the word \"abccba\" as example:\\n```\\noriginal word: abccba\\neven-indexed chars: a c b   --sort--> a b c --combine--> abc\\nodd-indexed chars: b c a --sort--> a b c --combine--> abc\\ncombine: abcabc\\n```\\n\"abcabc\" would be the signature for \"abccba\".\\n```\\n\\nvar numSpecialEquivGroups = function(A) {\\n    let s = new Set()\\n    for (let w of A) {\\n        let tmp = helper(w)\\n        s.add(tmp)\\n    }\\n    return s.size\\n};\\n\\nconst helper = function(s) {\\n    if (s.length <= 1)\\n        return s\\n    let fst = \\'\\', sec = \\'\\'\\n    for (let i = 0; i < s.length; i += 2)\\n        fst += s[i]\\n    fst = fst.split(\\'\\').sort().join(\\'\\')\\n    for (let i = 1; i < s.length; i += 2)\\n        sec += s[i]\\n    sec = sec.split(\\'\\').sort().join(\\'\\')\\n    return fst + sec\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\noriginal word: abccba\\neven-indexed chars: a c b   --sort--> a b c --combine--> abc\\nodd-indexed chars: b c a --sort--> a b c --combine--> abc\\ncombine: abcabc\\n```\n```\\n\\nvar numSpecialEquivGroups = function(A) {\\n    let s = new Set()\\n    for (let w of A) {\\n        let tmp = helper(w)\\n        s.add(tmp)\\n    }\\n    return s.size\\n};\\n\\nconst helper = function(s) {\\n    if (s.length <= 1)\\n        return s\\n    let fst = \\'\\', sec = \\'\\'\\n    for (let i = 0; i < s.length; i += 2)\\n        fst += s[i]\\n    fst = fst.split(\\'\\').sort().join(\\'\\')\\n    for (let i = 1; i < s.length; i += 2)\\n        sec += s[i]\\n    sec = sec.split(\\'\\').sort().join(\\'\\')\\n    return fst + sec\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 311765,
                "title": "python-sol-for-starters-extremely-easy",
                "content": "```python\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        length = len(A)\\n        res = set()\\n        for item in A:\\n            odds = item[::2]\\n            evens = item[1::2]\\n            res.add((str(sorted(odds)),str(sorted(evens))))\\n        return len(res)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        length = len(A)\\n        res = set()\\n        for item in A:\\n            odds = item[::2]\\n            evens = item[1::2]\\n            res.add((str(sorted(odds)),str(sorted(evens))))\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300132,
                "title": "c-beat-99-with-explanation",
                "content": "\\tafter realizing the question, all we have to do is the check if odd/even position pattern is the same between two string.\\n\\tfor instance : \"abcdefggyy\"\\n\\todd pattern : \"acegy\"\\n\\teven pattern : \"bdfgy\"\\n\\twe can simply check those pattern after sorting.\\n\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        map<std::pair<string,string>,int> mymap; // key:pattern pair\\n        for(int i = 0 ; i < A.size() ; i++){\\n            string s[2];\\n            for(int j = 0 ; j < A[i].length() ; j++)\\n                s[j%2]+= A[i][j];\\n            sort(s[0].begin(),s[0].end()),sort(s[1].begin(),s[1].end());\\n            mymap[{s[0],s[1]}]++;\\n        }\\n        return mymap.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        map<std::pair<string,string>,int> mymap; // key:pattern pair\\n        for(int i = 0 ; i < A.size() ; i++){\\n            string s[2];\\n            for(int j = 0 ; j < A[i].length() ; j++)\\n                s[j%2]+= A[i][j];\\n            sort(s[0].begin(),s[0].end()),sort(s[1].begin(),s[1].end());\\n            mymap[{s[0],s[1]}]++;\\n        }\\n        return mymap.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285486,
                "title": "python3-one-line-solution",
                "content": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len(set([(\\'\\'.join(sorted(i[::2])),\\'\\'.join(sorted(i[1::2]))) for i in A]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len(set([(\\'\\'.join(sorted(i[::2])),\\'\\'.join(sorted(i[1::2]))) for i in A]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283634,
                "title": "why-the-answer-of-abcd-cdab-adcb-cbad-last-test-case-35-is-2-not-1-in-example-4",
                "content": "Below is my code. It passed the example 4 when testing but failed it after I submitted (the last test case). \\nI\\'ve checked many times and, if I am correct, found the 35-th test case should be the same as example 4. \\nIs there anyone who knows why it has two different answers? Thanks.\\n```\\n    def numSpecialEquivGroups(self, A):\\n        table = set()\\n        for string in A:\\n            set0 = frozenset(string[::2]) # mod 2 = 0\\n            set1 = frozenset(string[1::2]) # mod 2 = 1\\n            table.add((set0, set1))\\n        return len(table)\\n```\\n![image](https://assets.leetcode.com/users/victorchen1028/image_1556525968.png)\\n",
                "solutionTags": [],
                "code": "```\\n    def numSpecialEquivGroups(self, A):\\n        table = set()\\n        for string in A:\\n            set0 = frozenset(string[::2]) # mod 2 = 0\\n            set1 = frozenset(string[1::2]) # mod 2 = 1\\n            table.add((set0, set1))\\n        return len(table)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 261975,
                "title": "two-lines-python-solution",
                "content": "\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        # re-order string based on special equvilant\\n        lists = [ \\'\\'.join([\\'\\'.join(sorted(a[0::2])),\\'\\'.join(sorted(a[1::2]))]) for a in A ]\\n        return len(Counter(lists).keys())\\n```\\n\\nexplanation:\\n`a[0::2]` will give all the letters on the even number positions.\\n`a[1::2]` will give all the letters on the odd number positions.\\n`sorted` them to fix an order since we could achieve it with certain number of moves.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        # re-order string based on special equvilant\\n        lists = [ \\'\\'.join([\\'\\'.join(sorted(a[0::2])),\\'\\'.join(sorted(a[1::2]))]) for a in A ]\\n        return len(Counter(lists).keys())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254323,
                "title": "javascript-easy-solution",
                "content": "``` JavaScript\\nvar numSpecialEquivGroups = function(A) {\\n    const map = A.reduce((res, str) => {\\n    \\tconst key = transString(str);\\n    \\tif (key in res) {\\n    \\t\\tres[key] += 1;\\n    \\t} else {\\n    \\t\\tres[key] = 1;\\n    \\t}\\n    \\treturn res;\\n    }, {});\\n    return Object.keys(map).length;\\n};\\n\\nfunction transString(str) {\\n\\tconst odd = [], even = [];\\n\\tfor (let i = 0; i < str.length; i++) {\\n\\t\\tif (i % 2 === 0) {\\n\\t\\t\\teven.push(str[i]);\\n\\t\\t} else {\\n\\t\\t\\todd.push(str[i]);\\n\\t\\t}\\n\\t}\\n\\treturn odd.sort().join(\\'\\') + \\';\\' + even.sort().join(\\'\\');\\n}\\n```",
                "solutionTags": [],
                "code": "``` JavaScript\\nvar numSpecialEquivGroups = function(A) {\\n    const map = A.reduce((res, str) => {\\n    \\tconst key = transString(str);\\n    \\tif (key in res) {\\n    \\t\\tres[key] += 1;\\n    \\t} else {\\n    \\t\\tres[key] = 1;\\n    \\t}\\n    \\treturn res;\\n    }, {});\\n    return Object.keys(map).length;\\n};\\n\\nfunction transString(str) {\\n\\tconst odd = [], even = [];\\n\\tfor (let i = 0; i < str.length; i++) {\\n\\t\\tif (i % 2 === 0) {\\n\\t\\t\\teven.push(str[i]);\\n\\t\\t} else {\\n\\t\\t\\todd.push(str[i]);\\n\\t\\t}\\n\\t}\\n\\treturn odd.sort().join(\\'\\') + \\';\\' + even.sort().join(\\'\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 191573,
                "title": "java-solution-using-set",
                "content": "The feature of Set is that there will be no duplicate elements, so as long as the size of the Set is counted, you can know how many different ones are. Plus, sort even and odd positions separately and save them into set.\\n```\\npublic int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n        for(String a : A){\\n            int n = a.length();\\n            char[] odd = new char[(n + 1)/2];\\n            char[] even = new char[(n + 1)/2];\\n            int to = 0, te = 0;\\n            for(int i = 0; i < a.length(); i++){\\n                if(i % 2 == 0) even[te++] = a.charAt(i);\\n                else odd[to++] = a.charAt(i);\\n            }\\n            Arrays.sort(odd);\\n            Arrays.sort(even);\\n            set.add(String.valueOf(odd)+String.valueOf(even));\\n        }\\n        return set.size();\\n    }```",
                "solutionTags": [],
                "code": "```\\npublic int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n        for(String a : A){\\n            int n = a.length();\\n            char[] odd = new char[(n + 1)/2];\\n            char[] even = new char[(n + 1)/2];\\n            int to = 0, te = 0;\\n            for(int i = 0; i < a.length(); i++){\\n                if(i % 2 == 0) even[te++] = a.charAt(i);\\n                else odd[to++] = a.charAt(i);\\n            }\\n            Arrays.sort(odd);\\n            Arrays.sort(even);\\n            set.add(String.valueOf(odd)+String.valueOf(even));\\n        }\\n        return set.size();\\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 187031,
                "title": "c-solution-based-on-sequential-multiplication-of-ascii-codes",
                "content": "the solution is based on multiplication of characters\\' ASCII codes, which don\\'t intersect in sense of  the following property: \\n```\\nascii(x) * ascii(y) != ascii(p) * ascii(q), where pairs of symbols (x, y) and (p, q) are different\\n```\\n\\ngiven the property, we can multiply over all the ascii codes of even- and odd-indexed (independently) characters in the string and then store them as unique pairs of result products in an _ordered_ set. Then, we count unique pairs\\nThe solution goes with O(n) time complexity and O(n) space complexity\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        std::set<std::pair<uint64_t, uint64_t>> s;\\n        for (auto &str : A) {\\n            std::pair<uint64_t, uint64_t> res{1, 1};\\n            for (int i = 0; i < str.size(); ++i) {\\n                if (0 == i % 2) res.first *= str[i];\\n                else res.second *= str[i];\\n            }\\n            s.insert(res);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nascii(x) * ascii(y) != ascii(p) * ascii(q), where pairs of symbols (x, y) and (p, q) are different\\n```\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        std::set<std::pair<uint64_t, uint64_t>> s;\\n        for (auto &str : A) {\\n            std::pair<uint64_t, uint64_t> res{1, 1};\\n            for (int i = 0; i < str.size(); ++i) {\\n                if (0 == i % 2) res.first *= str[i];\\n                else res.second *= str[i];\\n            }\\n            s.insert(res);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 178368,
                "title": "python-very-simple-easy-to-read-using-dictionary",
                "content": "This implementation can also return no.of elements in each group by changing the `return` statement\n```\nclass Solution:\n    def numSpecialEquivGroups(self, A):\n        d = dict()\n        for i in A:\n            if len(i) >= 2:\n                key = (tuple(sorted(i[::2])), tuple(sorted(i[1::2])))\n                d[key] = d.get(key,0) + 1\n            else:\n                d[i] = d.get(i,0) + 1     \n        return len(d) \n```",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def numSpecialEquivGroups(self, A):\n        d = dict()\n        for i in A:\n            if len(i) >= 2:\n                key = (tuple(sorted(i[::2])), tuple(sorted(i[1::2])))\n                d[key] = d.get(key,0) + 1\n            else:\n                d[i] = d.get(i,0) + 1     \n        return len(d) \n```",
                "codeTag": "Java"
            },
            {
                "id": 169632,
                "title": "c-beat-100-use-both-unordered-map-and-unordered-set",
                "content": "```\\nint numSpecialEquivGroups(vector<string>& A) {\\n        int res = 0;\\n        unordered_map<string,unordered_set<string>> table;// odd | evens\\n        for(int i = 0; i < A.size(); i++){\\n            int j = 0;\\n            string odds = \"\";\\n            string evens = \"\";\\n            while(j < A[i].size()){\\n                if(j%2 == 0)\\n                    evens = evens+A[i][j];\\n                if(j%2 == 1)\\n                    odds = odds+A[i][j];\\n                j++;\\n            }\\n            sort(evens.begin(),evens.end());\\n            sort(odds.begin(),odds.end());\\n            if(table[odds].find(evens) == table[odds].end()){\\n                res++;\\n                table[odds].insert(evens);\\n            }    \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint numSpecialEquivGroups(vector<string>& A) {\\n        int res = 0;\\n        unordered_map<string,unordered_set<string>> table;// odd | evens\\n        for(int i = 0; i < A.size(); i++){\\n            int j = 0;\\n            string odds = \"\";\\n            string evens = \"\";\\n            while(j < A[i].size()){\\n                if(j%2 == 0)\\n                    evens = evens+A[i][j];\\n                if(j%2 == 1)\\n                    odds = odds+A[i][j];\\n                j++;\\n            }\\n            sort(evens.begin(),evens.end());\\n            sort(odds.begin(),odds.end());\\n            if(table[odds].find(evens) == table[odds].end()){\\n                res++;\\n                table[odds].insert(evens);\\n            }    \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165769,
                "title": "concise-java-solution-using-char",
                "content": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> groups = new HashSet<>();\\n        for (String str : A) {\\n            char[] chars = str.toCharArray();\\n            char[] odd = new char[20];\\n            char[] even = new char[20];\\n            for (int i = 0; i < chars.length; i++) {\\n                if (i % 2 == 0) {\\n                    odd[i] = chars[i];\\n                } else {\\n                    even[i] = chars[i];\\n                }\\n            }\\n            Arrays.sort(odd);\\n            Arrays.sort(even);\\n            String unique = String.valueOf(odd) + String.valueOf(even);\\n            groups.add(unique);\\n        }\\n        return groups.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> groups = new HashSet<>();\\n        for (String str : A) {\\n            char[] chars = str.toCharArray();\\n            char[] odd = new char[20];\\n            char[] even = new char[20];\\n            for (int i = 0; i < chars.length; i++) {\\n                if (i % 2 == 0) {\\n                    odd[i] = chars[i];\\n                } else {\\n                    even[i] = chars[i];\\n                }\\n            }\\n            Arrays.sort(odd);\\n            Arrays.sort(even);\\n            String unique = String.valueOf(odd) + String.valueOf(even);\\n            groups.add(unique);\\n        }\\n        return groups.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164241,
                "title": "javascript-not-the-fastest-but-i-like-it",
                "content": "```\\nvar numSpecialEquivGroups = function(A) {\\n    return A.reduce((prev, curr) => {\\n        let left = \"\"\\n        let right = \"\"\\n        for(let i=0; i<curr.length; i++){\\n            i%2===0 ? left += curr[i] : right += curr[i] \\n        }\\n        left = [...left].sort().join(\"\")\\n        right = [...right].sort().join(\"\")\\n        for(let i=0; i<prev.length; i++){\\n            if(prev[i][0] === left && prev[i][1] === right){\\n                return prev\\n            }\\n        }\\n        prev.push([left,right])\\n        return prev\\n    }, []).length\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numSpecialEquivGroups = function(A) {\\n    return A.reduce((prev, curr) => {\\n        let left = \"\"\\n        let right = \"\"\\n        for(let i=0; i<curr.length; i++){\\n            i%2===0 ? left += curr[i] : right += curr[i] \\n        }\\n        left = [...left].sort().join(\"\")\\n        right = [...right].sort().join(\"\")\\n        for(let i=0; i<prev.length; i++){\\n            if(prev[i][0] === left && prev[i][1] === right){\\n                return prev\\n            }\\n        }\\n        prev.push([left,right])\\n        return prev\\n    }, []).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 163535,
                "title": "python-straightforward-solution",
                "content": "```\\nclass Solution(object):\\n\\tdef numSpecialEquivGroups(self, A):\\n\\t\\t\"\"\"\\n\\t\\t:type A: List[str]\\n\\t\\t:rtype: int\\n\\t\\t\"\"\"\\n\\t\\tB = set()\\n\\t\\tfor string in A:\\n\\t\\t\\tC = list(string)\\n\\t\\t\\ta, b = C[::2], C[1::2]\\n\\t\\t\\tB.add((\\'\\'.join(sorted(a)), \\'\\'.join(sorted(b))))\\n\\t\\t\\t\\n\\t\\treturn len(B)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\tdef numSpecialEquivGroups(self, A):\\n\\t\\t\"\"\"\\n\\t\\t:type A: List[str]\\n\\t\\t:rtype: int\\n\\t\\t\"\"\"\\n\\t\\tB = set()\\n\\t\\tfor string in A:\\n\\t\\t\\tC = list(string)\\n\\t\\t\\ta, b = C[::2], C[1::2]\\n\\t\\t\\tB.add((\\'\\'.join(sorted(a)), \\'\\'.join(sorted(b))))\\n\\t\\t\\t\\n\\t\\treturn len(B)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163442,
                "title": "java-sorting-solution",
                "content": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : A) {\\n            String key = sort(s);\\n            set.add(key);\\n        }\\n        return set.size();\\n    }\\n    private String sort(String s) {\\n        List<Character> l1 = new ArrayList<>();\\n        List<Character> l2 = new ArrayList<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i % 2 == 0) {\\n                l1.add(s.charAt(i));\\n            } else {\\n                l2.add(s.charAt(i));\\n            }\\n        }\\n        Collections.sort(l1);\\n        Collections.sort(l2);\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : l1) {\\n            sb.append(c);\\n        }\\n        for (char c : l2) {\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : A) {\\n            String key = sort(s);\\n            set.add(key);\\n        }\\n        return set.size();\\n    }\\n    private String sort(String s) {\\n        List<Character> l1 = new ArrayList<>();\\n        List<Character> l2 = new ArrayList<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i % 2 == 0) {\\n                l1.add(s.charAt(i));\\n            } else {\\n                l2.add(s.charAt(i));\\n            }\\n        }\\n        Collections.sort(l1);\\n        Collections.sort(l2);\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : l1) {\\n            sb.append(c);\\n        }\\n        for (char c : l2) {\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102505,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        d = {}\\n\\n        for i,word in enumerate(words):\\n            even, odd = \"\", \"\"\\n            for j in range(len(word)):\\n                if j % 2 == 0:\\n                    even += word[j]\\n                else:\\n                    odd += word[j]\\n            \\n            even = list(even)\\n            even.sort()\\n            even = \"\".join(even)\\n            odd = list(odd)\\n            odd.sort()\\n            odd = \"\".join(odd)\\n\\n            if even+odd in d:\\n                d[even+odd] += 1\\n            else:\\n                d[even+odd] = 1\\n\\n        return len(d)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        d = {}\\n\\n        for i,word in enumerate(words):\\n            even, odd = \"\", \"\"\\n            for j in range(len(word)):\\n                if j % 2 == 0:\\n                    even += word[j]\\n                else:\\n                    odd += word[j]\\n            \\n            even = list(even)\\n            even.sort()\\n            even = \"\".join(even)\\n            odd = list(odd)\\n            odd.sort()\\n            odd = \"\".join(odd)\\n\\n            if even+odd in d:\\n                d[even+odd] += 1\\n            else:\\n                d[even+odd] = 1\\n\\n        return len(d)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081089,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            String evens = \"\";\\n            String odds = \"\";\\n            for (int i = 0; i < word.length(); i++) {\\n                if (i % 2 == 0) {\\n                    evens += String.valueOf(word.charAt(i));\\n                } else {\\n                    odds += String.valueOf(word.charAt(i));\\n                }\\n            }\\n            char[] evensChar = evens.toCharArray();\\n            Arrays.sort(evensChar);\\n            char[] oddsChar = odds.toCharArray();\\n            Arrays.sort(oddsChar);\\n            set.add(String.valueOf(evensChar) + String.valueOf(oddsChar));\\n        }\\n        return set.size();\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int sz=words.size(),ct=0;\\n       // map<int,vector<int>>mp;\\n        vector<bool>vis(sz,false);\\n          for(int i=0;i<words.size();i++)\\n            {\\n              if(vis[i]==true)\\n                  continue;\\n              vector<char>even1,odd1;\\n              //seperate even and odd indices in differnent vectors\\n              for(int j=0;j<words[i].size();j++)\\n                  {\\n                    if(j%2==0)\\n                      even1.push_back(words[i][j]);\\n                    else\\n                      odd1.push_back(words[i][j]);\\n                  }\\n                 \\n                  //sort even and odd indices \\n                  sort(even1.begin(),even1.end());\\n                  sort(odd1.begin(),odd1.end());\\n              for(int j=i+1;j<sz;j++)\\n                 {\\n                    vector<char>even2,odd2;\\n                      \\n                        for(int i=0;i<words[j].size();i++)\\n                         {\\n                        if(i%2==0)\\n                           even2.push_back(words[j][i]);\\n                        else\\n                           odd2.push_back(words[j][i]);\\n                         }\\n                    sort(even2.begin(),even2.end());\\n                    sort(odd2.begin(),odd2.end());\\n                    //compare all even postion char and odd char are same if same then push it into the vector and mark is as visited\\n                if(even1==even2 and odd1==odd2)\\n                   {\\n                     \\n                         \\n                       vis[j]=true;\\n                           // mp[i].push_back(j);                    \\n                   }\\n                 }\\n              //if no match found then push empty index in vector\\n                ct++;\\n            }\\n            return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            String evens = \"\";\\n            String odds = \"\";\\n            for (int i = 0; i < word.length(); i++) {\\n                if (i % 2 == 0) {\\n                    evens += String.valueOf(word.charAt(i));\\n                } else {\\n                    odds += String.valueOf(word.charAt(i));\\n                }\\n            }\\n            char[] evensChar = evens.toCharArray();\\n            Arrays.sort(evensChar);\\n            char[] oddsChar = odds.toCharArray();\\n            Arrays.sort(oddsChar);\\n            set.add(String.valueOf(evensChar) + String.valueOf(oddsChar));\\n        }\\n        return set.size();\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int sz=words.size(),ct=0;\\n       // map<int,vector<int>>mp;\\n        vector<bool>vis(sz,false);\\n          for(int i=0;i<words.size();i++)\\n            {\\n              if(vis[i]==true)\\n                  continue;\\n              vector<char>even1,odd1;\\n              //seperate even and odd indices in differnent vectors\\n              for(int j=0;j<words[i].size();j++)\\n                  {\\n                    if(j%2==0)\\n                      even1.push_back(words[i][j]);\\n                    else\\n                      odd1.push_back(words[i][j]);\\n                  }\\n                 \\n                  //sort even and odd indices \\n                  sort(even1.begin(),even1.end());\\n                  sort(odd1.begin(),odd1.end());\\n              for(int j=i+1;j<sz;j++)\\n                 {\\n                    vector<char>even2,odd2;\\n                      \\n                        for(int i=0;i<words[j].size();i++)\\n                         {\\n                        if(i%2==0)\\n                           even2.push_back(words[j][i]);\\n                        else\\n                           odd2.push_back(words[j][i]);\\n                         }\\n                    sort(even2.begin(),even2.end());\\n                    sort(odd2.begin(),odd2.end());\\n                    //compare all even postion char and odd char are same if same then push it into the vector and mark is as visited\\n                if(even1==even2 and odd1==odd2)\\n                   {\\n                     \\n                         \\n                       vis[j]=true;\\n                           // mp[i].push_back(j);                    \\n                   }\\n                 }\\n              //if no match found then push empty index in vector\\n                ct++;\\n            }\\n            return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023782,
                "title": "rust-solution",
                "content": "# Code\\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn num_special_equiv_groups(words: Vec<String>) -> i32 {\\n       let mut hashset:HashSet::<String> = HashSet::new(); \\n\\n        for word in words{\\n            let mut even:Vec<char> = Vec::new();\\n            let mut odd:Vec<char> = Vec::new();\\n            for (idx,w) in word.chars().enumerate(){\\n                if idx % 2 == 0{\\n                    even.push(w);\\n                }else{\\n                    odd.push(w);\\n                }\\n            }\\n            even.sort();\\n            odd.sort();\\n            let my_str  = format!(\"{}{}\",\\n            even.iter().collect::<String>(),\\n            odd.iter().collect::<String>());\\n            hashset.insert(my_str);\\n        }\\n        let out = hashset.len() as i32;\\n        out\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn num_special_equiv_groups(words: Vec<String>) -> i32 {\\n       let mut hashset:HashSet::<String> = HashSet::new(); \\n\\n        for word in words{\\n            let mut even:Vec<char> = Vec::new();\\n            let mut odd:Vec<char> = Vec::new();\\n            for (idx,w) in word.chars().enumerate(){\\n                if idx % 2 == 0{\\n                    even.push(w);\\n                }else{\\n                    odd.push(w);\\n                }\\n            }\\n            even.sort();\\n            odd.sort();\\n            let my_str  = format!(\"{}{}\",\\n            even.iter().collect::<String>(),\\n            odd.iter().collect::<String>());\\n            hashset.insert(my_str);\\n        }\\n        let out = hashset.len() as i32;\\n        out\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009402,
                "title": "naive-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>&w){\\n        unordered_set<string>st;\\n        vector<int>v;\\n        for(int i=0; i<w.size(); i++){\\n            if(st.find(w[i])!=st.end()){\\n                continue;\\n            }\\n            else{\\n                st.insert(w[i]);\\n                string s1,s2;\\n                for(int j=0; j<w[i].size(); j+=2){\\n                    s1+=w[i][j];\\n                }\\n                for(int j=1; j<w[i].size(); j+=2){\\n                    s2+=w[i][j];\\n                }\\n                sort(s1.begin(),s1.end());\\n                sort(s2.begin(),s2.end());\\n                int c=0;\\n                for(int j=i+1; j<w.size(); j++){\\n                    string t1 , t2;\\n                    for(int k=0; k<w[j].size(); k+=2){\\n                        t1+=w[j][k];\\n                    }\\n                    for(int k=1; k<w[j].size(); k+=2){\\n                        t2+=w[j][k];\\n                    }\\n                    sort(t1.begin(),t1.end());\\n                    sort(t2.begin(),t2.end());\\n                    if(t1==s1 && t2==s2){\\n                        c++;\\n                        st.insert(w[j]);\\n                    }\\n                }\\n                v.push_back(c);\\n            }\\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>&w){\\n        unordered_set<string>st;\\n        vector<int>v;\\n        for(int i=0; i<w.size(); i++){\\n            if(st.find(w[i])!=st.end()){\\n                continue;\\n            }\\n            else{\\n                st.insert(w[i]);\\n                string s1,s2;\\n                for(int j=0; j<w[i].size(); j+=2){\\n                    s1+=w[i][j];\\n                }\\n                for(int j=1; j<w[i].size(); j+=2){\\n                    s2+=w[i][j];\\n                }\\n                sort(s1.begin(),s1.end());\\n                sort(s2.begin(),s2.end());\\n                int c=0;\\n                for(int j=i+1; j<w.size(); j++){\\n                    string t1 , t2;\\n                    for(int k=0; k<w[j].size(); k+=2){\\n                        t1+=w[j][k];\\n                    }\\n                    for(int k=1; k<w[j].size(); k+=2){\\n                        t2+=w[j][k];\\n                    }\\n                    sort(t1.begin(),t1.end());\\n                    sort(t2.begin(),t2.end());\\n                    if(t1==s1 && t2==s2){\\n                        c++;\\n                        st.insert(w[j]);\\n                    }\\n                }\\n                v.push_back(c);\\n            }\\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006307,
                "title": "python-solution-using-hashmap-and-helper-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        #an array \\'words\\' of strings of the same length\\n        #in one move i can swap any two even indexed chars or any two odd indexed\\n        #chars in word in words\\n        #two words in array words are special equivalent if after any number of moves\\n        #they can be the same\\n        #return the number of groups of special equivalent strings from words\\n        #to group them i think i have to use a hashmap\\n        #i should also define a helper function that can help me compare two strings\\n        #based on whether if they are special equivalent\\n\\n\\n        def specialEquivalence(s1):\\n            odd_1 = \"\"\\n            even_1 = \"\"\\n            for i in range(len(s1)):\\n                if i % 2 == 0:\\n                    even_1 += s1[i]\\n                else:\\n                    odd_1 += s1[i]\\n            return \"\".join((sorted(even_1) + sorted(odd_1)))\\n        \\n        lookup = {}\\n\\n        for word in words:\\n            lookup[specialEquivalence(word)] = 1 + lookup.get(specialEquivalence(word), 0)\\n        \\n        return len(lookup.keys())\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        #an array \\'words\\' of strings of the same length\\n        #in one move i can swap any two even indexed chars or any two odd indexed\\n        #chars in word in words\\n        #two words in array words are special equivalent if after any number of moves\\n        #they can be the same\\n        #return the number of groups of special equivalent strings from words\\n        #to group them i think i have to use a hashmap\\n        #i should also define a helper function that can help me compare two strings\\n        #based on whether if they are special equivalent\\n\\n\\n        def specialEquivalence(s1):\\n            odd_1 = \"\"\\n            even_1 = \"\"\\n            for i in range(len(s1)):\\n                if i % 2 == 0:\\n                    even_1 += s1[i]\\n                else:\\n                    odd_1 += s1[i]\\n            return \"\".join((sorted(even_1) + sorted(odd_1)))\\n        \\n        lookup = {}\\n\\n        for word in words:\\n            lookup[specialEquivalence(word)] = 1 + lookup.get(specialEquivalence(word), 0)\\n        \\n        return len(lookup.keys())\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998269,
                "title": "easy-c-solution-using-set-5-ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) \\n    {\\n        set<string>S ;\\n        for(auto& it : words)\\n        {\\n            string even , odd ;\\n            for(int i = 0 ; i < it.size() ; i++)\\n            {\\n                if(i%2 == 0)\\n                    even += it[i];\\n                else\\n                    odd+= it[i];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n\\n            even += odd ;\\n            if(S.find(even) == S.end())\\n                S.insert(even);\\n        }\\n        return S.size();    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) \\n    {\\n        set<string>S ;\\n        for(auto& it : words)\\n        {\\n            string even , odd ;\\n            for(int i = 0 ; i < it.size() ; i++)\\n            {\\n                if(i%2 == 0)\\n                    even += it[i];\\n                else\\n                    odd+= it[i];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n\\n            even += odd ;\\n            if(S.find(even) == S.end())\\n                S.insert(even);\\n        }\\n        return S.size();    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985024,
                "title": "python3-convert-characters-at-odd-and-even-indices-into-a-hash-count-unique-hashes",
                "content": "# Code\\n```\\nclass Solution:\\n    # Approach: Form a dictionary (h1, h2) -> [s1,s2...sn]\\n    # where h1 and h2 are two hashes -  sorted characters\\n    # at the odd and even indices respectively in the word.\\n    # So (h1,h2) will be the same for all special-equivalent strings.\\n    # Then count the number of unique hashes.\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n\\n        def build_hash(s:str) -> Tuple[str, str]:\\n            odd_chars = []\\n            even_chars = []\\n            for idx, c in enumerate(s):\\n                if idx % 2:\\n                    odd_chars.append(c)\\n                else:\\n                    even_chars.append(c)\\n            odd_chars.sort()\\n            even_chars.sort()\\n            return (\\'\\'.join(odd_chars), \\'\\'.join(even_chars))\\n\\n        word_hash_set = set()\\n        for w in words:\\n            word_hash_set.add(build_hash(w))\\n        return len(word_hash_set)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # Approach: Form a dictionary (h1, h2) -> [s1,s2...sn]\\n    # where h1 and h2 are two hashes -  sorted characters\\n    # at the odd and even indices respectively in the word.\\n    # So (h1,h2) will be the same for all special-equivalent strings.\\n    # Then count the number of unique hashes.\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n\\n        def build_hash(s:str) -> Tuple[str, str]:\\n            odd_chars = []\\n            even_chars = []\\n            for idx, c in enumerate(s):\\n                if idx % 2:\\n                    odd_chars.append(c)\\n                else:\\n                    even_chars.append(c)\\n            odd_chars.sort()\\n            even_chars.sort()\\n            return (\\'\\'.join(odd_chars), \\'\\'.join(even_chars))\\n\\n        word_hash_set = set()\\n        for w in words:\\n            word_hash_set.add(build_hash(w))\\n        return len(word_hash_set)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980595,
                "title": "c-simple-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int sz=words.size(),ct=0;\\n       // map<int,vector<int>>mp;\\n        vector<bool>vis(sz,false);\\n          for(int i=0;i<words.size();i++)\\n            {\\n              if(vis[i]==true)\\n                  continue;\\n              vector<char>even1,odd1;\\n              //seperate even and odd indices in differnent vectors\\n              for(int j=0;j<words[i].size();j++)\\n                  {\\n                    if(j%2==0)\\n                      even1.push_back(words[i][j]);\\n                    else\\n                      odd1.push_back(words[i][j]);\\n                  }\\n                 \\n                  //sort even and odd indices \\n                  sort(even1.begin(),even1.end());\\n                  sort(odd1.begin(),odd1.end());\\n              for(int j=i+1;j<sz;j++)\\n                 {\\n                    vector<char>even2,odd2;\\n                      \\n                        for(int i=0;i<words[j].size();i++)\\n                         {\\n                        if(i%2==0)\\n                           even2.push_back(words[j][i]);\\n                        else\\n                           odd2.push_back(words[j][i]);\\n                         }\\n                    sort(even2.begin(),even2.end());\\n                    sort(odd2.begin(),odd2.end());\\n                    //compare all even postion char and odd char are same if same then push it into the vector and mark is as visited\\n                if(even1==even2 and odd1==odd2)\\n                   {\\n                     \\n                         \\n                       vis[j]=true;\\n                           // mp[i].push_back(j);                    \\n                   }\\n                 }\\n              //if no match found then push empty index in vector\\n                ct++;\\n            }\\n            return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int sz=words.size(),ct=0;\\n       // map<int,vector<int>>mp;\\n        vector<bool>vis(sz,false);\\n          for(int i=0;i<words.size();i++)\\n            {\\n              if(vis[i]==true)\\n                  continue;\\n              vector<char>even1,odd1;\\n              //seperate even and odd indices in differnent vectors\\n              for(int j=0;j<words[i].size();j++)\\n                  {\\n                    if(j%2==0)\\n                      even1.push_back(words[i][j]);\\n                    else\\n                      odd1.push_back(words[i][j]);\\n                  }\\n                 \\n                  //sort even and odd indices \\n                  sort(even1.begin(),even1.end());\\n                  sort(odd1.begin(),odd1.end());\\n              for(int j=i+1;j<sz;j++)\\n                 {\\n                    vector<char>even2,odd2;\\n                      \\n                        for(int i=0;i<words[j].size();i++)\\n                         {\\n                        if(i%2==0)\\n                           even2.push_back(words[j][i]);\\n                        else\\n                           odd2.push_back(words[j][i]);\\n                         }\\n                    sort(even2.begin(),even2.end());\\n                    sort(odd2.begin(),odd2.end());\\n                    //compare all even postion char and odd char are same if same then push it into the vector and mark is as visited\\n                if(even1==even2 and odd1==odd2)\\n                   {\\n                     \\n                         \\n                       vis[j]=true;\\n                           // mp[i].push_back(j);                    \\n                   }\\n                 }\\n              //if no match found then push empty index in vector\\n                ct++;\\n            }\\n            return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966726,
                "title": "best-optimal-solution-linear",
                "content": "# Intuition\\nTricky Observation, if two strings have same characters then we can equate them using some swaps. No matter how many swaps we are going to use, but we can always equate them. Hence we are going to check characters present in odd and even places of two strings.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> mp ;\\n        for(auto x : words){\\n            string odd = \"\" , even = \"\" ;\\n            for(int i = 0; i <x.size() ; i++){\\n                if(i%2 == 0) even += x[i] ;\\n                else odd += x[i] ;\\n            }\\n            sort(odd.begin() , odd.end()) ;\\n            sort(even.begin(), even.end()) ;\\n            if(mp.find(odd+even) == mp.end()) mp.insert(odd+even) ;\\n        }\\n        return mp.size() ;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> mp ;\\n        for(auto x : words){\\n            string odd = \"\" , even = \"\" ;\\n            for(int i = 0; i <x.size() ; i++){\\n                if(i%2 == 0) even += x[i] ;\\n                else odd += x[i] ;\\n            }\\n            sort(odd.begin() , odd.end()) ;\\n            sort(even.begin(), even.end()) ;\\n            if(mp.find(odd+even) == mp.end()) mp.insert(odd+even) ;\\n        }\\n        return mp.size() ;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958495,
                "title": "best-easiest-solution-on-web-roght-now-i-am-a-genius",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        odd,even=\"\",\"\"\\n        final={}\\n        for i in words:\\n            for j in range(0,len(i)):\\n                if j%2==0:\\n                    even = even+i[j]\\n                else:\\n                    odd=odd+i[j]\\n            a = \"\".join(sorted(even)+sorted(odd))\\n            if a in final:\\n                final[a] = final[a]+1\\n            else:\\n                final[a]=1\\n            odd,even=\"\",\"\"\\n        return len(final)\\n                \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        odd,even=\"\",\"\"\\n        final={}\\n        for i in words:\\n            for j in range(0,len(i)):\\n                if j%2==0:\\n                    even = even+i[j]\\n                else:\\n                    odd=odd+i[j]\\n            a = \"\".join(sorted(even)+sorted(odd))\\n            if a in final:\\n                final[a] = final[a]+1\\n            else:\\n                final[a]=1\\n            odd,even=\"\",\"\"\\n        return len(final)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932744,
                "title": "straight-forward-solution-begineer-friendly-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Set<String>st=new HashSet<>();\\n        for(String word:words){\\n            StringBuilder odd=new StringBuilder();\\n            StringBuilder even=new StringBuilder();\\n\\n\\n            for(int i=0;i<word.length();i++){\\n                if(i%2==0){\\n                    even.append(word.charAt(i));\\n                }\\n                else{\\n                    odd.append(word.charAt(i));\\n                }\\n            }\\n            String oddstr=odd.toString();\\n            String evenstr=even.toString();\\n\\n            char oddarr[]=oddstr.toCharArray();\\n            char evenarr[]=evenstr.toCharArray();\\n            Arrays.sort(oddarr);\\n            Arrays.sort(evenarr);\\n\\n\\n            StringBuilder oddsorted=new StringBuilder(new String(oddarr));\\n            StringBuilder evensorted=new StringBuilder(new String(evenarr));\\n\\n            StringBuilder str=new StringBuilder();\\n            str.append(oddsorted);\\n            str.append(evensorted);\\n\\n            st.add(str.toString());\\n\\n\\n\\n\\n\\n        }\\n\\n\\n        return st.size();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Set<String>st=new HashSet<>();\\n        for(String word:words){\\n            StringBuilder odd=new StringBuilder();\\n            StringBuilder even=new StringBuilder();\\n\\n\\n            for(int i=0;i<word.length();i++){\\n                if(i%2==0){\\n                    even.append(word.charAt(i));\\n                }\\n                else{\\n                    odd.append(word.charAt(i));\\n                }\\n            }\\n            String oddstr=odd.toString();\\n            String evenstr=even.toString();\\n\\n            char oddarr[]=oddstr.toCharArray();\\n            char evenarr[]=evenstr.toCharArray();\\n            Arrays.sort(oddarr);\\n            Arrays.sort(evenarr);\\n\\n\\n            StringBuilder oddsorted=new StringBuilder(new String(oddarr));\\n            StringBuilder evensorted=new StringBuilder(new String(evenarr));\\n\\n            StringBuilder str=new StringBuilder();\\n            str.append(oddsorted);\\n            str.append(evensorted);\\n\\n            st.add(str.toString());\\n\\n\\n\\n\\n\\n        }\\n\\n\\n        return st.size();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882303,
                "title": "hashmap-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        gloss = {}\\n        answer = 0\\n        for w in words:\\n            ev = []\\n            od = []\\n            for i, ch in enumerate(w):\\n                if i%2==0:\\n                    ev.append(ch)\\n                else:\\n                    od.append(ch)\\n            k_ev = tuple(sorted(ev))\\n            v_ev = tuple(sorted(od))\\n            if k_ev in gloss:\\n                if v_ev not in gloss[k_ev]:\\n                    gloss[k_ev].append(v_ev)\\n                    answer += 1\\n            else:\\n                answer += 1\\n                gloss[k_ev] = [v_ev]\\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        gloss = {}\\n        answer = 0\\n        for w in words:\\n            ev = []\\n            od = []\\n            for i, ch in enumerate(w):\\n                if i%2==0:\\n                    ev.append(ch)\\n                else:\\n                    od.append(ch)\\n            k_ev = tuple(sorted(ev))\\n            v_ev = tuple(sorted(od))\\n            if k_ev in gloss:\\n                if v_ev not in gloss[k_ev]:\\n                    gloss[k_ev].append(v_ev)\\n                    answer += 1\\n            else:\\n                answer += 1\\n                gloss[k_ev] = [v_ev]\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848562,
                "title": "c-hash-table",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_map<string, int> Map;\\n        for(string word: words) {\\n            string odd = \"\";\\n            string even = \"\";\\n            for(int i = 0; i < word.length(); i++) {\\n                if(i % 2 == 0) even += word[i];\\n                else odd += word[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            ++Map[odd + even];\\n        }\\n        return Map.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_map<string, int> Map;\\n        for(string word: words) {\\n            string odd = \"\";\\n            string even = \"\";\\n            for(int i = 0; i < word.length(); i++) {\\n                if(i % 2 == 0) even += word[i];\\n                else odd += word[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            ++Map[odd + even];\\n        }\\n        return Map.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796458,
                "title": "python-simple-set",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        res = set()\\n        for w in words: res.add(\\'\\'.join(sorted(w[::2]) + sorted(w[1::2])))\\n        return len(res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        res = set()\\n        for w in words: res.add(\\'\\'.join(sorted(w[::2]) + sorted(w[1::2])))\\n        return len(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780585,
                "title": "java-beats-56",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            String evens = \"\";\\n            String odds = \"\";\\n            for (int i = 0; i < word.length(); i++) {\\n                if (i % 2 == 0) {\\n                    evens += String.valueOf(word.charAt(i));\\n                } else {\\n                    odds += String.valueOf(word.charAt(i));\\n                }\\n            }\\n            char[] evensChar = evens.toCharArray();\\n            Arrays.sort(evensChar);\\n            char[] oddsChar = odds.toCharArray();\\n            Arrays.sort(oddsChar);\\n            set.add(String.valueOf(evensChar) + String.valueOf(oddsChar));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            String evens = \"\";\\n            String odds = \"\";\\n            for (int i = 0; i < word.length(); i++) {\\n                if (i % 2 == 0) {\\n                    evens += String.valueOf(word.charAt(i));\\n                } else {\\n                    odds += String.valueOf(word.charAt(i));\\n                }\\n            }\\n            char[] evensChar = evens.toCharArray();\\n            Arrays.sort(evensChar);\\n            char[] oddsChar = odds.toCharArray();\\n            Arrays.sort(oddsChar);\\n            set.add(String.valueOf(evensChar) + String.valueOf(oddsChar));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736872,
                "title": "c-easy-solution-sorting-unordered-set-explanation",
                "content": "# EXPLANATION\\nCreated unordered set to store answer and deal with duplicates.\\nTraversed through words vector.\\nPushed the string in even position in **a** and odd positions in **b**.\\nSort string **a** and **b** and insert the combination of **a and b** in set.\\nFinally returned the size of set.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> s;\\n        for(auto x:words){\\n            string a,b;\\n            for(int i=0;i<x.size();i++){\\n                if(i%2==0)\\n                    a.push_back(x[i]);\\n                else\\n                    b.push_back(x[i]);\\n            }\\n            sort(a.begin(),a.end());\\n            sort(b.begin(),b.end());\\n            s.insert(a+b);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> s;\\n        for(auto x:words){\\n            string a,b;\\n            for(int i=0;i<x.size();i++){\\n                if(i%2==0)\\n                    a.push_back(x[i]);\\n                else\\n                    b.push_back(x[i]);\\n            }\\n            sort(a.begin(),a.end());\\n            sort(b.begin(),b.end());\\n            s.insert(a+b);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717598,
                "title": "groups-of-special-equivalent-strings-js-easy-solution",
                "content": "\\n\\n# JS Easy\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar numSpecialEquivGroups = function(words) {\\n    let set = new Set();\\n  let data = [];\\n  for (let i of words) {\\n    let temp = [...i];\\n    let even = [];\\n    let odd = [];\\n    temp.forEach((w, index) => {\\n      if (index % 2 == 0) {\\n        even.push(w);\\n      } else {\\n        odd.push(w);\\n      }\\n    });\\n    even.sort();\\n    odd.sort();\\n    let demo = [...even, ...odd];\\n    data.push(demo.join(\"\"));\\n  }\\n  data.forEach((a) => {\\n    set.add(a);\\n  });\\n  return set.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar numSpecialEquivGroups = function(words) {\\n    let set = new Set();\\n  let data = [];\\n  for (let i of words) {\\n    let temp = [...i];\\n    let even = [];\\n    let odd = [];\\n    temp.forEach((w, index) => {\\n      if (index % 2 == 0) {\\n        even.push(w);\\n      } else {\\n        odd.push(w);\\n      }\\n    });\\n    even.sort();\\n    odd.sort();\\n    let demo = [...even, ...odd];\\n    data.push(demo.join(\"\"));\\n  }\\n  data.forEach((a) => {\\n    set.add(a);\\n  });\\n  return set.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3704853,
                "title": "quite-ordinary-approach",
                "content": "# Approach\\nSpecial-Equivalent strings have the same elements in even positions, as well as the same elements in odd positions.\\n\\n# Complexity\\n- Time complexity: $$O(n*wordlen*log(wordlen))$$.\\n\\n- Space complexity: $$O(n*wordlen)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        W = len(words[0])\\n        groups = set()\\n        for word in words:\\n            even, odd = [], []\\n            for i in range(0, W, 2):\\n                even.append(word[i])\\n            for i in range(1, W, 2):\\n                odd.append(word[i])\\n\\n            groups.add(\\'\\'.join(chain(sorted(even), sorted(odd))))\\n\\n        return len(groups)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        W = len(words[0])\\n        groups = set()\\n        for word in words:\\n            even, odd = [], []\\n            for i in range(0, W, 2):\\n                even.append(word[i])\\n            for i in range(1, W, 2):\\n                odd.append(word[i])\\n\\n            groups.add(\\'\\'.join(chain(sorted(even), sorted(odd))))\\n\\n        return len(groups)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701491,
                "title": "c-easy-solution-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nw - words count\\nl - letters count\\n$$O(w * l)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] words) {\\n        var set = new HashSet<string>();\\n        foreach(var word in words)\\n        {\\n            var odd = new int[26];\\n            var even = new int[26];\\n            for (int i = 0; i < word.Length; i++)\\n            {\\n                if (i % 2 == 0)\\n                    even[word[i] - \\'a\\']++;\\n                else\\n                    odd[word[i] - \\'a\\']++;\\n            }\\n            set.Add(string.Concat(odd) + string.Concat(even));\\n        }\\n        return set.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] words) {\\n        var set = new HashSet<string>();\\n        foreach(var word in words)\\n        {\\n            var odd = new int[26];\\n            var even = new int[26];\\n            for (int i = 0; i < word.Length; i++)\\n            {\\n                if (i % 2 == 0)\\n                    even[word[i] - \\'a\\']++;\\n                else\\n                    odd[word[i] - \\'a\\']++;\\n            }\\n            set.Add(string.Concat(odd) + string.Concat(even));\\n        }\\n        return set.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646751,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        groups = set()\\n\\n        for x in words:\\n            counts = [0]*52\\n\\n            for i,x in enumerate(x):\\n                counts[ord(x)-ord(\\'a\\')+(26 if i%2 else 0)] += 1\\n            \\n            groups.add(tuple(counts))\\n        \\n        return len(groups)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        groups = set()\\n\\n        for x in words:\\n            counts = [0]*52\\n\\n            for i,x in enumerate(x):\\n                counts[ord(x)-ord(\\'a\\')+(26 if i%2 else 0)] += 1\\n            \\n            groups.add(tuple(counts))\\n        \\n        return len(groups)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620807,
                "title": "java-simple-solution-using-stringbuilder-and-lists",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        for(String word: words){\\n            StringBuilder sortedString = new StringBuilder();\\n            StringBuilder evenList = new StringBuilder();\\n            StringBuilder oddList = new StringBuilder();\\n            for(int i =0;i<word.length(); i++){\\n                if(i%2 == 0){\\n                    evenList.append(word.charAt(i));\\n                }\\n                else{\\n                    oddList.append(word.charAt(i));\\n                }\\n            }\\n            char evenArray[] = evenList.toString().toCharArray();\\n            Arrays.sort(evenArray);\\n            sortedString.append(evenArray);\\n            char oddArray[] = oddList.toString().toCharArray();\\n            Arrays.sort(oddArray);\\n            sortedString.append(oddArray);\\n            list.add(sortedString.toString());\\n        }\\n        return (int)list.stream().distinct().count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        for(String word: words){\\n            StringBuilder sortedString = new StringBuilder();\\n            StringBuilder evenList = new StringBuilder();\\n            StringBuilder oddList = new StringBuilder();\\n            for(int i =0;i<word.length(); i++){\\n                if(i%2 == 0){\\n                    evenList.append(word.charAt(i));\\n                }\\n                else{\\n                    oddList.append(word.charAt(i));\\n                }\\n            }\\n            char evenArray[] = evenList.toString().toCharArray();\\n            Arrays.sort(evenArray);\\n            sortedString.append(evenArray);\\n            char oddArray[] = oddList.toString().toCharArray();\\n            Arrays.sort(oddArray);\\n            sortedString.append(oddArray);\\n            list.add(sortedString.toString());\\n        }\\n        return (int)list.stream().distinct().count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611903,
                "title": "c-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set <string> st;\\n        for (auto w : words) {\\n            string odd, ev;\\n            for (int i = 0; i < w.size(); i++) {\\n                if (i%2==1)\\n                { ev += w[i];}\\n                else {\\n                odd += w[i];}\\n            }\\n            sort(odd.begin(),odd.end());\\n            sort(ev.begin(),ev.end());\\n            st.insert(odd+ev);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set <string> st;\\n        for (auto w : words) {\\n            string odd, ev;\\n            for (int i = 0; i < w.size(); i++) {\\n                if (i%2==1)\\n                { ev += w[i];}\\n                else {\\n                odd += w[i];}\\n            }\\n            sort(odd.begin(),odd.end());\\n            sort(ev.begin(),ev.end());\\n            st.insert(odd+ev);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574430,
                "title": "typescript-solution-using-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction numSpecialEquivGroups(words: string[]): number {\\n    const groups = {};\\n\\n    for (let word of words) {\\n        const map: Record<string, number> = {};\\n\\n        for (let i = 0; i < word.length; i++) {\\n            const hash = decode(word[i], i);\\n            map[hash] = map[hash] ?? 0;\\n            map[hash]++;\\n        }\\n\\n        const hash = decodeMappedWord(map)\\n\\n        groups[hash] = groups[hash] ?? true;\\n    }\\n\\n    return Object.keys(groups).length;\\n};\\n\\nfunction decode(letter: string, index: number): string {\\n    return `${letter}-${index % 2}`;\\n}\\n\\nfunction decodeMappedWord(map: Record<string,number>): string {\\n    return Object.keys(map).sort().reduce((acc, key) => acc + `${key}:${map[key]}`, \\'\\') \\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction numSpecialEquivGroups(words: string[]): number {\\n    const groups = {};\\n\\n    for (let word of words) {\\n        const map: Record<string, number> = {};\\n\\n        for (let i = 0; i < word.length; i++) {\\n            const hash = decode(word[i], i);\\n            map[hash] = map[hash] ?? 0;\\n            map[hash]++;\\n        }\\n\\n        const hash = decodeMappedWord(map)\\n\\n        groups[hash] = groups[hash] ?? true;\\n    }\\n\\n    return Object.keys(groups).length;\\n};\\n\\nfunction decode(letter: string, index: number): string {\\n    return `${letter}-${index % 2}`;\\n}\\n\\nfunction decodeMappedWord(map: Record<string,number>): string {\\n    return Object.keys(map).sort().reduce((acc, key) => acc + `${key}:${map[key]}`, \\'\\') \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567739,
                "title": "clean-easy-solution-explained-only-set-no-sort",
                "content": "If 2 strings are eqiv, then thier respective freq at even and odd indices must be same for the swap condition to be held true\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<pair<vector<int>,vector<int>>> s;\\n        for(auto &w:words)\\n        {\\n            vector<int> odd(26),even(26);\\n            for(int i=0;i<w.size();i++)\\n            {\\n                if(i%2) even[w[i]-\\'a\\']++;\\n                else odd[w[i]-\\'a\\']++;\\n            }\\n            s.insert({odd,even});\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<pair<vector<int>,vector<int>>> s;\\n        for(auto &w:words)\\n        {\\n            vector<int> odd(26),even(26);\\n            for(int i=0;i<w.size();i++)\\n            {\\n                if(i%2) even[w[i]-\\'a\\']++;\\n                else odd[w[i]-\\'a\\']++;\\n            }\\n            s.insert({odd,even});\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497603,
                "title": "hashset-string-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        int n = words.length;\\n        for(int i=0;i<n;i++){\\n            String t1=\"\",t2=\"\";\\n            List<Character> even = new ArrayList<>();\\n            List<Character> odd = new ArrayList<>();\\n            for(int j=0;j<words[i].length();j++){\\n               if(j%2==0) even.add(words[i].charAt(j));\\n               else odd.add(words[i].charAt(j));}\\n               Collections.sort(even);\\n               Collections.sort(odd);\\n               for(int k=0;k<even.size();k++){\\n                  t1 += even.get(k);\\n               }\\n               for(int k=0;k<odd.size();k++){\\n                  t2 += odd.get(k);\\n               }\\n           set.add(t1+t2);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        int n = words.length;\\n        for(int i=0;i<n;i++){\\n            String t1=\"\",t2=\"\";\\n            List<Character> even = new ArrayList<>();\\n            List<Character> odd = new ArrayList<>();\\n            for(int j=0;j<words[i].length();j++){\\n               if(j%2==0) even.add(words[i].charAt(j));\\n               else odd.add(words[i].charAt(j));}\\n               Collections.sort(even);\\n               Collections.sort(odd);\\n               for(int k=0;k<even.size();k++){\\n                  t1 += even.get(k);\\n               }\\n               for(int k=0;k<odd.size();k++){\\n                  t2 += odd.get(k);\\n               }\\n           set.add(t1+t2);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466282,
                "title": "faster-than-100-hashset",
                "content": "# Intuition\\nadd every word charracters in different strings odd and even, then sort them and add to the hashset, if they\\'ve not been already added\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nn - words count \\nw - letters count (max 20 due to description)\\nO(n * w^2 * log(w))\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] words) {\\n        HashSet<string> result = new HashSet<string>();\\n        foreach(string word in words)\\n        {\\n            string odd = \"\";\\n            string even = \"\";\\n            for (int i = 0; i < word.Length; i++)\\n            {\\n                if (i % 2 == 0) even += word[i];\\n                else odd+=word[i];\\n            }\\n            char[] odds = odd.ToCharArray();\\n            Array.Sort(odds);\\n            char[] evends = even.ToCharArray();\\n            Array.Sort(evends);\\n            string s = new string(odds) + new string(evends);\\n            result.Add(s);\\n        }\\n        return result.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] words) {\\n        HashSet<string> result = new HashSet<string>();\\n        foreach(string word in words)\\n        {\\n            string odd = \"\";\\n            string even = \"\";\\n            for (int i = 0; i < word.Length; i++)\\n            {\\n                if (i % 2 == 0) even += word[i];\\n                else odd+=word[i];\\n            }\\n            char[] odds = odd.ToCharArray();\\n            Array.Sort(odds);\\n            char[] evends = even.ToCharArray();\\n            Array.Sort(evends);\\n            string s = new string(odds) + new string(evends);\\n            result.Add(s);\\n        }\\n        return result.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433479,
                "title": "java-simple-and-clear-solution-with-hash-table-implementation",
                "content": "# Complexity\\n- Time complexity: O(n + m)\\n  - n is number of words\\n  - m is total length of all words \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int[] odds = new int[26];\\n    private int[] evens = new int[26];\\n    private  StringBuilder sb = new StringBuilder();\\n\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();   \\n  \\n        for(String s : words){\\n            String key = generateKey(s);\\n            map.put(key, map.getOrDefault(key, 0) + 1);\\n        }\\n\\n        return map.keySet().size();\\n    }\\n\\n    private String generateKey(String s){\\n        boolean isOdd = true;\\n        sb.setLength(0);\\n        \\n        for(int i = 0; i < 26; i++){\\n            odds[i]=0;\\n            evens[i]=0;\\n        }\\n\\n        for(char c : s.toCharArray()){\\n            if(isOdd)\\n                odds[c-\\'a\\']++;\\n            else\\n                evens[c -\\'a\\']++;\\n            isOdd = !isOdd;\\n        }\\n\\n        for(int i = 0; i < 26; i++){\\n            sb.append(odds[i]);\\n            sb.append(evens[i]);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    private int[] odds = new int[26];\\n    private int[] evens = new int[26];\\n    private  StringBuilder sb = new StringBuilder();\\n\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();   \\n  \\n        for(String s : words){\\n            String key = generateKey(s);\\n            map.put(key, map.getOrDefault(key, 0) + 1);\\n        }\\n\\n        return map.keySet().size();\\n    }\\n\\n    private String generateKey(String s){\\n        boolean isOdd = true;\\n        sb.setLength(0);\\n        \\n        for(int i = 0; i < 26; i++){\\n            odds[i]=0;\\n            evens[i]=0;\\n        }\\n\\n        for(char c : s.toCharArray()){\\n            if(isOdd)\\n                odds[c-\\'a\\']++;\\n            else\\n                evens[c -\\'a\\']++;\\n            isOdd = !isOdd;\\n        }\\n\\n        for(int i = 0; i < 26; i++){\\n            sb.append(odds[i]);\\n            sb.append(evens[i]);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427024,
                "title": "not-very-good-solution-but-i-hope-it-ll-help-you",
                "content": "![Screenshot 2023-04-17 162629.png](https://assets.leetcode.com/users/images/d2ff9101-1e00-4fe8-be8f-1a1e83aeaa31_1681737995.5241587.png)\\n\\nAs there is no solution in c# yet I hope this will help you to understand the question better.\\n# Code\\n```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] words) {\\n        int res = 0;\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            if (words[i] != \"\")\\n            {\\n                res++;\\n                List<char> evenCh = new();\\n                List<char> oddCh = new();\\n                for (int j = 0; j < words[i].Length; j++)\\n                {\\n                    if(j % 2 == 0)\\n                        evenCh.Add(words[i][j]);\\n                    else\\n                        oddCh.Add(words[i][j]);\\n                }\\n                for (int j = i + 1; j < words.Length; j++)\\n                {\\n                    List<char> tmp_evenCh = new List<char>(evenCh);\\n                    List<char> tmp_oddCh = new List<char>(oddCh);\\n                    bool add = true;\\n                    for (int k = 0; k < words[j].Length; k++)\\n                    {\\n                        if (k % 2 == 0 && tmp_evenCh.Contains(words[j][k]))\\n                        {\\n                            tmp_evenCh.Remove(words[j][k]);\\n                        }\\n                        else if(k % 2 == 0)\\n                        {\\n                            add = false;\\n                            break;\\n                        }\\n                        if(k % 2 == 1 && tmp_oddCh.Contains(words[j][k]))\\n                        {\\n                            tmp_oddCh.Remove(words[j][k]);\\n                        }\\n                        else if(k % 2 == 1)\\n                        {\\n                            add = false;\\n                            break;\\n                        }\\n                    }\\n                    if (add)\\n                    {\\n                        words[j] = \"\";\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] words) {\\n        int res = 0;\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            if (words[i] != \"\")\\n            {\\n                res++;\\n                List<char> evenCh = new();\\n                List<char> oddCh = new();\\n                for (int j = 0; j < words[i].Length; j++)\\n                {\\n                    if(j % 2 == 0)\\n                        evenCh.Add(words[i][j]);\\n                    else\\n                        oddCh.Add(words[i][j]);\\n                }\\n                for (int j = i + 1; j < words.Length; j++)\\n                {\\n                    List<char> tmp_evenCh = new List<char>(evenCh);\\n                    List<char> tmp_oddCh = new List<char>(oddCh);\\n                    bool add = true;\\n                    for (int k = 0; k < words[j].Length; k++)\\n                    {\\n                        if (k % 2 == 0 && tmp_evenCh.Contains(words[j][k]))\\n                        {\\n                            tmp_evenCh.Remove(words[j][k]);\\n                        }\\n                        else if(k % 2 == 0)\\n                        {\\n                            add = false;\\n                            break;\\n                        }\\n                        if(k % 2 == 1 && tmp_oddCh.Contains(words[j][k]))\\n                        {\\n                            tmp_oddCh.Remove(words[j][k]);\\n                        }\\n                        else if(k % 2 == 1)\\n                        {\\n                            add = false;\\n                            break;\\n                        }\\n                    }\\n                    if (add)\\n                    {\\n                        words[j] = \"\";\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386764,
                "title": "better-than-my-previous-version",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst, I noticed that two words are special equivalent iff their even characters are \"count equivalent\" and odd characters are \"count equivalent\", where two strings are \"count equivalent\" iff they have the same multiset of characters.  Two strings are \"count equivalent\" iff they are identical when their characters are sorted.  Second, when you want to count a number of objects subject to equivalence,\\nyou can use a ```set```. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first step is for each \"word\", to separate the even and the odd characters.  Then, for each of the two resulting strings, sort the characters in each, since two strings are \"count equivalent\" if their character-sorted versions are identical.  Then, count the number of pairs of the split, sorted words using a Set.  The function ```canon``` converts a word into a *canonical form* by splitting, sorting, and pairing.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time is at least proportional to the number of words.  Further, the sort inside ```canon``` is proportional to $$O(c log c)$$ where $$c$$ is the number of characters in each word.  The comparison used to maintain the set is $$O(c)$$.  The overall time complexity is $$O(n * c * log c)$$.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe only storage that grows is the set of canonicalized representations, which is proportional in the worst case to $$O(n * c)$$.\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        groupCanons = set()\\n        for word in words:\\n            wordCanon = self.canon( word )\\n            groupCanons.add( wordCanon )\\n        return len( groupCanons )\\n    \\n    # Convert \"word\" into canonical form, which is the sorted\\n    # even characters and the sorted odd characters in \"word\":\\n    def canon( self, word ):\\n        result = ( \\'\\'.join( sorted( word[ 0::2] ) ), \\'\\'.join( sorted( word[1::2] ) ) )\\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```set```\n```canon```\n```canon```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        groupCanons = set()\\n        for word in words:\\n            wordCanon = self.canon( word )\\n            groupCanons.add( wordCanon )\\n        return len( groupCanons )\\n    \\n    # Convert \"word\" into canonical form, which is the sorted\\n    # even characters and the sorted odd characters in \"word\":\\n    def canon( self, word ):\\n        result = ( \\'\\'.join( sorted( word[ 0::2] ) ), \\'\\'.join( sorted( word[1::2] ) ) )\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386492,
                "title": "simple-code-but-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thing I looked at was the even<->even and odd<->odd aspect of the definition of special equivalence.  I realized that two words w1 and w2 were special equivalent iff their even characters were special equivalent *and* their odd characters were special equivalent, since even and odd characters could never be swapped.  Next, I realized that two strings are special equivalent iff their character frequencies are the same.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI defined a function ```canon``` that maps an original \"word\" into a 2-tuple consisting of the character frequencies of even characters and character frequencies of odd characters.  Two words were then special equivalent iff their canonical representations are equal (thanks! to Python for making it so easy to compare 2-tuples of Counters).  Then it was a matter of counting how many distinct canonical representations were found; this was a little painful, since it involved an $$O(n)$$ loop that results in quadratic time complexity.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs noted above, the time complexity is proportional to $$O(n^2)$$.  There is an additional factor:  the canonicalization and comparisons in the counting loop are $$O(c)$$ where $$c$$ is the number of characters in each word.  Thus the overall time complexity is $$O(n^2*c)$$.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe storage cost for one canonical representation is $$O(c)$$, and we may have to store up to $$O(n)$$ canonical representations if none of the words are special-equivalent, making the overall space complexity $$O(n*c)$$.\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        groupCanons = []\\n        for word in words:\\n            wordCanon = self.canon( word )\\n            found = False\\n            for groupCanon in groupCanons:\\n                if groupCanon == wordCanon:\\n                    found = True\\n                    break\\n            if not found:\\n                groupCanons.append( wordCanon )\\n        return len( groupCanons )\\n    \\n    # Convert \"word\" into canonical form, which is the letter\\n    # frequency of even characters and letter frequency of\\n    # odd characters in \"word\":\\n    def canon( self, word ):\\n        result = ( Counter( word[ 0::2] ), Counter( word[1::2] ) )\\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```canon```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        groupCanons = []\\n        for word in words:\\n            wordCanon = self.canon( word )\\n            found = False\\n            for groupCanon in groupCanons:\\n                if groupCanon == wordCanon:\\n                    found = True\\n                    break\\n            if not found:\\n                groupCanons.append( wordCanon )\\n        return len( groupCanons )\\n    \\n    # Convert \"word\" into canonical form, which is the letter\\n    # frequency of even characters and letter frequency of\\n    # odd characters in \"word\":\\n    def canon( self, word ):\\n        result = ( Counter( word[ 0::2] ), Counter( word[1::2] ) )\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384648,
                "title": "c-unordered-set-hash-table-sort-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can group words that are special equivalent by sorting their even-indexed and odd-indexed characters separately and then concatenating them back together. We can use an unordered set to keep track of the unique groups of special equivalent words.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each word in the input vector, we can extract the even-indexed characters and odd-indexed characters separately using a for loop with a step of 2. We can then sort both substrings and concatenate them back together to form a unique key. We can insert this key into an unordered set to keep track of the unique groups of special equivalent words. Finally, we can return the size of the unordered set as the number of special equivalent groups.\\n\\n# Complexity\\n- Time complexity: $$O(n * k * log(k))$$\\nwhere n is the number of words in the input vector, and k is the maximum length of a word in the input vector. We iterate through the input vector once, and for each word, we sort the even-indexed characters and odd-indexed characters separately, which takes O(k*log(k)) time.\\n\\n- Space complexity: $$O(n * k)$$\\nwhere n is the number of words in the input vector, and k is the maximum length of a word in the input vector. We store each sorted key in the unordered set, which takes O(k) space, and we may have up to n unique keys in the unordered set.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> st;\\n        for (auto& w : words) {\\n            string odd, even;\\n            for (int i = 0; i < w.size(); i++) {\\n                if (i % 2) even += w[i];\\n                else odd += w[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            st.insert(even + odd);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> st;\\n        for (auto& w : words) {\\n            string odd, even;\\n            for (int i = 0; i < w.size(); i++) {\\n                if (i % 2) even += w[i];\\n                else odd += w[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            st.insert(even + odd);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373279,
                "title": "i-dare-you-to-read-this-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        map<map<char,pair<int,int>>,string> mp;\\n\\n        for(int i = 0; i<words.size(); i++){\\n            map<char,pair<int,int>> m1;\\n            for(int j = 0; j<words[0].size(); j++){\\n                if(j%2 == 0) m1[words[i][j]].first++;\\n                else m1[words[i][j]].second++;\\n            }\\n            mp[m1] = words[i];\\n        }\\n\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        map<map<char,pair<int,int>>,string> mp;\\n\\n        for(int i = 0; i<words.size(); i++){\\n            map<char,pair<int,int>> m1;\\n            for(int j = 0; j<words[0].size(); j++){\\n                if(j%2 == 0) m1[words[i][j]].first++;\\n                else m1[words[i][j]].second++;\\n            }\\n            mp[m1] = words[i];\\n        }\\n\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364646,
                "title": "c-set-with-explanation",
                "content": "# **Please upvote and give feedback into comment**\\n\\n---\\n\\n\\n# Approach\\n\\n---\\n\\n\\nwe take set for uniqueness and store the one element from the pair(\"abcd\", \"cdba\") and return the length of set \\n\\n1. we add all the even string even=a+c , even =c+a  and odd string odd=b+d,odd=d+b \\n2. sort even and odd string \\n3. total=even +odd and store total into set and return the length of set\\n\\n---\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<string>res;\\n       \\n        for(auto i:words)\\n        {\\n                string even=\"\",odd=\"\",tot=\"\";\\n                for (int j=0;j<i.size();j++)\\n                {\\n                    if(j%2==0)\\n                    {\\n                        even+=i[j];\\n                    }\\n                    else\\n                    {\\n                        odd+=i[j];\\n                    }\\n                }\\n                sort(even.begin(),even.end());\\n                sort(odd.begin(),odd.end());\\n            tot=even+odd;\\n            res.insert(tot);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<string>res;\\n       \\n        for(auto i:words)\\n        {\\n                string even=\"\",odd=\"\",tot=\"\";\\n                for (int j=0;j<i.size();j++)\\n                {\\n                    if(j%2==0)\\n                    {\\n                        even+=i[j];\\n                    }\\n                    else\\n                    {\\n                        odd+=i[j];\\n                    }\\n                }\\n                sort(even.begin(),even.end());\\n                sort(odd.begin(),odd.end());\\n            tot=even+odd;\\n            res.insert(tot);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326597,
                "title": "python-hashmap-set-tuple",
                "content": "The trick here is that we create an array of size 52 to count occurances the first half being our characters that are even and the second half characters that are odd.\\n\\nOnce we have this we need to convert it into a tuple so it can be used as a key and we add it to our map/set.\\n\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        \\n        #solved using a tuple of size 52 to hold all of the alpha characters * 2 \\n        #the second half being used to hold odd and the first half to hold even\\n        mp = defaultdict(int)\\n        #tuple the size of 52\\n        for i in range(len(words)):\\n            a = [0] * 52\\n            for j in range(len(words[i])):\\n                char = words[i][j]\\n                if j % 2 == 0:\\n                    v = ord(char) - ord(\\'a\\')\\n                    a[v] += 1\\n                else:\\n                    v = ord(char) - ord(\\'a\\')\\n                    v += 26\\n                    a[v] +=1\\n            \\n            mp[tuple(a)] += 1\\n            \\n        \\n        \\n        return len(mp)\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "The trick here is that we create an array of size 52 to count occurances the first half being our characters that are even and the second half characters that are odd.\\n\\nOnce we have this we need to convert it into a tuple so it can be used as a key and we add it to our map/set.\\n\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        \\n        #solved using a tuple of size 52 to hold all of the alpha characters * 2 \\n        #the second half being used to hold odd and the first half to hold even\\n        mp = defaultdict(int)\\n        #tuple the size of 52\\n        for i in range(len(words)):\\n            a = [0] * 52\\n            for j in range(len(words[i])):\\n                char = words[i][j]\\n                if j % 2 == 0:\\n                    v = ord(char) - ord(\\'a\\')\\n                    a[v] += 1\\n                else:\\n                    v = ord(char) - ord(\\'a\\')\\n                    v += 26\\n                    a[v] +=1\\n            \\n            mp[tuple(a)] += 1\\n            \\n        \\n        \\n        return len(mp)\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 3302555,
                "title": "simple-java-solution-runtime-11ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n     Set<String>set=new HashSet<>();\\n     \\n     for(String word:words)\\n     {\\n         String even=\"\",odd=\"\";\\n         for(int i=0;i<word.length();i++)\\n         {\\n             if(i%2==0)\\n             {\\n                 even+=word.charAt(i);\\n             }\\n             else{\\n                 odd+=word.charAt(i);\\n             }\\n\\n         }\\n\\n         odd=sorted(odd);\\n         even=sorted(even);\\n         set.add(odd+even);\\n     } \\n     return set.size();  \\n    }\\n\\n    public String sorted(String s )\\n    {\\n        char[] c=s.toCharArray();\\n        Arrays.sort(c);\\n        return String.valueOf(c);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n     Set<String>set=new HashSet<>();\\n     \\n     for(String word:words)\\n     {\\n         String even=\"\",odd=\"\";\\n         for(int i=0;i<word.length();i++)\\n         {\\n             if(i%2==0)\\n             {\\n                 even+=word.charAt(i);\\n             }\\n             else{\\n                 odd+=word.charAt(i);\\n             }\\n\\n         }\\n\\n         odd=sorted(odd);\\n         even=sorted(even);\\n         set.add(odd+even);\\n     } \\n     return set.size();  \\n    }\\n\\n    public String sorted(String s )\\n    {\\n        char[] c=s.toCharArray();\\n        Arrays.sort(c);\\n        return String.valueOf(c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275835,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) \\n    {\\n        unordered_map<string ,int>u;\\n       for(int i=0;i<w.size();++i)\\n       {\\n           string s1=\"\",s2=\"\";\\n           for(int j=0;j<w[i].length();++j)\\n           {\\n               if(j%2!=0)\\n                   s2.push_back(w[i][j]);\\n               else\\n                   s1.push_back(w[i][j]);\\n           }\\n           sort(s1.begin(),s1.end());\\n           sort(s2.begin(),s2.end());\\n           int k=0;\\n           for(int j=0;j<w[i].length();++j)\\n           {\\n               if(j%2!=0)\\n                   w[i][j]=s2[k++];\\n               else\\n                 w[i][j]=s1[k];\\n           }\\n           ++u[w[i]];\\n       }\\n        int c=0;\\n        for(auto a:u)\\n        {\\n            ++c;\\n            \\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) \\n    {\\n        unordered_map<string ,int>u;\\n       for(int i=0;i<w.size();++i)\\n       {\\n           string s1=\"\",s2=\"\";\\n           for(int j=0;j<w[i].length();++j)\\n           {\\n               if(j%2!=0)\\n                   s2.push_back(w[i][j]);\\n               else\\n                   s1.push_back(w[i][j]);\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 3255268,
                "title": "python3-one-liner-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        return len(Counter([\"\".join(sorted(w[1::2]) + sorted(w[::2])) for w in words]))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        return len(Counter([\"\".join(sorted(w[1::2]) + sorted(w[::2])) for w in words]))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238916,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string>Set ;\\n        for(auto& word : words)\\n        {\\n            string even, odd ;\\n            for(int i = 0; i < word.size(); i++)\\n            {\\n                if(i % 2)\\n                    odd.push_back(word[i]) ;\\n                else\\n                    even.push_back(word[i]) ;\\n            }\\n            sort(even.begin(), even.end()) ;\\n            sort(odd.begin(), odd.end()) ;\\n            Set.insert(even + odd) ;\\n        }\\n        return Set.size() ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string>Set ;\\n        for(auto& word : words)\\n        {\\n            string even, odd ;\\n            for(int i = 0; i < word.size(); i++)\\n            {\\n                if(i % 2)\\n                    odd.push_back(word[i]) ;\\n                else\\n                    even.push_back(word[i]) ;\\n            }\\n            sort(even.begin(), even.end()) ;\\n            sort(odd.begin(), odd.end()) ;\\n            Set.insert(even + odd) ;\\n        }\\n        return Set.size() ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205327,
                "title": "rust-0ms",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn num_special_equiv_groups(words: Vec<String>) -> i32 {\\n        use std::collections::HashSet;\\n        words\\n            .into_iter()\\n            .map(|w| {\\n                let (mut even, mut odd) = (vec![0; 26], vec![0; 26]);\\n                for (i, ch) in w.chars().enumerate() {\\n                    let idx = ch as usize - \\'a\\' as usize;\\n                    if i % 2 == 0 {\\n                        even[idx] += 1;\\n                    } else {\\n                        odd[idx] += 1;\\n                    }\\n                }\\n                (even, odd)\\n            })\\n            .fold(HashSet::new(), |mut acc, k| {\\n                acc.insert(k);\\n                acc\\n            })\\n            .len() as i32   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_special_equiv_groups(words: Vec<String>) -> i32 {\\n        use std::collections::HashSet;\\n        words\\n            .into_iter()\\n            .map(|w| {\\n                let (mut even, mut odd) = (vec![0; 26], vec![0; 26]);\\n                for (i, ch) in w.chars().enumerate() {\\n                    let idx = ch as usize - \\'a\\' as usize;\\n                    if i % 2 == 0 {\\n                        even[idx] += 1;\\n                    } else {\\n                        odd[idx] += 1;\\n                    }\\n                }\\n                (even, odd)\\n            })\\n            .fold(HashSet::new(), |mut acc, k| {\\n                acc.insert(k);\\n                acc\\n            })\\n            .len() as i32   \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3192615,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func numSpecialEquivGroups(_ words: [String]) -> Int {\\n        Set(\\n            words\\n                .map { w -> String in\\n                    let cs = w.map { $0 }\\n                    let es = cs.indices.filter({ $0 % 2 == 0 }).map({ cs[$0] })\\n                    let os = cs.indices.filter({ $0 % 2 == 1 }).map({ cs[$0] })\\n                    return String(es.sorted() + os.sorted())\\n                }\\n        ).count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numSpecialEquivGroups(_ words: [String]) -> Int {\\n        Set(\\n            words\\n                .map { w -> String in\\n                    let cs = w.map { $0 }\\n                    let es = cs.indices.filter({ $0 % 2 == 0 }).map({ cs[$0] })\\n                    let os = cs.indices.filter({ $0 % 2 == 1 }).map({ cs[$0] })\\n                    return String(es.sorted() + os.sorted())\\n                }\\n        ).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169209,
                "title": "c-solution-using-map-and-set",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        set<pair<map<char,int>,map<char,int>>>s;\\n        for(int i=0;i<w.size();++i){\\n            map<char,int>odd;\\n            map<char,int>even;\\n            for(int j=0;j<w[i].size();++j){\\n                if(j%2==0)\\n                   even[w[i][j]]++;\\n                else\\n                   odd[w[i][j]]++;\\n            }\\n            s.insert({even,odd});\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        set<pair<map<char,int>,map<char,int>>>s;\\n        for(int i=0;i<w.size();++i){\\n            map<char,int>odd;\\n            map<char,int>even;\\n            for(int j=0;j<w[i].size();++j){\\n                if(j%2==0)\\n                   even[w[i][j]]++;\\n                else\\n                   odd[w[i][j]]++;\\n            }\\n            s.insert({even,odd});\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142211,
                "title": "simple-and-concise-beats-98-c-set-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<string> res;\\n        for(auto s:words)\\n        {\\n            string ev = \"\";\\n            string od = \"\";\\n            for(int i = 0;i<s.size();i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ev = ev+s[i];\\n                }\\n                else\\n                    od = od+s[i];\\n            }\\n            sort(ev.begin(), ev.end());\\n            sort(od.begin(), od.end());\\n            string final_str = ev+od;\\n            if(res.count(final_str)==0)\\n                res.insert(final_str);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<string> res;\\n        for(auto s:words)\\n        {\\n            string ev = \"\";\\n            string od = \"\";\\n            for(int i = 0;i<s.size();i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ev = ev+s[i];\\n                }\\n                else\\n                    od = od+s[i];\\n            }\\n            sort(ev.begin(), ev.end());\\n            sort(od.begin(), od.end());\\n            string final_str = ev+od;\\n            if(res.count(final_str)==0)\\n                res.insert(final_str);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140656,
                "title": "easy-direct-approach",
                "content": "# Approach\\nuse the brute force approach as the parameters are comfortable in doing that.\\nStore the map of even and odd words count of each words and compare them using a brute force method.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        vector<unordered_map<char,int>> a(words.size()),b(words.size());\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(int j = 0;j<words[i].size();j=j+2)\\n            {\\n                a[i][words[i][j]]++;\\n            }\\n            for(int j = 1;j<words[i].size();j=j+2)\\n            {\\n                b[i][words[i][j]]++;\\n            }\\n        }\\n        int ans = 0 ;\\n        for(int k = 0 ; k<words.size()-1;k++)\\n        {\\n            if(words[k]!=\" \")\\n            {\\n                for(int j=k+1;j<words.size();j++)\\n                {\\n                    if(words[j]!=\" \")\\n                    {\\n                        \\n                        if(a[k]==a[j] and b[k]==b[j])\\n                        {\\n                            ans++;\\n                            words[j] = \" \";\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return words.size() - ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        vector<unordered_map<char,int>> a(words.size()),b(words.size());\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(int j = 0;j<words[i].size();j=j+2)\\n            {\\n                a[i][words[i][j]]++;\\n            }\\n            for(int j = 1;j<words[i].size();j=j+2)\\n            {\\n                b[i][words[i][j]]++;\\n            }\\n        }\\n        int ans = 0 ;\\n        for(int k = 0 ; k<words.size()-1;k++)\\n        {\\n            if(words[k]!=\" \")\\n            {\\n                for(int j=k+1;j<words.size();j++)\\n                {\\n                    if(words[j]!=\" \")\\n                    {\\n                        \\n                        if(a[k]==a[j] and b[k]==b[j])\\n                        {\\n                            ans++;\\n                            words[j] = \" \";\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return words.size() - ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133726,
                "title": "c-map-and-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_map<string, int> m;\\n        for (auto& s : words){\\n            string odd = \"\";\\n            string even = \"\";\\n            for (int i = 0; i < s.size(); ++i){\\n                if (i % 2 == 0) even += s[i];\\n                else odd += s[i];\\n            }\\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            ++m[odd + even];\\n        }\\n        return m.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_map<string, int> m;\\n        for (auto& s : words){\\n            string odd = \"\";\\n            string even = \"\";\\n            for (int i = 0; i < s.size(); ++i){\\n                if (i % 2 == 0) even += s[i];\\n                else odd += s[i];\\n            }\\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            ++m[odd + even];\\n        }\\n        return m.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131918,
                "title": "easiest-solution-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        map<pair<string,string>,int> mp;\\n        for(auto &i:words){\\n            string t = \"\",s=\"\";\\n            for(int j=0;j<i.length();j++){\\n                if(j%2) s+=i[j];\\n                else t+=i[j];\\n            }\\n            sort(t.begin(),t.end()),sort(s.begin(),s.end());\\n            pair<string,string> pr = {t,s};\\n            mp[pr]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        map<pair<string,string>,int> mp;\\n        for(auto &i:words){\\n            string t = \"\",s=\"\";\\n            for(int j=0;j<i.length();j++){\\n                if(j%2) s+=i[j];\\n                else t+=i[j];\\n            }\\n            sort(t.begin(),t.end()),sort(s.begin(),s.end());\\n            pair<string,string> pr = {t,s};\\n            mp[pr]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122297,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<pair<string,string>>st;\\n        for(int i=0;i<words.size();i++){\\n            string emp=\"\",omp=\"\";\\n            for(int j=0;j<words[i].size();j+=2)\\n            emp+=words[i][j];\\n            for(int j=1;j<words[i].size();j+=2)\\n            omp+=words[i][j];\\n            sort(emp.begin(),emp.end());\\n            sort(omp.begin(),omp.end());\\n            st.insert({emp,omp});\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<pair<string,string>>st;\\n        for(int i=0;i<words.size();i++){\\n            string emp=\"\",omp=\"\";\\n            for(int j=0;j<words[i].size();j+=2)\\n            emp+=words[i][j];\\n            for(int j=1;j<words[i].size();j+=2)\\n            omp+=words[i][j];\\n            sort(emp.begin(),emp.end());\\n            sort(omp.begin(),omp.end());\\n            st.insert({emp,omp});\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106915,
                "title": "c-short-easy-solution",
                "content": "Approach:-\\n\\nwe first keep odd and even indexes character seperate and the sort it and then put in set\\nso we get only unique words that is answer\\n\\n\\n\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        set<string>s;\\n        for(int i=0;i<w.size();i++){\\n            string e=\"\",o=\"\";\\n            for(int j=0;j<w[i].size();j++){\\n                if(j%2==0)\\n                    e+=w[i][j];\\n                else\\n                    o+=w[i][j];\\n            }\\n            sort(e.begin(),e.end());\\n            sort(o.begin(),o.end());\\n            s.insert(o+e);\\n        }\\n        return s.size();\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        set<string>s;\\n        for(int i=0;i<w.size();i++){\\n            string e=\"\",o=\"\";\\n            for(int j=0;j<w[i].size();j++){\\n                if(j%2==0)\\n                    e+=w[i][j];\\n                else\\n                    o+=w[i][j];\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564644,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1565190,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1573918,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1568182,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1567392,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1569321,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1568050,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1572660,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1572130,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1572110,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1564644,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1565190,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1573918,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1568182,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1567392,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1569321,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1568050,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1572660,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1572130,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1572110,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sum of Mutated Array Closest to Target",
        "question_content": "<p>Given an integer array <code>arr</code> and a target value <code>target</code>, return the integer <code>value</code> such that when we change all the integers larger than <code>value</code> in the given array to be equal to <code>value</code>, the sum of the array gets as close as possible (in absolute difference) to <code>target</code>.</p>\n\n<p>In case of a tie, return the minimum such integer.</p>\n\n<p>Notice that the answer is not neccesarilly a number from <code>arr</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [4,9,3], target = 10\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> When using 3 arr converts to [3, 3, 3] which sums 9 and that&#39;s the optimal answer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [2,3,5], target = 10\n<strong>Output:</strong> 5\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [60864,25176,27249,21296,20204], target = 56803\n<strong>Output:</strong> 11361\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= arr[i], target &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 463306,
                "title": "java-c-python-just-sort-o-nlogn",
                "content": "## **Explanation**\\nBinary search is `O(NlogMax(A))`.\\nIn order to ruduce the difficulty, it constrains `A[i] < 10 ^ 5`.\\n\\nIn this solution,\\nwe sort the input and compared `A[i]` with target one by one.\\n\\n1. Sort the array `A` in decreasing order.\\n2. We try to make all values in `A` to be the `min(A)` (the last element)\\n3. If `target >= min(A) * n`, we doesn\\'t hit our target yet.\\nWe should continue to try a value bigger.\\n4. So we pop the `min(A)` value.\\nConsider that it won\\'t be affected anymore,\\nwe can remove it from target by `target -= A.pop()`\\n5. We continue doing step 2-4, until the next number is too big for target.\\n6. We split the the target evenly, depending on the number of element left in `A`\\n\\n\\nAt this point, @bobalice help explain the round part:\\nif A is empty means its impossible to reach target so we just return maximum element.\\nIf A is not empty, intuitively the answer should be the nearest integer to `target / len(A)`.\\n\\nSince we need to return the minimum such integer if there is a tie,\\nif `target / len(A)` has `0.5` we should round down,\\n<br>\\n\\n## **Complexity**\\nTime `O(NlogN)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int findBestValue(int[] A, int target) {\\n        Arrays.sort(A);\\n        int n = A.length, i = 0;\\n        while (i < n && target > A[i] * (n - i)) {\\n            target -= A[i++];\\n        }\\n        if (i == n) return A[n - 1];\\n        int res = target / (n - i);\\n        if (target - res * (n - i) > (res + 1) * (n - i) - target)\\n            res++;\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int findBestValue(vector<int>& A, int target) {\\n        sort(A.begin(), A.end());\\n        int n = A.size(), i = 0;\\n        while (i < n && target > A[i] * (n - i))\\n            target -= A[i++];\\n        return i == n ? A[n - 1] : int(round((target - 0.0001) / (n - i)));\\n    }\\n```\\n**Python:**\\n```py\\n    def findBestValue(self, A, target):\\n        A.sort(reverse=1)\\n        maxA = A[0]\\n        while A and target >= A[-1] * len(A):\\n            target -= A.pop()\\n        return int(round((target - 0.0001) / len(A))) if A else maxA\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int findBestValue(int[] A, int target) {\\n        Arrays.sort(A);\\n        int n = A.length, i = 0;\\n        while (i < n && target > A[i] * (n - i)) {\\n            target -= A[i++];\\n        }\\n        if (i == n) return A[n - 1];\\n        int res = target / (n - i);\\n        if (target - res * (n - i) > (res + 1) * (n - i) - target)\\n            res++;\\n        return res;\\n    }\\n```\n```cpp\\n    int findBestValue(vector<int>& A, int target) {\\n        sort(A.begin(), A.end());\\n        int n = A.size(), i = 0;\\n        while (i < n && target > A[i] * (n - i))\\n            target -= A[i++];\\n        return i == n ? A[n - 1] : int(round((target - 0.0001) / (n - i)));\\n    }\\n```\n```py\\n    def findBestValue(self, A, target):\\n        A.sort(reverse=1)\\n        maxA = A[0]\\n        while A and target >= A[-1] * len(A):\\n            target -= A.pop()\\n        return int(round((target - 0.0001) / len(A))) if A else maxA\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 463268,
                "title": "java-c-4ms-binary-search-short-readable-code-sorting-solution",
                "content": "# Binary search solution\\nSee also a sorting solution below.\\n\\nThe value we are looking for is somewhere between 1 and maxValue (```m```).\\nNow use Binary search to speed up the process.\\n* go up if the sum is too small\\n* go down if the sum is too big\\n\\nWhen we are done with binary search, ```l``` and ```r``` are equal, but it might happen that we have not exactly reached the target.\\nCheck if ```l-1``` (should get us below the ```target```) leads to the ```sum``` closer to the ```target```.\\n\\nJava, 4ms:\\n```java\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int l, r, mi, s=0, m=-1;\\n        for(int v:arr) { s += v; m=Math.max(m,v); }\\n\\n        if(s<=target) return m; // return the max value since we will keep all nums as is\\n\\n        for(l=1,r=m;l<r;) {\\n            mi=(l+r)/2;\\n            s=0;\\n            for(int v:arr) s += (v>mi)?mi:v;\\n            if(s>=target) r=mi;\\n            else          l=mi+1;\\n        }\\n        // check if we are 1 step off the target \\n        int s1=0,s2=0;\\n        for(int v:arr) {\\n            s1 += (v>l)?(l):v;\\n            s2 += (v>l-1)?(l-1):v;\\n        }\\n        \\n        return (Math.abs(s2-target) <= Math.abs(s1-target)) ? l-1 : l;\\n    }\\n}\\n```\\n\\nC++, 16ms\\n```cpp\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l, r, mi, s=0, m=-1;\\n        for(int v:arr) s += v, m=max(m,v);\\n\\n        if(s<=target) return m; // return the max value since we will keep all nums as is\\n\\n        for(l=1,r=m;l<r;) {\\n            mi=(l+r)/2;\\n            s=0;\\n            for(int v:arr) s += (v>mi)?mi:v;\\n            if(s>=target) r=mi;\\n            else          l=mi+1;\\n        }\\n        // check if we are 1 step off the target \\n        int s1=0,s2=0;\\n        for(int v:arr) s1 += (v>l)?(l):v, s2 += (v>l-1)?(l-1):v;\\n        \\n        return (abs(s2-target) <= abs(s1-target)) ? l-1 : l;\\n    }\\n};\\n```\\n\\n**UPDATE:**\\n# Sorting solution\\n \\nI got comments that sorting solution can be more intuitive. It\\'s maybe shorter but binary search is easier to apply as a pattern (at least for me). \\nWell, sorting leads to O(NLogN) speed while binary search gives O(NLog(Max(A))) so it\\'s similar.\\nHowever, in practice It\\'s slightly slower on given tests. \\n\\nIntuition:\\n  - We will need to replace the highest values with some value ```v```\\n  - ```v``` must be >= the highest value of the array. In other words: ```v >= max(arr)```\\n  - We should pop the highest value from arr while the current result is above the target: \\n   ```while(target < sum + max(arr)*numOfRemoved)```\\n  - Sorting is done to speed up the search for the higest values\\n  - Then we simply calculate ```v``` to replace each removed element and get as close to the ```target``` as possible\\n\\nIn the end of \"pop high values\" process we will split the sorted array in 2 parts:\\n```cpp\\n          Splitted the sorted values to left and right parts:\\n          a,b,c,d   |   X,Y,Z\\n          -------       =====\\n          keep          replace each elem\\n          as is         with v\\n  sum:    =sum-X-Y-Z    =v*numOfElems \\n          left part + right part = target\\n```\\nValues in the left part will stay as is. Their sum is the ```total sum - sum of the removed```.\\nValues in the right part will be replaced with ```v``` and we keep their number in ```removed```.\\n```cpp\\nleft part + right part = target\\nleft part + v*removed  = target\\nv = (target - left part)/removed\\n``` \\nWhen we do the division, ```v``` is rounded down. I check also ```v+1``` to cover the undesired rounding though I\\'m pretty sure that a sophisticated formula can do the same shorter (I prefer simpler things).\\n\\nJava, 5ms\\n```java\\n    public int findBestValue(int[] arr, int target) {\\n        int s=0, m=-1;\\n        for(int v:arr) { s += v; m=Math.max(m,v); }\\n        if(s<=target) return m; // return the max value since we will keep all nums as is\\n\\n        Arrays.sort(arr);\\n        \\n        int removed=0, lastIx=arr.length-1;\\n        while(lastIx>=0 && target < s + removed*arr[lastIx]) {\\n            removed++;\\n            s -= arr[lastIx];\\n            lastIx--;\\n        }\\n        int v=(target-s)/removed; // rounded down\\n        if(Math.abs(target-s-removed*v) <=\\n           Math.abs(target-s-removed*(v+1))) // check v+1 to compensate round down\\n            return v;\\n        return v+1;\\n    }\\n```\\n\\nC++, 24ms\\n```cpp\\n    int findBestValue(vector<int>& arr, int target) {\\n        int s=0, m=-1;\\n        for(int v:arr) s += v, m=max(m,v);\\n        if(s<=target) return m; // return the max value since we will keep all nums as is\\n\\n        sort(arr.begin(),arr.end());\\n        \\n        int removed=0, lastIx=arr.size()-1;\\n        while(lastIx>=0 && target < s + removed*arr[lastIx]) {\\n            removed++;\\n            s -= arr[lastIx];\\n            lastIx--;\\n        }\\n        int v=(target-s)/removed; // rounded down\\n        if(abs(target-s-removed*v) <=\\n           abs(target-s-removed*(v+1))) // check v+1 to compensate round down\\n            return v;\\n        return v+1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```m```\n```l```\n```r```\n```l-1```\n```target```\n```sum```\n```target```\n```java\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int l, r, mi, s=0, m=-1;\\n        for(int v:arr) { s += v; m=Math.max(m,v); }\\n\\n        if(s<=target) return m; // return the max value since we will keep all nums as is\\n\\n        for(l=1,r=m;l<r;) {\\n            mi=(l+r)/2;\\n            s=0;\\n            for(int v:arr) s += (v>mi)?mi:v;\\n            if(s>=target) r=mi;\\n            else          l=mi+1;\\n        }\\n        // check if we are 1 step off the target \\n        int s1=0,s2=0;\\n        for(int v:arr) {\\n            s1 += (v>l)?(l):v;\\n            s2 += (v>l-1)?(l-1):v;\\n        }\\n        \\n        return (Math.abs(s2-target) <= Math.abs(s1-target)) ? l-1 : l;\\n    }\\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l, r, mi, s=0, m=-1;\\n        for(int v:arr) s += v, m=max(m,v);\\n\\n        if(s<=target) return m; // return the max value since we will keep all nums as is\\n\\n        for(l=1,r=m;l<r;) {\\n            mi=(l+r)/2;\\n            s=0;\\n            for(int v:arr) s += (v>mi)?mi:v;\\n            if(s>=target) r=mi;\\n            else          l=mi+1;\\n        }\\n        // check if we are 1 step off the target \\n        int s1=0,s2=0;\\n        for(int v:arr) s1 += (v>l)?(l):v, s2 += (v>l-1)?(l-1):v;\\n        \\n        return (abs(s2-target) <= abs(s1-target)) ? l-1 : l;\\n    }\\n};\\n```\n```v```\n```v```\n```v >= max(arr)```\n```while(target < sum + max(arr)*numOfRemoved)```\n```v```\n```target```\n```cpp\\n          Splitted the sorted values to left and right parts:\\n          a,b,c,d   |   X,Y,Z\\n          -------       =====\\n          keep          replace each elem\\n          as is         with v\\n  sum:    =sum-X-Y-Z    =v*numOfElems \\n          left part + right part = target\\n```\n```total sum - sum of the removed```\n```v```\n```removed```\n```cpp\\nleft part + right part = target\\nleft part + v*removed  = target\\nv = (target - left part)/removed\\n```\n```v```\n```v+1```\n```java\\n    public int findBestValue(int[] arr, int target) {\\n        int s=0, m=-1;\\n        for(int v:arr) { s += v; m=Math.max(m,v); }\\n        if(s<=target) return m; // return the max value since we will keep all nums as is\\n\\n        Arrays.sort(arr);\\n        \\n        int removed=0, lastIx=arr.length-1;\\n        while(lastIx>=0 && target < s + removed*arr[lastIx]) {\\n            removed++;\\n            s -= arr[lastIx];\\n            lastIx--;\\n        }\\n        int v=(target-s)/removed; // rounded down\\n        if(Math.abs(target-s-removed*v) <=\\n           Math.abs(target-s-removed*(v+1))) // check v+1 to compensate round down\\n            return v;\\n        return v+1;\\n    }\\n```\n```cpp\\n    int findBestValue(vector<int>& arr, int target) {\\n        int s=0, m=-1;\\n        for(int v:arr) s += v, m=max(m,v);\\n        if(s<=target) return m; // return the max value since we will keep all nums as is\\n\\n        sort(arr.begin(),arr.end());\\n        \\n        int removed=0, lastIx=arr.size()-1;\\n        while(lastIx>=0 && target < s + removed*arr[lastIx]) {\\n            removed++;\\n            s -= arr[lastIx];\\n            lastIx--;\\n        }\\n        int v=(target-s)/removed; // rounded down\\n        if(abs(target-s-removed*v) <=\\n           abs(target-s-removed*(v+1))) // check v+1 to compensate round down\\n            return v;\\n        return v+1;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464153,
                "title": "java-binary-search",
                "content": "```\\npublic int findBestValue(int[] arr, int target) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for (int a : arr) {\\n            sum += a;\\n            max = Math.max(max, a);\\n        }\\n        if (sum == target) return max;\\n        int min = 0, res = 1,diff = Integer.MAX_VALUE;\\n        // The answer would lie between 0 and maximum value in the array.\\n        while (min <= max) {\\n            int mid = min + (max - min) / 2;\\n            sum = getMutatedSum(arr, mid); \\n            if (sum > target) {\\n                max = mid - 1;\\n            } else {\\n                min = mid + 1;\\n            }\\n            // If current difference is less than diff || current difference==diff but mid < res.(choose the smaller one.)\\n            if (Math.abs(sum - target) < diff || (Math.abs(sum - target) == diff && mid < res)) { \\n                res = mid;\\n                diff = Math.abs(sum - target);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private int getMutatedSum(int[] arr, int mid) {\\n        int sum = 0;\\n        for (int a : arr) {\\n            sum += (a > mid) ? mid : a;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findBestValue(int[] arr, int target) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for (int a : arr) {\\n            sum += a;\\n            max = Math.max(max, a);\\n        }\\n        if (sum == target) return max;\\n        int min = 0, res = 1,diff = Integer.MAX_VALUE;\\n        // The answer would lie between 0 and maximum value in the array.\\n        while (min <= max) {\\n            int mid = min + (max - min) / 2;\\n            sum = getMutatedSum(arr, mid); \\n            if (sum > target) {\\n                max = mid - 1;\\n            } else {\\n                min = mid + 1;\\n            }\\n            // If current difference is less than diff || current difference==diff but mid < res.(choose the smaller one.)\\n            if (Math.abs(sum - target) < diff || (Math.abs(sum - target) == diff && mid < res)) { \\n                res = mid;\\n                diff = Math.abs(sum - target);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private int getMutatedSum(int[] arr, int mid) {\\n        int sum = 0;\\n        for (int a : arr) {\\n            sum += (a > mid) ? mid : a;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463222,
                "title": "java-binary-search-o-nlogk-k-is-the-max-value-in-arr",
                "content": "``` java\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int max = -1;\\n        for(int a : arr){\\n            max = Math.max(max, a);\\n        }\\n        \\n        int left = 0, right = max;\\n        int diff = target;\\n        int prevValue = max;\\n        while(left <= right){\\n            int mid = (left + right) / 2;\\n            int sum = getSum(arr, mid);\\n            int currentDiff = Math.abs(target - sum);\\n            if(currentDiff < diff){\\n                diff = currentDiff;\\n                prevValue = mid;\\n            }\\n            else if(currentDiff == diff){\\n                prevValue = Math.min(prevValue, mid);\\n            }\\n            if(sum > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return prevValue;\\n    }\\n    \\n    \\n    public int getSum(int[] arr, int value){\\n        int sum = 0;\\n        for(int a : arr){\\n            sum += a > value ? value : a;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int max = -1;\\n        for(int a : arr){\\n            max = Math.max(max, a);\\n        }\\n        \\n        int left = 0, right = max;\\n        int diff = target;\\n        int prevValue = max;\\n        while(left <= right){\\n            int mid = (left + right) / 2;\\n            int sum = getSum(arr, mid);\\n            int currentDiff = Math.abs(target - sum);\\n            if(currentDiff < diff){\\n                diff = currentDiff;\\n                prevValue = mid;\\n            }\\n            else if(currentDiff == diff){\\n                prevValue = Math.min(prevValue, mid);\\n            }\\n            if(sum > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return prevValue;\\n    }\\n    \\n    \\n    public int getSum(int[] arr, int value){\\n        int sum = 0;\\n        for(int a : arr){\\n            sum += a > value ? value : a;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228048,
                "title": "c-binary-search-easy-and-short-code",
                "content": "```\\nint diff(int mid, vector<int>& arr, int target)\\n    {\\n        int sum = 0;\\n        for(int i = 0; i < arr.size(); i++)\\n            sum += min(mid, arr[i]);\\n        \\n        return abs(target - sum);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target)\\n    {\\n        int n = arr.size();\\n        int s = 0;\\n        int e = target;\\n        \\n        while(s < e)\\n        {\\n            int mid = s + (e - s)/2;\\n            if(diff(mid, arr, target) <= diff(mid + 1, arr, target))\\n                e = mid;\\n            else\\n                s = mid + 1;\\n        }\\n        \\n        return s;\\n        \\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nint diff(int mid, vector<int>& arr, int target)\\n    {\\n        int sum = 0;\\n        for(int i = 0; i < arr.size(); i++)\\n            sum += min(mid, arr[i]);\\n        \\n        return abs(target - sum);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target)\\n    {\\n        int n = arr.size();\\n        int s = 0;\\n        int e = target;\\n        \\n        while(s < e)\\n        {\\n            int mid = s + (e - s)/2;\\n            if(diff(mid, arr, target) <= diff(mid + 1, arr, target))\\n                e = mid;\\n            else\\n                s = mid + 1;\\n        }\\n        \\n        return s;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463586,
                "title": "python3-sort-scan",
                "content": "Algorithm:\\nSort the array in ascending order. \\nAt each index `i`, compute the value to set `arr[i:]` to so that `sum(arr)` would be closest to `target`. If this value is smaller than `arr[i]`, return it; otherwise, return `arr[-1]`. \\n\\nImplementation (24ms, 100%):\\n```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        s, n = 0, len(arr)\\n        \\n        for i in range(n):\\n            ans = round((target - s)/n)\\n            if ans <= arr[i]: return ans \\n            s += arr[i]\\n            n -= 1\\n            \\n        return arr[-1]\\n```\\n\\nAnalysis:\\nTime complexity `O(NlogN)`\\nSpace complexity `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        s, n = 0, len(arr)\\n        \\n        for i in range(n):\\n            ans = round((target - s)/n)\\n            if ans <= arr[i]: return ans \\n            s += arr[i]\\n            n -= 1\\n            \\n        return arr[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464434,
                "title": "classic-binary-search",
                "content": "```\\n    public int findBestValue(int[] arr, int target) {\\n        int low = 0;\\n        int high = target;\\n        while(low <= high){\\n            int mid = low + (high-low)/2;            \\n            int sum = sum(arr,mid);         \\n            if(sum == target) return mid;\\n            else if(sum < target) low = mid + 1;\\n            else high = mid - 1;\\n            \\n            \\n        }\\n        // at this point, the solution is either low or low - 1;\\n        int first = sum(arr,low);\\n        int second = sum(arr,low-1);\\n        \\n        if(Math.abs(first-target) < Math.abs(second-target)) return low;\\n        \\n        return low-1;\\n    }\\n    \\n    private int sum(int[] arr, int mid){\\n        int sum = 0;\\n        for(int x: arr){\\n            sum += x > mid ? mid : x;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int findBestValue(int[] arr, int target) {\\n        int low = 0;\\n        int high = target;\\n        while(low <= high){\\n            int mid = low + (high-low)/2;            \\n            int sum = sum(arr,mid);         \\n            if(sum == target) return mid;\\n            else if(sum < target) low = mid + 1;\\n            else high = mid - 1;\\n            \\n            \\n        }\\n        // at this point, the solution is either low or low - 1;\\n        int first = sum(arr,low);\\n        int second = sum(arr,low-1);\\n        \\n        if(Math.abs(first-target) < Math.abs(second-target)) return low;\\n        \\n        return low-1;\\n    }\\n    \\n    private int sum(int[] arr, int mid){\\n        int sum = 0;\\n        for(int x: arr){\\n            sum += x > mid ? mid : x;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 532804,
                "title": "python-binary-search-python-really-intuitive",
                "content": "```\\nclass Solution(object):\\n    def getRes(self,arr,t):\\n        nums = [t if num >= t else num for num in arr]\\n        return sum(nums)\\n    \\n    def findBestValue(self, arr, target):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        l = 1\\n        h = max(arr)\\n        \\n        while l <= h:\\n            mid = (h-l)//2 + l\\n            curr = self.getRes(arr,mid)\\n            if curr == target:\\n                return mid\\n            elif curr < target:\\n                l = mid+1\\n            else:\\n                h = mid-1\\n        if abs(self.getRes(arr,l) - target) < abs(self.getRes(arr,h) - target):\\n            return l\\n        return h\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getRes(self,arr,t):\\n        nums = [t if num >= t else num for num in arr]\\n        return sum(nums)\\n    \\n    def findBestValue(self, arr, target):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        l = 1\\n        h = max(arr)\\n        \\n        while l <= h:\\n            mid = (h-l)//2 + l\\n            curr = self.getRes(arr,mid)\\n            if curr == target:\\n                return mid\\n            elif curr < target:\\n                l = mid+1\\n            else:\\n                h = mid-1\\n        if abs(self.getRes(arr,l) - target) < abs(self.getRes(arr,h) - target):\\n            return l\\n        return h\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253854,
                "title": "c-binary-search-peak-finding-o-nlogk-o-nlogn-logk-logn-prefix-sum",
                "content": "The idea is to use the fact that value `abs(target - valSum)` will be first decreasing and then increasing for val in range [0, 1e5], somewhat similar to below graph:\\n<p>*</p>\\n<p>&nbsp; &nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *</p>\\n<p>&nbsp; &nbsp; &nbsp; &nbsp;*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</p>\\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * &nbsp; &nbsp;*</p>\\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</p>\\n\\nSo although valSum keep incresing for increase in val, the `abs(target - valSum)` will have minima as shown above. Using the above observation we can use standard peak finding algorithm using binary search(in this case we can because there is only one global and local minima).\\n\\n**Reference problem**: [162. Find Peak Element](https://leetcode.com/problems/find-peak-element/)\\n\\n\\n    int check(int val, vector<int>& arr, int target) {\\n        int valSum = 0;\\n        for(auto ele: arr) {\\n            valSum += min(val, ele);\\n        }\\n        \\n        return abs(valSum - target);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int low = 0, high = 1e5 + 2;\\n        \\n        while(low < high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(check(mid, arr, target) > check(mid + 1, arr, target))\\n                low = mid + 1;\\n\\n            else \\n                high = mid;\\n        }\\n        \\n        return low;\\n    }\\n----------------------------------------------------------------------------\\n<br>\\n\\n**Optimisation**\\n\\t\\nTime complexity can be further improved to O(nlogn + logklogn) by sorting the array and using prefix sum.\\nHere we can improve complexity of check method from O(n) to O(logn) by binary searching/upperbound on the val in arr and using it to get index for prefix array whose elements will be less than val i.e. \"*binary search within binary search*\".\\n\\n    vector<int> pre;\\n    \\n    int check(int val, vector<int>& arr, int target) {\\n        int valSum = 0;\\n        int id = upper_bound(arr.begin(), arr.end(), val) - arr.begin() - 1;\\n        if(id > -1)\\n            valSum = pre[id];\\n        valSum += val*((int)arr.size() - (id + 1));\\n        \\n        return abs(valSum - target);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        pre = arr;\\n        for(int i = 1; i < pre.size(); i++)\\n            pre[i] +=pre[i - 1];\\n        \\n        int low = 0, high = 1e5 + 2;\\n        \\n        while(low < high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(check(mid, arr, target) > check(mid + 1, arr, target))\\n                low = mid + 1;\\n\\n            else \\n                high = mid;\\n        }\\n        \\n        return low;\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "The idea is to use the fact that value `abs(target - valSum)` will be first decreasing and then increasing for val in range [0, 1e5], somewhat similar to below graph:\\n<p>*</p>\\n<p>&nbsp; &nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *</p>\\n<p>&nbsp; &nbsp; &nbsp; &nbsp;*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</p>\\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * &nbsp; &nbsp;*</p>\\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</p>\\n\\nSo although valSum keep incresing for increase in val, the `abs(target - valSum)` will have minima as shown above. Using the above observation we can use standard peak finding algorithm using binary search(in this case we can because there is only one global and local minima).\\n\\n**Reference problem**: [162. Find Peak Element](https://leetcode.com/problems/find-peak-element/)\\n\\n\\n    int check(int val, vector<int>& arr, int target) {\\n        int valSum = 0;\\n        for(auto ele: arr) {\\n            valSum += min(val, ele);\\n        }\\n        \\n        return abs(valSum - target);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int low = 0, high = 1e5 + 2;\\n        \\n        while(low < high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(check(mid, arr, target) > check(mid + 1, arr, target))\\n                low = mid + 1;\\n\\n            else \\n                high = mid;\\n        }\\n        \\n        return low;\\n    }\\n----------------------------------------------------------------------------\\n<br>\\n\\n**Optimisation**\\n\\t\\nTime complexity can be further improved to O(nlogn + logklogn) by sorting the array and using prefix sum.\\nHere we can improve complexity of check method from O(n) to O(logn) by binary searching/upperbound on the val in arr and using it to get index for prefix array whose elements will be less than val i.e. \"*binary search within binary search*\".\\n\\n    vector<int> pre;\\n    \\n    int check(int val, vector<int>& arr, int target) {\\n        int valSum = 0;\\n        int id = upper_bound(arr.begin(), arr.end(), val) - arr.begin() - 1;\\n        if(id > -1)\\n            valSum = pre[id];\\n        valSum += val*((int)arr.size() - (id + 1));\\n        \\n        return abs(valSum - target);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        pre = arr;\\n        for(int i = 1; i < pre.size(); i++)\\n            pre[i] +=pre[i - 1];\\n        \\n        int low = 0, high = 1e5 + 2;\\n        \\n        while(low < high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(check(mid, arr, target) > check(mid + 1, arr, target))\\n                low = mid + 1;\\n\\n            else \\n                high = mid;\\n        }\\n        \\n        return low;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 470114,
                "title": "c-binary-search-get-the-lowest-point",
                "content": "```\\n#include <cmath>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int eval(int m, vector<int>& arr, int target) {\\n        int sum = 0;\\n        for(int i = 0; i < arr.size(); i++) {\\n            sum += min(arr[i], m);\\n        }\\n        return abs(sum-target);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int l = 0, r = 100001;\\n        while(l<r) {\\n            int m = (l+r)>>1;\\n            if(eval(m, arr, target) <= eval(m+1, arr, target)) r = m;\\n            else l = m+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <cmath>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int eval(int m, vector<int>& arr, int target) {\\n        int sum = 0;\\n        for(int i = 0; i < arr.size(); i++) {\\n            sum += min(arr[i], m);\\n        }\\n        return abs(sum-target);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int l = 0, r = 100001;\\n        while(l<r) {\\n            int m = (l+r)>>1;\\n            if(eval(m, arr, target) <= eval(m+1, arr, target)) r = m;\\n            else l = m+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 463230,
                "title": "python-binary-search",
                "content": "```python\\ndef findBestValue(arr: List[int], target: int) -> int:\\n\\tdef get_sum(v):\\n\\t\\treturn sum(v if a > v else a for a in arr)\\n\\n\\t# Binary search to find the largest v (as the final lo) \\n\\t# such that the sum is smaller than or equal to target\\n\\tlo, hi = 0, max(arr)\\n\\twhile lo < hi:\\n\\t\\tmid = (lo + hi + 1) // 2\\n\\t\\tif get_sum(mid) <= target:\\n\\t\\t\\tlo = mid\\n\\t\\telse:\\n\\t\\t\\thi = mid - 1\\n\\n\\t# Check if (lo + 1) results in a smaller absolute difference\\n\\t# Note: get_sum(lo) <= target\\n\\t#       get_sum(lo + 1) > target if lo < max(arr)\\n\\tif target - get_sum(lo) <= abs(get_sum(lo + 1) - target):\\n\\t\\treturn lo\\n\\treturn lo + 1\\n```",
                "solutionTags": [],
                "code": "```python\\ndef findBestValue(arr: List[int], target: int) -> int:\\n\\tdef get_sum(v):\\n\\t\\treturn sum(v if a > v else a for a in arr)\\n\\n\\t# Binary search to find the largest v (as the final lo) \\n\\t# such that the sum is smaller than or equal to target\\n\\tlo, hi = 0, max(arr)\\n\\twhile lo < hi:\\n\\t\\tmid = (lo + hi + 1) // 2\\n\\t\\tif get_sum(mid) <= target:\\n\\t\\t\\tlo = mid\\n\\t\\telse:\\n\\t\\t\\thi = mid - 1\\n\\n\\t# Check if (lo + 1) results in a smaller absolute difference\\n\\t# Note: get_sum(lo) <= target\\n\\t#       get_sum(lo + 1) > target if lo < max(arr)\\n\\tif target - get_sum(lo) <= abs(get_sum(lo + 1) - target):\\n\\t\\treturn lo\\n\\treturn lo + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1028857,
                "title": "java-easy-understand-binary-search-beats-97",
                "content": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        \\n        int max = 0;\\n        int sum = 0;\\n        \\n        // Find the max value and the upper bound of the seach range.\\n        for(int num : arr) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        // If the sum is smaller than the target the greatest number is the answer.\\n        if(sum <= target) {\\n            return max;\\n        }\\n        \\n        // Prepare the binary search\\n        int left = 0;\\n        int right = sum;\\n        int leftSum = getSum(arr, left);\\n        int rightSum = getSum(arr, right);\\n        \\n        \\n        // Eventually it will narrow down to 2 Consecutive numbers.\\n        // The smaller one\\'s sum is smaller than the target while the greater one\\'s is greater than the target.\\n        // Unless we locate a middle value\\'s sum is equal to target.\\n        while(Math.abs(left - right) != 1) {\\n            \\n            int middle = left + (right - left) / 2;\\n            int midSum = getSum(arr, middle);\\n            \\n            if(midSum < target) {\\n                left = middle;\\n                leftSum = midSum;\\n            } else if(midSum > target) {\\n                right = middle;\\n                rightSum = midSum;\\n            } else {\\n                return middle;\\n            }\\n        }\\n        \\n        // Determine which one is closer to the target.\\n        if(Math.abs(leftSum - target) <= Math.abs(rightSum - target)) {\\n            return left;\\n        } else {\\n            return right;\\n        }\\n        \\n    }\\n    \\n    // Get the sum of the chosen number\\n    private int getSum(int[] arr, int number) {\\n        int sum = 0;\\n        \\n        for(int num : arr) {\\n            sum += Math.min(num, number);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        \\n        int max = 0;\\n        int sum = 0;\\n        \\n        // Find the max value and the upper bound of the seach range.\\n        for(int num : arr) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        // If the sum is smaller than the target the greatest number is the answer.\\n        if(sum <= target) {\\n            return max;\\n        }\\n        \\n        // Prepare the binary search\\n        int left = 0;\\n        int right = sum;\\n        int leftSum = getSum(arr, left);\\n        int rightSum = getSum(arr, right);\\n        \\n        \\n        // Eventually it will narrow down to 2 Consecutive numbers.\\n        // The smaller one\\'s sum is smaller than the target while the greater one\\'s is greater than the target.\\n        // Unless we locate a middle value\\'s sum is equal to target.\\n        while(Math.abs(left - right) != 1) {\\n            \\n            int middle = left + (right - left) / 2;\\n            int midSum = getSum(arr, middle);\\n            \\n            if(midSum < target) {\\n                left = middle;\\n                leftSum = midSum;\\n            } else if(midSum > target) {\\n                right = middle;\\n                rightSum = midSum;\\n            } else {\\n                return middle;\\n            }\\n        }\\n        \\n        // Determine which one is closer to the target.\\n        if(Math.abs(leftSum - target) <= Math.abs(rightSum - target)) {\\n            return left;\\n        } else {\\n            return right;\\n        }\\n        \\n    }\\n    \\n    // Get the sum of the chosen number\\n    private int getSum(int[] arr, int number) {\\n        int sum = 0;\\n        \\n        for(int num : arr) {\\n            sum += Math.min(num, number);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809821,
                "title": "binary-search-template-solution-intuition-explained-in-detail-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhey every one, i have made video playlist for binary search where i discuss a template solution and intuition behind it, this template solution will be very useful as this will help you solve many other questions in binary search this question is the part of that playlist:\\nhttps://youtu.be/jbiDsInyTwA\\n\\n\\nPlaylist link: \\nhttps://youtube.com/playlist?list=PLICVjZ3X1AcYYdde4GTp79zfdp_VACSkX\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int map_fun(int val, vector<int> & arr,int target){\\n        int sum=0;\\n        for(auto num:arr){\\n            sum+= min(num,val);\\n        }\\n        return abs(sum-target);\\n    }\\n    bool predicate(int m, vector<int> & arr,int target){\\n        return map_fun(m,arr,target) <=map_fun(m+1,arr,target);\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l=0;\\n        int r=*max_element(arr.begin(), arr.end());\\n\\n        while(l<r){\\n            int m=l+ (r-l)/2;\\n            if(predicate(m,arr,target)){\\n                r=m;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int map_fun(int val, vector<int> & arr,int target){\\n        int sum=0;\\n        for(auto num:arr){\\n            sum+= min(num,val);\\n        }\\n        return abs(sum-target);\\n    }\\n    bool predicate(int m, vector<int> & arr,int target){\\n        return map_fun(m,arr,target) <=map_fun(m+1,arr,target);\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l=0;\\n        int r=*max_element(arr.begin(), arr.end());\\n\\n        while(l<r){\\n            int m=l+ (r-l)/2;\\n            if(predicate(m,arr,target)){\\n                r=m;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569251,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\nprivate:\\n    int find(int mid,vector<int>&arr,int target)\\n    {\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i]>=mid)\\n                sum+=mid;\\n            else\\n                sum+=arr[i];\\n        }\\n        return abs(sum-target);\\n    }\\npublic:\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        int n=arr.size();\\n        int low=0;\\n        int high=1e8;\\n        sort(arr.begin(),arr.end());\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)>>1;\\n            \\n            int e1=find(mid,arr,target);\\n            int e2=find(mid+1,arr,target);\\n            \\n            if(e1<=e2)\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity : O ( nlogn ) \\nSpace Complexity : O ( 1 ) \\n\\n\\n**Please upvote if you found it helpful.**\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int find(int mid,vector<int>&arr,int target)\\n    {\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i]>=mid)\\n                sum+=mid;\\n            else\\n                sum+=arr[i];\\n        }\\n        return abs(sum-target);\\n    }\\npublic:\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        int n=arr.size();\\n        int low=0;\\n        int high=1e8;\\n        sort(arr.begin(),arr.end());\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)>>1;\\n            \\n            int e1=find(mid,arr,target);\\n            int e2=find(mid+1,arr,target);\\n            \\n            if(e1<=e2)\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337622,
                "title": "c-simple-and-short-solution-7-lines-no-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        int n = arr.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            \\n            if (arr[i] * (n-i) >= target) \\n                return int(round((target - 0.0001) / (n - i)));\\n            \\n            target -= arr[i];\\n        }\\n        \\n        return arr[n-1];\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        int n = arr.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            \\n            if (arr[i] * (n-i) >= target) \\n                return int(round((target - 0.0001) / (n - i)));\\n            \\n            target -= arr[i];\\n        }\\n        \\n        return arr[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231230,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>& arr,int k)\\n    {\\n        int sum=0;\\n        for(auto x:arr)\\n        {\\n            if(x<=k)\\n                sum+=x;\\n            else\\n                sum+=k;\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) \\n    {\\n        int i=0,j=*max_element(arr.begin(),arr.end());\\n        int res=INT_MAX,diff=INT_MAX;\\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;\\n            int sum=find(arr,mid);\\n            int d=abs(sum-target);\\n            if(d<diff || (d==diff && mid<res))\\n            {\\n                res=mid;diff=d;\\n            }\\n            if(sum<target)\\n                i=mid+1;\\n            else\\n                j=mid-1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>& arr,int k)\\n    {\\n        int sum=0;\\n        for(auto x:arr)\\n        {\\n            if(x<=k)\\n                sum+=x;\\n            else\\n                sum+=k;\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) \\n    {\\n        int i=0,j=*max_element(arr.begin(),arr.end());\\n        int res=INT_MAX,diff=INT_MAX;\\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;\\n            int sum=find(arr,mid);\\n            int d=abs(sum-target);\\n            if(d<diff || (d==diff && mid<res))\\n            {\\n                res=mid;diff=d;\\n            }\\n            if(sum<target)\\n                i=mid+1;\\n            else\\n                j=mid-1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749333,
                "title": "python-solution-with-video-explanation",
                "content": "[https://www.youtube.com/watch?v=j0KejYpI_Mc&feature=youtu.be]\\n```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        length = len(arr)\\n        \\n        for x in range(length):\\n            sol = round(target / length)\\n            if arr[x] >= sol:\\n                return sol\\n            target -= arr[x]\\n            length -= 1\\n        \\n        return arr[-1]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        length = len(arr)\\n        \\n        for x in range(length):\\n            sol = round(target / length)\\n            if arr[x] >= sol:\\n                return sol\\n            target -= arr[x]\\n            length -= 1\\n        \\n        return arr[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359402,
                "title": "very-easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n      int n = arr.length;\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < n; i++) {\\n            hi = Math.max(hi, arr[i]);\\n        }\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                sum += Math.min(arr[i], mid);\\n            }\\n            if (sum >= target) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += Math.min(arr[i], lo);\\n            sum2 += Math.min(arr[i], lo - 1);\\n        }\\n        \\n        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n      int n = arr.length;\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < n; i++) {\\n            hi = Math.max(hi, arr[i]);\\n        }\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                sum += Math.min(arr[i], mid);\\n            }\\n            if (sum >= target) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += Math.min(arr[i], lo);\\n            sum2 += Math.min(arr[i], lo - 1);\\n        }\\n        \\n        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991288,
                "title": "java-binary-search",
                "content": "``` java\\npublic int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int left = 0, right = arr[arr.length - 1];\\n        int minDifference = Integer.MAX_VALUE, result = 0;\\n\\n        while (left <= right) {\\n            int middle = (left + right) / 2;\\n            int sum = sumAfterChanges(arr, middle);\\n            if (sum > target)\\n                right = middle - 1;\\n            else\\n                left = middle + 1;\\n\\n            if ((Math.abs(sum - target) < minDifference) || (Math.abs(sum - target) == minDifference && middle < result)) {\\n                minDifference = Math.abs(sum - target);\\n                result = middle;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private int sumAfterChanges(int[] array, int value) {\\n        int sum = 0;\\n        for (int number : array) {\\n            sum += Math.min(number, value);\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "``` java\\npublic int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int left = 0, right = arr[arr.length - 1];\\n        int minDifference = Integer.MAX_VALUE, result = 0;\\n\\n        while (left <= right) {\\n            int middle = (left + right) / 2;\\n            int sum = sumAfterChanges(arr, middle);\\n            if (sum > target)\\n                right = middle - 1;\\n            else\\n                left = middle + 1;\\n\\n            if ((Math.abs(sum - target) < minDifference) || (Math.abs(sum - target) == minDifference && middle < result)) {\\n                minDifference = Math.abs(sum - target);\\n                result = middle;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private int sumAfterChanges(int[] array, int value) {\\n        int sum = 0;\\n        for (int number : array) {\\n            sum += Math.min(number, value);\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1192814,
                "title": "c-binary-search-8-ms-faster-than-100",
                "content": "```\\n//low = 0  and high is going to be max element from the array\\n//It is monotonically increasing fn. \\n//Predicate is going to be FFFF...TTTT... so we can use Binary search;\\n\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        int low = 0; \\n        int high = INT_MIN;\\n        for(auto i: arr){\\n            high = max(high, i);\\n        }\\n        \\n        int mid;\\n        int sum;\\n        while(low < high){\\n            sum = 0; \\n            mid = low + (high-low)/2;\\n            \\n            for(auto i: arr){\\n                if(i > mid){\\n                    sum += mid;\\n                    continue;\\n                }\\n                sum += i;\\n            }\\n            \\n            if(sum < target)\\n                low = mid+1;\\n            else\\n                high = mid;\\n        }\\n        \\n        int sum1 = 0;\\n        sum = 0;\\n   \\n        for(auto i: arr){\\n            if(i > low-1){\\n                sum += low-1;\\n                continue;\\n            }\\n            sum += i;\\n        }\\n        \\n        \\n        for(auto i: arr){\\n            if(i > low){\\n                sum1 += low;\\n                continue;\\n            }\\n            sum1 += i;\\n        }\\n\\n        \\n        sum = abs(target - sum);\\n        sum1 = abs(target - sum1);\\n        \\n        return (sum <= sum1)?(low-1):low;\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n//low = 0  and high is going to be max element from the array\\n//It is monotonically increasing fn. \\n//Predicate is going to be FFFF...TTTT... so we can use Binary search;\\n\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        int low = 0; \\n        int high = INT_MIN;\\n        for(auto i: arr){\\n            high = max(high, i);\\n        }\\n        \\n        int mid;\\n        int sum;\\n        while(low < high){\\n            sum = 0; \\n            mid = low + (high-low)/2;\\n            \\n            for(auto i: arr){\\n                if(i > mid){\\n                    sum += mid;\\n                    continue;\\n                }\\n                sum += i;\\n            }\\n            \\n            if(sum < target)\\n                low = mid+1;\\n            else\\n                high = mid;\\n        }\\n        \\n        int sum1 = 0;\\n        sum = 0;\\n   \\n        for(auto i: arr){\\n            if(i > low-1){\\n                sum += low-1;\\n                continue;\\n            }\\n            sum += i;\\n        }\\n        \\n        \\n        for(auto i: arr){\\n            if(i > low){\\n                sum1 += low;\\n                continue;\\n            }\\n            sum1 += i;\\n        }\\n\\n        \\n        sum = abs(target - sum);\\n        sum1 = abs(target - sum1);\\n        \\n        return (sum <= sum1)?(low-1):low;\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462840,
                "title": "c-binary-search-on-answer-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We can think of Binary Serach on answer as`target`is given and operations need to be done accordingly.\\n- Used Sort, Prefix-Sum, Binary Search and Upper bound.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Firstly, we calculate prefix sum.\\n- Then, set`low=0`and`high=target` as these are edge conditions and answer will lie between these.\\n- Now, calculate upper bound of`mid=(low+high)/2`which is say`ind`so that elements after this`ind`will be converted to`mid` and so, final`sum`of new array will be`prefix[ind-1]+(mid)*(n-1-ind)`.\\n   (where`(n-1-ind)` is number of elements which are updated).\\n- Also, we maintain`diff` which stores how close the`sum`is to the`target`. \\n- `ans`stores the answer which will be`mid` if minimal of`diff`.\\n- Two conditions exists:\\n   1. If`upper bound`is at end, meaning`mid`is larger than the largest of the array, then`high=mid-1`as going ahead will lead to increase in`diff` which is not required.\\n   2. Else, `low`and`high`and updated based on required conditions.\\n# Complexity\\n- Time complexity:`O(n*log(n))`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        int n=arr.size(), i;\\n        # Prefix Sum\\n        vector<int> presum;\\n        presum.push_back(arr[0]);\\n        for(i=1; i<n; ++i){\\n            presum.push_back(presum[i-1]+arr[i]);\\n        }\\n        int low=0, high=target;\\n        # ans and diff initialized to max value.\\n        int ans=target+1, diff=target+1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            auto ubound=upper_bound(arr.begin(), arr.end(), mid);\\n            if(ubound==arr.end()){\\n                int sum=presum[n-1];\\n                if(abs(target-sum)<diff){\\n                    diff=abs(target-sum);\\n                    ans=mid;\\n                }\\n                if(abs(target-sum)==diff){\\n                    ans=min(ans, mid);\\n                }\\n                # As upper bound is at end, no need to increase value of mid\\n                high=mid-1;\\n            }\\n            else{\\n                int sum;\\n                if(ubound==arr.begin()){\\n                    # Replace all elements of arr with mid.\\n                    sum=n*mid;\\n                }\\n                else{\\n                    int ind=ubound-arr.begin();\\n                    ind--;\\n                    sum=presum[ind]+((n-1-ind)*mid);\\n                }\\n                if(target-sum==0){\\n                    return mid;\\n                }\\n                if(target-sum>0){\\n                    if(target-sum<diff){\\n                        diff=target-sum;\\n                        ans=mid;\\n                    }\\n                    if(target-sum==diff){\\n                        ans=min(ans, mid);\\n                    }\\n                    # As target>sum, we move ahead.\\n                    low=mid+1;\\n                }\\n                else{\\n                    if(sum-target<diff){\\n                        diff=sum-target;\\n                        ans=mid;\\n                    }\\n                    if(sum-target==diff){\\n                        ans=min(ans, mid);\\n                    }\\n                    # As sum>target, we move backwards.\\n                    high=mid-1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        int n=arr.size(), i;\\n        # Prefix Sum\\n        vector<int> presum;\\n        presum.push_back(arr[0]);\\n        for(i=1; i<n; ++i){\\n            presum.push_back(presum[i-1]+arr[i]);\\n        }\\n        int low=0, high=target;\\n        # ans and diff initialized to max value.\\n        int ans=target+1, diff=target+1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            auto ubound=upper_bound(arr.begin(), arr.end(), mid);\\n            if(ubound==arr.end()){\\n                int sum=presum[n-1];\\n                if(abs(target-sum)<diff){\\n                    diff=abs(target-sum);\\n                    ans=mid;\\n                }\\n                if(abs(target-sum)==diff){\\n                    ans=min(ans, mid);\\n                }\\n                # As upper bound is at end, no need to increase value of mid\\n                high=mid-1;\\n            }\\n            else{\\n                int sum;\\n                if(ubound==arr.begin()){\\n                    # Replace all elements of arr with mid.\\n                    sum=n*mid;\\n                }\\n                else{\\n                    int ind=ubound-arr.begin();\\n                    ind--;\\n                    sum=presum[ind]+((n-1-ind)*mid);\\n                }\\n                if(target-sum==0){\\n                    return mid;\\n                }\\n                if(target-sum>0){\\n                    if(target-sum<diff){\\n                        diff=target-sum;\\n                        ans=mid;\\n                    }\\n                    if(target-sum==diff){\\n                        ans=min(ans, mid);\\n                    }\\n                    # As target>sum, we move ahead.\\n                    low=mid+1;\\n                }\\n                else{\\n                    if(sum-target<diff){\\n                        diff=sum-target;\\n                        ans=mid;\\n                    }\\n                    if(sum-target==diff){\\n                        ans=min(ans, mid);\\n                    }\\n                    # As sum>target, we move backwards.\\n                    high=mid-1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277249,
                "title": "c-binary-search-o-nlogn",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int i=0;\\n        int j=*max_element(arr.begin(),arr.end());\\n        int mid, ans, diff=INT_MAX, sum;\\n        while(i<=j){\\n            mid=i+(j-i)/2;\\n\\n            sum=0;\\n            for(int n:arr){\\n                if(n>mid){\\n                    sum+=mid;\\n                }else{\\n                    sum+=n;\\n                }\\n            }\\n\\n            if(diff>abs(sum-target)){\\n                diff=abs(sum-target);\\n                ans=mid;\\n            }else if(diff==abs(sum-target)){\\n                ans=min(ans,mid);\\n            }\\n\\n            if(sum>target){\\n                j=mid-1;\\n            }else if(sum<target){\\n                i=mid+1;\\n            }else{\\n                ans=mid;\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n**UPVOTE IF HELPFUL!!!**",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int i=0;\\n        int j=*max_element(arr.begin(),arr.end());\\n        int mid, ans, diff=INT_MAX, sum;\\n        while(i<=j){\\n            mid=i+(j-i)/2;\\n\\n            sum=0;\\n            for(int n:arr){\\n                if(n>mid){\\n                    sum+=mid;\\n                }else{\\n                    sum+=n;\\n                }\\n            }\\n\\n            if(diff>abs(sum-target)){\\n                diff=abs(sum-target);\\n                ans=mid;\\n            }else if(diff==abs(sum-target)){\\n                ans=min(ans,mid);\\n            }\\n\\n            if(sum>target){\\n                j=mid-1;\\n            }else if(sum<target){\\n                i=mid+1;\\n            }else{\\n                ans=mid;\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268479,
                "title": "easy-solutions-1300-in-java-python-and-c-look-at-once",
                "content": "# Intuition:\\nThe idea is to perform a binary search on the possible values of the answer. Let the answer be x, then we need to find the minimum value of x such that the sum of the modified array is greater than or equal to the target value.\\n# Approach:\\n1. Initialize the range of possible values of x as [0, max(arr)] where max(arr) is the maximum value in the input array arr.\\n2. Perform binary search on the range [lo, hi], where lo and hi are the lower and upper bounds of the range.\\n3. In each iteration of the binary search, calculate the sum of the modified array for the current value of x.\\n4. If the sum is greater than or equal to the target, set the upper bound of the range as the current value of x. Otherwise, set the lower bound of the range as the current value of x + 1.\\n5. After the binary search, calculate the sum of the modified array for the two possible values of x (lo and lo - 1) and return the value of x that minimizes the absolute difference between the sum and the target.\\n# Complexity:\\n- Time complexity: $$O(nlog(max(arr)))$$ where n is the length of the input array and max(arr) is the maximum value in the input array.\\n- Space complexity: $$O(1)$$ since we are only using constant extra space.\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n```Python []\\nclass Solution(object):\\n    def findBestValue(self, arr, target):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        left, right = 1, max(arr)\\n        best_value = 0\\n        min_diff = float(\\'inf\\')\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            total = sum(min(num, mid) for num in arr)\\n            diff = abs(total - target)\\n            \\n            if diff < min_diff:\\n                min_diff = diff\\n                best_value = mid\\n            \\n            if total >= target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        \\n        return best_value\\n\\n```\\n``` Java []\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n      int n = arr.length;\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < n; i++) {\\n            hi = Math.max(hi, arr[i]);\\n        }\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                sum += Math.min(arr[i], mid);\\n            }\\n            if (sum >= target) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += Math.min(arr[i], lo);\\n            sum2 += Math.min(arr[i], lo - 1);\\n        }\\n        \\n        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < n; i++) {\\n            hi = max(hi, arr[i]);\\n        }\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                sum += min(arr[i], mid);\\n            }\\n            if (sum >= target) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += min(arr[i], lo);\\n            sum2 += min(arr[i], lo - 1);\\n        }\\n        \\n        return abs(sum2 - target) <= abs(sum1 - target) ? lo - 1 : lo;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```Python []\\nclass Solution(object):\\n    def findBestValue(self, arr, target):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        left, right = 1, max(arr)\\n        best_value = 0\\n        min_diff = float(\\'inf\\')\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            total = sum(min(num, mid) for num in arr)\\n            diff = abs(total - target)\\n            \\n            if diff < min_diff:\\n                min_diff = diff\\n                best_value = mid\\n            \\n            if total >= target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        \\n        return best_value\\n\\n```\n``` Java []\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n      int n = arr.length;\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < n; i++) {\\n            hi = Math.max(hi, arr[i]);\\n        }\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                sum += Math.min(arr[i], mid);\\n            }\\n            if (sum >= target) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += Math.min(arr[i], lo);\\n            sum2 += Math.min(arr[i], lo - 1);\\n        }\\n        \\n        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < n; i++) {\\n            hi = max(hi, arr[i]);\\n        }\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                sum += min(arr[i], mid);\\n            }\\n            if (sum >= target) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += min(arr[i], lo);\\n            sum2 += min(arr[i], lo - 1);\\n        }\\n        \\n        return abs(sum2 - target) <= abs(sum1 - target) ? lo - 1 : lo;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278006,
                "title": "weeb-does-python-using-binary-search",
                "content": "\\n\\tclass Solution:\\n\\t\\tdef findBestValue(self, arr: List[int], target: int) -> int:\\n\\t\\t\\tarr.sort()\\n\\t\\t\\tlow, high = 0, arr[-1]\\n\\t\\t\\tmemo = {}\\n\\t\\t\\twhile low<=high:\\n\\t\\t\\t\\tmid = low + (high-low) // 2\\n\\t\\t\\t\\tcount=0\\n\\n\\t\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\t\\tif arr[i]>mid:\\n\\t\\t\\t\\t\\t\\tcount+= mid * (len(arr)-i)\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\telse: count+=arr[i]\\n\\n\\t\\t\\t\\tif count == target:\\n\\t\\t\\t\\t\\treturn mid\\n\\n\\t\\t\\t\\tif count < target:\\n\\t\\t\\t\\t\\tlow = mid + 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\thigh = mid - 1 \\n\\n\\t\\t\\t\\tmemo[mid] = abs(count-target)\\n\\n\\t\\t\\treturn min(sorted(zip(memo.values(), memo.keys())))[1]\\n\\nAight coders, take a break, its time to watch some anime\\nCheck out **Hunter X Hunter**\\n\\n# Episodes: 148\\n# Genre: Action, Adventure, Shounen, Super Power\\n\\nClassic shounen, I highly recommend this if u are a shounen lover\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution:\\n\\t\\tdef findBestValue(self, arr: List[int], target: int) -> int:\\n\\t\\t\\tarr.sort()\\n\\t\\t\\tlow, high = 0, arr[-1]\\n\\t\\t\\tmemo = {}",
                "codeTag": "Java"
            },
            {
                "id": 1048694,
                "title": "java-count-sort-solution-time-space-o-max-element-in-array",
                "content": "Creating two array frequency and prefixSum.\\n\\nTime & Space complexity : O(Max element in Array)\\n\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int high=0;\\n        for(int i: arr) high=Math.max(high,i);\\n        int[] frq=new int[high+1];\\n        for(int i=0;i<arr.length;i++){\\n            frq[arr[i]]++;\\n        }\\n        for(int i=1;i<=high;i++){\\n            frq[i]=frq[i]+frq[i-1];\\n        }\\n       int[] prefixSum=new int[high+1];\\n        for(int i=0;i<arr.length;i++){\\n            prefixSum[arr[i]]=arr[i];\\n        }\\n        for(int i=1;i<=high;i++){\\n            prefixSum[i]=prefixSum[i]+prefixSum[i-1];\\n        }\\n        int curdiff=target;\\n        for(int i=1;i<=high;i++){\\n            int temp=prefixSum[i]+(frq[high]-frq[i])*i;\\n            int diff=Math.abs(target-temp);\\n            if(diff>=curdiff) return i-1;\\n            else{\\n                curdiff=diff;\\n            }\\n        }\\n        return high;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int high=0;\\n        for(int i: arr) high=Math.max(high,i);\\n        int[] frq=new int[high+1];\\n        for(int i=0;i<arr.length;i++){\\n            frq[arr[i]]++;\\n        }\\n        for(int i=1;i<=high;i++){\\n            frq[i]=frq[i]+frq[i-1];\\n        }\\n       int[] prefixSum=new int[high+1];\\n        for(int i=0;i<arr.length;i++){\\n            prefixSum[arr[i]]=arr[i];\\n        }\\n        for(int i=1;i<=high;i++){\\n            prefixSum[i]=prefixSum[i]+prefixSum[i-1];\\n        }\\n        int curdiff=target;\\n        for(int i=1;i<=high;i++){\\n            int temp=prefixSum[i]+(frq[high]-frq[i])*i;\\n            int diff=Math.abs(target-temp);\\n            if(diff>=curdiff) return i-1;\\n            else{\\n                curdiff=diff;\\n            }\\n        }\\n        return high;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824010,
                "title": "java-o-nlogn-without-binary-search",
                "content": "```\\n\\tpublic int findBestValue(int[] arr, int target) {\\n        int n = arr.length, sum = 0;\\n        Arrays.sort(arr);\\n        for (int i = 0; i < n; i++) {\\n            int x = target/(n-i);\\n            if (target-x*(n-i) > (x+1)*(n-i)-target) x = x+1;\\n            if (x < arr[i]) return x;\\n            target -= arr[i];\\n        }\\n        return arr[n-1];\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int findBestValue(int[] arr, int target) {\\n        int n = arr.length, sum = 0;\\n        Arrays.sort(arr);\\n        for (int i = 0; i < n; i++) {\\n            int x = target/(n-i);\\n            if (target-x*(n-i) > (x+1)*(n-i)-target) x = x+1;\\n            if (x < arr[i]) return x;\\n            target -= arr[i];\\n        }\\n        return arr[n-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 736404,
                "title": "python-0-nlog-n-solution-using-prefix-sum-and-binary-search",
                "content": "```\\nfrom bisect import bisect_right\\n\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        \\n        n = len(arr)\\n        arr.sort()\\n        \\n        def check(sum_array, num):\\n            \\n            index = bisect_right(arr, num)\\n            \\n            pre_sum = 0\\n            \\n            if (index-1)>=0:\\n                \\n                pre_sum += sum_array[index-1]\\n                \\n            pre_sum += num*(n-index)\\n            \\n            return pre_sum\\n                \\n        prefix_sum = []\\n        \\n        for i in arr:\\n            \\n            if len(prefix_sum) == 0:\\n                prefix_sum.append(i)\\n                \\n            else:\\n                prefix_sum.append(prefix_sum[-1] + i)\\n                \\n                \\n        low = 0\\n        high = arr[-1]\\n        \\n        min_ans = high\\n        min_diff_seen = abs(target-prefix_sum[-1])\\n        \\n        for i in range(low, high+1):\\n            \\n            ans = check(prefix_sum, i)\\n            \\n            if abs(target-ans)<min_diff_seen:\\n                \\n                min_ans = i\\n                min_diff_seen = abs(target-ans)\\n                \\n        return min_ans\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nfrom bisect import bisect_right\\n\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        \\n        n = len(arr)\\n        arr.sort()\\n        \\n        def check(sum_array, num):\\n            \\n            index = bisect_right(arr, num)\\n            \\n            pre_sum = 0\\n            \\n            if (index-1)>=0:\\n                \\n                pre_sum += sum_array[index-1]\\n                \\n            pre_sum += num*(n-index)\\n            \\n            return pre_sum\\n                \\n        prefix_sum = []\\n        \\n        for i in arr:\\n            \\n            if len(prefix_sum) == 0:\\n                prefix_sum.append(i)\\n                \\n            else:\\n                prefix_sum.append(prefix_sum[-1] + i)\\n                \\n                \\n        low = 0\\n        high = arr[-1]\\n        \\n        min_ans = high\\n        min_diff_seen = abs(target-prefix_sum[-1])\\n        \\n        for i in range(low, high+1):\\n            \\n            ans = check(prefix_sum, i)\\n            \\n            if abs(target-ans)<min_diff_seen:\\n                \\n                min_ans = i\\n                min_diff_seen = abs(target-ans)\\n                \\n        return min_ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 500121,
                "title": "binary-search-nlogn",
                "content": "```\\npublic int findBestValue(int[] arr, int target) {\\n        int s=0;\\n        int lo=0,hi=0;\\n        for(int a:arr)\\n        {    \\n            hi=Math.max(hi,a);\\n            s+=a;\\n        }\\n        if(s<=target) return hi;\\n        \\n        int dif=Integer.MAX_VALUE;\\n        while(lo<hi){\\n            int mid=lo+(hi-lo)/2;\\n            int sum=0;\\n            int diff1=cal(arr,mid,target);\\n            int diff2=cal(arr,mid+1,target);\\n            \\n            if(diff1<=diff2){\\n                hi=mid;\\n            }\\n            else lo=mid+1;\\n        }\\n        return lo;\\n    }\\n    \\n    int cal(int[] arr,int value,int target){\\n        int sum=0;\\n        for(int a:arr)\\n        {\\n            if(a>value) sum+=value;\\n            else sum+=a;\\n        }\\n        return Math.abs(sum-target);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findBestValue(int[] arr, int target) {\\n        int s=0;\\n        int lo=0,hi=0;\\n        for(int a:arr)\\n        {    \\n            hi=Math.max(hi,a);\\n            s+=a;\\n        }\\n        if(s<=target) return hi;\\n        \\n        int dif=Integer.MAX_VALUE;\\n        while(lo<hi){\\n            int mid=lo+(hi-lo)/2;\\n            int sum=0;\\n            int diff1=cal(arr,mid,target);\\n            int diff2=cal(arr,mid+1,target);\\n            \\n            if(diff1<=diff2){\\n                hi=mid;\\n            }\\n            else lo=mid+1;\\n        }\\n        return lo;\\n    }\\n    \\n    int cal(int[] arr,int value,int target){\\n        int sum=0;\\n        for(int a:arr)\\n        {\\n            if(a>value) sum+=value;\\n            else sum+=a;\\n        }\\n        return Math.abs(sum-target);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463262,
                "title": "concise-python-binary-search",
                "content": "```python3\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        l, h = 0, max(arr)\\n        def mySum(val):\\n            return sum(min(a, val) for a in arr)\\n        while l < h:\\n            m = (l + h) // 2\\n            if mySum(m) < target:\\n                l = m + 1\\n            else:\\n                h = m\\n        return min(l - 1, l, l + 1, key=lambda x: abs(mySum(x) - target))\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```python3\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        l, h = 0, max(arr)\\n        def mySum(val):\\n            return sum(min(a, val) for a in arr)\\n        while l < h:\\n            m = (l + h) // 2\\n            if mySum(m) < target:\\n                l = m + 1\\n            else:\\n                h = m\\n        return min(l - 1, l, l + 1, key=lambda x: abs(mySum(x) - target))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463206,
                "title": "c-simple-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int l = 0, r = 100000;\\n        int ans = -1,minm = INT_MAX;\\n        \\n        while (l < r) {\\n            int mid = l + (r-l+1)/2;\\n            long long int sum = 0;\\n            for (int i = 0; i<n; i++){\\n                if (arr[i] < mid){\\n                    sum += arr[i];\\n                }\\n                else {\\n                    sum += mid;\\n                }\\n            }\\n            long long int diff = abs(target - sum);\\n            if (diff <= minm){\\n                minm = diff;\\n                ans = mid;\\n            }\\n            if (sum >= target){\\n                r = mid;\\n            }\\n            else {\\n                l = mid;\\n            }\\n            if (l+1 == r){\\n                sum = 0;\\n                for (int i = 0; i<n; i++){\\n                    if (arr[i] < l){\\n                        sum += arr[i];\\n                    }\\n                    else {\\n                        sum += l;\\n                    }\\n                }\\n                diff = abs(target - sum);\\n                if (diff <= minm){\\n                    minm = diff;\\n                    ans = l;\\n                }\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int l = 0, r = 100000;\\n        int ans = -1,minm = INT_MAX;\\n        \\n        while (l < r) {\\n            int mid = l + (r-l+1)/2;\\n            long long int sum = 0;\\n            for (int i = 0; i<n; i++){\\n                if (arr[i] < mid){\\n                    sum += arr[i];\\n                }\\n                else {\\n                    sum += mid;\\n                }\\n            }\\n            long long int diff = abs(target - sum);\\n            if (diff <= minm){\\n                minm = diff;\\n                ans = mid;\\n            }\\n            if (sum >= target){\\n                r = mid;\\n            }\\n            else {\\n                l = mid;\\n            }\\n            if (l+1 == r){\\n                sum = 0;\\n                for (int i = 0; i<n; i++){\\n                    if (arr[i] < l){\\n                        sum += arr[i];\\n                    }\\n                    else {\\n                        sum += l;\\n                    }\\n                }\\n                diff = abs(target - sum);\\n                if (diff <= minm){\\n                    minm = diff;\\n                    ans = l;\\n                }\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549536,
                "title": "python-easy-to-read-and-understand-binary-search",
                "content": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        start, end = 0, max(arr)\\n        res, mn, val = float(\"inf\"), float(\"inf\"), -1\\n        while start <= end:\\n            mid = (start + end)//2\\n            sums = 0\\n            for i in arr:\\n                sums += min(mid, i)\\n            val = abs(sums-target)\\n            if val == mn:\\n                res = min(res, mid)\\n            if val < mn:\\n                mn = val\\n                res = mid\\n            if sums >= target:\\n                end = mid-1\\n            else:\\n                start = mid+1\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        start, end = 0, max(arr)\\n        res, mn, val = float(\"inf\"), float(\"inf\"), -1\\n        while start <= end:\\n            mid = (start + end)//2\\n            sums = 0\\n            for i in arr:\\n                sums += min(mid, i)\\n            val = abs(sums-target)\\n            if val == mn:\\n                res = min(res, mid)\\n            if val < mn:\\n                mn = val\\n                res = mid\\n            if sums >= target:\\n                end = mid-1\\n            else:\\n                start = mid+1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2331504,
                "title": "c-o-nlogn-binary-search-solution-97-faster",
                "content": "\\nclass Solution {\\npublic:\\n    \\n    int fun(int m, vector<int>& arr){\\n       int sum = 0;\\n        for(int i = 0; i < arr.size(); i++){\\n            if(arr[i] >= m)\\n                sum += m;\\n            else \\n                sum += arr[i];\\n        }\\n        return sum;\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        \\n        int l = 0, h = *max_element(arr.begin(),arr.end());\\n        \\n        pair<int,int> left, right;\\n        \\n        left.second = right.second = INT_MAX;\\n        while(l <= h){\\n            int m = l + (h-l)/2;\\n            int sum = fun(m,arr);\\n            \\n            if(sum == target)\\n                return m;\\n            else if(sum < target){   // left half\\n                if(abs(target-sum) < left.second){\\n                    left.second = abs(target-sum);\\n                    left.first = m;\\n                }\\n                l = m+1;\\n            }\\n            else{                    // right half\\n                if(abs(target-sum) < right.second){\\n                    right.second = abs(target-sum);\\n                    right.first = m;\\n                }\\n                h = m-1;\\n            }\\n        }\\n        \\n        if(right.second == left.second)\\n            return left.first;\\n        else if(right.second < left.second)\\n            return right.first;\\n        else return left.first;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int fun(int m, vector<int>& arr){\\n       int sum = 0;\\n        for(int i = 0; i < arr.size(); i++){\\n            if(arr[i] >= m)\\n                sum += m;\\n            else \\n                sum += arr[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2172759,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    int max = 0;\\n    int len;\\n    public int findBestValue(int[] arr, int target) {\\n        this.len = arr.length;\\n        \\n        for (int i = 0; i < len; i++)\\n            max = Math.max(max, arr[i]);\\n        \\n        int l = 0;\\n        int r = max;\\n        while(l < r){\\n            int mid = l + (r-l) / 2;\\n            \\n            if(check(arr, mid, target) <= check(arr, mid+1, target))\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n    \\n    private int check(int[] arr, int value, int target){\\n        int sum = 0;\\n        for(int e : arr){\\n            if(e > value)\\n                sum += value;\\n            else\\n                sum += e;\\n        }\\n        \\n        return Math.abs(sum-target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    int len;\\n    public int findBestValue(int[] arr, int target) {\\n        this.len = arr.length;\\n        \\n        for (int i = 0; i < len; i++)\\n            max = Math.max(max, arr[i]);\\n        \\n        int l = 0;\\n        int r = max;\\n        while(l < r){\\n            int mid = l + (r-l) / 2;\\n            \\n            if(check(arr, mid, target) <= check(arr, mid+1, target))\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n    \\n    private int check(int[] arr, int value, int target){\\n        int sum = 0;\\n        for(int e : arr){\\n            if(e > value)\\n                sum += value;\\n            else\\n                sum += e;\\n        }\\n        \\n        return Math.abs(sum-target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158495,
                "title": "java-binary-search-easy-to-understand-intuitive",
                "content": "```\\nclass Solution {\\n    int getArraySum(int[] nums, int value)\\n    {\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (nums[i] <= value) sum = sum + nums[i];\\n            else sum = sum + value;\\n        }\\n        return sum;\\n    }\\n    public int findBestValue(int[] nums, int target) \\n    {\\n        int mx = 0, n = nums.length;\\n        for (int i = 0; i < n; i++) mx = Math.max(mx, nums[i]); \\n        int low = 0, high = mx;\\n        int upperBestVal = -1, upperBestSum = -1;\\n        int lowerBestVal = -1, lowerBestSum = -1;\\n        //========================================\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            int newSum = getArraySum(nums, mid);\\n            if (newSum > target) \\n            { \\n                upperBestVal = mid; \\n                upperBestSum = newSum;\\n                high = mid - 1; \\n            }\\n            else if (newSum <= target) \\n            {\\n                lowerBestVal = mid; \\n                lowerBestSum = newSum;\\n                low = mid + 1; \\n            }\\n        }\\n        //===============================================\\n        int lowerDiff = Math.abs(target - lowerBestSum);\\n        int upperDiff = Math.abs(upperBestSum - target);\\n        if (lowerDiff < upperDiff) return lowerBestVal;\\n        else if (upperDiff < lowerDiff) return upperBestVal;\\n        else if (lowerDiff == upperDiff) return Math.min(upperBestVal, lowerBestVal);\\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int getArraySum(int[] nums, int value)\\n    {\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (nums[i] <= value) sum = sum + nums[i];\\n            else sum = sum + value;\\n        }\\n        return sum;\\n    }\\n    public int findBestValue(int[] nums, int target) \\n    {\\n        int mx = 0, n = nums.length;\\n        for (int i = 0; i < n; i++) mx = Math.max(mx, nums[i]); \\n        int low = 0, high = mx;\\n        int upperBestVal = -1, upperBestSum = -1;\\n        int lowerBestVal = -1, lowerBestSum = -1;\\n        //========================================\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            int newSum = getArraySum(nums, mid);\\n            if (newSum > target) \\n            { \\n                upperBestVal = mid; \\n                upperBestSum = newSum;\\n                high = mid - 1; \\n            }\\n            else if (newSum <= target) \\n            {\\n                lowerBestVal = mid; \\n                lowerBestSum = newSum;\\n                low = mid + 1; \\n            }\\n        }\\n        //===============================================\\n        int lowerDiff = Math.abs(target - lowerBestSum);\\n        int upperDiff = Math.abs(upperBestSum - target);\\n        if (lowerDiff < upperDiff) return lowerBestVal;\\n        else if (upperDiff < lowerDiff) return upperBestVal;\\n        else if (lowerDiff == upperDiff) return Math.min(upperBestVal, lowerBestVal);\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809101,
                "title": "c-prefix-sum-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& nums, int target) {\\n        \\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int>pref(n,0);\\n        pref[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            pref[i]=nums[i]+pref[i-1];\\n        }\\n        \\n            int mnDiff=INT_MAX;\\n           int diff,sum;\\n            int ans=-1;\\n            for(int i=0;i<=nums[n-1];i++){\\n\\n            int idx=upper_bound(nums.begin(),nums.end(),i)-nums.begin();\\n            \\n             if(idx==0)\\n            sum=n*i;\\n                else if(idx==n)\\n            sum=pref[n-1];\\n                else\\n            sum=pref[idx-1] + i*(n-idx);\\n            \\n            diff=abs(target-sum);\\n                \\n                if(diff<mnDiff){\\n                    mnDiff=diff;\\n                    ans=i;\\n                }\\n        }    \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int findBestValue(vector<int>& nums, int target) {\\n        \\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int>pref(n,0);\\n        pref[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            pref[i]=nums[i]+pref[i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1121369,
                "title": "javascript-solution-no-binary-search",
                "content": "* Runtime: 84 ms, faster than 89.66% of JavaScript online submissions for Sum of Mutated Array Closest to Target.\\n* Memory Usage: 40.8 MB, less than 43.10% of JavaScript online submissions for Sum of Mutated Array Closest to Target.\\n```\\nvar findBestValue = function(arr, target) {\\n    arr.sort((a, b) => a - b);\\n    let sum = 0;\\n    for (let i = 0; i < arr.length; i++) {\\n        const lengthOfNumsToRight = arr.length - i;\\n        const currentNum = arr[i];\\n        if (sum + (currentNum * lengthOfNumsToRight) > target) {\\n            return Math.ceil((target - sum) / lengthOfNumsToRight - 0.5);\\n        }\\n        sum += currentNum;\\n    }\\n\\n    return arr[arr.length - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findBestValue = function(arr, target) {\\n    arr.sort((a, b) => a - b);\\n    let sum = 0;\\n    for (let i = 0; i < arr.length; i++) {\\n        const lengthOfNumsToRight = arr.length - i;\\n        const currentNum = arr[i];\\n        if (sum + (currentNum * lengthOfNumsToRight) > target) {\\n            return Math.ceil((target - sum) / lengthOfNumsToRight - 0.5);\\n        }\\n        sum += currentNum;\\n    }\\n\\n    return arr[arr.length - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1112038,
                "title": "simple-solution-with-explanation",
                "content": "Success\\n        Details \\n        Runtime: 96 ms, faster than 82.70% of Python3 online submissions for Sum of Mutated Array Closest to Target.\\n     Memory Usage: 15.3 MB, less than 69.58% of Python3 online submissions for Sum of Mutated Array Closest to    Target.\\n\\t \\n\\t \\n\\t \\n\\t\\t# SO BASICALLY THE LOGIC IS FIRSTLY \\'LL SORT THE ARR THAT WE ARE GONNA DIVIDE THE TARGET         WITH LEN(ARR)\\n        # AND CHECK IF THE ARR[I]>= SOL(TARGET /LEN(ARR)) IF THAT IS THE CASE THEN\\n        #WE WILL JUST RETURN THE SOL\\n        #OTHERWISE WE ARE GONNA SUBRATCT ARR[I] FROM TARGET AND DECREASE THE LEN\\n        #AT EACH ITERATION.\\n        #THE REASON WE ARE DOING THIS BEACUSE \\n        #SUPOOSE WE REACHED THE FIRST NO OF ARR i.e. 2 THEN WE WILL SEE IF TARGET=<ARR[I]\\n        #NEITHER 2 NOR 3 IS > SO DECREMENT THE COUNT OF LEN AND SUBRATCT ARR[I] FROM TARGET\\n        #ND AFTER ALL WE DON\\'T GET ANY THING THEN Wnums.sort(E SIMPLY RETURN THE LARGET VAL\\n        \\n        \\n        \\n        arr.sort()\\n        \\n        l = len(arr)\\n        \\n        for i in range(l):\\n            sol = round(target/l)\\n            if arr[i]>=sol:\\n                return sol\\n            else:\\n                target-=arr[i]\\n                l-=1\\n                \\n        return max(arr)\\n        \\n**If you find it helpful please upvote**\\n*Nd if you have any questions or suggestion please comment down. I will reply as soon as possible*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Success\\n        Details \\n        Runtime: 96 ms, faster than 82.70% of Python3 online submissions for Sum of Mutated Array Closest to Target.\\n     Memory Usage: 15.3 MB, less than 69.58% of Python3 online submissions for Sum of Mutated Array Closest to    Target.\\n\\t \\n\\t \\n\\t \\n\\t\\t# SO BASICALLY THE LOGIC IS FIRSTLY \\'LL SORT THE ARR THAT WE ARE GONNA DIVIDE THE TARGET         WITH LEN(ARR)\\n        # AND CHECK IF THE ARR[I]>= SOL(TARGET /LEN(ARR)) IF THAT IS THE CASE THEN\\n        #WE WILL JUST RETURN THE SOL\\n        #OTHERWISE WE ARE GONNA SUBRATCT ARR[I] FROM TARGET AND DECREASE THE LEN\\n        #AT EACH ITERATION.\\n        #THE REASON WE ARE DOING THIS BEACUSE \\n        #SUPOOSE WE REACHED THE FIRST NO OF ARR i.e. 2 THEN WE WILL SEE IF TARGET=<ARR[I]\\n        #NEITHER 2 NOR 3 IS > SO DECREMENT THE COUNT OF LEN AND SUBRATCT ARR[I] FROM TARGET\\n        #ND AFTER ALL WE DON\\'T GET ANY THING THEN Wnums.sort(E SIMPLY RETURN THE LARGET VAL\\n        \\n        \\n        \\n        arr.sort()\\n        \\n        l = len(arr)\\n        \\n        for i in range(l):\\n            sol = round(target/l)\\n            if arr[i]>=sol:\\n                return sol\\n            else:\\n                target-=arr[i]\\n                l-=1\\n                \\n        return max(arr)\\n        \\n**If you find it helpful please upvote**\\n*Nd if you have any questions or suggestion please comment down. I will reply as soon as possible*",
                "codeTag": "Unknown"
            },
            {
                "id": 842528,
                "title": "sort-python",
                "content": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        \\n        \\n        arr.sort()\\n        \\n        length = len(arr)\\n        \\n        \\n        for i in range(length):\\n            \\n            sol = round(target / length)\\n            \\n            if(arr[i] >= sol):\\n                return sol\\n            \\n            target -= arr[i]\\n            length -=1\\n            \\n        return arr[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        \\n        \\n        arr.sort()\\n        \\n        length = len(arr)\\n        \\n        \\n        for i in range(length):\\n            \\n            sol = round(target / length)\\n            \\n            if(arr[i] >= sol):\\n                return sol\\n            \\n            target -= arr[i]\\n            length -=1\\n            \\n        return arr[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478200,
                "title": "amazing-c-easy-to-understand-faster-than-99-5",
                "content": "I can not believe that my solution can work so well!\\nRuntime: 12 ms, faster than 99.52% of C++ online submissions for Sum of Mutated Array Closest to Target.\\nMemory Usage: 9.4 MB, less than 100.00% of C++ online submissions for Sum of Mutated Array Closest to Target.\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int res=0;\\n        int differ=INT_MAX;\\n        int left=0;\\n        int right=INT_MIN;\\n        for(int i=0; i<arr.size();++i){\\n            \\n            right=max(right,arr[i]);\\n            \\n        }\\n        while(left<=right){\\n            int mid=(left+right)/2;\\n            int sum=0;\\n            for(int temp: arr){\\n                int curr=temp>mid?mid:temp;\\n                sum+=curr;\\n            }\\n            if(abs(sum-target)<differ){\\n                res=mid;\\n                differ=abs(sum-target);\\n                \\n            }\\n            if(abs(sum-target)==differ){\\n                res=min(res,mid);\\n            }\\n            if(sum>target){\\n                right=mid-1;\\n            }\\n            else if(sum==target){\\n                right--;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int res=0;\\n        int differ=INT_MAX;\\n        int left=0;\\n        int right=INT_MIN;\\n        for(int i=0; i<arr.size();++i){\\n            \\n            right=max(right,arr[i]);\\n            \\n        }\\n        while(left<=right){\\n            int mid=(left+right)/2;\\n            int sum=0;\\n            for(int temp: arr){\\n                int curr=temp>mid?mid:temp;\\n                sum+=curr;\\n            }\\n            if(abs(sum-target)<differ){\\n                res=mid;\\n                differ=abs(sum-target);\\n                \\n            }\\n            if(abs(sum-target)==differ){\\n                res=min(res,mid);\\n            }\\n            if(sum>target){\\n                right=mid-1;\\n            }\\n            else if(sum==target){\\n                right--;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464286,
                "title": "python-binary-search",
                "content": "```python\\nclass Solution:\\n    def score(self, value):\\n        res = 0\\n        for e in self.arr:\\n            if e > value:\\n                res += value\\n            else:\\n                res += e\\n        return res\\n    \\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        self.arr = arr[:]\\n        l, h = 1, max(arr)\\n        while l < h:\\n            m = (l+h) // 2\\n            if self.score(m) < target:\\n                l = m + 1\\n            else:\\n                h = m\\n        #print(l, h)        \\n        s1 = abs(self.score(h-1)-target)\\n        s2 = abs(self.score(h)-target)\\n        if s1 <= s2:\\n            return h-1\\n        return h\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def score(self, value):\\n        res = 0\\n        for e in self.arr:\\n            if e > value:\\n                res += value\\n            else:\\n                res += e\\n        return res\\n    \\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        self.arr = arr[:]\\n        l, h = 1, max(arr)\\n        while l < h:\\n            m = (l+h) // 2\\n            if self.score(m) < target:\\n                l = m + 1\\n            else:\\n                h = m\\n        #print(l, h)        \\n        s1 = abs(self.score(h-1)-target)\\n        s2 = abs(self.score(h)-target)\\n        if s1 <= s2:\\n            return h-1\\n        return h\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463713,
                "title": "java-hashmap-linear-solution",
                "content": "```\\nclass Solution {\\n    public int findBestValue(int[] nums, int target) {\\n        Map<Integer,Integer>map=new HashMap<>();\\n        int ans=0;\\n        int dif=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        \\n        int sum=0;int counter=0;\\n        for(int i=0;i<=target;i++){\\n            int total=0;\\n            if(map.containsKey(i)){\\n                counter+=map.get(i);\\n                sum=sum+(i*map.get(i));\\n                total=sum+(nums.length-counter)*i;    \\n            }else{\\n                total=sum+(nums.length-counter)*i; \\n            }\\n            if(dif>Math.abs(total-target)){\\n                dif=Math.abs(total-target);\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] nums, int target) {\\n        Map<Integer,Integer>map=new HashMap<>();\\n        int ans=0;\\n        int dif=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        \\n        int sum=0;int counter=0;\\n        for(int i=0;i<=target;i++){\\n            int total=0;\\n            if(map.containsKey(i)){\\n                counter+=map.get(i);\\n                sum=sum+(i*map.get(i));\\n                total=sum+(nums.length-counter)*i;    \\n            }else{\\n                total=sum+(nums.length-counter)*i; \\n            }\\n            if(dif>Math.abs(total-target)){\\n                dif=Math.abs(total-target);\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463516,
                "title": "python-3-partitioning-no-binary-search-28ms-beats-100",
                "content": "Partition into greater and less than average* until everything above average or one element left.\\n\\\\* Edit: by average I mean the optimal case when each element is exactly `target / array size` rounded to the nearest integer.\\n\\n```py\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        if n == 1:\\n            return min(arr[0], target)\\n\\n        ravg = round(target / n)\\n        gt = []\\n        next_total = target\\n        for num in arr:\\n            if num <= ravg:\\n                next_total -= num\\n            else:\\n                gt.append(num)\\n        \\n\\t\\t# all elements greater than the average\\n        if next_total == target:\\n            return ravg\\n        \\n        return self.findBestValue(gt, next_total)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        if n == 1:\\n            return min(arr[0], target)\\n\\n        ravg = round(target / n)\\n        gt = []\\n        next_total = target\\n        for num in arr:\\n            if num <= ravg:\\n                next_total -= num\\n            else:\\n                gt.append(num)\\n        \\n\\t\\t# all elements greater than the average\\n        if next_total == target:\\n            return ravg\\n        \\n        return self.findBestValue(gt, next_total)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463377,
                "title": "python-solution-using-sorting",
                "content": "For any number in the array you need to know how many other numbers are bigger than or equal to it.\\nTherefore the first thing to do is sorting the array.\\n\\nFor every index and number in the sorted array:\\n- ```prefix_sum``` contains the sum of all previous numbers.\\n- There are ```suffix_length``` numbers left in the array including the ```current_number```.\\n- A value that would optimally reduce the difference to the target can be calculated if you divide the difference of the target and the ```prefix_sum``` by the ```suffix_length```.\\n- Such a value must be constrained so that it won\\'t be bigger than the ```current_number``` or smaller than the ```previous_number```.\\n- Then the array sum that is obtainable by replacing all numbers starting at the current index by ```value``` is easily calculated by multiplying ```value``` with ```suffix_length``` and adding the ```prefix_sum```.\\n- All that\\'s left to do is to update ```min_difference``` and ```min_value``` if the difference between that sum and the target is smaller than those previously found or if it is equal and ```value``` is smaller.\\n\\nTime complexity: ```O(n log n)``` (for sorting)\\nSpace complexity: ```O(n)``` (for sorting)\\n\\n```python\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        \\n        prefix_sum = 0\\n        suffix_length = len(arr)\\n        \\n        previous_number = 0\\n        min_value = 0\\n        min_difference = math.inf\\n        \\n        for index, current_number in enumerate(arr):\\n            value = round((target - prefix_sum) / suffix_length)\\n            value = max(previous_number, min(current_number, value))\\n            \\n            calculated_sum = prefix_sum + suffix_length * value\\n            \\n            difference = abs(calculated_sum - target)\\n            \\n            if difference < min_difference or (difference == min_difference and value < min_value):\\n                min_difference = difference\\n                min_value = value\\n            \\n            prefix_sum += current_number\\n            suffix_length -= 1\\n            previous_number = current_number\\n            \\n        return min_value\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```prefix_sum```\n```suffix_length```\n```current_number```\n```prefix_sum```\n```suffix_length```\n```current_number```\n```previous_number```\n```value```\n```value```\n```suffix_length```\n```prefix_sum```\n```min_difference```\n```min_value```\n```value```\n```O(n log n)```\n```O(n)```\n```python\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        \\n        prefix_sum = 0\\n        suffix_length = len(arr)\\n        \\n        previous_number = 0\\n        min_value = 0\\n        min_difference = math.inf\\n        \\n        for index, current_number in enumerate(arr):\\n            value = round((target - prefix_sum) / suffix_length)\\n            value = max(previous_number, min(current_number, value))\\n            \\n            calculated_sum = prefix_sum + suffix_length * value\\n            \\n            difference = abs(calculated_sum - target)\\n            \\n            if difference < min_difference or (difference == min_difference and value < min_value):\\n                min_difference = difference\\n                min_value = value\\n            \\n            prefix_sum += current_number\\n            suffix_length -= 1\\n            previous_number = current_number\\n            \\n        return min_value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463296,
                "title": "c-sorting-binary-search-o-nlogn-simple-unoptimized-solution",
                "content": "The idea is to find the best answer, and it will always lie in the range [0, max-number]\\n\\nThe approach is to find to try for all possible numbers in the range and for each number, find the count of numbers which are greater than this (using `lower_bound` on sorted array)\\nand then find sum of numbers smaller than this number (using prefix sum). \\n\\nI know that this is an optimized solution and I use extra space(for `prefix-sum`), as well sorting and `binary-search` for every candidate number, but I could think of this only during contest. (But was not able to code it, due to less time).\\nThis problem confused me alot, to come up with a solution fast.\\n\\nTime complexity : `O(n logn)` and Space complexity : `O(n)`\\n\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& A, int target) {\\n        int n = A.size();\\n        if(n == 0)\\n            return 0;\\n        int h = *max_element(A.begin(), A.end());\\n        sort(A.begin(), A.end());\\n        \\n        vector<int> pre(n);\\n        for(int i = 0; i < n; i++)\\n            pre[i] = A[i] + (i - 1 >= 0 ? pre[i - 1] : 0);\\n        \\n        if(pre[n - 1] <= target)\\n            return h;\\n        int ans = h, diff = abs(pre[n - 1] - target);\\n        for(int v = 0; v <= h; v++)\\n        {\\n            int higherThanVid = lower_bound(A.begin(), A.end(), v) - A.begin();\\n            \\n            int lowerThanV = 0;\\n            if(higherThanVid > 0)\\n                lowerThanV = pre[ higherThanVid - 1 ];\\n            int higherSum = (n - higherThanVid)*v;\\n            int nsum = lowerThanV + higherSum;\\n            \\n            if(diff > abs(nsum - target) || (diff == abs(nsum - target) && ans > v))\\n            {\\n                ans = v;\\n                diff = abs(nsum - target);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& A, int target) {\\n        int n = A.size();\\n        if(n == 0)\\n            return 0;\\n        int h = *max_element(A.begin(), A.end());\\n        sort(A.begin(), A.end());\\n        \\n        vector<int> pre(n);\\n        for(int i = 0; i < n; i++)\\n            pre[i] = A[i] + (i - 1 >= 0 ? pre[i - 1] : 0);\\n        \\n        if(pre[n - 1] <= target)\\n            return h;\\n        int ans = h, diff = abs(pre[n - 1] - target);\\n        for(int v = 0; v <= h; v++)\\n        {\\n            int higherThanVid = lower_bound(A.begin(), A.end(), v) - A.begin();\\n            \\n            int lowerThanV = 0;\\n            if(higherThanVid > 0)\\n                lowerThanV = pre[ higherThanVid - 1 ];\\n            int higherSum = (n - higherThanVid)*v;\\n            int nsum = lowerThanV + higherSum;\\n            \\n            if(diff > abs(nsum - target) || (diff == abs(nsum - target) && ans > v))\\n            {\\n                ans = v;\\n                diff = abs(nsum - target);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163387,
                "title": "java-solution-1-ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int arrSum = 0;\\n        for(int num: arr) {\\n            arrSum += num;\\n        }\\n        return binarySearch(0, target, arr, target, arrSum);\\n    }\\n\\n    private int getSum(int[] arr, int num) {\\n        int sum = 0;\\n        for(int curr: arr) {\\n            sum += Math.min(curr, num);\\n        }\\n        return sum;\\n    }\\n\\n    private int binarySearch(int begin, int end, int[] arr, int target, int arrSum) {\\n        if(begin == end) {\\n            return begin;\\n        }\\n        if(end == begin + 1) {\\n            int endSum = getSum(arr, end);\\n            int beginSum = getSum(arr, begin);\\n            if(Math.abs(target - beginSum) <= Math.abs(target - endSum)) {\\n                return begin;\\n            }\\n            return end;\\n        }\\n        int medium = begin + (end - begin) / 2;\\n        int mediumSum = getSum(arr, medium);\\n        if(mediumSum >= target || mediumSum == arrSum) {\\n            return binarySearch(begin, medium, arr, target, arrSum);\\n        }\\n        return binarySearch(medium, end, arr, target, arrSum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int arrSum = 0;\\n        for(int num: arr) {\\n            arrSum += num;\\n        }\\n        return binarySearch(0, target, arr, target, arrSum);\\n    }\\n\\n    private int getSum(int[] arr, int num) {\\n        int sum = 0;\\n        for(int curr: arr) {\\n            sum += Math.min(curr, num);\\n        }\\n        return sum;\\n    }\\n\\n    private int binarySearch(int begin, int end, int[] arr, int target, int arrSum) {\\n        if(begin == end) {\\n            return begin;\\n        }\\n        if(end == begin + 1) {\\n            int endSum = getSum(arr, end);\\n            int beginSum = getSum(arr, begin);\\n            if(Math.abs(target - beginSum) <= Math.abs(target - endSum)) {\\n                return begin;\\n            }\\n            return end;\\n        }\\n        int medium = begin + (end - begin) / 2;\\n        int mediumSum = getSum(arr, medium);\\n        if(mediumSum >= target || mediumSum == arrSum) {\\n            return binarySearch(begin, medium, arr, target, arrSum);\\n        }\\n        return binarySearch(medium, end, arr, target, arrSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082819,
                "title": "prefix-sum-and-binary-search-with-comments",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int FindBestValue(int[] arr, int target) {\\n        var res = Int32.MaxValue;\\n        var diff = Int32.MaxValue;\\n\\n        var n = arr.Length;\\n        Array.Sort(arr);\\n\\n        var sums = new int[n];\\n        sums[0] = arr[0];\\n\\n        // prefix sum for further calculations\\n        for (var i = 1; i < n; i++) {\\n            sums[i] = arr[i] + sums[i - 1];\\n        }\\n\\n        var lo = 0;\\n        var hi = arr[n - 1];\\n\\n        while (lo <= hi) {\\n            // this is the value we are trying to guess\\n            var num = lo + (hi - lo) / 2;\\n\\n            var left = 0;\\n            var right = n - 1;\\n\\n            // with binary seach we search for index from\\n            // we need to correct sum\\n            while (left < right) {\\n                var mid = left + (right - left) / 2;\\n\\n                if (arr[mid] < num) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid;\\n                }\\n            }\\n\\n            if (arr[left] < num) left++;\\n\\n            // calc the new sum and the difference with target\\n            var sum = ((left == 0) ? 0 : sums[left - 1]) + num * (n - left);\\n            var difference = Math.Abs(sum - target);\\n\\n            // update result depending on the difference\\n            if (difference < diff) {\\n                res = num;\\n            } else if (difference == diff) {\\n                res = Math.Min(res, num);\\n            }\\n\\n            diff = Math.Min(difference, diff);\\n\\n            if (sum < target) {\\n                lo = num + 1;\\n            } else {\\n                hi = num - 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindBestValue(int[] arr, int target) {\\n        var res = Int32.MaxValue;\\n        var diff = Int32.MaxValue;\\n\\n        var n = arr.Length;\\n        Array.Sort(arr);\\n\\n        var sums = new int[n];\\n        sums[0] = arr[0];\\n\\n        // prefix sum for further calculations\\n        for (var i = 1; i < n; i++) {\\n            sums[i] = arr[i] + sums[i - 1];\\n        }\\n\\n        var lo = 0;\\n        var hi = arr[n - 1];\\n\\n        while (lo <= hi) {\\n            // this is the value we are trying to guess\\n            var num = lo + (hi - lo) / 2;\\n\\n            var left = 0;\\n            var right = n - 1;\\n\\n            // with binary seach we search for index from\\n            // we need to correct sum\\n            while (left < right) {\\n                var mid = left + (right - left) / 2;\\n\\n                if (arr[mid] < num) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid;\\n                }\\n            }\\n\\n            if (arr[left] < num) left++;\\n\\n            // calc the new sum and the difference with target\\n            var sum = ((left == 0) ? 0 : sums[left - 1]) + num * (n - left);\\n            var difference = Math.Abs(sum - target);\\n\\n            // update result depending on the difference\\n            if (difference < diff) {\\n                res = num;\\n            } else if (difference == diff) {\\n                res = Math.Min(res, num);\\n            }\\n\\n            diff = Math.Min(difference, diff);\\n\\n            if (sum < target) {\\n                lo = num + 1;\\n            } else {\\n                hi = num - 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029793,
                "title": "rust-solution-using-ternary-search",
                "content": "\\n# Code\\n```\\nfn helper(arr: &Vec<i32>, target:i32, mid:i32) -> i32 {\\n  let mut temp = 0;\\n  for &v in arr {\\n    temp += v.min(mid);\\n  }\\n  (target-temp).abs()\\n}\\n\\nimpl Solution {\\n    pub fn find_best_value(arr: Vec<i32>, target: i32) -> i32 {\\n      let mut left = 0;\\n      let mut right = 100010;\\n      while left + 2 < right {\\n        let lr1 = (left * 2 + right) / 3;\\n        let lr2 = (left + right * 2) / 3;\\n    \\n        let lr1v = helper(&arr, target, lr1);\\n        let lr2v = helper(&arr, target, lr2);\\n        \\n        if lr1v > lr2v {\\n          left = lr1;\\n        } else {\\n          right = lr2;\\n        }\\n      }\\n\\n      let mut min = i32::max_value();\\n      let mut result = 0;\\n      for mid in (left..=right).rev() {\\n        let v = helper(&arr, target, mid);\\n        if v <= min {\\n          min = v;\\n          result = mid;\\n        }\\n      }\\n\\n      result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfn helper(arr: &Vec<i32>, target:i32, mid:i32) -> i32 {\\n  let mut temp = 0;\\n  for &v in arr {\\n    temp += v.min(mid);\\n  }\\n  (target-temp).abs()\\n}\\n\\nimpl Solution {\\n    pub fn find_best_value(arr: Vec<i32>, target: i32) -> i32 {\\n      let mut left = 0;\\n      let mut right = 100010;\\n      while left + 2 < right {\\n        let lr1 = (left * 2 + right) / 3;\\n        let lr2 = (left + right * 2) / 3;\\n    \\n        let lr1v = helper(&arr, target, lr1);\\n        let lr2v = helper(&arr, target, lr2);\\n        \\n        if lr1v > lr2v {\\n          left = lr1;\\n        } else {\\n          right = lr2;\\n        }\\n      }\\n\\n      let mut min = i32::max_value();\\n      let mut result = 0;\\n      for mid in (left..=right).rev() {\\n        let v = helper(&arr, target, mid);\\n        if v <= min {\\n          min = v;\\n          result = mid;\\n        }\\n      }\\n\\n      result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2780488,
                "title": "python-binary-search-approach-explained",
                "content": "We are asked for a \"value\" such that sum of the array after replacing all elements bigger than \"value\" by \"value\" is closest to the \"target\".\\n\\nNow think about it. What can be the closest sum? It can be the \"sum\" that is equal to \"target\", right? Because in that case, the difference will be 0 which is the smallest possible absolute difference.\\n\\n\\tThis is something you will see in test case arr = [2,3,5], target = 10\\n\\t\\n\\tBecause here, the sum of array is already equal to 10. So there is no need to replace any number.\\n\\t\\n\\tIn other words, in this case, the required value is \"5\" because only if value is \"5\" we will get sum = 10\\n\\t\\n\\tIf value is more than \"5\", then too we will get sum = 10 but we are asked for minimum value in case of tie.\\n\\n\\nTo understand it better, here is a graph of the \"sum\" and \"value\" - \\n\\n![image](https://assets.leetcode.com/users/images/22576c83-8cdf-44c3-b3eb-e1f22924bb57_1667635289.4486818.png)\\n\\n\\nIf you see, when value is 1, we get sum = 3 because we have to replace all values in array by 1 as all are greater. \\nBut when value is 2, we get a higher sum. So absolute difference will be smaller than before. \\nAnd so on when we reach value = 5, in that case, sum will be 10 which is the same as target. So this is the required value here.\\n\\n***HENCE, THE MAIN IDEA IS TO TRY TO FIND THE CLOSEST SUM, THAT IS, THE SUM THAT IS EQUAL TO TARGET!***\\n\\nEven if there exists no such value for a test case where sum of array becomes equal to target, then we will get two values that will give us two closest sums.\\n\\nTake a look at this graph as an example - \\n\\n![image](https://assets.leetcode.com/users/images/4f01b43a-d067-427d-a8d3-f5ab2ab38a86_1667635027.957436.png)\\n\\nAs we can see, at value 4, the sum will be 11. And since target = 10, absolute difference = 1\\nBut at value = 3, sum will be 9. And here as well, absolute difference is 1.\\n\\nSo we have a tie here. Hence, in this case, we will go for the minimum of two values, which is 3.\\n\\nHence, the basic idea of the Binary Search approach is that we try to find a value that results in \"sum == target\". If we can find such a value, we can simply return it. If the sum is less than target, we want a bigger sum hence we move to right side of mid. But if sum is greater than target, we want a smaller sum hence we move to left side of mid.\\n\\nAfter binary search ends, if we were not able to find a value that results in \"sum == target\", then  we will get two values that will result in the closest absolute difference that is, \"start\" and \"end\".\\n\\nAnd we have to choose one of them as the output, depending on whether absolute difference of one is smaller than the other.\\n\\n\\n```\\nclass Solution:\\n    \\n    # Helper method to find the sum off array\\n    # After replacing all elements larger than \"x\" with \"x\"\\n    def getSum(self, x, arr, target):\\n        currSum = 0\\n            \\n        for num in arr: currSum += num if num < x else x\\n            \\n        return currSum\\n    \\n    \\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        # What is the smallest possible \"value\"? It can be \"1\"\\n        # Since range of values in the array is from 1 to 10^4   \\n        \\n        # And similarly, what is the largest possible \"value\"? \\n        # It is the max value in the array\\n        # because any value more than that will always give the same absolute difference\\n          \\n        # So we try to apply Binary Search on this range of 1 to max(arr) to find the required \"value\"\\n        # Because the range is in a sorted order\\n        start = 1\\n        end = max(arr)\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            \\n            # What is this mid?\\n            # This is a possible \"value\"\\n            # So we need to check if after changing all numbers > mid in the array to mid\\n            # The sum is equal to target or not\\n            currSum = self.getSum(mid, arr, target)\\n            \\n            # If the sum we get is same as target, it simply means this is the least possible absolute difference\\n            # Because the absolute difference between sum and target will be \"0\"\\n            # Hence we can simply return \"mid\" value\\n            if currSum == target: return mid\\n            \\n            # If the sum if still less than target, search on right of mid as we want a larger sum\\n            if currSum < target: start = mid + 1\\n                \\n            # If the sum becomes more than target, search on left of mid\\n            else: end = mid - 1\\n        \\n        # Here, \"start\" and \"end\" will be two values that will give us two closest absolute differences\\n        # So, we want the closest of the two values\\n        sum1 = self.getSum(start, arr, target)\\n        sum2 = self.getSum(end, arr, target) \\n        \\n        diff1 = abs(sum1 - target)\\n        diff2 = abs(sum2 - target)\\n        \\n        # Since \"end\" is less than \"start\", this will take care of the condition of a \"tie\"\\n        return start if diff1 < diff2 else end\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # Helper method to find the sum off array\\n    # After replacing all elements larger than \"x\" with \"x\"\\n    def getSum(self, x, arr, target):\\n        currSum = 0\\n            \\n        for num in arr: currSum += num if num < x else x\\n            \\n        return currSum\\n    \\n    \\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        # What is the smallest possible \"value\"? It can be \"1\"\\n        # Since range of values in the array is from 1 to 10^4   \\n        \\n        # And similarly, what is the largest possible \"value\"? \\n        # It is the max value in the array\\n        # because any value more than that will always give the same absolute difference\\n          \\n        # So we try to apply Binary Search on this range of 1 to max(arr) to find the required \"value\"\\n        # Because the range is in a sorted order\\n        start = 1\\n        end = max(arr)\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            \\n            # What is this mid?\\n            # This is a possible \"value\"\\n            # So we need to check if after changing all numbers > mid in the array to mid\\n            # The sum is equal to target or not\\n            currSum = self.getSum(mid, arr, target)\\n            \\n            # If the sum we get is same as target, it simply means this is the least possible absolute difference\\n            # Because the absolute difference between sum and target will be \"0\"\\n            # Hence we can simply return \"mid\" value\\n            if currSum == target: return mid\\n            \\n            # If the sum if still less than target, search on right of mid as we want a larger sum\\n            if currSum < target: start = mid + 1\\n                \\n            # If the sum becomes more than target, search on left of mid\\n            else: end = mid - 1\\n        \\n        # Here, \"start\" and \"end\" will be two values that will give us two closest absolute differences\\n        # So, we want the closest of the two values\\n        sum1 = self.getSum(start, arr, target)\\n        sum2 = self.getSum(end, arr, target) \\n        \\n        diff1 = abs(sum1 - target)\\n        diff2 = abs(sum2 - target)\\n        \\n        # Since \"end\" is less than \"start\", this will take care of the condition of a \"tie\"\\n        return start if diff1 < diff2 else end\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768926,
                "title": "solution-with-simple-binary-search-in-c-cpp",
                "content": "# Pease Upvote if you like this solution \\nclass Solution {\\npublic:\\n    bool check(int target, vector<int>& arr, int mid){\\n        \\n        int sum = 0, sizeQ = arr.size();\\n        for(int i=0; i<sizeQ; i++){\\n           if(arr[i] > mid ) sum += mid;\\n            else sum += arr[i];\\n        }\\n        return (sum <= target) ? true : false;\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int low = 0, mid, ans, sizeQ = arr.size(), hi = *max_element(arr.begin(),arr.end());\\n        \\n        while(low <= hi){\\n            mid = low + (hi-low)/2;\\n            \\n            if(check(target, arr, mid)){\\n                ans = mid;\\n                low = mid+1;        \\n            }\\n            else hi = mid-1;\\n        }\\n        \\n        \\n        int s =0, ss=0;\\n        for(int i=0; i<sizeQ; i++)\\n            s+= (arr[i] > ans+1 ) ? ans+1 : arr[i];\\n        \\n         for(int i=0; i<sizeQ; i++)\\n            ss+= (arr[i] > ans) ? ans : arr[i];\\n        \\n        return abs(s-target) < abs(ss-target) ? ans+1 : ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool check(int target, vector<int>& arr, int mid){\\n        \\n        int sum = 0, sizeQ = arr.size();\\n        for(int i=0; i<sizeQ; i++){\\n           if(arr[i] > mid ) sum += mid;\\n            else sum += arr[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2450965,
                "title": "java-run-o-nlogn-space-o-n",
                "content": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int max = 0;\\n        for (int n : arr) {\\n            max = Math.max(max, n);\\n        }\\n        int left = 0, right = max;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (check(arr, mid, target) <= check(arr, mid + 1, target)) {\\n                right = mid;\\n            }\\n            else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n    public int check(int[] arr, int value, int target) {\\n        int sum = 0;\\n        for (int n : arr) {\\n            if (n > value) {\\n                sum += value;\\n            }\\n            else {\\n                sum += n;\\n            }\\n        }\\n        return Math.abs(sum - target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int max = 0;\\n        for (int n : arr) {\\n            max = Math.max(max, n);\\n        }\\n        int left = 0, right = max;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (check(arr, mid, target) <= check(arr, mid + 1, target)) {\\n                right = mid;\\n            }\\n            else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n    public int check(int[] arr, int value, int target) {\\n        int sum = 0;\\n        for (int n : arr) {\\n            if (n > value) {\\n                sum += value;\\n            }\\n            else {\\n                sum += n;\\n            }\\n        }\\n        return Math.abs(sum - target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104180,
                "title": "simple-and-nice-javascript-solution",
                "content": "```\\nfunction findBestValue (A, target, n = A.length) {\\n    // sort first\\n    A.sort((a, b) => a - b)\\n    \\n    // set accumulate\\n    let a = 0\\n\\n    // loop\\n    for (let i in A) {\\n        // difference\\n        const x = (target - a) / (n - i)\\n\\n        // get integer\\n        if (x < A[i]) {\\n            return Math.round(x - 0.1)\\n        }\\n\\n        // sum\\n        a += A[i]\\n    }\\n\\t\\n\\t// result\\n    return A[n - 1]\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction findBestValue (A, target, n = A.length) {\\n    // sort first\\n    A.sort((a, b) => a - b)\\n    \\n    // set accumulate\\n    let a = 0\\n\\n    // loop\\n    for (let i in A) {\\n        // difference\\n        const x = (target - a) / (n - i)\\n\\n        // get integer\\n        if (x < A[i]) {\\n            return Math.round(x - 0.1)\\n        }\\n\\n        // sum\\n        a += A[i]\\n    }\\n\\t\\n\\t// result\\n    return A[n - 1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081944,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int eval(vector<int> a,int m,int t)\\n    {\\n        int sum=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            sum+=min(a[i],m);\\n        }\\n        return abs(t-sum);\\n    }\\n    int findBestValue(vector<int>& arr, int target)\\n    {\\n        int low=0,high=100000;\\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(eval(arr,mid,target)>eval(arr,mid+1,target))\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        return low;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int eval(vector<int> a,int m,int t)\\n    {\\n        int sum=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            sum+=min(a[i],m);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1984416,
                "title": "python3-binary-search-o-nlogk",
                "content": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        l,r=0,max(arr)\\n        while l<r:\\n            mid=(l+r)//2\\n            total=sum(el if el<=mid else mid for el in arr)\\n            if total<target:\\n                l=mid+1\\n            else:\\n                r=mid\\n        a=sum(el if el<=l else l for el in arr)\\n        b=sum(el if el<=l-1 else l-1 for el in arr)\\n        return l if abs(a-target)<abs(b-target) else l-1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        l,r=0,max(arr)\\n        while l<r:\\n            mid=(l+r)//2\\n            total=sum(el if el<=mid else mid for el in arr)\\n            if total<target:\\n                l=mid+1\\n            else:\\n                r=mid\\n        a=sum(el if el<=l else l for el in arr)\\n        b=sum(el if el<=l-1 else l-1 for el in arr)\\n        return l if abs(a-target)<abs(b-target) else l-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969519,
                "title": "c-easy-detail-explanation-binary",
                "content": "Please ask in the comment if you have any doubt in my code. I will try to reply to your query as soon as possible.\\n\\n```\\nclass Solution {\\npublic:\\n    bool check(int mid, vector<int>& a, int x, int& sum, int& val){\\n        int total = 0;\\n        // Calculating sum according to the question\\n        for(auto i:a){\\n            total += min(i, mid);\\n        }\\n        \\n        // Updating closeness and value\\n        if(abs(total-x) < sum){\\n            sum = abs(total - x);\\n            val = mid;\\n        }\\n        \\n        // Because in case of tie we need minimum number\\n        else if(abs(total-x) == sum){\\n            val = min(val, mid);\\n        }\\n        \\n        return (total < x);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        // Calculating initial closeness to target and initial value\\n        int val = 0, sum = 0;\\n        for(auto i:arr){\\n            val = max(val, i);\\n            sum += i;\\n        }\\n        \\n        sum = abs(sum - target);\\n        int low = 0, high = target;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            \\n            // Checking if the sum is less than target and also\\n            // updating closeness(sum) and value(val) accordingly\\n            if(check(mid, arr, target, sum, val)){\\n                low = mid + 1;\\n            }\\n            else\\n                high = mid - 1;\\n        }\\n        return val;\\n    }\\n};\\n```\\nUpvote if you found my solution helpful :-)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int mid, vector<int>& a, int x, int& sum, int& val){\\n        int total = 0;\\n        // Calculating sum according to the question\\n        for(auto i:a){\\n            total += min(i, mid);\\n        }\\n        \\n        // Updating closeness and value\\n        if(abs(total-x) < sum){\\n            sum = abs(total - x);\\n            val = mid;\\n        }\\n        \\n        // Because in case of tie we need minimum number\\n        else if(abs(total-x) == sum){\\n            val = min(val, mid);\\n        }\\n        \\n        return (total < x);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        // Calculating initial closeness to target and initial value\\n        int val = 0, sum = 0;\\n        for(auto i:arr){\\n            val = max(val, i);\\n            sum += i;\\n        }\\n        \\n        sum = abs(sum - target);\\n        int low = 0, high = target;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            \\n            // Checking if the sum is less than target and also\\n            // updating closeness(sum) and value(val) accordingly\\n            if(check(mid, arr, target, sum, val)){\\n                low = mid + 1;\\n            }\\n            else\\n                high = mid - 1;\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936278,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int summation(vector<int> &arr,int mid)\\n    {\\n        int n=arr.size(),sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]<=mid)\\n            {\\n                sum+=arr[i];\\n            }\\n            else\\n            {\\n                sum+=mid;\\n            }\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        int low=0;\\n        int high=arr[n-1];\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            int sum=summation(arr,mid);\\n            if(target>sum)\\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        int sum_high=summation(arr,high);\\n        int sum_low=summation(arr,low);\\n        if(abs(target-sum_high)>abs(target-sum_low))\\n        {\\n            return low;\\n        }\\n        return high;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int summation(vector<int> &arr,int mid)\\n    {\\n        int n=arr.size(),sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]<=mid)\\n            {\\n                sum+=arr[i];\\n            }\\n            else\\n            {\\n                sum+=mid;\\n            }\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        int low=0;\\n        int high=arr[n-1];\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            int sum=summation(arr,mid);\\n            if(target>sum)\\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        int sum_high=summation(arr,high);\\n        int sum_low=summation(arr,low);\\n        if(abs(target-sum_high)>abs(target-sum_low))\\n        {\\n            return low;\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922344,
                "title": "simple-easy-c-binary-search-nlogn",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int findSum(vector<int> &arr, int mid)\\n    {\\n        int n = arr.size();\\n        int sum = 0;\\n        for (int i = 0; i < n; i++)\\n            if (arr[i] <= mid)\\n                sum += arr[i];\\n            else\\n                sum += mid;\\n        return sum;\\n    }\\n    int findBestValue(vector<int> &arr, int target)\\n    {\\n        int n = arr.size();\\n        int low = 0, high = 0;\\n\\n        for (int i = 0; i < n; i++)\\n            high = max(high, arr[i]);\\n\\n        sort(arr.begin(), arr.end());\\n\\n        while (low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            int sum = findSum(arr, mid);\\n\\n            if (sum >= target)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;\\n        }\\n\\n        int s_low = abs(target - findSum(arr, low));\\n        int s_high = abs(target - findSum(arr, high));\\n\\n        if (s_high <= s_low)\\n            return high;\\n        else\\n            return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int findSum(vector<int> &arr, int mid)\\n    {\\n        int n = arr.size();\\n        int sum = 0;\\n        for (int i = 0; i < n; i++)\\n            if (arr[i] <= mid)\\n                sum += arr[i];\\n            else\\n                sum += mid;\\n        return sum;\\n    }\\n    int findBestValue(vector<int> &arr, int target)\\n    {\\n        int n = arr.size();\\n        int low = 0, high = 0;\\n\\n        for (int i = 0; i < n; i++)\\n            high = max(high, arr[i]);\\n\\n        sort(arr.begin(), arr.end());\\n\\n        while (low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            int sum = findSum(arr, mid);\\n\\n            if (sum >= target)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;\\n        }\\n\\n        int s_low = abs(target - findSum(arr, low));\\n        int s_high = abs(target - findSum(arr, high));\\n\\n        if (s_high <= s_low)\\n            return high;\\n        else\\n            return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848331,
                "title": "binary-search-implementation-with-comments",
                "content": "**[Summary]**\\nThis is my implementation of this challenge using the binary search approach.\\nBreaking up the code in this manner helped me digest and understand the core concept.\\nHope it provides some clarity and guidance to others \\uD83D\\uDE4C\\n\\nBest of luck \\uD83C\\uDF40!\\n\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        // Initialize the binary search parameters with its bounds\\n        int low = 1;\\n        int high = 0;\\n        // O(n): Find the max value\\n        for (int entry : arr) {\\n            high = Math.max(high, entry);\\n        }\\n        // O(nlogn): Use binary search to find the target summation\\n        while (low < high) {\\n            int mid = (low + high) / 2;\\n            // O(n): Calculate the sum of arrays at every iteration\\n            int sum = sumEntireArray(arr, mid);\\n            if (sum == target) {\\n                System.out.println(\"TARGET SUMMMATION WAS MET\");\\n                return mid;\\n            }\\n            else if (sum < target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        \\n        System.out.println(\"NO EXACT SUMMATION WAS FOUND..CHECKING ABSOLUTE DIFFERENCE\");\\n        int lowerBound = target - sumEntireArray(arr, low-1);\\n        int upperBound = sumEntireArray(arr, low) - target;\\n        System.out.println(\"LOWER BOUND: \" + lowerBound + \"\\\\nUPPER BOUND: \" + upperBound);\\n                \\n        if (lowerBound > upperBound) {\\n            System.out.println(\"LOWER SUMMATION IS BETTER!\");\\n            return low;\\n        } else if (upperBound < lowerBound) {\\n            System.out.print(\"UPPER SUMMATION IS BETTER!\");\\n            return low-1;\\n        } else {\\n            System.out.print(\"BOTH SUMMATIONS ARE SAME!\");\\n            return low-1;\\n        }\\n    }\\n    \\n    // A summation helper to calculate the sum managed by a threshold\\n    private int sumEntireArray(int[] arr, int threshold) {\\n        int total_sum = 0;\\n        for (int entry : arr) {\\n            if (entry > threshold) {\\n                total_sum += threshold;\\n            } else {\\n                total_sum += entry;\\n            }\\n        }\\n        return total_sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        // Initialize the binary search parameters with its bounds\\n        int low = 1;\\n        int high = 0;\\n        // O(n): Find the max value\\n        for (int entry : arr) {\\n            high = Math.max(high, entry);\\n        }\\n        // O(nlogn): Use binary search to find the target summation\\n        while (low < high) {\\n            int mid = (low + high) / 2;\\n            // O(n): Calculate the sum of arrays at every iteration\\n            int sum = sumEntireArray(arr, mid);\\n            if (sum == target) {\\n                System.out.println(\"TARGET SUMMMATION WAS MET\");\\n                return mid;\\n            }\\n            else if (sum < target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        \\n        System.out.println(\"NO EXACT SUMMATION WAS FOUND..CHECKING ABSOLUTE DIFFERENCE\");\\n        int lowerBound = target - sumEntireArray(arr, low-1);\\n        int upperBound = sumEntireArray(arr, low) - target;\\n        System.out.println(\"LOWER BOUND: \" + lowerBound + \"\\\\nUPPER BOUND: \" + upperBound);\\n                \\n        if (lowerBound > upperBound) {\\n            System.out.println(\"LOWER SUMMATION IS BETTER!\");\\n            return low;\\n        } else if (upperBound < lowerBound) {\\n            System.out.print(\"UPPER SUMMATION IS BETTER!\");\\n            return low-1;\\n        } else {\\n            System.out.print(\"BOTH SUMMATIONS ARE SAME!\");\\n            return low-1;\\n        }\\n    }\\n    \\n    // A summation helper to calculate the sum managed by a threshold\\n    private int sumEntireArray(int[] arr, int threshold) {\\n        int total_sum = 0;\\n        for (int entry : arr) {\\n            if (entry > threshold) {\\n                total_sum += threshold;\\n            } else {\\n                total_sum += entry;\\n            }\\n        }\\n        return total_sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515242,
                "title": "double-binary-search-logk-logn",
                "content": "```\\nimport bisect\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        if not arr: return abs(target)\\n        \\n        arr.sort()\\n        n = len(arr)\\n        \\n        left, right = 0, arr[-1]\\n        \\n        prefixSum = [0]\\n        \\n        for v in arr:\\n            prefixSum.append(prefixSum[-1] + v)\\n        \\n        start, end = 0, len(arr) - 1\\n        ans = None\\n        minDiff = float(\\'inf\\')\\n        \\n        while left <= right:\\n            mid = (left + right) >> 1\\n            \\n            left_most = bisect.bisect_left(arr, mid, lo = start, hi= end + 1)\\n            summ = prefixSum[left_most] + (n - left_most) * mid\\n            diff = summ - target\\n            \\n            if abs(diff) < minDiff or (abs(diff) == minDiff and mid < ans):\\n                minDiff = abs(diff)\\n                ans = mid\\n            \\n            if diff == 0:\\n                return mid\\n            elif diff < 0:\\n                left = mid + 1\\n                start = left_most\\n            else:\\n                right = mid - 1\\n                end = left_most\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nimport bisect\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        if not arr: return abs(target)\\n        \\n        arr.sort()\\n        n = len(arr)\\n        \\n        left, right = 0, arr[-1]\\n        \\n        prefixSum = [0]\\n        \\n        for v in arr:\\n            prefixSum.append(prefixSum[-1] + v)\\n        \\n        start, end = 0, len(arr) - 1\\n        ans = None\\n        minDiff = float(\\'inf\\')\\n        \\n        while left <= right:\\n            mid = (left + right) >> 1\\n            \\n            left_most = bisect.bisect_left(arr, mid, lo = start, hi= end + 1)\\n            summ = prefixSum[left_most] + (n - left_most) * mid\\n            diff = summ - target\\n            \\n            if abs(diff) < minDiff or (abs(diff) == minDiff and mid < ans):\\n                minDiff = abs(diff)\\n                ans = mid\\n            \\n            if diff == 0:\\n                return mid\\n            elif diff < 0:\\n                left = mid + 1\\n                start = left_most\\n            else:\\n                right = mid - 1\\n                end = left_most\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390461,
                "title": "python-average-o-n-solution",
                "content": "If we have the array sorted, we can easily find the solution to be near (target - left_sum)//(num of remaining number).\\n\\nAs a follow up, we actually don\\'t need to sort the entire array, but utilizing the idea of QuickSelect to find that break point.\\n```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        # We use quickSelect to find a pivot at index i, such that:\\n        #   1. left_sum + arr[i]* (len(arr) -i) >= target\\n\\t\\t#   2. All the element on the left of arr are less than the pivot\\n\\t\\t#   3. We can\\'t find next pivot on the left of current pivot that satisfies 1&2\\n        n = len(arr)\\n        def quickSelect(start, end, left_sum):\\n            if start==end:\\n                return (start, left_sum)\\n            i = start\\n            j = end -1\\n            cur_sum = 0\\n            while i<j:\\n                if arr[i+1] < arr[i]:\\n                    cur_sum += arr[i+1]\\n                    tmp = arr[i+1]\\n                    arr[i+1] = arr[i]\\n                    arr[i] = tmp\\n                    i += 1\\n                else:\\n                    tmp = arr[i+1]\\n                    arr[i+1] = arr[j]\\n                    arr[j] = tmp\\n                    j -= 1\\n            if target > left_sum + cur_sum + (len(arr) - i ) * arr[i]:\\n                return quickSelect(i+1, end, left_sum + cur_sum + arr[i])\\n            else:\\n                return quickSelect(start, i, left_sum)\\n        k, left_sum = quickSelect(0, len(arr), 0)\\n        if k == len(arr):\\n            return arr[k-1]\\n        lower = (target - left_sum) // (n - k) \\n        if abs(target - left_sum - (n-k) * lower) <= abs(target- left_sum - (n-k)* (lower+1)):\\n            return lower\\n        else:\\n            return lower+1\\n                    \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        # We use quickSelect to find a pivot at index i, such that:\\n        #   1. left_sum + arr[i]* (len(arr) -i) >= target\\n\\t\\t#   2. All the element on the left of arr are less than the pivot\\n\\t\\t#   3. We can\\'t find next pivot on the left of current pivot that satisfies 1&2\\n        n = len(arr)\\n        def quickSelect(start, end, left_sum):\\n            if start==end:\\n                return (start, left_sum)\\n            i = start\\n            j = end -1\\n            cur_sum = 0\\n            while i<j:\\n                if arr[i+1] < arr[i]:\\n                    cur_sum += arr[i+1]\\n                    tmp = arr[i+1]\\n                    arr[i+1] = arr[i]\\n                    arr[i] = tmp\\n                    i += 1\\n                else:\\n                    tmp = arr[i+1]\\n                    arr[i+1] = arr[j]\\n                    arr[j] = tmp\\n                    j -= 1\\n            if target > left_sum + cur_sum + (len(arr) - i ) * arr[i]:\\n                return quickSelect(i+1, end, left_sum + cur_sum + arr[i])\\n            else:\\n                return quickSelect(start, i, left_sum)\\n        k, left_sum = quickSelect(0, len(arr), 0)\\n        if k == len(arr):\\n            return arr[k-1]\\n        lower = (target - left_sum) // (n - k) \\n        if abs(target - left_sum - (n-k) * lower) <= abs(target- left_sum - (n-k)* (lower+1)):\\n            return lower\\n        else:\\n            return lower+1\\n                    \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338117,
                "title": "c-heap-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef pair<int,int>pi;\\n    int check(int mid ,vector<int>&a)\\n    {\\n        int nq = a.size();\\n        int sum = 0 ;\\n        for(int i = 0 ; i < nq; i++)\\n        {\\n            if(a[i] >= mid)\\n                sum += mid;\\n            else\\n                sum += a[i];\\n        }\\n        return sum;\\n    }\\n\\n    int findBestValue(vector<int>& a, int t) {\\n        int n = a.size();\\n         int max = INT_MIN; \\n        for (int i : a){\\n            if (max <= i)\\n                max = i;\\n        }\\n        priority_queue<pi , vector<pi> , greater<pi>>p;\\n      //      vector<pair<int,int>>p;\\n        int l = 0 ; \\n        int h = max;\\n        int ans,id, tillclose = 1e9;\\n        while(l <= h)\\n        {\\n            int mid = l + (h-l)/2 ;\\n          //  cout<<mid<<\" \";\\n            int sum = check(mid , a ) ;\\n            ans = abs(t - sum);\\n            p.push({ans , mid});\\n            if(sum > t)\\n                h = mid - 1 ;\\n            else\\n                l = mid + 1 ;\\n        }\\n        return p.top().second ;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    typedef pair<int,int>pi;\\n    int check(int mid ,vector<int>&a)\\n    {\\n        int nq = a.size();\\n        int sum = 0 ;\\n        for(int i = 0 ; i < nq; i++)\\n        {\\n            if(a[i] >= mid)\\n                sum += mid;\\n            else\\n                sum += a[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1319982,
                "title": "simple-and-easy-intuitive-c-solution-using-binary-search-monotonic-approach",
                "content": "```\\n bool check(vector<int> &arr,int target,int assumevalue){\\n        \\n        int sum=0;\\n        \\n        for(auto x: arr){\\n            \\n            if(x>assumevalue){\\n                sum+=assumevalue;\\n            }\\n            else{\\n                sum+=x;\\n            }\\n        }\\n       \\n        return sum>target;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        //FFFFFFFFFTTTTTT = > here mid =>integer assume value for which we will check for uor conditions,let\\'s do\\n        sort(arr.begin(),arr.end());\\n        \\n        int l=1,r=arr[arr.size() - 1];\\n        \\n        while(r>l){\\n            int mid= l + (r - l)/2;\\n            \\n            if(check(arr,target,mid)){\\n                r=mid;\\n            }\\n            else{\\n                l =  mid + 1;\\n            }\\n        }\\n         \\n          int sum1=0;\\n        \\n        for(auto x: arr){\\n            \\n            if(x>l-1){\\n                sum1+=l - 1;\\n            }\\n            else{ \\n                sum1+=x;\\n            }\\n        }\\n        \\n        int sum2=0;\\n        \\n        \\n        for(auto x: arr){\\n            if(x>l){\\n                sum2+=l;\\n            }\\n            else{\\n                sum2+=x;\\n            }\\n        }\\n        \\n        sum1=abs(target -sum1);\\n        sum2=abs(target- sum2);\\n        \\n        \\n        return sum1>sum2 ? l : l  - 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool check(vector<int> &arr,int target,int assumevalue){\\n        \\n        int sum=0;\\n        \\n        for(auto x: arr){\\n            \\n            if(x>assumevalue){\\n                sum+=assumevalue;\\n            }\\n            else{\\n                sum+=x;\\n            }\\n        }\\n       \\n        return sum>target;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        //FFFFFFFFFTTTTTT = > here mid =>integer assume value for which we will check for uor conditions,let\\'s do\\n        sort(arr.begin(),arr.end());\\n        \\n        int l=1,r=arr[arr.size() - 1];\\n        \\n        while(r>l){\\n            int mid= l + (r - l)/2;\\n            \\n            if(check(arr,target,mid)){\\n                r=mid;\\n            }\\n            else{\\n                l =  mid + 1;\\n            }\\n        }\\n         \\n          int sum1=0;\\n        \\n        for(auto x: arr){\\n            \\n            if(x>l-1){\\n                sum1+=l - 1;\\n            }\\n            else{ \\n                sum1+=x;\\n            }\\n        }\\n        \\n        int sum2=0;\\n        \\n        \\n        for(auto x: arr){\\n            if(x>l){\\n                sum2+=l;\\n            }\\n            else{\\n                sum2+=x;\\n            }\\n        }\\n        \\n        sum1=abs(target -sum1);\\n        sum2=abs(target- sum2);\\n        \\n        \\n        return sum1>sum2 ? l : l  - 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1270070,
                "title": "c-o-nlogn-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        // Sum of arr[i] == target\\n        float n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        // 0.0000001 is subsracted to make round(4.5) = 4, bcz we need the smaller int\\n        int avg = round(target/n-0.00000001);\\n        int i=0;\\n        while (i<arr.size() && arr[i]<=avg){\\n            target -= arr[i];\\n            n -= 1;\\n            if (n==0)\\n                return arr[arr.size()-1];\\n            avg = round(target/n-0.00000001);\\n            i++;\\n        }\\n        return avg;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        // Sum of arr[i] == target\\n        float n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        // 0.0000001 is subsracted to make round(4.5) = 4, bcz we need the smaller int\\n        int avg = round(target/n-0.00000001);\\n        int i=0;\\n        while (i<arr.size() && arr[i]<=avg){\\n            target -= arr[i];\\n            n -= 1;\\n            if (n==0)\\n                return arr[arr.size()-1];\\n            avg = round(target/n-0.00000001);\\n            i++;\\n        }\\n        return avg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137723,
                "title": "simple-binary-search-on-answer-solution-using-sum-of-array-floor-and-ceil-technique",
                "content": "```\\n int findBestValue(vector<int>& arr, int target) {\\n        int low=1,high=0,mid,ans1,ans2,n=arr.size(),sum1,sum2,high2;\\n        for(int i=0;i<n;i++) {\\n            high=max(high,arr[i]);\\n        }\\n        high2=high;\\n        while(low<=high) {\\n            mid=low+(high-low)/2;\\n            int sum=0;\\n            for(auto x:arr) {\\n                if(x>mid) sum+=mid;\\n                else sum+=x;\\n            }\\n            if(sum>=target) {\\n                ans1=mid;\\n                sum1=sum;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        low=1;\\n        high=high2;\\n        while(low<=high) {\\n            mid=low+(high-low)/2;\\n            int sum=0;\\n            for(auto x:arr) {\\n                if(x>mid) sum+=mid;\\n                else sum+=x;\\n            }\\n            if(sum<=target) {\\n                ans2=mid;\\n                sum2=sum;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        if(abs(target-sum1)==abs(target-sum2)) return ans2;\\n        return (abs(target-sum1)>abs(target-sum2))?(ans2):(ans1);\\n    }\\n\\t```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n int findBestValue(vector<int>& arr, int target) {\\n        int low=1,high=0,mid,ans1,ans2,n=arr.size(),sum1,sum2,high2;\\n        for(int i=0;i<n;i++) {\\n            high=max(high,arr[i]);\\n        }\\n        high2=high;\\n        while(low<=high) {\\n            mid=low+(high-low)/2;\\n            int sum=0;\\n            for(auto x:arr) {\\n                if(x>mid) sum+=mid;\\n                else sum+=x;\\n            }\\n            if(sum>=target) {\\n                ans1=mid;\\n                sum1=sum;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        low=1;\\n        high=high2;\\n        while(low<=high) {\\n            mid=low+(high-low)/2;\\n            int sum=0;\\n            for(auto x:arr) {\\n                if(x>mid) sum+=mid;\\n                else sum+=x;\\n            }\\n            if(sum<=target) {\\n                ans2=mid;\\n                sum2=sum;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        if(abs(target-sum1)==abs(target-sum2)) return ans2;\\n        return (abs(target-sum1)>abs(target-sum2))?(ans2):(ans1);\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1106426,
                "title": "python3-binary-search",
                "content": "Straightforward but a little bit slow.\\n\\n```python\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        def calculate(k):\\n            return sum([min(k, a) for a in arr])\\n        \\n        left, right = 0, max(arr)+1\\n        while left < right:\\n            mid = (left + right)//2\\n            if calculate(mid) <= target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n\\n        can1, can2 = calculate(right-1), calculate(right)\\n        if abs(can1-target) <= abs(can2-target):\\n            return right-1\\n        else:\\n            return right\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        def calculate(k):\\n            return sum([min(k, a) for a in arr])\\n        \\n        left, right = 0, max(arr)+1\\n        while left < right:\\n            mid = (left + right)//2\\n            if calculate(mid) <= target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n\\n        can1, can2 = calculate(right-1), calculate(right)\\n        if abs(can1-target) <= abs(can2-target):\\n            return right-1\\n        else:\\n            return right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030626,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int possible(int m, vector<int>& arr, int target)\\n    {\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n            sum+=min(m,arr[i]);\\n        return abs(sum-target);\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n            sum+=arr[i];\\n        if(sum<=target)\\n            return *max_element(arr.begin(),arr.end());\\n        int l=0,r=*max_element(arr.begin(),arr.end())+1;\\n        while(l<r)\\n        {\\n            int m=(l+r)/2;\\n            if(possible(m,arr,target)>possible(m+1,arr,target))\\n                l=m+1;\\n            else\\n                r=m;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int possible(int m, vector<int>& arr, int target)\\n    {\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n            sum+=min(m,arr[i]);\\n        return abs(sum-target);\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n            sum+=arr[i];\\n        if(sum<=target)\\n            return *max_element(arr.begin(),arr.end());\\n        int l=0,r=*max_element(arr.begin(),arr.end())+1;\\n        while(l<r)\\n        {\\n            int m=(l+r)/2;\\n            if(possible(m,arr,target)>possible(m+1,arr,target))\\n                l=m+1;\\n            else\\n                r=m;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014527,
                "title": "very-easy-commented-solution-without-using-binary-search-faster-than-100-percent",
                "content": "class Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int i;\\n        int n=arr.size();\\n        int length=n;\\n        int sum=0;\\n        for(i=0;i<n;i++)// taking sum of array\\n        {\\n            sum+=arr[i];\\n        }\\n        if(sum==target)\\n        {\\n            return arr[n-1];\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            double k=(target x 0.1)/(length x 0.1);// rounding of decimal to integer\\n            double diff= ceil(k)-k;\\n            if(diff>=0.5)\\n            {\\n                k= floor(k);\\n            }\\n            else\\n            {\\n                k=ceil(k);\\n            }\\n            \\n            if(arr[i]>=k)//  if k is greater than the current element means we have have reached the ideal case.\\n            {\\n                return k;\\n            }\\n            else\\n            {\\n                target-=arr[i];\\n                length--;\\n            }\\n        }\\n        return arr[n-1];\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int i;\\n        int n=arr.size();\\n        int length=n;\\n        int sum=0;\\n        for(i=0;i<n;i++)// taking sum of array\\n        {\\n            sum+=arr[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 995111,
                "title": "simple-binary-search-with-explanation-2ms-beats-98",
                "content": "Idea: Min Value : 1\\n\\t\\t Max Value: Maximum value in the array\\nApply Binary Search between min Value and max value to find the number in range which satisfies the condition.\\nLet it be stored in lo. Let the diff between sum and target be x. \\nNow also check for lo+1 and the difference be y\\nif(x <= y) return lo ;\\nelse return lo+1;\\n\\n\\n\\n```\\npublic static  int findBestValue(int[] arr, int target) {\\n\\t\\tint lo = 1 ; \\n\\t\\tint hi = Integer.MIN_VALUE ;\\n\\t\\t\\n\\t\\tfor(int num : arr) {\\n\\t\\t\\thi = Math.max(hi, num);\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\twhile(lo <= hi) {\\n\\t\\t\\tint mid = lo + ((hi - lo)/2);\\n\\t\\t\\tif(isPossible(arr, mid, target) <= target) { \\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\thi = mid-1 ; \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tint val1 = isPossible(arr, lo-1, target);\\n\\t\\tint val2 = isPossible(arr, lo, target);\\n\\t\\t\\n\\t\\tif(Math.abs(target-val1) > Math.abs(target-val2)) return lo;\\n\\t\\telse return lo+1 ; \\n\\t\\t\\n\\t\\t\\n\\n\\t}\\n\\t\\n\\tpublic static int isPossible(int[] arr, int val, int target) {\\n\\t\\t\\n\\t\\tint sum = 0; \\n\\t\\tfor(int num : arr) {\\n\\t\\t\\tsum += Math.min(num, val);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn sum ;\\n\\t\\t\\n\\t}\\n```\\nIf you like the solution do upvote it!",
                "solutionTags": [],
                "code": "```\\npublic static  int findBestValue(int[] arr, int target) {\\n\\t\\tint lo = 1 ; \\n\\t\\tint hi = Integer.MIN_VALUE ;\\n\\t\\t\\n\\t\\tfor(int num : arr) {\\n\\t\\t\\thi = Math.max(hi, num);\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\twhile(lo <= hi) {\\n\\t\\t\\tint mid = lo + ((hi - lo)/2);\\n\\t\\t\\tif(isPossible(arr, mid, target) <= target) { \\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\thi = mid-1 ; \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tint val1 = isPossible(arr, lo-1, target);\\n\\t\\tint val2 = isPossible(arr, lo, target);\\n\\t\\t\\n\\t\\tif(Math.abs(target-val1) > Math.abs(target-val2)) return lo;\\n\\t\\telse return lo+1 ; \\n\\t\\t\\n\\t\\t\\n\\n\\t}\\n\\t\\n\\tpublic static int isPossible(int[] arr, int val, int target) {\\n\\t\\t\\n\\t\\tint sum = 0; \\n\\t\\tfor(int num : arr) {\\n\\t\\t\\tsum += Math.min(num, val);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn sum ;\\n\\t\\t\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 891720,
                "title": "c-easy-to-understand-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int sum=accumulate(arr.begin(),arr.end(),0);\\n        if(sum<=target)\\n        {\\n            return *max_element(arr.begin(),arr.end());\\n            \\n        }\\n        int diff=sum-target;\\n        int ans=*max_element(arr.begin(),arr.end());\\n        int low=0;\\n        int high=ans-1;\\n        int n=arr.size();\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int sum1=0;\\n            int i;\\n            for(i=0;i<n;i++)\\n            {\\n                sum1+=min(arr[i],mid);\\n            }\\n            int diff1=abs(sum1-target);\\n            if(diff1<diff)\\n            {\\n                ans=mid;\\n                diff=diff1;\\n            }\\n            else if(diff1==diff)\\n            {\\n                ans=min(ans,mid);\\n            }\\n            if(sum1<=target)\\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int sum=accumulate(arr.begin(),arr.end(),0);\\n        if(sum<=target)\\n        {\\n            return *max_element(arr.begin(),arr.end());\\n            \\n        }\\n        int diff=sum-target;\\n        int ans=*max_element(arr.begin(),arr.end());\\n        int low=0;\\n        int high=ans-1;\\n        int n=arr.size();\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int sum1=0;\\n            int i;\\n            for(i=0;i<n;i++)\\n            {\\n                sum1+=min(arr[i],mid);\\n            }\\n            int diff1=abs(sum1-target);\\n            if(diff1<diff)\\n            {\\n                ans=mid;\\n                diff=diff1;\\n            }\\n            else if(diff1==diff)\\n            {\\n                ans=min(ans,mid);\\n            }\\n            if(sum1<=target)\\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694415,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int L = 0 , R = 0 , mid = 0 , ans = INT_MAX ;\\n        for(auto i : arr ) R = max( R , i ) ;\\n        int disp = INT_MAX ;\\n        while( L <= R )\\n        {\\n            mid = ( L + R ) / 2 ;\\n            int K = solve( mid , arr , target ) ;\\n            if( abs(target-K) < ans )\\n            {\\n                ans = abs(target-K) ;\\n                disp = mid ;\\n            }\\n            else if( abs(target-K) == ans ) disp = min(disp , mid ) ;\\n            (K>=target)?R=mid-1:L=mid+1;\\n        }\\n        return disp ;\\n    }\\n    int solve( int an , vector<int>&arr,  int target )\\n    {\\n        int all_ = 0 ;\\n        for( auto i : arr )\\n        {\\n            (i>=an)?all_+=an:all_+=i;\\n        }\\n        return all_ ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int L = 0 , R = 0 , mid = 0 , ans = INT_MAX ;\\n        for(auto i : arr ) R = max( R , i ) ;\\n        int disp = INT_MAX ;\\n        while( L <= R )\\n        {\\n            mid = ( L + R ) / 2 ;\\n            int K = solve( mid , arr , target ) ;\\n            if( abs(target-K) < ans )\\n            {\\n                ans = abs(target-K) ;\\n                disp = mid ;\\n            }\\n            else if( abs(target-K) == ans ) disp = min(disp , mid ) ;\\n            (K>=target)?R=mid-1:L=mid+1;\\n        }\\n        return disp ;\\n    }\\n    int solve( int an , vector<int>&arr,  int target )\\n    {\\n        int all_ = 0 ;\\n        for( auto i : arr )\\n        {\\n            (i>=an)?all_+=an:all_+=i;\\n        }\\n        return all_ ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691487,
                "title": "java-sort-1-loop-from-highest-to-lowest",
                "content": "1, sort  the array\\n2, loop from highest value, then gradually decrease, update the mult with the number of elements decreasing.\\n```\\n    public int findBestValue(int[] arr, int target) {\\n        if (arr == null || arr.length == 0) return 0;\\n        Arrays.sort(arr);\\n        int sum = 0, n = arr.length;\\n        for (int i : arr) sum += i;\\n        if (target >= sum) return arr[n - 1];\\n        int diff = sum - target, mult = 1, prev = arr[n - 1];\\n        for (int i = n - 2; i >= 0; i--, mult++) {\\n            System.out.println(diff + \",\" + i + \",\" + prev);\\n            diff -= (prev - arr[i]) * mult;\\n            if (diff <= 0) return arr[i] + (-diff) / mult + ((-diff) % mult <= (mult - (-diff) % mult) ? 0 : 1);\\n            prev = arr[i];\\n        }\\n        diff -= prev * mult;\\n        return (-diff) / mult + ((-diff) % mult <= (mult - (-diff) % mult)  ? 0 : 1);\\n                                           \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findBestValue(int[] arr, int target) {\\n        if (arr == null || arr.length == 0) return 0;\\n        Arrays.sort(arr);\\n        int sum = 0, n = arr.length;\\n        for (int i : arr) sum += i;\\n        if (target >= sum) return arr[n - 1];\\n        int diff = sum - target, mult = 1, prev = arr[n - 1];\\n        for (int i = n - 2; i >= 0; i--, mult++) {\\n            System.out.println(diff + \",\" + i + \",\" + prev);\\n            diff -= (prev - arr[i]) * mult;\\n            if (diff <= 0) return arr[i] + (-diff) / mult + ((-diff) % mult <= (mult - (-diff) % mult) ? 0 : 1);\\n            prev = arr[i];\\n        }\\n        diff -= prev * mult;\\n        return (-diff) / mult + ((-diff) % mult <= (mult - (-diff) % mult)  ? 0 : 1);\\n                                           \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 644439,
                "title": "java-binary-search-solution-explanation",
                "content": "Let\\'s assume that there\\'s exact target sum exists with value. (not close one)\\nBecause it makes problem more simpler because we only need to find value that sum is equals to target. \\nThen, it is just a simple binary search problem to find value from 1 to maximum value in array.\\n\\nThe problem is to the most CLOSEST value, so answer is one of two: \\n1. smaller or same one\\n2. bigger one\\n\\nSo we have to choose close one between above.\\ne.g.   \\n98, 100, 101, target  = 100, low-1 = 98, low = 101\\n101(low) is answer.\\n99, 100, 102, target = 100, low-1 = 99, low = 102\\n99(low-1) is answer.\\n100, 100, 101 target = 100, low-1 = 100, low = 101\\n100(low-1) is answer.\\n\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int low = 1, high = max(arr)+1;\\n        while (low < high) {\\n            int mid = low + (high-low)/2;\\n            int sum = sumArray(arr, mid);\\n            if (sum <= target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        if (target - sumArray(arr, low-1) > (sumArray(arr, low) - target)) {\\n            return low;\\n        }\\n        return low-1;\\n    }\\n    \\n    public int sumArray(int[] arr, int k) {\\n        int sum = 0;\\n        for (int num : arr) {\\n            if (num > k) sum += k;\\n            else sum += num;\\n        }\\n        return sum;\\n    }\\n    \\n    public int max(int[] arr) {\\n        int high = 1;\\n        for (int num : arr) {\\n            if (num > high) high = num;\\n        }\\n        return high;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int low = 1, high = max(arr)+1;\\n        while (low < high) {\\n            int mid = low + (high-low)/2;\\n            int sum = sumArray(arr, mid);\\n            if (sum <= target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        if (target - sumArray(arr, low-1) > (sumArray(arr, low) - target)) {\\n            return low;\\n        }\\n        return low-1;\\n    }\\n    \\n    public int sumArray(int[] arr, int k) {\\n        int sum = 0;\\n        for (int num : arr) {\\n            if (num > k) sum += k;\\n            else sum += num;\\n        }\\n        return sum;\\n    }\\n    \\n    public int max(int[] arr) {\\n        int high = 1;\\n        for (int num : arr) {\\n            if (num > high) high = num;\\n        }\\n        return high;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522016,
                "title": "straightforward-java-solution-binary-search",
                "content": "Time: O(nlogk), where `n` is length of `arr`, `k` is the max value of `arr`\\nSpace: O(1)\\n\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int high = 0;\\n        for (int i : arr) {\\n            high = Math.max(high, i);\\n        }\\n        int low = 0;\\n        while (low + 1 < high) {\\n            int mid = low + (high - low) / 2;\\n            if (getSum(arr, mid) > target) {\\n                high = mid;\\n            } else {\\n                low = mid;\\n            }\\n        }\\n        if (Math.abs(getSum(arr, high) - target) < Math.abs(getSum(arr, low) - target)) {\\n            return high;\\n        }\\n        return low;\\n    }\\n    \\n    public int getSum(int[] arr, int max) {\\n        int sum = 0;\\n        for (int i : arr) {\\n            sum += i > max ? max : i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int high = 0;\\n        for (int i : arr) {\\n            high = Math.max(high, i);\\n        }\\n        int low = 0;\\n        while (low + 1 < high) {\\n            int mid = low + (high - low) / 2;\\n            if (getSum(arr, mid) > target) {\\n                high = mid;\\n            } else {\\n                low = mid;\\n            }\\n        }\\n        if (Math.abs(getSum(arr, high) - target) < Math.abs(getSum(arr, low) - target)) {\\n            return high;\\n        }\\n        return low;\\n    }\\n    \\n    public int getSum(int[] arr, int max) {\\n        int sum = 0;\\n        for (int i : arr) {\\n            sum += i > max ? max : i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518151,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int l = 0, r = target;\\n        \\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (helper(arr, mid, target) <= helper(arr, mid + 1, target))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        \\n        return l;\\n    }\\n    \\n    private int helper(int[] arr, int t, int target) {\\n        int sum = 0;\\n        for (int a : arr) sum += a < t ? a : t;\\n        return Math.abs(sum - target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int l = 0, r = target;\\n        \\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (helper(arr, mid, target) <= helper(arr, mid + 1, target))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        \\n        return l;\\n    }\\n    \\n    private int helper(int[] arr, int t, int target) {\\n        int sum = 0;\\n        for (int a : arr) sum += a < t ? a : t;\\n        return Math.abs(sum - target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463665,
                "title": "c-100-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        vector<pair<int, int>> possibleResults;\\n        for (int i = target/arr.size(); i <= *max_element(arr.begin(), arr.end()); i++)\\n        {\\n            int sum = std::accumulate(arr.begin(), arr.end(), 0, [&i](int currentSum, int n)\\n               {\\n                   return n > i ? currentSum + i : currentSum + n;\\n               });\\n            \\n            if (sum == target) return i;\\n            possibleResults.emplace_back(i, sum);\\n            if (sum > target) break;\\n        }        \\n        \\n        auto closestPair = min_element(possibleResults.begin(), possibleResults.end(),\\n        [&target](const pair<int,int>& p1, const pair<int,int>& p2){\\n            return (abs(target - p1.second)) < (abs(target - p2.second));\\n        });\\n        \\n        return closestPair->first;\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        vector<pair<int, int>> possibleResults;\\n        for (int i = target/arr.size(); i <= *max_element(arr.begin(), arr.end()); i++)\\n        {\\n            int sum = std::accumulate(arr.begin(), arr.end(), 0, [&i](int currentSum, int n)\\n               {\\n                   return n > i ? currentSum + i : currentSum + n;\\n               });\\n            \\n            if (sum == target) return i;\\n            possibleResults.emplace_back(i, sum);\\n            if (sum > target) break;\\n        }        \\n        \\n        auto closestPair = min_element(possibleResults.begin(), possibleResults.end(),\\n        [&target](const pair<int,int>& p1, const pair<int,int>& p2){\\n            return (abs(target - p1.second)) < (abs(target - p2.second));\\n        });\\n        \\n        return closestPair->first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463470,
                "title": "python-3-four-lines-math-solution-28-ms-beats-100-o-n-log-n-o-1-space",
                "content": "```\\nclass Solution:\\n    def findBestValue(self, A: List[int], t: int) -> int:\\n        L, A, y = len(A), [0]+sorted(A), 0\\n        for i in range(L):\\n            y += (A[i+1]-A[i])*(L-i)\\n            if y >= t: return round(A[i+1] + (t-y)/(L-i) - 0.01)\\n\\t\\t\\t\\n\\t\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, A: List[int], t: int) -> int:\\n        L, A, y = len(A), [0]+sorted(A), 0\\n        for i in range(L):\\n            y += (A[i+1]-A[i])*(L-i)\\n            if y >= t: return round(A[i+1] + (t-y)/(L-i) - 0.01)\\n\\t\\t\\t\\n\\t\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 463272,
                "title": "binary-search-python",
                "content": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        num, mindiff = 0, float(\\'Inf\\')\\n        left, right = 0, max(arr)\\n        while left <= right:\\n            middle = left+(right-left)//2\\n            su = 0\\n            for i in arr:\\n                if i > middle:su += middle\\n                else:su += i\\n            if abs(target-su) < mindiff:\\n                num = middle\\n                mindiff = abs(target-su)\\n            elif abs(target-su) == mindiff:\\n                if num > middle:\\n                    num = middle\\n            if su > target:\\n                right = middle-1\\n            else:\\n                left = middle+1\\n        return num\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        num, mindiff = 0, float(\\'Inf\\')\\n        left, right = 0, max(arr)\\n        while left <= right:\\n            middle = left+(right-left)//2\\n            su = 0\\n            for i in arr:\\n                if i > middle:su += middle\\n                else:su += i\\n            if abs(target-su) < mindiff:\\n                num = middle\\n                mindiff = abs(target-su)\\n            elif abs(target-su) == mindiff:\\n                if num > middle:\\n                    num = middle\\n            if su > target:\\n                right = middle-1\\n            else:\\n                left = middle+1\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463269,
                "title": "java-1ms-o-n-no-binary-search",
                "content": "we won\\'t change values less than average anyways, we can remove them from total sum. answer should be nearest int of rest / restCount\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        if (arr == null || arr.length == 0) return 0;\\n        int average = target / arr.length;\\n        int sum = 0, count = 0;\\n        for (int num: arr) {\\n            if (num <= average) {\\n                sum += num;\\n                count += 1;\\n            }\\n        }\\n        if (target - sum == 0) return average;\\n        double val = (double)(target - sum) / (arr.length - count); \\n        double large = Math.ceil(val);\\n        double small = Math.floor(val);\\n        if (Math.abs(small - val) == Math.abs(large - val)) return (int)small;\\n        \\n        return (int)Math.round(val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        if (arr == null || arr.length == 0) return 0;\\n        int average = target / arr.length;\\n        int sum = 0, count = 0;\\n        for (int num: arr) {\\n            if (num <= average) {\\n                sum += num;\\n                count += 1;\\n            }\\n        }\\n        if (target - sum == 0) return average;\\n        double val = (double)(target - sum) / (arr.length - count); \\n        double large = Math.ceil(val);\\n        double small = Math.floor(val);\\n        if (Math.abs(small - val) == Math.abs(large - val)) return (int)small;\\n        \\n        return (int)Math.round(val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463259,
                "title": "python-very-intuitive-o-nlogn-sorting-keep-optimal-value",
                "content": "Keep track of an optimal value that we would like, keep updating optimal value as we go through the array and return when we can sub in the optimal value.\\n```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        n = len(arr)\\n        optimal = round(target/n)\\n        \\n        for i,a in enumerate(arr):\\n            if a >= optimal:\\n                return optimal\\n            elif i != n-1:\\n                target -= a\\n                optimal = round(target/(n-i-1))\\n            else:\\n                break\\n            \\n        return arr[-1]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        n = len(arr)\\n        optimal = round(target/n)\\n        \\n        for i,a in enumerate(arr):\\n            if a >= optimal:\\n                return optimal\\n            elif i != n-1:\\n                target -= a\\n                optimal = round(target/(n-i-1))\\n            else:\\n                break\\n            \\n        return arr[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463234,
                "title": "java-7ms-sorting-and-bruteforce-naive-solution-less-than-30-lines-easy-to-follow",
                "content": "Let me know if you think this can be improved.\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int ans = 0;\\n        int lowestDiff = Integer.MAX_VALUE;    \\n        int sumTillNow = 0;\\n        int index = 0;\\n\\t\\t\\n        Arrays.sort(arr);\\n        for(int i : arr){\\n            int tans = (target-sumTillNow) / (arr.length - index);\\n            int tpans = tans + 1;\\n            \\n            if(((index > 0 && tans >= (arr[index - 1]) && tans <= i) || (index == 0 && tans <= i)) && \\n\\t\\t\\t\\tMath.abs(tans*(arr.length-index) - (target-sumTillNow)) < lowestDiff){\\n\\t\\t\\t\\t\\tlowestDiff = Math.abs(tans*(arr.length-index) - (target-sumTillNow));\\n\\t\\t\\t\\t\\tans = tans;\\n            }\\n\\n\\t\\t\\tif(((index > 0 && tpans >= (arr[index - 1]) && tpans <= i || (index == 0 && tans <= i)) && \\n\\t\\t\\t\\tMath.abs(tpans*(arr.length-index) - (target-sumTillNow)) < lowestDiff)){\\n\\t\\t\\t\\t\\tlowestDiff = Math.abs(tpans*(arr.length-index) - (target-sumTillNow));\\n\\t\\t\\t\\t\\tans = tpans;\\n            }\\n            \\n            sumTillNow += i;\\n            index++;\\n            if( Math.abs((sumTillNow + (i*(arr.length - index))) - target) < lowestDiff){\\n                lowestDiff = Math.abs((sumTillNow + (i*(arr.length - index))) - target);\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int ans = 0;\\n        int lowestDiff = Integer.MAX_VALUE;    \\n        int sumTillNow = 0;\\n        int index = 0;\\n\\t\\t\\n        Arrays.sort(arr);\\n        for(int i : arr){\\n            int tans = (target-sumTillNow) / (arr.length - index);\\n            int tpans = tans + 1;\\n            \\n            if(((index > 0 && tans >= (arr[index - 1]) && tans <= i) || (index == 0 && tans <= i)) && \\n\\t\\t\\t\\tMath.abs(tans*(arr.length-index) - (target-sumTillNow)) < lowestDiff){\\n\\t\\t\\t\\t\\tlowestDiff = Math.abs(tans*(arr.length-index) - (target-sumTillNow));\\n\\t\\t\\t\\t\\tans = tans;\\n            }\\n\\n\\t\\t\\tif(((index > 0 && tpans >= (arr[index - 1]) && tpans <= i || (index == 0 && tans <= i)) && \\n\\t\\t\\t\\tMath.abs(tpans*(arr.length-index) - (target-sumTillNow)) < lowestDiff)){\\n\\t\\t\\t\\t\\tlowestDiff = Math.abs(tpans*(arr.length-index) - (target-sumTillNow));\\n\\t\\t\\t\\t\\tans = tpans;\\n            }\\n            \\n            sumTillNow += i;\\n            index++;\\n            if( Math.abs((sumTillNow + (i*(arr.length - index))) - target) < lowestDiff){\\n                lowestDiff = Math.abs((sumTillNow + (i*(arr.length - index))) - target);\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463212,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& A, int target) {\\n        sort(A.begin(), A.end());\\n        vector<int> sum;\\n        int n = A.size();\\n        sum.push_back(A[0]);\\n        for(int i = 1; i < A.size(); i++) {\\n            sum.push_back(sum.back() + A[i]);\\n        }\\n        int ans = 0, diff = target;\\n        for(int i = 1; i <= target; i++) {\\n            auto pos = upper_bound(A.begin(), A.end(), i);\\n            int p, tot;\\n            if(pos != A.begin()) {\\n                pos--;\\n                p = pos - A.begin();\\n                tot = sum[p] + i * (n - 1 - p);\\n            }\\n            else {\\n                tot = i * n;\\n            }\\n            if(abs(tot - target) < diff) {\\n                ans = i;\\n                diff = abs(tot - target);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& A, int target) {\\n        sort(A.begin(), A.end());\\n        vector<int> sum;\\n        int n = A.size();\\n        sum.push_back(A[0]);\\n        for(int i = 1; i < A.size(); i++) {\\n            sum.push_back(sum.back() + A[i]);\\n        }\\n        int ans = 0, diff = target;\\n        for(int i = 1; i <= target; i++) {\\n            auto pos = upper_bound(A.begin(), A.end(), i);\\n            int p, tot;\\n            if(pos != A.begin()) {\\n                pos--;\\n                p = pos - A.begin();\\n                tot = sum[p] + i * (n - 1 - p);\\n            }\\n            else {\\n                tot = i * n;\\n            }\\n            if(abs(tot - target) < diff) {\\n                ans = i;\\n                diff = abs(tot - target);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463203,
                "title": "python-binary-search-with-hashmap-dictionary",
                "content": "```py\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        def getSum(val):\\n            total = 0\\n            for i in range(n):\\n                total += arr[i] if arr[i] <= val else val\\n            return total\\n\\n        lo, hi, n = 0, max(arr), len(arr)\\n        diff = collections.defaultdict(set)\\n        while lo <= hi:\\n            mid = (lo+hi) // 2\\n            total = getSum(mid)\\n            # store the absolute differences\\n            diff[abs(total - target)].add(mid)\\n            if total < target:\\n                lo = mid+1\\n            elif total > target:\\n                hi = mid-1\\n            else:\\n                break\\n        \\n        # Find the lowest diff\\n        cand = diff[sorted(diff.keys())[0]]\\n        # Return the minimum value among candidates\\n        return sorted(cand)[0]        \\n```\\t\\t",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        def getSum(val):\\n            total = 0\\n            for i in range(n):\\n                total += arr[i] if arr[i] <= val else val\\n            return total\\n\\n        lo, hi, n = 0, max(arr), len(arr)\\n        diff = collections.defaultdict(set)\\n        while lo <= hi:\\n            mid = (lo+hi) // 2\\n            total = getSum(mid)\\n            # store the absolute differences\\n            diff[abs(total - target)].add(mid)\\n            if total < target:\\n                lo = mid+1\\n            elif total > target:\\n                hi = mid-1\\n            else:\\n                break\\n        \\n        # Find the lowest diff\\n        cand = diff[sorted(diff.keys())[0]]\\n        # Return the minimum value among candidates\\n        return sorted(cand)[0]        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 463187,
                "title": "c-binary-search-approximation-solution-description-updated",
                "content": "Our goal is to find a threshold T which can be used to modify the array so that the numbers in the array greater than T are set to T. Also, the sum of the result array should be close to the specified target.\\n\\nLet\\'s see the given example, [4,9,3]. We can choose 3 as the threshold to modify the array. As a result, the array is changed to [3,3,3], and the array sum 9 is close to 10.\\n\\nFor this, we can use a linear scan to find such threshold T. That is, we can try the candidates from 0 to 9. However, a more efficient approach is using binary approximation on the candidates to find the best T.\\n\\nAgain, let\\'s check the same example:\\nin the first iteration, lower bound L is set to 0, and the upper bound R is set to 9. Now we can get a middle point M, which is 4. Then we try to change the array to [4,4,3] whose sum is 11. \\n\\nSince 11 is greater than 10, we can decrease the upper bound R to 4 and launch another iteration to find T.\\n\\nThus, in the second iteration, lower bound L is 0, and the upper bound R is 4. Now we can get a new middle point M, which is 2. Then we change the array to [2, 2, 2] whose sum is 6.\\n\\nSince 6 is less than 10, we can increase the lower bound L to 2 and launch the third iteration to find T.\\n\\nIn the third iteration, lower bound L is 2, and the upper bound R is 4. Now we get the middle point 3, and change the array to [3,3,3].\\n\\nFinally, we narrow down to 2 candidates, 3 and 4. According to the problem description, 3 is a better one. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        int l = 0, r = arr[0];\\n        for (int num : arr) {\\n            r = std::max(r, num);\\n        }\\n        \\n        while (l + 1 < r) {\\n            int m = l + (r - l) / 2;\\n            int sum = getSum(arr, m);\\n            if (sum > target) {\\n                r = m;\\n            } else {\\n                l = m;\\n            }\\n        }\\n        \\n        int sum_l = getSum(arr, l);\\n        int sum_r = getSum(arr, r);\\n        \\n        if (abs(sum_l - target) <= abs(sum_r - target)) {\\n            return l;\\n        } else {\\n            return r;\\n        }\\n    }\\n    \\nprivate:\\n    int getSum(const auto& nums, int k) {\\n        \\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += (num < k) ? num : k;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        int l = 0, r = arr[0];\\n        for (int num : arr) {\\n            r = std::max(r, num);\\n        }\\n        \\n        while (l + 1 < r) {\\n            int m = l + (r - l) / 2;\\n            int sum = getSum(arr, m);\\n            if (sum > target) {\\n                r = m;\\n            } else {\\n                l = m;\\n            }\\n        }\\n        \\n        int sum_l = getSum(arr, l);\\n        int sum_r = getSum(arr, r);\\n        \\n        if (abs(sum_l - target) <= abs(sum_r - target)) {\\n            return l;\\n        } else {\\n            return r;\\n        }\\n    }\\n    \\nprivate:\\n    int getSum(const auto& nums, int k) {\\n        \\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += (num < k) ? num : k;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048920,
                "title": "easy-c-solution-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int find_diff(int mid,vector<int>& arr,int target){\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]>mid)\\n            sum+=mid;\\n            else\\n            sum+=arr[i];\\n        }\\n        return abs(target-sum);\\n    }\\n\\n    int findBestValue(vector<int>& arr, int target) {\\n        int start=0;\\n        int end=target;\\n\\n        //binary search\\n        while(start<end){\\n            int mid = start + (end - start)/2;\\n            int temp1 = find_diff(mid,arr,target);\\n            int temp2 = find_diff(mid+1,arr,target);\\n\\n            if(temp1<=temp2)\\n            end=mid;\\n\\n            else\\n            start=mid+1;\\n        }\\n\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_diff(int mid,vector<int>& arr,int target){\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]>mid)\\n            sum+=mid;\\n            else\\n            sum+=arr[i];\\n        }\\n        return abs(target-sum);\\n    }\\n\\n    int findBestValue(vector<int>& arr, int target) {\\n        int start=0;\\n        int end=target;\\n\\n        //binary search\\n        while(start<end){\\n            int mid = start + (end - start)/2;\\n            int temp1 = find_diff(mid,arr,target);\\n            int temp2 = find_diff(mid+1,arr,target);\\n\\n            if(temp1<=temp2)\\n            end=mid;\\n\\n            else\\n            start=mid+1;\\n        }\\n\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942707,
                "title": "java-binary-serach-solution",
                "content": "# Approach\\nThe element can be between 0 and the max element of the array. So we can apply binary search from 0 to max element of the array\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int getSum(int arr[], int num)\\n    {\\n        int sum = 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>num)\\n            sum+=num;\\n            else\\n            sum+=arr[i];\\n        }\\n        return sum;\\n    }\\n\\n    public int findBestValue(int[] arr, int target) {\\n        int start = 0, end = arr[0], max = arr[0];\\n        for(int i=0;i<arr.length;i++)\\n        max = Math.max(max,arr[i]);\\n\\n        end = max;\\n\\n        while(start<=end)\\n        {\\n            int mid = start + (end-start)/2;\\n            if(getSum(arr,mid) < target) start = mid+1;\\n            else end = mid-1;\\n        }\\n\\n        if(Math.abs(getSum(arr,start)-target) < Math.abs(target-getSum(arr,start-1)))\\n        return start;\\n        return start-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int getSum(int arr[], int num)\\n    {\\n        int sum = 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>num)\\n            sum+=num;\\n            else\\n            sum+=arr[i];\\n        }\\n        return sum;\\n    }\\n\\n    public int findBestValue(int[] arr, int target) {\\n        int start = 0, end = arr[0], max = arr[0];\\n        for(int i=0;i<arr.length;i++)\\n        max = Math.max(max,arr[i]);\\n\\n        end = max;\\n\\n        while(start<=end)\\n        {\\n            int mid = start + (end-start)/2;\\n            if(getSum(arr,mid) < target) start = mid+1;\\n            else end = mid-1;\\n        }\\n\\n        if(Math.abs(getSum(arr,start)-target) < Math.abs(target-getSum(arr,start-1)))\\n        return start;\\n        return start-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888019,
                "title": "golden-section-search",
                "content": "# Intuition\\nIt use golden-section search\\n\\n# Approach\\nThe critical is figuring out base rage for golden-section search\\n\\n# Complexity\\nGiven `N` as size of incoming array and `T` as min between `target` and max element in the array\\n- Time complexity for `calculateDeltaForCandidate`:\\n$$O(N)$$\\n- Time complexity for `findBestValue` **(final)**:\\n$$O(N*logN)$$ for initial sorting plus $$O(logT)*O(N)$$ for golden-section search\\n\\n- Space complexity:\\n$$O(N)$$ to keep sorted array\\n$$O(N)$$ to cover `sArr.slice(0, i)` in `calculateDeltaForCandidate`, can be optimazed\\n$$O(1)$$ for other variables\\n$$O(3*N)$$ **in general**\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\nvar findBestValue = function(arr, target) {\\n    const sortedArr = [...arr].sort(function (a, b) {  return a - b;  });\\n    var lowestValue = Math.min(sortedArr[arr.length-1], Math.floor(target/arr.length));\\n    var higestValue = Math.min(sortedArr[arr.length-1], target);\\n    var value, deltaLeft, deltaRight;\\n    \\n    while (true) {\\n        candidateRight = Math.ceil((lowestValue + higestValue)/2)\\n        candidateLeft = candidateRight - 1\\n        deltaLeft = calculateDeltaForCandidate(sortedArr, target, candidateLeft)\\n        if (deltaLeft == 0) {\\n            return candidateLeft\\n        }\\n        deltaRight = calculateDeltaForCandidate(sortedArr, target, candidateRight)\\n        if (deltaRight == 0) {\\n            return candidateRight\\n        }\\n        if (deltaRight == 0) {\\n            return candidateRight\\n        }\\n        if (candidateRight == higestValue) {\\n            return deltaLeft <= deltaRight ? candidateLeft : candidateRight;\\n        }\\n        if (deltaLeft <= deltaRight) {\\n            higestValue = candidateLeft\\n        } else {\\n            lowestValue = candidateRight\\n        }\\n    }\\n};\\n\\nvar calculateDeltaForCandidate = function(sArr, target, candidate) {\\n    var sum\\n    //find idx lover then candidate\\n    for (var i=0; i < sArr.length; i++) {\\n        if (sArr[i] >= candidate) {\\n            sum = sArr.slice(0, i).reduce((partialSum, a) => partialSum + a, 0) + (sArr.length - i) * candidate;\\n            return Math.abs(sum - target)\\n        };\\n    }\\n    return NaN\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\nvar findBestValue = function(arr, target) {\\n    const sortedArr = [...arr].sort(function (a, b) {  return a - b;  });\\n    var lowestValue = Math.min(sortedArr[arr.length-1], Math.floor(target/arr.length));\\n    var higestValue = Math.min(sortedArr[arr.length-1], target);\\n    var value, deltaLeft, deltaRight;\\n    \\n    while (true) {\\n        candidateRight = Math.ceil((lowestValue + higestValue)/2)\\n        candidateLeft = candidateRight - 1\\n        deltaLeft = calculateDeltaForCandidate(sortedArr, target, candidateLeft)\\n        if (deltaLeft == 0) {\\n            return candidateLeft\\n        }\\n        deltaRight = calculateDeltaForCandidate(sortedArr, target, candidateRight)\\n        if (deltaRight == 0) {\\n            return candidateRight\\n        }\\n        if (deltaRight == 0) {\\n            return candidateRight\\n        }\\n        if (candidateRight == higestValue) {\\n            return deltaLeft <= deltaRight ? candidateLeft : candidateRight;\\n        }\\n        if (deltaLeft <= deltaRight) {\\n            higestValue = candidateLeft\\n        } else {\\n            lowestValue = candidateRight\\n        }\\n    }\\n};\\n\\nvar calculateDeltaForCandidate = function(sArr, target, candidate) {\\n    var sum\\n    //find idx lover then candidate\\n    for (var i=0; i < sArr.length; i++) {\\n        if (sArr[i] >= candidate) {\\n            sum = sArr.slice(0, i).reduce((partialSum, a) => partialSum + a, 0) + (sArr.length - i) * candidate;\\n            return Math.abs(sum - target)\\n        };\\n    }\\n    return NaN\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855332,
                "title": "c-binary-search-short-and-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint diff(vector<int>& arr,int mid, int target){\\n    int sum=0;\\n    for(int a: arr){\\n        a>mid? sum+=mid: sum+=a;\\n    }\\n   return abs(target -sum);\\n}\\nint findBestValue(vector<int>& arr, int target) {\\n    int start=0;\\n    int end=target;\\n    int mid;\\n    while(start<end){\\n        mid=start+(end-start)/2;\\n        if(diff(arr,mid,target)<=diff(arr,mid+1,target)) end=mid;\\n        else start=mid+1;\\n}\\nreturn start;\\n }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint diff(vector<int>& arr,int mid, int target){\\n    int sum=0;\\n    for(int a: arr){\\n        a>mid? sum+=mid: sum+=a;\\n    }\\n   return abs(target -sum);\\n}\\nint findBestValue(vector<int>& arr, int target) {\\n    int start=0;\\n    int end=target;\\n    int mid;\\n    while(start<end){\\n        mid=start+(end-start)/2;\\n        if(diff(arr,mid,target)<=diff(arr,mid+1,target)) end=mid;\\n        else start=mid+1;\\n}\\nreturn start;\\n }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834325,
                "title": "easy-solution-using-binary-search-c",
                "content": "\\nExplaination:\\nIt initializes start to 0 and end to the maximum element in the input vector arr.\\nIt sets leftdiff and rightdiff to INT_MAX, which will be used to keep track of the minimum absolute differences found in the left and right halves of the binary search.\\nIt initializes variables lb and rb to store the best values found for the left and right halves, respectively.\\nThe function enters a binary search loop, where it calculates the mid point between start and end.\\nIt then calculates the sum using the result function with mid as the parameter.\\nDepending on whether the sum is less than or greater than the target value, it updates the leftdiff and rightdiff variables and the corresponding best value (lb or rb).\\nThe binary search is narrowed down based on the comparison between the sum and the target value.\\nAfter the binary search, it returns the best value (lb or rb) with the smaller absolute difference from the target value\\n\\n\\nCODE:\\n\"\"\"\\nint result(int start,vector<int>& arr)\\n    {\\n      int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            sum=sum+min(start,arr[i]);\\n\\n        \\n        }\\n        return sum;\\n    \\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n    int start = 0;\\n    int end = *max_element(arr.begin(), arr.end());\\n    int rightdiff = INT_MAX;\\n    int leftdiff=INT_MAX;\\n        int lb;\\n        int rb;\\n    \\n    while (start <= end) {\\n         // Use binary search to narrow down the range\\n        int mid=(start+end)/2;\\n        int sum = result(mid,arr);\\n        if(sum<target)\\n        {\\n            int left=abs(sum-target);\\n            if(min(leftdiff,left)==left)\\n            {\\n                leftdiff=left;\\n                lb=mid;\\n            }\\n           start=mid+1;\\n        \\n        }\\n        else\\n        {\\n            int right=abs(sum-target);\\n            if(min(rightdiff,right)==right)\\n            {\\n                         rightdiff=right;\\n                             rb=mid;\\n            }\\n                 end=mid-1;\\n        }\\n        \\n    }\\n    \\n    if(leftdiff<=rightdiff)//even both diff are same we take ans as smalest possible value\\n        return lb;\\n        return rb;\\n}\\n\"\"\"\\n<<<HOPE IT HELPS>>>",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "\\nExplaination:\\nIt initializes start to 0 and end to the maximum element in the input vector arr.\\nIt sets leftdiff and rightdiff to INT_MAX, which will be used to keep track of the minimum absolute differences found in the left and right halves of the binary search.\\nIt initializes variables lb and rb to store the best values found for the left and right halves, respectively.\\nThe function enters a binary search loop, where it calculates the mid point between start and end.\\nIt then calculates the sum using the result function with mid as the parameter.\\nDepending on whether the sum is less than or greater than the target value, it updates the leftdiff and rightdiff variables and the corresponding best value (lb or rb).\\nThe binary search is narrowed down based on the comparison between the sum and the target value.\\nAfter the binary search, it returns the best value (lb or rb) with the smaller absolute difference from the target value\\n\\n\\nCODE:\\n\"\"\"\\nint result(int start,vector<int>& arr)\\n    {\\n      int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            sum=sum+min(start,arr[i]);\\n\\n        \\n        }\\n        return sum;\\n    \\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n    int start = 0;\\n    int end = *max_element(arr.begin(), arr.end());\\n    int rightdiff = INT_MAX;\\n    int leftdiff=INT_MAX;\\n        int lb;\\n        int rb;\\n    \\n    while (start <= end) {\\n         // Use binary search to narrow down the range\\n        int mid=(start+end)/2;\\n        int sum = result(mid,arr);\\n        if(sum<target)\\n        {\\n            int left=abs(sum-target);\\n            if(min(leftdiff,left)==left)\\n            {\\n                leftdiff=left;\\n                lb=mid;\\n            }\\n           start=mid+1;\\n        \\n        }\\n        else\\n        {\\n            int right=abs(sum-target);\\n            if(min(rightdiff,right)==right)\\n            {\\n                         rightdiff=right;\\n                             rb=mid;\\n            }\\n                 end=mid-1;\\n        }\\n        \\n    }\\n    \\n    if(leftdiff<=rightdiff)//even both diff are same we take ans as smalest possible value\\n        return lb;\\n        return rb;\\n}\\n\"\"\"\\n<<<HOPE IT HELPS>>>",
                "codeTag": "Unknown"
            },
            {
                "id": 3824465,
                "title": "binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int mid,vector<int> &arr,int target){\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i] > mid) sum+=mid;\\n            else sum+=arr[i];\\n        }\\n        return abs(target-sum);\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l=0,r=*max_element(arr.begin(),arr.end()),ans;\\n        while(l<=r){\\n            int mid=(l+r)/2;\\n            if(solve(mid,arr,target) <= solve(mid+1,arr,target)) {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int mid,vector<int> &arr,int target){\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i] > mid) sum+=mid;\\n            else sum+=arr[i];\\n        }\\n        return abs(target-sum);\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l=0,r=*max_element(arr.begin(),arr.end()),ans;\\n        while(l<=r){\\n            int mid=(l+r)/2;\\n            if(solve(mid,arr,target) <= solve(mid+1,arr,target)) {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788320,
                "title": "c-no-binary-search",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nC++ method without using binary search \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n  \\n    int findBestValue(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        int s=0;\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<n;i++){\\n            if(arr[i]*(n-i)>=target){\\n                return int(round((target-0.0001)/(n-i)));\\n            }\\n            target-=arr[i];\\n        }\\n        \\n        return arr[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n  \\n    int findBestValue(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        int s=0;\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<n;i++){\\n            if(arr[i]*(n-i)>=target){\\n                return int(round((target-0.0001)/(n-i)));\\n            }\\n            target-=arr[i];\\n        }\\n        \\n        return arr[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778839,
                "title": "sort-and-control-the-rolling-sum-as-compared-to-averaged-target-hit-if-all-elements-x",
                "content": "# Intuition\\nNote the constraint that the elements are never less than 1 or negatie. This significantly simplifies the task.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe array is sorted first (as with unsorted one, you never know what the next element brings). In the sorted array for each element, we divide the difference between target and the sum of the elements that have already passed by the number of remaining elements (and round the result). The result of this operation is essentially \"if all remaining numbers are equal to it, we will hit the target\". If the current element is greater than this number - we got our response. If not, once the loop is over, we simply return the last (largest) element of array.\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n) )$$ because of sorting. $$O(n)$$ otherwise.\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int target_mem, rolling_sum=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            target_mem=(target-rolling_sum)/(arr.size()-i);\\n            if((target-rolling_sum)%(arr.size()-i)>0.5*(arr.size()-i))//>= would also fly, but hits an invalid test case\\n            {\\n                target_mem++;\\n            }\\n            if(arr[i]>target_mem)\\n            {\\n                return target_mem;\\n            }\\n            rolling_sum+=arr[i];\\n        }\\n        return arr[arr.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int target_mem, rolling_sum=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            target_mem=(target-rolling_sum)/(arr.size()-i);\\n            if((target-rolling_sum)%(arr.size()-i)>0.5*(arr.size()-i))//>= would also fly, but hits an invalid test case\\n            {\\n                target_mem++;\\n            }\\n            if(arr[i]>target_mem)\\n            {\\n                return target_mem;\\n            }\\n            rolling_sum+=arr[i];\\n        }\\n        return arr[arr.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775423,
                "title": "java-very-slow",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n     \\n\\n        int lastIndex = 0;\\n        int minDiff = Integer.MAX_VALUE;\\n        int result = -1;\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            int currentElement = arr[i];\\n            for (int j = lastIndex; j < currentElement; j++) {\\n                int currentDiff = Math.abs(target - j * (arr.length - i));\\n                if (currentDiff < minDiff) {\\n                    minDiff = currentDiff;\\n                    result = j;\\n                }\\n            }\\n            int currentDiff = Math.abs(target - currentElement * (arr.length - i));\\n            if (currentDiff < minDiff) {\\n                minDiff = currentDiff;\\n                result = currentElement;\\n            }\\n            target -= currentElement;\\n            lastIndex = currentElement;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n     \\n\\n        int lastIndex = 0;\\n        int minDiff = Integer.MAX_VALUE;\\n        int result = -1;\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            int currentElement = arr[i];\\n            for (int j = lastIndex; j < currentElement; j++) {\\n                int currentDiff = Math.abs(target - j * (arr.length - i));\\n                if (currentDiff < minDiff) {\\n                    minDiff = currentDiff;\\n                    result = j;\\n                }\\n            }\\n            int currentDiff = Math.abs(target - currentElement * (arr.length - i));\\n            if (currentDiff < minDiff) {\\n                minDiff = currentDiff;\\n                result = currentElement;\\n            }\\n            target -= currentElement;\\n            lastIndex = currentElement;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751649,
                "title": "easy-java-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSelf explanatory.!!,.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NLogN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int[] pre = new int[arr.length+1];\\n        pre[0]=0;\\n        for(int i=1;i<=arr.length;i++){\\n            pre[i]=arr[i-1]+pre[i-1];\\n        }\\n        int n = arr.length-1;\\n        if(pre[n+1]==target)return arr[n];\\n        int l=0,r=target;\\n        while(l<r){\\n            int m = (l+r)/2;\\n            int j=0;\\n            for(j=0;j<=n;j++){\\n                if(arr[j]>=m)break;\\n            }\\n            int val = pre[j]+(n-j+1)*m;\\n            for(;j<=n;j++){\\n                if(arr[j]>=m+1)break;\\n            }\\n            int val2 = pre[j]+(n-j+1)*(m+1);\\n            if(Math.abs(target-val)<=Math.abs(target-val2))r=m;\\n            else l=m+1;\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int[] pre = new int[arr.length+1];\\n        pre[0]=0;\\n        for(int i=1;i<=arr.length;i++){\\n            pre[i]=arr[i-1]+pre[i-1];\\n        }\\n        int n = arr.length-1;\\n        if(pre[n+1]==target)return arr[n];\\n        int l=0,r=target;\\n        while(l<r){\\n            int m = (l+r)/2;\\n            int j=0;\\n            for(j=0;j<=n;j++){\\n                if(arr[j]>=m)break;\\n            }\\n            int val = pre[j]+(n-j+1)*m;\\n            for(;j<=n;j++){\\n                if(arr[j]>=m+1)break;\\n            }\\n            int val2 = pre[j]+(n-j+1)*(m+1);\\n            if(Math.abs(target-val)<=Math.abs(target-val2))r=m;\\n            else l=m+1;\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736569,
                "title": "c-solution-using-binary-search-find-the-peak-element-in-bitonic-array",
                "content": "```\\nquestion is reduced to find the first element (cur) where abs(target-mutatedSum(cur)) <= abs(target-mutatedSum(cur+1))\\n```\\n```\\n//literally same as the peak element or else we can do it by normally also\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int lo = 0,hi = *max_element(arr.begin(),arr.end());\\n        int ans = hi;\\n        function<bool(int)> check = [&](int cur)->bool{\\n            int next = cur+1;\\n            int curSum = 0,nextSum = 0;\\n            for(auto & i : arr){\\n                curSum += i > cur ? cur : i;\\n                nextSum += i > next ? next : i;\\n            }\\n            return abs(target-curSum) <= abs(target-nextSum);\\n        };\\n        while(lo <= hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(check(mid)){\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else lo = mid+1;\\n        }\\n        return ans;\\n    }\\n```\\nupvote if it helps :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nquestion is reduced to find the first element (cur) where abs(target-mutatedSum(cur)) <= abs(target-mutatedSum(cur+1))\\n```\n```\\n//literally same as the peak element or else we can do it by normally also\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int lo = 0,hi = *max_element(arr.begin(),arr.end());\\n        int ans = hi;\\n        function<bool(int)> check = [&](int cur)->bool{\\n            int next = cur+1;\\n            int curSum = 0,nextSum = 0;\\n            for(auto & i : arr){\\n                curSum += i > cur ? cur : i;\\n                nextSum += i > next ? next : i;\\n            }\\n            return abs(target-curSum) <= abs(target-nextSum);\\n        };\\n        while(lo <= hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(check(mid)){\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else lo = mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3718579,
                "title": "clever-solution-in-c-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        vector<int> sum(arr.begin(),arr.end());\\n        int n=arr.size();\\n        int maxi=-1;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,arr[i]);\\n        }\\n        for(int i=1;i<n;i++){\\n            sum[i]+=sum[i-1];\\n        }\\n        int val=-1,dif=INT_MAX;\\n        vector<int>::iterator upper1;\\n        for(int i=0;i<=maxi;i++){\\n           upper1=upper_bound(arr.begin(),arr.end(),i);\\n           int ap=upper1-arr.begin();\\n           if(ap!=0){\\n             int vali=(n-ap)*i+sum[ap-1];\\n             if(abs(vali-target)<dif){\\n                 dif=abs(vali-target); val=i;\\n             }\\n           }\\n           else{\\n               int vali=(n)*i;\\n               if(abs(vali-target)<dif) {dif=abs(vali-target); val=i;}\\n           }\\n           \\n        }\\n        return val;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        vector<int> sum(arr.begin(),arr.end());\\n        int n=arr.size();\\n        int maxi=-1;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,arr[i]);\\n        }\\n        for(int i=1;i<n;i++){\\n            sum[i]+=sum[i-1];\\n        }\\n        int val=-1,dif=INT_MAX;\\n        vector<int>::iterator upper1;\\n        for(int i=0;i<=maxi;i++){\\n           upper1=upper_bound(arr.begin(),arr.end(),i);\\n           int ap=upper1-arr.begin();\\n           if(ap!=0){\\n             int vali=(n-ap)*i+sum[ap-1];\\n             if(abs(vali-target)<dif){\\n                 dif=abs(vali-target); val=i;\\n             }\\n           }\\n           else{\\n               int vali=(n)*i;\\n               if(abs(vali-target)<dif) {dif=abs(vali-target); val=i;}\\n           }\\n           \\n        }\\n        return val;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702616,
                "title": "solution-usign-binary-search-c",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nbased on binary search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<int>& arr,int m){\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]>m){\\n                sum=sum+m;\\n            }\\n            else{\\n                sum=sum+arr[i];\\n            }\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int mm=0;\\n        for(auto x:arr){\\n            if(x>mm){\\n                mm=x;\\n            }\\n        }\\n        int l=0,r=mm,m;\\n        int maxi=-1,mini=-1;\\n        int max=INT_MAX,min=INT_MAX;\\n        while(l<=r){\\n            m=l+(r-l)/2;\\n            int k=fun(arr,m);\\n            \\n            if(k>=target){\\n                max=k;\\n                maxi=m;\\n                r=m-1;\\n            }\\n            else{\\n                min=k;\\n                mini=m;\\n                l=m+1;\\n            }\\n        }\\n        if((target-min)<=(max-target)){\\n            return mini;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>& arr,int m){\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]>m){\\n                sum=sum+m;\\n            }\\n            else{\\n                sum=sum+arr[i];\\n            }\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int mm=0;\\n        for(auto x:arr){\\n            if(x>mm){\\n                mm=x;\\n            }\\n        }\\n        int l=0,r=mm,m;\\n        int maxi=-1,mini=-1;\\n        int max=INT_MAX,min=INT_MAX;\\n        while(l<=r){\\n            m=l+(r-l)/2;\\n            int k=fun(arr,m);\\n            \\n            if(k>=target){\\n                max=k;\\n                maxi=m;\\n                r=m-1;\\n            }\\n            else{\\n                min=k;\\n                mini=m;\\n                l=m+1;\\n            }\\n        }\\n        if((target-min)<=(max-target)){\\n            return mini;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679875,
                "title": "binary-search-with-two-edge-cases",
                "content": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        total = sum(arr)\\n        beg = min(arr)\\n        end = max(arr)\\n        res = (float(\\'inf\\'), -1)\\n        while beg <= end:\\n            mid = (beg + end) // 2\\n            curr = 0\\n            for el in arr:\\n                curr += el if el < mid else mid\\n            if curr >= target:\\n                res = min(res, (curr - target, mid))\\n                end = mid - 1\\n            else:\\n                res = min(res, (target - curr, mid))\\n                beg = mid + 1\\n        for extra in [target // n, target // n + 1]:\\n            curr = 0\\n            for el in arr:\\n                curr += el if el < extra else extra\\n            res = min(res, (abs(curr - target), extra))\\n        return res[1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        total = sum(arr)\\n        beg = min(arr)\\n        end = max(arr)\\n        res = (float(\\'inf\\'), -1)\\n        while beg <= end:\\n            mid = (beg + end) // 2\\n            curr = 0\\n            for el in arr:\\n                curr += el if el < mid else mid\\n            if curr >= target:\\n                res = min(res, (curr - target, mid))\\n                end = mid - 1\\n            else:\\n                res = min(res, (target - curr, mid))\\n                beg = mid + 1\\n        for extra in [target // n, target // n + 1]:\\n            curr = 0\\n            for el in arr:\\n                curr += el if el < extra else extra\\n            res = min(res, (abs(curr - target), extra))\\n        return res[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645398,
                "title": "prefix-sum-binary-search-python3-solution",
                "content": "```\\nclass Solution:\\n    \\n    def findDiffAfterMutation(self, value: int, arr: List[int], prefix_sum: List[int]) -> int:\\n        \\n        lo, hi = 0, len(arr)-1\\n        index = -1\\n        while lo <= hi:\\n            mid = (lo+hi)//2\\n            if arr[mid] <= value:\\n                index = mid\\n                lo = mid+1\\n            else:\\n                hi = mid-1\\n                \\n        tot = prefix_sum[index+1]\\n        mutated_len = len(arr)-index-1\\n        tot += (value*mutated_len)\\n        \\n        return tot\\n                \\n    \\n    # O(nlogn) time,\\n    # O(n) space,\\n    # Approach: prefix sum, binary search, sorting, \\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        prefix_sum = [0]\\n        tot = 0\\n        for num in arr:\\n            tot += num\\n            prefix_sum.append(tot)\\n        \\n        min_diff = float(\\'inf\\')\\n        ans = arr[-1]\\n        for i in range(0, arr[-1]+1):\\n            curr_diff = abs(target-self.findDiffAfterMutation(i, arr, prefix_sum))\\n            if curr_diff > min_diff:\\n                break\\n            elif curr_diff < min_diff:\\n                ans = i\\n                min_diff = curr_diff\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def findDiffAfterMutation(self, value: int, arr: List[int], prefix_sum: List[int]) -> int:\\n        \\n        lo, hi = 0, len(arr)-1\\n        index = -1\\n        while lo <= hi:\\n            mid = (lo+hi)//2\\n            if arr[mid] <= value:\\n                index = mid\\n                lo = mid+1\\n            else:\\n                hi = mid-1\\n                \\n        tot = prefix_sum[index+1]\\n        mutated_len = len(arr)-index-1\\n        tot += (value*mutated_len)\\n        \\n        return tot\\n                \\n    \\n    # O(nlogn) time,\\n    # O(n) space,\\n    # Approach: prefix sum, binary search, sorting, \\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        prefix_sum = [0]\\n        tot = 0\\n        for num in arr:\\n            tot += num\\n            prefix_sum.append(tot)\\n        \\n        min_diff = float(\\'inf\\')\\n        ans = arr[-1]\\n        for i in range(0, arr[-1]+1):\\n            curr_diff = abs(target-self.findDiffAfterMutation(i, arr, prefix_sum))\\n            if curr_diff > min_diff:\\n                break\\n            elif curr_diff < min_diff:\\n                ans = i\\n                min_diff = curr_diff\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637477,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n   int getsum(vector<int>&arr,int mid){//can be calculated using prefix sum\\n        long long sum=0;\\n        for(auto x:arr){\\n          sum+=(x>mid)?mid:x;\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int low=0,high=*max_element(arr.begin(),arr.end());\\n        int mnvalue=0;\\n        for(auto x:arr){mnvalue+=x;}\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n             int sum=getsum(arr,mid);\\n            if((target-sum)<=0){\\n                  if(mnvalue>=abs(target-sum)){\\n                      ans=(mnvalue==abs(target-sum))?min(ans,mid):mid;\\n                    mnvalue=min(mnvalue,abs(target-sum));\\n                     \\n                }\\n                high=mid-1;\\n            }else{\\n                   if(mnvalue>=abs(target-sum)){\\n                        ans=(mnvalue==abs(target-sum))?min(ans,mid):mid;\\n                    mnvalue=min(mnvalue,abs(target-sum));\\n                    \\n                }\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int getsum(vector<int>&arr,int mid){//can be calculated using prefix sum\\n        long long sum=0;\\n        for(auto x:arr){\\n          sum+=(x>mid)?mid:x;\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int low=0,high=*max_element(arr.begin(),arr.end());\\n        int mnvalue=0;\\n        for(auto x:arr){mnvalue+=x;}\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n             int sum=getsum(arr,mid);\\n            if((target-sum)<=0){\\n                  if(mnvalue>=abs(target-sum)){\\n                      ans=(mnvalue==abs(target-sum))?min(ans,mid):mid;\\n                    mnvalue=min(mnvalue,abs(target-sum));\\n                     \\n                }\\n                high=mid-1;\\n            }else{\\n                   if(mnvalue>=abs(target-sum)){\\n                        ans=(mnvalue==abs(target-sum))?min(ans,mid):mid;\\n                    mnvalue=min(mnvalue,abs(target-sum));\\n                    \\n                }\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613132,
                "title": "simple-c-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint bs(vector<int>& arr,int number){\\n    int l=0;\\n    int r=arr.size()-1;\\n    int index=-1;\\n    while(l<=r){\\n        int mid=(l+r)/2;\\n        if(arr[mid]>number){\\n            index=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]<=number){\\n            l=mid+1;\\n        }\\n    }\\n    return index;\\n}\\n    int findBestValue(vector<int>& arr, int target) {\\n     sort(arr.begin(),arr.end());\\n     vector<int>prefix;\\n     prefix.push_back(arr[0]);\\n     for(int i=1;i<arr.size();i++){\\n         prefix.push_back(arr[i]+prefix[i-1]);\\n     }\\n     int ans=INT_MAX;\\n     int hope=0;\\n     for(int i=0;i<=target;i++){\\n         int index=bs(arr,i);\\n         int res;\\n         if(index>0) res=prefix[index-1]+(arr.size()-index)*i;\\n         if(index==0)res=(arr.size()-index)*i;\\n         if(index==-1)res=prefix[arr.size()-1];\\n         if(ans>abs(res-target)){\\n             ans=abs(res-target);\\n             hope=i;\\n         }\\n     }\\n     return hope;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint bs(vector<int>& arr,int number){\\n    int l=0;\\n    int r=arr.size()-1;\\n    int index=-1;\\n    while(l<=r){\\n        int mid=(l+r)/2;\\n        if(arr[mid]>number){\\n            index=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]<=number){\\n            l=mid+1;\\n        }\\n    }\\n    return index;\\n}\\n    int findBestValue(vector<int>& arr, int target) {\\n     sort(arr.begin(),arr.end());\\n     vector<int>prefix;\\n     prefix.push_back(arr[0]);\\n     for(int i=1;i<arr.size();i++){\\n         prefix.push_back(arr[i]+prefix[i-1]);\\n     }\\n     int ans=INT_MAX;\\n     int hope=0;\\n     for(int i=0;i<=target;i++){\\n         int index=bs(arr,i);\\n         int res;\\n         if(index>0) res=prefix[index-1]+(arr.size()-index)*i;\\n         if(index==0)res=(arr.size()-index)*i;\\n         if(index==-1)res=prefix[arr.size()-1];\\n         if(ans>abs(res-target)){\\n             ans=abs(res-target);\\n             hope=i;\\n         }\\n     }\\n     return hope;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559290,
                "title": "a-simple-and-easy-to-understand-o-log-n-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe sum of array that we get after replacing all the values larger than a $$num$$ by $$num$$ is non-decreasing with respect to $$num$$. So, we can use binary search for this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo calculate the sum easily, we can pre-calulate the cumulative sum array $$pre$$, where $$pre[i] = arr[0] + arr[1] + ... + arr[i]$$.\\n\\nNow we use binary search to find the number. The lowest such number can be $$0$$, because if we replace all numbers by $$0$$, we will get sum as $$0$$. So, we will set the lower bound of our solution space as $$0$$. Our upper bound can be the largest number in the array, since any $$mid$$ greater than $$max(arr)$$ will lead to no replacement, so that will be as good as $$max(arr)$$.\\n\\nWe also sort the array to easily find the elements larger than $$mid$$.\\n\\nFor a given $$num$$, we find the index $$ub$$ so that $$ub$$ is the minimum index at which $$arr[ub] > mid$$. So, we know that all elements at $$ub$$ and after it are greater than $$mid$$. So, sum of all such elements after replacing them with $$mid$$ will be $$mid * (n - ub)$$. All the elements at indices less than $$ub$$ will be less than or equal to $$mid$$, so sum of all such elements will be $$pre[ub - 1]$$. So, total sum $$sum$$ will be equal to sum of both parts: $$pre[ub - 1] + mid * (n - ub)$$.\\n\\nWe compare $$sum$$ with $$target$$ and adjust our solution space according to that. We also update our answer based on $$abs(sum - target)$$.\\n\\n# Complexity\\n- Time complexity: $$O(n log(n))$$, since the most expensive operation is sorting. Our binary search loop takes $$O((log(n))^2)$$ time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for storing cumulative sum.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        int n = arr.size();\\n        int lo = 0, hi = arr[n - 1];\\n        vector<long long int> pre(n);\\n        pre[0] = arr[0];\\n        for (int i = 1; i < n; i++) {\\n            pre[i] = pre[i - 1] + arr[i];\\n        }\\n        int ans;\\n        long long int minmDiff = INT_MAX;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int ub = upper_bound(arr.begin(), arr.end(), mid) - arr.begin();\\n            long long int sum = (ub > 0 ? pre[ub - 1] : 0) + mid * (n - ub);\\n            long long int diff = abs(sum - target);\\n            if (diff < minmDiff || (minmDiff == diff && mid < ans)) {\\n                minmDiff = diff;\\n                ans = mid;\\n            }\\n            if (sum >= target) {\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        int n = arr.size();\\n        int lo = 0, hi = arr[n - 1];\\n        vector<long long int> pre(n);\\n        pre[0] = arr[0];\\n        for (int i = 1; i < n; i++) {\\n            pre[i] = pre[i - 1] + arr[i];\\n        }\\n        int ans;\\n        long long int minmDiff = INT_MAX;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int ub = upper_bound(arr.begin(), arr.end(), mid) - arr.begin();\\n            long long int sum = (ub > 0 ? pre[ub - 1] : 0) + mid * (n - ub);\\n            long long int diff = abs(sum - target);\\n            if (diff < minmDiff || (minmDiff == diff && mid < ans)) {\\n                minmDiff = diff;\\n                ans = mid;\\n            }\\n            if (sum >= target) {\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534255,
                "title": "easy-c-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int sum = accumulate(arr.begin(), arr.end(), 0);\\n        if(target >= sum){\\n            auto it = max_element(arr.begin(), arr.end());\\n            return *it;\\n        }\\n        int minNumber = 0;\\n        int prevDiff = INT_MAX;\\n        int result = 0;\\n        \\n        while(1){\\n            int currentSum = 0;\\n            for(int i=0; i<arr.size(); i++){\\n                if(arr[i] > minNumber){\\n                    currentSum += minNumber;\\n                }else{\\n                    currentSum += arr[i];\\n                }\\n            }\\n\\n            int currentDiff = abs(target - currentSum);\\n            if(currentDiff < prevDiff){\\n                prevDiff = currentDiff;\\n                result = minNumber;\\n            }else{\\n                break;\\n            }\\n\\n            minNumber++;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int sum = accumulate(arr.begin(), arr.end(), 0);\\n        if(target >= sum){\\n            auto it = max_element(arr.begin(), arr.end());\\n            return *it;\\n        }\\n        int minNumber = 0;\\n        int prevDiff = INT_MAX;\\n        int result = 0;\\n        \\n        while(1){\\n            int currentSum = 0;\\n            for(int i=0; i<arr.size(); i++){\\n                if(arr[i] > minNumber){\\n                    currentSum += minNumber;\\n                }else{\\n                    currentSum += arr[i];\\n                }\\n            }\\n\\n            int currentDiff = abs(target - currentSum);\\n            if(currentDiff < prevDiff){\\n                prevDiff = currentDiff;\\n                result = minNumber;\\n            }else{\\n                break;\\n            }\\n\\n            minNumber++;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518776,
                "title": "readable-swift-binary-search",
                "content": "# Complexity\\n- Time complexity: $$O(nlog * max(arr))$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func findBestValue(_ arr: [Int], _ target: Int) -> Int {\\n        var l = target / arr.count\\n        var r = arr.max()!\\n\\n        var ans = r\\n        var total = arr.reduce(0, +)\\n        var diff = abs(total - target)\\n\\n        while l <= r {\\n            let mid = (l + r) / 2\\n\\n            var sum = 0\\n            for num in arr {\\n                sum += num <= mid ? num : mid\\n            }\\n\\n            if sum > target {\\n                r = mid - 1\\n            } else {\\n                l = mid + 1\\n            }\\n\\n            if abs(sum - target) < diff || abs(sum - target) == diff && mid < ans  {\\n                diff = abs(sum - target)\\n                ans = mid\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findBestValue(_ arr: [Int], _ target: Int) -> Int {\\n        var l = target / arr.count\\n        var r = arr.max()!\\n\\n        var ans = r\\n        var total = arr.reduce(0, +)\\n        var diff = abs(total - target)\\n\\n        while l <= r {\\n            let mid = (l + r) / 2\\n\\n            var sum = 0\\n            for num in arr {\\n                sum += num <= mid ? num : mid\\n            }\\n\\n            if sum > target {\\n                r = mid - 1\\n            } else {\\n                l = mid + 1\\n            }\\n\\n            if abs(sum - target) < diff || abs(sum - target) == diff && mid < ans  {\\n                diff = abs(sum - target)\\n                ans = mid\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483867,
                "title": "c-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        std::sort(arr.begin(), arr.end());\\n        int l = 0, r = arr[arr.size() - 1];\\n        while (l + 1 < r) {\\n            int mid = (l + r) / 2;\\n            int diff = getDiff(arr, target, mid);\\n            if (diff >= 0) r = mid;\\n            else l = mid;\\n        }\\n        if (abs(getDiff(arr, target, l)) <= abs(getDiff(arr, target, r))) return l;\\n        else return r;\\n    }\\n\\n    int getDiff(vector<int>& arr, int target, int value) {\\n        int diff;\\n        if (arr[0] >= value) {\\n            diff = value * arr.size() - target;\\n        } else if (arr[arr.size() - 1] <= value) {\\n            diff = std::accumulate(arr.begin(), arr.end(), 0) - target;\\n        } else {\\n            int sum = 0;\\n            for (int i = 0; i < arr.size() - 1; i++) {\\n                sum = sum + arr[i];\\n                if (arr[i] <= value && arr[i + 1] >= value) {\\n                    diff = sum + (arr.size() - i - 1) * value - target;\\n                    break;\\n                }\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        std::sort(arr.begin(), arr.end());\\n        int l = 0, r = arr[arr.size() - 1];\\n        while (l + 1 < r) {\\n            int mid = (l + r) / 2;\\n            int diff = getDiff(arr, target, mid);\\n            if (diff >= 0) r = mid;\\n            else l = mid;\\n        }\\n        if (abs(getDiff(arr, target, l)) <= abs(getDiff(arr, target, r))) return l;\\n        else return r;\\n    }\\n\\n    int getDiff(vector<int>& arr, int target, int value) {\\n        int diff;\\n        if (arr[0] >= value) {\\n            diff = value * arr.size() - target;\\n        } else if (arr[arr.size() - 1] <= value) {\\n            diff = std::accumulate(arr.begin(), arr.end(), 0) - target;\\n        } else {\\n            int sum = 0;\\n            for (int i = 0; i < arr.size() - 1; i++) {\\n                sum = sum + arr[i];\\n                if (arr[i] <= value && arr[i + 1] >= value) {\\n                    diff = sum + (arr.size() - i - 1) * value - target;\\n                    break;\\n                }\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389914,
                "title": "c-easy-to-understand-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int low =0,high =0;\\n        for(int i=0;i<n;i++){\\n            high = max(high,arr[i]);\\n        }\\n        while(low<high){\\n            int mid = low+(high-low)/2;\\n            int sum =0;\\n            for(int i=0;i<n;i++){\\n                sum+=min(arr[i],mid);\\n            }\\n\\n            if(sum>=target){\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n\\n        int sum1 =0,sum2 =0;\\n        for(int i=0;i<n;i++){\\n            sum1 += min(arr[i],low);\\n            sum2 += min(arr[i],low-1);\\n\\n        }\\n        return abs(sum2-target)<=abs(sum1-target)? low-1:low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int low =0,high =0;\\n        for(int i=0;i<n;i++){\\n            high = max(high,arr[i]);\\n        }\\n        while(low<high){\\n            int mid = low+(high-low)/2;\\n            int sum =0;\\n            for(int i=0;i<n;i++){\\n                sum+=min(arr[i],mid);\\n            }\\n\\n            if(sum>=target){\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n\\n        int sum1 =0,sum2 =0;\\n        for(int i=0;i<n;i++){\\n            sum1 += min(arr[i],low);\\n            sum2 += min(arr[i],low-1);\\n\\n        }\\n        return abs(sum2-target)<=abs(sum1-target)? low-1:low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361907,
                "title": "binary-search",
                "content": "\\n```\\n\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        low,high = 0,max(max(arr),target//len(arr))\\n        diff = float(\\'inf\\')\\n        ans = 0\\n\\n        def solve(num):\\n            sumi = 0\\n            for i in range(len(arr)):\\n                if arr[i]>num:\\n                    sumi+=num\\n                else:\\n                    sumi+=arr[i]\\n            \\n            return sumi\\n\\n        while low<=high:\\n            mid = (low+high)//2\\n            val = solve(mid)\\n            if abs(val-target)==diff:\\n                ans = min(ans,mid)\\n            if abs(val-target)<diff:\\n                diff = abs(val-target)\\n                ans = mid\\n            if val>=target:\\n                high = mid-1\\n\\n            else:\\n                low = mid+1\\n\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        low,high = 0,max(max(arr),target//len(arr))\\n        diff = float(\\'inf\\')\\n        ans = 0\\n\\n        def solve(num):\\n            sumi = 0\\n            for i in range(len(arr)):\\n                if arr[i]>num:\\n                    sumi+=num\\n                else:\\n                    sumi+=arr[i]\\n            \\n            return sumi\\n\\n        while low<=high:\\n            mid = (low+high)//2\\n            val = solve(mid)\\n            if abs(val-target)==diff:\\n                ans = min(ans,mid)\\n            if abs(val-target)<diff:\\n                diff = abs(val-target)\\n                ans = mid\\n            if val>=target:\\n                high = mid-1\\n\\n            else:\\n                low = mid+1\\n\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349806,
                "title": "classic-binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: nlog(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(vector<int>nums,int target,int mid)\\n    {   int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>mid)\\n            {\\n                sum+=mid;\\n            }else\\n            {\\n                sum+=nums[i];\\n            }\\n        }\\n       return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int start=0;\\n        int end=*max_element(arr.begin(),arr.end());\\n        int diff=INT_MAX;\\n        int ans=0;\\n        \\n        while(start<=end)\\n        {\\n            int mid=start + (end-start)/2;\\n            int sum=func(arr,target,mid);\\n            if(sum==target)\\n            return mid;\\n            if(sum<target)\\n            {\\n                start=mid+1;\\n                if(abs(sum-target)<diff)\\n                {\\n                    diff=abs(sum-target);\\n                    ans=mid;\\n                }else if(abs(target-sum)==diff)\\n                ans=min(ans,mid);\\n\\n            }else\\n            {\\n                end=mid-1;\\n                 if(abs(sum-target)<diff)\\n                {\\n                    diff=abs(sum-target);\\n                    ans=mid;\\n                }else if(abs(target-sum)==diff)\\n                ans=min(ans,mid);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n//4 , 9,3\\n//diff=1\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(vector<int>nums,int target,int mid)\\n    {   int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>mid)\\n            {\\n                sum+=mid;\\n            }else\\n            {\\n                sum+=nums[i];\\n            }\\n        }\\n       return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int start=0;\\n        int end=*max_element(arr.begin(),arr.end());\\n        int diff=INT_MAX;\\n        int ans=0;\\n        \\n        while(start<=end)\\n        {\\n            int mid=start + (end-start)/2;\\n            int sum=func(arr,target,mid);\\n            if(sum==target)\\n            return mid;\\n            if(sum<target)\\n            {\\n                start=mid+1;\\n                if(abs(sum-target)<diff)\\n                {\\n                    diff=abs(sum-target);\\n                    ans=mid;\\n                }else if(abs(target-sum)==diff)\\n                ans=min(ans,mid);\\n\\n            }else\\n            {\\n                end=mid-1;\\n                 if(abs(sum-target)<diff)\\n                {\\n                    diff=abs(sum-target);\\n                    ans=mid;\\n                }else if(abs(target-sum)==diff)\\n                ans=min(ans,mid);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n//4 , 9,3\\n//diff=1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336309,
                "title": "binary-search-solution-faster-than-100-java",
                "content": "\\n# Binary Search Solution\\nThe value we are looking for is somewhere between 0 and maxValue (m).\\nNow use Binary search to speed up the process.\\n\\n- go up if the sum is too small\\n- go down if the sum is too big\\n- \\nWhen we are done with binary search, left and right are equal, but it might happen that we have not exactly reached the target.\\nCheck if left - 1 (should get us below the target) leads to the sum closer to the target.\\n\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int max = arr[0], sum = arr[0], n = arr.length;\\n\\n        for (int i = 1; i < n; i++) {\\n            sum += arr[i];\\n            max = Math.max(arr[i], max);\\n        }\\n\\n        if (sum <= target) return max;\\n\\n        int left = 0, right = max;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            sum = 0;\\n            for (int num : arr) {\\n                sum += (num > mid) ? mid : num;\\n            }\\n            if (sum >= target) right = mid;\\n            else left = mid + 1;\\n        }\\n\\n        int sum1 = 0, sum2 = 0;\\n\\n        for (int num : arr) {\\n            sum1 += (num > left) ? left : num;\\n            sum2 += (num > left - 1) ? left - 1 : num;\\n        }\\n\\n        return (Math.abs(sum2 - target) <= Math.abs(sum1 - target)) ? left - 1: left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int max = arr[0], sum = arr[0], n = arr.length;\\n\\n        for (int i = 1; i < n; i++) {\\n            sum += arr[i];\\n            max = Math.max(arr[i], max);\\n        }\\n\\n        if (sum <= target) return max;\\n\\n        int left = 0, right = max;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            sum = 0;\\n            for (int num : arr) {\\n                sum += (num > mid) ? mid : num;\\n            }\\n            if (sum >= target) right = mid;\\n            else left = mid + 1;\\n        }\\n\\n        int sum1 = 0, sum2 = 0;\\n\\n        for (int num : arr) {\\n            sum1 += (num > left) ? left : num;\\n            sum2 += (num > left - 1) ? left - 1 : num;\\n        }\\n\\n        return (Math.abs(sum2 - target) <= Math.abs(sum1 - target)) ? left - 1: left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332144,
                "title": "scala-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def findBestValue(arr: Array[Int], target: Int): Int = {\\n      var sum = 0\\n      var max = Int.MinValue\\n      for (i<-arr) {\\n        sum += i\\n        max = math.max(max, i)\\n      }\\n      \\n      def getMutSum(tmp: Array[Int], mid: Int) = {\\n        var sum = 0\\n        for (i<-tmp) sum += (if (i > mid) mid else i)\\n        sum\\n      }\\n\\n      if (sum == target) max\\n      else {\\n        var min = 0\\n        var res = 1\\n        var diff = Int.MaxValue\\n        while(min <= max) {\\n          val mid = min + (max - min)/2\\n          sum = getMutSum(arr, mid)\\n          if (sum>target) max = mid -1\\n          else min = mid + 1\\n          if (math.abs(sum-target)<diff || (math.abs(sum-target) == diff && mid < res)) {\\n            res = mid\\n            diff = math.abs(sum - target)\\n          }\\n        }\\n        res\\n      }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def findBestValue(arr: Array[Int], target: Int): Int = {\\n      var sum = 0\\n      var max = Int.MinValue\\n      for (i<-arr) {\\n        sum += i\\n        max = math.max(max, i)\\n      }\\n      \\n      def getMutSum(tmp: Array[Int], mid: Int) = {\\n        var sum = 0\\n        for (i<-tmp) sum += (if (i > mid) mid else i)\\n        sum\\n      }\\n\\n      if (sum == target) max\\n      else {\\n        var min = 0\\n        var res = 1\\n        var diff = Int.MaxValue\\n        while(min <= max) {\\n          val mid = min + (max - min)/2\\n          sum = getMutSum(arr, mid)\\n          if (sum>target) max = mid -1\\n          else min = mid + 1\\n          if (math.abs(sum-target)<diff || (math.abs(sum-target) == diff && mid < res)) {\\n            res = mid\\n            diff = math.abs(sum - target)\\n          }\\n        }\\n        res\\n      }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3329832,
                "title": "java-solution-prefix-sum-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n- Space complexity:O(n)\\n# Code\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int presum[]=new int[arr.length];\\n        presum[0]=arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            presum[i]=presum[i-1]+arr[i];\\n        }\\n        int i=0;\\n        int min=Integer.MAX_VALUE;\\n        int j=arr[arr.length-1];\\n        int ans=0;\\n        while(i<=j){\\n            int sum=findsum(i,presum,arr,i);\\n            if(min>((int)Math.abs(target-sum))){\\n                min=(int)Math.abs(target-sum);\\n                ans=i;\\n            }\\n            i++;\\n\\n        }\\n        return ans;\\n    }\\n    public static int findsum(int i,int presum[],int arr[],int target){\\n        int index=0;\\n        int start = 0, end = arr.length - 1;\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if(arr[mid]==target){\\n                index=mid;\\n                break;\\n            };\\n            if (arr[mid] <= target) {\\n                start = mid + 1;\\n            }\\n            else {\\n                index = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        int sum=(arr.length-index)*i;\\n        if(index!=0)\\n        sum+=presum[index-1];\\n        return sum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int presum[]=new int[arr.length];\\n        presum[0]=arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            presum[i]=presum[i-1]+arr[i];\\n        }\\n        int i=0;\\n        int min=Integer.MAX_VALUE;\\n        int j=arr[arr.length-1];\\n        int ans=0;\\n        while(i<=j){\\n            int sum=findsum(i,presum,arr,i);\\n            if(min>((int)Math.abs(target-sum))){\\n                min=(int)Math.abs(target-sum);\\n                ans=i;\\n            }\\n            i++;\\n\\n        }\\n        return ans;\\n    }\\n    public static int findsum(int i,int presum[],int arr[],int target){\\n        int index=0;\\n        int start = 0, end = arr.length - 1;\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if(arr[mid]==target){\\n                index=mid;\\n                break;\\n            };\\n            if (arr[mid] <= target) {\\n                start = mid + 1;\\n            }\\n            else {\\n                index = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        int sum=(arr.length-index)*i;\\n        if(index!=0)\\n        sum+=presum[index-1];\\n        return sum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280976,
                "title": "o-log-n-2-approach-explained-c-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nyou can see the code plus a little imporovement on your side could be that rather then summing up in the diff func by iterating over the whole arr you could sort the array pre hand and then precompute the prefix sum of the entire array and then you can just easily do a quick bianry search over the array and then calculate the sum as following:\\n```\\nsum = (size_of_arr - index_just_smaller_than_mid)*mid + pre[index_just_smaller_than_mid]; \\n```\\nand this would just give you what you are trying to find out int the for loop. \\n\\nhere a good thing to notice would be that the time complexity in both the approaches would be same for the simple reason that in the optmized approach you would have to sort the array beforehand and that would cost around nlogn but the 2nd apporach as is described above would be so much better if you are given a sorted array and that could be the case in other problems\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn) can be reduced to O((log(n))^2) + sort\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int diff(int mid, vector<int>& arr, int target)\\n    {\\n        int sum = 0;\\n        for(int i = 0; i < arr.size(); i++) sum += min(mid, arr[i]);\\n        return abs(target - sum);\\n    }\\n    int findBestValue(vector<int>& arr, int target)\\n    {\\n        int n = arr.size();\\n        int s = 0;\\n        int e = target;\\n        while(s < e)\\n        {\\n            int mid = s + (e - s)/2;\\n            if(diff(mid, arr, target) <= diff(mid + 1, arr, target)) e = mid;\\n            else s = mid + 1;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nsum = (size_of_arr - index_just_smaller_than_mid)*mid + pre[index_just_smaller_than_mid]; \\n```\n```\\nclass Solution {\\npublic:\\n    int diff(int mid, vector<int>& arr, int target)\\n    {\\n        int sum = 0;\\n        for(int i = 0; i < arr.size(); i++) sum += min(mid, arr[i]);\\n        return abs(target - sum);\\n    }\\n    int findBestValue(vector<int>& arr, int target)\\n    {\\n        int n = arr.size();\\n        int s = 0;\\n        int e = target;\\n        while(s < e)\\n        {\\n            int mid = s + (e - s)/2;\\n            if(diff(mid, arr, target) <= diff(mid + 1, arr, target)) e = mid;\\n            else s = mid + 1;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260972,
                "title": "c-binary-search-16ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int start=0;\\n        int end=1e5;\\n        int mid=start+(end-start)/2;\\n        int ans=-1;\\n        int diff=INT_MAX;\\n        while(start<=end){\\n            mid=start+(end-start)/2;\\n            int sum=0;\\n            bool temp=0;\\n            for(int i: arr){\\n                if(i>mid) temp=1;\\n                sum+=min(i,mid);    \\n            }\\n            int curr_diff=target-sum;\\n            if(abs(curr_diff)<diff){\\n                diff=abs(curr_diff);\\n                ans=mid;\\n            }\\n            else if(abs(curr_diff)==diff && mid<ans){\\n                ans=mid;\\n            }\\n            if(temp==0 || curr_diff<=0){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int start=0;\\n        int end=1e5;\\n        int mid=start+(end-start)/2;\\n        int ans=-1;\\n        int diff=INT_MAX;\\n        while(start<=end){\\n            mid=start+(end-start)/2;\\n            int sum=0;\\n            bool temp=0;\\n            for(int i: arr){\\n                if(i>mid) temp=1;\\n                sum+=min(i,mid);    \\n            }\\n            int curr_diff=target-sum;\\n            if(abs(curr_diff)<diff){\\n                diff=abs(curr_diff);\\n                ans=mid;\\n            }\\n            else if(abs(curr_diff)==diff && mid<ans){\\n                ans=mid;\\n            }\\n            if(temp==0 || curr_diff<=0){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247009,
                "title": "ordinary-binary-search-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$.\\n\\n- Space complexity: $$O(n)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        self.arr = arr\\n        self.arr.sort()\\n        self.arr.insert(0, 0)\\n        self.prefixSum = [0]*len(self.arr)\\n        for i in range(1, len(self.arr)):\\n            self.prefixSum[i] = self.prefixSum[i-1] + self.arr[i]\\n        \\n        value = None\\n        lValue, rValue = 0, self.arr[-1]\\n        minDiff = math.inf\\n        while lValue <= rValue:\\n            mValue = lValue + (rValue - lValue)//2\\n            diff = self.calcSum(mValue) - target\\n            if abs(diff) < minDiff:\\n                minDiff = abs(diff)\\n                value = mValue\\n            elif abs(diff) == minDiff:\\n                value = min(value, mValue)\\n\\n            if diff == 0:\\n                break\\n            elif diff > 0:\\n                rValue = mValue - 1\\n            else:\\n                lValue = mValue + 1\\n        \\n        return value\\n    \\n\\n    def calcSum(self, value):\\n        ind = None\\n        lInd, rInd = 0, len(self.arr)-1\\n        while lInd <= rInd:\\n            mInd = lInd + (rInd - lInd)//2\\n            if self.arr[mInd] <= value:\\n                ind = mInd\\n                lInd = mInd + 1\\n            else:\\n                rInd = mInd - 1\\n        \\n        return self.prefixSum[ind] + value*(len(self.arr) - ind - 1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        self.arr = arr\\n        self.arr.sort()\\n        self.arr.insert(0, 0)\\n        self.prefixSum = [0]*len(self.arr)\\n        for i in range(1, len(self.arr)):\\n            self.prefixSum[i] = self.prefixSum[i-1] + self.arr[i]\\n        \\n        value = None\\n        lValue, rValue = 0, self.arr[-1]\\n        minDiff = math.inf\\n        while lValue <= rValue:\\n            mValue = lValue + (rValue - lValue)//2\\n            diff = self.calcSum(mValue) - target\\n            if abs(diff) < minDiff:\\n                minDiff = abs(diff)\\n                value = mValue\\n            elif abs(diff) == minDiff:\\n                value = min(value, mValue)\\n\\n            if diff == 0:\\n                break\\n            elif diff > 0:\\n                rValue = mValue - 1\\n            else:\\n                lValue = mValue + 1\\n        \\n        return value\\n    \\n\\n    def calcSum(self, value):\\n        ind = None\\n        lInd, rInd = 0, len(self.arr)-1\\n        while lInd <= rInd:\\n            mInd = lInd + (rInd - lInd)//2\\n            if self.arr[mInd] <= value:\\n                ind = mInd\\n                lInd = mInd + 1\\n            else:\\n                rInd = mInd - 1\\n        \\n        return self.prefixSum[ind] + value*(len(self.arr) - ind - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206677,
                "title": "java-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n   public int findBestValue(int[] arr, int target) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for (int a : arr) {\\n            sum += a;\\n            max = Math.max(max, a);\\n        }\\n        if (sum == target) return max;\\n        int min = 0, res = 1,diff = Integer.MAX_VALUE;\\n        // The answer would lie between 0 and maximum value in the array.\\n        while (min <= max) {\\n            int mid = min + (max - min) / 2;\\n            sum = getMutatedSum(arr, mid); \\n            if (sum > target) {\\n                max = mid - 1;\\n            } else {\\n                min = mid + 1;\\n            }\\n            // If current difference is less than diff || current difference==diff but mid < res.(choose the smaller one.)\\n            if (Math.abs(sum - target) < diff || (Math.abs(sum - target) == diff && mid < res)) { \\n                res = mid;\\n                diff = Math.abs(sum - target);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private int getMutatedSum(int[] arr, int mid) {\\n        int sum = 0;\\n        for (int a : arr) {\\n            sum += (a > mid) ? mid : a;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int findBestValue(int[] arr, int target) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for (int a : arr) {\\n            sum += a;\\n            max = Math.max(max, a);\\n        }\\n        if (sum == target) return max;\\n        int min = 0, res = 1,diff = Integer.MAX_VALUE;\\n        // The answer would lie between 0 and maximum value in the array.\\n        while (min <= max) {\\n            int mid = min + (max - min) / 2;\\n            sum = getMutatedSum(arr, mid); \\n            if (sum > target) {\\n                max = mid - 1;\\n            } else {\\n                min = mid + 1;\\n            }\\n            // If current difference is less than diff || current difference==diff but mid < res.(choose the smaller one.)\\n            if (Math.abs(sum - target) < diff || (Math.abs(sum - target) == diff && mid < res)) { \\n                res = mid;\\n                diff = Math.abs(sum - target);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private int getMutatedSum(int[] arr, int mid) {\\n        int sum = 0;\\n        for (int a : arr) {\\n            sum += (a > mid) ? mid : a;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201012,
                "title": "c-binary-search-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findSum(vector<int> &arr, int val) {\\n        long long sum = 0;\\n        for(auto &x: arr) sum += min(x, val);\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l =0, r = *max_element(arr.begin(), arr.end());\\n        int left_diff = INT_MAX, right_diff = INT_MAX;\\n        int left_val, right_val;\\n        while(l<=r) {\\n            int mid = (l+r)/2;\\n            \\n            long long sum = findSum(arr, mid);\\n            long long diff = abs(target - sum);\\n            \\n            if(sum < target) {\\n                if(diff < left_diff) {\\n                    left_diff = diff;\\n                    left_val = mid;\\n                }\\n                l = mid+1;\\n            } else {\\n                if(diff < right_diff) {\\n                    right_diff = diff;\\n                    right_val = mid;\\n                }\\n                r = mid-1;\\n            }\\n        }\\n        return (left_diff <= right_diff) ? left_val : right_val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findSum(vector<int> &arr, int val) {\\n        long long sum = 0;\\n        for(auto &x: arr) sum += min(x, val);\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l =0, r = *max_element(arr.begin(), arr.end());\\n        int left_diff = INT_MAX, right_diff = INT_MAX;\\n        int left_val, right_val;\\n        while(l<=r) {\\n            int mid = (l+r)/2;\\n            \\n            long long sum = findSum(arr, mid);\\n            long long diff = abs(target - sum);\\n            \\n            if(sum < target) {\\n                if(diff < left_diff) {\\n                    left_diff = diff;\\n                    left_val = mid;\\n                }\\n                l = mid+1;\\n            } else {\\n                if(diff < right_diff) {\\n                    right_diff = diff;\\n                    right_val = mid;\\n                }\\n                r = mid-1;\\n            }\\n        }\\n        return (left_diff <= right_diff) ? left_val : right_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194750,
                "title": "c-binary-search-sorting-easy",
                "content": "# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint Sum(vector<int>& arr, int n, int val)\\n{\\n    int s = 0;\\n    for(int i=0 ;i<n ;i++)\\n    s+= min(arr[i],val);\\n    return s;\\n}\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        sort(arr.begin() , arr.end());\\n        int n = arr.size(), mn = INT_MAX, ans = 0;\\n\\n        int sum = 0;\\n        for(int i=0 ;i<n;i++)\\n        sum+=arr[i];\\n        if(sum<=target)\\n        return arr[n-1];\\n\\n        int s = 0 , e = target;\\n        int mid = s+(e-s)/2;\\n\\n        while(s<e)\\n        {\\n            int sm1 = Sum(arr, n, mid);\\n            int sm2 = Sum(arr, n, mid+1);\\n            if(abs(target-sm1) <= abs(target-sm2))\\n            e = mid;\\n            else \\n            s = mid+1;\\n            mid = s+(e-s)/2;\\n        }\\n        return mid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint Sum(vector<int>& arr, int n, int val)\\n{\\n    int s = 0;\\n    for(int i=0 ;i<n ;i++)\\n    s+= min(arr[i],val);\\n    return s;\\n}\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        sort(arr.begin() , arr.end());\\n        int n = arr.size(), mn = INT_MAX, ans = 0;\\n\\n        int sum = 0;\\n        for(int i=0 ;i<n;i++)\\n        sum+=arr[i];\\n        if(sum<=target)\\n        return arr[n-1];\\n\\n        int s = 0 , e = target;\\n        int mid = s+(e-s)/2;\\n\\n        while(s<e)\\n        {\\n            int sm1 = Sum(arr, n, mid);\\n            int sm2 = Sum(arr, n, mid+1);\\n            if(abs(target-sm1) <= abs(target-sm2))\\n            e = mid;\\n            else \\n            s = mid+1;\\n            mid = s+(e-s)/2;\\n        }\\n        return mid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190008,
                "title": "easy-c-o-nlogn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int k=0;\\n        int currSum=0;\\n        int len=arr.size();\\n        int j=arr[len-1];\\n        int minDiff=INT_MAX;\\n        int ans=-1;\\n        for(int i=0;i<=j;i++)\\n        {\\n            while(k<len && arr[k]==i){\\n                currSum+=arr[k];\\n                k++;\\n            }\\n            int curr=currSum+(len-k)*i;\\n            if(abs(target-curr)<minDiff)\\n            {\\n                minDiff=abs(target-curr);\\n                ans=i;\\n            }\\n                        \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int k=0;\\n        int currSum=0;\\n        int len=arr.size();\\n        int j=arr[len-1];\\n        int minDiff=INT_MAX;\\n        int ans=-1;\\n        for(int i=0;i<=j;i++)\\n        {\\n            while(k<len && arr[k]==i){\\n                currSum+=arr[k];\\n                k++;\\n            }\\n            int curr=currSum+(len-k)*i;\\n            if(abs(target-curr)<minDiff)\\n            {\\n                minDiff=abs(target-curr);\\n                ans=i;\\n            }\\n                        \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155973,
                "title": "binary-search-prefix-sum-sorting-python-solution-readable-code",
                "content": "# Complexity\\n- Time complexity: O(nlog(n)) + O(log(n) * log(k))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        diff_min = (inf, inf)\\n        n = len(arr)\\n        psum = list(itertools.accumulate(arr)) + [0]\\n\\n        left, right = 0 , max(arr)\\n        while left <= right:\\n            mid = (left + right)//2\\n            mid_ind_in_arr = bisect.bisect_left(arr, mid)\\n\\n            \\n            sum_till_mid = psum[mid_ind_in_arr - 1] \\n            right_sum = (n - mid_ind_in_arr) * mid\\n            total = right_sum + sum_till_mid\\n            diff = total - target\\n            \\n            diff_min = min(diff_min, (abs(diff),mid))\\n            if total >= target:\\n                right =  mid -1\\n            else:\\n                left = mid + 1\\n        \\n        return diff_min[1]\\n\\n        \\n       \\n\\n       \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        diff_min = (inf, inf)\\n        n = len(arr)\\n        psum = list(itertools.accumulate(arr)) + [0]\\n\\n        left, right = 0 , max(arr)\\n        while left <= right:\\n            mid = (left + right)//2\\n            mid_ind_in_arr = bisect.bisect_left(arr, mid)\\n\\n            \\n            sum_till_mid = psum[mid_ind_in_arr - 1] \\n            right_sum = (n - mid_ind_in_arr) * mid\\n            total = right_sum + sum_till_mid\\n            diff = total - target\\n            \\n            diff_min = min(diff_min, (abs(diff),mid))\\n            if total >= target:\\n                right =  mid -1\\n            else:\\n                left = mid + 1\\n        \\n        return diff_min[1]\\n\\n        \\n       \\n\\n       \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130533,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l=0,r=*max_element(arr.begin(), arr.end()),sum=accumulate(arr.begin(), arr.end(), 0);\\n        if(sum<=target){\\n            return r;\\n        }    \\n        while(l<r){\\n            int mid=l+(r-l)/2;\\n            int csum=0;\\n            for(auto i:arr){\\n                csum+=(i>mid)?mid:i;\\n            }\\n            if(csum>=target){\\n                r=mid;\\n            } else {\\n                l=mid+1;\\n            }\\n        }\\n        sum=0;\\n        for(auto i:arr){\\n            sum+=(i>l)?l:i;\\n        }\\n        int csum=0;\\n        for(auto i:arr){\\n            csum+=(i>(l-1))?(l-1):i;\\n        }\\n        if(abs(csum-target)<=abs(sum-target)){\\n            return l-1;\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        curr_sum = 0\\n        n = len(arr)\\n        for i, num in enumerate(arr):\\n            if num*(n-i)+curr_sum > target:\\n                return ceil((target-curr_sum)/(n-i) - 0.5)\\n            curr_sum += num\\n        return arr[-1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int arrSum = 0;\\n        for(int num: arr) {\\n            arrSum += num;\\n        }\\n        return binarySearch(0, target, arr, target, arrSum);\\n    }\\n\\n    private int getSum(int[] arr, int num) {\\n        int sum = 0;\\n        for(int curr: arr) {\\n            sum += Math.min(curr, num);\\n        }\\n        return sum;\\n    }\\n\\n    private int binarySearch(int begin, int end, int[] arr, int target, int arrSum) {\\n        if(begin == end) {\\n            return begin;\\n        }\\n        if(end == begin + 1) {\\n            int endSum = getSum(arr, end);\\n            int beginSum = getSum(arr, begin);\\n            if(Math.abs(target - beginSum) <= Math.abs(target - endSum)) {\\n                return begin;\\n            }\\n            return end;\\n        }\\n        int medium = begin + (end - begin) / 2;\\n        int mediumSum = getSum(arr, medium);\\n        if(mediumSum >= target || mediumSum == arrSum) {\\n            return binarySearch(begin, medium, arr, target, arrSum);\\n        }\\n        return binarySearch(medium, end, arr, target, arrSum);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l=0,r=*max_element(arr.begin(), arr.end()),sum=accumulate(arr.begin(), arr.end(), 0);\\n        if(sum<=target){\\n            return r;\\n        }    \\n        while(l<r){\\n            int mid=l+(r-l)/2;\\n            int csum=0;\\n            for(auto i:arr){\\n                csum+=(i>mid)?mid:i;\\n            }\\n            if(csum>=target){\\n                r=mid;\\n            } else {\\n                l=mid+1;\\n            }\\n        }\\n        sum=0;\\n        for(auto i:arr){\\n            sum+=(i>l)?l:i;\\n        }\\n        int csum=0;\\n        for(auto i:arr){\\n            csum+=(i>(l-1))?(l-1):i;\\n        }\\n        if(abs(csum-target)<=abs(sum-target)){\\n            return l-1;\\n        }\\n        return l;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        curr_sum = 0\\n        n = len(arr)\\n        for i, num in enumerate(arr):\\n            if num*(n-i)+curr_sum > target:\\n                return ceil((target-curr_sum)/(n-i) - 0.5)\\n            curr_sum += num\\n        return arr[-1]\\n```\n```Java []\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int arrSum = 0;\\n        for(int num: arr) {\\n            arrSum += num;\\n        }\\n        return binarySearch(0, target, arr, target, arrSum);\\n    }\\n\\n    private int getSum(int[] arr, int num) {\\n        int sum = 0;\\n        for(int curr: arr) {\\n            sum += Math.min(curr, num);\\n        }\\n        return sum;\\n    }\\n\\n    private int binarySearch(int begin, int end, int[] arr, int target, int arrSum) {\\n        if(begin == end) {\\n            return begin;\\n        }\\n        if(end == begin + 1) {\\n            int endSum = getSum(arr, end);\\n            int beginSum = getSum(arr, begin);\\n            if(Math.abs(target - beginSum) <= Math.abs(target - endSum)) {\\n                return begin;\\n            }\\n            return end;\\n        }\\n        int medium = begin + (end - begin) / 2;\\n        int mediumSum = getSum(arr, medium);\\n        if(mediumSum >= target || mediumSum == arrSum) {\\n            return binarySearch(begin, medium, arr, target, arrSum);\\n        }\\n        return binarySearch(medium, end, arr, target, arrSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123038,
                "title": "python-binary-search-on-values-beats-97-runtimes-96-in-space",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def bs(self, nums, target, left = None, right = None):\\n        if left is None or right is None:\\n            left, right = 0, len(nums)\\n        while left< right:\\n            mid = (left+right)//2\\n            if nums[mid] < target: left = mid+1\\n            else: right = mid \\n        return left\\n    def findBestValue(self, arr, target):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums = sorted(arr)\\n        mem = [0]*len(nums)\\n        prefix_sum = [0]*len(nums)\\n        prefix_sum[0] = 0\\n        for i in range(1,len(nums)):\\n            prefix_sum[i] = prefix_sum[i-1]+ nums[i-1]\\n\\n        left = 0 \\n        right = max(arr)\\n        res = [right,float(\\'inf\\')]\\n        while left <= right:\\n            mid = (left+right)//2\\n            curr_sum = 0\\n            index = self.bs(nums,mid)\\n            \\n            if index == 0: curr_sum = len(nums)*mid\\n            if index == len(nums): curr_sum = prefix_sum[-1] + nums[-1]\\n            else: curr_sum = prefix_sum[index]+ (len(nums)-index)* mid\\n\\n            curr_res = abs(curr_sum - target)\\n            if curr_res<res[1]:\\n                res = [mid,curr_res]\\n            if curr_res == res[1]:\\n                res[0] = min(res[0],mid)\\n            if curr_sum>=target:\\n                right = mid-1\\n            else: left = mid+1\\n        return res[0]\\n        \\n\\n\\n        \\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def bs(self, nums, target, left = None, right = None):\\n        if left is None or right is None:\\n            left, right = 0, len(nums)\\n        while left< right:\\n            mid = (left+right)//2\\n            if nums[mid] < target: left = mid+1\\n            else: right = mid \\n        return left\\n    def findBestValue(self, arr, target):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums = sorted(arr)\\n        mem = [0]*len(nums)\\n        prefix_sum = [0]*len(nums)\\n        prefix_sum[0] = 0\\n        for i in range(1,len(nums)):\\n            prefix_sum[i] = prefix_sum[i-1]+ nums[i-1]\\n\\n        left = 0 \\n        right = max(arr)\\n        res = [right,float(\\'inf\\')]\\n        while left <= right:\\n            mid = (left+right)//2\\n            curr_sum = 0\\n            index = self.bs(nums,mid)\\n            \\n            if index == 0: curr_sum = len(nums)*mid\\n            if index == len(nums): curr_sum = prefix_sum[-1] + nums[-1]\\n            else: curr_sum = prefix_sum[index]+ (len(nums)-index)* mid\\n\\n            curr_res = abs(curr_sum - target)\\n            if curr_res<res[1]:\\n                res = [mid,curr_res]\\n            if curr_res == res[1]:\\n                res[0] = min(res[0],mid)\\n            if curr_sum>=target:\\n                right = mid-1\\n            else: left = mid+1\\n        return res[0]\\n        \\n\\n\\n        \\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111422,
                "title": "c-brute-force-with-speed-up-22ms",
                "content": "# Intuition\\nSort arr and try value[0, target]. If found the closest value, break out of the loop (the speed up). \\n\\n# Approach\\nFor the speedup part, we maintain a bool \\'smaller\\' initilized to true meaning the current sum is smaller than target. If we found the turning point (i.e. curr sum > target), meaning we have seen the value that\\'s cloest to target (because curr sum will only get bigger as we procedd), thus we stop looping. \\n\\n# Complexity\\n- Time complexity:\\nO(target * len(arr)) worst case\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int ret =0;\\n        int diff =INT_MAX;\\n        bool smaller = true;\\n\\n        sort(arr.begin(), arr.end());\\n\\n        for(int i=0; i<=target; i++){\\n            int sum=0;\\n            for(auto num:arr){\\n                if(num>i) sum+=i;\\n                else sum+=num;\\n            }\\n            if(abs(sum-target) < diff){\\n                diff = abs(sum-target);\\n                ret = i;\\n            }\\n            if(sum < target) smaller = true;\\n            else if(smaller && sum>=target) break;\\n        }\\n        return ret;\\n    }\\n};\\n/*\\nsort \\n{3,4,9}\\ntarget = 10\\n\\nbrute force:\\n1-10\\n1: 1+1+1\\n2: 2+2+2\\n3: 3+3+3=9 -> curr<target \\n4: 3+4+4=11 -> curr>target: turning point! result must be either 3 or 4.\\n5: 3+4+5=12\\n6: 3+4+6=13\\n\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int ret =0;\\n        int diff =INT_MAX;\\n        bool smaller = true;\\n\\n        sort(arr.begin(), arr.end());\\n\\n        for(int i=0; i<=target; i++){\\n            int sum=0;\\n            for(auto num:arr){\\n                if(num>i) sum+=i;\\n                else sum+=num;\\n            }\\n            if(abs(sum-target) < diff){\\n                diff = abs(sum-target);\\n                ret = i;\\n            }\\n            if(sum < target) smaller = true;\\n            else if(smaller && sum>=target) break;\\n        }\\n        return ret;\\n    }\\n};\\n/*\\nsort \\n{3,4,9}\\ntarget = 10\\n\\nbrute force:\\n1-10\\n1: 1+1+1\\n2: 2+2+2\\n3: 3+3+3=9 -> curr<target \\n4: 3+4+4=11 -> curr>target: turning point! result must be either 3 or 4.\\n5: 3+4+5=12\\n6: 3+4+6=13\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111420,
                "title": "c-brute-force-with-speed-up-22ms",
                "content": "# Intuition\\nSort arr and try value[0, target]. If found the closest value, break out of the loop (the speed up). \\n\\n# Approach\\nFor the speedup part, we maintain a bool \\'smaller\\' initilized to true meaning the current sum is smaller than target. If we found the turning point (i.e. curr sum > target), meaning we have seen the value that\\'s cloest to target (because curr sum will only get bigger as we procedd), thus we stop looping. \\n\\n# Complexity\\n- Time complexity:\\nO(target * len(arr)) worst case\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int ret =0;\\n        int diff =INT_MAX;\\n        bool smaller = true;\\n\\n        sort(arr.begin(), arr.end());\\n\\n        for(int i=0; i<=target; i++){\\n            int sum=0;\\n            for(auto num:arr){\\n                if(num>i) sum+=i;\\n                else sum+=num;\\n            }\\n            if(abs(sum-target) < diff){\\n                diff = abs(sum-target);\\n                ret = i;\\n            }\\n            if(sum < target) smaller = true;\\n            else if(smaller && sum>=target) break;\\n        }\\n        return ret;\\n    }\\n};\\n/*\\nsort \\n{3,4,9}\\ntarget = 10\\n\\nbrute force:\\n1-10\\n1: 1+1+1\\n2: 2+2+2\\n3: 3+3+3=9 -> curr<target \\n4: 3+4+4=11 -> curr>target: turning point! result must be either 3 or 4.\\n5: 3+4+5=12\\n6: 3+4+6=13\\n\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int ret =0;\\n        int diff =INT_MAX;\\n        bool smaller = true;\\n\\n        sort(arr.begin(), arr.end());\\n\\n        for(int i=0; i<=target; i++){\\n            int sum=0;\\n            for(auto num:arr){\\n                if(num>i) sum+=i;\\n                else sum+=num;\\n            }\\n            if(abs(sum-target) < diff){\\n                diff = abs(sum-target);\\n                ret = i;\\n            }\\n            if(sum < target) smaller = true;\\n            else if(smaller && sum>=target) break;\\n        }\\n        return ret;\\n    }\\n};\\n/*\\nsort \\n{3,4,9}\\ntarget = 10\\n\\nbrute force:\\n1-10\\n1: 1+1+1\\n2: 2+2+2\\n3: 3+3+3=9 -> curr<target \\n4: 3+4+4=11 -> curr>target: turning point! result must be either 3 or 4.\\n5: 3+4+5=12\\n6: 3+4+6=13\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080079,
                "title": "c-sorting-prefix-sum-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int tar) {\\n        sort(arr.begin(),arr.end());\\n        int tsum=0;\\n        int n = arr.size();\\n        for(auto i:arr)\\n        tsum+=i;\\n        vector<int> pref(n);\\n        pref[0] = arr[0];\\n        for(int i=1;i<n;i++)\\n        pref[i] = pref[i-1]+arr[i];\\n        int l = 0,r = arr[n-1];\\n        int ans=INT_MAX;\\n        int fans=0;\\n        for(int i=l;i<=r;i++)\\n        {\\n            int idx = upper_bound(arr.begin(),arr.end(),i)-arr.begin();\\n            if(idx==n)\\n            {\\n                if(tsum>tar)\\n                {\\n                    if(ans>tsum-tar)\\n                    {\\n                        ans = tsum-tar;\\n                        fans = i;\\n                    }\\n                }\\n                else\\n                {\\n                    if(ans>tar-tsum)\\n                    {\\n                        ans = tar-tsum;\\n                        fans = i;\\n                    }\\n                }\\n            }\\n            else if(idx==0)\\n            {\\n                int tmpsum = n*i;\\n                if(tmpsum>tar)\\n                {\\n                    if(ans>tmpsum-tar)\\n                    {\\n                        ans = tmpsum-tar;\\n                        fans = i;\\n                    }\\n                }\\n                else\\n                {\\n                    if(ans>tar-tmpsum)\\n                    {\\n                        ans = tar-tmpsum;\\n                        fans = i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                int tmp = pref[n-1]-pref[idx-1];\\n                int tmpsum = tsum-tmp;\\n                tmpsum+=(n-idx)*i;\\n                if(tmpsum>tar)\\n                {\\n                    if(ans>tmpsum-tar)\\n                    {\\n                        ans = tmpsum-tar;\\n                        fans = i;\\n                    }\\n                }\\n                else\\n                {\\n                    if(ans>tar-tmpsum)\\n                    {\\n                        ans = tar-tmpsum;\\n                        fans = i;\\n                    }\\n                }\\n            }\\n        }\\n        return fans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int tar) {\\n        sort(arr.begin(),arr.end());\\n        int tsum=0;\\n        int n = arr.size();\\n        for(auto i:arr)\\n        tsum+=i;\\n        vector<int> pref(n);\\n        pref[0] = arr[0];\\n        for(int i=1;i<n;i++)\\n        pref[i] = pref[i-1]+arr[i];\\n        int l = 0,r = arr[n-1];\\n        int ans=INT_MAX;\\n        int fans=0;\\n        for(int i=l;i<=r;i++)\\n        {\\n            int idx = upper_bound(arr.begin(),arr.end(),i)-arr.begin();\\n            if(idx==n)\\n            {\\n                if(tsum>tar)\\n                {\\n                    if(ans>tsum-tar)\\n                    {\\n                        ans = tsum-tar;\\n                        fans = i;\\n                    }\\n                }\\n                else\\n                {\\n                    if(ans>tar-tsum)\\n                    {\\n                        ans = tar-tsum;\\n                        fans = i;\\n                    }\\n                }\\n            }\\n            else if(idx==0)\\n            {\\n                int tmpsum = n*i;\\n                if(tmpsum>tar)\\n                {\\n                    if(ans>tmpsum-tar)\\n                    {\\n                        ans = tmpsum-tar;\\n                        fans = i;\\n                    }\\n                }\\n                else\\n                {\\n                    if(ans>tar-tmpsum)\\n                    {\\n                        ans = tar-tmpsum;\\n                        fans = i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                int tmp = pref[n-1]-pref[idx-1];\\n                int tmpsum = tsum-tmp;\\n                tmpsum+=(n-idx)*i;\\n                if(tmpsum>tar)\\n                {\\n                    if(ans>tmpsum-tar)\\n                    {\\n                        ans = tmpsum-tar;\\n                        fans = i;\\n                    }\\n                }\\n                else\\n                {\\n                    if(ans>tar-tmpsum)\\n                    {\\n                        ans = tar-tmpsum;\\n                        fans = i;\\n                    }\\n                }\\n            }\\n        }\\n        return fans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078385,
                "title": "python-solution-beats-99-with-explanation-and-complexities",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The problem is asking to find the value that minimizes the absolute difference between the sum of elements in the array that are less or equal to that value, and the given target value.\\n- The first thought would be to iterate through all possible values and check the absolute difference for each one, and return the value that results in the minimum difference.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The approach used in the provided code is a binary search algorithm.\\n- It starts by sorting the array, and then using bisect_right to find the index of the first element that is greater than the mid value.\\n- Then it calculates the sum of elements in the array that are less than or equal to the mid value and the difference between that sum and the target.\\n- It compares this difference with the previous minimum difference and updates the result if necessary.\\n- The process is repeated until the left pointer is greater than the right pointer.\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nas the bisect.bisect_right has logarithmic time complexity and it is called n times in the while loop.\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nas it uses only a few variables and the algorithm is in-place.\\n# Code\\n```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        n = len(arr)\\n        diff = float(\\'inf\\')\\n        res = -1\\n        l = 0\\n        r = arr[-1]\\n        while l <= r:\\n            mid = l + (r - l) // 2\\n            idx = bisect.bisect_right(arr, mid)\\n            sum1 = sum(arr[:idx]) + ((n - idx) * mid)\\n            \\n            if sum1 < target:\\n                l = mid + 1\\n            elif sum1 >= target:\\n                r = mid - 1\\n                \\n            d = abs(sum1 - target)\\n            if d < diff or (d == diff and mid < res):\\n                diff = d\\n                res = mid\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        n = len(arr)\\n        diff = float(\\'inf\\')\\n        res = -1\\n        l = 0\\n        r = arr[-1]\\n        while l <= r:\\n            mid = l + (r - l) // 2\\n            idx = bisect.bisect_right(arr, mid)\\n            sum1 = sum(arr[:idx]) + ((n - idx) * mid)\\n            \\n            if sum1 < target:\\n                l = mid + 1\\n            elif sum1 >= target:\\n                r = mid - 1\\n                \\n            d = abs(sum1 - target)\\n            if d < diff or (d == diff and mid < res):\\n                diff = d\\n                res = mid\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069859,
                "title": "my-thoughts-for-this-question-in-binary-search",
                "content": "\\n# Intuition\\nFinding value one by one untill I find sum of modified array is as closest as target seems to be a costly affair.\\n\\nBut think like this \\nvalue \\u221D currSum that means monotonic\\n\\n# Terminology:\\nvalue,target,arr -> explained in question\\ns -> start index\\ne -> end index\\nmaxm -> maximum value possible\\nmid -> value considered as of now to calculate currSum\\ncurrSum -> current sum of the array for current mid\\n\\n# Approach\\nnow when we have to replace all that are greater so in the array\\n[2, 3, 5] going to 6, does it make sense?\\n\\nnow our answer must lie in 0 to maximum of the array, as value is replacing all that is greater in the array.\\n\\nFind mid from 0 to maximumElement and check of nearest possible from target.\\n\\nif I get currSum < target -> increase currSum by s = mid+1 & vice versa.\\n\\nAt last only competitor is s and s - 1 -> check them seperatly.\\n\\n# Complexity\\n- Time complexity: $$O(nlog(maxmEle))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNote: I am solving january daily leetcode challange\\'23, every day on my youtube channel. link: https://www.youtube.com/@hemantranjan2297/videos\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sum(vector<int>&a,int m){\\n        int sum = 0;\\n        for(auto ele:a){\\n            if(ele>m){\\n                sum += m;\\n            }else sum += ele;\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        int n =arr.size(), maxm =-1;\\n        //finding max in array\\n        for(int i =0;i<n;i++){\\n            maxm = max(maxm,arr[i]);\\n        }\\n        \\n        //the momnet I thought value is directly proportion \\n        //to currSum and that\\'s a monotnous relation\\n        so value must be found via binary search\\n        */\\n        int s = 0, e = maxm;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            int currSum = sum(arr,mid);//curr sum for current value if taken.\\n            if(currSum == target)return mid;//if(currSum == target) that is nearest, so return that value\\n            else if(currSum>target) e = mid-1;//if(currSum > target) then reduse value to get smaller currSum\\n            else s = mid+1; // at last value should increase to currSum\\n        }\\n        if(abs(target-sum(arr,s-1))>abs(target-sum(arr,s)))return s;\\n        return s-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum(vector<int>&a,int m){\\n        int sum = 0;\\n        for(auto ele:a){\\n            if(ele>m){\\n                sum += m;\\n            }else sum += ele;\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        int n =arr.size(), maxm =-1;\\n        //finding max in array\\n        for(int i =0;i<n;i++){\\n            maxm = max(maxm,arr[i]);\\n        }\\n        \\n        //the momnet I thought value is directly proportion \\n        //to currSum and that\\'s a monotnous relation\\n        so value must be found via binary search\\n        */\\n        int s = 0, e = maxm;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            int currSum = sum(arr,mid);//curr sum for current value if taken.\\n            if(currSum == target)return mid;//if(currSum == target) that is nearest, so return that value\\n            else if(currSum>target) e = mid-1;//if(currSum > target) then reduse value to get smaller currSum\\n            else s = mid+1; // at last value should increase to currSum\\n        }\\n        if(abs(target-sum(arr,s-1))>abs(target-sum(arr,s)))return s;\\n        return s-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045656,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&arr,int &mid)\\n    {\\n        int sum=0;\\n        for (int i=0;i<arr.size();i++)\\n        {\\n            if (arr[i]>mid)\\n            sum+=mid;\\n            else sum+=arr[i];\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) \\n    {\\n        int mini;\\n        int sum=0;\\n        int ans=INT_MIN;\\n        for (int i=0;i<arr.size();i++)\\n        {\\n            sum+=arr[i];\\n            ans=max(ans,arr[i]);\\n        }\\n        //cout<<sum;\\n        mini=abs(sum-target);\\n        int low=0;\\n        int high=target;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int val=helper(arr,mid);\\n            if (val>=target)\\n           {\\n               high=mid-1;\\n           }\\n           else\\n           {\\n               low=mid+1;\\n           }\\n           if (mini>abs(target-val))\\n           {\\n           ans=mid;\\n           mini=abs(target-val);\\n           }\\n           if (mini==abs(target-val) && mid<ans) // so that we get   minimum value \\n           ans=mid;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&arr,int &mid)\\n    {\\n        int sum=0;\\n        for (int i=0;i<arr.size();i++)\\n        {\\n            if (arr[i]>mid)\\n            sum+=mid;\\n            else sum+=arr[i];\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) \\n    {\\n        int mini;\\n        int sum=0;\\n        int ans=INT_MIN;\\n        for (int i=0;i<arr.size();i++)\\n        {\\n            sum+=arr[i];\\n            ans=max(ans,arr[i]);\\n        }\\n        //cout<<sum;\\n        mini=abs(sum-target);\\n        int low=0;\\n        int high=target;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int val=helper(arr,mid);\\n            if (val>=target)\\n           {\\n               high=mid-1;\\n           }\\n           else\\n           {\\n               low=mid+1;\\n           }\\n           if (mini>abs(target-val))\\n           {\\n           ans=mid;\\n           mini=abs(target-val);\\n           }\\n           if (mini==abs(target-val) && mid<ans) // so that we get   minimum value \\n           ans=mid;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3032284,
                "title": "binary-search-solution-with-intuition-c-beats-99-69",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe answer will lie on the range L = 1 to R = (max element of the array).\\nSo, we will apply binary search on this range taking mid as the ```\\nvalue```.\\n\\nOur predicate function will check if the difference = ```target``` - (sum of the elements of the array after replacing all the values with mid if mid<arr[i]) is positive or negative. If the difference is equal to zero, we will return the mid as it is the best possible answer.\\n\\nThis will finally divide the array into two parts:\\n```\\n// Initially\\nL                                                            R\\nv                                                            v\\n[      predicate==false      ] [       predicate==true       ]\\n\\n// Finally\\n                             R L                                \\n                             v v                               \\n[      predicate==false      ] [       predicate==true       ]\\n```\\nFinally, we need to check if the value at R or L is the best possible answer. If a tie occurs, we need to return R(minimum answer).\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int predicate(vector<int>& arr, int target, int m){\\n        int sum=0;\\n        for(auto i:arr){\\n            if(i>m) sum+=m;\\n            else sum+=i;\\n        }\\n        return sum - target;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l=1,r=INT_MIN;\\n        for(auto i:arr) r=max(r,i);\\n        while(l<=r){\\n            int m = l + (r-l)/2;\\n            if(predicate(arr,target,m)>0) r=m-1; \\n            else if(predicate(arr,target,m)==0) return m; //Return this mid as this is the best possible answer.\\n            else l=m+1;\\n        }\\n        int sum_l=0;\\n        int sum_r=0;\\n        for(auto i:arr){\\n            if(i>l) sum_l+=l;\\n            else sum_l+=i;\\n            if(i>r) sum_r+=r;\\n            else sum_r+=i;\\n        }\\n        if(abs(target-sum_l)>=abs(target-sum_r) ) return r;\\n        else return l;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvalue```\n```target```\n```\\n// Initially\\nL                                                            R\\nv                                                            v\\n[      predicate==false      ] [       predicate==true       ]\\n\\n// Finally\\n                             R L                                \\n                             v v                               \\n[      predicate==false      ] [       predicate==true       ]\\n```\n```\\nclass Solution {\\npublic:\\n    int predicate(vector<int>& arr, int target, int m){\\n        int sum=0;\\n        for(auto i:arr){\\n            if(i>m) sum+=m;\\n            else sum+=i;\\n        }\\n        return sum - target;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l=1,r=INT_MIN;\\n        for(auto i:arr) r=max(r,i);\\n        while(l<=r){\\n            int m = l + (r-l)/2;\\n            if(predicate(arr,target,m)>0) r=m-1; \\n            else if(predicate(arr,target,m)==0) return m; //Return this mid as this is the best possible answer.\\n            else l=m+1;\\n        }\\n        int sum_l=0;\\n        int sum_r=0;\\n        for(auto i:arr){\\n            if(i>l) sum_l+=l;\\n            else sum_l+=i;\\n            if(i>r) sum_r+=r;\\n            else sum_r+=i;\\n        }\\n        if(abs(target-sum_l)>=abs(target-sum_r) ) return r;\\n        else return l;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002758,
                "title": "python-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        def count(num):\\n            res = 0\\n            for i in range(len(arr)):res += min(num,arr[i])\\n            return res\\n\\n        l = 0\\n        r = target\\n        last_m = float(\"inf\")\\n        min_diff = float(\"inf\")\\n        res = 0\\n\\n        while l <= r:\\n            m = int((l+r)/2)\\n            diff = target-count(m)\\n            \\n            if diff > 0:\\n                l = m+1\\n            elif diff < 0:\\n                r = m-1\\n                \\n            if abs(diff) < min_diff:\\n                res = m\\n                min_diff = abs(diff)\\n            elif abs(diff) == min_diff:\\n                if m > res:res = m\\n                \\n            if last_m == m: break\\n            last_m = m\\n        \\n        cur = res\\n        while True:\\n            cur -=1\\n            diff = target-count(cur)\\n            if abs(diff) <= min_diff:\\n                min_diff = abs(diff)\\n                res = cur\\n            else:break\\n            \\n        cur = res\\n        while True:\\n            cur +=1\\n            diff = target-count(cur)\\n            if abs(diff) < min_diff:\\n                min_diff = abs(diff)\\n                res = cur\\n            else:break\\n        \\n        return res\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        def count(num):\\n            res = 0\\n            for i in range(len(arr)):res += min(num,arr[i])\\n            return res\\n\\n        l = 0\\n        r = target\\n        last_m = float(\"inf\")\\n        min_diff = float(\"inf\")\\n        res = 0\\n\\n        while l <= r:\\n            m = int((l+r)/2)\\n            diff = target-count(m)\\n            \\n            if diff > 0:\\n                l = m+1\\n            elif diff < 0:\\n                r = m-1\\n                \\n            if abs(diff) < min_diff:\\n                res = m\\n                min_diff = abs(diff)\\n            elif abs(diff) == min_diff:\\n                if m > res:res = m\\n                \\n            if last_m == m: break\\n            last_m = m\\n        \\n        cur = res\\n        while True:\\n            cur -=1\\n            diff = target-count(cur)\\n            if abs(diff) <= min_diff:\\n                min_diff = abs(diff)\\n                res = cur\\n            else:break\\n            \\n        cur = res\\n        while True:\\n            cur +=1\\n            diff = target-count(cur)\\n            if abs(diff) < min_diff:\\n                min_diff = abs(diff)\\n                res = cur\\n            else:break\\n        \\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969866,
                "title": "bs",
                "content": "**Linearithmic time / range binary search**\\n**time: `O(N log R)`; space: `O(1)`**\\n\\n![image](https://assets.leetcode.com/users/images/19f95818-d839-4568-b1e3-ae4656ebe55e_1672411558.8841085.png)\\n\\n![image](https://assets.leetcode.com/users/images/1c96edbe-68f3-4e47-8a08-c6733bba9f0b_1672411937.3978314.png)\\n\\n```\\nint findBestValue(vector<int>& aa, int t)\\n{\\n\\tint l{};\\n\\tfor(int h{100001}; l+1<h; )\\n\\t{\\n\\t\\tint m=(l+h)/2;\\n\\t\\tint x{}, y{};\\n\\t\\tfor(const auto & a : aa) x+=min(a,m-1), y+=min(a,m); \\n\\t\\t(abs(t-y)<abs(t-x) ? l : h) = m;\\n\\t}\\n\\treturn l;  \\n}\\n```\\n||\\n```\\nint findBestValue(vector<int>& a, int t)\\n{\\n\\tint l{};\\n    const int & (*_min)(const int &, const int &) = min<int>; // c++ facepalm\\n\\tauto f = [&](int x){ return abs(t-transform_reduce(begin(a), end(a), 0, plus{}, bind(_min, placeholders::_1, x))); };\\n\\tfor(int h{100001}; l+1<h; )\\n\\t{\\n\\t\\tint m=(l+h)/2;\\n\\t\\t(f(m)<f(m-1) ? l : h) = m;\\n\\t}\\n\\treturn l;  \\n}\\n```\\n`c++ facepalm =` https://stackoverflow.com/questions/47109317/cant-pass-stdmin-to-function-copy-of-stdmin-works\\n\\n**Explanation:**\\nSuch problems follow the following scheme:\\n\\n![image](https://assets.leetcode.com/users/images/c975b436-a7d8-4ec0-a31d-503d0e666ea0_1672413842.145775.png)\\n\\n\\n**Similar problems:**\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/2053517/bs?currentPage=1&orderBy=most_relevant&query=android)\\n[1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/discuss/2963593/bs)\\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/discuss/2127417/binary-search)\\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/discuss/1676227/binary-search)\\n[1300. Sum of Mutated Array Closest to Target](https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/discuss/2969866/bs)\\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/discuss/3251398/ok)\\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/discuss/3251393/ok)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/3253585/bs)\\n[1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/3254564/bs)\\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/3807049/bs)\\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/discuss/3808940/bs)\\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/discuss/3945204/range-bs)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint findBestValue(vector<int>& aa, int t)\\n{\\n\\tint l{};\\n\\tfor(int h{100001}; l+1<h; )\\n\\t{\\n\\t\\tint m=(l+h)/2;\\n\\t\\tint x{}, y{};\\n\\t\\tfor(const auto & a : aa) x+=min(a,m-1), y+=min(a,m); \\n\\t\\t(abs(t-y)<abs(t-x) ? l : h) = m;\\n\\t}\\n\\treturn l;  \\n}\\n```\n```\\nint findBestValue(vector<int>& a, int t)\\n{\\n\\tint l{};\\n    const int & (*_min)(const int &, const int &) = min<int>; // c++ facepalm\\n\\tauto f = [&](int x){ return abs(t-transform_reduce(begin(a), end(a), 0, plus{}, bind(_min, placeholders::_1, x))); };\\n\\tfor(int h{100001}; l+1<h; )\\n\\t{\\n\\t\\tint m=(l+h)/2;\\n\\t\\t(f(m)<f(m-1) ? l : h) = m;\\n\\t}\\n\\treturn l;  \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2963091,
                "title": "python-binary-search-solution-faster-than-82-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDefine a lower limit ```left``` and upper limit ```right```, check if all numbers larger than ```mid = (left + right) / 2``` are changed to ```mid```, can we achieve a sum closer to target. Then adjust the ```mid``` according to if the given sum is bigger or smaller than ```target```. Update ```left``` and ```right``` by Binary Search logic\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        sm, ans = sum(arr), max(arr)\\n        diff, ideal = abs(sm - target), target // len(arr)\\n        if sm <= target:\\n            return ans\\n        left, right = ideal, ans\\n        while left <= right:\\n            mid, tempSum = (left + right) // 2, 0\\n            for num in arr:\\n                if num > mid: tempSum += mid\\n                else: tempSum += num\\n            if diff > abs(target - tempSum):\\n                ans, diff = mid, abs(target - tempSum)\\n            elif diff == abs(target - tempSum):\\n                ans = min(ans, mid)\\n            if tempSum >= target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```left```\n```right```\n```mid = (left + right) / 2```\n```mid```\n```mid```\n```target```\n```left```\n```right```\n```python []\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        sm, ans = sum(arr), max(arr)\\n        diff, ideal = abs(sm - target), target // len(arr)\\n        if sm <= target:\\n            return ans\\n        left, right = ideal, ans\\n        while left <= right:\\n            mid, tempSum = (left + right) // 2, 0\\n            for num in arr:\\n                if num > mid: tempSum += mid\\n                else: tempSum += num\\n            if diff > abs(target - tempSum):\\n                ans, diff = mid, abs(target - tempSum)\\n            elif diff == abs(target - tempSum):\\n                ans = min(ans, mid)\\n            if tempSum >= target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903564,
                "title": "ruby-with-binary-search",
                "content": "```ruby\\ndef find_best_value(arr, target)\\n  right = arr.max\\n  left = (1..right).bsearch { |mid| val_sum(arr, mid) >= target } || right\\n\\n  left_val_sum_diff = (val_sum(arr, left) - target).abs\\n  # left - 1 might have a difference smaller than left\\n  cand_val_sum_diff = (val_sum(arr, left - 1) - target).abs\\n   \\n  # if so, return left - 1 instead\\n  cand_val_sum_diff <= left_val_sum_diff ? left - 1 : left\\nend\\n\\ndef val_sum(arr, val)\\n  arr.map { |num| num > val ? val : num }.sum\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```ruby\\ndef find_best_value(arr, target)\\n  right = arr.max\\n  left = (1..right).bsearch { |mid| val_sum(arr, mid) >= target } || right\\n\\n  left_val_sum_diff = (val_sum(arr, left) - target).abs\\n  # left - 1 might have a difference smaller than left\\n  cand_val_sum_diff = (val_sum(arr, left - 1) - target).abs\\n   \\n  # if so, return left - 1 instead\\n  cand_val_sum_diff <= left_val_sum_diff ? left - 1 : left\\nend\\n\\ndef val_sum(arr, val)\\n  arr.map { |num| num > val ? val : num }.sum\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2863550,
                "title": "simple-solution-using-binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        // the idea is to decrease numbers so that we get sum near to target\\n        int ans = 0;\\n        int dif = 0;\\n        int sum = 0;\\n        for(int x: arr){ sum += x; ans = max(ans,x); }\\n        dif = abs(sum - target);\\n        if(sum <= target) return ans;\\n        int right = ans;\\n        int ideal = target/arr.size();\\n        int left = ideal;\\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            // cout<<mid<<endl;\\n            int lsum = 0;\\n            for(int x: arr){\\n                if(x > mid) lsum += mid;\\n                else lsum += x;\\n            }\\n            if(dif > abs(target - lsum)){ \\n                dif = abs(target - lsum);\\n                ans = mid;\\n            }\\n            if(dif == abs(target - lsum)) ans = min(ans,mid);\\n            if(lsum >= target){\\n                right = mid - 1;\\n            }else{\\n                \\n                left = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        // the idea is to decrease numbers so that we get sum near to target\\n        int ans = 0;\\n        int dif = 0;\\n        int sum = 0;\\n        for(int x: arr){ sum += x; ans = max(ans,x); }\\n        dif = abs(sum - target);\\n        if(sum <= target) return ans;\\n        int right = ans;\\n        int ideal = target/arr.size();\\n        int left = ideal;\\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            // cout<<mid<<endl;\\n            int lsum = 0;\\n            for(int x: arr){\\n                if(x > mid) lsum += mid;\\n                else lsum += x;\\n            }\\n            if(dif > abs(target - lsum)){ \\n                dif = abs(target - lsum);\\n                ans = mid;\\n            }\\n            if(dif == abs(target - lsum)) ans = min(ans,mid);\\n            if(lsum >= target){\\n                right = mid - 1;\\n            }else{\\n                \\n                left = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2852386,
                "title": "binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n\\n        def getSum(arr, threshold):\\n            res = count = 0\\n            value = inf\\n            for n in arr:\\n                if n > threshold:\\n                    res += threshold\\n                else:\\n                    res += n\\n            return res\\n\\n        left, right = target // len(arr) - 1, max(arr)\\n        larger_dis = inf\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            val = getSum(arr, mid)\\n            if val >= target:\\n                right = mid\\n                larger_dis = val - target\\n            else:\\n                left  = mid + 1\\n        larger_val = right\\n\\n        left, right = target // len(arr) - 1, max(arr)\\n        smaller_dis = inf\\n        while left < right:\\n            mid = left + (right - left + 1) // 2\\n            val = getSum(arr, mid)\\n            if val <= target:\\n                left = mid\\n                smaller_dis = target - val\\n            else:\\n                right = mid - 1\\n        smaller_val = left\\n\\n        if larger_dis == smaller_dis:\\n            return min(smaller_val, larger_val)\\n        elif larger_dis < smaller_dis:\\n            return larger_val\\n        else:\\n            return smaller_val\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n\\n        def getSum(arr, threshold):\\n            res = count = 0\\n            value = inf\\n            for n in arr:\\n                if n > threshold:\\n                    res += threshold\\n                else:\\n                    res += n\\n            return res\\n\\n        left, right = target // len(arr) - 1, max(arr)\\n        larger_dis = inf\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            val = getSum(arr, mid)\\n            if val >= target:\\n                right = mid\\n                larger_dis = val - target\\n            else:\\n                left  = mid + 1\\n        larger_val = right\\n\\n        left, right = target // len(arr) - 1, max(arr)\\n        smaller_dis = inf\\n        while left < right:\\n            mid = left + (right - left + 1) // 2\\n            val = getSum(arr, mid)\\n            if val <= target:\\n                left = mid\\n                smaller_dis = target - val\\n            else:\\n                right = mid - 1\\n        smaller_val = left\\n\\n        if larger_dis == smaller_dis:\\n            return min(smaller_val, larger_val)\\n        elif larger_dis < smaller_dis:\\n            return larger_val\\n        else:\\n            return smaller_val\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825155,
                "title": "python3-sorting-binary-search",
                "content": "\\n```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr = sorted(arr)\\n        n = len(arr)\\n        suffixSum = [0 for i in range(n)]\\n        totalSum = 0\\n        for i in range(n-1,-1,-1):\\n            suffixSum[i] = suffixSum[i+1] + arr[i] if i < n-1 else arr[i]\\n            totalSum += arr[i]\\n        low,high = 0,max(arr)\\n        ans = math.inf\\n        diff = math.inf\\n        while low <= high:\\n            mid = (low+high)//2\\n            ind = bisect.bisect_right(arr,mid)\\n            currentSum = totalSum - suffixSum[ind] + (n-ind) * mid if ind < n else totalSum\\n            if currentSum >= target:\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n            if abs(currentSum - target) < diff:\\n                ans = mid\\n                diff = abs(currentSum - target)\\n            elif abs(currentSum - target) == diff:\\n                ans = min(mid,ans)\\n        return ans\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Suffix Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr = sorted(arr)\\n        n = len(arr)\\n        suffixSum = [0 for i in range(n)]\\n        totalSum = 0\\n        for i in range(n-1,-1,-1):\\n            suffixSum[i] = suffixSum[i+1] + arr[i] if i < n-1 else arr[i]\\n            totalSum += arr[i]\\n        low,high = 0,max(arr)\\n        ans = math.inf\\n        diff = math.inf\\n        while low <= high:\\n            mid = (low+high)//2\\n            ind = bisect.bisect_right(arr,mid)\\n            currentSum = totalSum - suffixSum[ind] + (n-ind) * mid if ind < n else totalSum\\n            if currentSum >= target:\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n            if abs(currentSum - target) < diff:\\n                ans = mid\\n                diff = abs(currentSum - target)\\n            elif abs(currentSum - target) == diff:\\n                ans = min(mid,ans)\\n        return ans\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814034,
                "title": "c-simple-binary-search-easy-to-understand",
                "content": "### *Upvote*\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr,int& target,int mid){\\n        int sum = 0;\\n        for(auto & it : arr){\\n            sum += min(it,mid);\\n        }\\n        return abs(sum - target);\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int diff = INT_MAX;\\n        int start = 0;\\n        int end = target;\\n        int ans = -1;\\n        while(start <= end){\\n            int mid = start + ((end - start) >> 1);\\n            if(solve(arr,target,mid) <= solve(arr,target,mid+1)){\\n                end = mid-1;\\n                ans = mid;\\n            }else{\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr,int& target,int mid){\\n        int sum = 0;\\n        for(auto & it : arr){\\n            sum += min(it,mid);\\n        }\\n        return abs(sum - target);\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int diff = INT_MAX;\\n        int start = 0;\\n        int end = target;\\n        int ans = -1;\\n        while(start <= end){\\n            int mid = start + ((end - start) >> 1);\\n            if(solve(arr,target,mid) <= solve(arr,target,mid+1)){\\n                end = mid-1;\\n                ans = mid;\\n            }else{\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786633,
                "title": "typescript-solution-commented",
                "content": "# Intuition\\nIt wasn\\'t very intuitive. It took me like an hour to end up with a solution. After 30mins of trying different techniques, I decided to evaluate this problem as a function to optimize because we have a target and a variable to find.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nI defined variables to formulate an objective function:\\n- m: variable that we are looking for\\n- changes: number of variables in the array that are bigger than \"m\"\\n- restSum: sum of the variables of the array that are less or equal to \"m\"\\n- target: target variable used to evaluate \"m\"\\n\\nObjective function: (changes * m) + restSum <= target\\n\\nIn each loop I calculate a new \"m\" to see if the number of changes available decreases or not. In case where the number of changes decrease, then I calculate a new \"m\" otherwise I procede to evaluate the end result of my equation.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ / $$O(n^2)$$\\n\\nThe loops to get the best \"m\" nevers gonna be equal to the length of the array so it cannot be O(n^2) but it can be close to it in the worst cases. If I\\'m wrong please let me know.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Results\\n- 132 ms / 44.6mb\\n\\n# Code\\n```\\nfunction findBestValue(arr: number[], target: number): number {\\n    // Using Least Common Multiple as basis\\n    let m = Math.floor(target/arr.length)\\n    let changes = 0\\n    \\n    while(true){\\n        // Define and clear variables\\n        let prevChanges = changes\\n        let restSum = 0\\n        let totalSum = 0\\n        changes = 0\\n\\n        // Calculate number of possible changes, restSum and totalSum\\n        for(let i = 0; i< arr.length; i++) {\\n            // if m > arr[i], means that arr[i] can be changed by m\\n            if(arr[i] > m) {\\n                changes++\\n            } else {\\n                // if cannot be changed, then I accumulate the number\\n                restSum += arr[i]\\n            }\\n            // totalSum is only used when there is only one change available\\n            totalSum += arr[i]\\n        }\\n\\n        // If there aren\\'t changes available return the biggest number of the array\\n        if(changes === 0) {\\n            return Math.max(...arr)\\n        }\\n\\n        // If there is only one change available\\n        if(changes === 1) {\\n            let x = target - restSum\\n            let y = totalSum - restSum\\n            if(x > y) return y\\n            return x\\n        }\\n\\n        // If the number of changes available is the same with the prevChanges, \\n        //then I it means that m is a candidate.\\n        if(prevChanges === changes) {\\n            // Because m is calculated with a division and I use only the integer, there is a \\n            // posibility that the value was closer to the next integer, so I try both cases.\\n            let result1 = Math.abs((m * changes) + restSum - target)\\n            let result2 = Math.abs(((m+1) * changes) + restSum - target)\\n\\n            return result2 >= result1 ? m : m + 1\\n        }\\n\\n        // update the value to minimize the result\\n        m = Math.floor((target - restSum)/changes)\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction findBestValue(arr: number[], target: number): number {\\n    // Using Least Common Multiple as basis\\n    let m = Math.floor(target/arr.length)\\n    let changes = 0\\n    \\n    while(true){\\n        // Define and clear variables\\n        let prevChanges = changes\\n        let restSum = 0\\n        let totalSum = 0\\n        changes = 0\\n\\n        // Calculate number of possible changes, restSum and totalSum\\n        for(let i = 0; i< arr.length; i++) {\\n            // if m > arr[i], means that arr[i] can be changed by m\\n            if(arr[i] > m) {\\n                changes++\\n            } else {\\n                // if cannot be changed, then I accumulate the number\\n                restSum += arr[i]\\n            }\\n            // totalSum is only used when there is only one change available\\n            totalSum += arr[i]\\n        }\\n\\n        // If there aren\\'t changes available return the biggest number of the array\\n        if(changes === 0) {\\n            return Math.max(...arr)\\n        }\\n\\n        // If there is only one change available\\n        if(changes === 1) {\\n            let x = target - restSum\\n            let y = totalSum - restSum\\n            if(x > y) return y\\n            return x\\n        }\\n\\n        // If the number of changes available is the same with the prevChanges, \\n        //then I it means that m is a candidate.\\n        if(prevChanges === changes) {\\n            // Because m is calculated with a division and I use only the integer, there is a \\n            // posibility that the value was closer to the next integer, so I try both cases.\\n            let result1 = Math.abs((m * changes) + restSum - target)\\n            let result2 = Math.abs(((m+1) * changes) + restSum - target)\\n\\n            return result2 >= result1 ? m : m + 1\\n        }\\n\\n        // update the value to minimize the result\\n        m = Math.floor((target - restSum)/changes)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2723079,
                "title": "simple-binary-search-js-solution",
                "content": "\\n# Code\\n```\\n/*\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\n\\nvar findBestValue = function(arr, target) {\\n       const addSum = (mid) =>{\\n             let addsum = 0;\\n             for (let i=0; i<arr.length; i++){\\n                   addsum += (arr[i]>mid)? mid : arr[i]; \\n             }  \\n             return addsum;\\n       }   \\n\\n       let l = 0, r = Math.max(...arr);\\n       let ans = 1;\\n       let diff = +Infinity;\\n\\n       while (l<=r) {\\n            let mid = Math.floor((l+r)/2);\\n           if (addSum(mid) > target){\\n                r = mid-1;\\n           } else {\\n                l = mid+1;\\n           }\\n\\n           if (Math.abs(addSum(mid)-target) < diff || Math.abs(addSum(mid)-target) === diff && mid<ans){\\n                  ans = mid;\\n                  diff = Math.abs(addSum(mid)-target);\\n           }\\n\\n       }\\n\\n       return ans;\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\n\\nvar findBestValue = function(arr, target) {\\n       const addSum = (mid) =>{\\n             let addsum = 0;\\n             for (let i=0; i<arr.length; i++){\\n                   addsum += (arr[i]>mid)? mid : arr[i]; \\n             }  \\n             return addsum;\\n       }   \\n\\n       let l = 0, r = Math.max(...arr);\\n       let ans = 1;\\n       let diff = +Infinity;\\n\\n       while (l<=r) {\\n            let mid = Math.floor((l+r)/2);\\n           if (addSum(mid) > target){\\n                r = mid-1;\\n           } else {\\n                l = mid+1;\\n           }\\n\\n           if (Math.abs(addSum(mid)-target) < diff || Math.abs(addSum(mid)-target) === diff && mid<ans){\\n                  ans = mid;\\n                  diff = Math.abs(addSum(mid)-target);\\n           }\\n\\n       }\\n\\n       return ans;\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2676347,
                "title": "c",
                "content": "```\\nint cmpfunc(const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\n\\nint findBestValue(int* arr, int arrSize, int target){\\n    int n = arrSize; \\n    qsort(arr, n, sizeof(int), cmpfunc);\\n    long long*  preSum = malloc(n * sizeof(long long));\\n    preSum[0] = arr[0];\\n    for(int i = 1; i < n; i++){\\n        preSum[i] = preSum[i-1] + arr[i];\\n    }\\n    //special case >>>\\n    if(preSum[n-1] == target)\\n        return arr[n-1];\\n    \\n    if(preSum[0]*n > target){\\n        int a = target/n;\\n        if(abs(target - a*n) <= abs(target - (a+1)*n))\\n            return a;\\n        else\\n            return a+1;\\n    }\\n\\n    if(preSum[n-1] < target)\\n        return arr[n-1];\\n    //<<<<\\n    \\n    int left = 0, right = n-1;\\n    int mid, sum ;\\n    while(left < right){\\n        mid = left + (right - left)/2;\\n        sum = preSum[mid] + (n-mid-1) * arr[mid];\\n        if(sum == target)\\n            return arr[mid];\\n        if(sum < target)\\n            left = mid + 1;\\n        else\\n            right = mid;\\n    }\\n    \\n    sum = preSum[left] + (n-left-1) * arr[left];\\n    if(sum == target || left == 0)\\n        return arr[left];\\n    \\n    int L = arr[left-1], R = arr[left];\\n    int M;\\n    \\n    while(L < R){        \\n        M = L + (R-L)/2;        \\n        sum = preSum[left-1] + M*(n-left);\\n        //printf(\"L = %d, R=%d, M=%d, sum=%d \", L, R, M, sum);\\n        if(sum == target)\\n            return M;\\n        if(sum < target)\\n            L = M + 1;\\n        else\\n            R = M;\\n    }\\n    \\n    int sum1 = preSum[left-1] + L*(n-left);\\n    int sum2 = preSum[left-1] + (L-1)*(n-left);\\n    if( abs(target - sum2)  <=  abs(target - sum1) )\\n        return L-1;\\n    else\\n        return L;\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nint cmpfunc(const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\n\\nint findBestValue(int* arr, int arrSize, int target){\\n    int n = arrSize; \\n    qsort(arr, n, sizeof(int), cmpfunc);\\n    long long*  preSum = malloc(n * sizeof(long long));\\n    preSum[0] = arr[0];\\n    for(int i = 1; i < n; i++){\\n        preSum[i] = preSum[i-1] + arr[i];\\n    }\\n    //special case >>>\\n    if(preSum[n-1] == target)\\n        return arr[n-1];\\n    \\n    if(preSum[0]*n > target){\\n        int a = target/n;\\n        if(abs(target - a*n) <= abs(target - (a+1)*n))\\n            return a;\\n        else\\n            return a+1;\\n    }\\n\\n    if(preSum[n-1] < target)\\n        return arr[n-1];\\n    //<<<<\\n    \\n    int left = 0, right = n-1;\\n    int mid, sum ;\\n    while(left < right){\\n        mid = left + (right - left)/2;\\n        sum = preSum[mid] + (n-mid-1) * arr[mid];\\n        if(sum == target)\\n            return arr[mid];\\n        if(sum < target)\\n            left = mid + 1;\\n        else\\n            right = mid;\\n    }\\n    \\n    sum = preSum[left] + (n-left-1) * arr[left];\\n    if(sum == target || left == 0)\\n        return arr[left];\\n    \\n    int L = arr[left-1], R = arr[left];\\n    int M;\\n    \\n    while(L < R){        \\n        M = L + (R-L)/2;        \\n        sum = preSum[left-1] + M*(n-left);\\n        //printf(\"L = %d, R=%d, M=%d, sum=%d \", L, R, M, sum);\\n        if(sum == target)\\n            return M;\\n        if(sum < target)\\n            L = M + 1;\\n        else\\n            R = M;\\n    }\\n    \\n    int sum1 = preSum[left-1] + L*(n-left);\\n    int sum2 = preSum[left-1] + (L-1)*(n-left);\\n    if( abs(target - sum2)  <=  abs(target - sum1) )\\n        return L-1;\\n    else\\n        return L;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2664503,
                "title": "c-standard-binary-search-problem-must-know-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        int low=0,high=INT_MIN,mid;\\n        for(int i=0;i<n;i++)\\n        {\\n            high=max(high,arr[i]);\\n        }\\n        int res=INT_MAX,sum=0,close=INT_MAX;\\n        while(low<=high)\\n        {\\n            mid=low+(high-low)/2;\\n            sum=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(arr[i]>mid)\\n                    sum+=mid;\\n                else\\n                    sum+=arr[i];\\n            }\\n            if(abs(sum-target)<=close)\\n            {\\n                if(close==abs(sum-target))\\n                    res=min(res,mid);\\n                else\\n                    res=mid;\\n                close=abs(sum-target);\\n            }\\n            if(sum>=target)\\n                high=mid-1;\\n            else if(sum<target)\\n                low=mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\nAN UPVOTE FROM YOUR SIDE IS HIGHLY APPRECIATED :)",
                "solutionTags": [
                    "C",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        int low=0,high=INT_MIN,mid;\\n        for(int i=0;i<n;i++)\\n        {\\n            high=max(high,arr[i]);\\n        }\\n        int res=INT_MAX,sum=0,close=INT_MAX;\\n        while(low<=high)\\n        {\\n            mid=low+(high-low)/2;\\n            sum=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(arr[i]>mid)\\n                    sum+=mid;\\n                else\\n                    sum+=arr[i];\\n            }\\n            if(abs(sum-target)<=close)\\n            {\\n                if(close==abs(sum-target))\\n                    res=min(res,mid);\\n                else\\n                    res=mid;\\n                close=abs(sum-target);\\n            }\\n            if(sum>=target)\\n                high=mid-1;\\n            else if(sum<target)\\n                low=mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664156,
                "title": "easy-c-binary-search",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        \\n        int low=0, high=*max_element(arr.begin(), arr.end()), mid, sum, ans, prevDiff=INT_MAX;\\n        \\n        while(low<=high) {\\n            mid = low + ((high-low)>>1);\\n            sum=0;\\n            \\n            for(int i=0; i<n; i++) {\\n                if(arr[i]<=mid) sum+=arr[i];\\n                else sum+=mid;\\n            }\\n            \\n            if(prevDiff >= abs(target-sum)) {\\n                if(prevDiff == abs(target-sum))\\n                    ans=min(mid, ans);\\n                else \\n                    ans=mid;\\n                prevDiff=abs(target-sum);\\n            }\\n            \\n            if(sum>=target) {\\n                high=mid-1;\\n            } else {\\n                low=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        \\n        int low=0, high=*max_element(arr.begin(), arr.end()), mid, sum, ans, prevDiff=INT_MAX;\\n        \\n        while(low<=high) {\\n            mid = low + ((high-low)>>1);\\n            sum=0;\\n            \\n            for(int i=0; i<n; i++) {\\n                if(arr[i]<=mid) sum+=arr[i];\\n                else sum+=mid;\\n            }\\n            \\n            if(prevDiff >= abs(target-sum)) {\\n                if(prevDiff == abs(target-sum))\\n                    ans=min(mid, ans);\\n                else \\n                    ans=mid;\\n                prevDiff=abs(target-sum);\\n            }\\n            \\n            if(sum>=target) {\\n                high=mid-1;\\n            } else {\\n                low=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641217,
                "title": "java-binary-search",
                "content": "\\tclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int max=Integer.MIN_VALUE;\\n        for(int i: arr)\\n        {\\n            max=Math.max(max, i);\\n        }\\n        \\n        int l=0;\\n        int h=max;\\n        int ret=Integer.MAX_VALUE;\\n        int diff=Integer.MAX_VALUE;\\n        while(l<=h)\\n        {\\n            int m=l+(h-l)/2;\\n            int ans=call(arr, m);\\n            if(diff>Math.abs(target-ans))\\n            {\\n                System.out.println(diff+\" \"+m+\" \"+ans);\\n                diff=Math.abs(target-ans);\\n                ret=m;\\n            }\\n            else if(diff==Math.abs(target-ans))\\n            {\\n                ret=Math.min(ret, m);\\n            }\\n            \\n            \\n            if(target-ans>0)\\n            {\\n                l=m+1;\\n            }\\n            else \\n            {\\n                h=m-1;\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    public int call(int[]arr, int m)\\n    {\\n        int s=0;\\n        for(int i: arr)\\n        {\\n            s+=i>m?m:i;\\n        }\\n        return s;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int max=Integer.MIN_VALUE;\\n        for(int i: arr)\\n        {\\n            max=Math.max(max, i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2619200,
                "title": "c-binary-search-easyy",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int> v,int mid){\\n        int s=0;\\n        for(int x : v){\\n            if(x > mid)\\n                s += mid;\\n            else\\n               s += x; \\n        }\\n        return s;\\n    }\\n    \\n    int findBestValue(vector<int>& a, int t) {\\n        int l=0,n=a.size(),h = *max_element(a.begin(),a.end()),ans=0;\\n        int minDiff=INT_MAX;\\n        while(l<=h){\\n            int mid = (l+h)/2;\\n            int k = solve(a,mid);\\n            if(k==t)\\n                return mid;\\n            else if(k > t)\\n                h=mid-1;\\n            else \\n                l=mid+1;\\n            \\n           int diff = abs(k-t);\\n            if(diff<minDiff){\\n                minDiff=diff;\\n                ans=mid;\\n            }\\n            else if(diff == minDiff){\\n                ans=min(ans,mid);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int> v,int mid){\\n        int s=0;\\n        for(int x : v){\\n            if(x > mid)\\n                s += mid;\\n            else\\n               s += x; \\n        }\\n        return s;\\n    }\\n    \\n    int findBestValue(vector<int>& a, int t) {\\n        int l=0,n=a.size(),h = *max_element(a.begin(),a.end()),ans=0;\\n        int minDiff=INT_MAX;\\n        while(l<=h){\\n            int mid = (l+h)/2;\\n            int k = solve(a,mid);\\n            if(k==t)\\n                return mid;\\n            else if(k > t)\\n                h=mid-1;\\n            else \\n                l=mid+1;\\n            \\n           int diff = abs(k-t);\\n            if(diff<minDiff){\\n                minDiff=diff;\\n                ans=mid;\\n            }\\n            else if(diff == minDiff){\\n                ans=min(ans,mid);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602622,
                "title": "all-of-my-testcases-do-not-pass-help",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int length = arr.size();\\n        for(int i =0;i<=length;i++){\\n            int sol = target/length;\\n            if(arr[i]>=sol){\\n                return sol;\\n            }\\n        \\n                target -=arr[i];\\n                length-=1;\\n            \\n              \\n        }\\n        return arr.back(); //nothing is true return the last number\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int length = arr.size();\\n        for(int i =0;i<=length;i++){\\n            int sol = target/length;\\n            if(arr[i]>=sol){\\n                return sol;\\n            }\\n        \\n                target -=arr[i];\\n                length-=1;\\n            \\n              \\n        }\\n        return arr.back(); //nothing is true return the last number\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551287,
                "title": "c-binary-search-easy-and-readable-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(int mid,vector<int>& arr){\\n        int sum=0;\\n        for(auto &it: arr){\\n            if(it<=mid){\\n                sum+= it;\\n            }\\n            else{\\n                sum+= mid;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n          sort(arr.begin(),arr.end());\\n        int n= arr.size();\\n        int l=0,r= target;\\n        if(check(arr[n-1],arr)<=target){\\n            return arr[n-1];\\n        }\\n        while(l<=r){\\n            int mid= l+ (r-l)/2;\\n            int sum= check(mid,arr);\\n            if(sum==target){\\n                l= mid;\\n                break;\\n            }\\n            else if(sum<target){\\n                l= mid+1;\\n            }\\n            else{\\n                r= mid-1;\\n            }\\n        }\\n        \\n        int m=l-1;\\n        \\n        if(abs(target-check(l,arr))>=abs(target-check(m,arr))){\\n            return m;\\n        }\\n        else{\\n            return l;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int check(int mid,vector<int>& arr){\\n        int sum=0;\\n        for(auto &it: arr){\\n            if(it<=mid){\\n                sum+= it;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2548330,
                "title": "python-sorting-solution",
                "content": "```\\ndef findBestValue(self, arr: List[int], x: int) -> int:\\n\\tleft, arr, k = 0, sorted(arr), 0\\n\\tfor i in range(len(arr)):\\n\\t\\tk = round((x-left)/(len(arr)-i))\\n\\t\\tif k<arr[i]:\\n\\t\\t\\treturn k\\n\\t\\tleft += arr[i]\\n\\treturn arr[-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef findBestValue(self, arr: List[int], x: int) -> int:\\n\\tleft, arr, k = 0, sorted(arr), 0\\n\\tfor i in range(len(arr)):\\n\\t\\tk = round((x-left)/(len(arr)-i))\\n\\t\\tif k<arr[i]:\\n\\t\\t\\treturn k\\n\\t\\tleft += arr[i]\\n\\treturn arr[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2530875,
                "title": "c-reduce-possibilities",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findBestValue(vector<int>& a, int target) {\\n\\t\\t\\tint mx=0,res=0;\\n\\t\\t\\tfor(int i=0;i<a.size();i++)  {\\n\\t\\t\\t\\tmx=max(mx,a[i]);\\n\\t\\t\\t\\tres+=a[i];\\n\\t\\t\\t}\\n\\t\\t\\tif(res<=target) return mx;\\n\\t\\t\\tint l=0,r=1e9+1;\\n\\t\\t\\twhile(l<r)  {\\n\\t\\t\\t\\tint m=(l+r)/2;\\n\\t\\t\\t\\tint sum=0;\\n\\t\\t\\t\\tfor(int i=0;i<a.size();i++) {\\n\\t\\t\\t\\t\\tsum+=(a[i]>m?m:a[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(sum-target>=0) {\\n\\t\\t\\t\\t\\tr=m;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse l=m+1;\\n\\t\\t\\t}\\n\\t\\t\\tint sum1=0,sum2=0;\\n\\t\\t\\tfor(int i=0;i<a.size();i++) {\\n\\t\\t\\t\\tsum1+=(a[i]>r?r:a[i]);\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<a.size();i++) {\\n\\t\\t\\t\\tsum2+=(a[i]>r-1?r-1:a[i]);\\n\\t\\t\\t}\\n\\t\\t\\tif(abs(sum1-target)>=abs(sum2-target)) return r-1;\\n\\t\\t\\treturn r;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint findBestValue(vector<int>& a, int target) {\\n\\t\\t\\tint mx=0,res=0;\\n\\t\\t\\tfor(int i=0;i<a.size();i++)  {\\n\\t\\t\\t\\tmx=max(mx,a[i]);\\n\\t\\t\\t\\tres+=a[i];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2513778,
                "title": "binary-search-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getNewSum(vector <int> &arr, int m) {\\n        int sum = 0;\\n        \\n        for(const int &num : arr) {\\n            if(num > m) {\\n                sum += m;\\n            }\\n            else {\\n                sum += num;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size();\\n        int low = 0; int high = arr[n-1];\\n        int minDiff = INT_MAX; int ans=0;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            int sum = getNewSum(arr,mid);\\n            int diff = abs(sum-target);\\n            if(diff<minDiff){\\n                minDiff=diff;\\n                ans=mid;\\n            }\\n            else if(diff == minDiff){\\n                ans=min(ans,mid);\\n            }\\n            \\n            if(sum>target){\\n                high = mid-1;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNewSum(vector <int> &arr, int m) {\\n        int sum = 0;\\n        \\n        for(const int &num : arr) {\\n            if(num > m) {\\n                sum += m;\\n            }\\n            else {\\n                sum += num;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size();\\n        int low = 0; int high = arr[n-1];\\n        int minDiff = INT_MAX; int ans=0;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            int sum = getNewSum(arr,mid);\\n            int diff = abs(sum-target);\\n            if(diff<minDiff){\\n                minDiff=diff;\\n                ans=mid;\\n            }\\n            else if(diff == minDiff){\\n                ans=min(ans,mid);\\n            }\\n            \\n            if(sum>target){\\n                high = mid-1;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500813,
                "title": "2-solutions-in-c-binary-search-sorting-binary-search-prefix-sum",
                "content": "**Solution 1 : [Binary-search]**\\n\\n```\\nclass Solution {\\npublic:\\n    int getNewSum(vector <int> &arr, int m) {\\n        int sum = 0;\\n        \\n        for(const int &num : arr) {\\n            if(num > m) {\\n                sum += m;\\n            }\\n            else {\\n                sum += num;\\n            }\\n        }\\n        \\n        return sum;\\n    }  \\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int max_e = INT_MIN;\\n        \\n        for(const int &num : arr) {\\n            max_e = max(num, max_e);\\n        }\\n        \\n        int l = 0, r = max_e, res = 0, minDiff = INT_MAX;\\n        \\n        while(l <= r) {\\n            int m = l + (r - l) / 2, sum = getNewSum(arr, m);\\n            \\n            int diff = abs(sum - target);\\n            \\n            if(diff < minDiff) {\\n                minDiff = diff;\\n                res = m;\\n            } \\n            else if(diff == minDiff) {\\n                res = min(res, m);\\n            } \\n            \\n            if(sum > target) {\\n                r = m - 1;\\n            }\\n            else {\\n                l = m + 1;\\n            }\\n        } \\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Solution 2 : [Sorting + Binary-search + prefix sum]**\\n\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int N = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int min_e = 0, max_e = arr.back();\\n        \\n        vector <int> ps(N, 0);\\n        ps[0] = arr[0];\\n        \\n        for(int i = 1; i < N; i++) {\\n            ps[i] = ps[i - 1] + arr[i];\\n        }\\n        \\n        int minDiff = INT_MAX, res = 0;\\n        for(int i = min_e; i <= max_e; i++) {\\n            int idx = upper_bound(arr.begin(), arr.end(), i) - arr.begin();\\n            \\n            int sum = idx > 0 ? ps[idx - 1] : 0;\\n            \\n            // convert integers larger than i to i\\n            sum += (i * (N - idx));\\n            \\n            int diff = abs(sum - target);\\n            \\n            if(diff < minDiff) {\\n                minDiff = diff;\\n                res = i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNewSum(vector <int> &arr, int m) {\\n        int sum = 0;\\n        \\n        for(const int &num : arr) {\\n            if(num > m) {\\n                sum += m;\\n            }\\n            else {\\n                sum += num;\\n            }\\n        }\\n        \\n        return sum;\\n    }  \\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int max_e = INT_MIN;\\n        \\n        for(const int &num : arr) {\\n            max_e = max(num, max_e);\\n        }\\n        \\n        int l = 0, r = max_e, res = 0, minDiff = INT_MAX;\\n        \\n        while(l <= r) {\\n            int m = l + (r - l) / 2, sum = getNewSum(arr, m);\\n            \\n            int diff = abs(sum - target);\\n            \\n            if(diff < minDiff) {\\n                minDiff = diff;\\n                res = m;\\n            } \\n            else if(diff == minDiff) {\\n                res = min(res, m);\\n            } \\n            \\n            if(sum > target) {\\n                r = m - 1;\\n            }\\n            else {\\n                l = m + 1;\\n            }\\n        } \\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int N = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int min_e = 0, max_e = arr.back();\\n        \\n        vector <int> ps(N, 0);\\n        ps[0] = arr[0];\\n        \\n        for(int i = 1; i < N; i++) {\\n            ps[i] = ps[i - 1] + arr[i];\\n        }\\n        \\n        int minDiff = INT_MAX, res = 0;\\n        for(int i = min_e; i <= max_e; i++) {\\n            int idx = upper_bound(arr.begin(), arr.end(), i) - arr.begin();\\n            \\n            int sum = idx > 0 ? ps[idx - 1] : 0;\\n            \\n            // convert integers larger than i to i\\n            sum += (i * (N - idx));\\n            \\n            int diff = abs(sum - target);\\n            \\n            if(diff < minDiff) {\\n                minDiff = diff;\\n                res = i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480044,
                "title": "simple-c-solution-binary-search-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l = 0;\\n        int h = *max_element(begin(arr), end(arr));\\n        int ans = h, diff = target;\\n        while(l<=h)\\n        {\\n            int mid = (h+l)/2;\\n            int sum = getSum(arr,mid);\\n            int currDiff = abs(target-sum);\\n            if(currDiff< diff)\\n                diff = currDiff , ans = mid;\\n            if(currDiff == diff) \\n                ans = min(ans, mid);\\n            if(sum > target)\\n                h = mid - 1;\\n            else\\n                l = mid + 1;\\n        }\\n        return ans;\\n    }\\n    \\n    int getSum(vector<int>& arr, int &mid)\\n    {\\n        int sum = 0;\\n        for(int x : arr)\\n            sum += x > mid ? mid : x;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l = 0;\\n        int h = *max_element(begin(arr), end(arr));\\n        int ans = h, diff = target;\\n        while(l<=h)\\n        {\\n            int mid = (h+l)/2;\\n            int sum = getSum(arr,mid);\\n            int currDiff = abs(target-sum);\\n            if(currDiff< diff)\\n                diff = currDiff , ans = mid;\\n            if(currDiff == diff) \\n                ans = min(ans, mid);\\n            if(sum > target)\\n                h = mid - 1;\\n            else\\n                l = mid + 1;\\n        }\\n        return ans;\\n    }\\n    \\n    int getSum(vector<int>& arr, int &mid)\\n    {\\n        int sum = 0;\\n        for(int x : arr)\\n            sum += x > mid ? mid : x;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472255,
                "title": "c-code",
                "content": "class Solution {\\npublic:\\n    long long cal(int num, vector<int> &nums) {\\n        long long sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] <= num) sum += nums[i];\\n            else sum += num;\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        if(cal(arr[n-1], arr) <= target) return arr[n-1];\\n        int lo = 0, hi = 1e5;\\n        while(lo < hi) {\\n            int mid = lo + (hi-lo+1)/2;\\n            long long sum = cal(mid, arr);\\n            if(sum <= target) lo = mid;\\n            else hi = mid-1;\\n        }\\n        if(abs(cal(lo, arr)-target) <= abs(cal(lo+1, arr)-target))\\n            return lo;\\n        return lo+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long cal(int num, vector<int> &nums) {\\n        long long sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] <= num) sum += nums[i];\\n            else sum += num;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2448721,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long cal(int num, vector<int> &nums) {\\n        long long sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] <= num) sum += nums[i];\\n            else sum += num;\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        if(cal(arr[n-1], arr) <= target) return arr[n-1];\\n        int lo = 0, hi = 1e5;\\n        while(lo < hi) {\\n            int mid = lo + (hi-lo+1)/2;\\n            long long sum = cal(mid, arr);\\n            if(sum <= target) lo = mid;\\n            else hi = mid-1;\\n        }\\n        if(abs(cal(lo, arr)-target) <= abs(cal(lo+1, arr)-target))\\n            return lo;\\n        return lo+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long cal(int num, vector<int> &nums) {\\n        long long sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] <= num) sum += nums[i];\\n            else sum += num;\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        if(cal(arr[n-1], arr) <= target) return arr[n-1];\\n        int lo = 0, hi = 1e5;\\n        while(lo < hi) {\\n            int mid = lo + (hi-lo+1)/2;\\n            long long sum = cal(mid, arr);\\n            if(sum <= target) lo = mid;\\n            else hi = mid-1;\\n        }\\n        if(abs(cal(lo, arr)-target) <= abs(cal(lo+1, arr)-target))\\n            return lo;\\n        return lo+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2073401,
                "content": [
                    {
                        "username": "arvin_draj",
                        "content": "A little catch in the example 2...\\nI just wonder why the answer is  not 3"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Example 2:\\n\\nInput: arr = [2,3,5], target = 10\\nOutput: 5\\nWhy not in example 2 the answer is 3, since if we convert all elements to 3 then sum would be 9.\\nIncase we convert all to 5 then sum of array would be 15.\\nNow 9 is close to 10 than 15 does right? ..\\nPlease help if i am wrong or misunderstood the question."
                    },
                    {
                        "username": "gauravbharti",
                        "content": "You understood it wrong, you can only update the ones which are smaller, so here in 2,3,5 -> if  you choose 3 then it will be 2,3,3 which totals for 8, and if you leave it as it is, it totals for 10"
                    }
                ]
            },
            {
                "id": 1972692,
                "content": [
                    {
                        "username": "arvin_draj",
                        "content": "A little catch in the example 2...\\nI just wonder why the answer is  not 3"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Example 2:\\n\\nInput: arr = [2,3,5], target = 10\\nOutput: 5\\nWhy not in example 2 the answer is 3, since if we convert all elements to 3 then sum would be 9.\\nIncase we convert all to 5 then sum of array would be 15.\\nNow 9 is close to 10 than 15 does right? ..\\nPlease help if i am wrong or misunderstood the question."
                    },
                    {
                        "username": "gauravbharti",
                        "content": "You understood it wrong, you can only update the ones which are smaller, so here in 2,3,5 -> if  you choose 3 then it will be 2,3,3 which totals for 8, and if you leave it as it is, it totals for 10"
                    }
                ]
            }
        ]
    }
]