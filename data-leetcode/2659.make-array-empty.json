[
    {
        "title": "Make Array Empty",
        "question_content": "You are given an integer array nums containing distinct numbers, and you can perform the following operations until the array is empty:\n\n\tIf the first element has the smallest value, remove it\n\tOtherwise, put the first element at the end of the array.\n\nReturn an integer denoting the number of operations it takes to make nums empty.\n&nbsp;\nExample 1:\n\nInput: nums = [3,4,-1]\nOutput: 5\n\n\t\n\t\t\n\t\t\tOperation\n\t\t\tArray\n\t\t\n\t\n\t\n\t\t\n\t\t\t1\n\t\t\t[4, -1, 3]\n\t\t\n\t\t\n\t\t\t2\n\t\t\t[-1, 3, 4]\n\t\t\n\t\t\n\t\t\t3\n\t\t\t[3, 4]\n\t\t\n\t\t\n\t\t\t4\n\t\t\t[4]\n\t\t\n\t\t\n\t\t\t5\n\t\t\t[]\n\t\t\n\t\n\nExample 2:\n\nInput: nums = [1,2,4,3]\nOutput: 5\n\n\t\n\t\t\n\t\t\tOperation\n\t\t\tArray\n\t\t\n\t\n\t\n\t\t\n\t\t\t1\n\t\t\t[2, 4, 3]\n\t\t\n\t\t\n\t\t\t2\n\t\t\t[4, 3]\n\t\t\n\t\t\n\t\t\t3\n\t\t\t[3, 4]\n\t\t\n\t\t\n\t\t\t4\n\t\t\t[4]\n\t\t\n\t\t\n\t\t\t5\n\t\t\t[]\n\t\t\n\t\n\nExample 3:\n\nInput: nums = [1,2,3]\nOutput: 3\n\n\t\n\t\t\n\t\t\tOperation\n\t\t\tArray\n\t\t\n\t\n\t\n\t\t\n\t\t\t1\n\t\t\t[2, 3]\n\t\t\n\t\t\n\t\t\t2\n\t\t\t[3]\n\t\t\n\t\t\n\t\t\t3\n\t\t\t[]\n\t\t\n\t\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t-109&nbsp;<= nums[i] <= 109\n\tAll values in nums are distinct.",
        "solutions": [
            {
                "id": 3466800,
                "title": "java-c-python-easy-sort-solution",
                "content": "# **Intuition**\\nThere `n` elements at first,\\nso there will take at least `n` operations.\\nAnd it take `n` operations rotate all elements once.\\n<br>\\n\\n# **Explanation**\\nInitialize `res` as `n` at first,\\nand we record every elements position, `pos[A[i]] = i`.\\n\\nThen we iterate all element from small to big in `A`,\\nif the position decrease,\\nthis mean we will rotate all remining element to the begin,\\nand this bring us back to out begining intuition above,\\nwe will increase `res` by the number of remaining elements.\\n<br>\\n\\n\\n# **Example**\\n\\n`A = [7,8,9]`\\nthis `A` takes 3 operation.\\n\\nNow we insert `4,5,6` in A,\\nno matter what position but keep their order\\nMaybe `A = [4,5,7,8,9,6]`\\nNow it take one round to remove 4,5,6 then 7,8,9\\nso it needs `6 + 3 = 9` operations\\n\\nNow we insert `1,2,3` in A,\\nno matter what position but keep their order\\nso it needs `9 + 6 + 3 = 18` operations\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public long countOperationsToEmptyArray(int[] A) {\\n        Map<Integer, Integer> pos = new HashMap<>();\\n        long n = A.length, res = n;\\n        for (int i = 0; i < n; ++i)\\n            pos.put(A[i], i);\\n        Arrays.sort(A);\\n        for (int i = 1; i < n; ++i)\\n            if (pos.get(A[i]) < pos.get(A[i - 1]))\\n                res += n - i;\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        unordered_map<int, int> pos;\\n        long long n = A.size(), res = n;\\n        for (int i = 0; i < n; ++i)\\n            pos[A[i]] = i;\\n        sort(A.begin(), A.end());\\n        for (int i = 1; i < n; ++i)\\n            if (pos[A[i]] < pos[A[i - 1]])\\n                res += n - i;\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def countOperationsToEmptyArray(self, A: List[int]) -> int:\\n        pos = {a: i for i, a in enumerate(A)}\\n        res = n = len(A)\\n        A.sort()\\n        for i in range(1, n):\\n            if pos[A[i]] < pos[A[i - 1]]:\\n                res += n - i\\n        return res\\n```\\n<br>\\n\\n\\n# **Solution II: Not sort input**\\nSuggested by @sgallivan,\\nbetter not to sort directly on the input.\\n\\nTime `O(nlogn)`\\nSpace `O(n)`\\n\\n**Java**\\n```java\\n    public long countOperationsToEmptyArray(int[] A) {\\n        int n = A.length;\\n        Integer[] pos = new Integer[n];\\n        for (int i = 0; i < n; ++i)\\n            pos[i] = i;\\n        Arrays.sort(pos, (i, j) -> A[i] - A[j]);\\n        long res = n;\\n        for (int i = 1; i < n; ++i)\\n            if (pos[i] < pos[i - 1])\\n                res += n - i;\\n        return res;\\n    }\\n```\\n\\n**C++**\\nby @sgallivan\\n```cpp\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        long long n = A.size(), res = n;\\n        vector<int> pos(n);\\n        iota(begin(pos), end(pos), 0);\\n        sort(begin(pos), end(pos), [&](int a, int b) {return A[a] < A[b];});\\n        for (int i = 1; i < n; ++i)\\n            if (pos[i] < pos[i - 1])\\n                res += n - i;\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def countOperationsToEmptyArray(self, A: List[int]) -> int:\\n        n = len(A)\\n        pos = sorted(range(n), key=lambda i: A[i])\\n        return n + sum(n - i for i in range(1, n) if pos[i] < pos[i - 1])\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long countOperationsToEmptyArray(int[] A) {\\n        Map<Integer, Integer> pos = new HashMap<>();\\n        long n = A.length, res = n;\\n        for (int i = 0; i < n; ++i)\\n            pos.put(A[i], i);\\n        Arrays.sort(A);\\n        for (int i = 1; i < n; ++i)\\n            if (pos.get(A[i]) < pos.get(A[i - 1]))\\n                res += n - i;\\n        return res;\\n    }\\n```\n```cpp\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        unordered_map<int, int> pos;\\n        long long n = A.size(), res = n;\\n        for (int i = 0; i < n; ++i)\\n            pos[A[i]] = i;\\n        sort(A.begin(), A.end());\\n        for (int i = 1; i < n; ++i)\\n            if (pos[A[i]] < pos[A[i - 1]])\\n                res += n - i;\\n        return res;\\n    }\\n```\n```py\\n    def countOperationsToEmptyArray(self, A: List[int]) -> int:\\n        pos = {a: i for i, a in enumerate(A)}\\n        res = n = len(A)\\n        A.sort()\\n        for i in range(1, n):\\n            if pos[A[i]] < pos[A[i - 1]]:\\n                res += n - i\\n        return res\\n```\n```java\\n    public long countOperationsToEmptyArray(int[] A) {\\n        int n = A.length;\\n        Integer[] pos = new Integer[n];\\n        for (int i = 0; i < n; ++i)\\n            pos[i] = i;\\n        Arrays.sort(pos, (i, j) -> A[i] - A[j]);\\n        long res = n;\\n        for (int i = 1; i < n; ++i)\\n            if (pos[i] < pos[i - 1])\\n                res += n - i;\\n        return res;\\n    }\\n```\n```cpp\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        long long n = A.size(), res = n;\\n        vector<int> pos(n);\\n        iota(begin(pos), end(pos), 0);\\n        sort(begin(pos), end(pos), [&](int a, int b) {return A[a] < A[b];});\\n        for (int i = 1; i < n; ++i)\\n            if (pos[i] < pos[i - 1])\\n                res += n - i;\\n        return res;\\n    }\\n```\n```py\\n    def countOperationsToEmptyArray(self, A: List[int]) -> int:\\n        n = len(A)\\n        pos = sorted(range(n), key=lambda i: A[i])\\n        return n + sum(n - i for i in range(1, n) if pos[i] < pos[i - 1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3466731,
                "title": "just-sort-without-any-other-tricky-data-structures",
                "content": "# Intuition\\nIf we just find the smallest, 2nd smallest\\u2026until the m-th smallest number and they are just from left to right, then after n operations (n - m movings and m deletions) all the other (n - m) numbers go back to the \\u201Ccorrect\\u201D/original positions. We just have a shorter array to restart.\\n\\n# Approach\\nSort by index and process all the numbers from left to right and then restart.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) because of sorting.\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> ind(n);\\n        for (int i = 0; i < n; ++i) {\\n            ind[i] = i;\\n        }\\n        sort(ind.begin(), ind.end(), [&](const int x, const int y) {\\n            return nums[x] < nums[y];\\n        });\\n        int m = n;\\n        long long r = 0;\\n        for (int i = 1; i < n; ++i) {\\n            if (ind[i] < ind[i - 1]) {\\n                r += m;\\n                m = n - i;\\n            }\\n        }\\n        r += m;\\n        return r;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> ind(n);\\n        for (int i = 0; i < n; ++i) {\\n            ind[i] = i;\\n        }\\n        sort(ind.begin(), ind.end(), [&](const int x, const int y) {\\n            return nums[x] < nums[y];\\n        });\\n        int m = n;\\n        long long r = 0;\\n        for (int i = 1; i < n; ++i) {\\n            if (ind[i] < ind[i - 1]) {\\n                r += m;\\n                m = n - i;\\n            }\\n        }\\n        r += m;\\n        return r;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466620,
                "title": "count-rotations-vs-bit",
                "content": "We sort the indexes of the numbers. \\n\\nFor example, for `[8, 6, 11, 1, 2, 3, 7]`, the sorted indexes will be `[3, 4, 5, 1, 6, 0, 2]`.\\n\\nI solved this problem using BIT (second solution below), but there is another approach (first solution) with tricky intuition but simpler implementation.\\n\\n## Count Rotations\\nThe implementation is simple but the intuition is not. I only found a good explanation in the solution by [mkyang](https://leetcode.com/mkyang/).\\n\\n1. For the test case `[10, 20, 30, 40, 50]`, we need five operations.\\n2. For `[50, 40, 30, 20, 10]`, we need to first rotate 4 elements to reach the smallest number `10`.\\n\\t- So we need 5 operations to remove the smallest element, 4 - for the second smallest one, and so on;\\n\\t- Total 5 + 10 operations.\\n3. For `[10, 30, 50, 20, 40]`, we need:\\n\\t- 2 rotations to reach 20, 1 rotations 30, 1 rotation to reach 40.\\n\\t- Total 5 + 4 operations.\\n\\n- The sorted index array `ids` for the last case is `[0, 3, 1, 4, 2]`.\\n\\t- We see that `ids[1] > ids[2]`, and it means that we needed to rotate `3` elements (`30, 50, 40`) to reach/remove `20`, and go back to `30`.\\n\\t- As `ids[3] > ids[4]`, we need `1` rotation (`50`) to reach/remove `40` and go back to `50`.\\n\\n**C++**\\n```cpp\\nlong long countOperationsToEmptyArray(vector<int>& n) {\\n    long long res = 0, sz = n.size();\\n    vector<int> ids(n.size());\\n    iota(begin(ids), end(ids), 0);\\n    sort(begin(ids), end(ids), [&](int i, int j){ return n[i] < n[j]; });\\n    for (int i = 1; i < sz; ++i)\\n        res += ids[i - 1] < ids[i] ? 0 : sz - i;\\n    return res + sz;\\n}\\n```\\n\\n## BIT\\n\\nWe start from index zero, and go to the first smallest number. In our example, the position is 3, and it takes 4 operations to remove that number.\\n\\nGoing from index `cur` to index `id` takes:\\n- `id - cur + 1` operations, or \\n- `id + sz - cur` if the current index is larger.\\n\\nHowever, we need to reduce the number operations for elements we already removed. \\n\\nFor that, we can use a mutating prefix sum data structure, like BIT.\\n\\n**C++**\\n```cpp        \\nconstexpr int static n = 100001;\\nint bt[n + 1] = {};\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nlong long countOperationsToEmptyArray(vector<int>& n) {\\n    long long res = 0, cur = 0, sz = n.size();\\n    vector<int> ids(n.size());\\n    iota(begin(ids), end(ids), 0);\\n    sort(begin(ids), end(ids), [&](int i, int j){ return n[i] < n[j]; });\\n    for (int id : ids) {\\n        if (cur <= id)\\n            res += 1 + (id - prefix_sum(id)) - (cur - prefix_sum(cur - 1));\\n        else\\n            res += (sz - prefix_sum(sz)) + (id - prefix_sum(id)) - (cur - prefix_sum(cur));\\n        add(id, 1);\\n        cur = id;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nlong long countOperationsToEmptyArray(vector<int>& n) {\\n    long long res = 0, sz = n.size();\\n    vector<int> ids(n.size());\\n    iota(begin(ids), end(ids), 0);\\n    sort(begin(ids), end(ids), [&](int i, int j){ return n[i] < n[j]; });\\n    for (int i = 1; i < sz; ++i)\\n        res += ids[i - 1] < ids[i] ? 0 : sz - i;\\n    return res + sz;\\n}\\n```\n```cpp        \\nconstexpr int static n = 100001;\\nint bt[n + 1] = {};\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nlong long countOperationsToEmptyArray(vector<int>& n) {\\n    long long res = 0, cur = 0, sz = n.size();\\n    vector<int> ids(n.size());\\n    iota(begin(ids), end(ids), 0);\\n    sort(begin(ids), end(ids), [&](int i, int j){ return n[i] < n[j]; });\\n    for (int id : ids) {\\n        if (cur <= id)\\n            res += 1 + (id - prefix_sum(id)) - (cur - prefix_sum(cur - 1));\\n        else\\n            res += (sz - prefix_sum(sz)) + (id - prefix_sum(id)) - (cur - prefix_sum(cur));\\n        add(id, 1);\\n        cur = id;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3469773,
                "title": "day-395-easy-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nIntuition:\\n\\nThink backwards: simulate in reverse direction. When you remove the last remaining element, how will it affect? When you will have 2 elements left, how will it affect and so on\\u2026\\n\\nThe relative position of an element to the next element which will be removed will determine the number of operations required to remove that element.\\n\\nApproach:\\n\\nStore the index and element in an array and then sort the array. This will tell us if after doing some operation what will be the relative position of that given element to the next element which will be removed.\\n\\nUse a HashMap to store the index of each element in the input array.\\n\\nIterate over the sorted array in reverse order, starting from the second last element.\\n\\nFor each element, check if its index in the original array is greater than the index of the next element to be removed. If it is, then the element will move to the end of the array after the next element is removed, and we need to perform n - i operations to remove it, where n is the length of the input array. Otherwise, we only need to perform 1 operation to remove the element.\\n\\nAdd the number of operations required to remove the current element to the answer.\\n\\nReturn the answer.\\n\\nThe time complexity of this approach is O(n log n), where n is the length of the input array, due to the sorting operation.\\n\\n\\n# Code\\n```java []\\npublic long countOperationsToEmptyArray(int[] nums) {\\n    HashMap<Integer,Integer> map = new HashMap<>();\\n    int n=nums.length;\\n    for(int i=0;i<n;i++)map.put(nums[i],i);\\n    Arrays.sort(nums);\\n    long ans=1;\\n    for(int i=n-2;i>=0;i--){\\n        ans += (map.get(nums[i])>map.get(nums[i+1]))?n-i:1;\\n    }return ans;\\n}\\n```\\n```python []\\ndef countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    map = {nums[i]: i for i in range(n)}\\n    nums.sort()\\n    ans = 1\\n    for i in range(n - 2, -1, -1):\\n        ans += (map[nums[i]] > map[nums[i+1]]) * (n - i) + (map[nums[i]] <= map[nums[i+1]])\\n    return ans\\n```\\n```c++ []\\n long countOperationsToEmptyArray(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            map[nums[i]] = i;\\n        }\\n        sort(nums.begin(), nums.end());\\n        long ans = 1;\\n        for(int i = n - 2; i >= 0; i--) {\\n            ans += (map[nums[i]] > map[nums[i+1]]) ? n - i : 1;\\n        }\\n        return ans;\\n    }\\n```\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: o(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```java []\\npublic long countOperationsToEmptyArray(int[] nums) {\\n    HashMap<Integer,Integer> map = new HashMap<>();\\n    int n=nums.length;\\n    for(int i=0;i<n;i++)map.put(nums[i],i);\\n    Arrays.sort(nums);\\n    long ans=1;\\n    for(int i=n-2;i>=0;i--){\\n        ans += (map.get(nums[i])>map.get(nums[i+1]))?n-i:1;\\n    }return ans;\\n}\\n```\n```python []\\ndef countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    map = {nums[i]: i for i in range(n)}\\n    nums.sort()\\n    ans = 1\\n    for i in range(n - 2, -1, -1):\\n        ans += (map[nums[i]] > map[nums[i+1]]) * (n - i) + (map[nums[i]] <= map[nums[i+1]])\\n    return ans\\n```\n```c++ []\\n long countOperationsToEmptyArray(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            map[nums[i]] = i;\\n        }\\n        sort(nums.begin(), nums.end());\\n        long ans = 1;\\n        for(int i = n - 2; i >= 0; i--) {\\n            ans += (map[nums[i]] > map[nums[i+1]]) ? n - i : 1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3466873,
                "title": "c-python-easy-code-for-understanding",
                "content": "> **I know almost nothing about English, pointing out the mistakes in my article would be much appreciated.**\\n\\n> **In addition, I\\'m too weak, please be critical of my ideas.**\\n---\\n\\n# Intuition\\n- The most important thing is to calculate for each $a_i$, the deleted turn of $a_i$ is called $turn(i)$.\\n- Obviously, all elements which $>a_i$ will be deleted after $i$, so they will never make contribution to $turn(i)$. And all elements which $<a_i$ will be deleted before or in the same turn of $i$.\\n- So simulate the process, easily find that $turn(i)$ must satisfy two constraints:\\n    - **For all the left smaller elements** $j$, $turn(i) >= turn(j)$.\\n    - **For all the right smaller elements** $k$, $turn(i) > turn(k)$.\\n- So the result of $a_i$ is:\\n        $turn(i) = \\\\max{ \\\\{\\\\max\\\\limits_{j=0}^i {turn(j)}, \\\\max\\\\limits_{k=i+1}^{n-1} {turn(k)} + 1 \\\\}}, a_j < a_i, a_k < a_i$\\n- Easily traversing the array from small to large, using segment tree to maintain the range maximum, we can solve the problem in $O(n \\\\log n)$ time. \\n-   But in this problem we can find a good property:\\n    **From previous one to the next in sorted array, $turn$ is either unchanged or increased by one.**\\n- What\\'s more? \\n    **Assuming that the current maximum turn is $t$, $turn(i) = t + 1$ only when there is a $t$ on the right side of $a_i$, otherwise $turn(i) = t$.**\\n- So maintain the current $t$ and max index of $t$. If the current index is greater than the largest index that appeared before, then inherit $t$; otherwise update to $t+1$. And update the current largest index at the same time.\\n\\n# Complexity\\n- Time complexity: $O(n\\\\log{n})$\\n- Space complexity: $O(n)$\\n\\n# Code\\n``` Python3 []\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n, res, turn = len(nums), 1, 1\\n        idx = sorted(range(n), key=lambda x: nums[x])\\n        for i in range(1, n):\\n            turn += idx[i] < idx[i-1]\\n            res += turn\\n        return res\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long n = nums.size(), res = 1, turn = 1;\\n        vector<int> idx(n);\\n        iota(idx.begin(), idx.end(), 0);\\n        sort(idx.begin(), idx.end(), [&](int x, int y) -> bool {\\n            return nums[x] < nums[y];\\n        });\\n        for (int i = 1; i < n; ++i) {\\n            turn += idx[i] < idx[i-1];\\n            res += turn;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Sort"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n, res, turn = len(nums), 1, 1\\n        idx = sorted(range(n), key=lambda x: nums[x])\\n        for i in range(1, n):\\n            turn += idx[i] < idx[i-1]\\n            res += turn\\n        return res\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long n = nums.size(), res = 1, turn = 1;\\n        vector<int> idx(n);\\n        iota(idx.begin(), idx.end(), 0);\\n        sort(idx.begin(), idx.end(), [&](int x, int y) -> bool {\\n            return nums[x] < nums[y];\\n        });\\n        for (int i = 1; i < n; ++i) {\\n            turn += idx[i] < idx[i-1];\\n            res += turn;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469719,
                "title": "fully-explained-in-easy-way-must-check",
                "content": "# Intuition\\nThis question needs a good level of observation . Just think what is asked in problem  ! You have to delete the smallest element and shift the rest of the elements. Just check that how much operation is needed to delete the smallest element. It will be the current index of smallest element + 1 . Now check the next smallest if it was present before this index then You Need to do N operations at any cost to delete this element .\\n\\nfor this first sort the array like this \\nsmallest element - index\\n2nd smallest element - index\\n.\\n.\\n.\\n.\\nlargest element -index \\n\\nuse this array to check wether the 2nd smallest element is coming before the smallest element or after the smallest element and perform accordingly .\\n\\nif before then we need n operations \\nelse we can delete them together so increment d\\ntry to Dry run this !! else you\\'ll not get it \\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op =0;\\n        map<int,int>mp;\\n       for(int i = 0 ; i < nums.size() ; ++i){\\n           mp[nums[i]] = i ;\\n       }\\n        vector<int>v;\\n        for(auto x:mp){\\n          \\n            v.push_back(x.second);\\n        }\\n    \\n        int last=  v[0];\\n        long long d = 1; //items to be deleted now \\n        long long n = nums.size(); //size of current array \\n        if(v.size()==1) return op+1;\\n        for(int i = 1; i<v.size(); ++i){\\n            if(v[i]<last){\\n                op+=n ; //if index of the next smallest  element < last smallest element then we need to perform n operations to delete this \\n                n-=d; \\n                d=1;\\n                last= v[i];\\n                if(i==v.size()-1) op++;\\n            }\\n            else{\\n                \\n                d++;\\n                last=v[i];\\n                 if(i==v.size()-1) op+=n ;\\n            }\\n        }\\n        return op ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op =0;\\n        map<int,int>mp;\\n       for(int i = 0 ; i < nums.size() ; ++i){\\n           mp[nums[i]] = i ;\\n       }\\n        vector<int>v;\\n        for(auto x:mp){\\n          \\n            v.push_back(x.second);\\n        }\\n    \\n        int last=  v[0];\\n        long long d = 1; //items to be deleted now \\n        long long n = nums.size(); //size of current array \\n        if(v.size()==1) return op+1;\\n        for(int i = 1; i<v.size(); ++i){\\n            if(v[i]<last){\\n                op+=n ; //if index of the next smallest  element < last smallest element then we need to perform n operations to delete this \\n                n-=d; \\n                d=1;\\n                last= v[i];\\n                if(i==v.size()-1) op++;\\n            }\\n            else{\\n                \\n                d++;\\n                last=v[i];\\n                 if(i==v.size()-1) op+=n ;\\n            }\\n        }\\n        return op ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466953,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n log n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums){\\n        Map<Integer, Integer> nm = new HashMap<>();\\n        int n=nums.length,val=0;\\n        long ans=n;\\n        for(int i=0;i<n;i++)\\n        {\\n            nm.put(nums[i],i);\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nm.get(nums[i])<val)\\n            {\\n                ans+=n-i;\\n            }\\n            val=nm.get(nums[i]);\\n        }   \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums){\\n        Map<Integer, Integer> nm = new HashMap<>();\\n        int n=nums.length,val=0;\\n        long ans=n;\\n        for(int i=0;i<n;i++)\\n        {\\n            nm.put(nums[i],i);\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nm.get(nums[i])<val)\\n            {\\n                ans+=n-i;\\n            }\\n            val=nm.get(nums[i]);\\n        }   \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467389,
                "title": "python3-sortedlist-natural-approach",
                "content": "We can transform the problem into taking from a circular `positions` array of [0, 1, ..., N-1].  For example with A = [3, 4, -1], we take these values in sorted order (-1, 4, 3), so we want to take from positions [2, 0, 1].\\n\\nLet\\'s keep a `SortedList` of these positions.  When we transition from position `a` to position `b`, we need `(positions.index(b) - positions.index(a)) % len(positions)` rotation operations.  We use `i` and `j` to keep track of these `position.index`\\'es.\\n\\nWe also need to do `N` deletion operations, so `ans += N` at the end.\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, A: List[int]) -> int:\\n        N = len(A)\\n        locs = {v: i for i, v in enumerate(A)}\\n        positions = SortedList(range(N))\\n\\n        ans = i = 0\\n        for x in sorted(A):\\n            r = locs[x]\\n            j = positions.index(r)\\n            ans += (j - i) % len(positions)\\n            positions.pop(j)\\n            i = j\\n        return ans + N\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, A: List[int]) -> int:\\n        N = len(A)\\n        locs = {v: i for i, v in enumerate(A)}\\n        positions = SortedList(range(N))\\n\\n        ans = i = 0\\n        for x in sorted(A):\\n            r = locs[x]\\n            j = positions.index(r)\\n            ans += (j - i) % len(positions)\\n            positions.pop(j)\\n            i = j\\n        return ans + N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470229,
                "title": "concise-o-nlogn-solution-with-example-and-explanation-to-be-removed-at-which-round",
                "content": "**Motivation**\\nFirstly, I start solving this problem by *simulating the steps* and using a BIT-like approach. This approach will count how many moves before remove the next target element. You may find similar approaches in other posts. \\n\\nHere, I want to share another approach. i prefer to use the following description of the problem,\\n***Scan the array from left to right round after round (perhaps several rounds). An element is visited but not be deleted unless it is the smallest of all elements remained. Continue such process until nothing left.*** The core idea here is **to count how many rounds an element is visited before ultimately deleted from the array (i.e. at which round be deleted)** Actually, this approach will become so clear as long as you go step by step with the example below.\\n\\n*#update on Aprial 30 23:30 UTC+8, 2023*\\nJust read the approach of @votrubac https://leetcode.com/problems/make-array-empty/discuss/3466620/Count-Rotations-vs.-BIT\\nI think the idea are similar. Here, our approach is to check at which round the element is to be removed. In another way, we can count at each round how many elements are visited but not removed. I will show the calculation in the following example.\\n\\n**Example**\\nWe use an example: [4,2,3,1,5] to demonstrate the process of removing. Please keep in mind about which round an element is removed. Starting from Round K=0, we mean that this array has been scanned from the left end to the right end K time. \\n```\\nNotation:\\n$/current: index of the last element be removed\\n^/target : index of the element to be removed\\n\\nStep0:\\nInit current=-1, round {of scanning}=0\\n\\nStep1: current=-1, target=3, \"1\" to be removed\\n    Since target>current, we continue this round\\n    [4, 2, 3, 1, 5]\\n  $   ---->   ^\\n    Before removed, \"1\" has been visited for 0 times. (round=0)\\nStep2: current=3, target=1, \"2\" to be removed\\n    Since target<current, we need to go back the left end and start another round of scanning. round+=1\\n    [4, 2, 3, -, 5]  \\n        ^ <---$    \\n    Before removed, \"2\" has been visited for 1 times. (round=1)\\nStep3: current=1, target=2, \"3\" to be removed\\n    Since target>current, we continue this round\\n    [4, -, 3, -, 5]\\n        $->^\\n    Before removed, \"3\" has been visited for 1 times. (round=1)\\nStep4: current=2, target=0, \"4\" to be removed\\n    Since target<current, we need to go back the left end and start another round of scanning. round+=1\\n    [4, -, -, -, 5]   \\n     ^ <-- $          \\n    Before removed, \"4\" has been visited for 2 times. (round=2)\\nStep5: current=0, target=4, \"5\" to be removed\\n    Since target>current, we continue this round\\n    [-, -, -, -, 5]\\n     $   ---->   ^\\n    Before removed, \"5\" has been visited for 2 times. (round=2)\\n\\nConclusion: \\n------------------------------------------------------------\\nLet us  have some statistic here. V=visit, D=Delete\\n            [4,      2,      3,      1,      5]           \\nRound 0:     V       V       V       D       V   | 4 visit, 1 delete\\nRound 1:     V       D       D       -       V   | 2 visit, 2 delete\\nRound 2:     D       -       -       -       D   | 0 visit, 2 delete\\n------------------------------------------------------------\\n         R2/2V   R1/1V   R1/1V   R0/0V   R2/2V   | 6 visit, 5 delete\\n\\nVisited before removed:\\n    Column by column:  totally 2 +1 +1+0+2=6 times\\n    Row by row:        totaly 4+2=6 times\\nDeleted:   5 elements need 5 steps.\\nThe answer is 5+6\\n\\n#update on Aprial 30 23:30 UTC+8, 2023\\nOur approach do the calculation column by column. And, it is also valid to do the calculation row by row.\\n```\\n\\n**Algorithm**\\nI think you have got the idea. N elements need N steps to be removed. If an element is removed at round K, it was visited for K times additionally. We just need to identify this K.\\n\\n```\\n0. Initialize ROUND=0 and ANS=n\\n1. Scan the element from small to big (with sorting or something similar)\\n\\t1.1. Suppose the index of the last element is A and the index of the current element is B, increase ROUND by1 in case A>B\\n\\t2.2. ANS+=ROUND;\\n2. Return ANS.\\n\\nDone.\\n```\\n\\n**Complexity & Performance**\\n```\\nRuntime: 146 ms, faster than 100.00% of C++ online submissions for Make Array Empty.\\nMemory Usage: 68.4 MB, less than 100.00% of C++ online submissions for Make Array Empty.\\n\\nTime Complexity: O(N*LogN) [for sorting or something similar]\\n```\\n**Code**\\n```\\n#column calculation\\npair<int,int> num[100000];\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int n=nums.size();\\n        long long ans=n;\\n        for(int i=0; i<n; ++i) {\\n            num[i].first=nums[i];\\n            num[i].second=i;\\n        }\\n        sort(num, num+n);\\n        for(int i=0, j=1, round=0; j<n; ) {\\n            round+=num[j++].second<num[i++].second;\\n            ans+=round;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\n#row calculation\\npair<int,int> num[100000];\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int n=nums.size();\\n        long long ans=n;\\n        for(int i=0; i<n; ++i) {\\n            num[i].first=nums[i];\\n            num[i].second=i;\\n        }\\n        sort(num, num+n);\\n        for(int i=0, j=1; j<n;) {\\n            if(num[j++].second<num[i++].second) // start a new round, all remain elements are visited once more\\n                ans+=n-i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nNotation:\\n$/current: index of the last element be removed\\n^/target : index of the element to be removed\\n\\nStep0:\\nInit current=-1, round {of scanning}=0\\n\\nStep1: current=-1, target=3, \"1\" to be removed\\n    Since target>current, we continue this round\\n    [4, 2, 3, 1, 5]\\n  $   ---->   ^\\n    Before removed, \"1\" has been visited for 0 times. (round=0)\\nStep2: current=3, target=1, \"2\" to be removed\\n    Since target<current, we need to go back the left end and start another round of scanning. round+=1\\n    [4, 2, 3, -, 5]  \\n        ^ <---$    \\n    Before removed, \"2\" has been visited for 1 times. (round=1)\\nStep3: current=1, target=2, \"3\" to be removed\\n    Since target>current, we continue this round\\n    [4, -, 3, -, 5]\\n        $->^\\n    Before removed, \"3\" has been visited for 1 times. (round=1)\\nStep4: current=2, target=0, \"4\" to be removed\\n    Since target<current, we need to go back the left end and start another round of scanning. round+=1\\n    [4, -, -, -, 5]   \\n     ^ <-- $          \\n    Before removed, \"4\" has been visited for 2 times. (round=2)\\nStep5: current=0, target=4, \"5\" to be removed\\n    Since target>current, we continue this round\\n    [-, -, -, -, 5]\\n     $   ---->   ^\\n    Before removed, \"5\" has been visited for 2 times. (round=2)\\n\\nConclusion: \\n------------------------------------------------------------\\nLet us  have some statistic here. V=visit, D=Delete\\n            [4,      2,      3,      1,      5]           \\nRound 0:     V       V       V       D       V   | 4 visit, 1 delete\\nRound 1:     V       D       D       -       V   | 2 visit, 2 delete\\nRound 2:     D       -       -       -       D   | 0 visit, 2 delete\\n------------------------------------------------------------\\n         R2/2V   R1/1V   R1/1V   R0/0V   R2/2V   | 6 visit, 5 delete\\n\\nVisited before removed:\\n    Column by column:  totally 2 +1 +1+0+2=6 times\\n    Row by row:        totaly 4+2=6 times\\nDeleted:   5 elements need 5 steps.\\nThe answer is 5+6\\n\\n#update on Aprial 30 23:30 UTC+8, 2023\\nOur approach do the calculation column by column. And, it is also valid to do the calculation row by row.\\n```\n```\\n0. Initialize ROUND=0 and ANS=n\\n1. Scan the element from small to big (with sorting or something similar)\\n\\t1.1. Suppose the index of the last element is A and the index of the current element is B, increase ROUND by1 in case A>B\\n\\t2.2. ANS+=ROUND;\\n2. Return ANS.\\n\\nDone.\\n```\n```\\nRuntime: 146 ms, faster than 100.00% of C++ online submissions for Make Array Empty.\\nMemory Usage: 68.4 MB, less than 100.00% of C++ online submissions for Make Array Empty.\\n\\nTime Complexity: O(N*LogN) [for sorting or something similar]\\n```\n```\\n#column calculation\\npair<int,int> num[100000];\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int n=nums.size();\\n        long long ans=n;\\n        for(int i=0; i<n; ++i) {\\n            num[i].first=nums[i];\\n            num[i].second=i;\\n        }\\n        sort(num, num+n);\\n        for(int i=0, j=1, round=0; j<n; ) {\\n            round+=num[j++].second<num[i++].second;\\n            ans+=round;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n#row calculation\\npair<int,int> num[100000];\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int n=nums.size();\\n        long long ans=n;\\n        for(int i=0; i<n; ++i) {\\n            num[i].first=nums[i];\\n            num[i].second=i;\\n        }\\n        sort(num, num+n);\\n        for(int i=0, j=1; j<n;) {\\n            if(num[j++].second<num[i++].second) // start a new round, all remain elements are visited once more\\n                ans+=n-i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466677,
                "title": "c-fenwick-tree-with-explanation",
                "content": "Here all the elements are distinct,thus answer is equal to n(size of array) plus the number of values greater than the bigger value between any pair of adjacent values in sorted array.\\nBasically, if array is {1,5,6,2} the sorted array is {1,2,5,6} \\nNow, initially ans=4 (length of array,i.e. the step where we remove this element)\\nFirst pair of adjacent values in sorted arry is {1,2}, so ans=4+2(since there are two values 5 and 6 greater than value 2 present between these values).\\nNext pair is {2,5} ,ans=6+0 (no value greater than 5 between 2 and 5)\\nLast pair is {5,6} ans=6+0.\\nthus ans=6.\\n**NOTE**: We need count of values between smaller and greater ,not the other way around.\\n**NOTE** We only need greater values since smaller values have been removed in previous operations.\\n```\\nclass Solution {\\npublic:\\n    const int maxi=1e5+2;\\n    int sum(int v,vector<int> &BIT){\\n        int sum=0,i=v;\\n        for(;i>0;i-=i&(-i))\\n            sum+=BIT[i];\\n        return sum;\\n    }\\n    \\n    void update(int v,vector<int> &BIT){\\n        for(int i=v+1;i<maxi;i+=i&(-i))\\n            ++BIT[i];\\n    }\\n    \\nlong long countOperationsToEmptyArray(vector<int>& arr) {\\n        long long ans=arr.size();\\n        int n=arr.size();\\n    vector<int> aux(n);\\n    for(int i=0;i<n;i++) aux[i]=arr[i];\\n        sort(aux.begin(),aux.end());\\n        map<int,int>mp,pos;\\n    for(int i=0;i<n;i++) mp[aux[i]]=i+1;\\n    for(int i=0;i<n;i++) {\\n        pos[mp[arr[i]]]=i;\\n        arr[i]=mp[arr[i]];\\n        \\n                         }\\n    vector<int> BIT(maxi,0);\\n    vector<int>cnt(n,0);\\n    for(int i=0;i<n;i++){\\n        int x=sum(arr[i],BIT);\\n        cnt[i]=i-x;\\n        update(arr[i],BIT);\\n    }\\n    ans=ans+(pos[1])*1ll;\\n    for(int i=1;i<n;i++){\\n        int x=pos[i],y=pos[i+1];\\n        if(x>y){\\n            int tot=n+1-i;\\n            tot=tot-(cnt[x]-cnt[y]+1);\\n            ans=ans+tot*1ll;\\n        }\\n        else{\\n            ans=ans+(cnt[y]-cnt[x])*1ll;\\n        }\\n    }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int maxi=1e5+2;\\n    int sum(int v,vector<int> &BIT){\\n        int sum=0,i=v;\\n        for(;i>0;i-=i&(-i))\\n            sum+=BIT[i];\\n        return sum;\\n    }\\n    \\n    void update(int v,vector<int> &BIT){\\n        for(int i=v+1;i<maxi;i+=i&(-i))\\n            ++BIT[i];\\n    }\\n    \\nlong long countOperationsToEmptyArray(vector<int>& arr) {\\n        long long ans=arr.size();\\n        int n=arr.size();\\n    vector<int> aux(n);\\n    for(int i=0;i<n;i++) aux[i]=arr[i];\\n        sort(aux.begin(),aux.end());\\n        map<int,int>mp,pos;\\n    for(int i=0;i<n;i++) mp[aux[i]]=i+1;\\n    for(int i=0;i<n;i++) {\\n        pos[mp[arr[i]]]=i;\\n        arr[i]=mp[arr[i]];\\n        \\n                         }\\n    vector<int> BIT(maxi,0);\\n    vector<int>cnt(n,0);\\n    for(int i=0;i<n;i++){\\n        int x=sum(arr[i],BIT);\\n        cnt[i]=i-x;\\n        update(arr[i],BIT);\\n    }\\n    ans=ans+(pos[1])*1ll;\\n    for(int i=1;i<n;i++){\\n        int x=pos[i],y=pos[i+1];\\n        if(x>y){\\n            int tot=n+1-i;\\n            tot=tot-(cnt[x]-cnt[y]+1);\\n            ans=ans+tot*1ll;\\n        }\\n        else{\\n            ans=ans+(cnt[y]-cnt[x])*1ll;\\n        }\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466961,
                "title": "c-100-faster-most-optimized-solution",
                "content": "````\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n         long long cnt = 1;// for counting answer\\n        int n = nums.size();\\n        vector <pair <int,int>> res;\\n        for(int i = 0; i < n; i++) {\\n            res.push_back({nums[i], i});\\n        }\\n        sort(res.begin(), res.end());// sorting\\n        int j = 2;\\n        //checking weather condition is matched\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(res[i].second > res[i + 1].second) {\\n                cnt += j;\\n            }\\n            else {\\n                cnt += 1;\\n            }\\n            j += 1;\\n        }\\n        return cnt;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n         long long cnt = 1;// for counting answer\\n        int n = nums.size();\\n        vector <pair <int,int>> res;\\n        for(int i = 0; i < n; i++) {\\n            res.push_back({nums[i], i});\\n        }\\n        sort(res.begin(), res.end());// sorting\\n        int j = 2;\\n        //checking weather condition is matched\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(res[i].second > res[i + 1].second) {\\n                cnt += j;\\n            }\\n            else {\\n                cnt += 1;\\n            }\\n            j += 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514715,
                "title": "greedy-solution-sorting-an-observation",
                "content": "# Intuition\\nTake the case when the array is sorted in descending order:\\n```\\nnums=[5,4,3,2,1]\\n```\\n1 is removed after performing = **5 operations**\\n```\\n1-> [4,3,2,1,5]\\n2-> [3,2,1,5,4]\\n3-> [2,1,5,4,3]\\n4-> [1,5,4,3,2]\\n5-> [5,4,3,2]\\n```\\n# The observation is, isn\\'t the number of steps required to remove 1 equal to the length of the array\\nFor the array: $$[5,4,3,2]$$, the steps required to remove 2 are= \\n4\\n=or current length of this array $$[5,4,3,2]$$\\n=or length of original array - numbers removed so far $$[1]$$\\n\\nThis is how the $$n-m$$ approach is used. \\nIf the array is sorted, you only need $$n$$ steps.\\nOr you first remove the numbers that are in sorted order, for ex:\\n```\\nnums1=[1,4,2,7,3,9,10]\\n```\\n\\nFor this array, perform this operation= **Place the element at the first index at the last index.**\\nAfter **2** such operations, $$nums1$$ will look like:\\n```\\n[2,7,3,9,10,1,4]\\n```\\nAfter $$nums1.length$$ steps, the array will look like the original nums1 array. The relation of this step with the steps in our question is, if the element you are sending at the last index is the minimum number in the array, you remove it, or you still perform one operation, you just don\\'t count it in the end. \\n\\nOr performing the steps mentioned in the question(removing min at first index), after nums1.length steps, nums1 will look like:\\n```\\nnums1=[4,7,9,10]\\n[1,2,3] were present in sorted order, and were removed in the nums1.length operations\\n```\\n$$m$$ is nothing but the number of elements removed.\\nIf you were to perform the operations on $$[4,7,9,10]$$, you would need 4 steps until you were back to the original configuration. Fortunately, this trimmed nums1 is sorted, and our answer is:\\n```\\nN [First rotation]+ (N - m) [Second Rotation]\\n```\\nThe value of m will keep on incrementing in the case of a reverse sorted array. Or:\\n```\\nN +   N-1  +  N-2   + N-3 ...  +1\\n```\\n\\n\\n# Approach\\nInspired from - [cpcs\\'  solution](https://leetcode.com/problems/make-array-empty/solutions/3466731/just-sort-without-any-other-tricky-data-structures/?orderBy=most_votes) \\n\\nBuild array, $$nums$$ such that:\\n```\\nint[][] nums = new int[num.length][2];\\n// for array= [4,3]\\n// [4,0], [3,1]\\n// We will sort nums so that wehave a track of the original index \\n\\nfor(int i=0;i<num.length;i++){\\n    nums[i][0]=num[i];\\n    nums[i][1]=i;\\n    }\\nArrays.sort(nums,(a,b)->a[0]-b[0]);\\n//Sorting the array, second column will have a track of original index\\n```\\nThe loop:\\n```\\nfor(int i=0;i<nums.length;i++){\\n\\n    if(i>0 && nums[i][1]<nums[i-1][1]){\\n//Whenever this happens, you need to do n-m steps to start at the original array again\\n        ans+=nums.length-m;\\n        m=i;\\n//quick way to update m is by setting it to the current index instead of counting\\n    }      \\n}\\n```\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n $$O(n log n)$$ for sorting\\n\\n\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] num) {\\n        int[][] nums = new int[num.length][2];\\n        for(int i=0;i<num.length;i++){\\n            nums[i][0]=num[i];\\n            nums[i][1]=i;\\n        }\\n        Arrays.sort(nums,(a,b)->a[0]-b[0]);\\n        long ans=0;\\n        int m=0;\\n        for(int i=0;i<nums.length;i++){\\n\\n            if(i>0 && nums[i][1]<nums[i-1][1]){\\n                ans+=nums.length-m;\\n                m=i;\\n            }      \\n        }\\n        ans+=nums.length-m;\\n        return ans; \\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        nums = [[nums[i], i] for i in range(len(nums))]\\n        nums.sort()\\n        ans, m = 0, 0\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i][1] < nums[i-1][1]:\\n                ans += len(nums) - m\\n                m = i\\n        ans += len(nums) - m\\n        return ans\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    long countOperationsToEmptyArray(vector<int>& num) {\\n        vector<vector<int>> nums(num.size(), vector<int>(2));\\n        for(int i=0;i<num.size();i++){\\n            nums[i][0] = num[i];\\n            nums[i][1] = i;\\n        }\\n        sort(nums.begin(), nums.end(), [](vector<int>& a, vector<int>& b){return a[0] < b[0];});\\n        long ans = 0;\\n        int m = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i > 0 && nums[i][1] < nums[i-1][1]){\\n                ans += nums.size() - m;\\n                m = i;\\n            }\\n        }\\n        ans += nums.size() - m;\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nnums=[5,4,3,2,1]\\n```\n```\\n1-> [4,3,2,1,5]\\n2-> [3,2,1,5,4]\\n3-> [2,1,5,4,3]\\n4-> [1,5,4,3,2]\\n5-> [5,4,3,2]\\n```\n```\\nnums1=[1,4,2,7,3,9,10]\\n```\n```\\n[2,7,3,9,10,1,4]\\n```\n```\\nnums1=[4,7,9,10]\\n[1,2,3] were present in sorted order, and were removed in the nums1.length operations\\n```\n```\\nN [First rotation]+ (N - m) [Second Rotation]\\n```\n```\\nN +   N-1  +  N-2   + N-3 ...  +1\\n```\n```\\nint[][] nums = new int[num.length][2];\\n// for array= [4,3]\\n// [4,0], [3,1]\\n// We will sort nums so that wehave a track of the original index \\n\\nfor(int i=0;i<num.length;i++){\\n    nums[i][0]=num[i];\\n    nums[i][1]=i;\\n    }\\nArrays.sort(nums,(a,b)->a[0]-b[0]);\\n//Sorting the array, second column will have a track of original index\\n```\n```\\nfor(int i=0;i<nums.length;i++){\\n\\n    if(i>0 && nums[i][1]<nums[i-1][1]){\\n//Whenever this happens, you need to do n-m steps to start at the original array again\\n        ans+=nums.length-m;\\n        m=i;\\n//quick way to update m is by setting it to the current index instead of counting\\n    }      \\n}\\n```\n```Java []\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] num) {\\n        int[][] nums = new int[num.length][2];\\n        for(int i=0;i<num.length;i++){\\n            nums[i][0]=num[i];\\n            nums[i][1]=i;\\n        }\\n        Arrays.sort(nums,(a,b)->a[0]-b[0]);\\n        long ans=0;\\n        int m=0;\\n        for(int i=0;i<nums.length;i++){\\n\\n            if(i>0 && nums[i][1]<nums[i-1][1]){\\n                ans+=nums.length-m;\\n                m=i;\\n            }      \\n        }\\n        ans+=nums.length-m;\\n        return ans; \\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        nums = [[nums[i], i] for i in range(len(nums))]\\n        nums.sort()\\n        ans, m = 0, 0\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i][1] < nums[i-1][1]:\\n                ans += len(nums) - m\\n                m = i\\n        ans += len(nums) - m\\n        return ans\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    long countOperationsToEmptyArray(vector<int>& num) {\\n        vector<vector<int>> nums(num.size(), vector<int>(2));\\n        for(int i=0;i<num.size();i++){\\n            nums[i][0] = num[i];\\n            nums[i][1] = i;\\n        }\\n        sort(nums.begin(), nums.end(), [](vector<int>& a, vector<int>& b){return a[0] < b[0];});\\n        long ans = 0;\\n        int m = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i > 0 && nums[i][1] < nums[i-1][1]){\\n                ans += nums.size() - m;\\n                m = i;\\n            }\\n        }\\n        ans += nums.size() - m;\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505772,
                "title": "easy-optimized-solution-using-maximum-popular-programming-languages",
                "content": "```\\nPlease Up-Vote If This Helps You !!!\\n```\\n\\n# Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n log n)\\n\\nThe code first initializes an empty object `(map)` and assigns the length of nums to n and 0 to p. This takes constant time and space complexity `O(1)`.\\n\\nThe for loop starting from line 7 iterates over each element in nums, assigning the index of the element to the corresponding key in the map object. This takes `O(n)` time and `O(n)` space.\\n\\nThe code then sorts the nums array in ascending order using the built-in sort method. This takes `O(n log n)` time complexity.\\n\\nThe second for loop starting from line 10 iterates over each element in the sorted nums array. It first checks if the index of the current element in the map object is less than the previously encountered index p. If so, it adds the remaining unsorted elements to the answer variable. This operation takes `O(1)` time.\\n\\nOverall, the time complexity of the code is dominated by the sort method, which takes `O(n log n)` time complexity. Therefore, the overall time complexity of the code is `O(n log n)`.\\n# Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\nThe space complexity is `O(n)` because of the map object which stores the index of each element of nums, which can take up to n elements. The rest of the variables used in the code take constant space, so they do not add to the space complexity.\\n# Code\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countOperationsToEmptyArray = function(nums) {\\n    var map = {};\\n    var n = nums.length,p=0;\\n    var ans = n;\\n    for(let i = 0; i < n; i++){\\n        map[nums[i]] = i;\\n    }\\n    \\n    nums.sort((a,b) => a-b);\\n    for(let i = 0; i < n; p = map[nums[i++]]){\\n        if(map[nums[i]]<p){\\n            ans += n-i;\\n        }\\n    }\\n    return ans\\n};\\n```\\n```python []\\n    def countOperationsToEmptyArray(self, A: List[int]) -> int:\\n        n = len(A)\\n        pos = sorted(range(n), key=lambda i: A[i])\\n        return n + sum(n - i for i in range(1, n) if pos[i] < pos[i - 1])\\n```\\n```C []\\ntypedef struct {\\n    int value;\\n    int index;\\n} Pair;\\n\\nint compare(const void *a, const void *b) {\\n    return ((Pair*)a)->value - ((Pair*)b)->value;\\n}\\n\\nlong long countOperationsToEmptyArray(int* nums, int numsSize){\\n    Pair pairs[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n        pairs[i].value = nums[i];\\n        pairs[i].index = i;\\n    }\\n    qsort(pairs, numsSize, sizeof(Pair), compare);\\n    long long ans = numsSize;\\n    for (int i = 1; i < numsSize; i++) {\\n        if (pairs[i].index < pairs[i - 1].index) ans += numsSize - i;\\n    }\\n    return ans;\\n}\\n```\\n```Go []\\nfunc countOperationsToEmptyArray(nums []int) int64 {\\n    n := len(nums)\\n    indexed := make([][2]int, n)\\n    for i := range nums {\\n        indexed[i][0] = i+1\\n        indexed[i][1] = nums[i]\\n    }\\n    sort.Slice(indexed, func(i, j int) bool { return indexed[i][1] < indexed[j][1] })\\n    \\n    ans := int64(n)\\n    for i := 1; i < n; i++ {\\n        if indexed[i][0] < indexed[i-1][0] {\\n            ans += int64(n - i)\\n        }\\n    }\\n    return ans\\n}\\n```\\n```C# []\\npublic class Solution\\n{\\n    public long CountOperationsToEmptyArray(int[] nums)\\n    {\\n        var n = nums.Length;\\n        var ind = Enumerable.Range(0, n).ToArray();\\n\\n        Array.Sort(ind, (x, y) => nums[x].CompareTo(nums[y]));\\n        var m = n;\\n        var result = 0L;\\n\\n        for (int i = 1, last = 0; i < n; ++i)\\n            if (ind[i] < ind[i - 1])\\n            {\\n                result += m;\\n                m -= i - last;\\n                last = i;\\n            }\\n\\n        result += m;\\n\\n        return result;\\n    }\\n}\\n```\\n\\n\\n```C++ []\\n    public long countOperationsToEmptyArray(int[] A) {\\n        int n = A.length;\\n        Integer[] pos = new Integer[n];\\n        for (int i = 0; i < n; ++i)\\n            pos[i] = i;\\n        Arrays.sort(pos, (i, j) -> A[i] - A[j]);\\n        long res = n;\\n        for (int i = 1; i < n; ++i)\\n            if (pos[i] < pos[i - 1])\\n                res += n - i;\\n        return res;\\n    }\\n```\\n\\n```Kotlin []\\nclass Solution {\\n    fun countOperationsToEmptyArray(nums: IntArray): Long {\\n        val sortNums = Array(nums.size){IntArray(2)}\\n\\n        for (i in nums.indices) {\\n            sortNums[i][0] = nums[i]\\n            sortNums[i][1] = i\\n        }\\n        sortNums.sortBy{ it[0] }\\n\\n        var res = 0L + nums.size\\n        for (i in 1..sortNums.lastIndex) {\\n            if (sortNums[i - 1][1] > sortNums[i][1])\\n                res += nums.size - i\\n        }\\n        \\n        return res\\n    }\\n}\\n```\\n```Swift []\\nclass Solution {\\n    func countOperationsToEmptyArray(_ nums: [Int]) -> Int {\\n        let arr = nums.enumerated().sorted { $0.1 < $1.1 }\\n        var result = nums.count\\n        for i in arr.indices.dropLast() where arr[i].0 > arr[i+1].0 {\\n            result += nums.count - (i+1)\\n        }\\n        return result\\n    }\\n}\\n```\\n```scala []\\nobject Solution {\\n  def countOperationsToEmptyArray(nums: Array[Int]): Long = {\\n    val pos = nums.zipWithIndex.sorted.map(_._2)\\n    val rotations = pos.zipWithIndex.tail.zip(pos).map { case ((p, i), pp) => if (p < pp) nums.length - i else 0 }\\n    rotations.foldLeft(nums.length.toLong)(_ + _)\\n  }\\n}\\n```\\n```rust []\\nstruct Bit {\\n    nums: Vec<i32>,\\n}\\nimpl Bit {\\n    fn low_bit(i: usize) -> usize {\\n        return i & (!i + 1);\\n    }\\n    fn add(&mut self, mut i: usize, v: i32) {\\n        while i < self.nums.len() {\\n            self.nums[i] += v;\\n            i += Self::low_bit(i);\\n        }\\n    }\\n    fn query(&self, mut i: usize) -> i32 {\\n        let mut ans = 0;\\n        while i > 0 {\\n            ans += self.nums[i];\\n            i -= Self::low_bit(i);\\n        }\\n        return ans;\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn count_operations_to_empty_array(nums: Vec<i32>) -> i64 {\\n        let mut idx: Vec<usize> = (0..nums.len()).collect();\\n        idx.sort_by_key(|&id| nums[id]);\\n        let mut ans = 0;\\n        let mut pre = 0;\\n        let mut bit = Bit { nums: vec![0; nums.len() + 100] };\\n        for &i in idx.iter() {\\n            if i >= pre {\\n                let x1 = bit.query(pre);\\n                let x2 = bit.query(i + 1);\\n                ans += (i - pre) as i64 - (x2 - x1) as i64 + 1;\\n            } else {\\n                let x = bit.query(i + 1) + (bit.query(nums.len()) - bit.query(pre));\\n                ans += (i + nums.len() - pre) as i64 - x as i64 + 1;\\n            }\\n            bit.add(i + 1, 1);\\n            pre = i;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n\\n```java []\\n    public long countOperationsToEmptyArray(int[] A) {\\n        int n = A.length;\\n        Integer[] pos = new Integer[n];\\n        for (int i = 0; i < n; ++i)\\n            pos[i] = i;\\n        Arrays.sort(pos, (i, j) -> A[i] - A[j]);\\n        long res = n;\\n        for (int i = 1; i < n; ++i)\\n            if (pos[i] < pos[i - 1])\\n                res += n - i;\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nPlease Up-Vote If This Helps You !!!\\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countOperationsToEmptyArray = function(nums) {\\n    var map = {};\\n    var n = nums.length,p=0;\\n    var ans = n;\\n    for(let i = 0; i < n; i++){\\n        map[nums[i]] = i;\\n    }\\n    \\n    nums.sort((a,b) => a-b);\\n    for(let i = 0; i < n; p = map[nums[i++]]){\\n        if(map[nums[i]]<p){\\n            ans += n-i;\\n        }\\n    }\\n    return ans\\n};\\n```\n```python []\\n    def countOperationsToEmptyArray(self, A: List[int]) -> int:\\n        n = len(A)\\n        pos = sorted(range(n), key=lambda i: A[i])\\n        return n + sum(n - i for i in range(1, n) if pos[i] < pos[i - 1])\\n```\n```C []\\ntypedef struct {\\n    int value;\\n    int index;\\n} Pair;\\n\\nint compare(const void *a, const void *b) {\\n    return ((Pair*)a)->value - ((Pair*)b)->value;\\n}\\n\\nlong long countOperationsToEmptyArray(int* nums, int numsSize){\\n    Pair pairs[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n        pairs[i].value = nums[i];\\n        pairs[i].index = i;\\n    }\\n    qsort(pairs, numsSize, sizeof(Pair), compare);\\n    long long ans = numsSize;\\n    for (int i = 1; i < numsSize; i++) {\\n        if (pairs[i].index < pairs[i - 1].index) ans += numsSize - i;\\n    }\\n    return ans;\\n}\\n```\n```Go []\\nfunc countOperationsToEmptyArray(nums []int) int64 {\\n    n := len(nums)\\n    indexed := make([][2]int, n)\\n    for i := range nums {\\n        indexed[i][0] = i+1\\n        indexed[i][1] = nums[i]\\n    }\\n    sort.Slice(indexed, func(i, j int) bool { return indexed[i][1] < indexed[j][1] })\\n    \\n    ans := int64(n)\\n    for i := 1; i < n; i++ {\\n        if indexed[i][0] < indexed[i-1][0] {\\n            ans += int64(n - i)\\n        }\\n    }\\n    return ans\\n}\\n```\n```C# []\\npublic class Solution\\n{\\n    public long CountOperationsToEmptyArray(int[] nums)\\n    {\\n        var n = nums.Length;\\n        var ind = Enumerable.Range(0, n).ToArray();\\n\\n        Array.Sort(ind, (x, y) => nums[x].CompareTo(nums[y]));\\n        var m = n;\\n        var result = 0L;\\n\\n        for (int i = 1, last = 0; i < n; ++i)\\n            if (ind[i] < ind[i - 1])\\n            {\\n                result += m;\\n                m -= i - last;\\n                last = i;\\n            }\\n\\n        result += m;\\n\\n        return result;\\n    }\\n}\\n```\n```C++ []\\n    public long countOperationsToEmptyArray(int[] A) {\\n        int n = A.length;\\n        Integer[] pos = new Integer[n];\\n        for (int i = 0; i < n; ++i)\\n            pos[i] = i;\\n        Arrays.sort(pos, (i, j) -> A[i] - A[j]);\\n        long res = n;\\n        for (int i = 1; i < n; ++i)\\n            if (pos[i] < pos[i - 1])\\n                res += n - i;\\n        return res;\\n    }\\n```\n```Kotlin []\\nclass Solution {\\n    fun countOperationsToEmptyArray(nums: IntArray): Long {\\n        val sortNums = Array(nums.size){IntArray(2)}\\n\\n        for (i in nums.indices) {\\n            sortNums[i][0] = nums[i]\\n            sortNums[i][1] = i\\n        }\\n        sortNums.sortBy{ it[0] }\\n\\n        var res = 0L + nums.size\\n        for (i in 1..sortNums.lastIndex) {\\n            if (sortNums[i - 1][1] > sortNums[i][1])\\n                res += nums.size - i\\n        }\\n        \\n        return res\\n    }\\n}\\n```\n```Swift []\\nclass Solution {\\n    func countOperationsToEmptyArray(_ nums: [Int]) -> Int {\\n        let arr = nums.enumerated().sorted { $0.1 < $1.1 }\\n        var result = nums.count\\n        for i in arr.indices.dropLast() where arr[i].0 > arr[i+1].0 {\\n            result += nums.count - (i+1)\\n        }\\n        return result\\n    }\\n}\\n```\n```scala []\\nobject Solution {\\n  def countOperationsToEmptyArray(nums: Array[Int]): Long = {\\n    val pos = nums.zipWithIndex.sorted.map(_._2)\\n    val rotations = pos.zipWithIndex.tail.zip(pos).map { case ((p, i), pp) => if (p < pp) nums.length - i else 0 }\\n    rotations.foldLeft(nums.length.toLong)(_ + _)\\n  }\\n}\\n```\n```rust []\\nstruct Bit {\\n    nums: Vec<i32>,\\n}\\nimpl Bit {\\n    fn low_bit(i: usize) -> usize {\\n        return i & (!i + 1);\\n    }\\n    fn add(&mut self, mut i: usize, v: i32) {\\n        while i < self.nums.len() {\\n            self.nums[i] += v;\\n            i += Self::low_bit(i);\\n        }\\n    }\\n    fn query(&self, mut i: usize) -> i32 {\\n        let mut ans = 0;\\n        while i > 0 {\\n            ans += self.nums[i];\\n            i -= Self::low_bit(i);\\n        }\\n        return ans;\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn count_operations_to_empty_array(nums: Vec<i32>) -> i64 {\\n        let mut idx: Vec<usize> = (0..nums.len()).collect();\\n        idx.sort_by_key(|&id| nums[id]);\\n        let mut ans = 0;\\n        let mut pre = 0;\\n        let mut bit = Bit { nums: vec![0; nums.len() + 100] };\\n        for &i in idx.iter() {\\n            if i >= pre {\\n                let x1 = bit.query(pre);\\n                let x2 = bit.query(i + 1);\\n                ans += (i - pre) as i64 - (x2 - x1) as i64 + 1;\\n            } else {\\n                let x = bit.query(i + 1) + (bit.query(nums.len()) - bit.query(pre));\\n                ans += (i + nums.len() - pre) as i64 - x as i64 + 1;\\n            }\\n            bit.add(i + 1, 1);\\n            pre = i;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```java []\\n    public long countOperationsToEmptyArray(int[] A) {\\n        int n = A.length;\\n        Integer[] pos = new Integer[n];\\n        for (int i = 0; i < n; ++i)\\n            pos[i] = i;\\n        Arrays.sort(pos, (i, j) -> A[i] - A[j]);\\n        long res = n;\\n        for (int i = 1; i < n; ++i)\\n            if (pos[i] < pos[i - 1])\\n                res += n - i;\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467161,
                "title": "tle-accepted-easy-approach-with-explaination",
                "content": "# Complexity\\n- Time complexity:\\nO(N log(N)) for sorting array\\n\\n- Space complexity:\\nO(N) for storing elements in hashmap\\n\\n# Code\\n```\\n//gives Time-Limit Exceeded TLE\\nclass Solution {\\npublic long countOperationsToEmptyArray(int[] nums) {\\n        //storing elements in ascending order\\n         PriorityQueue<Integer> pq=new PriorityQueue<Integer>();\\n         for(int i=0;i<nums.length;i++){\\n             pq.offer(nums[i]);\\n         }\\n        \\n        // storing elements in queue\\n         Queue<Integer> q=new LinkedList<>();\\n         for(int i=0;i<nums.length;i++){\\n             q.offer(nums[i]);\\n         }\\n         long operation=0;\\n        //until queue is empty\\n         while(!q.isEmpty()){\\n            //if top element of pq matches with q, then pop it\\n             if(pq.peek()==q.peek()){\\n                 pq.poll();\\n                 q.poll();\\n             }\\n            //else pop it from q and add it to last of q\\n             else{\\n                 int num=q.poll();\\n                 q.offer(num);\\n             }\\n            //increase operation by 1\\n             operation++;\\n         }\\n         return operation;\\n      }\\n}\\n```\\n```\\n//accepted solution\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        //storing position of original elements\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],i);\\n        }\\n        //sorting array in ascending order\\n        Arrays.sort(nums);\\n        long ans=nums.length;\\n        int m=0;\\n        for(int i=0;i<nums.length;i++){\\n            int original_pos=map.get(nums[i]);\\n            //if original position of current element is less,\\n            //that means operations have been performed\\n             if(original_pos<m){\\n                ans+=(nums.length-i);\\n            }\\n            m=map.get(nums[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//gives Time-Limit Exceeded TLE\\nclass Solution {\\npublic long countOperationsToEmptyArray(int[] nums) {\\n        //storing elements in ascending order\\n         PriorityQueue<Integer> pq=new PriorityQueue<Integer>();\\n         for(int i=0;i<nums.length;i++){\\n             pq.offer(nums[i]);\\n         }\\n        \\n        // storing elements in queue\\n         Queue<Integer> q=new LinkedList<>();\\n         for(int i=0;i<nums.length;i++){\\n             q.offer(nums[i]);\\n         }\\n         long operation=0;\\n        //until queue is empty\\n         while(!q.isEmpty()){\\n            //if top element of pq matches with q, then pop it\\n             if(pq.peek()==q.peek()){\\n                 pq.poll();\\n                 q.poll();\\n             }\\n            //else pop it from q and add it to last of q\\n             else{\\n                 int num=q.poll();\\n                 q.offer(num);\\n             }\\n            //increase operation by 1\\n             operation++;\\n         }\\n         return operation;\\n      }\\n}\\n```\n```\\n//accepted solution\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        //storing position of original elements\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],i);\\n        }\\n        //sorting array in ascending order\\n        Arrays.sort(nums);\\n        long ans=nums.length;\\n        int m=0;\\n        for(int i=0;i<nums.length;i++){\\n            int original_pos=map.get(nums[i]);\\n            //if original position of current element is less,\\n            //that means operations have been performed\\n             if(original_pos<m){\\n                ans+=(nums.length-i);\\n            }\\n            m=map.get(nums[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466684,
                "title": "subtract-overcount-when-wrapping-around",
                "content": "# Intuition\\nIntuition:\\nIf the problem is simplied such that the smallest number, instead of being removed, is only marked, then the solution is simply to do index sort and then suming up differences (index[i + 1] - index[i] + 1, when index[i + 1] > index[i]. or index[i + 1] + len(nums) - index[i] + 1 when index[i] > index[i + 1])\\n\\nThe additional condition that we remove the the smallest remaining number doesn\\'t change the process that much. The key difference being, when calculating index differences, we have to discount the removed indexes (index[i + 1] - index[i] + 1 - num_removed_indexes[index[i]:index[i + 1]], when index[i + 1] > index[i] )\\n\\nThe naive way of tracking all removed indexes in a boolean array would result in o(n) look up and times out as there are o(n) removes, totalling to o(n^2) complexity.\\n\\nThe key insight is that between each \\'wrapping around\\', if we calculate moves as if numbers are marked instead of removed, the overcount is always the number of indexs we removed already in previous loop. Therefore, we never have to actually deal with removed indexes until \\'wrapping around\\', during which we can easily track and query number of removed indexes in o(1). \\n\\n![IMG-0172.jpg](https://assets.leetcode.com/users/images/0ca944bf-ef4d-46e4-bf1b-4032e0253c2f_1682784289.5164747.jpeg)\\n\\nEdit: forgot about the sorting in complexity lol. o(nlgn)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        sorted_index = [i[0] for i in sorted(enumerate(nums), key=lambda x:x[1])]\\n        s = 0\\n        curr = 0\\n        curr_loop_subtract = 0\\n        looped_subtract = 0\\n        for ind in sorted_index:\\n            if curr <= ind:\\n                s += ind - curr + 1\\n                curr = ind + 1\\n                curr_loop_subtract += 1\\n            else:#wrap around\\n                s += ind + (len(nums) - curr) + 1\\n                curr = ind + 1\\n                s -= looped_subtract\\n                looped_subtract += curr_loop_subtract \\n                curr_loop_subtract = 1\\n        s -= (curr - curr_loop_subtract) \\n        return s\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        sorted_index = [i[0] for i in sorted(enumerate(nums), key=lambda x:x[1])]\\n        s = 0\\n        curr = 0\\n        curr_loop_subtract = 0\\n        looped_subtract = 0\\n        for ind in sorted_index:\\n            if curr <= ind:\\n                s += ind - curr + 1\\n                curr = ind + 1\\n                curr_loop_subtract += 1\\n            else:#wrap around\\n                s += ind + (len(nums) - curr) + 1\\n                curr = ind + 1\\n                s -= looped_subtract\\n                looped_subtract += curr_loop_subtract \\n                curr_loop_subtract = 1\\n        s -= (curr - curr_loop_subtract) \\n        return s\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466631,
                "title": "python-heap-fenwick-tree-o-nlogn",
                "content": "# Code\\n```\\nfrom heapq import heapify, heappop\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        tree = [0]*(n+1)\\n        \\n        def update(tree, i, delta):\\n            while i <= n:\\n                tree[i] += delta\\n                i += i&-i\\n        \\n        def query(tree, i):\\n            res = 0\\n            while i > 0:\\n                res += tree[i]\\n                i -= i&-i\\n            return res\\n        \\n        for i in range(n):\\n            update(tree, i+1, 1)\\n        \\n        heap = [(num, i) for i, num in enumerate(nums)]\\n        heapify(heap)\\n        i = 0\\n        res = 0\\n        while heap:\\n            v, j = heappop(heap)\\n            if j+1 > i:\\n                res +=  query(tree, j+1) - query(tree, i) \\n            else:\\n                res += query(tree, n) - query(tree, i) + query(tree, j+1)\\n            update(tree, j+1, -1)\\n            i = j + 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heapify, heappop\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        tree = [0]*(n+1)\\n        \\n        def update(tree, i, delta):\\n            while i <= n:\\n                tree[i] += delta\\n                i += i&-i\\n        \\n        def query(tree, i):\\n            res = 0\\n            while i > 0:\\n                res += tree[i]\\n                i -= i&-i\\n            return res\\n        \\n        for i in range(n):\\n            update(tree, i+1, 1)\\n        \\n        heap = [(num, i) for i, num in enumerate(nums)]\\n        heapify(heap)\\n        i = 0\\n        res = 0\\n        while heap:\\n            v, j = heappop(heap)\\n            if j+1 > i:\\n                res +=  query(tree, j+1) - query(tree, i) \\n            else:\\n                res += query(tree, n) - query(tree, i) + query(tree, j+1)\\n            update(tree, j+1, -1)\\n            i = j + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473659,
                "title": "using-segment-tree-to-count-operations-in-java",
                "content": "```\\nclass Solution {\\n    int[] seg;\\n    void build(int index,int start,int end){\\n        if(start==end){\\n            seg[index] = 1;\\n            return;\\n        }\\n        int mid = (start+end)/2;\\n        build(2*index,start,mid);\\n        build(2*index+1,mid+1,end);\\n        seg[index] = seg[2*index]+seg[2*index+1];\\n    }\\n    int query(int index,int start,int end,int left,int right){\\n        if(left>right) return 0;\\n        if(right<start || left>end) return 0;\\n        if(left<=start && end<=right) return seg[index];\\n        int mid = (start+end)/2;\\n        int l = query(index*2,start,mid,left,right);\\n        int r = query(index*2+1,mid+1,end,left,right);\\n        return l+r;\\n    }\\n    void update(int index,int start,int end,int pos){\\n        if(pos<start || pos>end) return;\\n        if(pos==start && pos==end){\\n            seg[index] = 0; \\n            return;\\n        }\\n        int mid = (start+end)/2;\\n        update(index*2,start,mid,pos);\\n        update(index*2+1,mid+1,end,pos);\\n        seg[index] = seg[2*index]+seg[2*index+1];\\n    }\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n = nums.length;\\n        int[][] numsI = new int[n][2];\\n        for(int i=0; i<nums.length; i++){\\n            numsI[i][0] = nums[i];\\n            numsI[i][1] = i;\\n        }\\n        Arrays.sort(numsI,(a,b)->(a[0]-b[0]));\\n        seg = new int[4*n];\\n        build(1,0,n-1);\\n        int prev = -1;\\n        int index = 0;\\n        long ans = 0;\\n        while(index<n-1){\\n            int curIndex = numsI[index][1];\\n            if(curIndex>prev){\\n                int present = query(1,0,n-1,prev+1,curIndex-1);\\n                ans+=(present+1);\\n            }else{\\n                int present = query(1,0,n-1,prev+1,n-1);\\n                present+=query(1,0,n-1,0,curIndex-1);\\n                ans+=(present+1);\\n            }\\n            index++;\\n            update(1,0,n-1,curIndex);\\n            prev = curIndex;\\n        }\\n        return ans+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    int[] seg;\\n    void build(int index,int start,int end){\\n        if(start==end){\\n            seg[index] = 1;\\n            return;\\n        }\\n        int mid = (start+end)/2;\\n        build(2*index,start,mid);\\n        build(2*index+1,mid+1,end);\\n        seg[index] = seg[2*index]+seg[2*index+1];\\n    }\\n    int query(int index,int start,int end,int left,int right){\\n        if(left>right) return 0;\\n        if(right<start || left>end) return 0;\\n        if(left<=start && end<=right) return seg[index];\\n        int mid = (start+end)/2;\\n        int l = query(index*2,start,mid,left,right);\\n        int r = query(index*2+1,mid+1,end,left,right);\\n        return l+r;\\n    }\\n    void update(int index,int start,int end,int pos){\\n        if(pos<start || pos>end) return;\\n        if(pos==start && pos==end){\\n            seg[index] = 0; \\n            return;\\n        }\\n        int mid = (start+end)/2;\\n        update(index*2,start,mid,pos);\\n        update(index*2+1,mid+1,end,pos);\\n        seg[index] = seg[2*index]+seg[2*index+1];\\n    }\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n = nums.length;\\n        int[][] numsI = new int[n][2];\\n        for(int i=0; i<nums.length; i++){\\n            numsI[i][0] = nums[i];\\n            numsI[i][1] = i;\\n        }\\n        Arrays.sort(numsI,(a,b)->(a[0]-b[0]));\\n        seg = new int[4*n];\\n        build(1,0,n-1);\\n        int prev = -1;\\n        int index = 0;\\n        long ans = 0;\\n        while(index<n-1){\\n            int curIndex = numsI[index][1];\\n            if(curIndex>prev){\\n                int present = query(1,0,n-1,prev+1,curIndex-1);\\n                ans+=(present+1);\\n            }else{\\n                int present = query(1,0,n-1,prev+1,n-1);\\n                present+=query(1,0,n-1,0,curIndex-1);\\n                ans+=(present+1);\\n            }\\n            index++;\\n            update(1,0,n-1,curIndex);\\n            prev = curIndex;\\n        }\\n        return ans+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467476,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Sorting\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> pos;\\n        for(int i = 0; i < n; i++) pos[nums[i]] = i;\\n        sort(nums.begin(), nums.end());\\n        long long ans = n;\\n        for(int i = 1; i < n; i++) {\\n            if(pos[nums[i]] < pos[nums[i - 1]]) ans += n - i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> pos;\\n        for(int i = 0; i < n; i++) pos[nums[i]] = i;\\n        sort(nums.begin(), nums.end());\\n        long long ans = n;\\n        for(int i = 1; i < n; i++) {\\n            if(pos[nums[i]] < pos[nums[i - 1]]) ans += n - i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467230,
                "title": "kotlin-o-nlogn-using-sorting",
                "content": "# Approach\\nCreate new array sortNums where `sortnums[i][0]` is each element from `nums` and `sortnums[i][1]` is its index in the original `nums`. We then sort `sortNums` by element.\\n\\nWe initialize `res` to `nums.size`, because it will take at least `nums.size` operations to delete all elements, if `nums` would have been sorted in order.\\n\\nThen traverse from 1 to last index in `sortNums`:\\n\\nIf the index (corresponding to the original sorting in `nums`) of previous is higher than current (e.g sortNums[i - 1][1] > sortNums[i][1]), then it will take `n.size - i` operations for that num to get deleted, so we add those operations to `res`.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    fun countOperationsToEmptyArray(nums: IntArray): Long {\\n        val sortNums = Array(nums.size){IntArray(2)}\\n\\n        for (i in nums.indices) {\\n            sortNums[i][0] = nums[i]\\n            sortNums[i][1] = i\\n        }\\n        sortNums.sortBy{ it[0] }\\n\\n        var res = 0L + nums.size\\n        for (i in 1..sortNums.lastIndex) {\\n            if (sortNums[i - 1][1] > sortNums[i][1])\\n                res += nums.size - i\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    fun countOperationsToEmptyArray(nums: IntArray): Long {\\n        val sortNums = Array(nums.size){IntArray(2)}\\n\\n        for (i in nums.indices) {\\n            sortNums[i][0] = nums[i]\\n            sortNums[i][1] = i\\n        }\\n        sortNums.sortBy{ it[0] }\\n\\n        var res = 0L + nums.size\\n        for (i in 1..sortNums.lastIndex) {\\n            if (sortNums[i - 1][1] > sortNums[i][1])\\n                res += nums.size - i\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466976,
                "title": "priority-queue-deque-brute-but-tle",
                "content": "1. We push all elemnt in priority queue to get min \\n2. We insert all element in deque for easy O(1) push_front and push_back (since we need to return count)\\n3. if first elm is min we pop from priority queue and don\\'t touch deque \\n4. else we pop from front and push it back in deque\\n5. Rest code is self explanatory ......\\n\\n```\\nlong long countOperationsToEmptyArray(vector<int>& nums) {\\n        deque<int> dq(nums.begin(), nums.end());\\n        priority_queue<int,vector<int>,greater<int> >pq(nums.begin(), nums.end());\\n        long long ans = 0;\\n        \\n        while(!dq.empty()){\\n            \\n            if(dq.front() == pq.top()){\\n                pq.pop();\\n                dq.pop_front();\\n            }\\n            else{\\n                int elem = dq.front();\\n                dq.pop_front();\\n                dq.push_back(elem);\\n            }\\n            ans++;\\n        }\\n        return\\xA0ans;\\n\\xA0\\xA0\\xA0\\xA0}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long countOperationsToEmptyArray(vector<int>& nums) {\\n        deque<int> dq(nums.begin(), nums.end());\\n        priority_queue<int,vector<int>,greater<int> >pq(nums.begin(), nums.end());\\n        long long ans = 0;\\n        \\n        while(!dq.empty()){\\n            \\n            if(dq.front() == pq.top()){\\n                pq.pop();\\n                dq.pop_front();\\n            }\\n            else{\\n                int elem = dq.front();\\n                dq.pop_front();\\n                dq.push_back(elem);\\n            }\\n            ans++;\\n        }\\n        return\\xA0ans;\\n\\xA0\\xA0\\xA0\\xA0}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466945,
                "title": "very-easy-and-concise-solution-with-only-sort-python",
                "content": "# Intuition\\nThe main idea was to understand how many times number will be moved to the end of list.\\nObservations:\\n1) minimun number will never be putted to the end\\n2) the next smallest element will be putted to the end only if it\\'s located before minimun\\n3) same with the thrid element - if it is located after scecond smallest it will be moved to the end only if second will be. \\nIf it is located before second smallest it will be putted to the end one more time\\n\\n# Approach\\nSo to solve the problem we just need to understand relative positions of adjusted elements of the sorted list.\\nSo we sort list by values + save their original indexes. Than we compare indexes of elements and take into account that the number of move for the following elemt equals:\\n- same number as the previous (if it\\'s located after this element)\\n- same number + 1 (if it\\'s located before elemnt)\\n- first element cnt = 0\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        num_ind = []\\n        for i, num in enumerate(nums):\\n            num_ind.append((num, i))\\n        \\n        num_ind.sort()\\n        \\n        count = len(num_ind)\\n        cur_cnt = 0\\n        for i in range(1, len(num_ind)):\\n            if num_ind[i][1] < num_ind[i-1][1]:\\n                cur_cnt += 1\\n            count += cur_cnt\\n        \\n        return count\\n                \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        num_ind = []\\n        for i, num in enumerate(nums):\\n            num_ind.append((num, i))\\n        \\n        num_ind.sort()\\n        \\n        count = len(num_ind)\\n        cur_cnt = 0\\n        for i in range(1, len(num_ind)):\\n            if num_ind[i][1] < num_ind[i-1][1]:\\n                cur_cnt += 1\\n            count += cur_cnt\\n        \\n        return count\\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490150,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) Performing the simulation results in TLE due to O(N<sup>2</sup>) runtime, thus for AC, we use a binary indexed tree (BIT) to accumulate the total `t` non-minimum values we \"rotate\" (dequeue from front + enqueue to back) from the input array `A` in order to dequeue each next minimum value from the front, ie. we use a map `m` to store each value\\'s index `i` and keep track of the `last` index `i` to determine if we need to wrap-around:\\n\\n* **Case 1: \\uD83D\\uDEAB wrap-around from `last` \\uD83D\\uDC49 `i`**\\n    * example: `A = [ \\uD83D\\uDEAB, \\uD83D\\uDEAB, \\uD83D\\uDEAB, last, \\u2705, \\u2705, \\u2705, i, \\uD83D\\uDEAB, \\uD83D\\uDEAB, \\uD83D\\uDEAB ]`\\n\\t* this use case is trivial, we simply accumulate the count of values between `last` non-inclusive to `i` non-inclusive\\n* **Case 2: \\u2705 wrap-around from `last` \\uD83D\\uDC49 `i`**\\n\\t* example: `A = [ \\u2705, \\u2705, \\u2705, i, \\uD83D\\uDEAB, \\uD83D\\uDEAB, \\uD83D\\uDEAB last, \\u2705, \\u2705, \\u2705 ]`\\n\\t* we accumulate the count of values between `last` non-inclusive to `N` non-inclusive *plus* the count of values between `0` inclusive to `i` non-inclusive\\n\\nWe return `N + t`, ie. each of the `N` values is dequeued once (each as a \"next minimum\" in ascending order) *plus* the total `t` \"rotations\"\\n\\n---\\n\\n*Kotlin*\\n```\\nclass BIT(A: IntArray) {\\n    var A: IntArray\\n    var S: LongArray\\n    var N: Int\\n    var prev = { i: Int -> i - (i and i.inv() + 1) }\\n    var next = { i: Int -> i + (i and i.inv() + 1) }\\n    init {\\n        this.A = A\\n        N = A.size\\n        S = LongArray(N + 1) { 0L }\\n        for (i in 0 until N) {\\n            var k = i + 1\\n            while (k <= N) {\\n                S[k] += A[i].toLong(); k = next(k)\\n            }\\n        }\\n    }\\n    fun update(i: Int, x: Int) {\\n        var diff = x - A[i]; A[i] = x\\n        var k = i + 1\\n        while (k <= N) {\\n            S[k] += diff.toLong(); k = next(k)\\n        }\\n    }\\n    fun query(i: Int): Long { return if (0 < i) S[i] + query(prev(i)) else 0L }\\n    var sum = { i: Int, j: Int -> query(j) - query(i) }  // [i..j), ie. from i inclusive to j non-inclusive\\n}\\nclass Solution {\\n    fun countOperationsToEmptyArray(A: IntArray): Long {\\n        var (N, t) = Pair(A.size, 0L)\\n        var (last, m) = Pair(-1, mutableMapOf<Int, Int>())\\n        for (i in 0 until N)\\n            m[A[i]] = i\\n        var bit = BIT(IntArray(N){ 1 })\\n        for (x in A.sorted()) {\\n            var i = m[x]!!\\n            if (last < i)\\n                t += bit.sum(last + 1, i)                  // case 1: \\uD83D\\uDEAB wrap-around from last \\uD83D\\uDC49 i\\n            else\\n                t += bit.sum(last + 1, N) + bit.sum(0, i)  // case 2: \\u2705 wrap-around from last \\uD83D\\uDC49 i\\n            bit.update(i, 0); last = i\\n        }\\n        return N + t\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nclass BIT {\\n    constructor(A) {\\n        this.A = [...A];\\n        this.N = this.A.length;\\n        this.S = Array(this.N + 1).fill(0);\\n        for (let i = 0; i < this.N; ++i)\\n            for (let k = i + 1; k <= this.N; k = this.next(k))\\n                this.S[k] += this.A[i];\\n    }\\n    update = (i, x) => {\\n        let diff = x - this.A[i]; this.A[i] = x;\\n        for (let k = i + 1; k <= this.N; k = this.next(k))\\n            this.S[k] += diff;\\n    }\\n    sum = (i, j) => this.query(j) - this.query(i);  // [i..j) ie. from i inclusive to j non-inclusive\\n    query = i => i ? this.S[i] + this.query(this.prev(i)) : 0;\\n    prev = i => i - (i & ~i + 1);\\n    next = i => i + (i & ~i + 1);\\n}\\nlet countOperationsToEmptyArray = (A, last = -1, t = 0) => {\\n    let N = A.length;\\n    let bit = new BIT(Array(N).fill(1));\\n    let m = new Map(A.map((x, i) => [x, i]));\\n    for (let x of A.sort((a, b) => a - b)) {\\n        let i = m.get(x);\\n        if (last < i)\\n            t += bit.sum(last + 1, i);                  // case 1: \\uD83D\\uDEAB wrap-around from last \\uD83D\\uDC49 i\\n        else\\n            t += bit.sum(last + 1, N) + bit.sum(0, i);  // case 2: \\u2705 wrap-around from last \\uD83D\\uDC49 i\\n        bit.update(i, 0), last = i;\\n    }\\n    return N + t;\\n};\\n```\\n\\n*Python3*\\n```\\nclass BIT:\\n    def __init__(self, A: List[int]):\\n        self.N = len(A)\\n        self.A, self.S = A[:], [0] * (self.N + 1)\\n        for i in range(self.N):\\n            k = i + 1\\n            while k <= self.N:\\n                self.S[k] += self.A[i]\\n                k = self.next(k)\\n\\n    def update(self, i: int, x: int) -> None:\\n        diff, self.A[i] = x - self.A[i], x\\n        k = i + 1\\n        while k <= self.N:\\n            self.S[k] += diff\\n            k = self.next(k)\\n\\n    sum = lambda self, i, j: self.query(j) - self.query(i)  # [i..j) ie. from i inclusive to j non-inclusive\\n    query = lambda self, i: self.S[i] + self.query(self.prev(i)) if i else 0\\n    prev = lambda self, i: i - (i & -i)\\n    next = lambda self, i: i + (i & -i)\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, A: List[int], last = -1, t = 0) -> int:\\n        N = len(A)\\n        bit = BIT([1] * N)\\n        m = {x: i for i, x in enumerate(A)}\\n        for x in sorted(A):\\n            i = m[x]\\n            if last < i:\\n                t += bit.sum(last + 1, i)                  # case 1: \\uD83D\\uDEAB wrap-around from last \\uD83D\\uDC49 i\\n            else:\\n                t += bit.sum(last + 1, N) + bit.sum(0, i)  # case 2: \\u2705 wrap-around from last \\uD83D\\uDC49 i\\n            bit.update(i, 0); last = i            \\n        return N + t\\n```\\n\\n*C++*\\n```\\nusing LL = long long;\\nusing VI = vector<int>;\\nusing VL = vector<LL>;\\nclass BIT {\\n    VI A; VL S; size_t N;\\n    int prev(int i) { return i - (i & -i); }\\n    int next(int i) { return i + (i & -i); }\\n    LL query(int i) { return i ? S[i] + query(prev(i)) : 0; }\\npublic:\\n    BIT(VI&& A) : A{ A }, S{ VL(A.size() + 1) }, N{ A.size() } {\\n        for (auto i{ 0 }; i < N; ++i)\\n            for (auto k{ i + 1 }; k <= N; k = next(k))\\n                S[k] += A[i];\\n    }\\n    void update(int i, int x) {\\n        auto diff = x - A[i]; A[i] = x;\\n        for (auto k{ i + 1 }; k <= N; k = next(k))\\n            S[k] += diff;\\n    }\\n    LL sum(int i, int j) { return query(j) - query(i); }  // [i..j) ie. from i inclusive to j non-inclusive\\n};\\nclass Solution {\\npublic:\\n    using Map = unordered_map<int, int>;\\n    LL countOperationsToEmptyArray(VI& A, Map m = {}, int last = -1, LL t = 0) {\\n        auto N = A.size();\\n        BIT bit(VI(N, 1));\\n        for (auto i{ 0 }; i < N; ++i)\\n            m[A[i]] = i;\\n        sort(A.begin(), A.end());\\n        for (auto x: A) {\\n            auto i = m[x];\\n            if (last < i)\\n                t += bit.sum(last + 1, i);                  // case 1: \\uD83D\\uDEAB wrap-around from last \\uD83D\\uDC49 i\\n            else\\n                t += bit.sum(last + 1, N) + bit.sum(0, i);  // case 2: \\u2705 wrap-around from last \\uD83D\\uDC49 i\\n            bit.update(i, 0), last = i;\\n        }\\n        return N + t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass BIT(A: IntArray) {\\n    var A: IntArray\\n    var S: LongArray\\n    var N: Int\\n    var prev = { i: Int -> i - (i and i.inv() + 1) }\\n    var next = { i: Int -> i + (i and i.inv() + 1) }\\n    init {\\n        this.A = A\\n        N = A.size\\n        S = LongArray(N + 1) { 0L }\\n        for (i in 0 until N) {\\n            var k = i + 1\\n            while (k <= N) {\\n                S[k] += A[i].toLong(); k = next(k)\\n            }\\n        }\\n    }\\n    fun update(i: Int, x: Int) {\\n        var diff = x - A[i]; A[i] = x\\n        var k = i + 1\\n        while (k <= N) {\\n            S[k] += diff.toLong(); k = next(k)\\n        }\\n    }\\n    fun query(i: Int): Long { return if (0 < i) S[i] + query(prev(i)) else 0L }\\n    var sum = { i: Int, j: Int -> query(j) - query(i) }  // [i..j), ie. from i inclusive to j non-inclusive\\n}\\nclass Solution {\\n    fun countOperationsToEmptyArray(A: IntArray): Long {\\n        var (N, t) = Pair(A.size, 0L)\\n        var (last, m) = Pair(-1, mutableMapOf<Int, Int>())\\n        for (i in 0 until N)\\n            m[A[i]] = i\\n        var bit = BIT(IntArray(N){ 1 })\\n        for (x in A.sorted()) {\\n            var i = m[x]!!\\n            if (last < i)\\n                t += bit.sum(last + 1, i)                  // case 1: \\uD83D\\uDEAB wrap-around from last \\uD83D\\uDC49 i\\n            else\\n                t += bit.sum(last + 1, N) + bit.sum(0, i)  // case 2: \\u2705 wrap-around from last \\uD83D\\uDC49 i\\n            bit.update(i, 0); last = i\\n        }\\n        return N + t\\n    }\\n}\\n```\n```\\nclass BIT {\\n    constructor(A) {\\n        this.A = [...A];\\n        this.N = this.A.length;\\n        this.S = Array(this.N + 1).fill(0);\\n        for (let i = 0; i < this.N; ++i)\\n            for (let k = i + 1; k <= this.N; k = this.next(k))\\n                this.S[k] += this.A[i];\\n    }\\n    update = (i, x) => {\\n        let diff = x - this.A[i]; this.A[i] = x;\\n        for (let k = i + 1; k <= this.N; k = this.next(k))\\n            this.S[k] += diff;\\n    }\\n    sum = (i, j) => this.query(j) - this.query(i);  // [i..j) ie. from i inclusive to j non-inclusive\\n    query = i => i ? this.S[i] + this.query(this.prev(i)) : 0;\\n    prev = i => i - (i & ~i + 1);\\n    next = i => i + (i & ~i + 1);\\n}\\nlet countOperationsToEmptyArray = (A, last = -1, t = 0) => {\\n    let N = A.length;\\n    let bit = new BIT(Array(N).fill(1));\\n    let m = new Map(A.map((x, i) => [x, i]));\\n    for (let x of A.sort((a, b) => a - b)) {\\n        let i = m.get(x);\\n        if (last < i)\\n            t += bit.sum(last + 1, i);                  // case 1: \\uD83D\\uDEAB wrap-around from last \\uD83D\\uDC49 i\\n        else\\n            t += bit.sum(last + 1, N) + bit.sum(0, i);  // case 2: \\u2705 wrap-around from last \\uD83D\\uDC49 i\\n        bit.update(i, 0), last = i;\\n    }\\n    return N + t;\\n};\\n```\n```\\nclass BIT:\\n    def __init__(self, A: List[int]):\\n        self.N = len(A)\\n        self.A, self.S = A[:], [0] * (self.N + 1)\\n        for i in range(self.N):\\n            k = i + 1\\n            while k <= self.N:\\n                self.S[k] += self.A[i]\\n                k = self.next(k)\\n\\n    def update(self, i: int, x: int) -> None:\\n        diff, self.A[i] = x - self.A[i], x\\n        k = i + 1\\n        while k <= self.N:\\n            self.S[k] += diff\\n            k = self.next(k)\\n\\n    sum = lambda self, i, j: self.query(j) - self.query(i)  # [i..j) ie. from i inclusive to j non-inclusive\\n    query = lambda self, i: self.S[i] + self.query(self.prev(i)) if i else 0\\n    prev = lambda self, i: i - (i & -i)\\n    next = lambda self, i: i + (i & -i)\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, A: List[int], last = -1, t = 0) -> int:\\n        N = len(A)\\n        bit = BIT([1] * N)\\n        m = {x: i for i, x in enumerate(A)}\\n        for x in sorted(A):\\n            i = m[x]\\n            if last < i:\\n                t += bit.sum(last + 1, i)                  # case 1: \\uD83D\\uDEAB wrap-around from last \\uD83D\\uDC49 i\\n            else:\\n                t += bit.sum(last + 1, N) + bit.sum(0, i)  # case 2: \\u2705 wrap-around from last \\uD83D\\uDC49 i\\n            bit.update(i, 0); last = i            \\n        return N + t\\n```\n```\\nusing LL = long long;\\nusing VI = vector<int>;\\nusing VL = vector<LL>;\\nclass BIT {\\n    VI A; VL S; size_t N;\\n    int prev(int i) { return i - (i & -i); }\\n    int next(int i) { return i + (i & -i); }\\n    LL query(int i) { return i ? S[i] + query(prev(i)) : 0; }\\npublic:\\n    BIT(VI&& A) : A{ A }, S{ VL(A.size() + 1) }, N{ A.size() } {\\n        for (auto i{ 0 }; i < N; ++i)\\n            for (auto k{ i + 1 }; k <= N; k = next(k))\\n                S[k] += A[i];\\n    }\\n    void update(int i, int x) {\\n        auto diff = x - A[i]; A[i] = x;\\n        for (auto k{ i + 1 }; k <= N; k = next(k))\\n            S[k] += diff;\\n    }\\n    LL sum(int i, int j) { return query(j) - query(i); }  // [i..j) ie. from i inclusive to j non-inclusive\\n};\\nclass Solution {\\npublic:\\n    using Map = unordered_map<int, int>;\\n    LL countOperationsToEmptyArray(VI& A, Map m = {}, int last = -1, LL t = 0) {\\n        auto N = A.size();\\n        BIT bit(VI(N, 1));\\n        for (auto i{ 0 }; i < N; ++i)\\n            m[A[i]] = i;\\n        sort(A.begin(), A.end());\\n        for (auto x: A) {\\n            auto i = m[x];\\n            if (last < i)\\n                t += bit.sum(last + 1, i);                  // case 1: \\uD83D\\uDEAB wrap-around from last \\uD83D\\uDC49 i\\n            else\\n                t += bit.sum(last + 1, N) + bit.sum(0, i);  // case 2: \\u2705 wrap-around from last \\uD83D\\uDC49 i\\n            bit.update(i, 0), last = i;\\n        }\\n        return N + t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468984,
                "title": "using-map-and-sorting-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        unordered_map<int, int>m;\\n        int n=A.size();\\n        long long ans=n;\\n        for (int i = 0; i < n; ++i)\\n            m[A[i]] = i;\\n        sort(A.begin(), A.end());\\n        for (int i = 1; i < n; ++i)\\n            if (m[A[i]] < m[A[i - 1]])\\n                ans += n - i;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        unordered_map<int, int>m;\\n        int n=A.size();\\n        long long ans=n;\\n        for (int i = 0; i < n; ++i)\\n            m[A[i]] = i;\\n        sort(A.begin(), A.end());\\n        for (int i = 1; i < n; ++i)\\n            if (m[A[i]] < m[A[i - 1]])\\n                ans += n - i;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467830,
                "title": "swift-analyze-indexed-sort",
                "content": "**Analyze Indexed Sort (accepted answer)**\\n```\\nclass Solution {\\n    func countOperationsToEmptyArray(_ nums: [Int]) -> Int {\\n        let arr = nums.enumerated().sorted { $0.1 < $1.1 }\\n        var result = nums.count\\n        for i in arr.indices.dropLast() where arr[i].0 > arr[i+1].0 {\\n            result += nums.count - (i+1)\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countOperationsToEmptyArray(_ nums: [Int]) -> Int {\\n        let arr = nums.enumerated().sorted { $0.1 < $1.1 }\\n        var result = nums.count\\n        for i in arr.indices.dropLast() where arr[i].0 > arr[i+1].0 {\\n            result += nums.count - (i+1)\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467350,
                "title": "beats-100-simple-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        q=[]\\n        for i,j in enumerate(nums):\\n            q.append([j,i])\\n        q.sort()\\n        n=len(nums)\\n        ans=n\\n        for i in range(1,len(nums)):\\n            if(q[i][1]<q[i-1][1]):\\n                ans+=(n-i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        q=[]\\n        for i,j in enumerate(nums):\\n            q.append([j,i])\\n        q.sort()\\n        n=len(nums)\\n        ans=n\\n        for i in range(1,len(nums)):\\n            if(q[i][1]<q[i-1][1]):\\n                ans+=(n-i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467030,
                "title": "100-simple-sort-o-nlogn-using-only-if-statements",
                "content": "# Approach\\nSort in ascending order of the element values. Then, for each pair in the sorted vector, I keep track of two variables: \"sum\" and \"cnt\". I initialize \"sum\" to the size of the input array and \"cnt\" to 1.\\n\\nI then check whether the current element\\'s index is greater than the previous element\\'s index. If it is, I increment \"cnt\" to count another element whose value is equal to its index. If not, I add the number of remaining elements in the array to \"sum\" (which is equal to the total size of the array minus \"cnt\"), and increment \"cnt\" to count this element.\\n\\nFinally, \"sum\" contains the number of operations needed to empty the array, which is returned by the code. Overall, this implementation is more optimized than the original one as it avoids using a priority queue, which has a higher overhead than a simple vector.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    typedef long long ll;    \\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int nn = nums.size();\\n        ll n = (ll)nn;\\n        vector<pair<int,int>>vec;\\n        for(int i=0;i<n;i++){\\n            vec.push_back({nums[i],i});\\n        }\\n        sort(vec.begin(),vec.end());\\n        ll sum = n;\\n        ll cnt = 1LL;\\n        for(int i=1;i<nn;i++){\\n            if(vec[i].second > vec[i-1].second){\\n                cnt++;                \\n            }\\n            else{\\n                sum += (ll)(n-cnt);\\n                cnt++;                \\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    typedef long long ll;    \\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int nn = nums.size();\\n        ll n = (ll)nn;\\n        vector<pair<int,int>>vec;\\n        for(int i=0;i<n;i++){\\n            vec.push_back({nums[i],i});\\n        }\\n        sort(vec.begin(),vec.end());\\n        ll sum = n;\\n        ll cnt = 1LL;\\n        for(int i=1;i<nn;i++){\\n            if(vec[i].second > vec[i-1].second){\\n                cnt++;                \\n            }\\n            else{\\n                sum += (ll)(n-cnt);\\n                cnt++;                \\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467007,
                "title": "c-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n*log(n))$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> x(n);\\n        for (int i=0;i<n;i++) {\\n            x[i]=i;\\n        }\\n        sort(x.begin(), x.end(),[&](int a,int b) {\\n            return nums[a]<nums[b];\\n        });\\n        int m=n,l=0;\\n        long long ans=0;\\n        for (int i=1;i<n;i++) {\\n            if(x[i]<x[i-1]){\\n                ans+=m;\\n                m-=i-l;\\n                l=i; \\n            }\\n        }\\n        return ans+m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> x(n);\\n        for (int i=0;i<n;i++) {\\n            x[i]=i;\\n        }\\n        sort(x.begin(), x.end(),[&](int a,int b) {\\n            return nums[a]<nums[b];\\n        });\\n        int m=n,l=0;\\n        long long ans=0;\\n        for (int i=1;i<n;i++) {\\n            if(x[i]<x[i-1]){\\n                ans+=m;\\n                m-=i-l;\\n                l=i; \\n            }\\n        }\\n        return ans+m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466958,
                "title": "c-intution-o-n-logn-easy-to-understand-segment-tree",
                "content": "Intution :- Don\\'t rotate the array just keep track of previous smaller element\\'s index\\nand current smaller element index (using map) and find remaining elements between them. For which we can use segment tree.\\n\\nThere are two cases :-\\n1.When previous elements index(a) is smaller than current element\\'s index(b)-\\n  find remaining element between a and b ( query from index a to b)\\n2.else :-\\n   find remaining element between 0 to b and a to nums.size() and add them.\\n   \\n Note:- Find elements in exclusive manner \\n\\nTC-O(n*logn)\\nSC-O(4*n)\\n\\n```\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> st;\\n\\n    void build(int i, int l, int h)\\n    {\\n        if (l == h)\\n        {\\n            st[i] = 1;\\n            return;\\n        }\\n        int md = (l + h) / 2;\\n        build(2 * i + 1, l, md);\\n        build(2 * i + 2, md + 1, h);\\n        st[i] = st[2 * i + 1] + st[2 * i + 2];\\n    }\\n    int query(int i, int l, int h, int rl, int rh)\\n    {\\n        if (rl > rh)\\n            return 0;\\n        if (l >= rl && h <= rh)\\n            return st[i];\\n        if (l > rh || h < rl)\\n            return 0;\\n        int md = (l + h) / 2;\\n        return query(2 * i + 1, l, md, rl, rh) + query(2 * i + 2, md + 1, h, rl, rh);\\n    }\\n    void update(int i, int l, int h, int id)\\n    {\\n\\n        if (id == l && id == h)\\n        {\\n            st[i] = 0;\\n            return;\\n        }\\n        int m = (l + h) / 2;\\n        if (id <= m)\\n            update(2 * i + 1, l, m, id);\\n        else\\n            update(2 * i + 2, m + 1, h, id);\\n        st[i] = st[2 * i + 1] + st[2 * i + 2];\\n    }\\n\\n    long long countOperationsToEmptyArray(vector<int> &nums)\\n    {\\n        map<int, int> mp;\\n        for (int i = 0; i < nums.size(); i++)\\n            mp[nums[i]] = i;\\n        int c = -1;\\n        int n = nums.size();\\n        auto it = mp.begin();\\n        long long ans = 0;\\n        st.resize(4 * nums.size());\\n        build(0, 0, nums.size() - 1);\\n        while (n > 1 && it != mp.end())\\n        {\\n\\n            if (it->second >= c)\\n            {\\n                int x = query(0, 0, nums.size() - 1, c + 1, it->second - 1);\\n                ans += x + 1;\\n            }\\n\\n            else\\n            {\\n                // ans+=(n+1)-c+it->second+1;\\n                int x = query(0, 0, nums.size() - 1, 0, it->second - 1);\\n                int y = query(0, 0, nums.size() - 1, c + 1, nums.size() - 1);\\n                ans += x + y + 1;\\n            }\\n            update(0, 0, nums.size() - 1, it->second);\\n            c = it->second;\\n            n--;\\n            it++;\\n           \\n        }\\n    \\n        return ans + 1;\\n    }\\n};\\n\\n```\\n\\nIf you like it then please upvote!",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> st;\\n\\n    void build(int i, int l, int h)\\n    {\\n        if (l == h)\\n        {\\n            st[i] = 1;\\n            return;\\n        }\\n        int md = (l + h) / 2;\\n        build(2 * i + 1, l, md);\\n        build(2 * i + 2, md + 1, h);\\n        st[i] = st[2 * i + 1] + st[2 * i + 2];\\n    }\\n    int query(int i, int l, int h, int rl, int rh)\\n    {\\n        if (rl > rh)\\n            return 0;\\n        if (l >= rl && h <= rh)\\n            return st[i];\\n        if (l > rh || h < rl)\\n            return 0;\\n        int md = (l + h) / 2;\\n        return query(2 * i + 1, l, md, rl, rh) + query(2 * i + 2, md + 1, h, rl, rh);\\n    }\\n    void update(int i, int l, int h, int id)\\n    {\\n\\n        if (id == l && id == h)\\n        {\\n            st[i] = 0;\\n            return;\\n        }\\n        int m = (l + h) / 2;\\n        if (id <= m)\\n            update(2 * i + 1, l, m, id);\\n        else\\n            update(2 * i + 2, m + 1, h, id);\\n        st[i] = st[2 * i + 1] + st[2 * i + 2];\\n    }\\n\\n    long long countOperationsToEmptyArray(vector<int> &nums)\\n    {\\n        map<int, int> mp;\\n        for (int i = 0; i < nums.size(); i++)\\n            mp[nums[i]] = i;\\n        int c = -1;\\n        int n = nums.size();\\n        auto it = mp.begin();\\n        long long ans = 0;\\n        st.resize(4 * nums.size());\\n        build(0, 0, nums.size() - 1);\\n        while (n > 1 && it != mp.end())\\n        {\\n\\n            if (it->second >= c)\\n            {\\n                int x = query(0, 0, nums.size() - 1, c + 1, it->second - 1);\\n                ans += x + 1;\\n            }\\n\\n            else\\n            {\\n                // ans+=(n+1)-c+it->second+1;\\n                int x = query(0, 0, nums.size() - 1, 0, it->second - 1);\\n                int y = query(0, 0, nums.size() - 1, c + 1, nums.size() - 1);\\n                ans += x + y + 1;\\n            }\\n            update(0, 0, nums.size() - 1, it->second);\\n            c = it->second;\\n            n--;\\n            it++;\\n           \\n        }\\n    \\n        return ans + 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466827,
                "title": "easy-sorting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nfirst we have to store all element index position ,that\\'s why we make vector of pair int ,int.\\nafter that we sort , so that all element are arrange ascending order. atleast one element , so cnt start with 1.\\nj=2 because i start with less 2 index.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n         long long cnt = 1;// for counting answer\\n        int n = nums.size();\\n        vector <pair <int,int>> res;\\n        for(int i = 0; i < n; i++) {\\n            res.push_back({nums[i], i});\\n        }\\n        sort(res.begin(), res.end());// sorting\\n        int j = 2;\\n        //checking weather condition is matched\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(res[i].second > res[i + 1].second) {\\n                cnt += j;\\n            }\\n            else {\\n                cnt += 1;\\n            }\\n            j += 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n         long long cnt = 1;// for counting answer\\n        int n = nums.size();\\n        vector <pair <int,int>> res;\\n        for(int i = 0; i < n; i++) {\\n            res.push_back({nums[i], i});\\n        }\\n        sort(res.begin(), res.end());// sorting\\n        int j = 2;\\n        //checking weather condition is matched\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(res[i].second > res[i + 1].second) {\\n                cnt += j;\\n            }\\n            else {\\n                cnt += 1;\\n            }\\n            j += 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512113,
                "title": "javascript-segment-tree",
                "content": "**Solution: Segment Tree**\\n\\nWe can think of it as a circular array.\\nThe order of the numbers will always stay the same in a circular sense. \\nThis means the distance between numbers will always stay the same except for when numbers are removed (even then the order stays the same).\\nBased on this understanding, instead of simulating moving the actual element around, we can count the number of moves by the differences in the sorted indexes.\\nThe distance between two numbers `(a, b)` will always be the same, with the two possible orders:\\n*   If `a` is in front of `b`: Distance is `b - a`\\n*   If `b` is in front of `a`: Distance is `(n-1 - b) + (a)`\\n\\nSort nums and map each `nums[i]` to the index in the sorted array.\\nFill the segment tree with `1`\\'s initially.\\nGo through each sorted `nums[i]` and get the distance difference with the previous index.\\n*   If `index > previousIndex`, count the sum in range `(previous index + 1, index)`.\\n*   If `index < previousIndex`, count the sum in range `(previous index + 1, n - 1)` + sum in range `(0, index)`\\n\\nAfter each `nums[i]`, update the element in the segment tree to be `0` to indicate removal.\\n\\nTime Complexity: `O(n log(n))` 399ms\\nSpace Complexity: `O(n)` 95.3MB\\n```\\nvar countOperationsToEmptyArray = function(nums) {\\n  let n = nums.length, segTree = new SegmentTree(Array(n).fill(1));\\n  nums = nums.map((num, index) => [num, index]).sort((a, b) => a[0] - b[0]);\\n  let prevIndex = -1, ans = 0;\\n  for (let [_num, index] of nums) {\\n    if (index >= prevIndex) {\\n      ans += segTree.sumRange(prevIndex + 1, index);\\n    } else {\\n      ans += segTree.sumRange(prevIndex + 1, n - 1) + segTree.sumRange(0, index);\\n    }\\n    segTree.update(index);\\n    prevIndex = index;\\n  }\\n  return ans;\\n};\\n\\nclass SegmentTree {\\n  constructor(arr) {\\n    let n = arr.length;\\n    this.size = n;\\n    this.segTree = Array(n * 2).fill(0);\\n    this.build(arr);\\n  }\\n  build(arr) {\\n    let n = this.size;\\n    for (let i = n; i < n * 2; i++) {\\n      this.segTree[i] = arr[i - n]; // populate leaf values\\n    }\\n    for (let i = n - 1; i > 0; i--) {\\n      this.segTree[i] = this.segTree[i * 2] + this.segTree[i * 2 + 1]; // sum\\n    }\\n  }\\n  update(index) {\\n    let n = this.size, idx = index + n;\\n    this.segTree[idx] = 0;\\n    idx = Math.floor(idx / 2);\\n\\n    while (idx > 0) {\\n      this.segTree[idx] = this.segTree[idx * 2] + this.segTree[idx * 2 + 1];\\n      idx = Math.floor(idx / 2);\\n    }\\n  }\\n  sumRange(left, right) {\\n    let n = this.size, sum = 0;\\n    let left_idx = left + n, right_idx = right + n;\\n    while (left_idx <= right_idx) {\\n      if (left_idx % 2 === 1) sum += this.segTree[left_idx++];\\n      if (right_idx % 2 === 0) sum += this.segTree[right_idx--];\\n      left_idx = Math.floor(left_idx / 2);\\n      right_idx = Math.floor(right_idx / 2);\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nvar countOperationsToEmptyArray = function(nums) {\\n  let n = nums.length, segTree = new SegmentTree(Array(n).fill(1));\\n  nums = nums.map((num, index) => [num, index]).sort((a, b) => a[0] - b[0]);\\n  let prevIndex = -1, ans = 0;\\n  for (let [_num, index] of nums) {\\n    if (index >= prevIndex) {\\n      ans += segTree.sumRange(prevIndex + 1, index);\\n    } else {\\n      ans += segTree.sumRange(prevIndex + 1, n - 1) + segTree.sumRange(0, index);\\n    }\\n    segTree.update(index);\\n    prevIndex = index;\\n  }\\n  return ans;\\n};\\n\\nclass SegmentTree {\\n  constructor(arr) {\\n    let n = arr.length;\\n    this.size = n;\\n    this.segTree = Array(n * 2).fill(0);\\n    this.build(arr);\\n  }\\n  build(arr) {\\n    let n = this.size;\\n    for (let i = n; i < n * 2; i++) {\\n      this.segTree[i] = arr[i - n]; // populate leaf values\\n    }\\n    for (let i = n - 1; i > 0; i--) {\\n      this.segTree[i] = this.segTree[i * 2] + this.segTree[i * 2 + 1]; // sum\\n    }\\n  }\\n  update(index) {\\n    let n = this.size, idx = index + n;\\n    this.segTree[idx] = 0;\\n    idx = Math.floor(idx / 2);\\n\\n    while (idx > 0) {\\n      this.segTree[idx] = this.segTree[idx * 2] + this.segTree[idx * 2 + 1];\\n      idx = Math.floor(idx / 2);\\n    }\\n  }\\n  sumRange(left, right) {\\n    let n = this.size, sum = 0;\\n    let left_idx = left + n, right_idx = right + n;\\n    while (left_idx <= right_idx) {\\n      if (left_idx % 2 === 1) sum += this.segTree[left_idx++];\\n      if (right_idx % 2 === 0) sum += this.segTree[right_idx--];\\n      left_idx = Math.floor(left_idx / 2);\\n      right_idx = Math.floor(right_idx / 2);\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474910,
                "title": "idiomatic-kotlin-with-comments-o-nlog-n-bonus-java-streams",
                "content": "# Complexity\\n- Time complexity: $$O(nlog(n))$$ required to sort `nums`.\\n\\n- Space complexity: $$O(1)$$\\n\\n# Kotlin Code\\n```\\nclass Solution {\\n    fun countOperationsToEmptyArray(nums: IntArray) =\\n        nums.size + // Number of remove operations we need to perform anyway\\n            nums.withIndex() // Map to pairs index:value\\n                .sortedBy { it.value } // Sort ascending by value\\n                .map { it.index } // Keep indices, drop values\\n                .windowed(size=2) // Slide window of size 2 and step 1\\n                .withIndex() // Map to pairs index:window\\n                // Ignore windows where lower element stands before \\n                // next bigger element.\\n                .filter { it.value[0] > it.value[1] }\\n                // Add number of shifts required to reach next element\\n                .map { nums.size - it.index - 1L }\\n                .sum() // Sum all shifts\\n}\\n\\n```\\n\\n# Java Code\\n```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int[] indices = IntStream.range(0, nums.length)\\n                .mapToObj(i -> new int[]{i, nums[i]})\\n                .sorted(Comparator.comparingInt(a -> a[1]))\\n                .mapToInt(a -> a[0])\\n                .toArray();\\n\\n        return nums.length + IntStream.range(1, indices.length)\\n                .filter(i -> indices[i - 1] > indices[i])\\n                .mapToLong(i -> nums.length - i)\\n                .sum();    \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin",
                    "Sort",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    fun countOperationsToEmptyArray(nums: IntArray) =\\n        nums.size + // Number of remove operations we need to perform anyway\\n            nums.withIndex() // Map to pairs index:value\\n                .sortedBy { it.value } // Sort ascending by value\\n                .map { it.index } // Keep indices, drop values\\n                .windowed(size=2) // Slide window of size 2 and step 1\\n                .withIndex() // Map to pairs index:window\\n                // Ignore windows where lower element stands before \\n                // next bigger element.\\n                .filter { it.value[0] > it.value[1] }\\n                // Add number of shifts required to reach next element\\n                .map { nums.size - it.index - 1L }\\n                .sum() // Sum all shifts\\n}\\n\\n```\n```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int[] indices = IntStream.range(0, nums.length)\\n                .mapToObj(i -> new int[]{i, nums[i]})\\n                .sorted(Comparator.comparingInt(a -> a[1]))\\n                .mapToInt(a -> a[0])\\n                .toArray();\\n\\n        return nums.length + IntStream.range(1, indices.length)\\n                .filter(i -> indices[i - 1] > indices[i])\\n                .mapToLong(i -> nums.length - i)\\n                .sum();    \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469261,
                "title": "ruby-o-nlogn-sort-one-pass",
                "content": "# Intuition\\nPerforming `nums.size` operations will retain the array order with some values removed. Counting the number of such cycles and the number of values removed will provide the answer.\\n \\n**Observations:**\\n1. Actual nums value doesn\\'t matter till the order of the elements is the same. `[3, 4, -1]` and `[3, 54, 0]` both will need 5 operations.\\n2. When performing the operation on the `k` smallest element in the array it will be removed only if `1..(k-1)` smallest elements are removed from the array. Since this rule is applied to all elements, it\\'s enough to know if `k-1` smallest element is already removed.\\n3. `k-1` and `k` smallest elements will be removed in the single cycle run if and only if the first one has a lower index in the array.\\n\\n# Approach\\n1. Convert array elements to their relative indexes in the sorted array\\n2. Pass through the array, memorizing if the previous element(in sorted order) has been already chosen for the cycle.\\n3. Count the number of cycles and number of elements\\n\\n# Example\\nLet\\'s check `[12, 42, 61, 58, 27, 33]`\\n1. Converting to the sorted indexes: `[1, 4, 6, 5, 2, 3]`\\n2. Passing using the code below will result in `[1, 4, 6, 4, 1, 1]`. Counting occurrences returns `{ 1 => 3, 4 => 2, 6 => 1 }`\\n3. First cycle will remove elements `12, 27, 33` and will take 6 operations. Second will remove `42, 58` in 3 operations. Last operation will remove 61 and make array empty. Total `6 + 3 + 1 = 10` operations. \\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(n)\\n# Code\\n```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef count_operations_to_empty_array(nums)\\n    pos_map = nums.sort.map.with_index { [_1, _2 + 1] }.to_h # Using 1-indexed positions so I don\\'t have to deal with negative index later\\n    nums_pos = nums.map { pos_map[_1] }\\n        \\n    mem = Array.new(nums.size + 1, nil)\\n    nums_pos.each do |pos|\\n        mem[pos] = mem[pos - 1] || pos\\n    end\\n    mem.shift\\n    \\n    res = 0\\n\\n    s = nums.size\\n    mem.tally.values.each do |val|\\n        res += s\\n        s -= val\\n    end\\n    \\n    res\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Array",
                    "Sort"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef count_operations_to_empty_array(nums)\\n    pos_map = nums.sort.map.with_index { [_1, _2 + 1] }.to_h # Using 1-indexed positions so I don\\'t have to deal with negative index later\\n    nums_pos = nums.map { pos_map[_1] }\\n        \\n    mem = Array.new(nums.size + 1, nil)\\n    nums_pos.each do |pos|\\n        mem[pos] = mem[pos - 1] || pos\\n    end\\n    mem.shift\\n    \\n    res = 0\\n\\n    s = nums.size\\n    mem.tally.values.each do |val|\\n        res += s\\n        s -= val\\n    end\\n    \\n    res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3467574,
                "title": "c-sort-then-count-out-of-order",
                "content": "1. sort indices according to indexed values\\n2. iterate sorted indices, \\n    - if in natural order, e.g. 0,1,2,3: just remove\\n    - otherwise, e.g 4,2: count and accumulate out of order\\n    - for each iterated index, current count is steps it needs to rotate.\\n3. finally add array size to the final steps, as we need to remove each once\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        vector<int> indices(nums.size());\\n        iota(indices.begin(), indices.end(), 0);\\n        sort(indices.begin(), indices.end(), [&nums](auto i, auto j) { return nums[i] < nums[j]; });\\n        long long steps = 0;\\n        for(int i = 0, j = 1, dec = 0; j < indices.size(); ++i, ++j) {\\n            if(indices[j] < indices[i])\\n                ++dec;\\n            steps += dec;\\n        }\\n        return steps + nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        vector<int> indices(nums.size());\\n        iota(indices.begin(), indices.end(), 0);\\n        sort(indices.begin(), indices.end(), [&nums](auto i, auto j) { return nums[i] < nums[j]; });\\n        long long steps = 0;\\n        for(int i = 0, j = 1, dec = 0; j < indices.size(); ++i, ++j) {\\n            if(indices[j] < indices[i])\\n                ++dec;\\n            steps += dec;\\n        }\\n        return steps + nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467540,
                "title": "fenwick-tree-o-nlogn-c",
                "content": "# Approach\\nThis is a Fenwick Tree based where I used Fenwick Tree to count the number of elements to be sent at the back of the array if i am currently at `c` and want to remove index `nxt[i]`, `nxt[i]` represents the index of ith smallest element in the array.\\n\\n# Complexity\\n- Time complexity: $$O(NlogN)$$\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define fi first\\n#define se second\\n#define pb push_back\\n#define ppb pop_back\\n#define all(a) a.begin(),a.end()\\nusing ll = long long;\\nusing vi = vector<int>;\\nusing vl = vector<ll>;\\nusing vb = vector<bool>;\\nusing pii = pair<int,int>;\\nusing pll = pair<ll,ll>;\\nconst int MOD = 1e9 + 7;\\nconst int iinf = 1e9;\\nll mod_a(ll a,ll b){a%=MOD;b%=MOD;return((a+b)%MOD);}\\nll mod_m(ll a,ll b){a%=MOD;b%=MOD;return((a*b)%MOD);}\\nll pow_m(ll a,ll b){a%=MOD;b%=(MOD-1);ll r = 1;\\nwhile(b){if(b&1){r=mod_m(r,a);}a=mod_m(a,a);b/=2;}return r;}\\nll mod_i(ll a){return pow_m(a,MOD-2);}\\nll mod_d(ll a,ll b){return mod_m(a,mod_i(b));}\\nll mod_s(ll a,ll b){a%=MOD;b%=MOD;return((((a-b)%MOD)+MOD)%MOD);}\\n\\nstruct Ftree{\\n    vl t; int n;\\n    Ftree(int _n) : n(_n + 1){\\n        t.assign(n, 0);\\n    }\\n    void U(int i,ll v){\\n        for(i++;i<n;i+=(i&-i))\\n            t[i] += v;\\n    }\\n    ll q(int i){\\n        int r = 0;\\n        for(i++;i>0;i-=(i&-i))r += t[i];\\n        return r;\\n    }\\n    ll Q(int l,int r){\\n        if(l>r)return 0;\\n        return q(r) - q(l-1);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size(), c = 0;\\n        vector<vi> S; vi nxI(n);\\n        for(int i=0;i<n;i++)S.pb({nums[i], i});\\n        sort(all(S));\\n        for(int i=0;i<n;i++)nxI[i] = S[i][1];\\n        Ftree Ft(n);\\n        for(int i=0;i<n;i++)Ft.U(i, 1);\\n        long long ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(nxI[i]>=c){\\n                ans += Ft.Q(c, nxI[i]);\\n            }else{\\n                ans += Ft.Q(c, n-1);\\n                ans += Ft.Q(0, nxI[i]);\\n            }\\n            c = nxI[i];\\n            Ft.U(nxI[i], -1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\n#define fi first\\n#define se second\\n#define pb push_back\\n#define ppb pop_back\\n#define all(a) a.begin(),a.end()\\nusing ll = long long;\\nusing vi = vector<int>;\\nusing vl = vector<ll>;\\nusing vb = vector<bool>;\\nusing pii = pair<int,int>;\\nusing pll = pair<ll,ll>;\\nconst int MOD = 1e9 + 7;\\nconst int iinf = 1e9;\\nll mod_a(ll a,ll b){a%=MOD;b%=MOD;return((a+b)%MOD);}\\nll mod_m(ll a,ll b){a%=MOD;b%=MOD;return((a*b)%MOD);}\\nll pow_m(ll a,ll b){a%=MOD;b%=(MOD-1);ll r = 1;\\nwhile(b){if(b&1){r=mod_m(r,a);}a=mod_m(a,a);b/=2;}return r;}\\nll mod_i(ll a){return pow_m(a,MOD-2);}\\nll mod_d(ll a,ll b){return mod_m(a,mod_i(b));}\\nll mod_s(ll a,ll b){a%=MOD;b%=MOD;return((((a-b)%MOD)+MOD)%MOD);}\\n\\nstruct Ftree{\\n    vl t; int n;\\n    Ftree(int _n) : n(_n + 1){\\n        t.assign(n, 0);\\n    }\\n    void U(int i,ll v){\\n        for(i++;i<n;i+=(i&-i))\\n            t[i] += v;\\n    }\\n    ll q(int i){\\n        int r = 0;\\n        for(i++;i>0;i-=(i&-i))r += t[i];\\n        return r;\\n    }\\n    ll Q(int l,int r){\\n        if(l>r)return 0;\\n        return q(r) - q(l-1);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size(), c = 0;\\n        vector<vi> S; vi nxI(n);\\n        for(int i=0;i<n;i++)S.pb({nums[i], i});\\n        sort(all(S));\\n        for(int i=0;i<n;i++)nxI[i] = S[i][1];\\n        Ftree Ft(n);\\n        for(int i=0;i<n;i++)Ft.U(i, 1);\\n        long long ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(nxI[i]>=c){\\n                ans += Ft.Q(c, nxI[i]);\\n            }else{\\n                ans += Ft.Q(c, n-1);\\n                ans += Ft.Q(0, nxI[i]);\\n            }\\n            c = nxI[i];\\n            Ft.U(nxI[i], -1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467430,
                "title": "bitch-ez-bit-sol",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums) -> int:\\n        mp=defaultdict(int)\\n        for id,i in enumerate(nums):\\n            mp[i]=id\\n        n=len(nums)\\n        bt=BIT(n)\\n        for i in range(n):\\n            bt.update(i,1)\\n        last=-1\\n        ans=0\\n        for i in sorted(nums):\\n            li=0\\n            bt.update(mp[i],-1)\\n            if last==-1:\\n                ans+=bt.sum(mp[i])+1\\n                last=mp[i]\\n            elif last<mp[i]:\\n                ans+=bt.sum(mp[i])-bt.sum(last)+1\\n                last=mp[i]\\n            elif last>mp[i]:\\n                li=bt.sum(n-1)-bt.sum(last)\\n                ans+=bt.sum(mp[i])+li+1\\n                last=mp[i]\\n                \\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums) -> int:\\n        mp=defaultdict(int)\\n        for id,i in enumerate(nums):\\n            mp[i]=id\\n        n=len(nums)\\n        bt=BIT(n)\\n        for i in range(n):\\n            bt.update(i,1)\\n        last=-1\\n        ans=0\\n        for i in sorted(nums):\\n            li=0\\n            bt.update(mp[i],-1)\\n            if last==-1:\\n                ans+=bt.sum(mp[i])+1\\n                last=mp[i]\\n            elif last<mp[i]:\\n                ans+=bt.sum(mp[i])-bt.sum(last)+1\\n                last=mp[i]\\n            elif last>mp[i]:\\n                li=bt.sum(n-1)-bt.sum(last)\\n                ans+=bt.sum(mp[i])+li+1\\n                last=mp[i]\\n                \\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467335,
                "title": "python-explanation-modulo-arithmetics-plus-binary-indexed-tree",
                "content": "# Intuition\\nYou cannot simply simulate the process with a deque, because at each step you could traverse the whole array (~n steps) and there would be `n` steps for each removal leading to $$O(n^2)$$\\n\\n# Approach\\nThe idea is to sort the numbers, while keeping their indices. Then visit each number in the increasing order and smartly calculate how many steps would be there **without actually doing these steps**\\n\\n# Without accounting for removal:\\nSo at the beginning we start at position `curPos = 0` and we need to reach the index `pos` of the smallest number. Easy, just subtract `pos - 0`. Likewise, if we start at any other position `curPos` we just take `pos - curPos` as the distance to travel. If we run off the array `nums` we just do it modulo `n` arithmetics: `steps = (n + pos - curPos) % n`.\\n\\n# Accounting for removed elements in the array:\\nThis is all true as long as we didn\\'t remove any numbers from the array. But we do! At every step we remove exactly one number. So to know how many `nums` indices have been removed we can keep a prefix array `prefSum[i]` which keeps the number of removed indices at `x` such `x<=i`, and do the usual trick with prefixSum: take the difference. \\nSo if we want do know how many indices were removed between `x` and `y` we do `prefSum[x] - prefSum[y]`.\\n\\n**The problem here is that we want to dynamically update `prefArray`. A structure to do it is Binary Indexed (or Fennwick) Tree.**\\nBelow I included a `BIT` class which implements BIT tree.\\n\\nWhen `pos >=curPos` we skip `bit.prefSum(pos) - bit.prefSum(curPos-1)` removed indices.\\n\\nWhat to do when we run off the array (i.e. `curPos > pos`)? We have to compute how many indices there were removed from `curPos` to the end of the array\\nThis is: `bit.prefSum(n-1) - bit.prefSum(curPos-1)`\\nAnd how many indices have been removed from the beginning of the array to `pos`.\\nThis is `bit.prefSum(pos)`\\n\\nSo from the number of `steps` if there were no removed indices we have to subtract the numbers mentioned above.\\n\\nThe last thing is to count the actual removal of the number, which is a simple `+1` which I added when initializing `steps` and a call to `BIT.insert`\\n\\nAfter we removed the number we automatically advance to the next position `curPos = (pos+1) % n`\\n\\n# Please upvote if you like this solution!\\n\\n\\n# Code\\n```\\n# A class defining Binary Indexed Tree:\\nclass BIT:\\n    def __init__(self, maxN):\\n        self.maxN = maxN\\n        self.bit = [0] * (maxN + 1)\\n    def prefSum(self, n):\\n        \\'\\'\\' return prefix sum; allowed n=-1 for no prefix\\'\\'\\'\\n        ret = 0\\n        n += 1\\n        while n > 0:\\n            ret += self.bit[n]\\n            n -= n & (-n)\\n        return ret\\n    def insert(self, v, delta):\\n        v += 1\\n        while v <= self.maxN:\\n            self.bit[v] += delta\\n            v += v & (-v)\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums):\\n        n = len(nums)\\n        bit = BIT(n)\\n        nums = [(num, i) for i, num in enumerate(nums)]\\n        nums.sort()\\n        curPos = 0\\n        ret = 0\\n        for _, pos in nums:\\n            steps = 1+(n + pos - curPos) % n\\n            if pos >= curPos:\\n                steps -= (bit.prefSum(pos) - bit.prefSum(curPos-1))\\n            else:\\n                steps -= (bit.prefSum(n-1) - bit.prefSum(curPos-1))\\n                steps -= bit.prefSum(pos)\\n            ret += steps\\n            bit.insert(pos, 1)\\n            curPos = (pos+1) % n\\n        return ret\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# A class defining Binary Indexed Tree:\\nclass BIT:\\n    def __init__(self, maxN):\\n        self.maxN = maxN\\n        self.bit = [0] * (maxN + 1)\\n    def prefSum(self, n):\\n        \\'\\'\\' return prefix sum; allowed n=-1 for no prefix\\'\\'\\'\\n        ret = 0\\n        n += 1\\n        while n > 0:\\n            ret += self.bit[n]\\n            n -= n & (-n)\\n        return ret\\n    def insert(self, v, delta):\\n        v += 1\\n        while v <= self.maxN:\\n            self.bit[v] += delta\\n            v += v & (-v)\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums):\\n        n = len(nums)\\n        bit = BIT(n)\\n        nums = [(num, i) for i, num in enumerate(nums)]\\n        nums.sort()\\n        curPos = 0\\n        ret = 0\\n        for _, pos in nums:\\n            steps = 1+(n + pos - curPos) % n\\n            if pos >= curPos:\\n                steps -= (bit.prefSum(pos) - bit.prefSum(curPos-1))\\n            else:\\n                steps -= (bit.prefSum(n-1) - bit.prefSum(curPos-1))\\n                steps -= bit.prefSum(pos)\\n            ret += steps\\n            bit.insert(pos, 1)\\n            curPos = (pos+1) % n\\n        return ret\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467306,
                "title": "easy-with-explaination-in-java",
                "content": "# Intuition\\nThe intuition behind the algorithm is that, initially, there are n elements in the array, and at least n operations are required to transform the array to a non-decreasing order. To perform a rotation, n operations are required to move all the elements once.\\n\\nTo implement the algorithm, we first set the result variable to n, which represents the minimum number of operations required to make the array non-decreasing. We then record the positions of all the elements in the array using a dictionary, where pos[A[i]] = i.\\n\\nNext, we iterate through the array from smallest to largest element. If the position of an element decreases compared to the previous element, we know that we need to rotate the remaining elements to the beginning of the array. This brings us back to the original intuition that we need n operations to rotate all the elements once. In this case, we increment the result variable by the number of remaining elements.\\n\\n# Code\\n```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] a) {\\n        HashMap<Integer, Integer> pos = new HashMap<>();\\n        long n = a.length, res = n;\\n        for (int i = 0; i < n; i++)\\n            pos.put(a[i], i);\\n        Arrays.sort(a);\\n        for (int i = 1; i < n; i++)\\n            if (pos.get(a[i]) < pos.get(a[i - 1]))\\n                res += n - i;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] a) {\\n        HashMap<Integer, Integer> pos = new HashMap<>();\\n        long n = a.length, res = n;\\n        for (int i = 0; i < n; i++)\\n            pos.put(a[i], i);\\n        Arrays.sort(a);\\n        for (int i = 1; i < n; i++)\\n            if (pos.get(a[i]) < pos.get(a[i - 1]))\\n                res += n - i;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467198,
                "title": "sort-with-indices-with-explanation",
                "content": "# Intuition\\nTry to modify the problem statement, and think of operations required to remove some strict increasing subsequence (including smallest)\\n\\n\\n\\n# Approach\\nWe need to calculate the strictly increasing subsequence including the smallest element, to remove those many elements we will require n operations.\\n \\n3  | 4  | [-1]\\n\\nhere the subsequence is of size 1, it will take n (i.e. 3) operations to remove that subsequence,\\n\\nnew array will be,\\n\\n[3  | 4 ]\\n\\nwhich itself is the longest strictly increasing array including the smallest element to remove them we need n (i.e. 2) operations\\n\\n\\nwe can easily get the subsequences with sorted array including the account of indices\\n\\n-1  |  3  |  4       ---->  sorted elements\\n0    |  1  |  2    ----->indices\\n\\nwe need to calculate the continues subarray that is increasing in both conditions. We can take some pointers to achieve the same\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<pair<int,int>> arr(n);\\n        \\n        for(int i=0;i<n;i++){\\n            arr[i] = {nums[i], i};\\n        }\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        long long answer=0;\\n        \\n        // adding last element to run the else condition below to execute after traversing is over\\n        arr.push_back({INT_MIN, 0});    \\n        \\n        //prev is the pointer and nn is take the count of current array size\\n        long long prev=0, nn=n;\\n        \\n        for(int i=1;i<=n;i++){\\n            \\n            if(arr[i-1].first <= arr[i].first && arr[i-1].second <= arr[i].second){\\n                //continue;    \\n            }else{\\n                \\n                long long items = i - prev;\\n                \\n                answer+= nn;\\n                \\n                nn -= items;\\n                prev = i;\\n            }   \\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<pair<int,int>> arr(n);\\n        \\n        for(int i=0;i<n;i++){\\n            arr[i] = {nums[i], i};\\n        }\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        long long answer=0;\\n        \\n        // adding last element to run the else condition below to execute after traversing is over\\n        arr.push_back({INT_MIN, 0});    \\n        \\n        //prev is the pointer and nn is take the count of current array size\\n        long long prev=0, nn=n;\\n        \\n        for(int i=1;i<=n;i++){\\n            \\n            if(arr[i-1].first <= arr[i].first && arr[i-1].second <= arr[i].second){\\n                //continue;    \\n            }else{\\n                \\n                long long items = i - prev;\\n                \\n                answer+= nn;\\n                \\n                nn -= items;\\n                prev = i;\\n            }   \\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467063,
                "title": "easy-c-ordered-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing ordered set to find out number of operations needed to get to next smallest element.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*log(N))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n  \\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n  \\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        int n = nums.size();\\n        long long int ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            pq.push({nums[i],i});           \\n        }\\n        int prev = pq.top().second;\\n        ans+=pq.top().second+1;\\n        pq.pop();\\n        \\n        ordered_set os;\\n        \\n        os.insert(prev);\\n        \\n        while(pq.size()){\\n            //cout<<ans<<endl;\\n            if(pq.top().second<prev){\\n                os.insert(pq.top().second);\\n                int tilas = os.size() - os.order_of_key(prev)-1;\\n                int tilnum = os.order_of_key (pq.top().second);//cout<<tilas<<\" \"<<tilnum<<\" \";\\n                int thisan = tilas+tilnum;\\n                ans+= (pq.top().second+1+(n-prev-1))- thisan;\\n                prev = pq.top().second;\\n                pq.pop();\\n            }else{\\n                os.insert(pq.top().second);\\n                ans+= pq.top().second-prev-( os.order_of_key(pq.top().second) - os.order_of_key(prev)-1);\\n                prev = pq.top().second;\\n                pq.pop();\\n            }\\n            \\n        }\\n        // cout<<ans<<endl<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\n\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n  \\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n  \\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        int n = nums.size();\\n        long long int ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            pq.push({nums[i],i});           \\n        }\\n        int prev = pq.top().second;\\n        ans+=pq.top().second+1;\\n        pq.pop();\\n        \\n        ordered_set os;\\n        \\n        os.insert(prev);\\n        \\n        while(pq.size()){\\n            //cout<<ans<<endl;\\n            if(pq.top().second<prev){\\n                os.insert(pq.top().second);\\n                int tilas = os.size() - os.order_of_key(prev)-1;\\n                int tilnum = os.order_of_key (pq.top().second);//cout<<tilas<<\" \"<<tilnum<<\" \";\\n                int thisan = tilas+tilnum;\\n                ans+= (pq.top().second+1+(n-prev-1))- thisan;\\n                prev = pq.top().second;\\n                pq.pop();\\n            }else{\\n                os.insert(pq.top().second);\\n                ans+= pq.top().second-prev-( os.order_of_key(pq.top().second) - os.order_of_key(prev)-1);\\n                prev = pq.top().second;\\n                pq.pop();\\n            }\\n            \\n        }\\n        // cout<<ans<<endl<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3466993,
                "title": "easiest-c-solution-o-nlogn",
                "content": "# Intuition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**sorting**\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        long long ans = 1, n = A.size(),j = 2;\\n        vector <pair <int,int>> v;\\n        for(int i = 0; i < n; i++)   v.push_back({A[i], i});\\n        sort(v.begin(), v.end());\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(v[i].second > v[i + 1].second)   ans += j;\\n            else   ans += 1;\\n            j += 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        long long ans = 1, n = A.size(),j = 2;\\n        vector <pair <int,int>> v;\\n        for(int i = 0; i < n; i++)   v.push_back({A[i], i});\\n        sort(v.begin(), v.end());\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(v[i].second > v[i + 1].second)   ans += j;\\n            else   ans += 1;\\n            j += 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466639,
                "title": "python3-sortedlist-o-nlogn-clean-concise",
                "content": "# Intuition\\nThink of the array `nums` as a circular array. Then each operation is essentially finding the number of (remaining) elements from the previously deleted element to the next deleted element, in a circular fashion.\\n\\n# Approach\\nWe use a SortedList `sl` or a min-heap to keep track of the current smallest element in the remaining array. We use another SortedList `sl_idx` to keep track of the remaining indices in sorted order. Each time, we count the number of indices between `[start, end]` (inclusive) in the remaining `sl_idx`, and add it to `ans`. Given we are putting elements in a circular fashion, there could be two possibilities where `start <= end` or `start > end`. For the case of `start > end`, we can count the number of indices between `[0, start]` (inclusive) and `[end, n - 1]` (inclusive).\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        sl = SortedList((num, i) for i, num in enumerate(nums))\\n        sl_idx = SortedList(range(n))\\n        start, ans = 0, 0\\n        while sl:\\n            num, i = sl.pop(0)\\n            ans += self.count(sl_idx, n, start, i)\\n            sl_idx.remove(i)\\n            start = (i + 1) % n\\n        return ans\\n    \\n    def count(self, sl, n, start, end):\\n        if start <= end:\\n            return sl.bisect(end) - sl.bisect_left(start)\\n        else:\\n            return self.count(sl, n, start, n - 1) + self.count(sl, n, 0, end)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        sl = SortedList((num, i) for i, num in enumerate(nums))\\n        sl_idx = SortedList(range(n))\\n        start, ans = 0, 0\\n        while sl:\\n            num, i = sl.pop(0)\\n            ans += self.count(sl_idx, n, start, i)\\n            sl_idx.remove(i)\\n            start = (i + 1) % n\\n        return ans\\n    \\n    def count(self, sl, n, start, end):\\n        if start <= end:\\n            return sl.bisect(end) - sl.bisect_left(start)\\n        else:\\n            return self.count(sl, n, start, n - 1) + self.count(sl, n, 0, end)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045231,
                "title": "swift-solution-inline-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTried with O(n) but with very large number the test case time limit increased, added the solution though. \\n\\nSecond approach was using dict (accepted) to get the information if the elements are in sorted order of increasing if not we need to increase the iterations to that many times as we have numbers left.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n* logn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func countOperationsToEmptyArray(_ nums: [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n\\n        // to make array empty, min operation it will take is nums.count\\n        var result = nums.count \\n        let k = nums.count\\n        var i = 0 \\n        var dict: [Int: Int] = [:]\\n        while i < k {\\n            dict[nums[i]] = i\\n\\n            i += 1\\n        }\\n\\n\\n        var sortedList = nums.sorted { $0 < $1 }\\n\\n        var j = 1\\n        while j < k {\\n\\n            let next = sortedList[j]\\n            let prev = sortedList[j - 1]\\n\\n            // if we have next element index smaller than previous (decreasing order), means we have to rotate rest of element again\\n            if dict[next]! < dict[prev]! {\\n                result += k - j\\n            }\\n            j += 1\\n        }\\n\\n        return result\\n    }\\n}\\n\\n/*\\nO(n) // time limit exceed with very huge input after 500 test case\\nfunc countOperationsToEmptyArray(_ nums: [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n        var result = 0 \\n        var nums = nums\\n\\n        var queue = nums.sorted { $0 < $1 }\\n        while !nums.isEmpty {\\n            \\n            if nums[0] == queue[0] {\\n                nums.removeFirst()\\n                queue.removeFirst()\\n            } else {\\n                let element = nums.removeFirst()\\n                nums.append(element)\\n            }\\n            result += 1\\n        }\\n\\n        return result\\n    }\\n*/\\n\\n\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countOperationsToEmptyArray(_ nums: [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n\\n        // to make array empty, min operation it will take is nums.count\\n        var result = nums.count \\n        let k = nums.count\\n        var i = 0 \\n        var dict: [Int: Int] = [:]\\n        while i < k {\\n            dict[nums[i]] = i\\n\\n            i += 1\\n        }\\n\\n\\n        var sortedList = nums.sorted { $0 < $1 }\\n\\n        var j = 1\\n        while j < k {\\n\\n            let next = sortedList[j]\\n            let prev = sortedList[j - 1]\\n\\n            // if we have next element index smaller than previous (decreasing order), means we have to rotate rest of element again\\n            if dict[next]! < dict[prev]! {\\n                result += k - j\\n            }\\n            j += 1\\n        }\\n\\n        return result\\n    }\\n}\\n\\n/*\\nO(n) // time limit exceed with very huge input after 500 test case\\nfunc countOperationsToEmptyArray(_ nums: [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n        var result = 0 \\n        var nums = nums\\n\\n        var queue = nums.sorted { $0 < $1 }\\n        while !nums.isEmpty {\\n            \\n            if nums[0] == queue[0] {\\n                nums.removeFirst()\\n                queue.removeFirst()\\n            } else {\\n                let element = nums.removeFirst()\\n                nums.append(element)\\n            }\\n            result += 1\\n        }\\n\\n        return result\\n    }\\n*/\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042035,
                "title": "short-python-with-example-to-illustrate",
                "content": "# Intuition\\nThe idea comes from the following link.\\n[https://leetcode.com/problems/make-array-empty/solutions/3466731/just-sort-without-any-other-tricky-data-structures/?orderBy=most_votes]()\\n\\nA quick example to get the idea. \\n\\nArray a=[3,1,2,4].\\nNow get the sorted arrary\\'s indices (i-th smallest entry\\'s position in original array): b=[1,2,0,3]\\n\\nIterate over this array b, and pause whenever we find a b[i]<b[i-1].\\nSince when there are b[i]<b[i-1], it means we need to wrap around the list to remove the smallest element.\\n\\nDuring each pause, (in our mind) repeating moving the first element to the end of list until it goes back to the original state. During this action, we are able to remove the smallest entry before this pause. E.g. 3,1,2,4 -> 1,2,4,3 -> 2,4,3,1 -> 4,3,1,2 -> 3,1,2,4. \\n\\n**Rmk1**: Note that though we kept 1,2 for illustration, we can remove 1, 2 during this loop and it doesn\\'t change the number of operations needed which is N, the length of array.\\n**Rmk2**: why pause after a whole iteration, why not pause at 4 in this example? **Because it\\'s easy to count.** And we need at least one iteration to remove all entries in the list even in the best case, so there won\\'t be any redundant operations.\\n\\nAfter this pause, the number of element remaining in the list is N-m where m is the number removed already. E.g. [3,4].\\n\\nThen we continue, until next pausing to compute the operations we need. In this example, there is no more pause needed. Instead, we can directly empty the list. E.g. So just adding N-m to the answer.\\n\\n\\n# Complexity\\n- Time complexity: $O(n\\\\log n)$ because of sorting.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$, if using nums to store then $O(1)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        nums = sorted(range(len(nums)), key=lambda x: nums[x])\\n        ans, m = 0, 0\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] < nums[i-1]:\\n                ans += len(nums) - m\\n                m = i\\n        ans += len(nums) - m\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        nums = sorted(range(len(nums)), key=lambda x: nums[x])\\n        ans, m = 0, 0\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] < nums[i-1]:\\n                ans += len(nums) - m\\n                m = i\\n        ans += len(nums) - m\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035077,
                "title": "python-easy-dp-once-you-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmy attempt to explain using DP\\nwe accumulate 1 rotations if idx is less than previous in sorted idx\\nby starting from the smallest idx we build up the cases from 1 element\\n\\nthe rest from size 2 onwards is handled in for loop \\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        # heapify nums,idx\\n        # curr i to next idx\\n        t=len(nums)\\n        ind = sorted(range(t), key=lambda i:nums[i])\\n        print(ind)\\n        # bottom up dp visualization, \\n        # current frame at 1, before that accumulate 1\\n        m = 1 # drop next, how much to rotate, add moves to res\\n        res = 1 # removed first, now at second, looking back\\n        for i in range(1, t):\\n            # looking back from item 1 to n-1\\n            # prev index is more, had to rotate\\n            if ind[i] < ind[i-1]: # rotated\\n                m += 1 # accumulate 1 more rotation\\n            res += m\\n        return res\\n```\\n```\\n\\n# 1 2 3 4 5\\n# 0 1 2 3 4 \\n\\n# 5 4 3 2 1\\n# 4 3 2 1 0\\n\\n# 1 3 2 4\\n# 0 2 1 3\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        # heapify nums,idx\\n        # curr i to next idx\\n        t=len(nums)\\n        ind = sorted(range(t), key=lambda i:nums[i])\\n        print(ind)\\n        # bottom up dp visualization, \\n        # current frame at 1, before that accumulate 1\\n        m = 1 # drop next, how much to rotate, add moves to res\\n        res = 1 # removed first, now at second, looking back\\n        for i in range(1, t):\\n            # looking back from item 1 to n-1\\n            # prev index is more, had to rotate\\n            if ind[i] < ind[i-1]: # rotated\\n                m += 1 # accumulate 1 more rotation\\n            res += m\\n        return res\\n```\n```\\n\\n# 1 2 3 4 5\\n# 0 1 2 3 4 \\n\\n# 5 4 3 2 1\\n# 4 3 2 1 0\\n\\n# 1 3 2 4\\n# 0 2 1 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020116,
                "title": "prefix-count-binary-indexed-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT\\n{\\n    public: \\n    vector<int> BITtree;\\n    int n;\\n    \\n    BIT(int n)\\n    {\\n        BITtree = vector<int>(n+1,0);\\n        this->n = n;\\n    }\\n    \\n    void add(int index)\\n    {\\n        index = index + 1;\\n\\n        while (index <= n)\\n        {\\n            BITtree[index] += 1;\\n            index += index & (-index);\\n        }\\n    }\\n\\n    void update(int index)\\n    {\\n        index = index + 1;\\n\\n        while (index <= n)\\n        {\\n            BITtree[index] -= 1;\\n            index += index & (-index);\\n        }\\n    }\\n    \\n    int get(int index)\\n    {\\n        int sum = 0;\\n\\n        index = index + 1;\\n\\n        while (index>0)\\n        {\\n            sum += BITtree[index];\\n            index -= index & (-index);\\n        }\\n        return sum;\\n    }\\n\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    #define pi pair<int,int>\\n    long long countOperationsToEmptyArray(vector<int>& nums)\\n    {\\n        long long ans = 0;\\n        \\n        int n = nums.size();\\n        \\n        BIT bit(n);\\n        for(int i=0;i<n;i++) bit.add(i);\\n     \\n        vector<pi> hash;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            hash.push_back({nums[i],i});\\n        }\\n        \\n        sort(hash.begin(),hash.end());\\n        \\n        int curr = 0;\\n        \\n        for(auto i : hash)\\n        {\\n            int idx = i.second;\\n            \\n            if(curr<=idx)\\n            {\\n                int to_add = bit.get(0);\\n                if(curr>0) to_add = bit.get(curr) - bit.get(curr-1);\\n                \\n              \\n                ans += (bit.get(idx)-bit.get(curr) + to_add);\\n            }\\n            else\\n            {\\n            \\n                int to_add = bit.get(0);\\n                if(curr>0) to_add = bit.get(curr) - bit.get(curr-1);\\n\\n                ans += bit.get(n-1) - bit.get(curr) + to_add;\\n                \\n              \\n                ans += bit.get(idx);\\n            }\\n                \\n         \\n            bit.update(idx);\\n        \\n            curr = idx;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass BIT\\n{\\n    public: \\n    vector<int> BITtree;\\n    int n;\\n    \\n    BIT(int n)\\n    {\\n        BITtree = vector<int>(n+1,0);\\n        this->n = n;\\n    }\\n    \\n    void add(int index)\\n    {\\n        index = index + 1;\\n\\n        while (index <= n)\\n        {\\n            BITtree[index] += 1;\\n            index += index & (-index);\\n        }\\n    }\\n\\n    void update(int index)\\n    {\\n        index = index + 1;\\n\\n        while (index <= n)\\n        {\\n            BITtree[index] -= 1;\\n            index += index & (-index);\\n        }\\n    }\\n    \\n    int get(int index)\\n    {\\n        int sum = 0;\\n\\n        index = index + 1;\\n\\n        while (index>0)\\n        {\\n            sum += BITtree[index];\\n            index -= index & (-index);\\n        }\\n        return sum;\\n    }\\n\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    #define pi pair<int,int>\\n    long long countOperationsToEmptyArray(vector<int>& nums)\\n    {\\n        long long ans = 0;\\n        \\n        int n = nums.size();\\n        \\n        BIT bit(n);\\n        for(int i=0;i<n;i++) bit.add(i);\\n     \\n        vector<pi> hash;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            hash.push_back({nums[i],i});\\n        }\\n        \\n        sort(hash.begin(),hash.end());\\n        \\n        int curr = 0;\\n        \\n        for(auto i : hash)\\n        {\\n            int idx = i.second;\\n            \\n            if(curr<=idx)\\n            {\\n                int to_add = bit.get(0);\\n                if(curr>0) to_add = bit.get(curr) - bit.get(curr-1);\\n                \\n              \\n                ans += (bit.get(idx)-bit.get(curr) + to_add);\\n            }\\n            else\\n            {\\n            \\n                int to_add = bit.get(0);\\n                if(curr>0) to_add = bit.get(curr) - bit.get(curr-1);\\n\\n                ans += bit.get(n-1) - bit.get(curr) + to_add;\\n                \\n              \\n                ans += bit.get(idx);\\n            }\\n                \\n         \\n            bit.update(idx);\\n        \\n            curr = idx;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011919,
                "title": "if-you-still-find-it-confusing-check-out-this",
                "content": "# Intuition\\nI think the most upvoted solution is genius. if you find it confusing, I can help explain further.\\n\\ntaking [4,3,1,2,6,5] as example, if we put it into a sorted map<value, index>, it would be \\n\\n{1: 2}\\n{2: 3}\\n{3: 1}\\n{4: 0}\\n{5: 5}\\n{6: 4}\\n\\nIf we only need to remove the first batch [1,2], it should only take 4 steps, which is basically (index of value 2) + 1, that should be easy to understand.\\n\\n[3,1,2,6,5,4]\\n[1,2,6,5,4,3]\\n[2,6,5,4,3]\\n[6,5,4,3]\\n\\nNow why does the solution keep saying it take one round to remove an increasing batch, I guess this is the confusing part. This is because once you remove [1,2] in the original array, the values after [1,2] which is [6,5] with bigger index can NOT be the next one to remove, otherwise the first batch won\\'t be [1,2]. But now they are rotated in the front of array, so they still need to be rotated to the tail, in which case the array was actually restored to the original order. It takes 2 more steps.\\n\\n[5,4,3,6]\\n[4,3,6,5]\\n\\nThis is called one round, which essentially equals the size of the array = 6.\\n\\nRound 2 removes [3] which takes the size of array steps = 4, array becomes\\n\\n[4,6,5]\\n\\nRound 3 removes [4,5] which takes the size of array steps = 3, array becomes\\n\\n[6]\\n\\nRound 4 removes [6] which takes the size of array steps = 1, array becomes\\n\\n[]\\n\\nTotal steps = 6 + 4 + 3 + 1 = 14\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n = nums.length;\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(nums[i], i);\\n        }\\n\\n        long steps = 0, prevRemovedIndex = -1;\\n        while (map.size() > 0) {\\n            int size = map.size();\\n            while (map.size() > 0 && map.get(map.firstKey()) > prevRemovedIndex) {\\n                int smallest = map.firstKey();\\n                int index = map.get(smallest);\\n                map.remove(smallest);\\n                prevRemovedIndex = index;\\n            }\\n\\n            steps += size;\\n            prevRemovedIndex = -1;\\n        }\\n\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n = nums.length;\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(nums[i], i);\\n        }\\n\\n        long steps = 0, prevRemovedIndex = -1;\\n        while (map.size() > 0) {\\n            int size = map.size();\\n            while (map.size() > 0 && map.get(map.firstKey()) > prevRemovedIndex) {\\n                int smallest = map.firstKey();\\n                int index = map.get(smallest);\\n                map.remove(smallest);\\n                prevRemovedIndex = index;\\n            }\\n\\n            steps += size;\\n            prevRemovedIndex = -1;\\n        }\\n\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977485,
                "title": "greedy-approach-for-counting-operations-to-empty-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou seem to be trying to solve the problem by sorting the indices of the input array based on the values at those indices. Then, you iterate through the sorted indices and count the number of operations needed to empty the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Create a list num_indices containing indices from 0 to len(nums) - 1.\\n2) Sort num_indices based on the corresponding values in the nums array using a custom sorting key.\\n3) Initialize count as the length of the nums array and operations as 0.\\n4) Iterate through num_indices starting from index 1. Compare the current index with the previous index in the sorted order.\\n    - If the current index is smaller than the previous index, increment operations.\\n    - Add the current value of operations to count in each iteration.\\n5) Finally, return the count as the result.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe overall time complexity is dominated by the sorting step and is O(n log n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe overall space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        num_indices = list(range(len(nums))) \\n\\n        num_indices.sort(key=lambda i: nums[i])\\n        \\n        count = len(nums)\\n        operations = 0\\n        \\n        for i in range(1, len(num_indices)):\\n            if num_indices[i] < num_indices[i - 1]:\\n                operations += 1\\n            count += operations\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        num_indices = list(range(len(nums))) \\n\\n        num_indices.sort(key=lambda i: nums[i])\\n        \\n        count = len(nums)\\n        operations = 0\\n        \\n        for i in range(1, len(num_indices)):\\n            if num_indices[i] < num_indices[i - 1]:\\n                operations += 1\\n            count += operations\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976817,
                "title": "count-query-using-balenced-binary-search-tree",
                "content": "# Intuition\\nUse balanced Red-Black-Tree to count how many nodes lie in given range. The number is made-empty from the array, while it is also deleted from the binary tree.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countOperationsToEmptyArray = function(nums) {\\n    \\n    const indexValueSorted = nums.map((val, index) => [index, val]);\\n    indexValueSorted.sort((a, b) => b[1] - a[1]);\\n\\n    const linkedList = nums.map((val, index) => new Element(index, val));\\n    linkedList[linkedList.length - 1].right = linkedList[0];\\n    for (let i = 0; i < linkedList.length; i++) {\\n        const nextI = (i + 1) % linkedList.length;\\n        linkedList[i].right = linkedList[nextI];\\n        linkedList[i].left = linkedList[(i - 1 + linkedList.length) % linkedList.length];\\n    }\\n\\n    let currentMin = indexValueSorted.pop();\\n    let operations = currentMin[0] - 0 + 1;\\n    let currentIndex = linkedList[currentMin[0]].right.index;\\n    deleteElement(linkedList, currentMin[0]);\\n    let root = new Element(currentMin[0], currentMin[1]);\\n    const tree = new RbTree();\\n    tree.insert(currentMin[0], currentMin[1]);\\n\\n    while (indexValueSorted.length > 0) {\\n        const [indexMin, valMin] = indexValueSorted.pop();\\n        if (currentIndex <= indexMin) {\\n            const countRemoved = countOfRemovedElements(tree.root, currentIndex, indexMin);\\n            operations += indexMin - currentIndex + 1 - countRemoved;\\n        } else {\\n            const countRemoved = countOfRemovedElements(tree.root, 0, indexMin) +\\n                countOfRemovedElements(tree.root, currentIndex, nums.length - 1);\\n            operations += indexMin + 1 + nums.length - currentIndex - countRemoved;\\n        }\\n        tree.insert(indexMin, valMin);\\n        // next index\\n        currentIndex = linkedList[indexMin].right.index;\\n        deleteElement(linkedList, indexMin);\\n    }\\n    return operations;\\n};\\n\\nclass Element {\\n    constructor(index, value) {\\n        this.index = index;\\n        this.value = value;\\n        this.left = null;\\n        this.right = null;\\n        this.leftCount = 0;\\n        this.rightCount = 0;\\n    }\\n}\\n\\nvar deleteElement = function(eleList, index) {\\n    const ele = eleList[index];\\n    if (ele.left == null || ele.right == null) {\\n        return ele;\\n    }\\n\\n    const leftEle = ele.left;\\n    const rightEle = ele.right;\\n    leftEle.right = rightEle;\\n    rightEle.left = leftEle;\\n    ele.left = ele.right = null;\\n    return rightEle;\\n};\\n\\nvar countOfRemovedElements = function(root, start, end) {\\n    if (isNilNode(root)) {\\n        return 0;\\n    }\\n    const ge = countOfGreatOrEqual(root, start);\\n    const ge1 = countOfGreatOrEqual(root, end + 1);\\n    return ge - ge1;\\n};\\n\\n/**\\n * \\n * @param {Node} root \\n * @param {Number} index \\n * @returns \\n */\\nvar countOfGreatOrEqual = function(root, index) {\\n    if (root == null || isNilNode(root)) {\\n        return 0;\\n    }\\n\\n    if (root.key >= index) {\\n        return countOfGreatOrEqual(root.left, index) + 1 + root.rightCount;\\n    } else {\\n        return countOfGreatOrEqual(root.right, index);\\n    }\\n};\\n\\n/**\\n * constructor\\n * Node of the red black tree\\n * 1.Every node is either red or black\\n * 2.Root and leaves are all black\\n * 3.Every red node has black parent\\n * 4.All simple paths from a node x to a descendant leaves of x has same black nodes\\n */\\nclass RbTree {\\n    constructor() {\\n      this.root = null;\\n    }\\n  \\n  /**\\n    * Complexity: O(1).\\n    *\\n    * param Node node Node.\\n    * return Node a copy of original node\\n    */\\n    clone(node) {\\n      return new Node(node.key, node.value, node.left, node.right, node.color, node.parent);\\n    }\\n  \\n  /**\\n   * find value by node key\\n   */\\n    find(input) {\\n      const key = toNumber(input);\\n      let node = this.root;\\n      while (node != null) {\\n        if (key < node.key) {\\n          node = node.left;\\n        } else if (key > node.key) {\\n          node = node.right;\\n        } else {\\n          return node.value;\\n        }\\n      }\\n      return null;\\n    }\\n  \\n    leftMostChild(node) {\\n      if (isNilNode(node)) {\\n        return null;\\n      }\\n      while (!isNilNode(node.left)) {\\n        node = node.left;\\n      }\\n      return node;\\n    }\\n  \\n    findNode(key) {\\n      let node = this.root;\\n      while (node != null) {\\n        if (key < node.key) {\\n          node = node.left;\\n        } else if (key > node.key) {\\n          node = node.right;\\n        } else if (key === node.key) {\\n          return node;\\n        } else {\\n          return null;\\n        }\\n      }\\n      return null;\\n    }\\n  \\n    update(key, value) {\\n      const node = this.findNode(key);\\n      node.value = value;\\n    }\\n  \\n  /**\\n    * Complexity: O(1).\\n    *       y                   x\\n    *      / \\\\                 / \\\\\\n    *     x  Gamma   ====>   alpha y\\n    *   /  \\\\                      / \\\\\\n    * alpha beta               beta Gamma\\n    * method\\n    * param Node node Node.\\n    * return Node\\n    */\\n    rotateRight(node) {\\n      const y = node.left;\\n  \\n      if (isNilNode(y.right)) {\\n        node.left = createLeafNode(node);\\n        node.leftCount = 0;\\n      } else {\\n        node.left = y.right;\\n        node.leftCount = y.rightCount;\\n      }\\n  \\n      if (!isNilNode(y.right)) {\\n        y.right.parent = node;\\n      }\\n      y.parent = node.parent;\\n      if (isNilNode(node.parent)) {\\n        this.root = y;\\n      } else {\\n        if (node === node.parent.right) {\\n          node.parent.right = y;\\n          // node.parent.rightCount = y.rightCount + y.leftCount + 1;\\n        } else {\\n          node.parent.left = y;\\n          // node.parent.leftCount = y.rightCount + y.leftCount + 1;\\n        }\\n      }\\n      y.right = node;\\n      y.rightCount = node.rightCount + node.leftCount + 1;\\n      node.parent = y;\\n    }\\n  \\n  /**\\n    * Complexity: O(1).\\n    *       y                   x\\n    *      / \\\\                 / \\\\\\n    *     x  Gamma   <====   alpha y\\n    *   /  \\\\                      / \\\\\\n    * alpha beta               beta Gamma\\n    * method\\n    * param Node node Node.\\n    * return Node\\n    */\\n    rotateLeft(node) {\\n      const y = node.right;\\n  \\n      // console.log(y.left)\\n      if (isNilNode(y.left)) {\\n        node.right = createLeafNode(node);\\n        node.rightCount = 0;\\n      } else {\\n        node.right = y.left;\\n        node.rightCount = y.leftCount;\\n      }\\n  \\n      if (!isNilNode(y.left)) {\\n        y.left.parent = node;\\n      }\\n      y.parent = node.parent;\\n      if (isNilNode(node.parent)) {\\n        this.root = y;\\n      } else {\\n        if (node === node.parent.left) {\\n          node.parent.left = y;\\n          // node.parent.leftCount = y.leftCount + y.rightCount + 1;\\n        } else {\\n          node.parent.right = y;\\n          // node.parent.rightCount = y.leftCount + y.rightCount + 1;\\n        }\\n      }\\n      y.left = node;\\n      y.leftCount = node.leftCount + node.rightCount + 1;\\n      node.parent = y;\\n    }\\n  \\n  /**\\n    * param Node node Node.\\n    * Make the color of newly inserted nodes as RED and then perform standard BST insertion\\n    * If x is root, change color of node as BLACK (Black height +1).\\n    */\\n    insert(key, value) {\\n      let y = null;\\n      let x = this.root;\\n      const z = createNode(key, value);\\n      if (this.root == null) {\\n        this.root = z;\\n        z.color = nodeColor.BLACK;\\n        z.parent = null;\\n      } else {\\n        while (!isNilNode(x)) {\\n          y = x;\\n          if (z.key < x.key) {\\n            x = x.left;\\n          } else {\\n            x = x.right;\\n          }\\n        }\\n        z.parent = y;\\n        // current node parent is root\\n        if (z.key < y.key) {\\n          y.left = z;\\n          y.leftCount = z.leftCount + z.rightCount + 1;\\n        } else {\\n          y.right = z;\\n          y.rightCount = z.leftCount + z.rightCount + 1;\\n        }\\n\\n        // update y\\'s parent count\\n        let p = y.parent;\\n        let c = y;\\n        while (!isNilNode(p)) {\\n            if (c === p.left) {\\n                p.leftCount++;\\n            } else {\\n                p.rightCount++;\\n            }\\n            c = p;\\n            p = p.parent;\\n        }\\n        // y.right is now z\\n        z.left = createLeafNode(z);\\n        z.right = createLeafNode(z);\\n        z.leftCount = z.rightCount = 0;\\n        z.color = nodeColor.RED;\\n        this.fixTree(z);\\n      }\\n    }\\n  \\n  /**\\n  * A method to fix RB TREE\\n  * when uncle is RED\\n  * Change color of parent and uncle as BLACK.\\n  * Color of grand parent as RED.\\n  * Change node = node\\u2019s grandparent, repeat steps 2 and 3 for new x.\\n  * ---------------------------------------------------------------\\n  * when uncle is BLACK\\n  * left_left_case\\n  * left_right_case\\n  * right_right_case\\n  * right_left_case\\n  */\\n  \\n    fixTree(node) {\\n      while (node.parent != null && node.parent.color === nodeColor.RED) {\\n        let uncle = null;\\n        if (node.parent === node.parent.parent.left) {\\n          uncle = node.parent.parent.right;\\n  \\n          if (uncle != null && uncle.color === nodeColor.RED) {\\n            node.parent.color = nodeColor.BLACK;\\n            uncle.color = nodeColor.BLACK;\\n            node.parent.parent.color = nodeColor.RED;\\n            node = node.parent.parent;\\n            continue;\\n          }\\n          if (node === node.parent.right) {\\n            // Double rotation needed\\n            node = node.parent;\\n            this.rotateLeft(node);\\n          }\\n          node.parent.color = nodeColor.BLACK;\\n          node.parent.parent.color = nodeColor.RED;\\n          // if the \"else if\" code hasn\\'t executed, this\\n          // is a case where we only need a single rotation\\n          this.rotateRight(node.parent.parent);\\n        } else {\\n          uncle = node.parent.parent.left;\\n          if (uncle != null && uncle.color === nodeColor.RED) {\\n            node.parent.color = nodeColor.BLACK;\\n            uncle.color = nodeColor.BLACK;\\n            node.parent.parent.color = nodeColor.RED;\\n            node = node.parent.parent;\\n            continue;\\n          }\\n          if (node === node.parent.left) {\\n            // Double rotation needed\\n            node = node.parent;\\n            this.rotateRight(node);\\n          }\\n          node.parent.color = nodeColor.BLACK;\\n          node.parent.parent.color = nodeColor.RED;\\n          // if the \"else if\" code hasn\\'t executed, this\\n          // is a case where we only need a single rotation\\n          this.rotateLeft(node.parent.parent);\\n        }\\n      }\\n      this.root.color = nodeColor.BLACK;\\n    }\\n  \\n    /**\\n    * return the height of a tree\\n    */\\n    findHeight(node) {\\n      if (node == null) {\\n        return -1;\\n      }\\n      const leftLen = this.findHeight(node.left);\\n      const rightLen = this.findHeight(node.right);\\n  \\n      if (leftLen > rightLen) {\\n        return leftLen + 1;\\n      }\\n      return rightLen + 1;\\n    }\\n  \\n    /**\\n    * print out current tree\\n    */\\n    print() {\\n      const height = this.findHeight(this.root) + 1;\\n      this.printHelper(this.root, \\'__\\', height);\\n    }\\n  \\n    printHelper(node, indent, height) {\\n      // tree height\\n      let treeHeight = height;\\n  \\n      if (node == null) {\\n        return;\\n      }\\n      if (node === this.root) {\\n        console.log(`${node.key} color: ${node.color}`);\\n      }\\n      if (node.left != null) {\\n        const parentInfo = `( parent node ${node.left.parent.key})`;\\n        console.log(`${indent}${node.left.key} color: ${node.left.color} ${parentInfo}`);\\n      }\\n      if (node.right != null) {\\n        const parentInfo = `( parent node ${node.right.parent.key})`;\\n        console.log(`${indent}${node.right.key} color: ${node.right.color} ${parentInfo}`);\\n      }\\n      treeHeight -= 1;\\n      this.printHelper(node.left, indent + indent, treeHeight);\\n      this.printHelper(node.right, indent + indent, treeHeight);\\n    }\\n  \\n    /**\\n    * remove all nodes inside the tree\\n    */\\n    emptyTree() {\\n      this.root = null;\\n    }\\n  \\n    /**\\n    * return the min node of a given tree\\n    */\\n    min(node) {\\n      if (node == null || node === undefined) {\\n        return {};\\n      }\\n      while (!isNilNode(node.left)) {\\n        node = node.left;\\n      }\\n      return node;\\n    }\\n  \\n    minNode() {\\n      let node = this.root;\\n      while (!isNilNode(node.left)) {\\n        node = node.left;\\n      }\\n      return node.getValue();\\n    }\\n  \\n    maxNode() {\\n      let node = this.root;\\n      while (!isNilNode(node.right)) {\\n        node = node.right;\\n      }\\n      return node.getValue();\\n    }\\n  \\n    transplant(u, v) {\\n      if (u.parent == null) {\\n        this.root = v;\\n      } else if (u === u.parent.left) {\\n        u.parent.left = v;\\n        u.parent.leftCount = v.leftCount + v.rightCount + 1;\\n      } else {\\n        u.parent.right = v;\\n        u.parent.rightCount = v.leftCount + v.rightCount + 1;\\n      }\\n      v.parent = u.parent;\\n    }\\n  \\n  /**\\n    * method\\n    * param Node node Node.\\n    * return Node\\n    */\\n    remove(key) {\\n      const z = this.findNode(key);\\n      if (z == null) {\\n        return;\\n      }\\n      let x;\\n      let y = z;\\n      let y_original_color = y.color;\\n      if (isNilNode(z.left)) {\\n        x = z.right;\\n        this.transplant(z, z.right);\\n      } else if (isNilNode(z.right)) {\\n        x = z.left;\\n        this.transplant(z, z.left);\\n      } else {\\n        y = this.min(z.right);\\n        y_original_color = y.color;\\n        x = y.right;\\n        if (y.parent === z) {\\n          x.parent = y;\\n        } else {\\n          this.transplant(y, y.right);\\n          y.right = z.right;\\n          y.rightCount = z.rightCount;\\n          y.right.parent = y;\\n        }\\n        this.transplant(z, y);\\n        y.left = z.left;\\n        y.leftCount = z.leftCount;\\n        y.left.parent = y;\\n        y.color = z.color;\\n      }\\n      if (y_original_color === nodeColor.BLACK) {\\n        this.removeFix(x);\\n      }\\n    }\\n  \\n  /**\\n   * a method to fix remove key\\n   */\\n    removeFix(node) {\\n      while (node !== this.root && node.color === nodeColor.BLACK) {\\n        if (node === node.parent.left) {\\n          let w = node.parent.right;\\n          if (w.color === nodeColor.RED) {\\n            w.color = nodeColor.BLACK;\\n            node.parent.color = nodeColor.RED;\\n            this.rotateLeft(node.parent);\\n            w = node.parent.right;\\n          }\\n          if (w.left.color === nodeColor.BLACK && w.right.color === nodeColor.BLACK) {\\n            w.color = nodeColor.RED;\\n            node = node.parent;\\n            continue;\\n          } else if (w.right.color === nodeColor.BLACK) {\\n            w.left.color = nodeColor.BLACK;\\n            w.color = nodeColor.RED;\\n            w = node.parent.right;\\n          }\\n          if (w.right.color === nodeColor.RED) {\\n            w.color = node.parent.color;\\n            node.parent.color = nodeColor.BLACK;\\n            w.right.color = nodeColor.BLACK;\\n            this.rotateLeft(node.parent);\\n            node = this.root;\\n          }\\n        } else {\\n          let w = node.parent.left;\\n          if (w.color === nodeColor.RED) {\\n            w.color = nodeColor.BLACK;\\n            node.parent.color = nodeColor.RED;\\n            this.rotateRight(node.parent);\\n            w = node.parent.left;\\n          }\\n          if (w.right.color === nodeColor.BLACK && w.left.color === nodeColor.BLACK) {\\n            w.color = nodeColor.RED;\\n            node = node.parent;\\n          } else if (w.left.color === nodeColor.BLACK) {\\n            w.right.color = nodeColor.BLACK;\\n            w.color = nodeColor.RED;\\n            this.rotateLeft(w);\\n            w = node.parent.left;\\n          }\\n          if (w.left.color === nodeColor.RED) {\\n            w.color = node.parent.color;\\n            node.parent.color = nodeColor.BLACK;\\n            w.left.color = nodeColor.BLACK;\\n            this.rotateRight(node.parent);\\n            node = this.root;\\n          }\\n        }\\n      }\\n      node.color = nodeColor.BLACK;\\n    }\\n  \\n    inOrderSucc(node) {\\n      if (isNilNode(node)) {\\n        return null;\\n      }\\n      // when a right child exist\\n      if (!isNilNode(node.right)) {\\n        return this.leftMostChild(node.right).getValue();\\n  \\n      // Where no right child exists\\n      } else { // eslint-disable-line\\n        let curr = node;\\n        let p = node.parent;\\n        // if this node is not its parent\\'s left child\\n        while (p != null && p.left !== curr) {\\n          curr = p;\\n          p = p.parent;\\n        }\\n        // when there is no successor\\n        if (p == null) {\\n          return null;\\n        }\\n        return p.getValue();\\n      }\\n    }\\n  \\n    toSortedArray() {\\n      const sortedArray = [];\\n      this.inOrder(this.root, sortedArray);\\n      return sortedArray;\\n    }\\n  \\n    toArrayPreOrder() {\\n      const preOrderArray = [];\\n      this.preOrder(this.root, preOrderArray);\\n      return preOrderArray;\\n    }\\n  \\n    toArrayPostOrder() {\\n      const postOrderArray = [];\\n      this.postOrder(this.root, postOrderArray);\\n      return postOrderArray;\\n    }\\n  \\n    inOrder(node, array) {\\n      if (isNilNode(node)) {\\n        return;\\n      }\\n      this.inOrder(node.left, array);\\n      array.push(node.getValue());\\n      this.inOrder(node.right, array);\\n    }\\n  \\n    preOrder(node, array) {\\n      if (isNilNode(node)) {\\n        return;\\n      }\\n      array.push(node.getValue());\\n      this.preOrder(node.left, array);\\n      this.preOrder(node.right, array);\\n    }\\n  \\n    postOrder(node, array) {\\n      if (isNilNode(node)) {\\n        return;\\n      }\\n      this.postOrder(node.left, array);\\n      this.postOrder(node.right, array);\\n      array.push(node.getValue());\\n    }\\n  \\n    createIterator() {\\n      return new iterator(this.root);\\n    }\\n  \\n  }\\n\\n  const nodeColor = {\\n    RED : 0,\\n    BLACK : 1\\n  }\\n\\n  function createLeafNode(parent) {\\n    let node = new Node(null, null);\\n    node.color = nodeColor.BLACK;\\n    node.parent = parent;\\n    return node;\\n  }\\n\\n  function createNode(key, value) {\\n    let node = new Node(key, value);\\n  \\n    //left leaf has color black. left, right to be nul\\n    let leftLeaf = new Node(null, null);\\n    leftLeaf.color = nodeColor.BLACK;\\n    leftLeaf.left = null;\\n    leftLeaf.right = null;\\n    leftLeaf.parent = node;\\n  \\n    //right leaf has color black. left, right to be nul\\n    let rightLeaf = new Node(null, null);\\n    rightLeaf.color = nodeColor.BLACK;\\n    rightLeaf.left = null;\\n    rightLeaf.right = null;\\n    rightLeaf.parent = node;\\n  \\n    //map leaves\\n    node.left = leftLeaf;\\n    node.right = rightLeaf;\\n    return node;\\n  }\\n  function toNumber(key) {\\n\\n    const offset = 96;\\n    //if key is not a number\\n    if (isNaN(key) && typeof key === \"string\") {\\n      const keyToLower = key.toLowerCase();\\n      if (keyToLower.length > 1) {\\n        let number = \\'\\';\\n        //converting each letter to a number\\n        for (let ch of keyToLower) {\\n          number += ch.charCodeAt(0) - offset + \\'\\';\\n        }\\n        return parseInt(number);\\n      }\\n      return keyToLower.charCodeAt(0) - offset;\\n    }\\n    return key;\\n  }\\n  function isNilNode(node) {\\n    return node == null || (node.key == null && node.value == null\\n           && node.color === nodeColor.BLACK\\n           && node.left == null && node.right == null);\\n  }\\n  class iterator {\\n    constructor(root) {\\n      this.stack = [];\\n      this.curr = root;\\n    }\\n  \\n     hasNext() {\\n       return !isNilNode(this.curr) || this.stack.length > 0;\\n     }\\n  \\n     next() {\\n       while (!isNilNode(this.curr)) {\\n         this.stack.push(this.curr);\\n         this.curr = this.curr.left;\\n       }\\n       this.curr = this.stack.pop();\\n       const node = this.curr;\\n       this.curr = this.curr.right;\\n       return node.getValue();\\n     }\\n  }\\n  class Node {\\n    constructor(key, value) {\\n      this.key = toNumber(key);\\n      this.value = value;\\n      this.left = null;\\n      this.right = null;\\n      this.color = null;\\n      this.parent = null;\\n      this.leftCount = 0;\\n      this.rightCount = 0;\\n    }\\n  \\n    /**\\n    * return Boolean\\n    */\\n    isRed() {\\n      return this.color === nodeColor.RED\\n    }\\n  \\n    getValue() {\\n      return {\\n        key: this.key,\\n        value: this.value,\\n      }\\n    }\\n  }\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countOperationsToEmptyArray = function(nums) {\\n    \\n    const indexValueSorted = nums.map((val, index) => [index, val]);\\n    indexValueSorted.sort((a, b) => b[1] - a[1]);\\n\\n    const linkedList = nums.map((val, index) => new Element(index, val));\\n    linkedList[linkedList.length - 1].right = linkedList[0];\\n    for (let i = 0; i < linkedList.length; i++) {\\n        const nextI = (i + 1) % linkedList.length;\\n        linkedList[i].right = linkedList[nextI];\\n        linkedList[i].left = linkedList[(i - 1 + linkedList.length) % linkedList.length];\\n    }\\n\\n    let currentMin = indexValueSorted.pop();\\n    let operations = currentMin[0] - 0 + 1;\\n    let currentIndex = linkedList[currentMin[0]].right.index;\\n    deleteElement(linkedList, currentMin[0]);\\n    let root = new Element(currentMin[0], currentMin[1]);\\n    const tree = new RbTree();\\n    tree.insert(currentMin[0], currentMin[1]);\\n\\n    while (indexValueSorted.length > 0) {\\n        const [indexMin, valMin] = indexValueSorted.pop();\\n        if (currentIndex <= indexMin) {\\n            const countRemoved = countOfRemovedElements(tree.root, currentIndex, indexMin);\\n            operations += indexMin - currentIndex + 1 - countRemoved;\\n        } else {\\n            const countRemoved = countOfRemovedElements(tree.root, 0, indexMin) +\\n                countOfRemovedElements(tree.root, currentIndex, nums.length - 1);\\n            operations += indexMin + 1 + nums.length - currentIndex - countRemoved;\\n        }\\n        tree.insert(indexMin, valMin);\\n        // next index\\n        currentIndex = linkedList[indexMin].right.index;\\n        deleteElement(linkedList, indexMin);\\n    }\\n    return operations;\\n};\\n\\nclass Element {\\n    constructor(index, value) {\\n        this.index = index;\\n        this.value = value;\\n        this.left = null;\\n        this.right = null;\\n        this.leftCount = 0;\\n        this.rightCount = 0;\\n    }\\n}\\n\\nvar deleteElement = function(eleList, index) {\\n    const ele = eleList[index];\\n    if (ele.left == null || ele.right == null) {\\n        return ele;\\n    }\\n\\n    const leftEle = ele.left;\\n    const rightEle = ele.right;\\n    leftEle.right = rightEle;\\n    rightEle.left = leftEle;\\n    ele.left = ele.right = null;\\n    return rightEle;\\n};\\n\\nvar countOfRemovedElements = function(root, start, end) {\\n    if (isNilNode(root)) {\\n        return 0;\\n    }\\n    const ge = countOfGreatOrEqual(root, start);\\n    const ge1 = countOfGreatOrEqual(root, end + 1);\\n    return ge - ge1;\\n};\\n\\n/**\\n * \\n * @param {Node} root \\n * @param {Number} index \\n * @returns \\n */\\nvar countOfGreatOrEqual = function(root, index) {\\n    if (root == null || isNilNode(root)) {\\n        return 0;\\n    }\\n\\n    if (root.key >= index) {\\n        return countOfGreatOrEqual(root.left, index) + 1 + root.rightCount;\\n    } else {\\n        return countOfGreatOrEqual(root.right, index);\\n    }\\n};\\n\\n/**\\n * constructor\\n * Node of the red black tree\\n * 1.Every node is either red or black\\n * 2.Root and leaves are all black\\n * 3.Every red node has black parent\\n * 4.All simple paths from a node x to a descendant leaves of x has same black nodes\\n */\\nclass RbTree {\\n    constructor() {\\n      this.root = null;\\n    }\\n  \\n  /**\\n    * Complexity: O(1).\\n    *\\n    * param Node node Node.\\n    * return Node a copy of original node\\n    */\\n    clone(node) {\\n      return new Node(node.key, node.value, node.left, node.right, node.color, node.parent);\\n    }\\n  \\n  /**\\n   * find value by node key\\n   */\\n    find(input) {\\n      const key = toNumber(input);\\n      let node = this.root;\\n      while (node != null) {\\n        if (key < node.key) {\\n          node = node.left;\\n        } else if (key > node.key) {\\n          node = node.right;\\n        } else {\\n          return node.value;\\n        }\\n      }\\n      return null;\\n    }\\n  \\n    leftMostChild(node) {\\n      if (isNilNode(node)) {\\n        return null;\\n      }\\n      while (!isNilNode(node.left)) {\\n        node = node.left;\\n      }\\n      return node;\\n    }\\n  \\n    findNode(key) {\\n      let node = this.root;\\n      while (node != null) {\\n        if (key < node.key) {\\n          node = node.left;\\n        } else if (key > node.key) {\\n          node = node.right;\\n        } else if (key === node.key) {\\n          return node;\\n        } else {\\n          return null;\\n        }\\n      }\\n      return null;\\n    }\\n  \\n    update(key, value) {\\n      const node = this.findNode(key);\\n      node.value = value;\\n    }\\n  \\n  /**\\n    * Complexity: O(1).\\n    *       y                   x\\n    *      / \\\\                 / \\\\\\n    *     x  Gamma   ====>   alpha y\\n    *   /  \\\\                      / \\\\\\n    * alpha beta               beta Gamma\\n    * method\\n    * param Node node Node.\\n    * return Node\\n    */\\n    rotateRight(node) {\\n      const y = node.left;\\n  \\n      if (isNilNode(y.right)) {\\n        node.left = createLeafNode(node);\\n        node.leftCount = 0;\\n      } else {\\n        node.left = y.right;\\n        node.leftCount = y.rightCount;\\n      }\\n  \\n      if (!isNilNode(y.right)) {\\n        y.right.parent = node;\\n      }\\n      y.parent = node.parent;\\n      if (isNilNode(node.parent)) {\\n        this.root = y;\\n      } else {\\n        if (node === node.parent.right) {\\n          node.parent.right = y;\\n          // node.parent.rightCount = y.rightCount + y.leftCount + 1;\\n        } else {\\n          node.parent.left = y;\\n          // node.parent.leftCount = y.rightCount + y.leftCount + 1;\\n        }\\n      }\\n      y.right = node;\\n      y.rightCount = node.rightCount + node.leftCount + 1;\\n      node.parent = y;\\n    }\\n  \\n  /**\\n    * Complexity: O(1).\\n    *       y                   x\\n    *      / \\\\                 / \\\\\\n    *     x  Gamma   <====   alpha y\\n    *   /  \\\\                      / \\\\\\n    * alpha beta               beta Gamma\\n    * method\\n    * param Node node Node.\\n    * return Node\\n    */\\n    rotateLeft(node) {\\n      const y = node.right;\\n  \\n      // console.log(y.left)\\n      if (isNilNode(y.left)) {\\n        node.right = createLeafNode(node);\\n        node.rightCount = 0;\\n      } else {\\n        node.right = y.left;\\n        node.rightCount = y.leftCount;\\n      }\\n  \\n      if (!isNilNode(y.left)) {\\n        y.left.parent = node;\\n      }\\n      y.parent = node.parent;\\n      if (isNilNode(node.parent)) {\\n        this.root = y;\\n      } else {\\n        if (node === node.parent.left) {\\n          node.parent.left = y;\\n          // node.parent.leftCount = y.leftCount + y.rightCount + 1;\\n        } else {\\n          node.parent.right = y;\\n          // node.parent.rightCount = y.leftCount + y.rightCount + 1;\\n        }\\n      }\\n      y.left = node;\\n      y.leftCount = node.leftCount + node.rightCount + 1;\\n      node.parent = y;\\n    }\\n  \\n  /**\\n    * param Node node Node.\\n    * Make the color of newly inserted nodes as RED and then perform standard BST insertion\\n    * If x is root, change color of node as BLACK (Black height +1).\\n    */\\n    insert(key, value) {\\n      let y = null;\\n      let x = this.root;\\n      const z = createNode(key, value);\\n      if (this.root == null) {\\n        this.root = z;\\n        z.color = nodeColor.BLACK;\\n        z.parent = null;\\n      } else {\\n        while (!isNilNode(x)) {\\n          y = x;\\n          if (z.key < x.key) {\\n            x = x.left;\\n          } else {\\n            x = x.right;\\n          }\\n        }\\n        z.parent = y;\\n        // current node parent is root\\n        if (z.key < y.key) {\\n          y.left = z;\\n          y.leftCount = z.leftCount + z.rightCount + 1;\\n        } else {\\n          y.right = z;\\n          y.rightCount = z.leftCount + z.rightCount + 1;\\n        }\\n\\n        // update y\\'s parent count\\n        let p = y.parent;\\n        let c = y;\\n        while (!isNilNode(p)) {\\n            if (c === p.left) {\\n                p.leftCount++;\\n            } else {\\n                p.rightCount++;\\n            }\\n            c = p;\\n            p = p.parent;\\n        }\\n        // y.right is now z\\n        z.left = createLeafNode(z);\\n        z.right = createLeafNode(z);\\n        z.leftCount = z.rightCount = 0;\\n        z.color = nodeColor.RED;\\n        this.fixTree(z);\\n      }\\n    }\\n  \\n  /**\\n  * A method to fix RB TREE\\n  * when uncle is RED\\n  * Change color of parent and uncle as BLACK.\\n  * Color of grand parent as RED.\\n  * Change node = node\\u2019s grandparent, repeat steps 2 and 3 for new x.\\n  * ---------------------------------------------------------------\\n  * when uncle is BLACK\\n  * left_left_case\\n  * left_right_case\\n  * right_right_case\\n  * right_left_case\\n  */\\n  \\n    fixTree(node) {\\n      while (node.parent != null && node.parent.color === nodeColor.RED) {\\n        let uncle = null;\\n        if (node.parent === node.parent.parent.left) {\\n          uncle = node.parent.parent.right;\\n  \\n          if (uncle != null && uncle.color === nodeColor.RED) {\\n            node.parent.color = nodeColor.BLACK;\\n            uncle.color = nodeColor.BLACK;\\n            node.parent.parent.color = nodeColor.RED;\\n            node = node.parent.parent;\\n            continue;\\n          }\\n          if (node === node.parent.right) {\\n            // Double rotation needed\\n            node = node.parent;\\n            this.rotateLeft(node);\\n          }\\n          node.parent.color = nodeColor.BLACK;\\n          node.parent.parent.color = nodeColor.RED;\\n          // if the \"else if\" code hasn\\'t executed, this\\n          // is a case where we only need a single rotation\\n          this.rotateRight(node.parent.parent);\\n        } else {\\n          uncle = node.parent.parent.left;\\n          if (uncle != null && uncle.color === nodeColor.RED) {\\n            node.parent.color = nodeColor.BLACK;\\n            uncle.color = nodeColor.BLACK;\\n            node.parent.parent.color = nodeColor.RED;\\n            node = node.parent.parent;\\n            continue;\\n          }\\n          if (node === node.parent.left) {\\n            // Double rotation needed\\n            node = node.parent;\\n            this.rotateRight(node);\\n          }\\n          node.parent.color = nodeColor.BLACK;\\n          node.parent.parent.color = nodeColor.RED;\\n          // if the \"else if\" code hasn\\'t executed, this\\n          // is a case where we only need a single rotation\\n          this.rotateLeft(node.parent.parent);\\n        }\\n      }\\n      this.root.color = nodeColor.BLACK;\\n    }\\n  \\n    /**\\n    * return the height of a tree\\n    */\\n    findHeight(node) {\\n      if (node == null) {\\n        return -1;\\n      }\\n      const leftLen = this.findHeight(node.left);\\n      const rightLen = this.findHeight(node.right);\\n  \\n      if (leftLen > rightLen) {\\n        return leftLen + 1;\\n      }\\n      return rightLen + 1;\\n    }\\n  \\n    /**\\n    * print out current tree\\n    */\\n    print() {\\n      const height = this.findHeight(this.root) + 1;\\n      this.printHelper(this.root, \\'__\\', height);\\n    }\\n  \\n    printHelper(node, indent, height) {\\n      // tree height\\n      let treeHeight = height;\\n  \\n      if (node == null) {\\n        return;\\n      }\\n      if (node === this.root) {\\n        console.log(`${node.key} color: ${node.color}`);\\n      }\\n      if (node.left != null) {\\n        const parentInfo = `( parent node ${node.left.parent.key})`;\\n        console.log(`${indent}${node.left.key} color: ${node.left.color} ${parentInfo}`);\\n      }\\n      if (node.right != null) {\\n        const parentInfo = `( parent node ${node.right.parent.key})`;\\n        console.log(`${indent}${node.right.key} color: ${node.right.color} ${parentInfo}`);\\n      }\\n      treeHeight -= 1;\\n      this.printHelper(node.left, indent + indent, treeHeight);\\n      this.printHelper(node.right, indent + indent, treeHeight);\\n    }\\n  \\n    /**\\n    * remove all nodes inside the tree\\n    */\\n    emptyTree() {\\n      this.root = null;\\n    }\\n  \\n    /**\\n    * return the min node of a given tree\\n    */\\n    min(node) {\\n      if (node == null || node === undefined) {\\n        return {};\\n      }\\n      while (!isNilNode(node.left)) {\\n        node = node.left;\\n      }\\n      return node;\\n    }\\n  \\n    minNode() {\\n      let node = this.root;\\n      while (!isNilNode(node.left)) {\\n        node = node.left;\\n      }\\n      return node.getValue();\\n    }\\n  \\n    maxNode() {\\n      let node = this.root;\\n      while (!isNilNode(node.right)) {\\n        node = node.right;\\n      }\\n      return node.getValue();\\n    }\\n  \\n    transplant(u, v) {\\n      if (u.parent == null) {\\n        this.root = v;\\n      } else if (u === u.parent.left) {\\n        u.parent.left = v;\\n        u.parent.leftCount = v.leftCount + v.rightCount + 1;\\n      } else {\\n        u.parent.right = v;\\n        u.parent.rightCount = v.leftCount + v.rightCount + 1;\\n      }\\n      v.parent = u.parent;\\n    }\\n  \\n  /**\\n    * method\\n    * param Node node Node.\\n    * return Node\\n    */\\n    remove(key) {\\n      const z = this.findNode(key);\\n      if (z == null) {\\n        return;\\n      }\\n      let x;\\n      let y = z;\\n      let y_original_color = y.color;\\n      if (isNilNode(z.left)) {\\n        x = z.right;\\n        this.transplant(z, z.right);\\n      } else if (isNilNode(z.right)) {\\n        x = z.left;\\n        this.transplant(z, z.left);\\n      } else {\\n        y = this.min(z.right);\\n        y_original_color = y.color;\\n        x = y.right;\\n        if (y.parent === z) {\\n          x.parent = y;\\n        } else {\\n          this.transplant(y, y.right);\\n          y.right = z.right;\\n          y.rightCount = z.rightCount;\\n          y.right.parent = y;\\n        }\\n        this.transplant(z, y);\\n        y.left = z.left;\\n        y.leftCount = z.leftCount;\\n        y.left.parent = y;\\n        y.color = z.color;\\n      }\\n      if (y_original_color === nodeColor.BLACK) {\\n        this.removeFix(x);\\n      }\\n    }\\n  \\n  /**\\n   * a method to fix remove key\\n   */\\n    removeFix(node) {\\n      while (node !== this.root && node.color === nodeColor.BLACK) {\\n        if (node === node.parent.left) {\\n          let w = node.parent.right;\\n          if (w.color === nodeColor.RED) {\\n            w.color = nodeColor.BLACK;\\n            node.parent.color = nodeColor.RED;\\n            this.rotateLeft(node.parent);\\n            w = node.parent.right;\\n          }\\n          if (w.left.color === nodeColor.BLACK && w.right.color === nodeColor.BLACK) {\\n            w.color = nodeColor.RED;\\n            node = node.parent;\\n            continue;\\n          } else if (w.right.color === nodeColor.BLACK) {\\n            w.left.color = nodeColor.BLACK;\\n            w.color = nodeColor.RED;\\n            w = node.parent.right;\\n          }\\n          if (w.right.color === nodeColor.RED) {\\n            w.color = node.parent.color;\\n            node.parent.color = nodeColor.BLACK;\\n            w.right.color = nodeColor.BLACK;\\n            this.rotateLeft(node.parent);\\n            node = this.root;\\n          }\\n        } else {\\n          let w = node.parent.left;\\n          if (w.color === nodeColor.RED) {\\n            w.color = nodeColor.BLACK;\\n            node.parent.color = nodeColor.RED;\\n            this.rotateRight(node.parent);\\n            w = node.parent.left;\\n          }\\n          if (w.right.color === nodeColor.BLACK && w.left.color === nodeColor.BLACK) {\\n            w.color = nodeColor.RED;\\n            node = node.parent;\\n          } else if (w.left.color === nodeColor.BLACK) {\\n            w.right.color = nodeColor.BLACK;\\n            w.color = nodeColor.RED;\\n            this.rotateLeft(w);\\n            w = node.parent.left;\\n          }\\n          if (w.left.color === nodeColor.RED) {\\n            w.color = node.parent.color;\\n            node.parent.color = nodeColor.BLACK;\\n            w.left.color = nodeColor.BLACK;\\n            this.rotateRight(node.parent);\\n            node = this.root;\\n          }\\n        }\\n      }\\n      node.color = nodeColor.BLACK;\\n    }\\n  \\n    inOrderSucc(node) {\\n      if (isNilNode(node)) {\\n        return null;\\n      }\\n      // when a right child exist\\n      if (!isNilNode(node.right)) {\\n        return this.leftMostChild(node.right).getValue();\\n  \\n      // Where no right child exists\\n      } else { // eslint-disable-line\\n        let curr = node;\\n        let p = node.parent;\\n        // if this node is not its parent\\'s left child\\n        while (p != null && p.left !== curr) {\\n          curr = p;\\n          p = p.parent;\\n        }\\n        // when there is no successor\\n        if (p == null) {\\n          return null;\\n        }\\n        return p.getValue();\\n      }\\n    }\\n  \\n    toSortedArray() {\\n      const sortedArray = [];\\n      this.inOrder(this.root, sortedArray);\\n      return sortedArray;\\n    }\\n  \\n    toArrayPreOrder() {\\n      const preOrderArray = [];\\n      this.preOrder(this.root, preOrderArray);\\n      return preOrderArray;\\n    }\\n  \\n    toArrayPostOrder() {\\n      const postOrderArray = [];\\n      this.postOrder(this.root, postOrderArray);\\n      return postOrderArray;\\n    }\\n  \\n    inOrder(node, array) {\\n      if (isNilNode(node)) {\\n        return;\\n      }\\n      this.inOrder(node.left, array);\\n      array.push(node.getValue());\\n      this.inOrder(node.right, array);\\n    }\\n  \\n    preOrder(node, array) {\\n      if (isNilNode(node)) {\\n        return;\\n      }\\n      array.push(node.getValue());\\n      this.preOrder(node.left, array);\\n      this.preOrder(node.right, array);\\n    }\\n  \\n    postOrder(node, array) {\\n      if (isNilNode(node)) {\\n        return;\\n      }\\n      this.postOrder(node.left, array);\\n      this.postOrder(node.right, array);\\n      array.push(node.getValue());\\n    }\\n  \\n    createIterator() {\\n      return new iterator(this.root);\\n    }\\n  \\n  }\\n\\n  const nodeColor = {\\n    RED : 0,\\n    BLACK : 1\\n  }\\n\\n  function createLeafNode(parent) {\\n    let node = new Node(null, null);\\n    node.color = nodeColor.BLACK;\\n    node.parent = parent;\\n    return node;\\n  }\\n\\n  function createNode(key, value) {\\n    let node = new Node(key, value);\\n  \\n    //left leaf has color black. left, right to be nul\\n    let leftLeaf = new Node(null, null);\\n    leftLeaf.color = nodeColor.BLACK;\\n    leftLeaf.left = null;\\n    leftLeaf.right = null;\\n    leftLeaf.parent = node;\\n  \\n    //right leaf has color black. left, right to be nul\\n    let rightLeaf = new Node(null, null);\\n    rightLeaf.color = nodeColor.BLACK;\\n    rightLeaf.left = null;\\n    rightLeaf.right = null;\\n    rightLeaf.parent = node;\\n  \\n    //map leaves\\n    node.left = leftLeaf;\\n    node.right = rightLeaf;\\n    return node;\\n  }\\n  function toNumber(key) {\\n\\n    const offset = 96;\\n    //if key is not a number\\n    if (isNaN(key) && typeof key === \"string\") {\\n      const keyToLower = key.toLowerCase();\\n      if (keyToLower.length > 1) {\\n        let number = \\'\\';\\n        //converting each letter to a number\\n        for (let ch of keyToLower) {\\n          number += ch.charCodeAt(0) - offset + \\'\\';\\n        }\\n        return parseInt(number);\\n      }\\n      return keyToLower.charCodeAt(0) - offset;\\n    }\\n    return key;\\n  }\\n  function isNilNode(node) {\\n    return node == null || (node.key == null && node.value == null\\n           && node.color === nodeColor.BLACK\\n           && node.left == null && node.right == null);\\n  }\\n  class iterator {\\n    constructor(root) {\\n      this.stack = [];\\n      this.curr = root;\\n    }\\n  \\n     hasNext() {\\n       return !isNilNode(this.curr) || this.stack.length > 0;\\n     }\\n  \\n     next() {\\n       while (!isNilNode(this.curr)) {\\n         this.stack.push(this.curr);\\n         this.curr = this.curr.left;\\n       }\\n       this.curr = this.stack.pop();\\n       const node = this.curr;\\n       this.curr = this.curr.right;\\n       return node.getValue();\\n     }\\n  }\\n  class Node {\\n    constructor(key, value) {\\n      this.key = toNumber(key);\\n      this.value = value;\\n      this.left = null;\\n      this.right = null;\\n      this.color = null;\\n      this.parent = null;\\n      this.leftCount = 0;\\n      this.rightCount = 0;\\n    }\\n  \\n    /**\\n    * return Boolean\\n    */\\n    isRed() {\\n      return this.color === nodeColor.RED\\n    }\\n  \\n    getValue() {\\n      return {\\n        key: this.key,\\n        value: this.value,\\n      }\\n    }\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908291,
                "title": "c-math-iq",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < n; ++i) mp[nums[i]] = i;\\n        sort(nums.begin(), nums.end());\\n        long long res = 0LL;\\n        for(int i = 1; i < n; ++i) if(mp[nums[i]] < mp[nums[i - 1]]) res += (n - i);\\n        return res + n;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < n; ++i) mp[nums[i]] = i;\\n        sort(nums.begin(), nums.end());\\n        long long res = 0LL;\\n        for(int i = 1; i < n; ++i) if(mp[nums[i]] < mp[nums[i - 1]]) res += (n - i);\\n        return res + n;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904844,
                "title": "c-segment-tree",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$(O(n))$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    class SegTree {\\n        int n;\\n        vector<int> vals;\\n        int set(int i, int ind, int l ,int sz, int v) {\\n            if(ind < l || ind >= l + sz) {\\n                return vals[i];\\n            }\\n            if(sz == 1) {\\n                return vals[i] = v;\\n            }\\n            return vals[i] = set(i + i + 1, ind, l, sz /2, v) + set(i + i + 2, ind, l + sz / 2, sz - sz/2, v);\\n        }\\n\\n        int getSums(int i, int st, int sz, int l ,int lsz) {\\n            if(l >= st + sz || st >= l + lsz || sz == 0 || lsz == 0) {\\n                return 0;\\n            }\\n            if(l <= st && l + lsz >= st + sz) {\\n                return vals[i];\\n            }\\n\\n            return getSums(i + i + 1, st, sz / 2, l , lsz) + getSums(i + i + 2, st + sz /2, sz - sz /2, l, lsz);\\n\\n        }\\n\\n        public:\\n        SegTree(int n): n(n), vals(vector<int>(n * 4, 0)) {}\\n        int set(int ind, int val) {\\n            return set(0,ind,0,n,val);\\n        }\\n\\n        int getSums(int l, int sz) {\\n            return getSums(0, 0, n, l, sz);\\n        } \\n     };\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        vector<int> indices;\\n        for(int i=0;i<nums.size();i++) {\\n            indices.push_back(i);\\n        }\\n        sort(indices.begin(), indices.end(), [&nums]( const int& lhs, const int& rhs ){return nums[lhs] < nums[rhs];});\\n        SegTree segTree(indices.size());\\n        int cur = 0;\\n        long long cost = 0;\\n        for(int i=0;i<indices.size();i++) {\\n            if(indices[i] < cur) {\\n                // reset to start\\n                cost+= (indices.size() - cur) - segTree.getSums(cur, indices.size() - cur);\\n                cur = 0;\\n            }\\n            cost += (indices[i] - cur) - segTree.getSums(cur, indices[i] - cur);\\n            cost++;\\n            cur = indices[i] + 1;\\n            segTree.set(indices[i], 1);\\n        }\\n        return cost;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class SegTree {\\n        int n;\\n        vector<int> vals;\\n        int set(int i, int ind, int l ,int sz, int v) {\\n            if(ind < l || ind >= l + sz) {\\n                return vals[i];\\n            }\\n            if(sz == 1) {\\n                return vals[i] = v;\\n            }\\n            return vals[i] = set(i + i + 1, ind, l, sz /2, v) + set(i + i + 2, ind, l + sz / 2, sz - sz/2, v);\\n        }\\n\\n        int getSums(int i, int st, int sz, int l ,int lsz) {\\n            if(l >= st + sz || st >= l + lsz || sz == 0 || lsz == 0) {\\n                return 0;\\n            }\\n            if(l <= st && l + lsz >= st + sz) {\\n                return vals[i];\\n            }\\n\\n            return getSums(i + i + 1, st, sz / 2, l , lsz) + getSums(i + i + 2, st + sz /2, sz - sz /2, l, lsz);\\n\\n        }\\n\\n        public:\\n        SegTree(int n): n(n), vals(vector<int>(n * 4, 0)) {}\\n        int set(int ind, int val) {\\n            return set(0,ind,0,n,val);\\n        }\\n\\n        int getSums(int l, int sz) {\\n            return getSums(0, 0, n, l, sz);\\n        } \\n     };\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        vector<int> indices;\\n        for(int i=0;i<nums.size();i++) {\\n            indices.push_back(i);\\n        }\\n        sort(indices.begin(), indices.end(), [&nums]( const int& lhs, const int& rhs ){return nums[lhs] < nums[rhs];});\\n        SegTree segTree(indices.size());\\n        int cur = 0;\\n        long long cost = 0;\\n        for(int i=0;i<indices.size();i++) {\\n            if(indices[i] < cur) {\\n                // reset to start\\n                cost+= (indices.size() - cur) - segTree.getSums(cur, indices.size() - cur);\\n                cur = 0;\\n            }\\n            cost += (indices[i] - cur) - segTree.getSums(cur, indices[i] - cur);\\n            cost++;\\n            cur = indices[i] + 1;\\n            segTree.set(indices[i], 1);\\n        }\\n        return cost;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899291,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  long long countOperationsToEmptyArray(vector<int>& nums) {\\n    const int n = nums.size();\\n    long long ans = n;\\n    unordered_map<int, int> numToIndex;\\n\\n    for (int i = 0; i < n; ++i)\\n      numToIndex[nums[i]] = i;\\n\\n    sort(nums.begin(), nums.end());\\n\\n    for (int i = 1; i < n; ++i)\\n      // On i-th step we\\'ve already removed i - 1 smallest nums and can ignore\\n      // them. If an element nums[i] has smaller index in origin array than\\n      // nums[i - 1], we should rotate whole left array n - i times to set\\n      // nums[i] element on the 1st position.\\n      if (numToIndex[nums[i]] < numToIndex[nums[i - 1]])\\n        ans += n - i;\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  long long countOperationsToEmptyArray(vector<int>& nums) {\\n    const int n = nums.size();\\n    long long ans = n;\\n    unordered_map<int, int> numToIndex;\\n\\n    for (int i = 0; i < n; ++i)\\n      numToIndex[nums[i]] = i;\\n\\n    sort(nums.begin(), nums.end());\\n\\n    for (int i = 1; i < n; ++i)\\n      // On i-th step we\\'ve already removed i - 1 smallest nums and can ignore\\n      // them. If an element nums[i] has smaller index in origin array than\\n      // nums[i - 1], we should rotate whole left array n - i times to set\\n      // nums[i] element on the 1st position.\\n      if (numToIndex[nums[i]] < numToIndex[nums[i - 1]])\\n        ans += n - i;\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818032,
                "title": "sorted-list-nothing-fancy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        nums_with_inds = [(nums[i],i) for i in range(len(nums))]\\n        nums_with_inds.sort()\\n        a = SortedList([nums_with_inds[0][1]])\\n        total_len = nums_with_inds[0][1]+1\\n        for i in range(len(nums_with_inds)-1):\\n            start_ind = nums_with_inds[i][1]\\n            end_ind = nums_with_inds[i+1][1]\\n            if end_ind>start_ind:\\n                total_len += end_ind-start_ind\\n                removed_len = a.bisect_left(end_ind)-a.bisect_left(start_ind+1)\\n                total_len -= removed_len\\n            else:\\n                total_len += (len(nums_with_inds)-start_ind)+end_ind\\n                non_removed_len = a.bisect_right(start_ind) - a.bisect_left(end_ind)\\n                total_len -= len(a)-non_removed_len\\n            a.add(nums_with_inds[i+1][1])\\n\\n        return total_len    \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        nums_with_inds = [(nums[i],i) for i in range(len(nums))]\\n        nums_with_inds.sort()\\n        a = SortedList([nums_with_inds[0][1]])\\n        total_len = nums_with_inds[0][1]+1\\n        for i in range(len(nums_with_inds)-1):\\n            start_ind = nums_with_inds[i][1]\\n            end_ind = nums_with_inds[i+1][1]\\n            if end_ind>start_ind:\\n                total_len += end_ind-start_ind\\n                removed_len = a.bisect_left(end_ind)-a.bisect_left(start_ind+1)\\n                total_len -= removed_len\\n            else:\\n                total_len += (len(nums_with_inds)-start_ind)+end_ind\\n                non_removed_len = a.bisect_right(start_ind) - a.bisect_left(end_ind)\\n                total_len -= len(a)-non_removed_len\\n            a.add(nums_with_inds[i+1][1])\\n\\n        return total_len    \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809671,
                "title": "easy-priority-queue-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        // min heap of {nums[i],i}\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i = 0;i<nums.size();i++){\\n            pq.push({nums[i],i});\\n        }\\n        \\n        long long ans = 0;\\n        int len = nums.size();\\n        int ind = -1;\\n        while(!pq.empty()){\\n            int mini = pq.top().first;\\n            int ind = pq.top().second;\\n            pq.pop();\\n            ans+=len;\\n            len--;\\n            while(!pq.empty() && pq.top().second>ind){\\n                if(pq.top().second>ind){\\n                    ind = pq.top().second;\\n                    pq.pop();\\n                    len--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        // min heap of {nums[i],i}\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i = 0;i<nums.size();i++){\\n            pq.push({nums[i],i});\\n        }\\n        \\n        long long ans = 0;\\n        int len = nums.size();\\n        int ind = -1;\\n        while(!pq.empty()){\\n            int mini = pq.top().first;\\n            int ind = pq.top().second;\\n            pq.pop();\\n            ans+=len;\\n            len--;\\n            while(!pq.empty() && pq.top().second>ind){\\n                if(pq.top().second>ind){\\n                    ind = pq.top().second;\\n                    pq.pop();\\n                    len--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649160,
                "title": "use-array-instead-of-hashmap-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n=nums.length;\\n        Integer[] arr=new Integer[n];\\n        for(int i=0;i<n;i++)arr[i]=i;\\n\\n        Arrays.sort(arr,(i,j)->nums[i]-nums[j]);\\n        long ans=n;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(arr[i]<arr[i-1])ans+=n-i;\\n        }\\n        return ans;\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n=nums.length;\\n        Integer[] arr=new Integer[n];\\n        for(int i=0;i<n;i++)arr[i]=i;\\n\\n        Arrays.sort(arr,(i,j)->nums[i]-nums[j]);\\n        long ans=n;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(arr[i]<arr[i-1])ans+=n-i;\\n        }\\n        return ans;\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644346,
                "title": "c-steps-counting-simple-and-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nthere will be n fixed steps for deleting each element ,now we look on arrangement ,store the index and then sort the array. Now look at the element ,suppose we need to delete arr[i] there arises two conditions if the index of element arr[i] is smaller than index of arr[i-1] then the element need to round the complete array(left after deleting previous elements) i elements already deleted so n-i steps needed to come for deletion.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        map<int,int>index;\\n        int n=nums.size();\\n\\n        //storing index of every element\\n        for(int i=0;i<n;i++){\\n            index[nums[i]]=i;\\n        }\\n\\n        sort(nums.begin(),nums.end());\\n\\n        //deleting steps (necessory steps)\\n        long long ans=n;\\n\\n        for(int i=1;i<n;i++){\\n\\n            if(index[nums[i]]<index[nums[i-1]]){\\n                ans+=(n-i);  //counts of steps needed after deletion of previous elements\\n            }\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        map<int,int>index;\\n        int n=nums.size();\\n\\n        //storing index of every element\\n        for(int i=0;i<n;i++){\\n            index[nums[i]]=i;\\n        }\\n\\n        sort(nums.begin(),nums.end());\\n\\n        //deleting steps (necessory steps)\\n        long long ans=n;\\n\\n        for(int i=1;i<n;i++){\\n\\n            if(index[nums[i]]<index[nums[i-1]]){\\n                ans+=(n-i);  //counts of steps needed after deletion of previous elements\\n            }\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569494,
                "title": "fully-commented-greedy-approach-with-a-bit-explanation",
                "content": "-> We will eliminate elements in ascending order\\n-> Whenever we will recive a number which have a lower index than the previous element it indicate that we have to do iteration again from starting index after removing the previous smaller values.\\n-> Hence in this iteration had to iterate on n(current size) values.\\n-> Then update the n(current size) as we have removed the smaller values.\\n-> Now just keep updating res accordingly.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        // Unordered Map for storing the orignal indexes of nums\\'s values.\\n        unordered_map<int, int> record;\\n        int n = nums.size();\\n        // Setting the values of nums to i the indexs respectively.\\n        for(int i = 0; i < n; i++) record[nums[i]] = i;\\n        // sorting to eleminate the number in orderwise fashion.\\n        sort(nums.begin(), nums.end());\\n        // res contain the out result.\\n        // miss contain the number of element present at current moment.\\n        // Size is curr size after eliminating the previous elements.\\n        // Prev is the previous index at which the smaller element was found.\\n        long long res = 0, miss = 0,size = n, prev = -1;\\n        for(int i = 0; i < n; i++){\\n        // If our previous index is greater than current index we will add the size to our result.\\n        // As we have to do size time iteration and again come to index 0 so we update our result and size.\\n            if(prev > record[nums[i]]){\\n                res = res + size;\\n                size = n - miss;\\n            }\\n        // We\\'ll update the prev regularly and increment miss as deleted values.\\n            prev = record[nums[i]];\\n            miss++;\\n        }\\n        return res + size;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        // Unordered Map for storing the orignal indexes of nums\\'s values.\\n        unordered_map<int, int> record;\\n        int n = nums.size();\\n        // Setting the values of nums to i the indexs respectively.\\n        for(int i = 0; i < n; i++) record[nums[i]] = i;\\n        // sorting to eleminate the number in orderwise fashion.\\n        sort(nums.begin(), nums.end());\\n        // res contain the out result.\\n        // miss contain the number of element present at current moment.\\n        // Size is curr size after eliminating the previous elements.\\n        // Prev is the previous index at which the smaller element was found.\\n        long long res = 0, miss = 0,size = n, prev = -1;\\n        for(int i = 0; i < n; i++){\\n        // If our previous index is greater than current index we will add the size to our result.\\n        // As we have to do size time iteration and again come to index 0 so we update our result and size.\\n            if(prev > record[nums[i]]){\\n                res = res + size;\\n                size = n - miss;\\n            }\\n        // We\\'ll update the prev regularly and increment miss as deleted values.\\n            prev = record[nums[i]];\\n            miss++;\\n        }\\n        return res + size;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552720,
                "title": "solution-in-python-sorted-plus-fenwick-tree",
                "content": "# Intuition\\nActually described operations can be represented as movinmg through the array as it were cycled. We move through the array and stop at the minimum element with excluding it. So finally we exclude all elements and the array will be empty.\\n\\n# Approach\\n1. Transform the array into pairs of values and indices and sort it.\\n2. After that it\\'s enough to traverse the sorted array once and compute the number of operations as the distance between the minimum element and the previous minimum element.\\n\\nIf idx[i] < idx[i - 1] it means we have to start a new loop and the distance will be len(nums) - (idx[i - 1] - idx[i]). Otherwise we just go to the next minimum element i.e. idx[i] - idx[i - 1].\\n\\nThere is an additional difficulty. We have to skip already removed elements. So for each idx[i] and idx[i-1] we have to know how many elements were removed between them. Fenwick tree is the most optimized structure for that.\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass FenwickTree:\\n  def __init__(self, capacity):\\n    self.fwt = [0] * capacity\\n    self.capacity = len(self.fwt)\\n\\n  def query(self, idx):\\n    result = 0\\n    while idx > 0:\\n      result += self.fwt[idx]\\n      idx -= idx & -idx\\n    \\n    return result\\n\\n  def update(self, idx, val):\\n    while idx < self.capacity:\\n      self.fwt[idx] += val\\n      idx += idx & -idx\\n\\nclass Solution(object):\\n  def countOperationsToEmptyArray(self, nums):\\n    \"\"\"\\n    :type nums: List[int]\\n    :rtype: int\\n    \"\"\"\\n    result = 0\\n    sorted_nums = sorted([(num, idx) for idx, num in enumerate(nums)])\\n    fwt = FenwickTree(len(nums) + 1)\\n    curr_idx = -1\\n    for _, idx in sorted_nums:\\n      left_r = fwt.query(min(curr_idx + 1, idx + 1))\\n      right_r = fwt.query(max(curr_idx + 1, idx + 1))\\n      if curr_idx < idx:\\n        removed = right_r - left_r\\n        result += idx - curr_idx\\n      else:\\n        removed = fwt.query(len(nums)) - right_r + left_r\\n        result += len(nums) - (curr_idx - idx)\\n      curr_idx = idx\\n      result -= removed\\n      fwt.update(idx + 1, 1)\\n    return result\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass FenwickTree:\\n  def __init__(self, capacity):\\n    self.fwt = [0] * capacity\\n    self.capacity = len(self.fwt)\\n\\n  def query(self, idx):\\n    result = 0\\n    while idx > 0:\\n      result += self.fwt[idx]\\n      idx -= idx & -idx\\n    \\n    return result\\n\\n  def update(self, idx, val):\\n    while idx < self.capacity:\\n      self.fwt[idx] += val\\n      idx += idx & -idx\\n\\nclass Solution(object):\\n  def countOperationsToEmptyArray(self, nums):\\n    \"\"\"\\n    :type nums: List[int]\\n    :rtype: int\\n    \"\"\"\\n    result = 0\\n    sorted_nums = sorted([(num, idx) for idx, num in enumerate(nums)])\\n    fwt = FenwickTree(len(nums) + 1)\\n    curr_idx = -1\\n    for _, idx in sorted_nums:\\n      left_r = fwt.query(min(curr_idx + 1, idx + 1))\\n      right_r = fwt.query(max(curr_idx + 1, idx + 1))\\n      if curr_idx < idx:\\n        removed = right_r - left_r\\n        result += idx - curr_idx\\n      else:\\n        removed = fwt.query(len(nums)) - right_r + left_r\\n        result += len(nums) - (curr_idx - idx)\\n      curr_idx = idx\\n      result -= removed\\n      fwt.update(idx + 1, 1)\\n    return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549723,
                "title": "best-code-execute-faster-than-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        vector<pair<int,int>> a;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            a.push_back({nums[i],i});\\n        }\\n        long long ans=n;\\n        sort(a.begin(),a.end());\\n        for(int i=1;i<n;i++)\\n        {\\n            int k=a[i].second;\\n            if(k<a[i-1].second)\\n            {\\n                ans+=n-i;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Binary Indexed Tree",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        vector<pair<int,int>> a;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            a.push_back({nums[i],i});\\n        }\\n        long long ans=n;\\n        sort(a.begin(),a.end());\\n        for(int i=1;i<n;i++)\\n        {\\n            int k=a[i].second;\\n            if(k<a[i-1].second)\\n            {\\n                ans+=n-i;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544418,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)-> Integer.compare(nums[a],nums[b]));\\n        int n = nums.length;\\n        for (int i=0;i<n;i++) pq.offer(i);\\n        int cur = pq.poll();\\n        long ans= n;\\n  \\n        while (!pq.isEmpty()){\\n            n--;\\n            int nextIndex =  pq.poll();\\n            if (nextIndex<cur) ans += n;\\n            cur = nextIndex;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)-> Integer.compare(nums[a],nums[b]));\\n        int n = nums.length;\\n        for (int i=0;i<n;i++) pq.offer(i);\\n        int cur = pq.poll();\\n        long ans= n;\\n  \\n        while (!pq.isEmpty()){\\n            n--;\\n            int nextIndex =  pq.poll();\\n            if (nextIndex<cur) ans += n;\\n            cur = nextIndex;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534144,
                "title": "no-explicit-sort-usage-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        std::map<int, int> idx{};\\n        for(int i = 0; i < nums.size(); i++)\\n          idx[nums[i]] = i;\\n\\n        long long res{};\\n        auto elems{ nums.size() };\\n        auto last_idx{ nums.size() }; // bigger then max idx->val\\n        \\n        for(const auto& [k,v] : idx) // iterate over std::map gives key-sorted sequence\\n        { \\n          if(last_idx > v) res += elems; \\n          \\n          last_idx = v;\\n          --elems;  \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        std::map<int, int> idx{};\\n        for(int i = 0; i < nums.size(); i++)\\n          idx[nums[i]] = i;\\n\\n        long long res{};\\n        auto elems{ nums.size() };\\n        auto last_idx{ nums.size() }; // bigger then max idx->val\\n        \\n        for(const auto& [k,v] : idx) // iterate over std::map gives key-sorted sequence\\n        { \\n          if(last_idx > v) res += elems; \\n          \\n          last_idx = v;\\n          --elems;  \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517635,
                "title": "c-segment-tree-and-ordered-map",
                "content": "```\\nclass Solution {\\n    void updateIndex(int index,int sz,vector<int>& st){\\n        st[sz+index]++;\\n        index = sz+index;\\n        for (int i=index;i>1;i>>=1){\\n            st[i>>1] = st[i] + st[i^1];\\n        }\\n    }\\n    int query(int l,int r,int sz,vector<int>& st){\\n        int res = 0;\\n      \\n        // loop to find the sum in the range\\n        for (l += sz, r += sz; l < r; l >>= 1, r >>= 1)\\n        {\\n            if (l&1) \\n                res += st[l++];\\n\\n            if (r&1) \\n                res += st[--r];\\n        }\\n        return res;\\n    }\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        \\n        map<int,int> dp;\\n        for(int i=0;i<nums.size();i++){\\n            dp[nums[i]]=i;\\n        }\\n        \\n        vector<int> m {-1};\\n        long long ans =0;\\n        int pi=-1;\\n        int sz = nums.size();\\n        int lb=0;\\n        vector<int> st (2*sz,0);\\n        for(auto const& [key, val] : dp){\\n            if (val>pi){\\n                lb = query(pi+1,val,sz,st);\\n                ans += val-pi-(lb);\\n            }\\n            else{\\n                lb = query(pi+1,sz,sz,st);\\n                ans += sz-1-pi-(lb);\\n                lb = query(0,val,sz,st);\\n                ans += val+1 - (lb);\\n            }\\n            pi = val;\\n            updateIndex(val,sz,st);\\n            //cout << \"ans:\" << ans << \" key:\" <<key << \" val:\" << val << endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void updateIndex(int index,int sz,vector<int>& st){\\n        st[sz+index]++;\\n        index = sz+index;\\n        for (int i=index;i>1;i>>=1){\\n            st[i>>1] = st[i] + st[i^1];\\n        }\\n    }\\n    int query(int l,int r,int sz,vector<int>& st){\\n        int res = 0;\\n      \\n        // loop to find the sum in the range\\n        for (l += sz, r += sz; l < r; l >>= 1, r >>= 1)\\n        {\\n            if (l&1) \\n                res += st[l++];\\n\\n            if (r&1) \\n                res += st[--r];\\n        }\\n        return res;\\n    }\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        \\n        map<int,int> dp;\\n        for(int i=0;i<nums.size();i++){\\n            dp[nums[i]]=i;\\n        }\\n        \\n        vector<int> m {-1};\\n        long long ans =0;\\n        int pi=-1;\\n        int sz = nums.size();\\n        int lb=0;\\n        vector<int> st (2*sz,0);\\n        for(auto const& [key, val] : dp){\\n            if (val>pi){\\n                lb = query(pi+1,val,sz,st);\\n                ans += val-pi-(lb);\\n            }\\n            else{\\n                lb = query(pi+1,sz,sz,st);\\n                ans += sz-1-pi-(lb);\\n                lb = query(0,val,sz,st);\\n                ans += val+1 - (lb);\\n            }\\n            pi = val;\\n            updateIndex(val,sz,st);\\n            //cout << \"ans:\" << ans << \" key:\" <<key << \" val:\" << val << endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3515271,
                "title": "c-solution-using-segment-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    int size;\\n    vector<int> tree;\\n    void add(int pos) {\\n        tree[size + pos - 1] = 1;\\n        for (int i = (size + pos - 2) / 2; i > 0; i = (i - 1) / 2) {\\n            tree[i] = tree[2 * i + 1] + tree[2 * i + 2];\\n        }\\n        if (size > 1) {\\n            tree[0] = tree[1] + tree[2];\\n        }\\n    }\\n    int getSum(int root, int l, int r, int left, int right) {\\n        if (right < l || left > r) return 0;\\n        if (left >= l && right <= r) return tree[root];\\n        int mid = (left + right) / 2;\\n        return getSum(2 * root + 1, l, r, left, mid) + getSum(2 * root + 2, l, r, mid + 1, right);\\n    }\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> in(n);\\n        iota(in.begin(), in.end(), 0);\\n        sort(in.begin(), in.end(), [&] (int i, int j) {\\n            return nums[i] < nums[j];\\n        });\\n        size = 1;\\n        while (size < n) {\\n            size *= 2;\\n        }\\n        tree = vector<int> (2 * size - 1);\\n        int cur = 0;\\n        long long sol = 0;\\n        for (int i = 0; i < n; i++) {\\n            int pos = in[i];\\n            if (cur <= pos) {\\n                int sum = getSum(0, cur, pos, 0, size - 1);\\n                int diff = pos - cur - sum;\\n                sol += diff + 1;\\n            } else {\\n                int sum = getSum(0, cur, n - 1, 0, size - 1);\\n                sum += getSum(0, 0, pos, 0, size - 1);\\n                int diff = n - (cur - pos) - sum;\\n                sol += diff + 1;\\n            }\\n            add(pos);\\n            cur = (pos + 1) % n;\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int size;\\n    vector<int> tree;\\n    void add(int pos) {\\n        tree[size + pos - 1] = 1;\\n        for (int i = (size + pos - 2) / 2; i > 0; i = (i - 1) / 2) {\\n            tree[i] = tree[2 * i + 1] + tree[2 * i + 2];\\n        }\\n        if (size > 1) {\\n            tree[0] = tree[1] + tree[2];\\n        }\\n    }\\n    int getSum(int root, int l, int r, int left, int right) {\\n        if (right < l || left > r) return 0;\\n        if (left >= l && right <= r) return tree[root];\\n        int mid = (left + right) / 2;\\n        return getSum(2 * root + 1, l, r, left, mid) + getSum(2 * root + 2, l, r, mid + 1, right);\\n    }\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> in(n);\\n        iota(in.begin(), in.end(), 0);\\n        sort(in.begin(), in.end(), [&] (int i, int j) {\\n            return nums[i] < nums[j];\\n        });\\n        size = 1;\\n        while (size < n) {\\n            size *= 2;\\n        }\\n        tree = vector<int> (2 * size - 1);\\n        int cur = 0;\\n        long long sol = 0;\\n        for (int i = 0; i < n; i++) {\\n            int pos = in[i];\\n            if (cur <= pos) {\\n                int sum = getSum(0, cur, pos, 0, size - 1);\\n                int diff = pos - cur - sum;\\n                sol += diff + 1;\\n            } else {\\n                int sum = getSum(0, cur, n - 1, 0, size - 1);\\n                sum += getSum(0, 0, pos, 0, size - 1);\\n                int diff = n - (cur - pos) - sum;\\n                sol += diff + 1;\\n            }\\n            add(pos);\\n            cur = (pos + 1) % n;\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514029,
                "title": "javascript-segmenttree-range-sum-query-fenwick-bit-two-solutions",
                "content": "segmentTree range Sum Query: 484ms\\n```\\nfunction SegmentTreeRSQ(n) {\\n    let h = Math.ceil(Math.log2(n)), len = 2 * 2 ** h, a = Array(len).fill(0);\\n    return { update, query, rangeSum, tree }\\n    function update(pos, v) {\\n        a[n + pos] = v;\\n        for (let i = parent(n + pos); i >= 1; i = parent(i)) pushup(i);\\n    }\\n    function pushup(i) {\\n        a[i] = a[left(i)] + a[right(i)];\\n    }\\n    function query(l, r) { // [L, R)\\n        let sum = 0;\\n        if (l >= r) return 0;\\n        l += n;\\n        r += n;\\n        for (; l < r; l = parent(l), r = parent(r)) {\\n            if (l & 1) sum += a[l++];\\n            if (r & 1) sum += a[--r];\\n        }\\n        return sum;\\n    }\\n    function rangeSum(l, r) {\\n        return query(0, r + 1) - query(0, l);\\n    }\\n    function parent(i) {\\n        return i >> 1;\\n    }\\n    function left(i) {\\n        return 2 * i;\\n    }\\n    function right(i) {\\n        return 2 * i + 1;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nconst countOperationsToEmptyArray = (a) => {\\n    let n = a.length, st = new SegmentTreeRSQ(n + 3), res = n, pre = 0, f = Array(n + 1).fill(0);\\n    a = a.map((x, i) => [x, i + 1]).sort((x, y) => x[0] - y[0] || x[1] - y[1]);\\n    a.map(e => {\\n        let [, idx] = e;\\n        res += idx - 1 - st.rangeSum(0, idx - 1);\\n        if (pre < idx) {\\n            res -= pre - st.rangeSum(0, pre);\\n        } else {\\n            res += (n - pre) - (st.rangeSum(0, n) - st.rangeSum(0, pre));\\n        }\\n        pre = idx;\\n        st.update(idx, ++f[idx]);\\n    })\\n    return res;\\n};\\n```\\n\\nfenwick: 386ms\\n```\\nfunction Fenwick(n) {\\n    let a = Array(n).fill(0);\\n    return { query, update, rangeSum, tree }\\n    function query(i) {\\n        let sum = 0;\\n        for (i++; i > 0; i = parent(i)) sum += a[i];\\n        return sum;\\n    }\\n    function update(i, v) {\\n        for (i++; i < n; i = next(i)) a[i] += v;\\n    }\\n    function rangeSum(l, r) {\\n        return query(r) - query(l - 1);\\n    }\\n    function parent(x) {\\n        return x - lowestOneBit(x);\\n    }\\n    function next(x) {\\n        return x + lowestOneBit(x);\\n    }\\n    function lowestOneBit(x) {\\n        return x & -x;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nconst countOperationsToEmptyArray = (a) => {\\n    let n = a.length, fen = new Fenwick(n + 3), res = n, pre = 0;\\n    a = a.map((x, i) => [x, i + 1]).sort((x, y) => x[0] - y[0] || x[1] - y[1]);\\n    a.map(e => {\\n        let [, idx] = e;\\n        res += idx - 1 - fen.rangeSum(0, idx - 1);\\n        if (pre < idx) {\\n            res -= pre - fen.rangeSum(0, pre);\\n        } else {\\n            res += (n - pre) - (fen.rangeSum(0, n) - fen.rangeSum(0, pre));\\n        }\\n        pre = idx;\\n        fen.update(idx, 1);\\n    })\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Indexed Tree",
                    "Segment Tree"
                ],
                "code": "```\\nfunction SegmentTreeRSQ(n) {\\n    let h = Math.ceil(Math.log2(n)), len = 2 * 2 ** h, a = Array(len).fill(0);\\n    return { update, query, rangeSum, tree }\\n    function update(pos, v) {\\n        a[n + pos] = v;\\n        for (let i = parent(n + pos); i >= 1; i = parent(i)) pushup(i);\\n    }\\n    function pushup(i) {\\n        a[i] = a[left(i)] + a[right(i)];\\n    }\\n    function query(l, r) { // [L, R)\\n        let sum = 0;\\n        if (l >= r) return 0;\\n        l += n;\\n        r += n;\\n        for (; l < r; l = parent(l), r = parent(r)) {\\n            if (l & 1) sum += a[l++];\\n            if (r & 1) sum += a[--r];\\n        }\\n        return sum;\\n    }\\n    function rangeSum(l, r) {\\n        return query(0, r + 1) - query(0, l);\\n    }\\n    function parent(i) {\\n        return i >> 1;\\n    }\\n    function left(i) {\\n        return 2 * i;\\n    }\\n    function right(i) {\\n        return 2 * i + 1;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nconst countOperationsToEmptyArray = (a) => {\\n    let n = a.length, st = new SegmentTreeRSQ(n + 3), res = n, pre = 0, f = Array(n + 1).fill(0);\\n    a = a.map((x, i) => [x, i + 1]).sort((x, y) => x[0] - y[0] || x[1] - y[1]);\\n    a.map(e => {\\n        let [, idx] = e;\\n        res += idx - 1 - st.rangeSum(0, idx - 1);\\n        if (pre < idx) {\\n            res -= pre - st.rangeSum(0, pre);\\n        } else {\\n            res += (n - pre) - (st.rangeSum(0, n) - st.rangeSum(0, pre));\\n        }\\n        pre = idx;\\n        st.update(idx, ++f[idx]);\\n    })\\n    return res;\\n};\\n```\n```\\nfunction Fenwick(n) {\\n    let a = Array(n).fill(0);\\n    return { query, update, rangeSum, tree }\\n    function query(i) {\\n        let sum = 0;\\n        for (i++; i > 0; i = parent(i)) sum += a[i];\\n        return sum;\\n    }\\n    function update(i, v) {\\n        for (i++; i < n; i = next(i)) a[i] += v;\\n    }\\n    function rangeSum(l, r) {\\n        return query(r) - query(l - 1);\\n    }\\n    function parent(x) {\\n        return x - lowestOneBit(x);\\n    }\\n    function next(x) {\\n        return x + lowestOneBit(x);\\n    }\\n    function lowestOneBit(x) {\\n        return x & -x;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nconst countOperationsToEmptyArray = (a) => {\\n    let n = a.length, fen = new Fenwick(n + 3), res = n, pre = 0;\\n    a = a.map((x, i) => [x, i + 1]).sort((x, y) => x[0] - y[0] || x[1] - y[1]);\\n    a.map(e => {\\n        let [, idx] = e;\\n        res += idx - 1 - fen.rangeSum(0, idx - 1);\\n        if (pre < idx) {\\n            res -= pre - fen.rangeSum(0, pre);\\n        } else {\\n            res += (n - pre) - (fen.rangeSum(0, n) - fen.rangeSum(0, pre));\\n        }\\n        pre = idx;\\n        fen.update(idx, 1);\\n    })\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3505447,
                "title": "image-explanation-intuition-c-short-and-crisp-code",
                "content": "# Image Explanation\\n\\n![Screenshot 2023-05-09 at 21.07.31.png](https://assets.leetcode.com/users/images/23c9ea64-8920-4031-83f5-840b7097c570_1683647657.873008.png)\\n\\n\\n![Screenshot 2023-05-09 at 21.07.49.png](https://assets.leetcode.com/users/images/cf9dffee-6b38-4811-a868-9602e5ec78cb_1683647669.3865345.png)\\n\\n![Screenshot 2023-05-09 at 21.08.03.png](https://assets.leetcode.com/users/images/19c636fe-4822-4209-8570-a6ed91e93cf4_1683647712.5779226.png)\\n\\n![Screenshot 2023-05-09 at 21.10.41.png](https://assets.leetcode.com/users/images/8142fe0d-2646-406f-961e-4896b47dd6d2_1683647730.8425517.png)\\n\\n![Screenshot 2023-05-09 at 21.25.14.png](https://assets.leetcode.com/users/images/d569af1c-c477-431c-a95e-f0d5233f66ed_1683647779.9984515.png)\\n\\n![Screenshot 2023-05-09 at 21.44.20.png](https://assets.leetcode.com/users/images/72580a1f-10be-4be5-95ed-079ec19c47cd_1683648710.4338896.png)\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> ind(n, 0);\\n        iota(ind.begin(), ind.end(), 0);\\n        sort(ind.begin(), ind.end(), [&](int a, int b) {return nums[a] < nums[b];});\\n\\n        long long res = 0;\\n        for(int i = 1; i < n; i++){\\n            if(ind[i] < ind[i - 1]){\\n                long long shift1 = ind[i - 1] - (i - 1);\\n                long long shift2 = (n - i) - shift1;\\n\\n                res += shift1 + shift2;\\n            }\\n        }\\n        return res + n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> ind(n, 0);\\n        iota(ind.begin(), ind.end(), 0);\\n        sort(ind.begin(), ind.end(), [&](int a, int b) {return nums[a] < nums[b];});\\n\\n        long long res = 0;\\n        for(int i = 1; i < n; i++){\\n            if(ind[i] < ind[i - 1]){\\n                long long shift1 = ind[i - 1] - (i - 1);\\n                long long shift2 = (n - i) - shift1;\\n\\n                res += shift1 + shift2;\\n            }\\n        }\\n        return res + n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497072,
                "title": "python-sort-greedy-o-n-log-n-explained",
                "content": "1. Consider the example, `[2,0,1,4,3]`. Let\\'s start by counting directly:\\n\\t1-1. In first round, we go through 2, 0, 1, 4, 3.\\n\\t1-2. In second round, 2, 4, 3.\\n\\t1-3. In third round, 4.\\n\\t1-4. The answer of this example is `5+3+1 = 9`.\\n2. In first round, `2` appeares before `1`, so we can\\'t remove `2` in first round. \\nIn second round, we go through the remaining 3 numbers, and since `4` appeares before `3`, we can\\'t remove `4` in second round.\\nIn third round, go through the only remaining number.\\n3. The action \"count\" described above is equivalent to the operations we can perform. \\nWhen we count a number `n`, that means we rotate the remaining array to the one with `n` being the first element.\\n4. We sort `nums` and keep the original indices. Let `l` be the length of `nums`.\\nIf the index of `n_i` is smaller than the index of `n_i-1`, we\\'ll need another round with `l-i` numbers remaining, so we add `l-i` to `ans`.\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        l = len(nums)\\n        arr = sorted([(n, idx) for idx, n in enumerate(nums)])\\n        ans = l\\n        for i in range(1, l):\\n            if arr[i][1] < arr[i-1][1]:\\n                ans += l - i\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. Consider the example, `[2,0,1,4,3]`. Let\\'s start by counting directly:\\n\\t1-1. In first round, we go through 2, 0, 1, 4, 3.\\n\\t1-2. In second round, 2, 4, 3.\\n\\t1-3. In third round, 4.\\n\\t1-4. The answer of this example is `5+3+1 = 9`.\\n2. In first round, `2` appeares before `1`, so we can\\'t remove `2` in first round. \\nIn second round, we go through the remaining 3 numbers, and since `4` appeares before `3`, we can\\'t remove `4` in second round.\\nIn third round, go through the only remaining number.\\n3. The action \"count\" described above is equivalent to the operations we can perform. \\nWhen we count a number `n`, that means we rotate the remaining array to the one with `n` being the first element.\\n4. We sort `nums` and keep the original indices. Let `l` be the length of `nums`.\\nIf the index of `n_i` is smaller than the index of `n_i-1`, we\\'ll need another round with `l-i` numbers remaining, so we add `l-i` to `ans`.\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        l = len(nums)\\n        arr = sorted([(n, idx) for idx, n in enumerate(nums)])\\n        ans = l\\n        for i in range(1, l):\\n            if arr[i][1] < arr[i-1][1]:\\n                ans += l - i\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3490725,
                "title": "c-solution-using-the-c-programming-language-not-c",
                "content": "\\n\\n# Code\\n```\\ntypedef struct {\\n    int value;\\n    int index;\\n} Pair;\\n\\nint compare(const void *a, const void *b) {\\n    return ((Pair*)a)->value - ((Pair*)b)->value;\\n}\\n\\nlong long countOperationsToEmptyArray(int* nums, int numsSize){\\n    Pair pairs[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n        pairs[i].value = nums[i];\\n        pairs[i].index = i;\\n    }\\n    qsort(pairs, numsSize, sizeof(Pair), compare);\\n    long long ans = numsSize;\\n    for (int i = 1; i < numsSize; i++) {\\n        if (pairs[i].index < pairs[i - 1].index) ans += numsSize - i;\\n    }\\n    return ans;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct {\\n    int value;\\n    int index;\\n} Pair;\\n\\nint compare(const void *a, const void *b) {\\n    return ((Pair*)a)->value - ((Pair*)b)->value;\\n}\\n\\nlong long countOperationsToEmptyArray(int* nums, int numsSize){\\n    Pair pairs[numsSize];\\n    for (int i = 0; i < numsSize; i++) {\\n        pairs[i].value = nums[i];\\n        pairs[i].index = i;\\n    }\\n    qsort(pairs, numsSize, sizeof(Pair), compare);\\n    long long ans = numsSize;\\n    for (int i = 1; i < numsSize; i++) {\\n        if (pairs[i].index < pairs[i - 1].index) ans += numsSize - i;\\n    }\\n    return ans;\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3485515,
                "title": "why-n-i",
                "content": "# Why are everyone so smart\\nGoing through many solutions and comments similar to the one below - I still didn\\'t get why the hack it works. I tried a few examples myself and want to share my thoughts.\\nIf anyone happens to have link to the proof of why it works - please share, I\\'d love to check it out.\\n\\n## My understanding\\n* I interpret the initialization `res = sz` as in we must pop all elements in the array at some point so the result is init with n/sz.\\n    * so we just need to count the # of rotations needed after this.\\n\\n## why `res += sz-i` ?\\n* the part that I am most confused is why does the sorted index `i` have to do with result?\\n* TL;DR \\n    - I interpret `sz - i` as the # of rotations to rotate all elements represented in [i, n) in the sorted array to the right of smaller elements.\\n\\nHere is an example. To not confuse my tiny brain with too much numbers, I use letters to represent the input.\\n\\n### Example\\ndef ghi abc\\n012 345 678 - original indices\\n\\nJust by inspecting, we know we need to shift `defghi` to the right then everything becomes sorted and can be popped one after anohter, so it take 6(shifting) + 9(popping) = 15 operations.\\n\\nAfter sorting:\\nabc def ghi\\n678 012 345\\n012 345 678 - the `i` in the sorted index array.\\n\\nwe can see `ids[3]=0 < ids[2]=8` is the only case that hits the `ids[i] < ids[i - 1]` check, and it is the only one that contributes to res by `sz-i` which is (9 - 3 = 6), so total is 6 (rotating) + 9(popping) = 15.\\n\\nIn other words, once we see a `ids[i] < ids[i - 1]`, it means we need shift [i,n) in the original array by some operations so that everything smaller than what i represent are to the left. \\nSince the array is sorted, everything with index >=i are larger elements, and we need to shift them to the right of the smaller elements.\\nHow many operations are needed to shift them? - the size of [i, n), which is `n-i`. \\n\\n# Code - Copied from [votrubac](https://leetcode.com/votrubac/)\\'s [solution](https://leetcode.com/problems/make-array-empty/solutions/3466620/count-rotations-vs-bit/)\\n```\\nclass Solution {\\npublic:\\nlong long countOperationsToEmptyArray(vector<int>& n) {\\n    long long res = 0, sz = n.size();\\n    vector<int> ids(n.size());\\n    iota(begin(ids), end(ids), 0);\\n    sort(begin(ids), end(ids), [&](int i, int j){ return n[i] < n[j]; });\\n    for (int i = 1; i < sz; ++i)\\n        if (ids[i] < ids[i - 1]) {\\n            res += sz - i;\\n        }\\n    return res + sz;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long countOperationsToEmptyArray(vector<int>& n) {\\n    long long res = 0, sz = n.size();\\n    vector<int> ids(n.size());\\n    iota(begin(ids), end(ids), 0);\\n    sort(begin(ids), end(ids), [&](int i, int j){ return n[i] < n[j]; });\\n    for (int i = 1; i < sz; ++i)\\n        if (ids[i] < ids[i - 1]) {\\n            res += sz - i;\\n        }\\n    return res + sz;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484322,
                "title": "scala-zip-zip-zip-sumlong",
                "content": "# Code\\n```\\nobject Solution {\\n  def countOperationsToEmptyArray(nums: Array[Int]): Long = {\\n    val pos = nums.zipWithIndex.sorted.map(_._2)\\n    val rotations = pos.zipWithIndex.tail.zip(pos).map { case ((p, i), pp) => if (p < pp) nums.length - i else 0 }\\n    rotations.foldLeft(nums.length.toLong)(_ + _)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def countOperationsToEmptyArray(nums: Array[Int]): Long = {\\n    val pos = nums.zipWithIndex.sorted.map(_._2)\\n    val rotations = pos.zipWithIndex.tail.zip(pos).map { case ((p, i), pp) => if (p < pp) nums.length - i else 0 }\\n    rotations.foldLeft(nums.length.toLong)(_ + _)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3476316,
                "title": "lazy-rotation",
                "content": "# Intuition\\n\\nCost of delete:\\nWe ignore the cost of rotation. When deleting a nums[i], we \"+1\" to the \"cost of delete\" to all numbers before nums[i], so that later when deleting any of nums[0]~nums[i-1] we will see +1 to the cost deleting it. This way, the cost of rotation is delayed and distributed to individual numbers at delete time, we only need to care about how many times each number is rotated.\\n\\nPending rotation:\\nIf we delete nums[i], we don\\'t immediately rotate it, but making nums[0]~nums[i] a pending rotation state. \"Pending rotation state\" will only last one round and will be resolved immediately in the next round.\\nWe can later prove that:\\n1. There is always only one \"pending rotation\" part, \\n2. The \"pending rotation\" part will always stay in the head, not middle.\\n3. No matter how we rotate the array, the array will always turn back to its original nums[0]~nums[n] order, with a \"pending rotation\" head.\\n\\nLet\\'s start:\\n1. Delete nums[i]. nums[0]~nums[i-1] becomes \"pending rotation\", don\\'t actually rotate it yet.\\n2. Delete nums[j], \\n**If j>i**:\\nThis is same as directly deleting nums[j] without deleting nums[i]. Just cancel the previous pending state of rotating nums[0]~nums[i-1]. The new array is unchanged, still nums[0]~nums[n-1] same as orignal array, new pending rotation numbers become nums[0]~nums[j-1].\\n    **Cost of delete:** unchanged\\n\\n    **If j<i**:\\n    1. Resolve previous pending state by rotating nums[0]~nums[i-1] to the end, array becomes nums[i+1]~nums[n-1]+nums[0]~nums[i-1]\\n    2. Rotate nums[i+1]~nums[n-1] to the end, array becomes: nums[0]~nums[n-1], we are back to original nums[0]~nums[n-1] again.\\n    3. Lazy rotate nums[0]~nums[j] by setting as pending rotation.\\n    4. Step #2 and #3 combined is same as rotating all numbers before nums[j], which is the required rotation when deleting nums[j].\\n\\n    **Cost of delete:** every single number in the whole array is rotated, +1 to \"cost of delete\" to all numbers. The lazy pending part actually requires +2 to the \"cost of delete\", but we don\\'t consider it because the lazy part will be considered in the next step. \\n\\nDelete numbers from small to big, when deleting, add \"cost of delete\" that belongs to the deleted number to the final result.\\n\\n# Code\\n```Python\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        res,cost_of_delete,prev_i = 0,1,-1\\n        for v,i in sorted([[v,i] for i,v in enumerate(nums)]):\\n            if i<prev_i: cost_of_delete += 1\\n            res += cost_of_delete\\n            prev_i = i\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        res,cost_of_delete,prev_i = 0,1,-1\\n        for v,i in sorted([[v,i] for i,v in enumerate(nums)]):\\n            if i<prev_i: cost_of_delete += 1\\n            res += cost_of_delete\\n            prev_i = i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475902,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < nums.length; i++){\\n            map.put(nums[i], i);\\n        }\\n        Arrays.sort(nums);\\n        long res = nums.length;\\n        for(int i = 1; i < nums.length; i++){\\n            if(map.get(nums[i]) < map.get(nums[i - 1]))\\n                res += nums.length - i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < nums.length; i++){\\n            map.put(nums[i], i);\\n        }\\n        Arrays.sort(nums);\\n        long res = nums.length;\\n        for(int i = 1; i < nums.length; i++){\\n            if(map.get(nums[i]) < map.get(nums[i - 1]))\\n                res += nums.length - i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475088,
                "title": "easy-to-understand-fenwick-tree-solution",
                "content": "# Intuition\\nIf there are some numbers before smallest num they should be rotated to the end before smallest can be removed + one operation to actually delete element.\\n\\n# Approach\\nWe remove numbers from smallest to largest using sorted arr. For each num in sorted arr: we also track prev & cur indexes in original input array.\\n\\n**With prev & cur there is can be two cases**:\\n**prev <= cur**: We do range(prev, cur) coz: we don\\'t want to count num of els before prev, we did it before when calculated num of ops for prev\\n\\n**prev > cur**: We do range(prev, n) coz: if cur before prev, then to rm prev we\\'d rotate cur to end of arr(num of els in end[after p]: n-p);\\nWe do range(0, cur) coz: those els wb rotated to end before cur cb removed\\n\\nAfter smallest element removed we update(-1) BIT counts of all larger indexes.\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n\\n# Code\\n```\\nclass Solution {\\n\\n        // Fenwick tree(BIT): idx & in brackets - count how many els < cur el\\n        //       0\\n        //   /   |   \\\\\\n        // 1(1) 2(2)  4(4)\\n        //      |\\n        //     3(1)\\n        //\\n        // 0 1 2 3 4\\n        //\\n        // 3,2,1,5,6\\n        // 0,1,2,3,4 We work with pos of input arr, sorted arr just tells us which pos to rm 1st(e.g. 1) rm pos 2, 2) pos 1, etc)\\n        // Idea:\\n        // BIT used to quickly find ranges between indexes, and updated counts of els in O(logN) time.\\n        // Initially it keeps counts for all els, for same lengths wb same counts eg: 54321 or 31245 -> 12345(count num of els smaller than i-th el(incl))\\n        //\\n        // Explaining conditions:\\n        // prev <= cur: We do range(prev, cur) coz: we don\\'t want to count num of els before prev, we did it before when calculated num of ops for prev\\n        //              123->23\\n        // E.g. case: 312 -> 0 1 2  -> 0 1 2(we already rotated 3 to rm 1, don\\'t need to count it again to rm 2)\\n        //              1 2 3     1 1 2\\n        //\\n        // prev > cur: We do range(prev, n) coz: if cur before prev, then to rm prev we\\'d rotate cur to end of arr(num of els in end[after p]: n-p);\\n        //             We do range(0, cur) coz: those els wb rotated to end before cur cb removed\\n        // Input 32156 -> 15632->5632        ->2563->563  -> 356->56      56->6        6 -> []\\n        //                    c     rm: i=2       c p        c p          p     c            p c\\n        // E.g. case: 32156 -> 0 1 2 3 4(indexes) -> 0 1 2 3 4 -> 0 1 2 3 4 -> 0 1 2 3 4 -> 0 1 2 3 4 -> Done!\\n        //        counts: 1 2 3 4 5 val=1       1 2 2 3 4    1 1 1 2 3    0 0 0 1 2    0 0 0 0 1\\n        //        2 els before i=2,val=1,   r(2,4) 2 els     r(1,4)=2     r(0,3)=0     r(3,4)=0\\n        //        ops += 2                 + r(0,1) 1 el    + r(0,0)=0\\n        //                                 ops += 3\\n        public long countOperationsToEmptyArray(int[] nums) {\\n            int n = nums.length;\\n            var originalPos = new HashMap<Integer, Integer>(); // num-origPos map\\n            var tree = new FenwickTree(n);\\n\\n            for (int i = 0; i < n; i++) originalPos.put(nums[i], i); // has orig idx\\n            Arrays.sort(nums);\\n            for (int i = 0; i < n; i++) tree.update(i, 1); // counts for input arr\\n\\n            int prev = 0; // we use 0 prev, so for 1st iter tree.countSmaller(-1)=0 which gives correct answer\\n            long operations = 0;\\n            for (int num : nums) {\\n                int cur = originalPos.get(num);\\n\\n                if (cur >= prev) operations += tree.range(prev, cur); // -1 to don\\'t count cur el\\n                else operations += tree.range(prev, n) + tree.range(0, cur);\\n\\n                tree.update(cur, -1); // remove element from BIT\\n                prev = cur;\\n                operations++; // remove element\\n            }\\n\\n            return operations;\\n        }\\n\\n        private static class FenwickTree {\\n            private final int[] tree;\\n\\n            FenwickTree(int n) {\\n                tree = new int[n + 1];\\n            }\\n\\n            void update(int i, int val) { // incr index i by x\\n                i++; // BIT has +1 offset\\n                while(i < tree.length) {\\n                    tree[i] += val;\\n                    i += lsb(i);\\n                }\\n            }\\n\\n            private int lsb(int i) {\\n                return i & -i;\\n            }\\n\\n            int countSmaller(int i) { // count num of smaller elements than i(inclusive)\\n                i++; // BIT has +1 offset\\n                int count = 0;\\n\\n                while(i > 0) {\\n                    count += tree[i];\\n                    i -= lsb(i);\\n                }\\n\\n                return count;\\n            }\\n\\n            int range(int fromIdx, int toIdx) { // count num of els in range (from, to)\\n                return countSmaller(toIdx - 1) - countSmaller(fromIdx - 1);\\n            }\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n        // Fenwick tree(BIT): idx & in brackets - count how many els < cur el\\n        //       0\\n        //   /   |   \\\\\\n        // 1(1) 2(2)  4(4)\\n        //      |\\n        //     3(1)\\n        //\\n        // 0 1 2 3 4\\n        //\\n        // 3,2,1,5,6\\n        // 0,1,2,3,4 We work with pos of input arr, sorted arr just tells us which pos to rm 1st(e.g. 1) rm pos 2, 2) pos 1, etc)\\n        // Idea:\\n        // BIT used to quickly find ranges between indexes, and updated counts of els in O(logN) time.\\n        // Initially it keeps counts for all els, for same lengths wb same counts eg: 54321 or 31245 -> 12345(count num of els smaller than i-th el(incl))\\n        //\\n        // Explaining conditions:\\n        // prev <= cur: We do range(prev, cur) coz: we don\\'t want to count num of els before prev, we did it before when calculated num of ops for prev\\n        //              123->23\\n        // E.g. case: 312 -> 0 1 2  -> 0 1 2(we already rotated 3 to rm 1, don\\'t need to count it again to rm 2)\\n        //              1 2 3     1 1 2\\n        //\\n        // prev > cur: We do range(prev, n) coz: if cur before prev, then to rm prev we\\'d rotate cur to end of arr(num of els in end[after p]: n-p);\\n        //             We do range(0, cur) coz: those els wb rotated to end before cur cb removed\\n        // Input 32156 -> 15632->5632        ->2563->563  -> 356->56      56->6        6 -> []\\n        //                    c     rm: i=2       c p        c p          p     c            p c\\n        // E.g. case: 32156 -> 0 1 2 3 4(indexes) -> 0 1 2 3 4 -> 0 1 2 3 4 -> 0 1 2 3 4 -> 0 1 2 3 4 -> Done!\\n        //        counts: 1 2 3 4 5 val=1       1 2 2 3 4    1 1 1 2 3    0 0 0 1 2    0 0 0 0 1\\n        //        2 els before i=2,val=1,   r(2,4) 2 els     r(1,4)=2     r(0,3)=0     r(3,4)=0\\n        //        ops += 2                 + r(0,1) 1 el    + r(0,0)=0\\n        //                                 ops += 3\\n        public long countOperationsToEmptyArray(int[] nums) {\\n            int n = nums.length;\\n            var originalPos = new HashMap<Integer, Integer>(); // num-origPos map\\n            var tree = new FenwickTree(n);\\n\\n            for (int i = 0; i < n; i++) originalPos.put(nums[i], i); // has orig idx\\n            Arrays.sort(nums);\\n            for (int i = 0; i < n; i++) tree.update(i, 1); // counts for input arr\\n\\n            int prev = 0; // we use 0 prev, so for 1st iter tree.countSmaller(-1)=0 which gives correct answer\\n            long operations = 0;\\n            for (int num : nums) {\\n                int cur = originalPos.get(num);\\n\\n                if (cur >= prev) operations += tree.range(prev, cur); // -1 to don\\'t count cur el\\n                else operations += tree.range(prev, n) + tree.range(0, cur);\\n\\n                tree.update(cur, -1); // remove element from BIT\\n                prev = cur;\\n                operations++; // remove element\\n            }\\n\\n            return operations;\\n        }\\n\\n        private static class FenwickTree {\\n            private final int[] tree;\\n\\n            FenwickTree(int n) {\\n                tree = new int[n + 1];\\n            }\\n\\n            void update(int i, int val) { // incr index i by x\\n                i++; // BIT has +1 offset\\n                while(i < tree.length) {\\n                    tree[i] += val;\\n                    i += lsb(i);\\n                }\\n            }\\n\\n            private int lsb(int i) {\\n                return i & -i;\\n            }\\n\\n            int countSmaller(int i) { // count num of smaller elements than i(inclusive)\\n                i++; // BIT has +1 offset\\n                int count = 0;\\n\\n                while(i > 0) {\\n                    count += tree[i];\\n                    i -= lsb(i);\\n                }\\n\\n                return count;\\n            }\\n\\n            int range(int fromIdx, int toIdx) { // count num of els in range (from, to)\\n                return countSmaller(toIdx - 1) - countSmaller(fromIdx - 1);\\n            }\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474270,
                "title": "o-n-log-n-short-solution-with-sorting-beating-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe brute-force solution with simulation can be as slow as $$O(N^2)$$ for the worst case. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInstead of simulation, my solution analyzes the sequence from left to right and finds all the 1-step increasing subsequences. For the input [3, 4, 1, 2, 7, 6], all the 1-step increasing subsequences are [3, 4, 6], [1, 2], and [7]. The smallest subsequence [1, 2] will be done in the first turn, so the cost is only 2. Next, the second smallest subseuquence [3, 4, 6] will be done in the second turn, so the cost is 3 + 3. Finally, the cost of the largest subsequence [7] is 2+1. The resultant total cost is 2+6+3 = 11.\\n\\nTo perform this solution, the input should be mapped to continouos numbers from 1 to n. So the first two lines are used to create the numbers. \\n\\n# Complexity\\n- Time complexity: $$O(N log N)$$ for sorting\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        num_order = {v: k for k, v in enumerate(sorted(nums))}\\n        nums = [num_order[k] for k in nums]\\n\\n        groups = {}\\n        sizes = {}\\n        for v in nums:\\n            if v - 1 in groups:\\n                groups[v] = groups[v-1]\\n                sizes[groups[v]] += 1\\n            else:\\n                groups[v] = v\\n                sizes[v] = 1\\n        turn = 1\\n        ans = 0\\n        for k, v in sorted([(k, v) for k, v in sizes.items()]):\\n            ans += turn * v \\n            turn += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        num_order = {v: k for k, v in enumerate(sorted(nums))}\\n        nums = [num_order[k] for k in nums]\\n\\n        groups = {}\\n        sizes = {}\\n        for v in nums:\\n            if v - 1 in groups:\\n                groups[v] = groups[v-1]\\n                sizes[groups[v]] += 1\\n            else:\\n                groups[v] = v\\n                sizes[v] = 1\\n        turn = 1\\n        ans = 0\\n        for k, v in sorted([(k, v) for k, v in sizes.items()]):\\n            ans += turn * v \\n            turn += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474136,
                "title": "make-array-empty-using-dsu-disjoint-set-union",
                "content": "# Intuition\\nThe intution might seem lengthy but give it a read you might find it useful.\\n\\nSolved this using the Disjoint Set Union(DSU) even though simpler method can also be used.\\nA number can either be removed or pushed back to the end, both take only 1 operation.\\nLet n be the current size of the array.\\nIf we apply the operation n times, an element will either be removed or pushed back.\\n\\nEx: nums -> 4,5,0,2,1  n -> 5\\nAfter applying 5 operations: nums -> 4,5,2\\nThis shows that after applying 5 operations the smallest element will be removed and the element that comes just after it in the sorted order.\\nNow the size of array is reduced, n -> 3\\nAfter applying 3 more operations: nums -> 4,5\\nNow the size of array is reduced again, n -> 2\\nAfter applying two more operations: nums -> {empty array}\\nSo the total no. of operations required are 5+3+2 = 10\\n\\nModifying the array and traversing it again and again will cause TLE.\\nSo we can groups the elements while traversing the array in one go.\\nFirst if we come across an element, we check if the element that comes just before the current element in the sorted array has appeared or not. If the previous element has appeared we group them togther otherwise if the previous element has not appeared we create a new group for the current group.\\nFor the above example the grouping will be something like this : [0,1] [2] [4,5].\\nNow we add the current size of the array to our answer and remove the group which contains the smallest element and reduce the size of the array be the size of that group. We do this until all the groups are removed and after this we get our final answer.\\n\\nThe grouping might seem very redundant and time consuming but it can be easily done using Disjoint Set Union properties.\\nSince all the element are distinct we can map the element in sorted order like 0,1,2..and so on to make it easier to implement the DSU.\\nWe only need to determine the group in which the element belong and DSU takes care of the grouping and the size of the group.\\n\\n**I haven\\'t explained it in the best possible way but upvote it if you understood my implementation or comment if you have any doubt.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:All DSU operations and sorting parallely take O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass DisjointSet\\n{\\npublic:\\n    vector<int> parent;\\n    vector<int> size;\\n//size n+1 is taken in case of 1 based indexing is used.\\n    DisjointSet(int n){\\n        size.resize(n+1,1);\\n        parent.resize(n+1);\\n        for(int i=0; i<=n; i++){\\n            parent[i]=i;\\n        }\\n    }\\n    \\n//This finds the ultimate parent of a node and also does path compression.\\n    int ulParent(int node){\\n        if(parent[node]==node){\\n            return node;\\n        }\\n        return parent[node]=ulParent(parent[node]);\\n    }\\n    \\n//This performs union by size of node u and v.\\n    void unionBySize(int u, int v){\\n        int ulp_u = ulParent(u);\\n        int ulp_v = ulParent(v);\\n        if(ulp_u == ulp_v){\\n            return;\\n        }\\n        if(size[ulp_u] < size[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        unordered_map<int,int> m, m2;\\n        DisjointSet ds(n);\\n        vector<int> v;\\n        \\n        for(auto it : nums)v.push_back(it);\\n\\n        sort(v.begin(),v.end());\\n\\n        for(int i=0;i<n;i++){\\n            m[v[i]] = i;\\n        }\\n\\n        for(auto it : nums){\\n            int x = m[it];\\n            if(m2.find(x-1) != m2.end()){\\n                ds.unionBySize(x-1, x);\\n            }\\n            m2[x] = 1;\\n        }\\n\\n        long long num = n;\\n        for(int i=0;i<n;i++){\\n            if(ds.parent[i] == i){\\n                ans += num;\\n                num -= ds.size[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet\\n{\\npublic:\\n    vector<int> parent;\\n    vector<int> size;\\n//size n+1 is taken in case of 1 based indexing is used.\\n    DisjointSet(int n){\\n        size.resize(n+1,1);\\n        parent.resize(n+1);\\n        for(int i=0; i<=n; i++){\\n            parent[i]=i;\\n        }\\n    }\\n    \\n//This finds the ultimate parent of a node and also does path compression.\\n    int ulParent(int node){\\n        if(parent[node]==node){\\n            return node;\\n        }\\n        return parent[node]=ulParent(parent[node]);\\n    }\\n    \\n//This performs union by size of node u and v.\\n    void unionBySize(int u, int v){\\n        int ulp_u = ulParent(u);\\n        int ulp_v = ulParent(v);\\n        if(ulp_u == ulp_v){\\n            return;\\n        }\\n        if(size[ulp_u] < size[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        unordered_map<int,int> m, m2;\\n        DisjointSet ds(n);\\n        vector<int> v;\\n        \\n        for(auto it : nums)v.push_back(it);\\n\\n        sort(v.begin(),v.end());\\n\\n        for(int i=0;i<n;i++){\\n            m[v[i]] = i;\\n        }\\n\\n        for(auto it : nums){\\n            int x = m[it];\\n            if(m2.find(x-1) != m2.end()){\\n                ds.unionBySize(x-1, x);\\n            }\\n            m2[x] = 1;\\n        }\\n\\n        long long num = n;\\n        for(int i=0;i<n;i++){\\n            if(ds.parent[i] == i){\\n                ans += num;\\n                num -= ds.size[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472552,
                "title": "solution-using-map-and-sorting-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        unordered_map<int, int> ans;\\n        long long n = A.size(), res = n;\\n        for(int i = 0; i < n; ++i)\\n            ans[A[i]] = i;\\n        sort(A.begin(), A.end());\\n        for(int i = 1; i < n; ++i)\\n        {\\n            if (ans[A[i]] < ans[A[i - 1]])\\n                res += n - i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& A) {\\n        unordered_map<int, int> ans;\\n        long long n = A.size(), res = n;\\n        for(int i = 0; i < n; ++i)\\n            ans[A[i]] = i;\\n        sort(A.begin(), A.end());\\n        for(int i = 1; i < n; ++i)\\n        {\\n            if (ans[A[i]] < ans[A[i - 1]])\\n                res += n - i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472450,
                "title": "c-segment-tree",
                "content": "# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    const static int maxn=1e5+10;\\n    ll seg[maxn<<2];\\n    void init_seg(int cur,int l,int r)\\n    {\\n        if(l+1==r)\\n        {\\n            seg[cur]=1;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        init_seg(cur<<1,l,mid);\\n        init_seg(cur<<1|1,mid,r);\\n        seg[cur]=seg[cur<<1]+seg[cur<<1|1];\\n    }\\n    int query(int cur,int l,int r,int ql,int qr)\\n    {\\n        if(ql<=l&&r<=qr)return seg[cur];\\n        if(ql>=r||qr<=l)return 0;\\n        int mid=(l+r)>>1;\\n        return query(cur<<1,l,mid,ql,qr)+query(cur<<1|1,mid,r,ql,qr);\\n    }\\n    void update(int cur,int l,int r,int target)\\n    {\\n        if(l+1==r)\\n        {\\n            seg[cur]=0;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        if(target<mid)update(cur<<1,l,mid,target);\\n        else update(cur<<1|1,mid,r,target);\\n        seg[cur]=seg[cur<<1]+seg[cur<<1|1];\\n    }\\n    long long countOperationsToEmptyArray(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        init_seg(1,0,n);\\n        vector<pair<int,int>>seq(n);\\n        for(int i=0;i<n;i++)seq[i]={nums[i],i};\\n        sort(seq.begin(),seq.end());\\n        ll res=0;\\n        int cur_idx=0;\\n        for(auto &x:seq)\\n        {\\n            int nxt_idx=x.second;\\n            if(cur_idx<nxt_idx)\\n            {\\n                int t1=query(1,0,n,cur_idx,nxt_idx);\\n                res+=query(1,0,n,cur_idx,nxt_idx);\\n            }else if(cur_idx>nxt_idx)\\n            {\\n                int t1=query(1,0,n,cur_idx,n);\\n                int t2=query(1,0,n,0,nxt_idx);\\n                res+=query(1,0,n,cur_idx,n)+query(1,0,n,0,nxt_idx);\\n            }\\n            update(1,0,n,nxt_idx);\\n            cur_idx=(nxt_idx+1)%n;\\n            res+=1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    const static int maxn=1e5+10;\\n    ll seg[maxn<<2];\\n    void init_seg(int cur,int l,int r)\\n    {\\n        if(l+1==r)\\n        {\\n            seg[cur]=1;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        init_seg(cur<<1,l,mid);\\n        init_seg(cur<<1|1,mid,r);\\n        seg[cur]=seg[cur<<1]+seg[cur<<1|1];\\n    }\\n    int query(int cur,int l,int r,int ql,int qr)\\n    {\\n        if(ql<=l&&r<=qr)return seg[cur];\\n        if(ql>=r||qr<=l)return 0;\\n        int mid=(l+r)>>1;\\n        return query(cur<<1,l,mid,ql,qr)+query(cur<<1|1,mid,r,ql,qr);\\n    }\\n    void update(int cur,int l,int r,int target)\\n    {\\n        if(l+1==r)\\n        {\\n            seg[cur]=0;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        if(target<mid)update(cur<<1,l,mid,target);\\n        else update(cur<<1|1,mid,r,target);\\n        seg[cur]=seg[cur<<1]+seg[cur<<1|1];\\n    }\\n    long long countOperationsToEmptyArray(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        init_seg(1,0,n);\\n        vector<pair<int,int>>seq(n);\\n        for(int i=0;i<n;i++)seq[i]={nums[i],i};\\n        sort(seq.begin(),seq.end());\\n        ll res=0;\\n        int cur_idx=0;\\n        for(auto &x:seq)\\n        {\\n            int nxt_idx=x.second;\\n            if(cur_idx<nxt_idx)\\n            {\\n                int t1=query(1,0,n,cur_idx,nxt_idx);\\n                res+=query(1,0,n,cur_idx,nxt_idx);\\n            }else if(cur_idx>nxt_idx)\\n            {\\n                int t1=query(1,0,n,cur_idx,n);\\n                int t2=query(1,0,n,0,nxt_idx);\\n                res+=query(1,0,n,cur_idx,n)+query(1,0,n,0,nxt_idx);\\n            }\\n            update(1,0,n,nxt_idx);\\n            cur_idx=(nxt_idx+1)%n;\\n            res+=1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472323,
                "title": "simple-easy-to-understand-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere **n** elements at first,\\nso there will take at least **n** operations.\\nAnd it take **n** operations rotate all elements once.\\n\\n\\n# Complexity\\n- Time complexity: O(n(log(n)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans=n;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]=i;\\n        }\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=1;i<n;i++){\\n            if(mp[nums[i]]<mp[nums[i-1]]){\\n                ans+= n-i;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans=n;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]=i;\\n        }\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=1;i<n;i++){\\n            if(mp[nums[i]]<mp[nums[i-1]]){\\n                ans+= n-i;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471087,
                "title": "java-solution-using-segment-tree",
                "content": "\\n# Time complexity:\\n   **O(nlogn)**\\n\\n# Space Complexity\\n   **O(n)**\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    int[] segTree;\\n    \\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n = nums.length;\\n        segTree = new int[4*n];\\n        int[] greater = new int[n];\\n        \\n        int[] ind = getRelativeValuesAndIndex(nums);\\n                \\n        for(int i=0; i<n; i++){\\n            // Number of elements to the left of nums[i]\\n           // that is greater than nums[i]\\n            greater[i] = sum(nums[i],n,0,0,n);\\n            update(nums[i],0,0,n);\\n        }\\n        \\n        long count = greater[ind[0]];\\n        \\n        for(int i=1; i< n; i++){\\n            if(ind[i] > ind[i-1]){\\n                count+= greater[ind[i]] - greater[ind[i-1]];\\n            }else{\\n                count+= greater[ind[i]];\\n                int totGreaterEle = n-i;\\n                totGreaterEle-=greater[ind[i-1]];\\n                count+= totGreaterEle;\\n            }\\n        }\\n        \\n        return count+n;\\n    }\\n    \\n    private int[] getRelativeValuesAndIndex(int[] nums){\\n        List<Integer> temp = new ArrayList();\\n        for(int i=0; i< nums.length; i++){\\n            temp.add(i);\\n        }\\n        \\n        Collections.sort(temp, (i,j) -> nums[i] - nums[j]);\\n        \\n        for(int i=0; i< nums.length; i++){\\n            nums[temp.get(i)] = i;\\n        }\\n        \\n        \\n        return temp.stream().mapToInt(i -> i).toArray();\\n    }\\n    \\n    \\n    \\n    private void update(int value, int pos, int low, int high){\\n        if(high < value || low > value)\\n            return;\\n        \\n        segTree[pos]++;\\n        if(low == high){\\n            return;\\n        }\\n        \\n        int mid = (low+high)/2;\\n        \\n        update(value, 2*pos+1, low,mid);\\n        update(value, 2*pos+2, mid+1, high);\\n        \\n    }\\n    \\n    private int sum(int l, int h, int pos, int low, int high){\\n        if(low > h || high < l)\\n            return 0;\\n        \\n        if(l <=low && high <= h)\\n            return segTree[pos];\\n        \\n        \\n        int mid = (low+high)/2;\\n        return sum(l,h, 2*pos+1, low,mid) + sum(l,h, 2*pos+2, mid+1, high);        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[] segTree;\\n    \\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n = nums.length;\\n        segTree = new int[4*n];\\n        int[] greater = new int[n];\\n        \\n        int[] ind = getRelativeValuesAndIndex(nums);\\n                \\n        for(int i=0; i<n; i++){\\n            // Number of elements to the left of nums[i]\\n           // that is greater than nums[i]\\n            greater[i] = sum(nums[i],n,0,0,n);\\n            update(nums[i],0,0,n);\\n        }\\n        \\n        long count = greater[ind[0]];\\n        \\n        for(int i=1; i< n; i++){\\n            if(ind[i] > ind[i-1]){\\n                count+= greater[ind[i]] - greater[ind[i-1]];\\n            }else{\\n                count+= greater[ind[i]];\\n                int totGreaterEle = n-i;\\n                totGreaterEle-=greater[ind[i-1]];\\n                count+= totGreaterEle;\\n            }\\n        }\\n        \\n        return count+n;\\n    }\\n    \\n    private int[] getRelativeValuesAndIndex(int[] nums){\\n        List<Integer> temp = new ArrayList();\\n        for(int i=0; i< nums.length; i++){\\n            temp.add(i);\\n        }\\n        \\n        Collections.sort(temp, (i,j) -> nums[i] - nums[j]);\\n        \\n        for(int i=0; i< nums.length; i++){\\n            nums[temp.get(i)] = i;\\n        }\\n        \\n        \\n        return temp.stream().mapToInt(i -> i).toArray();\\n    }\\n    \\n    \\n    \\n    private void update(int value, int pos, int low, int high){\\n        if(high < value || low > value)\\n            return;\\n        \\n        segTree[pos]++;\\n        if(low == high){\\n            return;\\n        }\\n        \\n        int mid = (low+high)/2;\\n        \\n        update(value, 2*pos+1, low,mid);\\n        update(value, 2*pos+2, mid+1, high);\\n        \\n    }\\n    \\n    private int sum(int l, int h, int pos, int low, int high){\\n        if(low > h || high < l)\\n            return 0;\\n        \\n        if(l <=low && high <= h)\\n            return segTree[pos];\\n        \\n        \\n        int mid = (low+high)/2;\\n        return sum(l,h, 2*pos+1, low,mid) + sum(l,h, 2*pos+2, mid+1, high);        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470964,
                "title": "c-queue",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n\\n    public long CountOperationsToEmptyArray(int[] A) {\\n        Dictionary<int, int> d = new Dictionary<int, int>();\\n        int n = A.Length, p = 0;\\n        long res = n;\\n\\n        for (int i = 0; i < n; i++) \\n        {\\n            d[A[i]] = i;\\n        }\\n\\n        Array.Sort(A);\\n\\n        for (int i = 0; i < n; p = d[A[i++]]) \\n        {\\n            if (d[A[i]] < p) \\n            {\\n                res += n - i;\\n            }\\n        }\\n        return res;\\n    }\\n\\n}\\n```\\n\\n# Nice Looking queue approach. Times out for last 4 test cases\\n\\n```\\npublic class Solution {\\n    public long CountOperationsToEmptyArray(int[] nums) \\n    {\\n        Queue<int> q = new Queue<int>(nums);\\n        \\n        Array.Sort(nums);\\n        \\n        int count = 0;\\n        int minVal = nums[0];\\n        int currIndex = 0;\\n        \\n        \\n        \\n        while(currIndex < nums.Length)\\n        {\\n            int currentVal = q.Dequeue();\\n\\n            if(currentVal == minVal)\\n            {      \\n                currIndex++;\\n                if(currIndex < nums.Length)\\n                {\\n                    minVal = nums[currIndex]; \\n                }\\n                              \\n            }\\n            else\\n            {\\n                q.Enqueue(currentVal);\\n            }\\n            \\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public long CountOperationsToEmptyArray(int[] A) {\\n        Dictionary<int, int> d = new Dictionary<int, int>();\\n        int n = A.Length, p = 0;\\n        long res = n;\\n\\n        for (int i = 0; i < n; i++) \\n        {\\n            d[A[i]] = i;\\n        }\\n\\n        Array.Sort(A);\\n\\n        for (int i = 0; i < n; p = d[A[i++]]) \\n        {\\n            if (d[A[i]] < p) \\n            {\\n                res += n - i;\\n            }\\n        }\\n        return res;\\n    }\\n\\n}\\n```\n```\\npublic class Solution {\\n    public long CountOperationsToEmptyArray(int[] nums) \\n    {\\n        Queue<int> q = new Queue<int>(nums);\\n        \\n        Array.Sort(nums);\\n        \\n        int count = 0;\\n        int minVal = nums[0];\\n        int currIndex = 0;\\n        \\n        \\n        \\n        while(currIndex < nums.Length)\\n        {\\n            int currentVal = q.Dequeue();\\n\\n            if(currentVal == minVal)\\n            {      \\n                currIndex++;\\n                if(currIndex < nums.Length)\\n                {\\n                    minVal = nums[currIndex]; \\n                }\\n                              \\n            }\\n            else\\n            {\\n                q.Enqueue(currentVal);\\n            }\\n            \\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470464,
                "title": "count-of-smaller-elements-on-either-side-python",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        arr=[(c,i) for i,c in enumerate(nums)]\\n        arr.sort()\\n        left,right=[0]*n,[0]*n\\n        l,r=SortedList(),SortedList()\\n        for i in range(n):\\n            idx=l.bisect_right(nums[i])\\n            left[i]=idx\\n            l.add(nums[i])\\n            j=n-i-1\\n            idx=r.bisect_right(nums[j])\\n            right[j]=idx\\n            r.add(nums[j])\\n        c,last=arr[0]\\n        ans=n+last\\n        for c,i in arr[1:]:\\n            if i>last:\\n                ans+=i-last-1-(right[last]-right[i])\\n            else:\\n                ans+=n-1-last+i-(right[last]+left[i])\\n            last=i\\n        return ans\\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        arr=[(c,i) for i,c in enumerate(nums)]\\n        arr.sort()\\n        left,right=[0]*n,[0]*n\\n        l,r=SortedList(),SortedList()\\n        for i in range(n):\\n            idx=l.bisect_right(nums[i])\\n            left[i]=idx\\n            l.add(nums[i])\\n            j=n-i-1\\n            idx=r.bisect_right(nums[j])\\n            right[j]=idx\\n            r.add(nums[j])\\n        c,last=arr[0]\\n        ans=n+last\\n        for c,i in arr[1:]:\\n            if i>last:\\n                ans+=i-last-1-(right[last]-right[i])\\n            else:\\n                ans+=n-1-last+i-(right[last]+left[i])\\n            last=i\\n        return ans\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470322,
                "title": "c-fenwic-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    ll find(vector<ll>& fen,int v,int n){\\n        ll x=0;\\n        // v--;\\n        while(v<=n){\\n            x+=fen[v];\\n            v+=v&(-v);\\n        }\\n        return x;\\n    }\\n    void insert(vector<ll> &fen,int v){\\n        while(v>0){\\n            fen[v]++;\\n            v-=(v&(-v));\\n        }\\n    }\\n    \\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n         vector<pair<int,int>> v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            v.push_back({nums[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        \\n       vector<int> a(n);\\n        vector<int> index(n+1);\\n        for(int i=0;i<n;i++){\\n            a[v[i].second]=i+1;\\n            index[i+1]=v[i].second;\\n        }\\n        \\n        vector<ll> fen1(n+10),fen2(n+10);\\n        vector<ll> left(n),right(n);\\n        \\n        for(int i=0;i<n;i++){\\n            left[i]=find(fen1,a[i],n);\\n            insert(fen1,a[i]);\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            right[i]=find(fen2,a[i],n);\\n            insert(fen2,a[i]);\\n        }\\n        \\n        ll ans=0;\\n        \\n        int idx=index[1];\\n        int i=1;\\n        ans+=left[idx];\\n        int pre=idx;\\n        i++;\\n        while(i<=n){\\n             idx=index[i];\\n            \\n         if(pre>idx){\\n             ll l=left[idx];\\n             ll r=right[pre];\\n             // cout<<l+r;\\n             ans+=l+r;\\n         }else{\\n             ll l=left[pre];\\n             ll r=right[idx];\\n             // cout<<l+r;\\n             ans+=n-i-(l+r);\\n         }\\n            pre=idx;\\n           \\n            i++;\\n        }\\n        // for(auto k:right)cout<<k<<\" \";\\n        return ans+n;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    ll find(vector<ll>& fen,int v,int n){\\n        ll x=0;\\n        // v--;\\n        while(v<=n){\\n            x+=fen[v];\\n            v+=v&(-v);\\n        }\\n        return x;\\n    }\\n    void insert(vector<ll> &fen,int v){\\n        while(v>0){\\n            fen[v]++;\\n            v-=(v&(-v));\\n        }\\n    }\\n    \\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n         vector<pair<int,int>> v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            v.push_back({nums[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        \\n       vector<int> a(n);\\n        vector<int> index(n+1);\\n        for(int i=0;i<n;i++){\\n            a[v[i].second]=i+1;\\n            index[i+1]=v[i].second;\\n        }\\n        \\n        vector<ll> fen1(n+10),fen2(n+10);\\n        vector<ll> left(n),right(n);\\n        \\n        for(int i=0;i<n;i++){\\n            left[i]=find(fen1,a[i],n);\\n            insert(fen1,a[i]);\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            right[i]=find(fen2,a[i],n);\\n            insert(fen2,a[i]);\\n        }\\n        \\n        ll ans=0;\\n        \\n        int idx=index[1];\\n        int i=1;\\n        ans+=left[idx];\\n        int pre=idx;\\n        i++;\\n        while(i<=n){\\n             idx=index[i];\\n            \\n         if(pre>idx){\\n             ll l=left[idx];\\n             ll r=right[pre];\\n             // cout<<l+r;\\n             ans+=l+r;\\n         }else{\\n             ll l=left[pre];\\n             ll r=right[idx];\\n             // cout<<l+r;\\n             ans+=n-i-(l+r);\\n         }\\n            pre=idx;\\n           \\n            i++;\\n        }\\n        // for(auto k:right)cout<<k<<\" \";\\n        return ans+n;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3469430,
                "title": "beginner-friendly-code-c",
                "content": "example:\\nPrerequiste :\\n1.Alteast n moves will be required for removing every element(for eg if the array is sorted)\\n2. To rotate every element once we will be having**n** moves.\\n\\t\\t\\t\\t\\t\\n####   array : 4 7 8 5 9 6\\n count = 6\\n###   step 1 : Make vector of Value and Index\\n   array : 4 7 8 5 9 6 \\n   Index: 0 1 2 3 4 5 \\n###    Step 2: Sort the vector pair on the value\\n\\narray : 4 5 6 7 8 9\\nindex: 0 3 5 1 2 4 \\n\\n### Step 3 : Check if i+1 is smaller than the i index\\n count=count + (n-i) \\n reason begin for (n-i) is : if the index of next element get smaller than current element then we have to rotate the whole array from that position to the end. \\n\\n\\t\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n    long count=0;\\n        int n=nums.size();\\n        vector<pair<int,int>>ans;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n            ans.push_back({nums[j],j});\\n        }\\n        sort(ans.begin(),ans.end());\\n        count=nums.size();\\n        for(int i=1;i<ans.size();i++)\\n        {\\n            if(ans[i-1].second>ans[i].second)\\n                count=count+(n-i);\\n        }\\n   return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n    long count=0;\\n        int n=nums.size();\\n        vector<pair<int,int>>ans;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n            ans.push_back({nums[j],j});\\n        }\\n        sort(ans.begin(),ans.end());\\n        count=nums.size();\\n        for(int i=1;i<ans.size();i++)\\n        {\\n            if(ans[i-1].second>ans[i].second)\\n                count=count+(n-i);\\n        }\\n   return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469412,
                "title": "python-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        for i in range(n):\\n            nums[i]=[nums[i],i]\\n        nums.sort(key=lambda x:x[0])\\n        count=0\\n        ans=n\\n        prev=0\\n        for i in range(1,n):\\n            if nums[i-1][1]>nums[i][1]:\\n                count+=1\\n            ans+=count\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        for i in range(n):\\n            nums[i]=[nums[i],i]\\n        nums.sort(key=lambda x:x[0])\\n        count=0\\n        ans=n\\n        prev=0\\n        for i in range(1,n):\\n            if nums[i-1][1]>nums[i][1]:\\n                count+=1\\n            ans+=count\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469345,
                "title": "100-faster-python",
                "content": "\\n# Intuition\\nimagine array to be circular and  iter through original index of sorted elements and keep track of steps traveled, in the end subtract number of times you crossed an element of each element.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        dic={nums[i]:i for i in range(len(nums))}\\n        nums.sort()\\n        dist=1\\n        prv=0\\n        arr=[0 for i in range(len(nums))]\\n        for i in range(len(nums)):\\n            ind=dic[nums[i]]\\n            temp=ind-prv\\n            if temp<0:\\n                dist+=len(nums)+temp\\n            else:\\n                dist+=temp\\n            arr[i]=dist\\n            prv=ind\\n        # print(arr,dist)    \\n        count=0    \\n        for i in arr:\\n            count+=(dist-i)//len(nums)\\n        return dist -count    \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        dic={nums[i]:i for i in range(len(nums))}\\n        nums.sort()\\n        dist=1\\n        prv=0\\n        arr=[0 for i in range(len(nums))]\\n        for i in range(len(nums)):\\n            ind=dic[nums[i]]\\n            temp=ind-prv\\n            if temp<0:\\n                dist+=len(nums)+temp\\n            else:\\n                dist+=temp\\n            arr[i]=dist\\n            prv=ind\\n        # print(arr,dist)    \\n        count=0    \\n        for i in arr:\\n            count+=(dist-i)//len(nums)\\n        return dist -count    \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469300,
                "title": "c-fenwickbtree-based-sln-o-n-logn-clean-code",
                "content": "\\n```\\n    class FenwickTree {\\n    public:\\n        FenwickTree(int n): v(n) {}\\n        \\n        int sum (int r) {\\n\\t        int result = 0;\\n\\t        for (; r >= 0; r = (r & (r+1)) - 1) {\\n                result += v[r];\\n            }   \\n\\t        return result;\\n        }\\n        \\n        void inc (int i, int delta) {\\n\\t        for (; i < size(v); i = (i | (i+1))) {\\n\\t\\t        v[i] += delta;\\n            }\\n        }\\n\\n        int sum (int l, int r) {\\n            if (l > r) return 0;\\n\\t        return sum (r) - sum (l-1);\\n        }\\n    private:\\n        vector<int> v;\\n    };\\n\\n\\nclass Solution {\\npublic:\\n    using ll = long long;    \\n    ll countOperationsToEmptyArray(vector<int>& nums) {\\n        const int n = size(nums);\\n        unordered_map<ll, ll> m;\\n        for (int i = 0; i < n; ++i) {\\n            m[nums[i]] = i;\\n        }\\n        sort(begin(nums), end(nums));\\n        FenwickTree ft(n);\\n        ft.inc(m[nums.front()], 1);\\n        ll ans = m[nums.front()];\\n        for (int i = 1; i < n; ++i) {\\n            int diff = 0;\\n            if (m[nums[i]] > m[nums[i - 1]]) {\\n                diff = m[nums[i]] - m[nums[i - 1]] - ft.sum(m[nums[i - 1]] + 1, m[nums[i]] - 1);\\n            } else {\\n                diff = n - m[nums[i - 1]] + m[nums[i]] - ft.sum(m[nums[i - 1]] + 1, n - 1) - ft.sum(0, m[nums[i]] - 1);\\n            }\\n            ft.inc(m[nums[i]], 1);\\n            ans += diff - 1;\\n        }\\n        return ans + size(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    class FenwickTree {\\n    public:\\n        FenwickTree(int n): v(n) {}\\n        \\n        int sum (int r) {\\n\\t        int result = 0;\\n\\t        for (; r >= 0; r = (r & (r+1)) - 1) {\\n                result += v[r];\\n            }   \\n\\t        return result;\\n        }\\n        \\n        void inc (int i, int delta) {\\n\\t        for (; i < size(v); i = (i | (i+1))) {\\n\\t\\t        v[i] += delta;\\n            }\\n        }\\n\\n        int sum (int l, int r) {\\n            if (l > r) return 0;\\n\\t        return sum (r) - sum (l-1);\\n        }\\n    private:\\n        vector<int> v;\\n    };\\n\\n\\nclass Solution {\\npublic:\\n    using ll = long long;    \\n    ll countOperationsToEmptyArray(vector<int>& nums) {\\n        const int n = size(nums);\\n        unordered_map<ll, ll> m;\\n        for (int i = 0; i < n; ++i) {\\n            m[nums[i]] = i;\\n        }\\n        sort(begin(nums), end(nums));\\n        FenwickTree ft(n);\\n        ft.inc(m[nums.front()], 1);\\n        ll ans = m[nums.front()];\\n        for (int i = 1; i < n; ++i) {\\n            int diff = 0;\\n            if (m[nums[i]] > m[nums[i - 1]]) {\\n                diff = m[nums[i]] - m[nums[i - 1]] - ft.sum(m[nums[i - 1]] + 1, m[nums[i]] - 1);\\n            } else {\\n                diff = n - m[nums[i - 1]] + m[nums[i]] - ft.sum(m[nums[i - 1]] + 1, n - 1) - ft.sum(0, m[nums[i]] - 1);\\n            }\\n            ft.inc(m[nums[i]], 1);\\n            ans += diff - 1;\\n        }\\n        return ans + size(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468822,
                "title": "simple-c-solution-using-map-o-n-logn",
                "content": "# Intuition\\nThe problem is asking to find the number of operations required to make the given array empty. In each operation, the maximum element in the array needs to be removed, and the sum of its value and the minimum value of the remaining array needs to be added to the answer. The approach is to sort the given array and then keep track of the number of elements greater than the current maximum element at any time.\\n\\nExample:\\nInput vector: [8, 1, 2, 4, 6, 3, 7, 5]\\n\\nSorted vector: [1, 2, 3, 4, 5, 6, 7, 8]\\nIf we go from left to right we see,\\n1, 2, 3 (3 elements) are in their expected order according to the sorted array\\nThen we have,\\n4, 5 (2 elements)\\n6, 7 (2 elements)\\n8 (1 element)\\n\\nSo here we can get the total count of operations as:\\n**count = (3 * 1) + (2 * 2) + (2 * 3) + (1 * 4)**\\nsums of (element counts * i), where i goes on incrementing.\\n\\n# Approach\\nThe approach is to use a map to keep track of the index of each element of the array. Then, we can use two pointers, p and q, to iterate over the map. We can start with p and q both pointing to the beginning of the map. We can then move p to the next element and check if its index is greater than the index of the element pointed to by q. If it is, we increment a counter n, which keeps track of the number of elements greater than the current maximum. If it is not, we add the product of n and i to the answer, where i is the number of operations performed so far, and reset n to 1. Finally, we add the product of n and i to the answer outside the loop, since there will be no more elements left in the map.\\n\\nExample:\\nInput vector: [8, 1, 2, 4, 6, 3, 7, 5]\\n\\nordered map mp: [1:1, 2:2, 3:5, 4:3, 5:7, 6:4, 7:6, 8:0]\\n\\nNow in the while loop we go on traversing in the map check the values of every key and performing if else conditions accordingly,\\n\\nas we can see in the map the values of first three keys are in increasing order count is incremented by 3 * 1 -> count=3\\nthen values of the keys 4 and 5 (i.e. 3 and 7) are in increasing order so count = count + (2 * 2) -> count = 7\\nsimilarly for keys 6, 7 -> count = count + (2 * 3) -> count = 13\\nand finally for key 8 -> count = count + (1 * 4) -> count = 17\\n\\nHence 17 is returned.\\n\\n# Complexity\\n- Time complexity: **O(n*log n)** due to sorting of the array.\\n\\n- Space complexity: **O(n)** due to the map.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long count = 0;\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++) mp[nums[i]] = i;\\n        auto p = mp.begin(), q = mp.begin();\\n        int n = 1, i = 1;\\n        p++;\\n        while(p != mp.end())\\n            if(p++ -> second > q++ -> second) n++;\\n            else{\\n                count += (n*i++);\\n                n=1;\\n            }\\n        return count + (n*i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long count = 0;\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++) mp[nums[i]] = i;\\n        auto p = mp.begin(), q = mp.begin();\\n        int n = 1, i = 1;\\n        p++;\\n        while(p != mp.end())\\n            if(p++ -> second > q++ -> second) n++;\\n            else{\\n                count += (n*i++);\\n                n=1;\\n            }\\n        return count + (n*i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468628,
                "title": "segment-tree-solution",
                "content": "Not sure why I am not seeing more segTree solutions in discussion. This was my solution during the contest:\\n\\nLet n = length of nums array.\\nLet say you pass the array, i.e. move from current index to next and mark removed elements instead of actually removing it.\\n**what alternate can you see for pushing back?:**\\npushing back can be alternatively seen as passing the array circularly more than once. For ex, let say in term of original operations you have pushed back a current element instead of removing it. Then it can be seen alternatively as skipping the marking of the element right now, but it can be marked when we circularly come back again to this element in next pass. (circularly means you go to first index after the last).\\nSo, if we find the original index in the sorted order of nums, let say {i1, i2, i3, ... in}\\nand you start from current index k = 0;\\nthen for marking first removed element you have to go from k to i1, mark i1, and k becomes i1 + 1\\nthen from k to i2, mark i2, and k becomes i2 + 1,\\nthen from k to i3, mark i3, and k becomes i3 + 1\\n...so on...\\ntill from k to in and mark in.\\nnow while traveling from index k to ia if ia >= k then you will get to ia in this pass only otherwise you will comeback again to ia in next pass to mark it.\\nso, **case 1:\\nia >= k :**\\nthen number of operations done by you to mark ia =\\n(number of push back operations) + (number of marking operations = 1)\\n= ((number of nodes alive(not marked) from k to ia) - 1) + 1\\n= **(number of nodes alive(not marked) from k to ia)**\\nas you need to push back only the not remove (i.e. not marked) elements while travelling.\\n\\n**case2:\\nia < k:**\\nthen number of operations done by you to mark ia =\\n(number of push back operations) + (number of marking operations = 1)\\n= ((number of nodes alive(not marked) from k to n - 1) +  (number of nodes alive(not marked) from 0 to ia) - 1) + 1\\n= **(number of nodes alive(not marked) from k to n - 1) +  (number of nodes alive(not marked) from 0 to ia) - 1)**\\n\\nnow to find number of alive nodes between index i to index j efficently, you can **maintain a segment tree**, and whenever you mark index k, you just reduce the number of alive nodes by 1 from the appropriate leaf node corresponding to k in the tree and work your way up to root.\\n(In the code below I am marking in segment tree itself by making the value at appropriate leaf node 0(from 1) and reducing progressively to its ancestors till I reach the root)\\n\\n```\\nclass Solution {\\n    int find(vector<vector<int> > &segTree, int i, int j, int c){\\n        if(j < i) return 0;\\n        if(segTree[c][0] == i && segTree[c][1] == j){\\n            return segTree[c][2];\\n        }\\n        else{\\n            int l = find(segTree, i, min(j, segTree[2*c + 1][1]), 2*c + 1);\\n            int r = find(segTree, max(i, segTree[2*c + 2][0]), j, 2*c + 2);\\n            return l + r;\\n        }\\n    }\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long ans = 0;\\n        vector<pair<int, int> > ord;\\n        for(int i = 0; i < nums.size(); i++){\\n            ord.push_back({nums[i], i});\\n        }\\n        int n = nums.size();\\n        sort(ord.begin(), ord.end());\\n        int k = 0;\\n        \\n        int t = 1;\\n        while(t < n){\\n            t *= 2;\\n        }\\n        int s = t - 1;\\n        t += s;\\n        vector<vector<int> > segTree(t, vector<int>());\\n        for(int i = 0; i < n; i++){\\n            segTree[s + i] = {i, i, 1};\\n        }\\n        for(int i = n; i <= s; i++){\\n            segTree[i + s] = {i, i, 0};\\n        }\\n        for(int i = s - 1; i >= 0; i--){\\n            segTree[i] = {segTree[2*i + 1][0], segTree[2*i + 2][1], segTree[2*i + 1][2] + segTree[2*i + 2][2]};\\n        }\\n        int x, y;\\n        for(int i = 0; i < n; i++){\\n            x = ord[i].second;\\n            if(x < k){\\n                y = find(segTree, k, n - 1, 0) + find(segTree, 0, x, 0);\\n            }\\n            else{\\n                y = find(segTree, k, x, 0);\\n            }\\n            t = s + x;\\n            while(t > 0){\\n                segTree[t][2]--;\\n                t = (t - 1)/2;\\n            }\\n            segTree[t][2]--;\\n            ans += y;\\n            k = (x + 1)%n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    int find(vector<vector<int> > &segTree, int i, int j, int c){\\n        if(j < i) return 0;\\n        if(segTree[c][0] == i && segTree[c][1] == j){\\n            return segTree[c][2];\\n        }\\n        else{\\n            int l = find(segTree, i, min(j, segTree[2*c + 1][1]), 2*c + 1);\\n            int r = find(segTree, max(i, segTree[2*c + 2][0]), j, 2*c + 2);\\n            return l + r;\\n        }\\n    }\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long ans = 0;\\n        vector<pair<int, int> > ord;\\n        for(int i = 0; i < nums.size(); i++){\\n            ord.push_back({nums[i], i});\\n        }\\n        int n = nums.size();\\n        sort(ord.begin(), ord.end());\\n        int k = 0;\\n        \\n        int t = 1;\\n        while(t < n){\\n            t *= 2;\\n        }\\n        int s = t - 1;\\n        t += s;\\n        vector<vector<int> > segTree(t, vector<int>());\\n        for(int i = 0; i < n; i++){\\n            segTree[s + i] = {i, i, 1};\\n        }\\n        for(int i = n; i <= s; i++){\\n            segTree[i + s] = {i, i, 0};\\n        }\\n        for(int i = s - 1; i >= 0; i--){\\n            segTree[i] = {segTree[2*i + 1][0], segTree[2*i + 2][1], segTree[2*i + 1][2] + segTree[2*i + 2][2]};\\n        }\\n        int x, y;\\n        for(int i = 0; i < n; i++){\\n            x = ord[i].second;\\n            if(x < k){\\n                y = find(segTree, k, n - 1, 0) + find(segTree, 0, x, 0);\\n            }\\n            else{\\n                y = find(segTree, k, x, 0);\\n            }\\n            t = s + x;\\n            while(t > 0){\\n                segTree[t][2]--;\\n                t = (t - 1)/2;\\n            }\\n            segTree[t][2]--;\\n            ans += y;\\n            k = (x + 1)%n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468098,
                "title": "o-n-log-n-solution-in-cpp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        long long n = nums.size(), ans = n;\\n        for (int i = 0; i < n; ++i)\\n            mp[nums[i]] = i;\\n\\n        sort(nums.begin(), nums.end());\\n\\n        for (int i = 1; i < n; ++i)\\n            if (mp[nums[i]] < mp[nums[i - 1]])\\n                ans += n - i;\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        long long n = nums.size(), ans = n;\\n        for (int i = 0; i < n; ++i)\\n            mp[nums[i]] = i;\\n\\n        sort(nums.begin(), nums.end());\\n\\n        for (int i = 1; i < n; ++i)\\n            if (mp[nums[i]] < mp[nums[i - 1]])\\n                ans += n - i;\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467975,
                "title": "my-solutions",
                "content": "**1. Use the Fenwick Tree**\\n```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n private:\\n  class FenwickTree {\\n   public:\\n    FenwickTree(const int n) : tree_(n) {\\n    }\\n    \\n    int read(const int i) {\\n      int ret = 0;\\n      for (int index = i; index > 0; index -= (index & -index)) {\\n        ret += tree_[index - 1];\\n      }\\n      return ret;\\n    }\\n    \\n    void update(const int i, const int delta) {\\n      const int n = static_cast<int>(tree_.size());\\n      for (int index = i; index <= n; index += (index & -index)) {\\n        tree_[index - 1] += delta;\\n      }\\n    }\\n    \\n   private:\\n    vector<int> tree_;\\n  };\\n  \\n public:\\n  long long countOperationsToEmptyArray(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    vector<int> indices(n);\\n    iota(indices.begin(), indices.end(), 0);\\n    sort(indices.begin(), indices.end(), [&nums](const int lhs, const int rhs) -> bool {\\n      return nums[lhs] < nums[rhs];\\n    });\\n    \\n    long long ret = 0;\\n    FenwickTree fenwick_tree(n);\\n    for (int previous = -1, current = -1, i = 0; i < n; previous = current, ++i) {\\n      current = indices[i];\\n      if (current > previous) {\\n        ret += current - previous - (fenwick_tree.read(current + 1) - fenwick_tree.read(previous + 1));\\n      } else {\\n        // current < previous\\n        ret += n + current - previous - (fenwick_tree.read(current + 1) + (fenwick_tree.read(n) - fenwick_tree.read(previous + 1)));\\n      }\\n      fenwick_tree.update(current + 1, 1);\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Sort and calculate the cost introducted by every disorder**\\n```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  long long countOperationsToEmptyArray(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    vector<int> indices(n);\\n    iota(indices.begin(), indices.end(), 0);\\n    sort(indices.begin(), indices.end(), [&nums](const int lhs, const int rhs) -> bool {\\n      return nums[lhs] < nums[rhs];\\n    });\\n    \\n    /**\\n     * all operations include `n` erasing operations and some (zero or more) moving operations\\n     * initially, `n` erasing operations are needed.\\n     */\\n    long long ret = n;\\n    for (int i = 1; i < n; ++i) {\\n      if (indices[i] < indices[i - 1]) {\\n        /**\\n         * the disorder introduced by `indices[i] < indices[i - 1]` will cost extra `n - i` moving operations\\n         */\\n        ret += n - i;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n private:\\n  class FenwickTree {\\n   public:\\n    FenwickTree(const int n) : tree_(n) {\\n    }\\n    \\n    int read(const int i) {\\n      int ret = 0;\\n      for (int index = i; index > 0; index -= (index & -index)) {\\n        ret += tree_[index - 1];\\n      }\\n      return ret;\\n    }\\n    \\n    void update(const int i, const int delta) {\\n      const int n = static_cast<int>(tree_.size());\\n      for (int index = i; index <= n; index += (index & -index)) {\\n        tree_[index - 1] += delta;\\n      }\\n    }\\n    \\n   private:\\n    vector<int> tree_;\\n  };\\n  \\n public:\\n  long long countOperationsToEmptyArray(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    vector<int> indices(n);\\n    iota(indices.begin(), indices.end(), 0);\\n    sort(indices.begin(), indices.end(), [&nums](const int lhs, const int rhs) -> bool {\\n      return nums[lhs] < nums[rhs];\\n    });\\n    \\n    long long ret = 0;\\n    FenwickTree fenwick_tree(n);\\n    for (int previous = -1, current = -1, i = 0; i < n; previous = current, ++i) {\\n      current = indices[i];\\n      if (current > previous) {\\n        ret += current - previous - (fenwick_tree.read(current + 1) - fenwick_tree.read(previous + 1));\\n      } else {\\n        // current < previous\\n        ret += n + current - previous - (fenwick_tree.read(current + 1) + (fenwick_tree.read(n) - fenwick_tree.read(previous + 1)));\\n      }\\n      fenwick_tree.update(current + 1, 1);\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  long long countOperationsToEmptyArray(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    vector<int> indices(n);\\n    iota(indices.begin(), indices.end(), 0);\\n    sort(indices.begin(), indices.end(), [&nums](const int lhs, const int rhs) -> bool {\\n      return nums[lhs] < nums[rhs];\\n    });\\n    \\n    /**\\n     * all operations include `n` erasing operations and some (zero or more) moving operations\\n     * initially, `n` erasing operations are needed.\\n     */\\n    long long ret = n;\\n    for (int i = 1; i < n; ++i) {\\n      if (indices[i] < indices[i - 1]) {\\n        /**\\n         * the disorder introduced by `indices[i] < indices[i - 1]` will cost extra `n - i` moving operations\\n         */\\n        ret += n - i;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467954,
                "title": "segment-tree-solution-c-self-explanatory-code",
                "content": "```\\nclass Node {\\n  public:\\n    int maxs;\\n    Node* left;\\n    Node* right;\\n    Node(int data) {\\n        this->maxs = data;\\n        left = NULL;\\n        right = NULL;\\n    }\\n     Node() {\\n        left = NULL;\\n        right = NULL;\\n    }\\n    \\n};\\nclass SegmentTree {\\npublic:\\n    Node* buildSegmentTree(vector<int>& nums, int i, int j) {\\n        if(i == j) {\\n            Node* nn = new Node(nums[i]);\\n            return nn;\\n        }\\n        \\n        int mid = (i+j)/2;\\n        \\n        Node* left = buildSegmentTree(nums,i,mid);\\n        Node* right = buildSegmentTree(nums,mid+1,j);\\n        Node* root = new Node();\\n        root->maxs = left->maxs+right->maxs;\\n        root->left = left;\\n        root->right = right;\\n        return root;   \\n    }\\n    int totalNumbers(Node* Tree, int i, int j, int a, int b) {\\n        if(i>j || a > b) {\\n            return 0;\\n        }\\n        if(Tree == NULL) {\\n            return 0;\\n        }\\n        if(i>b || j<a) {\\n            return 0;\\n        }\\n        \\n        if(a>=i && b<=j) {\\n            return Tree->maxs;    \\n        }\\n       \\n        int mid = (a+b)/2;\\n        int bb = totalNumbers(Tree->left,i,j,a,mid);\\n        int cc = totalNumbers(Tree->right,i,j,mid+1,b);\\n        return bb+cc;\\n    }\\n    Node* update(Node* Tree,int a, int b, int index) {\\n        if(a == b) {\\n            Tree->maxs = 0;\\n            return Tree;\\n        }\\n            \\n            int mid = (a+b)/2;\\n            if(index<=mid) {\\n                Tree->left = update(Tree->left,a,mid,index);\\n            }\\n        else {\\n            Tree->right = update(Tree->right,mid+1,b,index);\\n        }\\n        Tree->maxs = Tree->left->maxs + Tree->right->maxs;\\n        return Tree;\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& kk) {\\n        vector<int> tt(kk.size(), 1);\\n       SegmentTree *ss = new SegmentTree();\\n        Node* root = ss->buildSegmentTree(tt,0,kk.size()-1);\\n        unordered_map<int,int> numberIndex;\\n      \\n        for(int i = 0;i<kk.size(); i++) {\\n            numberIndex[kk[i]] = i;\\n        }\\n          sort(kk.begin(), kk.end());\\n        long long int ans = 0;\\n        \\n        for(int i = 0;i<=kk.size()-1;i++) {\\n            if(i == 0) {\\n                ans += numberIndex[kk[i]] + 1; \\n            }\\n            else {\\n                int prevNumberIndex = numberIndex[kk[i-1]];\\n                int currNumberIndex = numberIndex[kk[i]];\\n                int elementBwThem = 0;\\n                int elementSmallerThanPrevNumbBwThem = 0;\\n                if(currNumberIndex < prevNumberIndex) {\\n                    elementSmallerThanPrevNumbBwThem = ss->totalNumbers(root,0,currNumberIndex-1,0,kk.size()-1) + \\n                       ss->totalNumbers(root,prevNumberIndex+1 ,kk.size()-1,0,kk.size()-1) ;\\n                    ans += elementSmallerThanPrevNumbBwThem+1;\\n                }\\n                else {\\n                 \\n                    elementSmallerThanPrevNumbBwThem = ss->totalNumbers(root,prevNumberIndex+1,currNumberIndex-1,0,kk.size()-1);\\n                    ans += elementSmallerThanPrevNumbBwThem+1;\\n                    \\n                }\\n            }\\n            root = ss->update(root,0,kk.size()-1,numberIndex[kk[i]]);\\n            // cout<<ans<<endl;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node {\\n  public:\\n    int maxs;\\n    Node* left;\\n    Node* right;\\n    Node(int data) {\\n        this->maxs = data;\\n        left = NULL;\\n        right = NULL;\\n    }\\n     Node() {\\n        left = NULL;\\n        right = NULL;\\n    }\\n    \\n};\\nclass SegmentTree {\\npublic:\\n    Node* buildSegmentTree(vector<int>& nums, int i, int j) {\\n        if(i == j) {\\n            Node* nn = new Node(nums[i]);\\n            return nn;\\n        }\\n        \\n        int mid = (i+j)/2;\\n        \\n        Node* left = buildSegmentTree(nums,i,mid);\\n        Node* right = buildSegmentTree(nums,mid+1,j);\\n        Node* root = new Node();\\n        root->maxs = left->maxs+right->maxs;\\n        root->left = left;\\n        root->right = right;\\n        return root;   \\n    }\\n    int totalNumbers(Node* Tree, int i, int j, int a, int b) {\\n        if(i>j || a > b) {\\n            return 0;\\n        }\\n        if(Tree == NULL) {\\n            return 0;\\n        }\\n        if(i>b || j<a) {\\n            return 0;\\n        }\\n        \\n        if(a>=i && b<=j) {\\n            return Tree->maxs;    \\n        }\\n       \\n        int mid = (a+b)/2;\\n        int bb = totalNumbers(Tree->left,i,j,a,mid);\\n        int cc = totalNumbers(Tree->right,i,j,mid+1,b);\\n        return bb+cc;\\n    }\\n    Node* update(Node* Tree,int a, int b, int index) {\\n        if(a == b) {\\n            Tree->maxs = 0;\\n            return Tree;\\n        }\\n            \\n            int mid = (a+b)/2;\\n            if(index<=mid) {\\n                Tree->left = update(Tree->left,a,mid,index);\\n            }\\n        else {\\n            Tree->right = update(Tree->right,mid+1,b,index);\\n        }\\n        Tree->maxs = Tree->left->maxs + Tree->right->maxs;\\n        return Tree;\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& kk) {\\n        vector<int> tt(kk.size(), 1);\\n       SegmentTree *ss = new SegmentTree();\\n        Node* root = ss->buildSegmentTree(tt,0,kk.size()-1);\\n        unordered_map<int,int> numberIndex;\\n      \\n        for(int i = 0;i<kk.size(); i++) {\\n            numberIndex[kk[i]] = i;\\n        }\\n          sort(kk.begin(), kk.end());\\n        long long int ans = 0;\\n        \\n        for(int i = 0;i<=kk.size()-1;i++) {\\n            if(i == 0) {\\n                ans += numberIndex[kk[i]] + 1; \\n            }\\n            else {\\n                int prevNumberIndex = numberIndex[kk[i-1]];\\n                int currNumberIndex = numberIndex[kk[i]];\\n                int elementBwThem = 0;\\n                int elementSmallerThanPrevNumbBwThem = 0;\\n                if(currNumberIndex < prevNumberIndex) {\\n                    elementSmallerThanPrevNumbBwThem = ss->totalNumbers(root,0,currNumberIndex-1,0,kk.size()-1) + \\n                       ss->totalNumbers(root,prevNumberIndex+1 ,kk.size()-1,0,kk.size()-1) ;\\n                    ans += elementSmallerThanPrevNumbBwThem+1;\\n                }\\n                else {\\n                 \\n                    elementSmallerThanPrevNumbBwThem = ss->totalNumbers(root,prevNumberIndex+1,currNumberIndex-1,0,kk.size()-1);\\n                    ans += elementSmallerThanPrevNumbBwThem+1;\\n                    \\n                }\\n            }\\n            root = ss->update(root,0,kk.size()-1,numberIndex[kk[i]]);\\n            // cout<<ans<<endl;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3467898,
                "title": "fast-compact-2-definitions-3-statements-modern-c-solution",
                "content": "Suppose nums = [3, 4, 1, 5, 0 2]. We can now form an infinite sequence 3 4 1 5 0 2 3 4 1 5 0 2 3 4 1 5 0 2 3 4 1 5 0 2 3 4 1 5 0 2 ... by repeatingly appending nums.\\n\\nLet T be short-hand for countOperationsToEmptyArray. Since the two smallest numbers of nums (0 and 1) are out of order one has to proceed to the second block of the sequence after having elimiated 0. \\n\\nHence T([3, 4, 1, 5, 0, 2]) = block-length + T([3, 4, 1, 5, 2]). Whereas T([3, 4, 0, 5, 1, 2]) = 1 + T([3, 4, 5, 1, 2]).\\n\\nHence if we calculate the ordering of nums, getting [4, 2, 5, 0, 1, 3], the smallest entry is in position 4, then next smallest entry in position 2, etc, we can use the recurrence relation for T directly.\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n\\tlong long countOperationsToEmptyArray(std::vector<int>& nums)\\n\\t{\\n\\t\\tauto const n = std::size(nums);\\n\\n\\t\\tauto ordering = std::vector<int>(n);\\n\\t\\tstd::iota(std::begin(ordering), std::end(ordering), 0);\\n\\n\\t\\tstd::sort(std::begin(ordering), std::end(ordering),\\n\\t\\t\\t[&nums](auto const i, auto const j) { return nums[i] < nums[j]; });\\n\\n        // k is the block length\\n        // tail, head are consecutive elements in the ordering\\n\\t\\treturn std::transform_reduce(std::next(std::cbegin(ordering)), std::cend(ordering), std::cbegin(ordering), 1ULL,\\n\\t\\t\\tstd::plus<>(),\\n\\t\\t\\t[k = n + 1](auto head, auto tail) mutable\\n\\t\\t\\t{\\n\\t\\t\\t\\t--k;\\n\\t\\t\\t\\treturn head < tail ? k : 1ULL;\\n\\t\\t\\t});\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tlong long countOperationsToEmptyArray(std::vector<int>& nums)\\n\\t{\\n\\t\\tauto const n = std::size(nums);\\n\\n\\t\\tauto ordering = std::vector<int>(n);\\n\\t\\tstd::iota(std::begin(ordering), std::end(ordering), 0);\\n\\n\\t\\tstd::sort(std::begin(ordering), std::end(ordering),\\n\\t\\t\\t[&nums](auto const i, auto const j) { return nums[i] < nums[j]; });\\n\\n        // k is the block length\\n        // tail, head are consecutive elements in the ordering\\n\\t\\treturn std::transform_reduce(std::next(std::cbegin(ordering)), std::cend(ordering), std::cbegin(ordering), 1ULL,\\n\\t\\t\\tstd::plus<>(),\\n\\t\\t\\t[k = n + 1](auto head, auto tail) mutable\\n\\t\\t\\t{\\n\\t\\t\\t\\t--k;\\n\\t\\t\\t\\treturn head < tail ? k : 1ULL;\\n\\t\\t\\t});\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467820,
                "title": "python-short-simple-solution-sortedlist-reversed-operations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        sl = SortedList()\\n        nums = list(enumerate(nums))\\n        nums.sort(key=lambda x: x[1], reverse=True)\\n        \\n        sl.add(nums[0])\\n        total = 1\\n        for i in range(1, len(nums)):\\n            sl.add(nums[i])\\n            total += (sl.bisect_left(nums[i-1]) - sl.bisect_left(nums[i]))%len(sl)\\n        total += nums[-1][0]\\n        \\n        return total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        sl = SortedList()\\n        nums = list(enumerate(nums))\\n        nums.sort(key=lambda x: x[1], reverse=True)\\n        \\n        sl.add(nums[0])\\n        total = 1\\n        for i in range(1, len(nums)):\\n            sl.add(nums[i])\\n            total += (sl.bisect_left(nums[i-1]) - sl.bisect_left(nums[i]))%len(sl)\\n        total += nums[-1][0]\\n        \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467797,
                "title": "python-numpy-bruteforce",
                "content": "Numpy allows bruteforce solution to pass time limit.\\ncredit to @ankushbhrdwj\\n\\n# Code\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        nums_arr = np.array(nums)\\n        operations = len(nums)\\n        while len(nums_arr):\\n            min_loc = np.argmin(nums_arr)\\n            if min_loc:\\n                operations += min_loc\\n                nums_arr = np.concatenate((nums_arr[min_loc + 1:], nums_arr[:min_loc]))\\n            else:\\n                nums_arr = nums_arr[1:]\\n            \\n        return operations\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        nums_arr = np.array(nums)\\n        operations = len(nums)\\n        while len(nums_arr):\\n            min_loc = np.argmin(nums_arr)\\n            if min_loc:\\n                operations += min_loc\\n                nums_arr = np.concatenate((nums_arr[min_loc + 1:], nums_arr[:min_loc]))\\n            else:\\n                nums_arr = nums_arr[1:]\\n            \\n        return operations\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467743,
                "title": "brute-force-optimized-solution-using-map-cpp",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n\\n## Brute Force Approach\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n  \\n        long long cnt = 0;\\n        \\n        deque<int> dq(nums.begin(), nums.end());\\n        sort(nums.begin(), nums.end());\\n        int i=0;\\n        \\n        while(!dq.empty()){\\n            if(nums[i] == dq.front()){\\n                dq.pop_front();\\n                i++;\\n            }\\n            else\\n            {\\n                dq.push_back(dq.front());\\n                dq.pop_front();\\n            }\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n## Optimized Approach\\n```\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n\\n    unordered_map<int,int> map;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            map[nums[i]] = i;\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n        long ans=nums.size();\\n        int curr =0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int og_pos = map[nums[i]];\\n\\n             if(og_pos < curr){\\n                ans+=(nums.size()-i);\\n            }\\n            curr=map[nums[i]];\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n  \\n        long long cnt = 0;\\n        \\n        deque<int> dq(nums.begin(), nums.end());\\n        sort(nums.begin(), nums.end());\\n        int i=0;\\n        \\n        while(!dq.empty()){\\n            if(nums[i] == dq.front()){\\n                dq.pop_front();\\n                i++;\\n            }\\n            else\\n            {\\n                dq.push_back(dq.front());\\n                dq.pop_front();\\n            }\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n\\n    unordered_map<int,int> map;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            map[nums[i]] = i;\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n        long ans=nums.size();\\n        int curr =0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int og_pos = map[nums[i]];\\n\\n             if(og_pos < curr){\\n                ans+=(nums.size()-i);\\n            }\\n            curr=map[nums[i]];\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467580,
                "title": "c-tle-accepted-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n// TLE\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long count = 0;\\n        vector<int> v = nums;\\n        sort(v.begin(), v.end());\\n        queue<long long> d, q1, q2;\\n        for(auto i:nums)\\n            q1.push(i);\\n        for(auto i:v)\\n            d.push(i);\\n            // cout<<i<<\" \";\\n        while(!q1.empty() || !q2.empty()){\\n            while(!q1.empty()){\\n                if(q1.front()==d.front()){\\n                    q1.pop();\\n                    d.pop();\\n                    count++;\\n                }\\n                else{\\n                    q2.push(q1.front());\\n                    q1.pop();\\n                    count++;\\n                }     \\n            }\\n            \\n            while(!q2.empty()){\\n                if(q2.front()==d.front()){\\n                    q2.pop();\\n                    d.pop();\\n                    count++;\\n                }\\n                else{\\n                    q1.push(q2.front());\\n                    q2.pop();\\n                    count++;\\n                }     \\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n// Accepted sollution \\n\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long n = nums.size();\\n        long long count = n;\\n        unordered_map<int, int> m;\\n        for(int i=0; i<n; i++){\\n            m[nums[i]]=i;\\n        }\\n        sort(nums.begin(), nums.end());\\n        for(int i=1; i<n; i++){\\n            if(m[nums[i]]<m[nums[i-1]]){\\n                count = count + n - i;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n// TLE\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long count = 0;\\n        vector<int> v = nums;\\n        sort(v.begin(), v.end());\\n        queue<long long> d, q1, q2;\\n        for(auto i:nums)\\n            q1.push(i);\\n        for(auto i:v)\\n            d.push(i);\\n            // cout<<i<<\" \";\\n        while(!q1.empty() || !q2.empty()){\\n            while(!q1.empty()){\\n                if(q1.front()==d.front()){\\n                    q1.pop();\\n                    d.pop();\\n                    count++;\\n                }\\n                else{\\n                    q2.push(q1.front());\\n                    q1.pop();\\n                    count++;\\n                }     \\n            }\\n            \\n            while(!q2.empty()){\\n                if(q2.front()==d.front()){\\n                    q2.pop();\\n                    d.pop();\\n                    count++;\\n                }\\n                else{\\n                    q1.push(q2.front());\\n                    q2.pop();\\n                    count++;\\n                }     \\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n// Accepted sollution \\n\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long n = nums.size();\\n        long long count = n;\\n        unordered_map<int, int> m;\\n        for(int i=0; i<n; i++){\\n            m[nums[i]]=i;\\n        }\\n        sort(nums.begin(), nums.end());\\n        for(int i=1; i<n; i++){\\n            if(m[nums[i]]<m[nums[i-1]]){\\n                count = count + n - i;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3467539,
                "title": "python-sortedlist-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is a hard one. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the numbers and process each going from small to large. \\nFor current number, only consider the relative position to the last smaller number in the original array.  \\n\\nSee code comments for details.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        arr = [(c,i) for i,c in enumerate(nums)]\\n        sl = SortedList()\\n        b0 = [0]*n # b0[i]: # of elements > nums[i] in nums[0:i-1]\\n        s0 = [0]*n # s0[i]: # of elements < nums[i] in nums[0:i-1]\\n        sl.add(nums[0])\\n        for i in range(1, n):\\n            s0[i] = sl.bisect_left(nums[i])\\n            b0[i] = len(sl) - s0[i]\\n            sl.add(nums[i])\\n        b1 = [0]*n # b1[i]: # of elements > nums[i] in nums[i+1:]\\n        sl = SortedList()\\n        sl.add(nums[-1])\\n        for i in range(n-2, -1, -1):\\n            b1[i] = len(sl) - sl.bisect_left(nums[i])\\n            sl.add(nums[i])\\n        arr.append((-inf, -1))\\n        arr.sort()\\n        ans = 0\\n        for i in range(1, n+1):\\n            _, cur = arr[i]            \\n            last = arr[i-1][1]\\n            if cur > last:\\n                if arr[i-1][1] == -1: # this is for the min of nums\\n                    ans += cur - last # the # of ops is just moves to the left end plus 1 (remove op)\\n                else: # for all others if the last pos is to the left, find the # of elements < nums[idx] \\n                      # b.w. the last pos and idx (= s0[cur]-s0[last]-1); this is the # of elemnts \\n                      # already removed, so not counting any more  \\n                      # the # of ops is just moves to the left end (idx-arr[i-1][1]-1) minus\\n                      # the # of elements already removed (from above) plus 1 (remove op)\\n                    ans += (cur-last-1) - (s0[cur]-s0[last]-1) + 1\\n            else:# if the last pos is on the right, we need to find the # of elements > nums[idx]\\n                 # who are to the left of cur and to the right of the last pos  \\n                 # the # of ops in this case is just moves to pass all those bigger elements \\n                 # plus 1 (remove op)\\n                ans += b0[cur] + b1[last] + 1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        arr = [(c,i) for i,c in enumerate(nums)]\\n        sl = SortedList()\\n        b0 = [0]*n # b0[i]: # of elements > nums[i] in nums[0:i-1]\\n        s0 = [0]*n # s0[i]: # of elements < nums[i] in nums[0:i-1]\\n        sl.add(nums[0])\\n        for i in range(1, n):\\n            s0[i] = sl.bisect_left(nums[i])\\n            b0[i] = len(sl) - s0[i]\\n            sl.add(nums[i])\\n        b1 = [0]*n # b1[i]: # of elements > nums[i] in nums[i+1:]\\n        sl = SortedList()\\n        sl.add(nums[-1])\\n        for i in range(n-2, -1, -1):\\n            b1[i] = len(sl) - sl.bisect_left(nums[i])\\n            sl.add(nums[i])\\n        arr.append((-inf, -1))\\n        arr.sort()\\n        ans = 0\\n        for i in range(1, n+1):\\n            _, cur = arr[i]            \\n            last = arr[i-1][1]\\n            if cur > last:\\n                if arr[i-1][1] == -1: # this is for the min of nums\\n                    ans += cur - last # the # of ops is just moves to the left end plus 1 (remove op)\\n                else: # for all others if the last pos is to the left, find the # of elements < nums[idx] \\n                      # b.w. the last pos and idx (= s0[cur]-s0[last]-1); this is the # of elemnts \\n                      # already removed, so not counting any more  \\n                      # the # of ops is just moves to the left end (idx-arr[i-1][1]-1) minus\\n                      # the # of elements already removed (from above) plus 1 (remove op)\\n                    ans += (cur-last-1) - (s0[cur]-s0[last]-1) + 1\\n            else:# if the last pos is on the right, we need to find the # of elements > nums[idx]\\n                 # who are to the left of cur and to the right of the last pos  \\n                 # the # of ops in this case is just moves to pass all those bigger elements \\n                 # plus 1 (remove op)\\n                ans += b0[cur] + b1[last] + 1\\n        return ans\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3467470,
                "title": "solved-using-segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\ntypedef long long   int   ll;\\n\\nclass Solution {\\npublic:\\n    \\n//        // 4  2 1 3 5\\n//    +3\\n\\n//    3 5 4 2\\n\\n//    +4\\n\\n\\n//    3 5 4 \\n   vector<ll> hehe;\\n\\n    ll query(int node, int i, int j, int l, int r)\\n    {\\n        if (r < i || l > j)\\n        {\\n            return 0;\\n        }\\n        if (l <= i && j <= r)\\n        {\\n            return hehe[node];\\n        }\\n\\n        ll mid = (i + j) / 2;\\n\\n        return  query(2 * node, i, mid, l, r)+query(2 * node + 1, mid + 1, j, l, r);\\n    }\\n    ll update(int node, int i, int j, int l)\\n    {\\n        if (l < i || l > j)\\n        {\\n            return hehe[node];\\n        }\\n        if (i == j)\\n        {\\n            hehe[node] = 1;\\n            return 1;\\n        }\\n\\n        ll mid = (i + j) / 2;\\n\\n        return hehe[node] = update(2 * node, i, mid, l)+update(2 * node + 1, mid + 1, j, l);\\n    }\\n    \\n    long long countOperationsToEmptyArray(vector<int>& a) {\\n        \\n      unordered_map<int,int> m;\\n        \\n        for(int i=0;i<a.size();i++){\\n             m[a[i]]=i;\\n        }\\n        \\n        int n=a.size();\\n        \\n        hehe.resize(4*n,0);\\n        \\n        \\n        \\n        sort(a.begin(),a.end());\\n        \\n        long long ans=m[a[0]]+1;\\n         \\n        long long prev=a[0];\\n        \\n        int i=1;\\n        int rem=a.size()-1;\\n        \\n        update(1,0,n-1,m[a[0]]);        \\n        \\n        while(i<n){\\n            if(m[a[i-1]]<m[a[i]]){\\n                 ans+=m[a[i]]-m[a[i-1]]-query(1,0,n-1,m[a[i-1]]+1,m[a[i]]-1);\\n                 update(1,0,n-1,m[a[i]]); \\n            }\\n            else{\\n                 ans+=n-m[a[i-1]]+m[a[i]]-(query(1,0,n-1,m[a[i-1]]+1,n-1)+query(1,0,n-1,0,m[a[i]]));\\n                 update(1,0,n-1,m[a[i]]);\\n            }\\n            i++;\\n        }\\n  \\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\ntypedef long long   int   ll;\\n\\nclass Solution {\\npublic:\\n    \\n//        // 4  2 1 3 5\\n//    +3\\n\\n//    3 5 4 2\\n\\n//    +4\\n\\n\\n//    3 5 4 \\n   vector<ll> hehe;\\n\\n    ll query(int node, int i, int j, int l, int r)\\n    {\\n        if (r < i || l > j)\\n        {\\n            return 0;\\n        }\\n        if (l <= i && j <= r)\\n        {\\n            return hehe[node];\\n        }\\n\\n        ll mid = (i + j) / 2;\\n\\n        return  query(2 * node, i, mid, l, r)+query(2 * node + 1, mid + 1, j, l, r);\\n    }\\n    ll update(int node, int i, int j, int l)\\n    {\\n        if (l < i || l > j)\\n        {\\n            return hehe[node];\\n        }\\n        if (i == j)\\n        {\\n            hehe[node] = 1;\\n            return 1;\\n        }\\n\\n        ll mid = (i + j) / 2;\\n\\n        return hehe[node] = update(2 * node, i, mid, l)+update(2 * node + 1, mid + 1, j, l);\\n    }\\n    \\n    long long countOperationsToEmptyArray(vector<int>& a) {\\n        \\n      unordered_map<int,int> m;\\n        \\n        for(int i=0;i<a.size();i++){\\n             m[a[i]]=i;\\n        }\\n        \\n        int n=a.size();\\n        \\n        hehe.resize(4*n,0);\\n        \\n        \\n        \\n        sort(a.begin(),a.end());\\n        \\n        long long ans=m[a[0]]+1;\\n         \\n        long long prev=a[0];\\n        \\n        int i=1;\\n        int rem=a.size()-1;\\n        \\n        update(1,0,n-1,m[a[0]]);        \\n        \\n        while(i<n){\\n            if(m[a[i-1]]<m[a[i]]){\\n                 ans+=m[a[i]]-m[a[i-1]]-query(1,0,n-1,m[a[i-1]]+1,m[a[i]]-1);\\n                 update(1,0,n-1,m[a[i]]); \\n            }\\n            else{\\n                 ans+=n-m[a[i-1]]+m[a[i]]-(query(1,0,n-1,m[a[i-1]]+1,n-1)+query(1,0,n-1,0,m[a[i]]));\\n                 update(1,0,n-1,m[a[i]]);\\n            }\\n            i++;\\n        }\\n  \\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467342,
                "title": "segment-tree-good-qs",
                "content": "```\\nclass Solution {\\npublic:\\n    struct seg\\n{\\n    vector<int> v;\\n    vector<int> tree;\\n    vector<int> lazy;\\n    seg(vector<int>&arr)\\n    {\\n        v = arr;\\n        vector<int> dummy1(4 * v.size());\\n        vector<int> dummy2(4 * v.size());\\n        tree = dummy1;\\n        lazy = dummy2;\\n    }\\n    void build(int node,int start,int end){\\n        if(start==end){\\n            tree[node]=v[start];\\n        }\\n        else{\\n            int mid = (start+end)/2;\\n            build(node*2,start,mid);\\n            build(node*2+1,mid+1,end);\\n            tree[node] = tree[node*2] + tree[node*2+1];\\n        }\\n    }\\n    void propogate(int node, int start, int end)\\n    {\\n        if (start == end)\\n        {\\n            tree[node] += lazy[node];\\n            lazy[node] = 0;\\n        }\\n        else\\n        {\\n            tree[node] += ((end - start + 1) * lazy[node]);\\n            lazy[2 * node] += lazy[node];\\n            lazy[2 * node + 1] += lazy[node];\\n            lazy[node] = 0;\\n        }\\n    }\\n    void update(int node, int start, int end, int l, int r, int x)\\n    {\\n        propogate(node, start, end);\\n        if (start > r || end < l)\\n        {\\n            return;\\n        }\\n        if (start == end)\\n        {\\n            tree[node] += x;\\n        }\\n        else if (l <= start && end <= r)\\n        {\\n            lazy[node] += x;\\n            propogate(node, start, end);\\n        }\\n        else\\n        {\\n            int mid = (start + end) / 2;\\n            update(node * 2, start, mid, l, r, x);\\n            update(node * 2 + 1, mid + 1, end, l, r, x);\\n            tree[node] = tree[node * 2] + tree[node * 2 + 1];\\n        }\\n    }\\n    int query(int node, int start, int end, int l, int r)\\n    {\\n        if (start > r || end < l)\\n        {\\n            return 0;\\n        }\\n        propogate(node,start,end);\\n        if (start == end)\\n        {\\n            return tree[node];\\n        }\\n        else if (start >= l && end <= r)\\n        {\\n            return tree[node];\\n        }\\n        else\\n        {\\n            int mid = (start + end) / 2;\\n            int left = query(node * 2, start, mid, l, r);\\n            int right = query(node * 2 + 1, mid + 1, end, l, r);\\n            return left + right;\\n        }\\n    }\\n};\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long int ans=nums.size();\\n        map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]=i;\\n        }\\n        vector<pair<int,int>>t;\\n        for(auto &i:m){\\n            t.push_back({i.first,i.second});\\n        }\\n        // for(auto &i:t){\\n        //     cout<<i.second<<\" \";\\n        // }\\n        // cout<<endl;\\n        int prev=t[0].second;\\n        ans+=(t[0].second);\\n        // cout<<ans<<\" \";\\n        vector<int>v(nums.size(),0);\\n        seg s=seg(v);\\n        int n=nums.size();\\n        s.update(1,0,n-1,prev,prev,1);\\n        for(int i=1;i<n;i++){\\n            int idx=t[i].second;\\n            // cout<<prev<<\" \"<<idx<<\" \";\\n            if(prev>idx){\\n                ans+=(n-prev-1);\\n                ans+=(idx);\\n                int one=s.query(1,0,n-1,0,idx-1);\\n                int two=s.query(1,0,n-1,prev+1,n-1);\\n                ans-=(one+two);\\n            }\\n            else{\\n                ans+=(idx-prev-1);\\n                int bich=s.query(1,0,n-1,prev+1,idx-1);\\n                // cout<<bich<<\" \";\\n                ans-=bich;\\n            }\\n            s.update(1,0,n-1,idx,idx,1);\\n            prev=idx;\\n            // cout<<ans<<\"\\\\n\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct seg\\n{\\n    vector<int> v;\\n    vector<int> tree;\\n    vector<int> lazy;\\n    seg(vector<int>&arr)\\n    {\\n        v = arr;\\n        vector<int> dummy1(4 * v.size());\\n        vector<int> dummy2(4 * v.size());\\n        tree = dummy1;\\n        lazy = dummy2;\\n    }\\n    void build(int node,int start,int end){\\n        if(start==end){\\n            tree[node]=v[start];\\n        }\\n        else{\\n            int mid = (start+end)/2;\\n            build(node*2,start,mid);\\n            build(node*2+1,mid+1,end);\\n            tree[node] = tree[node*2] + tree[node*2+1];\\n        }\\n    }\\n    void propogate(int node, int start, int end)\\n    {\\n        if (start == end)\\n        {\\n            tree[node] += lazy[node];\\n            lazy[node] = 0;\\n        }\\n        else\\n        {\\n            tree[node] += ((end - start + 1) * lazy[node]);\\n            lazy[2 * node] += lazy[node];\\n            lazy[2 * node + 1] += lazy[node];\\n            lazy[node] = 0;\\n        }\\n    }\\n    void update(int node, int start, int end, int l, int r, int x)\\n    {\\n        propogate(node, start, end);\\n        if (start > r || end < l)\\n        {\\n            return;\\n        }\\n        if (start == end)\\n        {\\n            tree[node] += x;\\n        }\\n        else if (l <= start && end <= r)\\n        {\\n            lazy[node] += x;\\n            propogate(node, start, end);\\n        }\\n        else\\n        {\\n            int mid = (start + end) / 2;\\n            update(node * 2, start, mid, l, r, x);\\n            update(node * 2 + 1, mid + 1, end, l, r, x);\\n            tree[node] = tree[node * 2] + tree[node * 2 + 1];\\n        }\\n    }\\n    int query(int node, int start, int end, int l, int r)\\n    {\\n        if (start > r || end < l)\\n        {\\n            return 0;\\n        }\\n        propogate(node,start,end);\\n        if (start == end)\\n        {\\n            return tree[node];\\n        }\\n        else if (start >= l && end <= r)\\n        {\\n            return tree[node];\\n        }\\n        else\\n        {\\n            int mid = (start + end) / 2;\\n            int left = query(node * 2, start, mid, l, r);\\n            int right = query(node * 2 + 1, mid + 1, end, l, r);\\n            return left + right;\\n        }\\n    }\\n};\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long int ans=nums.size();\\n        map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]=i;\\n        }\\n        vector<pair<int,int>>t;\\n        for(auto &i:m){\\n            t.push_back({i.first,i.second});\\n        }\\n        // for(auto &i:t){\\n        //     cout<<i.second<<\" \";\\n        // }\\n        // cout<<endl;\\n        int prev=t[0].second;\\n        ans+=(t[0].second);\\n        // cout<<ans<<\" \";\\n        vector<int>v(nums.size(),0);\\n        seg s=seg(v);\\n        int n=nums.size();\\n        s.update(1,0,n-1,prev,prev,1);\\n        for(int i=1;i<n;i++){\\n            int idx=t[i].second;\\n            // cout<<prev<<\" \"<<idx<<\" \";\\n            if(prev>idx){\\n                ans+=(n-prev-1);\\n                ans+=(idx);\\n                int one=s.query(1,0,n-1,0,idx-1);\\n                int two=s.query(1,0,n-1,prev+1,n-1);\\n                ans-=(one+two);\\n            }\\n            else{\\n                ans+=(idx-prev-1);\\n                int bich=s.query(1,0,n-1,prev+1,idx-1);\\n                // cout<<bich<<\" \";\\n                ans-=bich;\\n            }\\n            s.update(1,0,n-1,idx,idx,1);\\n            prev=idx;\\n            // cout<<ans<<\"\\\\n\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3467249,
                "title": "how-it-can-work-simple-maths-time-o-n",
                "content": "# Explanation : \\nWe need to calculate the strictly increasing subsequence including the smallest element, to remove those many elements we will require n operations.\\n\\n3 | 4 | [-1]\\n\\nhere the subsequence is of size 1, it will take n (i.e. 3) operations to remove that subsequence,\\n\\nnew array will be,\\n\\n[3 | 4 ]\\n\\nwhich itself is the longest strictly increasing array including the smallest element to remove them we need n (i.e. 2) operations\\n\\nwe can easily get the subsequences with sorted array including the account of indices\\n\\n-1 | 3 | 4 ----> sorted elements\\n0 | 1 | 2 ----->indices\\n\\nwe need to calculate the continues subarray that is increasing in both conditions. We can take some pointers to achieve the same\\n\\n# Upvote if you like it \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long sum = nums.size(), count = 1;\\n        vector<pair<long long, long long>> ans;\\n        for(int i=0;i<nums.size();i++)\\n            ans.push_back({nums[i], i});\\n        sort(ans.begin(), ans.end());\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(ans[i].second > ans[i-1].second)\\n                count++;                \\n            else{\\n                sum += nums.size()-count;\\n                count++;                \\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long sum = nums.size(), count = 1;\\n        vector<pair<long long, long long>> ans;\\n        for(int i=0;i<nums.size();i++)\\n            ans.push_back({nums[i], i});\\n        sort(ans.begin(), ans.end());\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(ans[i].second > ans[i-1].second)\\n                count++;                \\n            else{\\n                sum += nums.size()-count;\\n                count++;                \\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467192,
                "title": "c-solution-with-segment-tree",
                "content": "# Intuition\\nSort and Segment Tree\\n\\n# Approach\\nFirst sort all the elements and remember the index. using that index we can use segment tree to find the total number to steps.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int getMid(int s, int e) { return s + (e -s)/2; }\\n \\nint getSumUtil(int *st, int ss, int se, int qs, int qe, int si)\\n{\\n    if (qs <= ss && qe >= se)\\n        return st[si];\\n \\n    if (se < qs || ss > qe)\\n        return 0;\\n \\n    int mid = getMid(ss, se);\\n    return getSumUtil(st, ss, mid, qs, qe, 2*si+1) +\\n        getSumUtil(st, mid+1, se, qs, qe, 2*si+2);\\n}\\n\\nvoid updateValueUtil(int *st, int ss, int se, int i, int diff, int si)\\n{\\n   \\n    if (i < ss || i > se)\\n        return;\\n \\n    \\n    st[si] = st[si] + diff;\\n    if (se != ss)\\n    {\\n        int mid = getMid(ss, se);\\n        updateValueUtil(st, ss, mid, i, diff, 2*si + 1);\\n        updateValueUtil(st, mid+1, se, i, diff, 2*si + 2);\\n    }\\n}\\n\\nvoid updateValue(int arr[], int *st, int n, int i, int new_val)\\n{\\n    if (i < 0 || i > n-1)\\n    {\\n        cout<<\"Invalid Input\";\\n        return;\\n    }\\n \\n    int diff = new_val - arr[i];\\n \\n    arr[i] = new_val;\\n \\n    updateValueUtil(st, 0, n-1, i, diff, 0);\\n}\\n \\nint getSum(int *st, int n, int qs, int qe)\\n{\\n    if (qs < 0 || qe > n-1 || qs > qe)\\n    {\\n        cout<<\"Invalid Input\";\\n        return -1;\\n    }\\n \\n    return getSumUtil(st, 0, n-1, qs, qe, 0);\\n}\\n \\nint constructSTUtil(int arr[], int ss, int se, int *st, int si)\\n{\\n\\n    if (ss == se)\\n    {\\n        st[si] = arr[ss];\\n        return arr[ss];\\n    }\\n \\n    int mid = getMid(ss, se);\\n    st[si] = constructSTUtil(arr, ss, mid, st, si*2+1) +\\n            constructSTUtil(arr, mid+1, se, st, si*2+2);\\n    return st[si];\\n}\\n \\nint *constructST(int arr[], int n)\\n{\\n    int x = (int)(ceil(log2(n)));\\n \\n    int max_size = 2*(int)pow(2, x) - 1;\\n \\n    int *st = new int[max_size];\\n \\n    constructSTUtil(arr, 0, n-1, st, 0);\\n \\n    return st;\\n}\\n    bool static sortcol( const vector<int>& v1,\\n               const vector<int>& v2 ) {\\n    return v1[0] < v2[0];\\n}\\n    \\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n      long long k = 0;\\n        int n = nums.size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            \\n            v.push_back({nums[i],i});\\n        }\\n        sort(v.begin(), v.end(), sortcol);\\n        \\n        int x[n];\\n        int y[n];\\n        for(int i=0;i<v.size();i++) {\\n            x[i] = v[i][1];\\n            y[i]=1;\\n            //cout<<v[i][1]<<endl;\\n        }\\n        int *st = constructST(y, n);\\n \\n    //updateValue(arr, st, n, 1, 10);\\n        //getSum(st, n, 1, 3)<<endl;\\n        int i=0;\\n        while(i<n){\\n            vector<int> d;\\n            while(i<n-1 && x[i+1]>x[i]){\\n                d.push_back(i++);\\n            }\\n            d.push_back(i);\\n            k+=getSum(st, n, 0, i);\\n            if(i<n-1){\\n                k+=getSum(st, n, i+1, n-1);\\n            }\\n            for(int j=0;j<d.size();j++) updateValue(y, st, n, d[j], 0);\\n            i++;\\n        }\\n        \\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int getMid(int s, int e) { return s + (e -s)/2; }\\n \\nint getSumUtil(int *st, int ss, int se, int qs, int qe, int si)\\n{\\n    if (qs <= ss && qe >= se)\\n        return st[si];\\n \\n    if (se < qs || ss > qe)\\n        return 0;\\n \\n    int mid = getMid(ss, se);\\n    return getSumUtil(st, ss, mid, qs, qe, 2*si+1) +\\n        getSumUtil(st, mid+1, se, qs, qe, 2*si+2);\\n}\\n\\nvoid updateValueUtil(int *st, int ss, int se, int i, int diff, int si)\\n{\\n   \\n    if (i < ss || i > se)\\n        return;\\n \\n    \\n    st[si] = st[si] + diff;\\n    if (se != ss)\\n    {\\n        int mid = getMid(ss, se);\\n        updateValueUtil(st, ss, mid, i, diff, 2*si + 1);\\n        updateValueUtil(st, mid+1, se, i, diff, 2*si + 2);\\n    }\\n}\\n\\nvoid updateValue(int arr[], int *st, int n, int i, int new_val)\\n{\\n    if (i < 0 || i > n-1)\\n    {\\n        cout<<\"Invalid Input\";\\n        return;\\n    }\\n \\n    int diff = new_val - arr[i];\\n \\n    arr[i] = new_val;\\n \\n    updateValueUtil(st, 0, n-1, i, diff, 0);\\n}\\n \\nint getSum(int *st, int n, int qs, int qe)\\n{\\n    if (qs < 0 || qe > n-1 || qs > qe)\\n    {\\n        cout<<\"Invalid Input\";\\n        return -1;\\n    }\\n \\n    return getSumUtil(st, 0, n-1, qs, qe, 0);\\n}\\n \\nint constructSTUtil(int arr[], int ss, int se, int *st, int si)\\n{\\n\\n    if (ss == se)\\n    {\\n        st[si] = arr[ss];\\n        return arr[ss];\\n    }\\n \\n    int mid = getMid(ss, se);\\n    st[si] = constructSTUtil(arr, ss, mid, st, si*2+1) +\\n            constructSTUtil(arr, mid+1, se, st, si*2+2);\\n    return st[si];\\n}\\n \\nint *constructST(int arr[], int n)\\n{\\n    int x = (int)(ceil(log2(n)));\\n \\n    int max_size = 2*(int)pow(2, x) - 1;\\n \\n    int *st = new int[max_size];\\n \\n    constructSTUtil(arr, 0, n-1, st, 0);\\n \\n    return st;\\n}\\n    bool static sortcol( const vector<int>& v1,\\n               const vector<int>& v2 ) {\\n    return v1[0] < v2[0];\\n}\\n    \\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n      long long k = 0;\\n        int n = nums.size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            \\n            v.push_back({nums[i],i});\\n        }\\n        sort(v.begin(), v.end(), sortcol);\\n        \\n        int x[n];\\n        int y[n];\\n        for(int i=0;i<v.size();i++) {\\n            x[i] = v[i][1];\\n            y[i]=1;\\n            //cout<<v[i][1]<<endl;\\n        }\\n        int *st = constructST(y, n);\\n \\n    //updateValue(arr, st, n, 1, 10);\\n        //getSum(st, n, 1, 3)<<endl;\\n        int i=0;\\n        while(i<n){\\n            vector<int> d;\\n            while(i<n-1 && x[i+1]>x[i]){\\n                d.push_back(i++);\\n            }\\n            d.push_back(i);\\n            k+=getSum(st, n, 0, i);\\n            if(i<n-1){\\n                k+=getSum(st, n, i+1, n-1);\\n            }\\n            for(int j=0;j<d.size();j++) updateValue(y, st, n, d[j], 0);\\n            i++;\\n        }\\n        \\n        return k;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3467168,
                "title": "best-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        Node root = null;\\n\\t\\t\\tMap<Integer, Node> map = new TreeMap<>();\\n\\t\\t\\tfor(int v : nums){\\n\\t\\t\\t\\tNode node = new Node(v);\\n\\t\\t\\t\\tmap.put(v, node);\\n\\t\\t\\t\\troot = merge(root, node);\\n\\t\\t\\t}\\n\\t\\t\\tlong ans = nums.length;\\n\\t\\t\\tfor(int k : map.keySet()){\\n\\t\\t\\t\\tNode node = map.get(k);\\n\\t\\t\\t\\tint index = index(node);\\n\\t\\t\\t\\tans += index;\\n\\t\\t\\t\\tNode[] lm_r = split(root, index+1);\\n\\t\\t\\t\\tNode[] l_m = split(lm_r[0], index);\\n\\t\\t\\t\\troot = merge(lm_r[1], l_m[0]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tpublic Random gen = new Random();\\n\\t\\tpublic final int mod = 998244353;\\n\\n\\t\\tpublic class Node\\n\\t\\t{\\n\\t\\t\\tpublic long priority;\\n\\t\\t\\tpublic Node L, R, P;\\n\\n\\t\\t\\tpublic long v; // value\\n\\t\\t\\tpublic long sum;\\n\\t\\t\\tpublic int size;\\n\\n\\t\\t\\tpublic Node(int v)\\n\\t\\t\\t{\\n\\t\\t\\t\\tthis.v = v;\\n\\t\\t\\t\\tpriority = gen.nextLong();\\n\\t\\t\\t\\tupdate();\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic void update()\\n\\t\\t\\t{\\n\\t\\t\\t\\tsize = size(L) + size(R) + 1;\\n\\t\\t\\t\\tsum = v + sum(L) + sum(R);\\n\\t\\t\\t\\t// TODO\\n\\t\\t\\t}\\n\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic String toString() {\\n\\t\\t\\t\\treturn \"Node{\" +\\n\\t\\t\\t\\t\\t\\t\"v=\" + v +\\n\\t\\t\\t\\t\\t\\t\", sum=\" + sum +\\n\\t\\t\\t\\t\\t\\t\", size=\" + size +\\n\\t\\t\\t\\t\\t\\t\\'}\\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic void propagate(Node x)\\n\\t\\t{\\n\\t\\t\\tfor(;x != null;x = x.P)x.update();\\n\\t\\t}\\n\\n\\t\\tpublic Node disconnect(Node a)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return null;\\n\\t\\t\\ta.L = a.R = a.P = null;\\n\\t\\t\\ta.update();\\n\\t\\t\\treturn a;\\n\\t\\t}\\n\\n\\t\\tpublic int size(Node x){ return x == null ? 0 : x.size;}\\n\\t\\tpublic long sum(Node x){ return x == null ? 0 : x.sum;}\\n\\n\\t\\tpublic void setParent(Node a, Node par)\\n\\t\\t{\\n\\t\\t\\tif(a != null)a.P = par;\\n\\t\\t}\\n\\n\\t\\tpublic Node merge(Node a, Node b, Node... c)\\n\\t\\t{\\n\\t\\t\\tNode x = merge(a, b);\\n\\t\\t\\tfor(Node n : c)x = merge(x, n);\\n\\t\\t\\treturn x;\\n\\t\\t}\\n\\n\\t\\tpublic Node merge(Node a, Node b)\\n\\t\\t{\\n\\t\\t\\tif(b == null)return a;\\n\\t\\t\\tif(a == null)return b;\\n\\t\\t\\tif(a.priority > b.priority){\\n\\t\\t\\t\\tsetParent(a.R, null);\\n\\t\\t\\t\\tsetParent(b, null);\\n\\t\\t\\t\\ta.R = merge(a.R, b);\\n\\t\\t\\t\\tsetParent(a.R, a);\\n\\t\\t\\t\\ta.update();\\n\\t\\t\\t\\treturn a;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tsetParent(a, null);\\n\\t\\t\\t\\tsetParent(b.L, null);\\n\\t\\t\\t\\tb.L = merge(a, b.L);\\n\\t\\t\\t\\tsetParent(b.L, b);\\n\\t\\t\\t\\tb.update();\\n\\t\\t\\t\\treturn b;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic Node[] split(Node x)\\n\\t\\t{\\n\\t\\t\\tif(x == null)return new Node[]{null, null};\\n\\t\\t\\tif(x.L != null)x.L.P = null;\\n\\t\\t\\tNode[] sp = new Node[]{x.L, x};\\n\\t\\t\\tx.L = null;\\n\\t\\t\\tx.update();\\n\\t\\t\\twhile(x.P != null){\\n\\t\\t\\t\\tNode p = x.P;\\n\\t\\t\\t\\tx.P = null;\\n\\t\\t\\t\\tif(x == p.L){\\n\\t\\t\\t\\t\\tp.L = sp[1];\\n\\t\\t\\t\\t\\tif(sp[1] != null)sp[1].P = p;\\n\\t\\t\\t\\t\\tsp[1] = p;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tp.R = sp[0];\\n\\t\\t\\t\\t\\tif(sp[0] != null)sp[0].P = p;\\n\\t\\t\\t\\t\\tsp[0] = p;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tp.update();\\n\\t\\t\\t\\tx = p;\\n\\t\\t\\t}\\n\\t\\t\\treturn sp;\\n\\t\\t}\\n\\n\\t\\t// [0,K),[K,N)\\n\\t\\tpublic Node[] split(Node a, int K)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return new Node[]{null, null};\\n\\t\\t\\tif(K <= size(a.L)){\\n\\t\\t\\t\\tsetParent(a.L, null);\\n\\t\\t\\t\\tNode[] s = split(a.L, K);\\n\\t\\t\\t\\ta.L = s[1];\\n\\t\\t\\t\\tsetParent(a.L, a);\\n\\t\\t\\t\\ta.update();\\n\\t\\t\\t\\ts[1] = a;\\n\\t\\t\\t\\treturn s;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tsetParent(a.R, null);\\n\\t\\t\\t\\tNode[] s = split(a.R, K- size(a.L)-1);\\n\\t\\t\\t\\ta.R = s[0];\\n\\t\\t\\t\\tsetParent(a.R, a);\\n\\t\\t\\t\\ta.update();\\n\\t\\t\\t\\ts[0] = a;\\n\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic Node insertb(Node root, Node x)\\n\\t\\t{\\n\\t\\t\\tassert x != null;\\n\\t\\t\\tint ind = lowerBound(root, x.v);\\n\\t\\t\\treturn insert(root, ind, x);\\n\\t\\t}\\n\\n\\t\\tpublic Node insert(Node root, int K, Node x)\\n\\t\\t{\\n\\t\\t\\tassert K >= 0;\\n\\t\\t\\tassert K <= size(root);\\n\\t\\t\\tassert size(x) == 1;\\n\\t\\t\\tNode[] sp = split(root, K);\\n\\t\\t\\treturn merge(sp[0], x, sp[1]);\\n\\t\\t}\\n\\n\\t\\tpublic Node delete(Node root, Node x)\\n\\t\\t{\\n\\t\\t\\treturn x == null ? root : delete(root, index(x));\\n\\t\\t}\\n\\n\\t\\tpublic Node delete(Node root, int K)\\n\\t\\t{\\n\\t\\t\\tassert K >= 0;\\n\\t\\t\\tassert K < size(root);\\n\\t\\t\\tNode[] lm_r = split(root, K+1);\\n\\t\\t\\tNode[] l_m = split(lm_r[0], K);\\n\\t\\t\\treturn merge(l_m[0], lm_r[1]);\\n\\t\\t}\\n\\n\\t\\tpublic Node get(Node a, int K)\\n\\t\\t{\\n\\t\\t\\tassert K >= 0;\\n\\t\\t\\tassert K < size(a);\\n\\t\\t\\twhile(a != null){\\n\\t\\t\\t\\tif(K < size(a.L)){\\n\\t\\t\\t\\t\\ta = a.L;\\n\\t\\t\\t\\t}else if(K == size(a.L)){\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tK = K - size(a.L)-1;\\n\\t\\t\\t\\t\\ta = a.R;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn a;\\n\\t\\t}\\n\\n\\t\\tpublic int index(Node a)\\n\\t\\t{\\n\\t\\t\\tassert a != null;\\n\\t\\t\\tint ind = size(a.L);\\n\\t\\t\\twhile(a != null){\\n\\t\\t\\t\\tNode par = a.P;\\n\\t\\t\\t\\tif(par != null && par.R == a){\\n\\t\\t\\t\\t\\tind += size(par.L) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ta = par;\\n\\t\\t\\t}\\n\\t\\t\\treturn ind;\\n\\t\\t}\\n\\n\\t\\tpublic Node mergeTechnically(Node x, Node y)\\n\\t\\t{\\n\\t\\t\\tif(size(x) > size(y)){\\n\\t\\t\\t\\tNode d = x; x = y; y = d;\\n\\t\\t\\t}\\n\\t\\t\\t// |x|<=|y|\\n\\t\\t\\tfor(Node cur : nodesdfs(x))y = insertb(y, disconnect(cur));\\n\\t\\t\\treturn y;\\n\\t\\t}\\n\\n\\t\\tpublic int lowerBound(Node a, long q)\\n\\t\\t{\\n\\t\\t\\tint lcount = 0;\\n\\t\\t\\twhile(a != null){\\n\\t\\t\\t\\tif(a.v >= q){\\n\\t\\t\\t\\t\\ta = a.L;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tlcount += size(a.L) + 1;\\n\\t\\t\\t\\t\\ta = a.R;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn lcount;\\n\\t\\t}\\n\\n\\t\\tpublic Node next(Node x)\\n\\t\\t{\\n\\t\\t\\tif(x == null)return null;\\n\\t\\t\\tif(x.R != null){\\n\\t\\t\\t\\tx = x.R;\\n\\t\\t\\t\\twhile(x.L != null)x = x.L;\\n\\t\\t\\t\\treturn x;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\twhile(true){\\n\\t\\t\\t\\t\\tNode p = x.P;\\n\\t\\t\\t\\t\\tif(p == null)return null;\\n\\t\\t\\t\\t\\tif(p.L == x)return p;\\n\\t\\t\\t\\t\\tx = p;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic Node prev(Node x)\\n\\t\\t{\\n\\t\\t\\tif(x == null)return null;\\n\\t\\t\\tif(x.L != null){\\n\\t\\t\\t\\tx = x.L;\\n\\t\\t\\t\\twhile(x.R != null)x = x.R;\\n\\t\\t\\t\\treturn x;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\twhile(true){\\n\\t\\t\\t\\t\\tNode p = x.P;\\n\\t\\t\\t\\t\\tif(p == null)return null;\\n\\t\\t\\t\\t\\tif(p.R == x)return p;\\n\\t\\t\\t\\t\\tx = p;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic Node build(Node[] a){return build(a, 0, a.length);}\\n\\t\\tpublic Node build(Node[] a, int l, int r)\\n\\t\\t{\\n\\t\\t\\tif(l >= r)return null;\\n\\n\\t\\t\\tint h = l+r>>1;\\n\\t\\t\\tNode root = a[h];\\n\\n\\t\\t\\tNode L = build(a, l, h);\\n\\t\\t\\troot.L = L;\\n\\t\\t\\tif(L != null)L.P = root;\\n\\n\\t\\t\\tNode R = build(a, h+1, r);\\n\\t\\t\\troot.R = R;\\n\\t\\t\\tif(R != null)R.P = root;\\n\\n\\t\\t\\troot.update();\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\n\\n\\t\\tpublic Node[] nodes(Node a) { return nodes(a, new Node[size(a)], 0, size(a)); }\\n\\t\\tpublic Node[] nodes(Node a, Node[] ns, int L, int R)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return ns;\\n\\t\\t\\tnodes(a.L, ns, L, L+ size(a.L));\\n\\t\\t\\tns[L+ size(a.L)] = a;\\n\\t\\t\\tnodes(a.R, ns, R- size(a.R), R);\\n\\t\\t\\treturn ns;\\n\\t\\t}\\n\\n\\t\\t// faster than nodes but inconsistent\\n\\t\\tpublic Node[] nodesdfs(Node a) { return nodesdfs(a, new Node[a.size], new int[]{0}); }\\n\\t\\tpublic Node[] nodesdfs(Node a, Node[] ns, int[] pos)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return ns;\\n\\t\\t\\tns[pos[0]++] = a;\\n\\t\\t\\tnodesdfs(a.L, ns, pos);\\n\\t\\t\\tnodesdfs(a.R, ns, pos);\\n\\t\\t\\treturn ns;\\n\\t\\t}\\n\\n\\t\\tpublic String toString(Node a, String indent)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return \"\";\\n\\t\\t\\treturn toString(a.L, indent + \"  \") +\\n\\t\\t\\t\\t\\tindent + a + \"\\\\n\" +\\n\\t\\t\\t\\t\\ttoString(a.R, indent + \"  \");\\n\\t\\t}\\n\\n\\t\\tpublic Node operate(Node root, int l, int r, Consumer<Node> o)\\n\\t\\t{\\n\\t\\t\\tNode[] lm_r = split(root, r);\\n\\t\\t\\tNode[] l_m = split(lm_r[0], l);\\n\\t\\t\\to.accept(l_m[1]);\\n\\t\\t\\tl_m[1].update();\\n\\t\\t\\treturn merge(l_m[0], l_m[1], lm_r[1]);\\n}\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        Node root = null;\\n\\t\\t\\tMap<Integer, Node> map = new TreeMap<>();\\n\\t\\t\\tfor(int v : nums){\\n\\t\\t\\t\\tNode node = new Node(v);\\n\\t\\t\\t\\tmap.put(v, node);\\n\\t\\t\\t\\troot = merge(root, node);\\n\\t\\t\\t}\\n\\t\\t\\tlong ans = nums.length;\\n\\t\\t\\tfor(int k : map.keySet()){\\n\\t\\t\\t\\tNode node = map.get(k);\\n\\t\\t\\t\\tint index = index(node);\\n\\t\\t\\t\\tans += index;\\n\\t\\t\\t\\tNode[] lm_r = split(root, index+1);\\n\\t\\t\\t\\tNode[] l_m = split(lm_r[0], index);\\n\\t\\t\\t\\troot = merge(lm_r[1], l_m[0]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tpublic Random gen = new Random();\\n\\t\\tpublic final int mod = 998244353;\\n\\n\\t\\tpublic class Node\\n\\t\\t{\\n\\t\\t\\tpublic long priority;\\n\\t\\t\\tpublic Node L, R, P;\\n\\n\\t\\t\\tpublic long v; // value\\n\\t\\t\\tpublic long sum;\\n\\t\\t\\tpublic int size;\\n\\n\\t\\t\\tpublic Node(int v)\\n\\t\\t\\t{\\n\\t\\t\\t\\tthis.v = v;\\n\\t\\t\\t\\tpriority = gen.nextLong();\\n\\t\\t\\t\\tupdate();\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic void update()\\n\\t\\t\\t{\\n\\t\\t\\t\\tsize = size(L) + size(R) + 1;\\n\\t\\t\\t\\tsum = v + sum(L) + sum(R);\\n\\t\\t\\t\\t// TODO\\n\\t\\t\\t}\\n\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic String toString() {\\n\\t\\t\\t\\treturn \"Node{\" +\\n\\t\\t\\t\\t\\t\\t\"v=\" + v +\\n\\t\\t\\t\\t\\t\\t\", sum=\" + sum +\\n\\t\\t\\t\\t\\t\\t\", size=\" + size +\\n\\t\\t\\t\\t\\t\\t\\'}\\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic void propagate(Node x)\\n\\t\\t{\\n\\t\\t\\tfor(;x != null;x = x.P)x.update();\\n\\t\\t}\\n\\n\\t\\tpublic Node disconnect(Node a)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return null;\\n\\t\\t\\ta.L = a.R = a.P = null;\\n\\t\\t\\ta.update();\\n\\t\\t\\treturn a;\\n\\t\\t}\\n\\n\\t\\tpublic int size(Node x){ return x == null ? 0 : x.size;}\\n\\t\\tpublic long sum(Node x){ return x == null ? 0 : x.sum;}\\n\\n\\t\\tpublic void setParent(Node a, Node par)\\n\\t\\t{\\n\\t\\t\\tif(a != null)a.P = par;\\n\\t\\t}\\n\\n\\t\\tpublic Node merge(Node a, Node b, Node... c)\\n\\t\\t{\\n\\t\\t\\tNode x = merge(a, b);\\n\\t\\t\\tfor(Node n : c)x = merge(x, n);\\n\\t\\t\\treturn x;\\n\\t\\t}\\n\\n\\t\\tpublic Node merge(Node a, Node b)\\n\\t\\t{\\n\\t\\t\\tif(b == null)return a;\\n\\t\\t\\tif(a == null)return b;\\n\\t\\t\\tif(a.priority > b.priority){\\n\\t\\t\\t\\tsetParent(a.R, null);\\n\\t\\t\\t\\tsetParent(b, null);\\n\\t\\t\\t\\ta.R = merge(a.R, b);\\n\\t\\t\\t\\tsetParent(a.R, a);\\n\\t\\t\\t\\ta.update();\\n\\t\\t\\t\\treturn a;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tsetParent(a, null);\\n\\t\\t\\t\\tsetParent(b.L, null);\\n\\t\\t\\t\\tb.L = merge(a, b.L);\\n\\t\\t\\t\\tsetParent(b.L, b);\\n\\t\\t\\t\\tb.update();\\n\\t\\t\\t\\treturn b;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic Node[] split(Node x)\\n\\t\\t{\\n\\t\\t\\tif(x == null)return new Node[]{null, null};\\n\\t\\t\\tif(x.L != null)x.L.P = null;\\n\\t\\t\\tNode[] sp = new Node[]{x.L, x};\\n\\t\\t\\tx.L = null;\\n\\t\\t\\tx.update();\\n\\t\\t\\twhile(x.P != null){\\n\\t\\t\\t\\tNode p = x.P;\\n\\t\\t\\t\\tx.P = null;\\n\\t\\t\\t\\tif(x == p.L){\\n\\t\\t\\t\\t\\tp.L = sp[1];\\n\\t\\t\\t\\t\\tif(sp[1] != null)sp[1].P = p;\\n\\t\\t\\t\\t\\tsp[1] = p;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tp.R = sp[0];\\n\\t\\t\\t\\t\\tif(sp[0] != null)sp[0].P = p;\\n\\t\\t\\t\\t\\tsp[0] = p;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tp.update();\\n\\t\\t\\t\\tx = p;\\n\\t\\t\\t}\\n\\t\\t\\treturn sp;\\n\\t\\t}\\n\\n\\t\\t// [0,K),[K,N)\\n\\t\\tpublic Node[] split(Node a, int K)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return new Node[]{null, null};\\n\\t\\t\\tif(K <= size(a.L)){\\n\\t\\t\\t\\tsetParent(a.L, null);\\n\\t\\t\\t\\tNode[] s = split(a.L, K);\\n\\t\\t\\t\\ta.L = s[1];\\n\\t\\t\\t\\tsetParent(a.L, a);\\n\\t\\t\\t\\ta.update();\\n\\t\\t\\t\\ts[1] = a;\\n\\t\\t\\t\\treturn s;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tsetParent(a.R, null);\\n\\t\\t\\t\\tNode[] s = split(a.R, K- size(a.L)-1);\\n\\t\\t\\t\\ta.R = s[0];\\n\\t\\t\\t\\tsetParent(a.R, a);\\n\\t\\t\\t\\ta.update();\\n\\t\\t\\t\\ts[0] = a;\\n\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic Node insertb(Node root, Node x)\\n\\t\\t{\\n\\t\\t\\tassert x != null;\\n\\t\\t\\tint ind = lowerBound(root, x.v);\\n\\t\\t\\treturn insert(root, ind, x);\\n\\t\\t}\\n\\n\\t\\tpublic Node insert(Node root, int K, Node x)\\n\\t\\t{\\n\\t\\t\\tassert K >= 0;\\n\\t\\t\\tassert K <= size(root);\\n\\t\\t\\tassert size(x) == 1;\\n\\t\\t\\tNode[] sp = split(root, K);\\n\\t\\t\\treturn merge(sp[0], x, sp[1]);\\n\\t\\t}\\n\\n\\t\\tpublic Node delete(Node root, Node x)\\n\\t\\t{\\n\\t\\t\\treturn x == null ? root : delete(root, index(x));\\n\\t\\t}\\n\\n\\t\\tpublic Node delete(Node root, int K)\\n\\t\\t{\\n\\t\\t\\tassert K >= 0;\\n\\t\\t\\tassert K < size(root);\\n\\t\\t\\tNode[] lm_r = split(root, K+1);\\n\\t\\t\\tNode[] l_m = split(lm_r[0], K);\\n\\t\\t\\treturn merge(l_m[0], lm_r[1]);\\n\\t\\t}\\n\\n\\t\\tpublic Node get(Node a, int K)\\n\\t\\t{\\n\\t\\t\\tassert K >= 0;\\n\\t\\t\\tassert K < size(a);\\n\\t\\t\\twhile(a != null){\\n\\t\\t\\t\\tif(K < size(a.L)){\\n\\t\\t\\t\\t\\ta = a.L;\\n\\t\\t\\t\\t}else if(K == size(a.L)){\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tK = K - size(a.L)-1;\\n\\t\\t\\t\\t\\ta = a.R;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn a;\\n\\t\\t}\\n\\n\\t\\tpublic int index(Node a)\\n\\t\\t{\\n\\t\\t\\tassert a != null;\\n\\t\\t\\tint ind = size(a.L);\\n\\t\\t\\twhile(a != null){\\n\\t\\t\\t\\tNode par = a.P;\\n\\t\\t\\t\\tif(par != null && par.R == a){\\n\\t\\t\\t\\t\\tind += size(par.L) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ta = par;\\n\\t\\t\\t}\\n\\t\\t\\treturn ind;\\n\\t\\t}\\n\\n\\t\\tpublic Node mergeTechnically(Node x, Node y)\\n\\t\\t{\\n\\t\\t\\tif(size(x) > size(y)){\\n\\t\\t\\t\\tNode d = x; x = y; y = d;\\n\\t\\t\\t}\\n\\t\\t\\t// |x|<=|y|\\n\\t\\t\\tfor(Node cur : nodesdfs(x))y = insertb(y, disconnect(cur));\\n\\t\\t\\treturn y;\\n\\t\\t}\\n\\n\\t\\tpublic int lowerBound(Node a, long q)\\n\\t\\t{\\n\\t\\t\\tint lcount = 0;\\n\\t\\t\\twhile(a != null){\\n\\t\\t\\t\\tif(a.v >= q){\\n\\t\\t\\t\\t\\ta = a.L;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tlcount += size(a.L) + 1;\\n\\t\\t\\t\\t\\ta = a.R;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn lcount;\\n\\t\\t}\\n\\n\\t\\tpublic Node next(Node x)\\n\\t\\t{\\n\\t\\t\\tif(x == null)return null;\\n\\t\\t\\tif(x.R != null){\\n\\t\\t\\t\\tx = x.R;\\n\\t\\t\\t\\twhile(x.L != null)x = x.L;\\n\\t\\t\\t\\treturn x;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\twhile(true){\\n\\t\\t\\t\\t\\tNode p = x.P;\\n\\t\\t\\t\\t\\tif(p == null)return null;\\n\\t\\t\\t\\t\\tif(p.L == x)return p;\\n\\t\\t\\t\\t\\tx = p;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic Node prev(Node x)\\n\\t\\t{\\n\\t\\t\\tif(x == null)return null;\\n\\t\\t\\tif(x.L != null){\\n\\t\\t\\t\\tx = x.L;\\n\\t\\t\\t\\twhile(x.R != null)x = x.R;\\n\\t\\t\\t\\treturn x;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\twhile(true){\\n\\t\\t\\t\\t\\tNode p = x.P;\\n\\t\\t\\t\\t\\tif(p == null)return null;\\n\\t\\t\\t\\t\\tif(p.R == x)return p;\\n\\t\\t\\t\\t\\tx = p;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic Node build(Node[] a){return build(a, 0, a.length);}\\n\\t\\tpublic Node build(Node[] a, int l, int r)\\n\\t\\t{\\n\\t\\t\\tif(l >= r)return null;\\n\\n\\t\\t\\tint h = l+r>>1;\\n\\t\\t\\tNode root = a[h];\\n\\n\\t\\t\\tNode L = build(a, l, h);\\n\\t\\t\\troot.L = L;\\n\\t\\t\\tif(L != null)L.P = root;\\n\\n\\t\\t\\tNode R = build(a, h+1, r);\\n\\t\\t\\troot.R = R;\\n\\t\\t\\tif(R != null)R.P = root;\\n\\n\\t\\t\\troot.update();\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\n\\n\\t\\tpublic Node[] nodes(Node a) { return nodes(a, new Node[size(a)], 0, size(a)); }\\n\\t\\tpublic Node[] nodes(Node a, Node[] ns, int L, int R)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return ns;\\n\\t\\t\\tnodes(a.L, ns, L, L+ size(a.L));\\n\\t\\t\\tns[L+ size(a.L)] = a;\\n\\t\\t\\tnodes(a.R, ns, R- size(a.R), R);\\n\\t\\t\\treturn ns;\\n\\t\\t}\\n\\n\\t\\t// faster than nodes but inconsistent\\n\\t\\tpublic Node[] nodesdfs(Node a) { return nodesdfs(a, new Node[a.size], new int[]{0}); }\\n\\t\\tpublic Node[] nodesdfs(Node a, Node[] ns, int[] pos)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return ns;\\n\\t\\t\\tns[pos[0]++] = a;\\n\\t\\t\\tnodesdfs(a.L, ns, pos);\\n\\t\\t\\tnodesdfs(a.R, ns, pos);\\n\\t\\t\\treturn ns;\\n\\t\\t}\\n\\n\\t\\tpublic String toString(Node a, String indent)\\n\\t\\t{\\n\\t\\t\\tif(a == null)return \"\";\\n\\t\\t\\treturn toString(a.L, indent + \"  \") +\\n\\t\\t\\t\\t\\tindent + a + \"\\\\n\" +\\n\\t\\t\\t\\t\\ttoString(a.R, indent + \"  \");\\n\\t\\t}\\n\\n\\t\\tpublic Node operate(Node root, int l, int r, Consumer<Node> o)\\n\\t\\t{\\n\\t\\t\\tNode[] lm_r = split(root, r);\\n\\t\\t\\tNode[] l_m = split(lm_r[0], l);\\n\\t\\t\\to.accept(l_m[1]);\\n\\t\\t\\tl_m[1].update();\\n\\t\\t\\treturn merge(l_m[0], l_m[1], lm_r[1]);\\n}\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467129,
                "title": "c-sorting-fenwick-tree",
                "content": "# Code\\n```\\nclass Solution {\\n    int query(vector<int> &BIT, int i) {\\n        int sum = 0; i++;\\n        while(i > 0) {\\n            sum += BIT[i];\\n            i = i - (i & -i);\\n        }\\n        return sum;\\n    }\\n    void update(vector<int> &BIT, int i, int val) {\\n        i++;\\n        while(i < BIT.size()) {\\n            BIT[i] += val;\\n            i = i + (i & -i);\\n        }\\n    }\\n    void build(vector<int> &BIT, int n) {\\n        for(int i = 0; i < n; i++) {\\n            update(BIT, i, 1);\\n        }\\n    }\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> index(n);\\n        iota(index.begin(), index.end(), 0);\\n        sort(index.begin(), index.end(), [&](int i, int j) {\\n            return nums[i] < nums[j];\\n        });\\n        vector<int> BIT(n + 1); \\n        build(BIT, n);\\n        long long ans = index[0] + 1;\\n        update(BIT, index[0], -1);\\n        for(int i = 1; i < n; i++) {\\n            if(index[i] > index[i - 1]) {\\n                ans += query(BIT, index[i]) - query(BIT, index[i - 1]);\\n            } else {\\n                ans += query(BIT, n - 1) - query(BIT, index[i - 1]) + query(BIT, index[i]);\\n            }\\n            update(BIT, index[i], -1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    int query(vector<int> &BIT, int i) {\\n        int sum = 0; i++;\\n        while(i > 0) {\\n            sum += BIT[i];\\n            i = i - (i & -i);\\n        }\\n        return sum;\\n    }\\n    void update(vector<int> &BIT, int i, int val) {\\n        i++;\\n        while(i < BIT.size()) {\\n            BIT[i] += val;\\n            i = i + (i & -i);\\n        }\\n    }\\n    void build(vector<int> &BIT, int n) {\\n        for(int i = 0; i < n; i++) {\\n            update(BIT, i, 1);\\n        }\\n    }\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> index(n);\\n        iota(index.begin(), index.end(), 0);\\n        sort(index.begin(), index.end(), [&](int i, int j) {\\n            return nums[i] < nums[j];\\n        });\\n        vector<int> BIT(n + 1); \\n        build(BIT, n);\\n        long long ans = index[0] + 1;\\n        update(BIT, index[0], -1);\\n        for(int i = 1; i < n; i++) {\\n            if(index[i] > index[i - 1]) {\\n                ans += query(BIT, index[i]) - query(BIT, index[i - 1]);\\n            } else {\\n                ans += query(BIT, n - 1) - query(BIT, index[i - 1]) + query(BIT, index[i]);\\n            }\\n            update(BIT, index[i], -1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467113,
                "title": "o-n-log-n-sorting-with-hashmap-rust",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn count_operations_to_empty_array(mut nums: Vec<i32>) -> i64 {\\n        let mut map = HashMap::new();\\n        let n = nums.len() as i64;\\n        let mut ans = n;\\n        \\n        for (i, &num) in nums.iter().enumerate() {\\n            map.insert(num, i);\\n        }\\n        \\n        nums.sort_unstable();\\n        for i in 1..nums.len() {\\n            if map[&nums[i]] < map[&nums[i - 1]] { \\n                ans += n - i as i64;\\n            }\\n        }\\n        \\n        ans\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn count_operations_to_empty_array(mut nums: Vec<i32>) -> i64 {\\n        let mut map = HashMap::new();\\n        let n = nums.len() as i64;\\n        let mut ans = n;\\n        \\n        for (i, &num) in nums.iter().enumerate() {\\n            map.insert(num, i);\\n        }\\n        \\n        nums.sort_unstable();\\n        for i in 1..nums.len() {\\n            if map[&nums[i]] < map[&nums[i - 1]] { \\n                ans += n - i as i64;\\n            }\\n        }\\n        \\n        ans\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467109,
                "title": "golang-sorting-o-nlogn",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n*logn)$$ - Sorting the slice\\n\\n- Space complexity: $$O(n)$$ \\n\\n\\n# Code\\n```\\nfunc countOperationsToEmptyArray(nums []int) int64 {\\n    n := len(nums)\\n    indexed := make([][2]int, n)\\n    for i := range nums {\\n        indexed[i][0] = i+1\\n        indexed[i][1] = nums[i]\\n    }\\n    sort.Slice(indexed, func(i, j int) bool { return indexed[i][1] < indexed[j][1] })\\n    \\n    ans := int64(n)\\n    for i := 1; i < n; i++ {\\n        if indexed[i][0] < indexed[i-1][0] {\\n            ans += int64(n - i)\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nfunc countOperationsToEmptyArray(nums []int) int64 {\\n    n := len(nums)\\n    indexed := make([][2]int, n)\\n    for i := range nums {\\n        indexed[i][0] = i+1\\n        indexed[i][1] = nums[i]\\n    }\\n    sort.Slice(indexed, func(i, j int) bool { return indexed[i][1] < indexed[j][1] })\\n    \\n    ans := int64(n)\\n    for i := 1; i < n; i++ {\\n        if indexed[i][0] < indexed[i-1][0] {\\n            ans += int64(n - i)\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467095,
                "title": "disjoint-set-o-nlogn-tc-beats-90-4-in-time-and-77-in-space",
                "content": "# Intuition\\nDisjoint set AND union\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n+n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass disjointSet{\\n    public:\\n        vector<long long int>set;\\n    \\n    disjointSet(int n){\\n        set.resize(n,-1);\\n    }\\n    \\n    int find(long long int i ){\\n        if(set[i] < 0)\\n            return i;\\n        return set[i] = find(set[i]);\\n    }\\n    \\n    void setUnion(int i , int j){\\n        int p1 = find(i), p2 = find(j);\\n        \\n        if(set[p1] < set[p2]){\\n            set[p1] += set[p2];\\n            set[p2] = p1;\\n        }else{\\n            set[p2] += set[p1];\\n            set[p1] = p2;\\n        }\\n    }\\n    \\n    long long int getRes(){\\n        long long int res = 0,si = set.size();\\n        for(int i = 0;i<set.size();i++){\\n            if(set[i] < 0){\\n                res += si;\\n                si += set[i];\\n            }   \\n        }\\n        return res;\\n    }\\n    \\n};\\n\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long int res = 0;\\n        int n = nums.size();\\n        priority_queue<pair<int,int> ,vector<pair<int,int>> , greater<pair<int,int>>>pq;\\n        vector<int>rank(n);\\n        for(int i = 0;i<n;i++){\\n            pq.push({nums[i],i});\\n        }\\n        int i = 0;\\n        while(!pq.empty()){\\n            rank[pq.top().second] = i;\\n            pq.pop();\\n            i++;\\n        }\\n        \\n        vector<int>vis(n,0);\\n        disjointSet ds(n);\\n        for(int i = 0;i<n;i++){\\n            vis[rank[i]]++;\\n            if(rank[i] != 0 && vis[rank[i] - 1]){\\n                ds.setUnion(rank[i] , rank[i] - 1);\\n            }\\n        }\\n        \\n        res = ds.getRes();\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass disjointSet{\\n    public:\\n        vector<long long int>set;\\n    \\n    disjointSet(int n){\\n        set.resize(n,-1);\\n    }\\n    \\n    int find(long long int i ){\\n        if(set[i] < 0)\\n            return i;\\n        return set[i] = find(set[i]);\\n    }\\n    \\n    void setUnion(int i , int j){\\n        int p1 = find(i), p2 = find(j);\\n        \\n        if(set[p1] < set[p2]){\\n            set[p1] += set[p2];\\n            set[p2] = p1;\\n        }else{\\n            set[p2] += set[p1];\\n            set[p1] = p2;\\n        }\\n    }\\n    \\n    long long int getRes(){\\n        long long int res = 0,si = set.size();\\n        for(int i = 0;i<set.size();i++){\\n            if(set[i] < 0){\\n                res += si;\\n                si += set[i];\\n            }   \\n        }\\n        return res;\\n    }\\n    \\n};\\n\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long int res = 0;\\n        int n = nums.size();\\n        priority_queue<pair<int,int> ,vector<pair<int,int>> , greater<pair<int,int>>>pq;\\n        vector<int>rank(n);\\n        for(int i = 0;i<n;i++){\\n            pq.push({nums[i],i});\\n        }\\n        int i = 0;\\n        while(!pq.empty()){\\n            rank[pq.top().second] = i;\\n            pq.pop();\\n            i++;\\n        }\\n        \\n        vector<int>vis(n,0);\\n        disjointSet ds(n);\\n        for(int i = 0;i<n;i++){\\n            vis[rank[i]]++;\\n            if(rank[i] != 0 && vis[rank[i] - 1]){\\n                ds.setUnion(rank[i] , rank[i] - 1);\\n            }\\n        }\\n        \\n        res = ds.getRes();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467052,
                "title": "go-python-o-n-log-n-time-o-n-space",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc countOperationsToEmptyArray(nums []int) int64 {\\n    pos :=  make(map[int]int)\\n    for i,item := range(nums){\\n        pos[item] = i\\n    }\\n    answer := 0\\n    n := len(nums)\\n    idx := -math.MaxInt\\n    sort.Ints(nums)\\n    for k,a := range(nums){\\n        if pos[a] < idx{\\n            answer += n - k\\n        }\\n        idx = pos[a]\\n        answer++\\n    }\\n    return int64(answer)\\n}\\n```\\n```python []\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        pos = {item: i for i,item in enumerate(nums)}\\n        answer = 0\\n        n = len(nums)\\n        idx = float(\"-inf\")\\n        nums.sort()\\n        for k,a in enumerate(nums):\\n            if pos[a] < idx:\\n                answer += n - k\\n            idx = pos[a]\\n            anwer+=1\\n        return answer\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Array",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```golang []\\nfunc countOperationsToEmptyArray(nums []int) int64 {\\n    pos :=  make(map[int]int)\\n    for i,item := range(nums){\\n        pos[item] = i\\n    }\\n    answer := 0\\n    n := len(nums)\\n    idx := -math.MaxInt\\n    sort.Ints(nums)\\n    for k,a := range(nums){\\n        if pos[a] < idx{\\n            answer += n - k\\n        }\\n        idx = pos[a]\\n        answer++\\n    }\\n    return int64(answer)\\n}\\n```\n```python []\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        pos = {item: i for i,item in enumerate(nums)}\\n        answer = 0\\n        n = len(nums)\\n        idx = float(\"-inf\")\\n        nums.sort()\\n        for k,a in enumerate(nums):\\n            if pos[a] < idx:\\n                answer += n - k\\n            idx = pos[a]\\n            anwer+=1\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467032,
                "title": "fenwick-tree-priorityqueue-java",
                "content": "The problem asks us to find the smallest value, and rotate all other values before it to the end of the array, and then take the smallest value out. We just keep doing it until we remove all values. At the beginning at each step, we would be at the position of the previously smallest value, and we want to rotate to the currently smallest value. In other words, if we have a_i, a_i+1, ... , a_j, a_j+1, .... at the currently step, and a_j is the smallest value in the remaining array, the element we removed before this step would be just before a_i. Now we need to rotate all elements before a_j to the end of the array.\\n\\nIf we sort the indices of the array by their values, or equivalently use a Priority Queue (Min Heap), we can iteratively go through the smallest values. Now we just need to find out how many rotations we need for each step. It is easy to see it\\'s just the number of elements left between the previously smallest element and the currently smallest element. (We have to account for two cases, since last could be before or after the current mininum) An efficient approach is to use a Fenwick Tree (Binary Indexed Tree) to keep track of which elements have been removed and how many elements remain before two indices.\\n\\n* In my implementation, the array uses 0-based index while BIT uses 1-based index. As a result, the arguments passed into BIT\\'s methods are all incremented by 1.\\n\\n```\\nclass Solution {\\n\\n    private static class BIT {\\n        private int[] arr;\\n\\n        public BIT(int n) {\\n            arr = new int[n+1];\\n            Arrays.fill(arr, 0);\\n        }\\n\\n        public BIT(int[] a) {\\n            arr = new int[a.length + 1];\\n            for (int i = 0; i < a.length; i++) {\\n                int idx = i+1;\\n                arr[idx] += a[i];\\n                int iidx = idx + lsb(idx);\\n                if (iidx < arr.length) {\\n                    arr[iidx] += arr[idx];\\n                }\\n            }\\n        }\\n\\n        public int preSum(int i) {\\n            int sum = 0;\\n            while (i > 0) {\\n                sum += arr[i];\\n                i = i - lsb(i);\\n            }\\n\\n            return sum;\\n\\n        }\\n\\n        public void add(int i, int v) {\\n            while (i < arr.length) {\\n                arr[i] += v;\\n                i = i + lsb(i);\\n            }\\n        }\\n\\n        private int lsb(int n) {\\n            return n & -n;\\n        }\\n    }\\n\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n = nums.length;\\n        BIT bit = new BIT(n);\\n        long total = 0;\\n        \\n        PriorityQueue<List<Integer>> pq = new PriorityQueue<>((a, b) -> a.get(0) - b.get(0));\\n        for (int i = 0; i < n; i++) {\\n            pq.add(List.of(nums[i], i));\\n        }\\n        for (int i = 0; i < n; i++) {\\n            bit.add(i+1, 1);\\n        }\\n        \\n        int lastIdx = -1;\\n        while (pq.size() > 0) {\\n            List<Integer> nu = pq.poll();\\n            int idx = nu.get(1);\\n            if (lastIdx < idx) {\\n                total += bit.preSum(idx+1) - 1 - bit.preSum(lastIdx + 1);\\n            } else {\\n                total += bit.preSum(n) - bit.preSum(lastIdx+1) + bit.preSum(idx+1) - 1;\\n            }\\n            //System.out.println(total);\\n            bit.add(idx+1, -1);\\n            lastIdx = idx;\\n        }\\n        \\n        return total + n;\\n    }\\n}\\n```\\nTime Complexity: O(n * log(n)) Priority Queue takes O(n * log (n)) and Fenwick tree takes O(log(n)) to update points and query ranges for each step.\\nSpace Complexity: O(n)",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n\\n    private static class BIT {\\n        private int[] arr;\\n\\n        public BIT(int n) {\\n            arr = new int[n+1];\\n            Arrays.fill(arr, 0);\\n        }\\n\\n        public BIT(int[] a) {\\n            arr = new int[a.length + 1];\\n            for (int i = 0; i < a.length; i++) {\\n                int idx = i+1;\\n                arr[idx] += a[i];\\n                int iidx = idx + lsb(idx);\\n                if (iidx < arr.length) {\\n                    arr[iidx] += arr[idx];\\n                }\\n            }\\n        }\\n\\n        public int preSum(int i) {\\n            int sum = 0;\\n            while (i > 0) {\\n                sum += arr[i];\\n                i = i - lsb(i);\\n            }\\n\\n            return sum;\\n\\n        }\\n\\n        public void add(int i, int v) {\\n            while (i < arr.length) {\\n                arr[i] += v;\\n                i = i + lsb(i);\\n            }\\n        }\\n\\n        private int lsb(int n) {\\n            return n & -n;\\n        }\\n    }\\n\\n    public long countOperationsToEmptyArray(int[] nums) {\\n        int n = nums.length;\\n        BIT bit = new BIT(n);\\n        long total = 0;\\n        \\n        PriorityQueue<List<Integer>> pq = new PriorityQueue<>((a, b) -> a.get(0) - b.get(0));\\n        for (int i = 0; i < n; i++) {\\n            pq.add(List.of(nums[i], i));\\n        }\\n        for (int i = 0; i < n; i++) {\\n            bit.add(i+1, 1);\\n        }\\n        \\n        int lastIdx = -1;\\n        while (pq.size() > 0) {\\n            List<Integer> nu = pq.poll();\\n            int idx = nu.get(1);\\n            if (lastIdx < idx) {\\n                total += bit.preSum(idx+1) - 1 - bit.preSum(lastIdx + 1);\\n            } else {\\n                total += bit.preSum(n) - bit.preSum(lastIdx+1) + bit.preSum(idx+1) - 1;\\n            }\\n            //System.out.println(total);\\n            bit.add(idx+1, -1);\\n            lastIdx = idx;\\n        }\\n        \\n        return total + n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467018,
                "title": "easy-sorting-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        arr = sorted([(e,i) for i, e in enumerate(nums)])\\n        ans = c = p = 0\\n        for e, i in arr:\\n            if i<p:\\n                c += 1 \\n            ans += c\\n            p = i\\n        return ans+len(nums)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        arr = sorted([(e,i) for i, e in enumerate(nums)])\\n        ans = c = p = 0\\n        for e, i in arr:\\n            if i<p:\\n                c += 1 \\n            ans += c\\n            p = i\\n        return ans+len(nums)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467008,
                "title": "best-c-solution-accepted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) \\n    {\\n        map<int, int> mp;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            mp[nums[i]] = i;\\n        }\\n        \\n        int lastInd = -1, len = n, removed = 0, cnt = 0;\\n        long long ans = 0;\\n        for(auto &[num, ind] : mp) {\\n            if(ind < lastInd) {\\n                ans += len-removed;\\n                removed += cnt;\\n                cnt = 0;\\n            }\\n            lastInd = ind;\\n            cnt++;\\n        }\\n        ans += len-removed;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) \\n    {\\n        map<int, int> mp;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            mp[nums[i]] = i;\\n        }\\n        \\n        int lastInd = -1, len = n, removed = 0, cnt = 0;\\n        long long ans = 0;\\n        for(auto &[num, ind] : mp) {\\n            if(ind < lastInd) {\\n                ans += len-removed;\\n                removed += cnt;\\n                cnt = 0;\\n            }\\n            lastInd = ind;\\n            cnt++;\\n        }\\n        ans += len-removed;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466994,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public long CountOperationsToEmptyArray(int[] nums)\\n    {\\n        var n = nums.Length;\\n        var ind = Enumerable.Range(0, n).ToArray();\\n\\n        Array.Sort(ind, (x, y) => nums[x].CompareTo(nums[y]));\\n        var m = n;\\n        var result = 0L;\\n\\n        for (int i = 1, last = 0; i < n; ++i)\\n            if (ind[i] < ind[i - 1])\\n            {\\n                result += m;\\n                m -= i - last;\\n                last = i;\\n            }\\n\\n        result += m;\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public long CountOperationsToEmptyArray(int[] nums)\\n    {\\n        var n = nums.Length;\\n        var ind = Enumerable.Range(0, n).ToArray();\\n\\n        Array.Sort(ind, (x, y) => nums[x].CompareTo(nums[y]));\\n        var m = n;\\n        var result = 0L;\\n\\n        for (int i = 1, last = 0; i < n; ++i)\\n            if (ind[i] < ind[i - 1])\\n            {\\n                result += m;\\n                m -= i - last;\\n                last = i;\\n            }\\n\\n        result += m;\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466975,
                "title": "brute-force-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInstead of adding numbers at the end, we just erase each smallest number, in increasing value and position order. Sorting (position, value) pairs by value only has to be done once.\\n\\nWe keep the numbers in a list sorted by position; each erasure or lookup takes logarithmic time.\\n\\nAfter reaching the end of the list, we go back to the beginning. This simulates adding the skipped numbers to the end of the list.\\n\\nThis solution uses the SortedList class from the sortedcontainers module.\\n\\n# Complexity\\n- Time complexity: $O(n \\\\log n)$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        l=len(nums)\\n        from sortedcontainers import SortedList as slist\\n        lst0=slist(enumerate(nums), key=lambda x:x[0])\\n        lst1=list(enumerate(nums))\\n        lst1.sort(key=lambda x:x[1])\\n        \\n        ans=0\\n        ct=0\\n        while ct<l:\\n            old_pos=-1\\n            it_lst=[]\\n            while ct<l:\\n                it=lst1[ct]\\n                pos=lst0.index(it)\\n                if pos>=old_pos:\\n                    ans+=pos-old_pos\\n                    old_pos=pos\\n                    it_lst.append(it)\\n                    ct+=1\\n                else:\\n                    ans+=len(lst0)-old_pos-1\\n                    break\\n            for it in it_lst:\\n                lst0.discard(it)\\n        return ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        l=len(nums)\\n        from sortedcontainers import SortedList as slist\\n        lst0=slist(enumerate(nums), key=lambda x:x[0])\\n        lst1=list(enumerate(nums))\\n        lst1.sort(key=lambda x:x[1])\\n        \\n        ans=0\\n        ct=0\\n        while ct<l:\\n            old_pos=-1\\n            it_lst=[]\\n            while ct<l:\\n                it=lst1[ct]\\n                pos=lst0.index(it)\\n                if pos>=old_pos:\\n                    ans+=pos-old_pos\\n                    old_pos=pos\\n                    it_lst.append(it)\\n                    ct+=1\\n                else:\\n                    ans+=len(lst0)-old_pos-1\\n                    break\\n            for it in it_lst:\\n                lst0.discard(it)\\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466970,
                "title": "c-simple-solution-with-sort",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        typedef pair<int, int> pii;\\n        int n = nums.size();\\n        vector<pii> sorted(n);\\n        for (int i = 0; i < n; i++) {\\n            sorted[i] = {nums[i], i};\\n        }\\n        sort(sorted.begin(), sorted.end());\\n        int count = 0, cursize = n;\\n        long long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            count++;\\n            if (i == n - 1 || sorted[i+1].second < sorted[i].second) {\\n                res += cursize;\\n                cursize -= count;\\n                count = 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        typedef pair<int, int> pii;\\n        int n = nums.size();\\n        vector<pii> sorted(n);\\n        for (int i = 0; i < n; i++) {\\n            sorted[i] = {nums[i], i};\\n        }\\n        sort(sorted.begin(), sorted.end());\\n        int count = 0, cursize = n;\\n        long long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            count++;\\n            if (i == n - 1 || sorted[i+1].second < sorted[i].second) {\\n                res += cursize;\\n                cursize -= count;\\n                count = 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466954,
                "title": "easy-solution-in-js",
                "content": "All credit goes to Lee .\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countOperationsToEmptyArray = function(nums) {\\n    var map={};\\n    var n=nums.length,p=0;\\n    var ans=n;\\n    for(let i=0;i<n;i++){\\n        map[nums[i]]=i;\\n    }\\n    nums.sort((a,b)=>a-b);\\n    for(let i=0;i<n;p=map[nums[i++]]){\\n        if(map[nums[i]]<p){\\n            ans+=n-i;\\n        }\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countOperationsToEmptyArray = function(nums) {\\n    var map={};\\n    var n=nums.length,p=0;\\n    var ans=n;\\n    for(let i=0;i<n;i++){\\n        map[nums[i]]=i;\\n    }\\n    nums.sort((a,b)=>a-b);\\n    for(let i=0;i<n;p=map[nums[i++]]){\\n        if(map[nums[i]]<p){\\n            ans+=n-i;\\n        }\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466927,
                "title": "worst-question-ever",
                "content": "\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        sl = SortedList((num, i) for i, num in enumerate(nums))\\n        sl_idx = SortedList(range(n))\\n        start, ans = 0, 0\\n        \\n        while sl:\\n            num, i = sl.pop(0)\\n            ans += self.count(sl_idx, n, start, i)\\n            sl_idx.remove(i)\\n            start = (i + 1) % n\\n        \\n        return ans\\n    \\n    def count(self, sl, n, start, end):\\n        if start <= end:\\n            return sl.bisect(end) - sl.bisect_left(start)\\n        \\n        else:\\n            left_count = self.count(sl, n, start, n - 1)\\n            right_count = self.count(sl, n, 0, end)\\n            return left_count + right_count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        sl = SortedList((num, i) for i, num in enumerate(nums))\\n        sl_idx = SortedList(range(n))\\n        start, ans = 0, 0\\n        \\n        while sl:\\n            num, i = sl.pop(0)\\n            ans += self.count(sl_idx, n, start, i)\\n            sl_idx.remove(i)\\n            start = (i + 1) % n\\n        \\n        return ans\\n    \\n    def count(self, sl, n, start, end):\\n        if start <= end:\\n            return sl.bisect(end) - sl.bisect_left(start)\\n        \\n        else:\\n            left_count = self.count(sl, n, start, n - 1)\\n            right_count = self.count(sl, n, 0, end)\\n            return left_count + right_count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466909,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        pos = {num: i + 1 for i,num in enumerate(nums)}\\n        n = len(nums)\\n        ans=n\\n        i = 0\\n        for k,num in enumerate(sorted(nums)):\\n            if pos[num] < i:\\n                ans += n - k\\n            i = pos[num]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        pos = {num: i + 1 for i,num in enumerate(nums)}\\n        n = len(nums)\\n        ans=n\\n        i = 0\\n        for k,num in enumerate(sorted(nums)):\\n            if pos[num] < i:\\n                ans += n - k\\n            i = pos[num]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466826,
                "title": "compress-the-array-and-traverse-it-loop-by-loop-python-o-nlogn-no-segment-tree",
                "content": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        compress = {}\\n        for i, n in enumerate(sorted(nums)):\\n            compress[n] = i + 1\\n        for i in range(len(nums)):\\n            nums[i] = compress[nums[i]]\\n        position = {}\\n        for i, n in enumerate(nums):\\n            position[n] = i\\n        \\n        res = 0\\n        current_loop_size = len(nums)\\n        cur_num = cur_loop_count = 1\\n        cur_idx = position[cur_num]\\n        while cur_num < len(nums):\\n            nex = position[cur_num + 1]\\n            if nex < cur_idx:\\n                res += current_loop_size\\n                current_loop_size -= cur_loop_count\\n                cur_loop_count = 0\\n            cur_idx = nex\\n            cur_num = nums[nex]\\n            cur_loop_count += 1\\n        return res + cur_loop_count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        compress = {}\\n        for i, n in enumerate(sorted(nums)):\\n            compress[n] = i + 1\\n        for i in range(len(nums)):\\n            nums[i] = compress[nums[i]]\\n        position = {}\\n        for i, n in enumerate(nums):\\n            position[n] = i\\n        \\n        res = 0\\n        current_loop_size = len(nums)\\n        cur_num = cur_loop_count = 1\\n        cur_idx = position[cur_num]\\n        while cur_num < len(nums):\\n            nex = position[cur_num + 1]\\n            if nex < cur_idx:\\n                res += current_loop_size\\n                current_loop_size -= cur_loop_count\\n                cur_loop_count = 0\\n            cur_idx = nex\\n            cur_num = nums[nex]\\n            cur_loop_count += 1\\n        return res + cur_loop_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466808,
                "title": "c-sorting-fenwick-tree",
                "content": "# Code\\n```\\nclass Solution {\\n    int query(vector<int> &BIT, int i) {\\n        int sum = 0; i++;\\n        while(i > 0) {\\n            sum += BIT[i];\\n            i = i - (i & -i);\\n        }\\n        return sum;\\n    }\\n    void update(vector<int> &BIT, int i) {\\n        i++;\\n        while(i < BIT.size()) {\\n            BIT[i]++;\\n            i = i + (i & -i);\\n        }\\n    }\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> index(n);\\n        iota(index.begin(), index.end(), 0);\\n        sort(index.begin(), index.end(), [&](int i, int j) {\\n            return nums[i] < nums[j];\\n        });\\n        vector<int> BIT(n + 1);\\n        long long ans = index[0] + 1;\\n        update(BIT, index[0]);\\n        for(int i = 1; i < n; i++) {\\n            if(index[i] > index[i - 1]) {\\n                ans += (index[i] - index[i - 1]) - (query(BIT, index[i]) - query(BIT, index[i - 1]));\\n            } else {\\n                ans += (n - index[i - 1] + index[i]) - (query(BIT, n - 1) - query(BIT, index[i - 1]) + query(BIT, index[i]));\\n            }\\n            update(BIT, index[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    int query(vector<int> &BIT, int i) {\\n        int sum = 0; i++;\\n        while(i > 0) {\\n            sum += BIT[i];\\n            i = i - (i & -i);\\n        }\\n        return sum;\\n    }\\n    void update(vector<int> &BIT, int i) {\\n        i++;\\n        while(i < BIT.size()) {\\n            BIT[i]++;\\n            i = i + (i & -i);\\n        }\\n    }\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> index(n);\\n        iota(index.begin(), index.end(), 0);\\n        sort(index.begin(), index.end(), [&](int i, int j) {\\n            return nums[i] < nums[j];\\n        });\\n        vector<int> BIT(n + 1);\\n        long long ans = index[0] + 1;\\n        update(BIT, index[0]);\\n        for(int i = 1; i < n; i++) {\\n            if(index[i] > index[i - 1]) {\\n                ans += (index[i] - index[i - 1]) - (query(BIT, index[i]) - query(BIT, index[i - 1]));\\n            } else {\\n                ans += (n - index[i - 1] + index[i]) - (query(BIT, n - 1) - query(BIT, index[i - 1]) + query(BIT, index[i]));\\n            }\\n            update(BIT, index[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466789,
                "title": "python-3-segment-tree",
                "content": "The list is circular, each next mininum needs to be rotated to the front. Number of operation needed depends on whether the next minimum is sitting to the left or right of the current minimum in the original nums. However, elements in between the two may have been removed, therefore need a counting structure to keep track of how many elements have been removed between any two indices. Hereinafter I used segment tree.\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        # track original indices to determine count of ratations\\n        dc = {v: i for i, v in enumerate(nums)} \\n        arr = sorted(nums)\\n            \\n        tree = [0] * (2 * n)\\n        \\n        def update(index):\\n            index += n\\n            while index:\\n                tree[index] += 1\\n                index //= 2\\n\\n        def sumRange(left, right):\\n            left += n\\n            right += n\\n            ans = 0\\n            while left <= right:\\n                if left & 1:\\n                    ans += tree[left]\\n                    left += 1\\n                if not right & 1:\\n                    ans += tree[right]\\n                    right -= 1\\n                left //= 2\\n                right //= 2\\n            return ans\\n        \\n        idx = dc[arr[0]]\\n        ans = dc[arr[0]] + 1\\n        update(idx)\\n        for i in range(1, n - 1):\\n            j = dc[arr[i]]\\n            if j > idx:\\n                # next is to the right, directly roate to the right\\n                ans += j - idx - sumRange(idx + 1, j)\\n            else:\\n                # next is to the left, rotate across the end\\n                ans += (j + 1 - sumRange(0, j)) + (n - idx - 1 - sumRange(idx + 1, n - 1))\\n            idx = j\\n            update(j)\\n        return ans + (1 if n > 1 else 0) # 1 extra for the last element if n > 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        # track original indices to determine count of ratations\\n        dc = {v: i for i, v in enumerate(nums)} \\n        arr = sorted(nums)\\n            \\n        tree = [0] * (2 * n)\\n        \\n        def update(index):\\n            index += n\\n            while index:\\n                tree[index] += 1\\n                index //= 2\\n\\n        def sumRange(left, right):\\n            left += n\\n            right += n\\n            ans = 0\\n            while left <= right:\\n                if left & 1:\\n                    ans += tree[left]\\n                    left += 1\\n                if not right & 1:\\n                    ans += tree[right]\\n                    right -= 1\\n                left //= 2\\n                right //= 2\\n            return ans\\n        \\n        idx = dc[arr[0]]\\n        ans = dc[arr[0]] + 1\\n        update(idx)\\n        for i in range(1, n - 1):\\n            j = dc[arr[i]]\\n            if j > idx:\\n                # next is to the right, directly roate to the right\\n                ans += j - idx - sumRange(idx + 1, j)\\n            else:\\n                # next is to the left, rotate across the end\\n                ans += (j + 1 - sumRange(0, j)) + (n - idx - 1 - sumRange(idx + 1, n - 1))\\n            idx = j\\n            update(j)\\n        return ans + (1 if n > 1 else 0) # 1 extra for the last element if n > 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466788,
                "title": "o-n-python3-solution-using-list-of-wrap-counts",
                "content": "# Intuition\\nSince N = 1E5, this requires an $$O(N * Log(N))$$ solution or better; however, it is not clear how to avoid the brute-force $$O(N^2)$$ traversals. We will first write a slow solution, then try to find a pattern or formula, then proceed with an $$O(N * Log(N))$$ solution.\\n\\n# Approach\\nSince only the relative ordering is needed, simplify the problem by producing `idxs`, the index of the ith smallest element. Then we use the formula `n + sum(wrapCounts)` observed in `countOperationsToEmptyArraySlow`, to write our $$O(N)$$ solution.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(N * Log(N))$$\\n\\n- Space complexity:\\n$$O(N)$$\\n\\n# Code\\n```\\nclass Solution:\\n    \"\"\"Notes\\n    * N = 1E5, so N Log N probably needed.\\n      * Ugh. The natural way is O(N^2). Need examples:\\n        * Find relative positions of numbers from small to large. Then the math is tricky.\\n        * Write slow method, then find pattern.\\n    \"\"\"\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        # return self.countOperationsToEmptyArraySlow(nums)\\n        return self.countOperationsToEmptyArrayFast(nums)\\n    \\n    def countOperationsToEmptyArrayFast(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # Produces indices of numbers from small to large.\\n        numIdxs = sorted((num, i) for i, num in enumerate(nums))\\n        idxs = []\\n        for num, idx in numIdxs:\\n            idxs.append(idx)\\n            \\n        # Find the wrapCount of each num.\\n        prevPos = -1\\n        wrapCounts = []\\n        wrapCount = 0\\n        for i in range(n):\\n            pos = idxs[i]               \\n            if prevPos > pos:\\n                wrapCount += 1\\n            wrapCounts.append(wrapCount)\\n            prevPos = pos\\n        sumWrapCounts = sum(wrapCounts)\\n        \\n        # This formula uses evidence gathered from countOperationsToEmptyArraySlow.\\n        return n + sumWrapCounts\\n        \\n    def countOperationsToEmptyArraySlow(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        numIdxs = sorted((num, i) for i, num in enumerate(nums))\\n        nums = [None] * n\\n        idxs = [None] * n\\n        for i, (num, idx) in enumerate(numIdxs):\\n            nums[idx] = i\\n            idxs[i] = idx\\n        numOps = 0\\n        prevPos = -1\\n        wrapCounts = []\\n        wraps = 0\\n        for i in range(n):\\n            pos = idxs[i]\\n            cursor = prevPos\\n            while cursor != pos:\\n                cursor = (cursor + 1) % n\\n                if nums[cursor] >= i:\\n                    numOps += 1\\n            if prevPos > pos:\\n                wraps += 1\\n            wrapCounts.append(wraps)\\n            prevPos = pos\\n        print(f\\'nums={nums}, idxs={idxs}, n={n}, wrapCounts={wrapCounts}, numOps={numOps}\\')\\n        return numOps        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"Notes\\n    * N = 1E5, so N Log N probably needed.\\n      * Ugh. The natural way is O(N^2). Need examples:\\n        * Find relative positions of numbers from small to large. Then the math is tricky.\\n        * Write slow method, then find pattern.\\n    \"\"\"\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        # return self.countOperationsToEmptyArraySlow(nums)\\n        return self.countOperationsToEmptyArrayFast(nums)\\n    \\n    def countOperationsToEmptyArrayFast(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # Produces indices of numbers from small to large.\\n        numIdxs = sorted((num, i) for i, num in enumerate(nums))\\n        idxs = []\\n        for num, idx in numIdxs:\\n            idxs.append(idx)\\n            \\n        # Find the wrapCount of each num.\\n        prevPos = -1\\n        wrapCounts = []\\n        wrapCount = 0\\n        for i in range(n):\\n            pos = idxs[i]               \\n            if prevPos > pos:\\n                wrapCount += 1\\n            wrapCounts.append(wrapCount)\\n            prevPos = pos\\n        sumWrapCounts = sum(wrapCounts)\\n        \\n        # This formula uses evidence gathered from countOperationsToEmptyArraySlow.\\n        return n + sumWrapCounts\\n        \\n    def countOperationsToEmptyArraySlow(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        numIdxs = sorted((num, i) for i, num in enumerate(nums))\\n        nums = [None] * n\\n        idxs = [None] * n\\n        for i, (num, idx) in enumerate(numIdxs):\\n            nums[idx] = i\\n            idxs[i] = idx\\n        numOps = 0\\n        prevPos = -1\\n        wrapCounts = []\\n        wraps = 0\\n        for i in range(n):\\n            pos = idxs[i]\\n            cursor = prevPos\\n            while cursor != pos:\\n                cursor = (cursor + 1) % n\\n                if nums[cursor] >= i:\\n                    numOps += 1\\n            if prevPos > pos:\\n                wraps += 1\\n            wrapCounts.append(wraps)\\n            prevPos = pos\\n        print(f\\'nums={nums}, idxs={idxs}, n={n}, wrapCounts={wrapCounts}, numOps={numOps}\\')\\n        return numOps        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466749,
                "title": "fenwick-tree-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n#include \"ext/pb_ds/assoc_container.hpp\"\\n#include \"ext/pb_ds/tree_policy.hpp\"\\nusing namespace __gnu_pbds;\\ntemplate<typename T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\\n\\n#define str string\\n#define ll long long\\n#define ld long double\\n#define ar array\\n\\n#define vt vector\\n#define pb push_back\\n#define fi first\\n#define se second\\n#define all(c) (c).begin(), (c).end()\\n#define len(x) (int)(x).size()\\n#define elif else if\\n#define def function\\n\\n#define F_OR(i, a, b, s) for (int i=(a); (s)>0?i<(b):i>(b); i+=(s))\\n#define F_OR1(e) F_OR(i, 0, e, 1)\\n#define F_OR2(i, e) F_OR(i, 0, e, 1)\\n#define F_OR3(i, b, e) F_OR(i, b, e, 1)\\n#define F_OR4(i, b, e, s) F_OR(i, b, e, s)\\n#define GET5(a, b, c, d, e, ...) e\\n#define F_ORC(...) GET5(__VA_ARGS__, F_OR4, F_OR3, F_OR2, F_OR1)\\n#define rep(...) F_ORC(__VA_ARGS__)(__VA_ARGS__)\\n#define each(x, a) for (auto& x: a)\\n\\nclass Solution {\\npublic:\\n    template<class T>\\nstruct range_add_range_sum_query_solver{\\n\\tint n;\\n\\tvector<T> data0, data1;\\n\\trange_add_range_sum_query_solver(){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(int n): n(n), data0(n), data1(n){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(int n, T init): range_add_range_sum_query_solver(vector<T>(n, init)){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(const vector<T> &v): n((int)v.size()), data0(n), data1(v){\\n\\t\\tfor(auto i = 1; i <= n; ++ i) if(i + (i & -i) <= n) data1[i + (i & -i) - 1] += data1[i - 1];\\n\\t}\\n\\tvoid update(int ql, int qr, T x){\\n\\t\\tassert(0 <= ql && ql <= qr && qr <= n);\\n\\t\\tif(ql == qr) return;\\n\\t\\tfor(auto l = ql + 1; l <= n; l += l & -l) data0[l - 1] += x, data1[l - 1] -= ql * x;\\n\\t\\tfor(auto r = qr + 1; r <= n; r += r & -r) data0[r - 1] -= x, data1[r - 1] += qr * x;\\n\\t}\\n\\tT pref(int qr) const{\\n\\t\\tassert(0 <= qr && qr <= n);\\n\\t\\tT sum0 = {}, sum1 = {};\\n\\t\\tfor(auto r = qr; r > 0; r -= r & -r) sum0 += data0[r - 1], sum1 += data1[r - 1];\\n\\t\\treturn qr * sum0 + sum1;\\n\\t}\\n\\tT query(int l, int r) const{\\n\\t\\tassert(0 <= l && l <= r && r <= n);\\n\\t\\treturn pref(r) - pref(l);\\n\\t}\\n\\ttemplate<class output_stream>\\n\\tfriend output_stream &operator<<(output_stream &out, const range_add_range_sum_query_solver<T> &solver){\\n\\t\\tout << \"[\";\\n\\t\\tfor(auto i = 0; i < solver.n; ++ i){\\n\\t\\t\\tout << solver.query(i, i + 1);\\n\\t\\t\\tif(i != solver.n - 1) out << \", \";\\n\\t\\t}\\n\\t\\treturn out << \\']\\';\\n\\t}\\n};\\n    long long countOperationsToEmptyArray(vector<int>& a) {\\n         int n = len(a);\\n   \\n    vt<int> st(n, 1);\\n    vt<pair<int, int>> b;\\n    rep(i, n) b.pb({a[i], i});\\n    sort(all(b));\\n    range_add_range_sum_query_solver rmq(st);\\n    ll ret = n, cur = 0;\\n    rep(i, n){\\n        auto [a, idx] = b[i];\\n        rmq.update(idx, idx+1, -1);\\n        if (idx < cur){\\n            ret += rmq.query(cur, n);\\n            ret += rmq.query(0, idx);\\n        }\\n        elif(cur == idx) {int ajay = 1;}\\n        else{\\n            ret += rmq.query(cur, idx);\\n        }\\n        cur = (idx + 1)%n;\\n    }\\n    return ret;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n#include \"ext/pb_ds/assoc_container.hpp\"\\n#include \"ext/pb_ds/tree_policy.hpp\"\\nusing namespace __gnu_pbds;\\ntemplate<typename T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\\n\\n#define str string\\n#define ll long long\\n#define ld long double\\n#define ar array\\n\\n#define vt vector\\n#define pb push_back\\n#define fi first\\n#define se second\\n#define all(c) (c).begin(), (c).end()\\n#define len(x) (int)(x).size()\\n#define elif else if\\n#define def function\\n\\n#define F_OR(i, a, b, s) for (int i=(a); (s)>0?i<(b):i>(b); i+=(s))\\n#define F_OR1(e) F_OR(i, 0, e, 1)\\n#define F_OR2(i, e) F_OR(i, 0, e, 1)\\n#define F_OR3(i, b, e) F_OR(i, b, e, 1)\\n#define F_OR4(i, b, e, s) F_OR(i, b, e, s)\\n#define GET5(a, b, c, d, e, ...) e\\n#define F_ORC(...) GET5(__VA_ARGS__, F_OR4, F_OR3, F_OR2, F_OR1)\\n#define rep(...) F_ORC(__VA_ARGS__)(__VA_ARGS__)\\n#define each(x, a) for (auto& x: a)\\n\\nclass Solution {\\npublic:\\n    template<class T>\\nstruct range_add_range_sum_query_solver{\\n\\tint n;\\n\\tvector<T> data0, data1;\\n\\trange_add_range_sum_query_solver(){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(int n): n(n), data0(n), data1(n){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(int n, T init): range_add_range_sum_query_solver(vector<T>(n, init)){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(const vector<T> &v): n((int)v.size()), data0(n), data1(v){\\n\\t\\tfor(auto i = 1; i <= n; ++ i) if(i + (i & -i) <= n) data1[i + (i & -i) - 1] += data1[i - 1];\\n\\t}\\n\\tvoid update(int ql, int qr, T x){\\n\\t\\tassert(0 <= ql && ql <= qr && qr <= n);\\n\\t\\tif(ql == qr) return;\\n\\t\\tfor(auto l = ql + 1; l <= n; l += l & -l) data0[l - 1] += x, data1[l - 1] -= ql * x;\\n\\t\\tfor(auto r = qr + 1; r <= n; r += r & -r) data0[r - 1] -= x, data1[r - 1] += qr * x;\\n\\t}\\n\\tT pref(int qr) const{\\n\\t\\tassert(0 <= qr && qr <= n);\\n\\t\\tT sum0 = {}, sum1 = {};\\n\\t\\tfor(auto r = qr; r > 0; r -= r & -r) sum0 += data0[r - 1], sum1 += data1[r - 1];\\n\\t\\treturn qr * sum0 + sum1;\\n\\t}\\n\\tT query(int l, int r) const{\\n\\t\\tassert(0 <= l && l <= r && r <= n);\\n\\t\\treturn pref(r) - pref(l);\\n\\t}\\n\\ttemplate<class output_stream>\\n\\tfriend output_stream &operator<<(output_stream &out, const range_add_range_sum_query_solver<T> &solver){\\n\\t\\tout << \"[\";\\n\\t\\tfor(auto i = 0; i < solver.n; ++ i){\\n\\t\\t\\tout << solver.query(i, i + 1);\\n\\t\\t\\tif(i != solver.n - 1) out << \", \";\\n\\t\\t}\\n\\t\\treturn out << \\']\\';\\n\\t}\\n};\\n    long long countOperationsToEmptyArray(vector<int>& a) {\\n         int n = len(a);\\n   \\n    vt<int> st(n, 1);\\n    vt<pair<int, int>> b;\\n    rep(i, n) b.pb({a[i], i});\\n    sort(all(b));\\n    range_add_range_sum_query_solver rmq(st);\\n    ll ret = n, cur = 0;\\n    rep(i, n){\\n        auto [a, idx] = b[i];\\n        rmq.update(idx, idx+1, -1);\\n        if (idx < cur){\\n            ret += rmq.query(cur, n);\\n            ret += rmq.query(0, idx);\\n        }\\n        elif(cur == idx) {int ajay = 1;}\\n        else{\\n            ret += rmq.query(cur, idx);\\n        }\\n        cur = (idx + 1)%n;\\n    }\\n    return ret;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3466707,
                "title": "rust-solution",
                "content": "\\n# Code\\n```\\nstruct Bit {\\n    nums: Vec<i32>,\\n}\\nimpl Bit {\\n    fn low_bit(i: usize) -> usize {\\n        return i & (!i + 1);\\n    }\\n    fn add(&mut self, mut i: usize, v: i32) {\\n        while i < self.nums.len() {\\n            self.nums[i] += v;\\n            i += Self::low_bit(i);\\n        }\\n    }\\n    fn query(&self, mut i: usize) -> i32 {\\n        let mut ans = 0;\\n        while i > 0 {\\n            ans += self.nums[i];\\n            i -= Self::low_bit(i);\\n        }\\n        return ans;\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn count_operations_to_empty_array(nums: Vec<i32>) -> i64 {\\n        let mut idx: Vec<usize> = (0..nums.len()).collect();\\n        idx.sort_by_key(|&id| nums[id]);\\n        let mut ans = 0;\\n        let mut pre = 0;\\n        let mut bit = Bit { nums: vec![0; nums.len() + 100] };\\n        for &i in idx.iter() {\\n            if i >= pre {\\n                let x1 = bit.query(pre);\\n                let x2 = bit.query(i + 1);\\n                ans += (i - pre) as i64 - (x2 - x1) as i64 + 1;\\n            } else {\\n                let x = bit.query(i + 1) + (bit.query(nums.len()) - bit.query(pre));\\n                ans += (i + nums.len() - pre) as i64 - x as i64 + 1;\\n            }\\n            bit.add(i + 1, 1);\\n            pre = i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct Bit {\\n    nums: Vec<i32>,\\n}\\nimpl Bit {\\n    fn low_bit(i: usize) -> usize {\\n        return i & (!i + 1);\\n    }\\n    fn add(&mut self, mut i: usize, v: i32) {\\n        while i < self.nums.len() {\\n            self.nums[i] += v;\\n            i += Self::low_bit(i);\\n        }\\n    }\\n    fn query(&self, mut i: usize) -> i32 {\\n        let mut ans = 0;\\n        while i > 0 {\\n            ans += self.nums[i];\\n            i -= Self::low_bit(i);\\n        }\\n        return ans;\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn count_operations_to_empty_array(nums: Vec<i32>) -> i64 {\\n        let mut idx: Vec<usize> = (0..nums.len()).collect();\\n        idx.sort_by_key(|&id| nums[id]);\\n        let mut ans = 0;\\n        let mut pre = 0;\\n        let mut bit = Bit { nums: vec![0; nums.len() + 100] };\\n        for &i in idx.iter() {\\n            if i >= pre {\\n                let x1 = bit.query(pre);\\n                let x2 = bit.query(i + 1);\\n                ans += (i - pre) as i64 - (x2 - x1) as i64 + 1;\\n            } else {\\n                let x = bit.query(i + 1) + (bit.query(nums.len()) - bit.query(pre));\\n                ans += (i + nums.len() - pre) as i64 - x as i64 + 1;\\n            }\\n            bit.add(i + 1, 1);\\n            pre = i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1879059,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1888401,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1878174,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1876996,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1928944,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1880102,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1879331,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 2007525,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1998398,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1972916,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1879059,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1888401,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1878174,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1876996,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1928944,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1880102,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1879331,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 2007525,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1998398,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            },
            {
                "id": 1972916,
                "content": [
                    {
                        "username": "DJPretzel",
                        "content": "Man I hate time limit exceeded. I don\\'t care if my code is slow, it works"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Try using deque. "
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "TLE!!!!\\nTestcase passed 505/514\\nbut I am happy that my code gives expected output."
                    },
                    {
                        "username": "vishakha036",
                        "content": "Same here, Stuck at same point."
                    },
                    {
                        "username": "prafullpandey2801",
                        "content": "Heavy observation needed !\\nNot everyone\\'s cup of Tea \\uD83D\\uDE02\\uD83D\\uDE02\\nCongrats to those who solved it ! \\nBut if you come up with a brute forces solution also then it\\'s not bad . Enjoy the process \\u2764\\uFE0F"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque.... "
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "solved first 3 questions within 15 mins, and then 4th question comes. I was totally clueless all the time."
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh for reverse array ex. li = [4,3,2,1] ans is (2 * len(li))-1 , but in a case there is [1000000000,999999999,....999900002,999900001] means 100000 elements are there. So here ans become 199999 , but here ans is 5000050000"
                    },
                    {
                        "username": "learn_improve",
                        "content": "@jaiswal_rakesh I am able to clear 506 cases , in a case I have a doubt regarding ans."
                    },
                    {
                        "username": "jaiswal_rakesh",
                        "content": "[@learn_improve](/learn_improve) 504\\n"
                    },
                    {
                        "username": "learn_improve",
                        "content": "How many cases your code has passed? "
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gaurav89830](/gaurav89830) You know its not exactly nlogn if you are doing it with min heap and queue. Calculating the steps is the one which results in TLE while polling and reattaching the elements in back of the queue."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "yes bro, I tried with list and queue but didn\\'t work. I got TLE."
                    },
                    {
                        "username": "tushh_R",
                        "content": "[@gaurav89830](/gaurav89830) Same Bro, Used min Heap and queue but it didn\\'t work."
                    },
                    {
                        "username": "gaurav89830",
                        "content": "TLE with nlogn , failed to optimize it more."
                    },
                    {
                        "username": "abdullohs_rival2009",
                        "content": "505/514 \\uD83D\\uDE1E"
                    },
                    {
                        "username": "Kanishk14",
                        "content": "TLE, But atleast my code is giving desired output :)"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Has anyone thought of  stack to do it?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "Use deque"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Ah, a real algo efficiency problem. Testcase 506 is clearly adversarially designed!"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Whats the point of this garbage? Handling 80+ edge cases...  for what? \n"
                    },
                    {
                        "username": "aryan1905",
                        "content": "it\\'s givng me TLE for this code, how can I optimize this:\\nclass Solution {\\npublic:\\n    long long countOperationsToEmptyArray(vector<int>& nums) {\\n        long long op = 0;\\n        int minEl = *min_element(nums.begin(), nums.end());\\n\\n        while (!nums.empty()) {\\n            if (nums[0] == minEl) {\\n                nums.erase(nums.begin());\\n                op++;\\n                if (!nums.empty()) {\\n                    minEl = *min_element(nums.begin(), nums.end());\\n                }\\n            }\\n            else {\\n                op++;\\n                std::rotate(nums.begin(), nums.begin() + 1, nums.end());\\n            }\\n        }\\n        return op;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "The current code is inefficient because it repeatedly calculates the minimum element and uses operations like erase and rotate on vectors, which can be costly in terms of time complexity. To optimize, maintain the original positions of the numbers, sort the array to get the desired order, and then use a strategy similar to counting inversions to determine how many operations are needed to place each number in its correct position."
                    }
                ]
            }
        ]
    }
]