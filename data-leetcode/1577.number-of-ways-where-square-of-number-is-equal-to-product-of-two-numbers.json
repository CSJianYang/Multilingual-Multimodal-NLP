[
    {
        "title": "Duplicate Zeros",
        "question_content": "Given a fixed-length integer array arr, duplicate each occurrence of zero, shifting the remaining elements to the right.\nNote that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything.\n&nbsp;\nExample 1:\n\nInput: arr = [1,0,2,3,0,4,5,0]\nOutput: [1,0,0,2,3,0,0,4]\nExplanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]\n\nExample 2:\n\nInput: arr = [1,2,3]\nOutput: [1,2,3]\nExplanation: After calling your function, the input array is modified to: [1,2,3]\n\n&nbsp;\nConstraints:\n\n\t1 <= arr.length <= 104\n\t0 <= arr[i] <= 9",
        "solutions": [
            {
                "id": 322576,
                "title": "python-3-real-in-place-solution",
                "content": "Start from the back and adjust items to correct locations. If item is zero then duplicate it.\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        zeroes = arr.count(0)\\n        n = len(arr)\\n        for i in range(n-1, -1, -1):\\n            if i + zeroes < n:\\n                arr[i + zeroes] = arr[i]\\n            if arr[i] == 0: \\n                zeroes -= 1\\n                if i + zeroes < n:\\n                    arr[i + zeroes] = 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        zeroes = arr.count(0)\\n        n = len(arr)\\n        for i in range(n-1, -1, -1):\\n            if i + zeroes < n:\\n                arr[i + zeroes] = arr[i]\\n            if arr[i] == 0: \\n                zeroes -= 1\\n                if i + zeroes < n:\\n                    arr[i + zeroes] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312727,
                "title": "c-java-two-pointers-space-o-1",
                "content": "# **Intuition**\\nThe problem can be easy solved:\\n1. with a copy (extra space)\\n2. by inserting zeros (extra time)\\n<br>\\n\\n**Python, with extra space**\\n```\\n    def duplicateZeros(self, A):\\n        A[:] = [x for a in A for x in ([a] if a else [0, 0])][:len(A)]\\n```\\n<br>\\n\\n# **Explanation**\\nWe can improve it to `O(N)` time and `O(1)` space.\\nBasically, we apply two pointers.\\n`i` is the position in the original array,\\n`j` is the position in the new array.\\n(the original and the new are actually the same array.)\\n\\nThe first we pass forward and count the zeros.\\nThe second we pass backward and assign the value from original input to the new array.\\nso that the original value won\\'t be overridden too early.\\n<br>\\n\\n**C++:**\\n```\\n    void duplicateZeros(vector<int>& A) {\\n        int n = A.size(), j = n + count(A.begin(), A.end(), 0);\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (--j < n)\\n                A[j] = A[i];\\n            if (A[i] == 0 && --j < n)\\n                A[j] = 0;\\n        }\\n    }\\n```\\n\\n**Java**\\nVersion suggested by @davidluoyes\\n```java\\n    public void duplicateZeros(int[] arr) {\\n        int countZero = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) countZero++;\\n        }\\n        int len = arr.length + countZero;\\n        //We just need O(1) space if we scan from back\\n        //i point to the original array, j point to the new location\\n        for (int i = arr.length - 1, j = len - 1; i < j; i--, j--) {\\n            if (arr[i] != 0) {\\n                if (j < arr.length) arr[j] = arr[i];\\n            } else {\\n                if (j < arr.length) arr[j] = arr[i];\\n                j--;\\n                if (j < arr.length) arr[j] = arr[i]; //copy twice when hit \\'0\\'\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    def duplicateZeros(self, A):\\n        A[:] = [x for a in A for x in ([a] if a else [0, 0])][:len(A)]\\n```\n```\\n    void duplicateZeros(vector<int>& A) {\\n        int n = A.size(), j = n + count(A.begin(), A.end(), 0);\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (--j < n)\\n                A[j] = A[i];\\n            if (A[i] == 0 && --j < n)\\n                A[j] = 0;\\n        }\\n    }\\n```\n```java\\n    public void duplicateZeros(int[] arr) {\\n        int countZero = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) countZero++;\\n        }\\n        int len = arr.length + countZero;\\n        //We just need O(1) space if we scan from back\\n        //i point to the original array, j point to the new location\\n        for (int i = arr.length - 1, j = len - 1; i < j; i--, j--) {\\n            if (arr[i] != 0) {\\n                if (j < arr.length) arr[j] = arr[i];\\n            } else {\\n                if (j < arr.length) arr[j] = arr[i];\\n                j--;\\n                if (j < arr.length) arr[j] = arr[i]; //copy twice when hit \\'0\\'\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 312743,
                "title": "java-c-o-n-o-1",
                "content": "First, go left to right and count how many shifts (```sh```) we can fit in our array.\\nThen, go right to left and move items; if it\\'s zero - duplicate it and decrement the shift.\\n> Note: ```i + sh``` can exceed the array size. We need a check for this case.\\n```\\nvoid duplicateZeros(vector<int>& a, int i = 0, int sh = 0) {\\n  for (i = 0; sh + i < a.size(); ++i) sh += a[i] == 0;\\n  for (i = i - 1; sh > 0; --i) {\\n    if (i + sh < a.size()) a[i + sh] = a[i];\\n    if (a[i] == 0) a[i + --sh] = a[i];\\n  }\\n}\\n```\\nJava version:\\n```\\npublic void duplicateZeros(int[] a) {\\n  int i = 0, sh = 0;\\n  for (i = 0; sh + i < a.length; ++i) sh += a[i] == 0 ? 1 : 0;\\n  for (i = i - 1; sh > 0; --i) {\\n    if (i + sh < a.length) a[i + sh] = a[i];\\n    if (a[i] == 0) a[i + --sh] = a[i];\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```sh```\n```i + sh```\n```\\nvoid duplicateZeros(vector<int>& a, int i = 0, int sh = 0) {\\n  for (i = 0; sh + i < a.size(); ++i) sh += a[i] == 0;\\n  for (i = i - 1; sh > 0; --i) {\\n    if (i + sh < a.size()) a[i + sh] = a[i];\\n    if (a[i] == 0) a[i + --sh] = a[i];\\n  }\\n}\\n```\n```\\npublic void duplicateZeros(int[] a) {\\n  int i = 0, sh = 0;\\n  for (i = 0; sh + i < a.length; ++i) sh += a[i] == 0 ? 1 : 0;\\n  for (i = i - 1; sh > 0; --i) {\\n    if (i + sh < a.length) a[i + sh] = a[i];\\n    if (a[i] == 0) a[i + --sh] = a[i];\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 315395,
                "title": "java-o-n-time-o-1-space-two-passes-for-loop-and-while-loop",
                "content": "**First pass** to count the number of 0\\'s.\\n**Second pass** is to write in the values in appropriate locations, moving from right to left (backwards from the usual), in which the `write` pointer initially extends outside of the length of the array (as if it was the full sized array without erasing values in the shift).\\n```java\\n  /*\\n  O(n) runtime\\n  O(1) space\\n  */\\n  public void duplicateZeros(int[] A) {\\n    \\n    int n = A.length, count = 0;\\n    \\n    for (int num : A) if (num == 0) count++;\\n    int i = n - 1;\\n    int write = n + count - 1;\\n    \\n    while (i >= 0 && write >= 0)  {\\n      \\n      if (A[i] != 0) { // Non-zero, just write it in\\n        if (write < n) A[write] = A[i];\\n        \\n      } else { // Zero found, write it in twice if we can\\n        if (write < n) A[write] = A[i];\\n        write--;\\n        if (write < n) A[write] = A[i];\\n      }\\n      \\n      i--;\\n      write--;\\n    }\\n  }\\n```",
                "solutionTags": [],
                "code": "```java\\n  /*\\n  O(n) runtime\\n  O(1) space\\n  */\\n  public void duplicateZeros(int[] A) {\\n    \\n    int n = A.length, count = 0;\\n    \\n    for (int num : A) if (num == 0) count++;\\n    int i = n - 1;\\n    int write = n + count - 1;\\n    \\n    while (i >= 0 && write >= 0)  {\\n      \\n      if (A[i] != 0) { // Non-zero, just write it in\\n        if (write < n) A[write] = A[i];\\n        \\n      } else { // Zero found, write it in twice if we can\\n        if (write < n) A[write] = A[i];\\n        write--;\\n        if (write < n) A[write] = A[i];\\n      }\\n      \\n      i--;\\n      write--;\\n    }\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 898225,
                "title": "python-2-solutions-easy-to-understand-time-o-n-space-o-1",
                "content": "**Solution 1: Straigh Forward**\\n```python\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        org = arr[:] # Copy values of `arr` to `org`\\n        i = j = 0\\n        n = len(arr)\\n        while j < n:\\n            arr[j] = org[i]\\n            j += 1\\n            if org[i] == 0: # Copy twice if ord[i] == 0\\n                if j < n: arr[j] = org[i]\\n                j += 1\\n            i += 1\\n```\\nComplexity\\n- Time: `O(N)`\\n- Space: `O(N)`\\n\\n**Solution 2: Copy values from the end to beginning**\\n```python\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        n = len(arr)\\n        cntZero = arr.count(0)\\n        newLen = n + cntZero # Length of new array if we don\\'t trim up to length `n`\\n        \\n        # Let\\'s copy values from the end\\n        i = n - 1\\n        j = newLen - 1\\n        while j >= 0:\\n            if j < n: arr[j] = arr[i]\\n            j -= 1\\n            if arr[i] == 0: # Copy twice if arr[i] == 0\\n                if j < n: arr[j] = arr[i]\\n                j -= 1\\n            i -= 1\\n```\\n\\nComplexity\\n- Time: `O(N)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        org = arr[:] # Copy values of `arr` to `org`\\n        i = j = 0\\n        n = len(arr)\\n        while j < n:\\n            arr[j] = org[i]\\n            j += 1\\n            if org[i] == 0: # Copy twice if ord[i] == 0\\n                if j < n: arr[j] = org[i]\\n                j += 1\\n            i += 1\\n```\n```python\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        n = len(arr)\\n        cntZero = arr.count(0)\\n        newLen = n + cntZero # Length of new array if we don\\'t trim up to length `n`\\n        \\n        # Let\\'s copy values from the end\\n        i = n - 1\\n        j = newLen - 1\\n        while j >= 0:\\n            if j < n: arr[j] = arr[i]\\n            j -= 1\\n            if arr[i] == 0: # Copy twice if arr[i] == 0\\n                if j < n: arr[j] = arr[i]\\n                j -= 1\\n            i -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505107,
                "title": "c-two-pass-shift-counter-fast-simple-explanation",
                "content": "First pass count `0s` in the array, this is our `shift` variable.\\nSecond reverse pass:\\n* If `arr[i] == 0` reduce `shift` count by 1.\\n* If `arr[i + shift]` within array boundary, then assign `arr[i + shift] = arr[i]` (shift element to it\\'s new position). If `arr[i] == 0` then also assign next element after `arr[i + shift]` to `0`, meaning `arr[i + shift + 1] = 0`, but don\\'t forget to check that `i + shift + 1` is withing array boundary.\\n\\n```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int shift = count(begin(arr), end(arr), 0), size = arr.size();\\n        for (int i = arr.size() - 1; i >= 0; i--) {\\n            if (!arr[i]) shift--;\\n            if (i + shift < size) {\\n                arr[i + shift] = arr[i];\\n                if (!arr[i] && i + shift + 1 < size)\\n                    arr[i + shift + 1] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int shift = count(begin(arr), end(arr), 0), size = arr.size();\\n        for (int i = arr.size() - 1; i >= 0; i--) {\\n            if (!arr[i]) shift--;\\n            if (i + shift < size) {\\n                arr[i + shift] = arr[i];\\n                if (!arr[i] && i + shift + 1 < size)\\n                    arr[i + shift + 1] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314126,
                "title": "python-o-n-time-o-1-space",
                "content": "```\\n# it requires us to do it in place, so we can\\'t use extra space here\\n# we can do it in 2 passes, the first pass record the count of 0s as shifts\\n# the second pass put the shifted elements in the right spot and put 0s in the right spot\\n# e.g, [1,0,2,3,0,4,5,0] will be extended as [1,0,0,2,3,0,0,4],5,0,0, only the first 8 elememnts\\n# fit in the array\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        shift = 0\\n        l = len(arr)\\n        for i in range(l):\\n            if arr[i] == 0:\\n                shift += 1\\n        for i in range(l-1, -1, -1):\\n            # put the shifted number in the right spot\\n            if i + shift < l:\\n                arr[i+shift] = arr[i]\\n            # if we meet a 0, we need to duplicate 0\\n            if arr[i] == 0:\\n                shift -= 1\\n                if i + shift < l:\\n                    arr[i+shift] = 0\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# it requires us to do it in place, so we can\\'t use extra space here\\n# we can do it in 2 passes, the first pass record the count of 0s as shifts\\n# the second pass put the shifted elements in the right spot and put 0s in the right spot\\n# e.g, [1,0,2,3,0,4,5,0] will be extended as [1,0,0,2,3,0,0,4],5,0,0, only the first 8 elememnts\\n# fit in the array\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        shift = 0\\n        l = len(arr)\\n        for i in range(l):\\n            if arr[i] == 0:\\n                shift += 1\\n        for i in range(l-1, -1, -1):\\n            # put the shifted number in the right spot\\n            if i + shift < l:\\n                arr[i+shift] = arr[i]\\n            # if we meet a 0, we need to duplicate 0\\n            if arr[i] == 0:\\n                shift -= 1\\n                if i + shift < l:\\n                    arr[i+shift] = 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353153,
                "title": "javascript-simple-solution",
                "content": "```\\nvar duplicateZeros = function(arr) {\\n    \\n    for (var i=0; i<arr.length; i++) {\\n        if (arr[i] === 0) {\\n            arr.splice(i, 0, 0);\\n            arr.pop();\\n            i+=1\\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    \\n    for (var i=0; i<arr.length; i++) {\\n        if (arr[i] === 0) {\\n            arr.splice(i, 0, 0);\\n            arr.pop();\\n            i+=1\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 312751,
                "title": "java-from-a-beginner-programmer",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i = 0; i < arr.length; i++){\\n            if(arr[i] == 0){\\n                shift(arr,i+1);\\n                if(i != arr.length-1){\\n                arr[i+1] = 0;\\n                    i++;\\n                }\\n            }\\n            }\\n        }\\n    public static void shift(int[] arr, int index){\\n        for(int i = arr.length-1; i > index; i--){\\n            arr[i] = arr[i-1];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i = 0; i < arr.length; i++){\\n            if(arr[i] == 0){\\n                shift(arr,i+1);\\n                if(i != arr.length-1){\\n                arr[i+1] = 0;\\n                    i++;\\n                }\\n            }\\n            }\\n        }\\n    public static void shift(int[] arr, int index){\\n        for(int i = arr.length-1; i > index; i--){\\n            arr[i] = arr[i-1];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399944,
                "title": "c-32ms-faster-than-40-04-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i=0; i<arr.size();++i){\\n            if(arr[i]==0){\\n                arr.pop_back();\\n                arr.insert(arr.begin()+i,0);\\n                ++i;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i=0; i<arr.size();++i){\\n            if(arr[i]==0){\\n                arr.pop_back();\\n                arr.insert(arr.begin()+i,0);\\n                ++i;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408059,
                "title": "python-simple-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef duplicateZeros(self, arr: List[int]) -> None:\\n\\t\\t\\ti = 0\\n\\t\\t\\tn = len(arr)\\n\\t\\t\\twhile(i<n):\\n\\t\\t\\t\\tif arr[i]==0:\\n\\t\\t\\t\\t\\tarr.pop()\\n\\t\\t\\t\\t\\tarr.insert(i,0)\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\ti+=1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef duplicateZeros(self, arr: List[int]) -> None:\\n\\t\\t\\ti = 0\\n\\t\\t\\tn = len(arr)\\n\\t\\t\\twhile(i<n):\\n\\t\\t\\t\\tif arr[i]==0:\\n\\t\\t\\t\\t\\tarr.pop()\\n\\t\\t\\t\\t\\tarr.insert(i,0)\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\ti+=1",
                "codeTag": "Java"
            },
            {
                "id": 884016,
                "title": "easy-to-understand-no-extra-space-java",
                "content": "```\\n        int n = arr.length;\\n        for(int i = 0; i<arr.length; i++) {\\n            if(arr[i] ==0) {\\n                int j;\\n                for(j = n-2; j>=i+1; j--) {\\n                    arr[j+1] = arr[j];\\n                }\\n                arr[j+1] = 0;\\n                i++;\\n            }\\n        }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n        int n = arr.length;\\n        for(int i = 0; i<arr.length; i++) {\\n            if(arr[i] ==0) {\\n                int j;\\n                for(j = n-2; j>=i+1; j--) {\\n                    arr[j+1] = arr[j];\\n                }\\n                arr[j+1] = 0;\\n                i++;\\n            }\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1612544,
                "title": "very-easy-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                for(int j=arr.size()-1;j>=i+1;j--)\\n                {\\n                    arr[j]=arr[j-1];\\n                }\\n                i=i+1;\\n            }\\n        }    \\n    }\\n};\\n\\npls upvote if it was helpful :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 316627,
                "title": "java-solution-two-pass-and-o-1-space",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int count = 0;\\n        for(int i : arr) {\\n            if(i == 0) {\\n                count++;\\n            }\\n        }\\n        int len = arr.length;\\n        for(int i = len - 1; i >= 0; i--) {\\n            int temp = i + count;\\n            if(temp < len) {\\n                arr[temp] = arr[i];\\n            }\\n            if(arr[i] == 0) {\\n                count--;\\n                temp = i + count;\\n                if(temp < len) {\\n                    arr[temp] = arr[i];\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int count = 0;\\n        for(int i : arr) {\\n            if(i == 0) {\\n                count++;\\n            }\\n        }\\n        int len = arr.length;\\n        for(int i = len - 1; i >= 0; i--) {\\n            int temp = i + count;\\n            if(temp < len) {\\n                arr[temp] = arr[i];\\n            }\\n            if(arr[i] == 0) {\\n                count--;\\n                temp = i + count;\\n                if(temp < len) {\\n                    arr[temp] = arr[i];\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319872,
                "title": "simple-java-solution-with-a-queue-100-memory",
                "content": "I have used the default LinkedList implementation from java (which could be used as a queue)\\n\\n```\\npublic void duplicateZeros(int[] arr) {\\n\\tLinkedList<Integer> queue=new LinkedList<Integer>();  \\n\\tfor(int i = 0; i < arr.length; i++) {\\n\\t\\tqueue.add(arr[i]);\\n\\t\\tif(arr[i] == 0) {\\n\\t\\t\\t//add another 0\\n\\t\\t\\tqueue.add(arr[i]);\\n\\t\\t}\\n\\t\\tarr[i] = queue.poll();\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic void duplicateZeros(int[] arr) {\\n\\tLinkedList<Integer> queue=new LinkedList<Integer>();  \\n\\tfor(int i = 0; i < arr.length; i++) {\\n\\t\\tqueue.add(arr[i]);\\n\\t\\tif(arr[i] == 0) {\\n\\t\\t\\t//add another 0\\n\\t\\t\\tqueue.add(arr[i]);\\n\\t\\t}\\n\\t\\tarr[i] = queue.poll();\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2127380,
                "title": "java-two-approaches-explained-with-codes",
                "content": "```\\n/*\\n     * Naive Approach:-\\n     * (1) Traverse array till length-1.\\n     * (2) If the element where you current at is zero then shift all the elements\\n     * including zero to one step ahead.\\n     * (3) Don\\'t forget increment the pointer by 1 else array will filled by 0s.\\n     * Time Complexity = O(n^2) for traversing & shifting.\\n     * Space Complexity = 0(1).\\n     */\\n\\n    static void duplicateZeros(int[] arr) {\\n        int n = arr.length;\\n        for (int i = 0; i < n - 1; i++) { // Traversing the array.\\n            if (arr[i] == 0) {\\n                for (int j = n - 2; j >= i; j--) {\\n                    arr[j + 1] = arr[j]; // Shifting The elements\\n                }\\n                i++; // incrementing i by 1\\n            }\\n        }\\n    }\\n\\n    /*\\n     * Better Approach:-\\n     * (1) Calculate the number of zeros in array.\\n     * (2) Create two pointers one is pointing to length-1 & other is pointing to\\n     * length+zeros-1.\\n     * (3) Start modifying array from back.\\n     * Time Complexity = O(n).\\n     * Space Complexity = 0(1).\\n     */\\n\\n    static void duplicateZeros(int[] arr) {\\n        int n = arr.length, count = 0;\\n\\n        for (int num : arr) {\\n            if (num == 0) {\\n                count++;\\n            }\\n        }\\n        int i = n - 1;\\n        int j = n + count - 1;\\n\\n        while (i >= 0 && j >= 0) {\\n\\n            if (arr[i] != 0) {\\n                if (j < n) {\\n                    arr[j] = arr[i];\\n                }\\n\\n            } else {\\n                if (j < n) {\\n                    arr[j] = arr[i];\\n                }\\n                j--;\\n                if (j < n) {\\n                    arr[j] = arr[i];\\n                }\\n            }\\n\\n            i--;\\n            j--;\\n        }\\n    }\\n\\t\\n\\tPlease Upvote if you find it helpful!\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n     * Naive Approach:-\\n     * (1) Traverse array till length-1.\\n     * (2) If the element where you current at is zero then shift all the elements\\n     * including zero to one step ahead.\\n     * (3) Don\\'t forget increment the pointer by 1 else array will filled by 0s.\\n     * Time Complexity = O(n^2) for traversing & shifting.\\n     * Space Complexity = 0(1).\\n     */\\n\\n    static void duplicateZeros(int[] arr) {\\n        int n = arr.length;\\n        for (int i = 0; i < n - 1; i++) { // Traversing the array.\\n            if (arr[i] == 0) {\\n                for (int j = n - 2; j >= i; j--) {\\n                    arr[j + 1] = arr[j]; // Shifting The elements\\n                }\\n                i++; // incrementing i by 1\\n            }\\n        }\\n    }\\n\\n    /*\\n     * Better Approach:-\\n     * (1) Calculate the number of zeros in array.\\n     * (2) Create two pointers one is pointing to length-1 & other is pointing to\\n     * length+zeros-1.\\n     * (3) Start modifying array from back.\\n     * Time Complexity = O(n).\\n     * Space Complexity = 0(1).\\n     */\\n\\n    static void duplicateZeros(int[] arr) {\\n        int n = arr.length, count = 0;\\n\\n        for (int num : arr) {\\n            if (num == 0) {\\n                count++;\\n            }\\n        }\\n        int i = n - 1;\\n        int j = n + count - 1;\\n\\n        while (i >= 0 && j >= 0) {\\n\\n            if (arr[i] != 0) {\\n                if (j < n) {\\n                    arr[j] = arr[i];\\n                }\\n\\n            } else {\\n                if (j < n) {\\n                    arr[j] = arr[i];\\n                }\\n                j--;\\n                if (j < n) {\\n                    arr[j] = arr[i];\\n                }\\n            }\\n\\n            i--;\\n            j--;\\n        }\\n    }\\n\\t\\n\\tPlease Upvote if you find it helpful!\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462758,
                "title": "duplicate-zeros-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n/2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int i=0, n=arr.size();\\n        while(i<n)\\n        {\\n            if(arr[i]==0)\\n            {\\n                arr.insert(arr.begin()+i, 0);\\n                i += 2;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        arr.resize(n);\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/79186693-bccb-4a98-9624-bd73ce99e074_1682665502.374058.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int i=0, n=arr.size();\\n        while(i<n)\\n        {\\n            if(arr[i]==0)\\n            {\\n                arr.insert(arr.begin()+i, 0);\\n                i += 2;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        arr.resize(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162030,
                "title": "python-simple",
                "content": "```\\ndef duplicateZeros(self, arr: List[int]) -> None:\\n        i = 0\\n        \\n        while i < len(arr) - 1:\\n            if arr[i] == 0:\\n                arr.insert(i+1, 0)\\n                arr.pop()\\n                i += 2\\n            else:\\n                i += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef duplicateZeros(self, arr: List[int]) -> None:\\n        i = 0\\n        \\n        while i < len(arr) - 1:\\n            if arr[i] == 0:\\n                arr.insert(i+1, 0)\\n                arr.pop()\\n                i += 2\\n            else:\\n                i += 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 313225,
                "title": "different-python-solutions",
                "content": "Solution 1: straightforward solution with O(n) time and O(n) space\\n```\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        res = []\\n        for x in arr:\\n            res.append(x)\\n            if x == 0:\\n                res.append(x)\\n        for i in range(len(arr)):\\n            arr[i] = res[i]\\n```\\nSolution 2: creat a map: i <--> i + # zeros in arr[:i]\\n```\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        n = len(arr)\\n        zeros = 0\\n        i = 0\\n        mp = dict()\\n        while i + zeros < n:\\n            mp[i+zeros] = i\\n            if arr[i] == 0:\\n                zeros += 1\\n                mp[i+zeros] = i\\n            i += 1\\n        for i in range(n - 1, -1, -1):\\n            arr[i] = arr[mp[i]]\\n```\\nSolution 3: improved version of solution 2\\n```\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        n = len(arr)\\n        zeros = 0\\n        i = 0\\n        while i + zeros < n:\\n            zeros += arr[i] == 0\\n            i += 1\\n\\t\\t# i + zeros is at most n + 1\\n        i -= 1\\n        while zeros > 0:\\n            if i + zeros < n:\\n                arr[i+zeros] = arr[i]\\n            if arr[i] == 0:\\n                zeros -= 1\\n                arr[i+zeros] = arr[i]\\n            i -= 1\\n```",
                "solutionTags": [],
                "code": "```\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        res = []\\n        for x in arr:\\n            res.append(x)\\n            if x == 0:\\n                res.append(x)\\n        for i in range(len(arr)):\\n            arr[i] = res[i]\\n```\n```\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        n = len(arr)\\n        zeros = 0\\n        i = 0\\n        mp = dict()\\n        while i + zeros < n:\\n            mp[i+zeros] = i\\n            if arr[i] == 0:\\n                zeros += 1\\n                mp[i+zeros] = i\\n            i += 1\\n        for i in range(n - 1, -1, -1):\\n            arr[i] = arr[mp[i]]\\n```\n```\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        n = len(arr)\\n        zeros = 0\\n        i = 0\\n        while i + zeros < n:\\n            zeros += arr[i] == 0\\n            i += 1\\n\\t\\t# i + zeros is at most n + 1\\n        i -= 1\\n        while zeros > 0:\\n            if i + zeros < n:\\n                arr[i+zeros] = arr[i]\\n            if arr[i] == 0:\\n                zeros -= 1\\n                arr[i+zeros] = arr[i]\\n            i -= 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3101355,
                "title": "easy-python-solution-while",
                "content": "# Code\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        l = len(arr)\\n        i = 0\\n        while i < l:\\n            if arr[i] == 0:\\n                arr.insert(i+1, 0)\\n                arr.pop()\\n                i += 1\\n            i += 1               \\n```\\nDo upvote if you like the solution :)",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        l = len(arr)\\n        i = 0\\n        while i < l:\\n            if arr[i] == 0:\\n                arr.insert(i+1, 0)\\n                arr.pop()\\n                i += 1\\n            i += 1               \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648310,
                "title": "java-100-simple-2-steps-solution-explained",
                "content": "Simple solution:\\n1. Count number of zeros.\\n2. Iterate from end of the array,\\n\\ta. Calculate index where current element needs to be shifted.\\n\\tb. Shift current element if index lies within array.\\n\\tc. Check if current element is zero:\\n\\t\\ti. Assign zero to (index-1) to duplicate zero if (index-1) lies within array.\\n\\t\\tii. Decrease zero counter by 1.\\n\\t\\t\\nHope this helps!!! :)\\n\\n\\n```\\npublic void duplicateZeros(int[] arr) \\n    {\\n        int noOfZeros = 0;\\n        int n = arr.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i] == 0) noOfZeros++;\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int curIndex = i+noOfZeros;\\n            if(curIndex<n)\\n            {\\n                arr[curIndex] = arr[i];\\n            }\\n            if(arr[i] == 0)\\n            {\\n                if(curIndex-1 < n)\\n                {\\n                    arr[curIndex-1] = arr[i];\\n                }\\n                noOfZeros--;\\n            }\\n        } \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void duplicateZeros(int[] arr) \\n    {\\n        int noOfZeros = 0;\\n        int n = arr.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i] == 0) noOfZeros++;\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int curIndex = i+noOfZeros;\\n            if(curIndex<n)\\n            {\\n                arr[curIndex] = arr[i];\\n            }\\n            if(arr[i] == 0)\\n            {\\n                if(curIndex-1 < n)\\n                {\\n                    arr[curIndex-1] = arr[i];\\n                }\\n                noOfZeros--;\\n            }\\n        } \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 364373,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length;i++) {\\n        \\tif(arr[i]==0) {\\n        \\t\\tfor(int j=arr.length-1;j>i;j--) {\\n        \\t\\t\\tarr[j]=arr[j-1];\\n        \\t\\t}\\n        \\t\\ti++;\\n        \\t}\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length;i++) {\\n        \\tif(arr[i]==0) {\\n        \\t\\tfor(int j=arr.length-1;j>i;j--) {\\n        \\t\\t\\tarr[j]=arr[j-1];\\n        \\t\\t}\\n        \\t\\ti++;\\n        \\t}\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304795,
                "title": "python-efficient-one-line-code-95-and-85-1089",
                "content": "# Python One Liner <span>1L.py</span>\\nNeat and clean one line code\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        [arr.insert(i,0) or arr.pop() for i in range(len(arr)-1,-1,-1) if not arr[i]]\\n```\\n\\n\\n#### Lets look into breadcrumbs!!<br>\\n```python\\n[... for ... in ... if ...]\\n```\\nAnything which looks like something shown above is nothing but [conditional list comprehension](https://realpython.com/list-comprehension-python/#using-conditional-logic \"Real Python\")\\n```python\\narr.insert(i,0)\\n```\\nWell, above function inserts a new zero at ```i```th position. This function returns `None` on successful insertion.\\n```python\\narr.pop()\\n```\\nBut when inserted, the length of the array is one more than the original length. So we need to pop an element from the end.\\n```python\\narr.insert(i,0) or arr.pop()\\n```\\nSince we need to do two function calls, we need to use OR operator between function calls ([why not AND?](#q1), think for a bit on return object from `arr.insert()`).\\n```\\nfor i in range(len(arr)-1,-1,-1)\\n```\\nWe start iterating from the end of the list to avoid infinite insertion of zeros when first zero is encountered.\\n```python\\n# All the below statements are identical\\nif not arr[i]:\\nif arr[i]==0:\\nif arr[i]==None:\\n```\\nWhole point to the algorithm is to add a new zero whenever a zero is encountered. Right? (Well, partially yes)\\n\\n### Q&A\\n<h5 id=\"q1\">1. why not AND?</h5>\\n\\n`arr.insert()` returns `None` upon successful insertion. If we had used AND operator, because of python\\'s [short circuiting](https://stackoverflow.com/a/14892812 \"Stack Overflow\") of AND, the second function would never be executed which results in no elements being popped out and the answer being wrong.\\n### Performance\\n![image](https://assets.leetcode.com/users/images/e6606b28-a04b-4b99-a341-71f1c01b9bc1_1624969176.0958948.png)\\n<!---\\nSubmission time: SESSION_DELETED :(\\n-->",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        [arr.insert(i,0) or arr.pop() for i in range(len(arr)-1,-1,-1) if not arr[i]]\\n```\n```python\\n[... for ... in ... if ...]\\n```\n```python\\narr.insert(i,0)\\n```\n```i```\n```python\\narr.pop()\\n```\n```python\\narr.insert(i,0) or arr.pop()\\n```\n```\\nfor i in range(len(arr)-1,-1,-1)\\n```\n```python\\n# All the below statements are identical\\nif not arr[i]:\\nif arr[i]==0:\\nif arr[i]==None:\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051352,
                "title": "python3-simple-solution-with-explanation",
                "content": "Let\\'s walk through an example: `10230450`.\\n\\nFirst, we count `0`s in the array (`cnt`). In this case, `cnt == 3` => our array needs 3 extra slots for 3 extra `0`s: `10230450|xxx`. We modify the array from the end, and at each index, we copy the element at position `i` to position `i + cnt`. If the element is `0`, we duplicate it, and decrease `cnt`.\\n\\nThe array gets modified as follows:\\n`1023045`**0**`|xxx` -> `1023045xx`**00** (since we copy a 0, we double it.)\\n```102304```**5**```x|x00``` -> ```102304xx|```**5**```00```\\n```10230```**4**```xx|500``` -> ```10230xx```**4**```|500```\\n```1023```**0**```xx4|500``` -> ```1023x```**00**```4|500``` (again, copying a 0 so doubled.)\\n```102```**3**```x004|500``` -> ```102x```**3**```004|500```\\n```10```**2**```x3004|500``` -> ```10x```**2**```3004|500```\\n```1```**0**```x23004|500``` -> ```1```**00**```23004|500```\\nEnd result: ```10023004|500```. We now return everything up to right before the ```|```.\\n\\nBut how do we use no extra space? We simply do not need to copy the elements over if they would end up outside our original array. So the last 3 slots ```|500``` are simulated, but not actually copied over.\\n\\nTime: ```O(n)```. Space: ```O(1)``` (we traverse the array twice (once to count ```0```s, once more to move elements)\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        cnt = arr.count(0)\\n\\n        for i in reversed(range(len(arr))):\\n            if i + cnt < len(arr): arr[i + cnt] = arr[i]  # copy the number over to correct position\\n            if arr[i] == 0:\\n                cnt -= 1\\n                if i + cnt < len(arr): arr[i + cnt] = arr[i]  # copy again if the number is 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```102304```\n```x|x00```\n```102304xx|```\n```00```\n```10230```\n```xx|500```\n```10230xx```\n```|500```\n```1023```\n```xx4|500```\n```1023x```\n```4|500```\n```102```\n```x004|500```\n```102x```\n```004|500```\n```10```\n```x3004|500```\n```10x```\n```3004|500```\n```1```\n```x23004|500```\n```1```\n```23004|500```\n```10023004|500```\n```|```\n```|500```\n```O(n)```\n```O(1)```\n```0```\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        cnt = arr.count(0)\\n\\n        for i in reversed(range(len(arr))):\\n            if i + cnt < len(arr): arr[i + cnt] = arr[i]  # copy the number over to correct position\\n            if arr[i] == 0:\\n                cnt -= 1\\n                if i + cnt < len(arr): arr[i + cnt] = arr[i]  # copy again if the number is 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857654,
                "title": "java-duplicate-zeros-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n\\t\\tfor (int i = 0; i < arr.length - 1; i++) { //if we are on the last element it doesn\\'t matter if it is non-zero or not\\n        \\tif (arr[i] == 0) { //if we get a zero we shift everything from the back to the right by one\\n        \\t\\tfor (int j = arr.length - 1; j > i; j--) {\\n        \\t\\t\\tarr[j] = arr[j - 1]; \\n        \\t\\t}\\n                i++; //if we get a zero we need to shift \\'i\\' twice to avoid running into the zero we just duplicated\\n        \\t}\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n\\t\\tfor (int i = 0; i < arr.length - 1; i++) { //if we are on the last element it doesn\\'t matter if it is non-zero or not\\n        \\tif (arr[i] == 0) { //if we get a zero we shift everything from the back to the right by one\\n        \\t\\tfor (int j = arr.length - 1; j > i; j--) {\\n        \\t\\t\\tarr[j] = arr[j - 1]; \\n        \\t\\t}\\n                i++; //if we get a zero we need to shift \\'i\\' twice to avoid running into the zero we just duplicated\\n        \\t}\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1002778,
                "title": "o-n-easiest-solution-ever-if-u-finding-other-solution-difficult-plz-refer-this-and-upvote",
                "content": "/*\\n\\nconsider, int [] arr = {1,0,2,3,0,4,5,0};\\nwe need to add one duplicate zero followed by original one\\nso we will use, for loop to check for zeroes,and \\nwe will use extra space ArrayList just to add element of arr and extra zeroes, \\n\\n   if element is non zero we will add it as it is\\n   else we will add extra zero to our ArrayList\\n\\n    after above operation we will get ArrayList as {1,0,0,2,3,0,0,4,5,0,0};\\n    and we will also replace element at index i in arr with element at index i on ArrayList;\\n    arr[i]=ll.get(i);\\n\\nso we will get updated arr ={1,0,0,2,3,0,0,4};  \\n\\n*/\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n    \\n        List <Integer> ll = new ArrayList();\\n\\t    \\n        int index=0;                          \\n        //index increment as we add elements in List\\n\\t    \\n        for(int i=0;i<arr.length;i++) {\\t\\n\\t    \\t\\n            if(arr[i]==0) \\n            {\\n              ll.add(index++,arr[i]);      // zero from array\\n              ll.add(index++,0);           // add duplicate zero \\n            }\\n\\t    \\t\\n            else \\n            { ll.add(index++,arr[i]); }\\n\\t    \\t\\n            arr[i]=ll.get(i);             \\n        // we will update our Arrays form 0 , with respect to our Updated list\\n\\t    }   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n    \\n        List <Integer> ll = new ArrayList();\\n\\t    \\n        int index=0;                          \\n        //index increment as we add elements in List\\n\\t    \\n        for(int i=0;i<arr.length;i++) {\\t\\n\\t    \\t\\n            if(arr[i]==0) \\n            {\\n              ll.add(index++,arr[i]);      // zero from array\\n              ll.add(index++,0);           // add duplicate zero \\n            }\\n\\t    \\t\\n            else \\n            { ll.add(index++,arr[i]); }\\n\\t    \\t\\n            arr[i]=ll.get(i);             \\n        // we will update our Arrays form 0 , with respect to our Updated list\\n\\t    }   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044179,
                "title": "python-easy-solution-with-comment",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\narr = [1,0,2,3,0,4,5,0]\\n         ^\\n        (i=1) & i+2\\n        (insert)\\n    \\narr = [1,0,0,2,3,0,4,5,0]\\n             ^         ^      \\n            (i=3)     (pop) \\n\\narr = [1,0,0,2,3,0,4,5]\\n\\n```\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        \\n            <!-- use while loop to contorl \"i\" -->\\n        i=0\\n        while(i<len(arr)):\\n            if(arr[i]==0):\\n                arr.insert(i,0)\\n\\n            <!-- i+2 for skip the insert index -->\\n                i=i+2\\n                arr.pop()\\n            else:\\n                i=i+1\\n \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\narr = [1,0,2,3,0,4,5,0]\\n         ^\\n        (i=1) & i+2\\n        (insert)\\n    \\narr = [1,0,0,2,3,0,4,5,0]\\n             ^         ^      \\n            (i=3)     (pop) \\n\\narr = [1,0,0,2,3,0,4,5]\\n\\n```\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        \\n            <!-- use while loop to contorl \"i\" -->\\n        i=0\\n        while(i<len(arr)):\\n            if(arr[i]==0):\\n                arr.insert(i,0)\\n\\n            <!-- i+2 for skip the insert index -->\\n                i=i+2\\n                arr.pop()\\n            else:\\n                i=i+1\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024740,
                "title": "python-easy-to-understand-single-pass-brute-force-approach-optimal-in-place-solution",
                "content": "It took me some time to properly understand and get some intuition, so I wrote the brute force approach and the neatest solution as good as i could (hope I don\\'t overengineer it)... I hope this helps newcomers:\\n\\nFor the brute force approach we will do a single pass from left to right (0 to len(array) - 1). Every time we find a zero in the array, we will copy all values to the right. This copying right side is done from right to left in order to not to erase the next iteration value.\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n\\t\\tcurr_idx = 0\\n\\t\\twhile curr_idx < len(array):\\n\\t\\t    if arr[curr_idx] == 0:\\n\\t\\t        self.copyRightSide(arr, curr_idx)\\n\\t\\t\\t    # We copied the right side including the current value, so the next idx would be the value of the curr_idx and we would get an infinite loop\\n\\t\\t\\t    curr_idx += 1\\n\\t        curr_idx += 1\\n\\n    def copyRightSide(self, arr: List[int], idx) -> None:\\n    \"\"\"   \\n    Insert an element at index idx and keep all values to the right aligned.\\n    E.g. \\n       copyRightSide([1, 0, 3, 7, 8, 5], idx=2) will yield [1, 0, 3, 3, 7, 8, 5]\\n\\t\"\"\"\\n   \\n    for curr_idx in range(len(arr) - 1, idx, -1):\\n       arr[curr_idx] = arr[curr_idx - 1]\\n```\\n\\nThe good thing about the approach above is that it\\'s straight forward and we do not have to consider the edge cases for many zeros. The problem though is that we\\'re iterating from left to right, copying the array, finding the next zero, and recopying elements that were already shifted. This is computationally expensive.\\n\\nAs shown in the solution, a better approach would be to do two passes: first count the amount of zeroes `total_zeroes`, then do another pass from right to left. \\nWe will effectively move the values in the array further to the right. The amount of spaces to the right that are shifted is the idx + amount of zeroes we found so far. That is, it holds `new_idx = curr_idx + total_zeroes` for every iteration. When we find a zero, we reduce the count of `total_zeroes` and recopy the same element a second time.\\nLet\\'s see what it looks like without having to worry about increasing the size of the array:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n\\t\\ttotal_zeroes = arr.count(0)\\n\\t\\t\\n\\t\\tlast_idx = len(arr) - 1\\n\\t\\tfor curr_idx in range(last_idx, -1, -1):\\n\\t\\t    \\n\\t\\t\\t# This is the place where the curr_idx gets extended in the array\\n\\t\\t    new_idx = curr_idx + total_zeroes\\n\\t\\t\\t\\n\\t\\t\\tarr[new_idx] = arr[curr_idx]\\n\\t\\t\\t\\n\\t\\t    if arr[curr_idx] == 0:\\n\\t\\t\\t    total_zeroes -= 1\\n\\t\\t\\t    arr[new_idx] = arr[curr_idx]\\n```\\n\\nThis effectively turns an array like `[0, 1, 0, 2, 3, 4, 0]` into `[0, 0, 1, 0, 0, 2, 3, 4, 0, 0]`. In order to comply then with the constraint, we should check first if the new_idx would still be within the length of the array before copying the values to the right i.e. add `if new_idx <= last_idx` before every assignment ```arr[new_idx] = arr[curr_idx]```\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n\\t\\ttotal_zeroes = arr.count(0)\\n\\t\\t\\n\\t\\tlast_idx = len(arr) - 1\\n\\t\\tfor curr_idx in range(last_idx, -1, -1):\\n\\t\\t    \\n\\t\\t\\t# This is the place where the curr_idx gets extended in the array\\n\\t\\t    new_idx = curr_idx + total_zeroes\\n\\t\\t\\t\\n\\t\\t\\tif new_idx <= last_idx:\\n\\t\\t\\t    arr[new_idx] = arr[curr_idx]\\n\\t\\t\\t\\n\\t\\t    if arr[curr_idx] == 0:\\n\\t\\t\\t    total_zeroes -= 1\\n\\t\\t\\t\\tif new_idx <= last_idx:\\n\\t\\t\\t        arr[new_idx] = arr[curr_idx] # or simply arr[new_idx] = 0\\n```\\n\\nCredit for the last solution goes to @rokanor. See https://leetcode.com/problems/duplicate-zeros/discuss/322576/Python-3-real-in-place-solution\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n\\t\\tcurr_idx = 0\\n\\t\\twhile curr_idx < len(array):\\n\\t\\t    if arr[curr_idx] == 0:\\n\\t\\t        self.copyRightSide(arr, curr_idx)\\n\\t\\t\\t    # We copied the right side including the current value, so the next idx would be the value of the curr_idx and we would get an infinite loop\\n\\t\\t\\t    curr_idx += 1\\n\\t        curr_idx += 1\\n\\n    def copyRightSide(self, arr: List[int], idx) -> None:\\n    \"\"\"   \\n    Insert an element at index idx and keep all values to the right aligned.\\n    E.g. \\n       copyRightSide([1, 0, 3, 7, 8, 5], idx=2) will yield [1, 0, 3, 3, 7, 8, 5]\\n\\t\"\"\"\\n   \\n    for curr_idx in range(len(arr) - 1, idx, -1):\\n       arr[curr_idx] = arr[curr_idx - 1]\\n```\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n\\t\\ttotal_zeroes = arr.count(0)\\n\\t\\t\\n\\t\\tlast_idx = len(arr) - 1\\n\\t\\tfor curr_idx in range(last_idx, -1, -1):\\n\\t\\t    \\n\\t\\t\\t# This is the place where the curr_idx gets extended in the array\\n\\t\\t    new_idx = curr_idx + total_zeroes\\n\\t\\t\\t\\n\\t\\t\\tarr[new_idx] = arr[curr_idx]\\n\\t\\t\\t\\n\\t\\t    if arr[curr_idx] == 0:\\n\\t\\t\\t    total_zeroes -= 1\\n\\t\\t\\t    arr[new_idx] = arr[curr_idx]\\n```\n```arr[new_idx] = arr[curr_idx]```\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n\\t\\ttotal_zeroes = arr.count(0)\\n\\t\\t\\n\\t\\tlast_idx = len(arr) - 1\\n\\t\\tfor curr_idx in range(last_idx, -1, -1):\\n\\t\\t    \\n\\t\\t\\t# This is the place where the curr_idx gets extended in the array\\n\\t\\t    new_idx = curr_idx + total_zeroes\\n\\t\\t\\t\\n\\t\\t\\tif new_idx <= last_idx:\\n\\t\\t\\t    arr[new_idx] = arr[curr_idx]\\n\\t\\t\\t\\n\\t\\t    if arr[curr_idx] == 0:\\n\\t\\t\\t    total_zeroes -= 1\\n\\t\\t\\t\\tif new_idx <= last_idx:\\n\\t\\t\\t        arr[new_idx] = arr[curr_idx] # or simply arr[new_idx] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589488,
                "title": "go-simple-solution-beats-100-100-o-n-complexity-o-1-space",
                "content": "```go\\nfunc duplicateZeros(arr []int)  {\\n    zeros := 0\\n\\n    for _, v := range arr {\\n        if v == 0 {\\n            zeros++\\n        }\\n    }\\n\\n    for i := len(arr) - 1; i >= 0; i-- {\\n        if arr[i] == 0 {\\n            if zeros + i < len(arr) {\\n                arr[zeros + i] = 0\\n            }\\n            \\n            if zeros - 1 + i < len(arr) {\\n                arr[zeros - 1 + i] = 0\\n            }\\n            \\n            zeros--\\n        } else if i + zeros < len(arr) {\\n            arr[zeros + i] = arr[i]\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc duplicateZeros(arr []int)  {\\n    zeros := 0\\n\\n    for _, v := range arr {\\n        if v == 0 {\\n            zeros++\\n        }\\n    }\\n\\n    for i := len(arr) - 1; i >= 0; i-- {\\n        if arr[i] == 0 {\\n            if zeros + i < len(arr) {\\n                arr[zeros + i] = 0\\n            }\\n            \\n            if zeros - 1 + i < len(arr) {\\n                arr[zeros - 1 + i] = 0\\n            }\\n            \\n            zeros--\\n        } else if i + zeros < len(arr) {\\n            arr[zeros + i] = arr[i]\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 543558,
                "title": "very-simple-js-solution-memory-less-than-100",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {void} Do not return anything, modify arr in-place instead.\\n */\\nvar duplicateZeros = function(arr) {\\n    for (i = 0; i < arr.length; i++) {\\n        if (arr[i] == 0) {\\n            arr.splice(i, 0, 0);\\n            arr.pop();\\n            i++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {void} Do not return anything, modify arr in-place instead.\\n */\\nvar duplicateZeros = function(arr) {\\n    for (i = 0; i < arr.length; i++) {\\n        if (arr[i] == 0) {\\n            arr.splice(i, 0, 0);\\n            arr.pop();\\n            i++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4094396,
                "title": "two-simple-java-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code1\\n```Java\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int length = arr.length;\\n        int zeros = 0;\\n\\n        for (int i = 0; i < length; i++) {\\n            if (arr[i] == 0) {\\n                zeros++;\\n            }\\n        }\\n\\n        int lastIndex = length - 1;\\n        int newIndex = length - 1 + zeros;\\n\\n        while (lastIndex >= 0) {\\n            if (newIndex < length) {\\n                arr[newIndex] = arr[lastIndex];\\n            }\\n\\n            if (arr[lastIndex] == 0) {\\n                newIndex--;\\n\\n                if (newIndex < length) {\\n                    arr[newIndex] = 0;\\n                }\\n            }\\n\\n            lastIndex--;\\n            newIndex--;\\n        }\\n    }\\n}\\n```\\n\\n\\n# Code2\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int length = arr.length;\\n\\n        for (int i = 0; i < length ; i++)\\n        {\\n            if (arr[i] == 0 && i+1 < length)\\n            {\\n                for (int j = length - 1; j > i+1; j--)\\n                {\\n                    int temp = arr[j-1];\\n                    arr[j] = temp;\\n                }\\n                arr[i+1] = 0;\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/8cefe933-b2ba-4b42-801b-1736daaf39b0_1695761536.3744702.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int length = arr.length;\\n        int zeros = 0;\\n\\n        for (int i = 0; i < length; i++) {\\n            if (arr[i] == 0) {\\n                zeros++;\\n            }\\n        }\\n\\n        int lastIndex = length - 1;\\n        int newIndex = length - 1 + zeros;\\n\\n        while (lastIndex >= 0) {\\n            if (newIndex < length) {\\n                arr[newIndex] = arr[lastIndex];\\n            }\\n\\n            if (arr[lastIndex] == 0) {\\n                newIndex--;\\n\\n                if (newIndex < length) {\\n                    arr[newIndex] = 0;\\n                }\\n            }\\n\\n            lastIndex--;\\n            newIndex--;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int length = arr.length;\\n\\n        for (int i = 0; i < length ; i++)\\n        {\\n            if (arr[i] == 0 && i+1 < length)\\n            {\\n                for (int j = length - 1; j > i+1; j--)\\n                {\\n                    int temp = arr[j-1];\\n                    arr[j] = temp;\\n                }\\n                arr[i+1] = 0;\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951028,
                "title": "basic-approach-easy-solution",
                "content": "# Intuition\\nCreated a temp vector in which elements were pushed according to constraints. But during copying , only limited length was allowed to copy.\\n\\n# Approach\\nCreate a temp vector which accepts \\'0\\' twice and nonzero elements single time. Just copy the elements only till length of arr.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        vector<int> temp;\\n        for(int i = 0; i<arr.size();i++){\\n            if(arr[i] == 0){\\n                temp.push_back(0);\\n                temp.push_back(0);\\n            }\\n            else temp.push_back(arr[i]);\\n        }\\n        for(int i = 0;i<arr.size();i++){\\n            arr[i]=temp[i];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        vector<int> temp;\\n        for(int i = 0; i<arr.size();i++){\\n            if(arr[i] == 0){\\n                temp.push_back(0);\\n                temp.push_back(0);\\n            }\\n            else temp.push_back(arr[i]);\\n        }\\n        for(int i = 0;i<arr.size();i++){\\n            arr[i]=temp[i];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799546,
                "title": "javascript-o-n-beats-90-easy",
                "content": "# Intuition\\nFrequence counter\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {void} Do not return anything, modify arr in-place instead.\\n */\\nvar duplicateZeros = function (arr) {\\n  const newArr = [];\\n  for (let i = 0; i < arr.length; i++) {\\n    newArr.push(arr[i]);\\n    arr[i] === 0 && newArr.push(0);\\n  }\\n  for (let i = 0; i < arr.length; i++) {\\n    arr[i] = newArr[i];\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {void} Do not return anything, modify arr in-place instead.\\n */\\nvar duplicateZeros = function (arr) {\\n  const newArr = [];\\n  for (let i = 0; i < arr.length; i++) {\\n    newArr.push(arr[i]);\\n    arr[i] === 0 && newArr.push(0);\\n  }\\n  for (let i = 0; i < arr.length; i++) {\\n    arr[i] = newArr[i];\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2496025,
                "title": "simple-python-solution",
                "content": "What the code does\\n1. Iterates through the array.\\n2. If the current element is 0, removes the last element from the array and Insert 0 at the current index.\\n4. Increment the index by 2.\\n5. If the current element is not 0, increment the index by 1\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0: \\n                arr.pop()\\n                arr.insert(i, 0)\\n                i += 2\\n            else:\\n                i += 1\\n```\\n\\nTime complexity is O(n) as it will iterate over the entire array and space complexity is O(1) as we are only inserting and deleting elements from the array.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0: \\n                arr.pop()\\n                arr.insert(i, 0)\\n                i += 2\\n            else:\\n                i += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364453,
                "title": "with-explanation-comments-time-67-ms-32-33-space-9-5-mb-99-62",
                "content": "**Like it? ->Upvote please!**\\n\\n**Solution 1:**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        \\n        //loop over the whole array elemenst\\n        for(int i=0;i<arr.size();i++){\\n            //if the current one is 0\\n            if(arr[i]==0){\\n                //remove one element from the last\\n                arr.pop_back();\\n                //insert 0 in the next position after this 0\\n                arr.insert(arr.begin()+i,0);\\n                //move an extra step, skip the new zero element\\n                i++;\\n            }\\n        }\\n    }\\n};\\n\\'\\'\\'\\n\\n**Solution 2: **\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<arr.size();i++)\\n            //if the current one is 0\\n            if(arr[i]==0){\\n                //shift elements from the last to the current element\\n                for(int j=arr.size()-1;j!=i;j--)\\n                    arr[j]=arr[j-1];\\n                    \\n                //move an extra step, skip the new zero element\\n                i++;\\n            }\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        \\n        //loop over the whole array elemenst\\n        for(int i=0;i<arr.size();i++){\\n            //if the current one is 0\\n            if(arr[i]==0){\\n                //remove one element from the last\\n                arr.pop_back();\\n                //insert 0 in the next position after this 0\\n                arr.insert(arr.begin()+i,0);\\n                //move an extra step, skip the new zero element\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1486534,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==0){\\n                for(int j=arr.length-1;j>i;j--){\\n                    arr[j]=arr[j-1];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==0){\\n                for(int j=arr.length-1;j>i;j--){\\n                    arr[j]=arr[j-1];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315352,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        j=0\\n        while j<len(arr)-1:\\n            if arr[j] == 0:\\n                arr[j+1:] = [0]+arr[j+1:-1]\\n                j+=2\\n            else:\\n                j+=1\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        j=0\\n        while j<len(arr)-1:\\n            if arr[j] == 0:\\n                arr[j+1:] = [0]+arr[j+1:-1]\\n                j+=2\\n            else:\\n                j+=1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607097,
                "title": "java-faster-than-99-34-solution",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int length = arr.length;\\n        int[] res = new int[length];\\n        int j = 0;\\n        \\n        for (int i = 0; i < length && j < length; i++){\\n            if (arr[i] != 0){\\n                res[j] = arr[i];\\n            } else {\\n                j++;\\n            }\\n            j++;\\n        }\\n        \\n        for (int i = 0; i < length; i++){\\n            arr[i] = res[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int length = arr.length;\\n        int[] res = new int[length];\\n        int j = 0;\\n        \\n        for (int i = 0; i < length && j < length; i++){\\n            if (arr[i] != 0){\\n                res[j] = arr[i];\\n            } else {\\n                j++;\\n            }\\n            j++;\\n        }\\n        \\n        for (int i = 0; i < length; i++){\\n            arr[i] = res[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148874,
                "title": "simple-python-sol-with-detailed-explanation",
                "content": "\\n        i = 0\\n        \\n        while i <len(arr): # coz index will be out of range as we are poping the last ele\\n            \\n            # although we the length remains same but we are inserting at i+1  so we need to keep i < len(arr)\\n            \\n            if arr[i]!=0:\\n                i+=1\\n                \\n            else:\\n                arr.insert(i+1, 0) # insert (1 st parameter as the position and then val u want to insert)\\n                \\n                i+=2 # coz we have duplicated 0 in next place \\n                arr.pop()",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "\\n        i = 0\\n        \\n        while i <len(arr): # coz index will be out of range as we are poping the last ele\\n            \\n            # although we the length remains same but we are inserting at i+1  so we need to keep i < len(arr)\\n            \\n            if arr[i]!=0:\\n                i+=1\\n                \\n            else:\\n                arr.insert(i+1, 0) # insert (1 st parameter as the position and then val u want to insert)\\n                \\n                i+=2 # coz we have duplicated 0 in next place \\n                arr.pop()",
                "codeTag": "Unknown"
            },
            {
                "id": 781693,
                "title": "c-one-pass-with-a-queue",
                "content": "Using a queue allows us to remember the elements we need to shift in the right order. \\nWe go through the list, and we add the current element in the queue, if it\\'s a zero we add a zero at the end of the queue. The current element is replaced by the first element of the queue.\\n\\n```\\n    void duplicateZeros(vector<int>& arr) {\\n        std::queue<int> q; \\n        for ( int i{0}; i < arr.size(); i++ ) {\\n            q.push(arr[i]);\\n            if ( arr[i] == 0 )\\n                q.push(0);\\n            arr[i] = q.front();\\n            q.pop();\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void duplicateZeros(vector<int>& arr) {\\n        std::queue<int> q; \\n        for ( int i{0}; i < arr.size(); i++ ) {\\n            q.push(arr[i]);\\n            if ( arr[i] == 0 )\\n                q.push(0);\\n            arr[i] = q.front();\\n            q.pop();\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 529613,
                "title": "golang-98-faster",
                "content": "```\\nfunc duplicateZeros(arr []int)  {\\n    for i:= 0; i < len(arr); i++ {\\n        if arr[i] == 0 {\\n            copy(arr[i+1:], arr[i:])\\n            i++\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc duplicateZeros(arr []int)  {\\n    for i:= 0; i < len(arr); i++ {\\n        if arr[i] == 0 {\\n            copy(arr[i+1:], arr[i:])\\n            i++\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 528320,
                "title": "100-faster-100-less-memory",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        // Clone the current array as the source of inputs.\\n        int[] original = arr.clone();\\n        \\n        // Create two different counter, one for the original array\\n        // the other for the modified array.\\n        int cO = 0;\\n        int cA = 0;\\n        \\n        // Continue until the modified array counter\\n        // is equal to the length of array.\\n        while (cA < arr.length) {\\n            // Copy the current index of original array\\n            // to the current modified array.\\n            arr[cA] = original[cO];\\n            cA++;\\n            \\n            // Only if the current counter of array is still less than the modified array\\n            // and if the original counter points to a zero.\\n            if (cA < arr.length && original[cO] == 0) {\\n                arr[cA] = 0;\\n                cA++;\\n            }\\n            cO++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        // Clone the current array as the source of inputs.\\n        int[] original = arr.clone();\\n        \\n        // Create two different counter, one for the original array\\n        // the other for the modified array.\\n        int cO = 0;\\n        int cA = 0;\\n        \\n        // Continue until the modified array counter\\n        // is equal to the length of array.\\n        while (cA < arr.length) {\\n            // Copy the current index of original array\\n            // to the current modified array.\\n            arr[cA] = original[cO];\\n            cA++;\\n            \\n            // Only if the current counter of array is still less than the modified array\\n            // and if the original counter points to a zero.\\n            if (cA < arr.length && original[cO] == 0) {\\n                arr[cA] = 0;\\n                cA++;\\n            }\\n            cO++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362616,
                "title": "easy-arraylist-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n      ArrayList<Integer> ans = new ArrayList<>();\\n        for(int i = 0 ; i < arr.length ; i++){\\n            if(arr[i] != 0){\\n                ans.add(arr[i]);\\n            }else{\\n                ans.add(0);\\n                ans.add(0);\\n            }\\n        }\\n        for(int i = 0 ; i < arr.length ;i++){\\n            arr[i] = ans.get(i);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n      ArrayList<Integer> ans = new ArrayList<>();\\n        for(int i = 0 ; i < arr.length ; i++){\\n            if(arr[i] != 0){\\n                ans.add(arr[i]);\\n            }else{\\n                ans.add(0);\\n                ans.add(0);\\n            }\\n        }\\n        for(int i = 0 ; i < arr.length ;i++){\\n            arr[i] = ans.get(i);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777649,
                "title": "fast-easy-3-approaches-c-time-o-n-space-o-1",
                "content": "\\u2B50 Please upvote if you like the post \\u2B50\\n\\n---\\n\\n### Approach 1 - Brute Force\\n**Time Complexity :** O(n^2)\\n**Space Complexity :**  O(1)\\n**Explanation:**\\n1. Iterate over array\\n2. Check if element is 0\\n3. Shift all remaining elements to right by one\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        const int VALUE_ZERO = 0;\\n        const int ARRAY_LENGTH = arr.size();\\n        \\n        for(int i=0; i<ARRAY_LENGTH; i++){\\n            if(arr[i] != VALUE_ZERO)\\n                continue;\\n            \\n            for(int j=ARRAY_LENGTH-1; j>i; j--)\\n                arr[j] = arr[j-1];\\n            \\n            i++;\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n### Approach 2 - Queue\\n**Time Complexity :** O(n)\\n**Space Complexity :**  O(n)\\n**Explanation:**\\n1. Create a queue\\n2. Add element to queue\\n3. Check if element is zero\\n4. Then again add element to queue\\n5. Set frontmost elemnt of queue to array\\n6. Remove element from queue\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        const int VALUE_ZERO = 0;\\n        const int ARRAY_LENGTH = arr.size();\\n        queue<int> data;\\n    \\n        for(int index=0; index<ARRAY_LENGTH; index++){\\n            data.push(arr[index]);\\n            \\n            if(arr[index] == VALUE_ZERO)\\n                data.push(arr[index]);\\n            \\n            arr[index] = data.front();\\n            data.pop();\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n### Approach 3 - Two Pointers\\n**Time Complexity :** O(n)\\n**Space Complexity :**  O(1)\\n**Explanation:**\\n1. Set start to 0 and end to last index\\n2. Iterate over array until end\\n3. Decrement end occurance of 0\\n4. Later iterate over array in reverse until end pointer\\n5. Set end pointer value to current\\n6. Set previous index to 0 on occurence of 0 if start != end\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        const int VALUE_ZERO = 0;\\n        const int ARRAY_LENGTH = arr.size();\\n        \\n        int start = 0;\\n        int end = ARRAY_LENGTH-1;\\n        \\n        while(start < end){\\n            if(arr[start] == VALUE_ZERO)\\n                end--;\\n            start++;\\n        }\\n        \\n        for(int index=ARRAY_LENGTH-1; index>end; index--, end--){\\n            arr[index] = arr[end];\\n            \\n            if(arr[end] == VALUE_ZERO && start != end)\\n                arr[--index] = VALUE_ZERO;\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        const int VALUE_ZERO = 0;\\n        const int ARRAY_LENGTH = arr.size();\\n        \\n        for(int i=0; i<ARRAY_LENGTH; i++){\\n            if(arr[i] != VALUE_ZERO)\\n                continue;\\n            \\n            for(int j=ARRAY_LENGTH-1; j>i; j--)\\n                arr[j] = arr[j-1];\\n            \\n            i++;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        const int VALUE_ZERO = 0;\\n        const int ARRAY_LENGTH = arr.size();\\n        queue<int> data;\\n    \\n        for(int index=0; index<ARRAY_LENGTH; index++){\\n            data.push(arr[index]);\\n            \\n            if(arr[index] == VALUE_ZERO)\\n                data.push(arr[index]);\\n            \\n            arr[index] = data.front();\\n            data.pop();\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        const int VALUE_ZERO = 0;\\n        const int ARRAY_LENGTH = arr.size();\\n        \\n        int start = 0;\\n        int end = ARRAY_LENGTH-1;\\n        \\n        while(start < end){\\n            if(arr[start] == VALUE_ZERO)\\n                end--;\\n            start++;\\n        }\\n        \\n        for(int index=ARRAY_LENGTH-1; index>end; index--, end--){\\n            arr[index] = arr[end];\\n            \\n            if(arr[end] == VALUE_ZERO && start != end)\\n                arr[--index] = VALUE_ZERO;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572094,
                "title": "java-my-solution-easy",
                "content": "```\\nclass Solution {\\n\\n    public void duplicateZeros(int[] arr) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 0; i < arr.length ; i++) {\\n            if (arr[i] == 0) {\\n                list.add(0);\\n                list.add(0);\\n            } \\n            else list.add(arr[i]);\\n        }\\n\\n        for (int i = 0; i < arr.length; i++) arr[i] = list.get(i);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public void duplicateZeros(int[] arr) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 0; i < arr.length ; i++) {\\n            if (arr[i] == 0) {\\n                list.add(0);\\n                list.add(0);\\n            } \\n            else list.add(arr[i]);\\n        }\\n\\n        for (int i = 0; i < arr.length; i++) arr[i] = list.get(i);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523683,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        ArrayList<Integer> al=new ArrayList<>();\\n        int n=arr.length;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                al.add(0);\\n                al.add(0);\\n            }\\n            else al.add(arr[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n            arr[i]=al.get(i);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        ArrayList<Integer> al=new ArrayList<>();\\n        int n=arr.length;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                al.add(0);\\n                al.add(0);\\n            }\\n            else al.add(arr[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n            arr[i]=al.get(i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521942,
                "title": "javascript-solution",
                "content": "var duplicateZeros = function(arr) {\\n\\n    for(let i = 0; i<arr.length;i++){\\n        if(arr[i]===0){\\n            arr.pop(); \\n            arr.splice(i+1,0,0);\\n            i++\\n        }\\n    }\\n    return arr; \\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var duplicateZeros = function(arr) {\\n\\n    for(let i = 0; i<arr.length;i++){\\n        if(arr[i]===0){\\n            arr.pop(); \\n            arr.splice(i+1,0,0);\\n            i++\\n        }\\n    }\\n    return arr; \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2482397,
                "title": "c-two-pointer-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr)\\n    {\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                for(int j=arr.size()-1;j>=i+1;j--)\\n                {\\n                    arr[j]=arr[j-1];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr)\\n    {\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                for(int j=arr.size()-1;j>=i+1;j--)\\n                {\\n                    arr[j]=arr[j-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2342060,
                "title": "very-simple-python-solution",
                "content": "```\\nfrom typing import List\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i]==0:\\n                arr.insert(i+1,0)\\n                arr.pop()\\n                i+=1\\n            i+=1\\n            \\n```\\n\\nfrom typing import List Because in Python bversion above 3.9 we need to import Lists",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i]==0:\\n                arr.insert(i+1,0)\\n                arr.pop()\\n                i+=1\\n            i+=1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831220,
                "title": "easy-to-understand-js-solution",
                "content": "```\\nvar duplicateZeros = function(arr) {\\n    \\n    for(let i=arr.length - 1; i >= 0; i--) {\\n        if (arr[i] == 0) {\\n            for (let j = arr.length - 1; j > i; j--) {\\n                arr[j] = arr[j-1];\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    \\n    for(let i=arr.length - 1; i >= 0; i--) {\\n        if (arr[i] == 0) {\\n            for (let j = arr.length - 1; j > i; j--) {\\n                arr[j] = arr[j-1];\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1727461,
                "title": "c-stl",
                "content": "```c++\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i=0; i<n; i++){\\n            if(arr[i] == 0){\\n                arr.insert(arr.begin()+i, 0);\\n                i++;\\n            }\\n        }\\n        arr.resize(n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i=0; i<n; i++){\\n            if(arr[i] == 0){\\n                arr.insert(arr.begin()+i, 0);\\n                i++;\\n            }\\n        }\\n        arr.resize(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713111,
                "title": "java-python-o-n",
                "content": "Its easy to do in O(n2) , but once we know the relationship i.e how many places a non zero element has to jump then one pass is pretty easy\\n\\n![image](https://assets.leetcode.com/users/images/9802d8d1-cc87-471d-99a6-1e8d9e77d8b0_1642946094.5311093.png)\\nJava\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int[] count = new int[arr.length];\\n        int c=0;\\n        \\n        for( int i =0; i < arr.length; i++ ){\\n            if( arr[i] == 0 )   \\n                c++;\\n            count[i]=c;\\n        }\\n        \\n        for( int end = arr.length-1; end >= 0; end-- ){\\n            int newIndex = end + count[end];\\n            if( newIndex < arr.length )  // new index for the non zero element\\n                arr[newIndex]=arr[end];\\n            if( newIndex != end ) //to handle the case if we havent encountered a zero yet\\n                arr[end]=0;\\n        }\\n    }\\n}\\n```\\nPython\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        count = [0]*len(arr)\\n        c=0\\n        \\n        for i in range(0,len(arr)):\\n            if arr[i] == 0:\\n                c+=1\\n            count[i]=c\\n        \\n        for end in range(len(arr)-1,-1,-1):\\n            \\n            newIndex=end+count[end]\\n            \\n            if(newIndex < len(arr)):\\n                arr[newIndex]=arr[end]\\n            \\n            if(newIndex != end ):\\n                arr[end]=0\\n```\\nPlease **upvote** if you find it **useful**. Thanks.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int[] count = new int[arr.length];\\n        int c=0;\\n        \\n        for( int i =0; i < arr.length; i++ ){\\n            if( arr[i] == 0 )   \\n                c++;\\n            count[i]=c;\\n        }\\n        \\n        for( int end = arr.length-1; end >= 0; end-- ){\\n            int newIndex = end + count[end];\\n            if( newIndex < arr.length )  // new index for the non zero element\\n                arr[newIndex]=arr[end];\\n            if( newIndex != end ) //to handle the case if we havent encountered a zero yet\\n                arr[end]=0;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        count = [0]*len(arr)\\n        c=0\\n        \\n        for i in range(0,len(arr)):\\n            if arr[i] == 0:\\n                c+=1\\n            count[i]=c\\n        \\n        for end in range(len(arr)-1,-1,-1):\\n            \\n            newIndex=end+count[end]\\n            \\n            if(newIndex < len(arr)):\\n                arr[newIndex]=arr[end]\\n            \\n            if(newIndex != end ):\\n                arr[end]=0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498916,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==0){\\n                ans.push_back(0);   ans.push_back(0);\\n            }else{\\n                ans.push_back(arr[i]);\\n            }\\n            if(ans.size()>=arr.size()){\\n                break;\\n            }\\n        }\\n        if(ans.size()>arr.size()){\\n            ans.pop_back();\\n        }\\n        arr=ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==0){\\n                ans.push_back(0);   ans.push_back(0);\\n            }else{\\n                ans.push_back(arr[i]);\\n            }\\n            if(ans.size()>=arr.size()){\\n                break;\\n            }\\n        }\\n        if(ans.size()>arr.size()){\\n            ans.pop_back();\\n        }\\n        arr=ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1091573,
                "title": "runtime-20-ms-c-3-line-of-code",
                "content": "Runtime: 20 ms, faster than 52.11% of C++ online submissions for Duplicate Zeros.\\nMemory Usage: 9.7 MB, less than 84.61% of C++ online submissions for Duplicate Zeros.\\n\\n```\\nfor(int i=0; i<arr.size();++i){\\n            if(arr[i]==0){\\n                arr.pop_back();\\n                arr.insert(arr.begin()+i,0);\\n                ++i;\\n            }\\n        }\\n\\t\\t\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "Runtime: 20 ms, faster than 52.11% of C++ online submissions for Duplicate Zeros.\\nMemory Usage: 9.7 MB, less than 84.61% of C++ online submissions for Duplicate Zeros.\\n\\n```\\nfor(int i=0; i<arr.size();++i){\\n            if(arr[i]==0){\\n                arr.pop_back();\\n                arr.insert(arr.begin()+i,0);\\n                ++i;\\n            }\\n        }\\n\\t\\t\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 967135,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func duplicateZeros(_ arr: inout [Int]) {\\n        var index = 0\\n        while (index < arr.count) {\\n            if arr[index] == 0 {\\n                index += 1\\n                arr.insert(0, at: index)\\n                arr.removeLast()\\n            }\\n            index += 1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func duplicateZeros(_ arr: inout [Int]) {\\n        var index = 0\\n        while (index < arr.count) {\\n            if arr[index] == 0 {\\n                index += 1\\n                arr.insert(0, at: index)\\n                arr.removeLast()\\n            }\\n            index += 1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894022,
                "title": "c-solution",
                "content": "Runtime: 236 ms, faster than 97.45% of C# online submissions for Duplicate Zeros.\\nMemory Usage: 33.5 MB, less than 5.40% of C# online submissions for Duplicate Zeros.\\n\\n```\\nvar zeros = 0;\\nfor (var i = 0; i < arr.Length; i++)\\n\\tif (arr[i] == 0)\\n\\t\\tzeros++;\\n\\nvar len = arr.Length - 1;\\n\\nwhile (len > 0 && zeros > 0)\\n{\\n\\tif (len + zeros <= arr.Length - 1)\\n\\t\\tarr[len + zeros] = arr[len];\\n\\n\\tif (arr[len] == 0)\\n\\t\\tzeros--;\\n\\n\\tarr[len] = 0;\\n\\tlen--;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar zeros = 0;\\nfor (var i = 0; i < arr.Length; i++)\\n\\tif (arr[i] == 0)\\n\\t\\tzeros++;\\n\\nvar len = arr.Length - 1;\\n\\nwhile (len > 0 && zeros > 0)\\n{\\n\\tif (len + zeros <= arr.Length - 1)\\n\\t\\tarr[len + zeros] = arr[len];\\n\\n\\tif (arr[len] == 0)\\n\\t\\tzeros--;\\n\\n\\tarr[len] = 0;\\n\\tlen--;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 750040,
                "title": "javascript-two-pass",
                "content": "```\\nvar duplicateZeros = function (arr) {\\n    if (arr == null || arr.length == 0) throw new Error(\"illegal input\");\\n    //move in place, so no extra space\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] == 0) {\\n            //that means must remove last one in arr\\n            for (let j = arr.length - 1; j > i; j--) {\\n                arr[j] = arr[j - 1];\\n            }\\n            i++;\\n        }\\n        else {\\n            continue;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar duplicateZeros = function (arr) {\\n    if (arr == null || arr.length == 0) throw new Error(\"illegal input\");\\n    //move in place, so no extra space\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] == 0) {\\n            //that means must remove last one in arr\\n            for (let j = arr.length - 1; j > i; j--) {\\n                arr[j] = arr[j - 1];\\n            }\\n            i++;\\n        }\\n        else {\\n            continue;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 628470,
                "title": "simple-java-solution-ya-dig",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]==0){\\n                for(int j=arr.length-2; j>=i; j--){\\n                    arr[j+1] = arr[j];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]==0){\\n                for(int j=arr.length-2; j>=i; j--){\\n                    arr[j+1] = arr[j];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 421807,
                "title": "python-solution-72-ms-faster-than-99-39-and-13-5-mb-less-than-100-00",
                "content": "```\\ndef duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        \\n        l = len(arr)\\n        i = 0\\n        \\n        while i < len(arr):\\n            if arr[i] == 0:\\n                i += 1\\n                arr.pop()\\n                arr.insert(i, 0)\\n            i += 1",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        \\n        l = len(arr)\\n        i = 0\\n        \\n        while i < len(arr):\\n            if arr[i] == 0:\\n                i += 1\\n                arr.pop()\\n                arr.insert(i, 0)\\n            i += 1",
                "codeTag": "Python3"
            },
            {
                "id": 313208,
                "title": "space-o-1-detailed-explanation",
                "content": "This solution is extended on @lee215 \\'s brilliant solution.\\nTo understand the algorithm better, let\\'s look at the following example:\\n\\nThe given array is\\n`[1, 0, 2, 3, 0, 4, 5, 0]`\\n\\n`[1, 0, 0, 2, 3, 0, 0, 4, 5, 0, 0]` // (A) Duplicating zeros\\n\\n`[1, 0, 0, 2, 3, 0, 0, 4 ] ` // (B) Then cut off the array based on the original array size\\n<br>\\nWe can then generalize the idea above to the following steps:\\n\\nWe can have two pointers - \\npt1 = arr.length - 1\\npt2 = the index after duplicating zeros\\n\\nIterate both pointers from back to front\\nOnce `pt2 < arr.length`, we start assigning `arr[pt1]` to the new index `arr[pt2]`,\\nand duplicate zeros on the way.\\n\\n<br>\\nThe whole process should look like this: \\n\\n...........................................pt1\\n`[1, 0, 2, 3, 0, 4, 5, 0]`\\n\\n............................................................pt2\\n`[1, 0, 0, 2, 3, 0, 0, 4, 5, 0, 0]`\\n\\n\\narr[pt1] == 0, so decrement pt2 twice.\\n.....................................pt1\\n`[1, 0, 2, 3, 0, 4, 5, 0]`\\n.................................................pt2\\n`[1, 0, 0, 2, 3, 0, 0, 4, 5, 0, 0]`\\n\\narr[pt1] == 5.\\n\\n..............................pt1\\n`[1, 0, 2, 3, 0, 4, 5, 0]`\\n..........................................pt2\\n`[1, 0, 0, 2, 3, 0, 0, 4, 5, 0, 0]`\\n\\nNow, `pt2 < arr.length`, so we start assigning\\n\\nAssign 4\\n...............................\\u2193.........\\u2193\\n`[1, 0, 2, 3, 0, 4, 5, 4]`\\n\\nAssign 0\\n..........................\\u2193.........\\u2193\\n`[1, 0, 2, 3, 0, 4, 0, 4]`\\n\\n..........................\\u2193...\\u2193\\n`[1, 0, 2, 3, 0, 0, 0, 4]`\\n\\nAssign 3\\n....................\\u2193...\\u2193\\n`[1, 0, 2, 3, 3, 0, 0, 4]`\\n\\nAssign 2\\n..............\\u2193...\\u2193\\n`[1, 0, 2, 2, 3, 0, 0, 4]`\\n\\nAssign 0\\n........\\u2193...\\u2193\\n`[1, 0, 0, 2, 3, 0, 0, 4]`\\n\\n........\\u2193\\n`[1, 0, 0, 2, 3, 0, 0, 4]`\\n\\nAssign 1\\n\\u2193\\n`[1, 0, 0, 2, 3, 0, 0, 4]`\\n\\n\\nImplenmentation -\\n```\\npublic void duplicateZeros(int[] arr) {\\n\\n        int pt2 = 0; // figuring out pt2\\n        for(int i = 0; i < arr.length; i++){\\n            if (arr[i] == 0) pt2++;\\n            pt2++;\\n        }\\n        \\n        int pt1 = arr.length - 1;\\n        pt2--;\\n        while (pt1 >= 0){\\n            if (pt2 < arr.length) arr[pt2] = arr[pt1];// assign if pt2 is in range\\n            pt2--;\\n            if (arr[pt1] == 0){\\n                if (pt2 < arr.length) arr[pt2] = 0; // duplicate zeros\\n                pt2--;\\n            } \\n            pt1--;\\n        }\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic void duplicateZeros(int[] arr) {\\n\\n        int pt2 = 0; // figuring out pt2\\n        for(int i = 0; i < arr.length; i++){\\n            if (arr[i] == 0) pt2++;\\n            pt2++;\\n        }\\n        \\n        int pt1 = arr.length - 1;\\n        pt2--;\\n        while (pt1 >= 0){\\n            if (pt2 < arr.length) arr[pt2] = arr[pt1];// assign if pt2 is in range\\n            pt2--;\\n            if (arr[pt1] == 0){\\n                if (pt2 < arr.length) arr[pt2] = 0; // duplicate zeros\\n                pt2--;\\n            } \\n            pt1--;\\n        }\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 313118,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        x = 0\\n        while x < len(arr):\\n            if arr[x] == 0:\\n                arr.insert(x, 0)\\n                arr.pop(-1)\\n                x+=1\\n            x += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        x = 0\\n        while x < len(arr):\\n            if arr[x] == 0:\\n                arr.insert(x, 0)\\n                arr.pop(-1)\\n                x+=1\\n            x += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634221,
                "title": "c-solution-java-solution-beat-100-in-runtime-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe function scans the vector, identifies the positions where zeros need to be duplicated, shifts the elements accordingly, and inserts the duplicated zeros in the correct positions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialization of variables:\\n\\npos is initialized to 0, representing the position in the arr vector.\\nptr is initialized to 0, representing the index in the for loop.\\nFirst for loop:\\n\\nIt iterates over the elements of the arr vector using the index i.\\nIt also keeps track of the number of iterations in the ct variable.\\nInside the loop, it checks if the current element at index ct is equal to 0.\\nIf it is 0, it increments i by 1 to skip the next element.\\nOtherwise, it updates pos to the current value of ct and ptr to the current value of i.\\nSecond for loop:\\n\\nIt iterates backward starting from ptr and continues until index 0.\\nInside the loop, it assigns the value at index pos to the current element at index i.\\nIf the value at index pos is 0 and i is not 0, it decrements i by 1 and assigns 0 to the previous index.\\nIt then decrements pos to move to the previous element.\\nThird for loop:\\n\\nIt iterates over the elements of the arr vector starting from index ptr + 1.\\nInside the loop, it assigns 0 to each element.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the duplicateZeros function can be analyzed as follows:\\n\\nThe first for loop iterates over the elements of the arr vector once, so its time complexity is O(n), where n is the size of the vector.\\n\\nThe second for loop iterates backward from ptr to 0, which can have at most n iterations. Therefore, its time complexity is O(n).\\n\\nThe third for loop iterates over the elements from ptr + 1 to the end of the arr vector, which also has at most n iterations. Thus, its time complexity is O(n).\\n\\nAs a result, the overall time complexity of the function is O(n), where n is the size of the input vector arr.\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nRegarding space complexity, the function does not use any additional data structures that grow with the input size. It only uses a constant amount of extra space for the variables pos and ptr. Therefore, the space complexity of the function is O(1), indicating constant space usage.\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int pos = 0;  // Variable to track the position of the last non-zero element\\n        int ptr = 0;  // Variable to track the current index in the for loop\\n\\n        // First loop: Find positions for duplicating zeros and update `pos` and `ptr`\\n        for (int i = 0, ct = 0; i < arr.size(); i++, ct++) {\\n            if (arr[ct] == 0) {\\n                i++;  // Increment `i` to skip the next element when a zero is encountered\\n            } else {\\n                pos = ct;  // Update `pos` with the index of the last non-zero element\\n                ptr = i;   // Update `ptr` with the current index in the for loop\\n            }\\n        }\\n\\n        // Second loop: Perform duplication and shifting\\n        for (int i = ptr; i >= 0; i--) {\\n            arr[i] = arr[pos];  // Shift the elements to the right by assigning the value of the last non-zero element\\n\\n            // Duplicate zeros by inserting 0 in the correct position\\n            if (arr[pos] == 0 && i != 0) {\\n                arr[--i] = 0;  // Decrement `i` and assign 0 to the previous index\\n            }\\n\\n            pos--;  // Move to the previous non-zero element\\n        }\\n\\n        // Third loop: Set remaining elements to 0\\n        for (int i = ptr + 1; i < arr.size(); i++) {\\n            arr[i] = 0;  // Set the remaining elements to 0\\n        }\\n    }\\n};\\n\\n```\\n```Java []\\npublic class Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int pos = 0; // Variable to track the position of the last non-zero element\\n        int ptr = 0; // Variable to track the current index in the for loop\\n\\n        // First loop: Find positions for duplicating zeros and update `pos` and `ptr`\\n        for (int i = 0, ct = 0; i < arr.length; i++, ct++) {\\n            if (arr[ct] == 0) {\\n                i++; // Increment `i` to skip the next element when a zero is encountered\\n            } else {\\n                pos = ct; // Update `pos` with the index of the last non-zero element\\n                ptr = i;  // Update `ptr` with the current index in the for loop\\n            }\\n        }\\n\\n        // Second loop: Perform duplication and shifting\\n        for (int i = ptr; i >= 0; i--) {\\n            arr[i] = arr[pos]; // Shift the elements to the right by assigning the value of the last non-zero element\\n\\n            // Duplicate zeros by inserting 0 in the correct position\\n            if (arr[pos] == 0 && i != 0) {\\n                arr[--i] = 0; // Decrement `i` and assign 0 to the previous index\\n            }\\n\\n            pos--; // Move to the previous non-zero element\\n        }\\n\\n        // Third loop: Set remaining elements to 0\\n        for (int i = ptr + 1; i < arr.length; i++) {\\n            arr[i] = 0; // Set the remaining elements to 0\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int pos = 0;  // Variable to track the position of the last non-zero element\\n        int ptr = 0;  // Variable to track the current index in the for loop\\n\\n        // First loop: Find positions for duplicating zeros and update `pos` and `ptr`\\n        for (int i = 0, ct = 0; i < arr.size(); i++, ct++) {\\n            if (arr[ct] == 0) {\\n                i++;  // Increment `i` to skip the next element when a zero is encountered\\n            } else {\\n                pos = ct;  // Update `pos` with the index of the last non-zero element\\n                ptr = i;   // Update `ptr` with the current index in the for loop\\n            }\\n        }\\n\\n        // Second loop: Perform duplication and shifting\\n        for (int i = ptr; i >= 0; i--) {\\n            arr[i] = arr[pos];  // Shift the elements to the right by assigning the value of the last non-zero element\\n\\n            // Duplicate zeros by inserting 0 in the correct position\\n            if (arr[pos] == 0 && i != 0) {\\n                arr[--i] = 0;  // Decrement `i` and assign 0 to the previous index\\n            }\\n\\n            pos--;  // Move to the previous non-zero element\\n        }\\n\\n        // Third loop: Set remaining elements to 0\\n        for (int i = ptr + 1; i < arr.size(); i++) {\\n            arr[i] = 0;  // Set the remaining elements to 0\\n        }\\n    }\\n};\\n\\n```\n```Java []\\npublic class Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int pos = 0; // Variable to track the position of the last non-zero element\\n        int ptr = 0; // Variable to track the current index in the for loop\\n\\n        // First loop: Find positions for duplicating zeros and update `pos` and `ptr`\\n        for (int i = 0, ct = 0; i < arr.length; i++, ct++) {\\n            if (arr[ct] == 0) {\\n                i++; // Increment `i` to skip the next element when a zero is encountered\\n            } else {\\n                pos = ct; // Update `pos` with the index of the last non-zero element\\n                ptr = i;  // Update `ptr` with the current index in the for loop\\n            }\\n        }\\n\\n        // Second loop: Perform duplication and shifting\\n        for (int i = ptr; i >= 0; i--) {\\n            arr[i] = arr[pos]; // Shift the elements to the right by assigning the value of the last non-zero element\\n\\n            // Duplicate zeros by inserting 0 in the correct position\\n            if (arr[pos] == 0 && i != 0) {\\n                arr[--i] = 0; // Decrement `i` and assign 0 to the previous index\\n            }\\n\\n            pos--; // Move to the previous non-zero element\\n        }\\n\\n        // Third loop: Set remaining elements to 0\\n        for (int i = ptr + 1; i < arr.length; i++) {\\n            arr[i] = 0; // Set the remaining elements to 0\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057945,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func duplicateZeros(_ arr: inout [Int]) {\\n\\n        var i = 0\\n        \\n        while i < arr.count {\\n            if arr[i] == 0 {\\n                arr.insert(0, at: i)\\n                arr.removeLast()\\n                i += 2\\n            }\\n            else {\\n                i += 1\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func duplicateZeros(_ arr: inout [Int]) {\\n\\n        var i = 0\\n        \\n        while i < arr.count {\\n            if arr[i] == 0 {\\n                arr.insert(0, at: i)\\n                arr.removeLast()\\n                i += 2\\n            }\\n            else {\\n                i += 1\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838928,
                "title": "python-one-pass-with-o-n-space-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a new pointer to record index with duplicated zero.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a pointer `j=0`. When we encounter a `0`, add j twice.\\nOne thing to note is that in case of out of bound error, break is necessary in the for loop.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        j = 0\\n        for n in arr[:]:\\n            if n == 0:\\n                arr[j] = 0\\n                j += 1\\n                if j == len(arr):\\n                    break\\n                arr[j] = 0\\n            else:\\n                arr[j] = n\\n            j += 1\\n            if j == len(arr):\\n                break\\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        j = 0\\n        for n in arr[:]:\\n            if n == 0:\\n                arr[j] = 0\\n                j += 1\\n                if j == len(arr):\\n                    break\\n                arr[j] = 0\\n            else:\\n                arr[j] = n\\n            j += 1\\n            if j == len(arr):\\n                break\\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641801,
                "title": "js-very-easy-solution",
                "content": "```\\nvar duplicateZeros = function(arr) {\\n    for (let i = 0 ; i < arr.length; i++) {\\n        if (!arr[i]) {\\n            arr.splice(i, 0, 0);\\n            arr.pop();\\n            i++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    for (let i = 0 ; i < arr.length; i++) {\\n        if (!arr[i]) {\\n            arr.splice(i, 0, 0);\\n            arr.pop();\\n            i++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2593862,
                "title": "java-solution-simple-solution-duplicate-zeros",
                "content": "```\\nclass Solution {\\n       public static void shift(int[] arr,int i)\\n    {\\n        for(int k=arr.length-1;k>i+1;k--)\\n        {\\n            arr[k]=arr[k-1];\\n        }\\n        \\n    }\\n    public void duplicateZeros(int[] arr) {\\n        \\n        \\n   for(int i=0;i<arr.length-1;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                shift(arr,i);\\n                arr[i+1]=0;\\n                i++;\\n            }\\n        }\\n        \\n    }\\n    \\n \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n       public static void shift(int[] arr,int i)\\n    {\\n        for(int k=arr.length-1;k>i+1;k--)\\n        {\\n            arr[k]=arr[k-1];\\n        }\\n        \\n    }\\n    public void duplicateZeros(int[] arr) {\\n        \\n        \\n   for(int i=0;i<arr.length-1;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                shift(arr,i);\\n                arr[i+1]=0;\\n                i++;\\n            }\\n        }\\n        \\n    }\\n    \\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458136,
                "title": "kotlin-with-queue",
                "content": "```\\nclass Solution {\\n    fun duplicateZeros(arr: IntArray) {\\n        var possibleDups = 0\\n        var length_ = arr.size - 1\\n\\n        // Find the number of zeros to be duplicated\\n        // Stopping when left points beyond the last element in the original array\\n        // which would be part of the modified array\\n        var left = 0\\n        while (left <= length_ - possibleDups) {\\n            // Count the zeros\\n            if (arr[left] == 0) {\\n                // Edge case: This zero can\\'t be duplicated. We have no more space,\\n                // as left is pointing to the last element which could be included\\n                if (left == length_ - possibleDups) {\\n                    // For this zero we just copy it without duplication.\\n                    arr[length_] = 0\\n                    length_ -= 1\\n                    break\\n                }\\n                possibleDups++\\n            }\\n            left++\\n        }\\n\\n        // Start backwards from the last element which would be part of the new array.\\n        var last = length_ - possibleDups\\n\\n        // Copy zero twice, and non-zero once.\\n        var i = last\\n        while (i >= 0) {\\n            if (arr[i] == 0) {\\n                arr[i + possibleDups] = 0\\n                possibleDups--\\n                arr[i + possibleDups] = 0\\n            } else {\\n                arr[i + possibleDups] = arr[i]\\n            }\\n            i--\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun duplicateZeros(arr: IntArray) {\\n        var possibleDups = 0\\n        var length_ = arr.size - 1\\n\\n        // Find the number of zeros to be duplicated\\n        // Stopping when left points beyond the last element in the original array\\n        // which would be part of the modified array\\n        var left = 0\\n        while (left <= length_ - possibleDups) {\\n            // Count the zeros\\n            if (arr[left] == 0) {\\n                // Edge case: This zero can\\'t be duplicated. We have no more space,\\n                // as left is pointing to the last element which could be included\\n                if (left == length_ - possibleDups) {\\n                    // For this zero we just copy it without duplication.\\n                    arr[length_] = 0\\n                    length_ -= 1\\n                    break\\n                }\\n                possibleDups++\\n            }\\n            left++\\n        }\\n\\n        // Start backwards from the last element which would be part of the new array.\\n        var last = length_ - possibleDups\\n\\n        // Copy zero twice, and non-zero once.\\n        var i = last\\n        while (i >= 0) {\\n            if (arr[i] == 0) {\\n                arr[i + possibleDups] = 0\\n                possibleDups--\\n                arr[i + possibleDups] = 0\\n            } else {\\n                arr[i + possibleDups] = arr[i]\\n            }\\n            i--\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456817,
                "title": "go-o-n-2-with-shifting",
                "content": "```\\nfunc duplicateZeros(arr []int)  {\\n    i := 0\\n    \\n    for i < len(arr) {\\n        if arr[i] == 0 {\\n            for j := len(arr)-2; j > i; j-- {\\n                arr[j+1] = arr[j]\\n            }\\n            \\n            if i+1 < len(arr) {\\n                arr[i+1] = 0\\n            }\\n            \\n            i += 2\\n        } else {\\n            i++            \\n        }\\n    } \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc duplicateZeros(arr []int)  {\\n    i := 0\\n    \\n    for i < len(arr) {\\n        if arr[i] == 0 {\\n            for j := len(arr)-2; j > i; j-- {\\n                arr[j+1] = arr[j]\\n            }\\n            \\n            if i+1 < len(arr) {\\n                arr[i+1] = 0\\n            }\\n            \\n            i += 2\\n        } else {\\n            i++            \\n        }\\n    } \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2253051,
                "title": "javascript-o-n-solution-faster-than-98",
                "content": "## Solution description:\\nIterate from the beginning of the array\\n\\nWhen we see a zero:\\n1. minus `lastKeepIdx` by one (move one index back), which means we\\'ll add duplicate the zero and remove item at `lastKeepIdx`. Keep items before the index of `lastKeepIdx`.\\n2. Set `lastDuplicatedZero` value to be current index to indicate the last index of zero we want to duplicate.\\n\\nRepeat the above process until current index is the last index we want to keep (`lastKeepIdx`). Note, if the current index has 0 value but it equals to the last index we want to keep, we don\\'t mark it as `lastDuplicatedZero` because we don\\'t have more space to duplicate a zero for it.\\n\\nWe only change the array when `lastKeepIdx` is not the last index of the array. If it\\'s the last index of the array, which means we want to keep the whole array and do nothing. (When no zeros in the array)\\n\\nIterate from the end of the array to shift whole array to the end and duplicate zeros\\n1. Replace the current index element with the element at `lastKeepIdx` (the last element that we want to keep)\\n2. If the element we want to keep is zero AND its index is less or equal to `lastDuplicatedZero` index -> duplicate the zero by replacing previous index with zero and reduce index by one\\n3. Reduce `lastKeepIdx` by one\\n\\nRepeat the process until `lastKeepIdx` is less than 0\\n\\n## Variables Declare:\\n`lastKeepIdx ` : last element\\'s index to keep in the array.\\n`lastDuplicatedZero` : last index of zero to duplicate(sometimes the last zero can\\'t be duplicated because there\\'s no more space). Default to be `undefined` because there may be no zero in the array.\\n\\n```\\nvar duplicateZeros = function(arr) {\\n    let lastKeepIdx = arr.length-1\\n    let lastDuplicatedZero\\n    \\n    for (let i = 0; i <= lastKeepIdx; i++) {\\n        if (arr[i] === 0 && i !== lastKeepIdx) {\\n            lastKeepIdx--\\n            lastDuplicatedZero = i\\n        }\\n    }\\n    if (lastKeepIdx < arr.length-1) {\\n        for (let i = arr.length - 1; lastKeepIdx >= 0; i--) {\\n            arr[i] = arr[lastKeepIdx]\\n            if (arr[lastKeepIdx] === 0 && lastKeepIdx <= lastDuplicatedZero) {\\n                arr[i-1] = 0\\n                i--\\n            }\\n            lastKeepIdx--\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    let lastKeepIdx = arr.length-1\\n    let lastDuplicatedZero\\n    \\n    for (let i = 0; i <= lastKeepIdx; i++) {\\n        if (arr[i] === 0 && i !== lastKeepIdx) {\\n            lastKeepIdx--\\n            lastDuplicatedZero = i\\n        }\\n    }\\n    if (lastKeepIdx < arr.length-1) {\\n        for (let i = arr.length - 1; lastKeepIdx >= 0; i--) {\\n            arr[i] = arr[lastKeepIdx]\\n            if (arr[lastKeepIdx] === 0 && lastKeepIdx <= lastDuplicatedZero) {\\n                arr[i-1] = 0\\n                i--\\n            }\\n            lastKeepIdx--\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2009080,
                "title": "python-faster-than-69-04-one-loop-solution",
                "content": "![image](https://assets.leetcode.com/users/images/67c595c7-1097-43f1-adf2-ee00ff0447dc_1651712212.6238477.png)\\n**Code:**\\n```\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        index = 0\\n        while index < len(arr):\\n            if arr[index] == 0:\\n                index += 1\\n                arr.insert(index - 1, 0)\\n                arr.pop()\\n            index += 1\\n```\\n______________________________________\\nKindly upvote the solution if you liked it. Any questions/suggestions are welcome, have a nice day :)\\n\\n**My GitHub with Leetcode Solutions --->** https://github.com/Krsmanovic-S/Leetcode-Exercises",
                "solutionTags": [],
                "code": "```\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        index = 0\\n        while index < len(arr):\\n            if arr[index] == 0:\\n                index += 1\\n                arr.insert(index - 1, 0)\\n                arr.pop()\\n            index += 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1852747,
                "title": "python-3-in-place-easy-to-understand-using-two-pointers-o-n",
                "content": "I beleive this code will be helpful to you. \\n1. Count zeroes in the array\\n2. Define two pointers,  i and  j \\n3. iterate from the end of the array while i < j\\n4. if j is within the array\\'s range put arr[i] in arr[j]\\n5. if arr[i] ==0, move j one step to the left and if j is within the array\\'s range put arr[i] in arr[j]\\n\\nHere is an example:\\narr = [1,0,2,3,0,4,5,0]\\n\\ni = 7 and j = 10  --->   if arr[i] == 0  :  [1, 0, 2, 3, 0, 4, 5, 0]\\ni = 6 and j = 8\\ni = 5 and j = 7   --->  if j < len(arr) :  [1, 0, 2, 3, 0, 4, 5, 4]\\ni = 4 and j = 6   --->  if j < len(arr) :  [1, 0, 2, 3, 0, 4, 0, 4]\\n----------------->  if arr[i] == 0  :  [1, 0, 2, 3, 0, 0, 0, 4]\\ni = 3 and j = 4   --->  if j < len(arr) :  [1, 0, 2, 3, 3, 0, 0, 4]\\ni = 2 and j = 3   --->  if j < len(arr) :  [1, 0, 2, 2, 3, 0, 0, 4]\\ni = 1 and j = 2   --->  if j < len(arr) :  [1, 0, 0, 2, 3, 0, 0, 4]\\n----------------->  if arr[i] == 0  :  [1, 0, 0, 2, 3, 0, 0, 4]\\n```\\n\\t\\tzeroes = arr.count(0) #count the number of zeroes in the arr\\n        i , j = len(arr) - 1, len(arr) -1 + zeroes #define i and j pointers\\n        \\n        while i<j:\\n            if j < len(arr): #if j is within the array\\'s range\\n                arr[j] = arr[i]\\n                \\n            if arr[i] == 0: #if arr[i] has zero \\n                j -= 1\\n                if j < len(arr): #if j is within the array\\'s range\\n                    arr[j] = arr[i]\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t#move one step to the left\\n            i -=1\\n            j -=1\\n```\\n\\t\\t\\t\\nI figured when we put zero in the second if condiction instead of arr[i] it\\'s going to be faster. I recommend the second one better but the above code is good to first understand the code.\\n\\n\\n```\\n\\t\\tzeroes = arr.count(0) #count the number of zeroes in the arr\\n        i , j = len(arr) - 1, len(arr) -1 + zeroes #define i and j pointers\\n        \\n        while i<j:\\n            if j < len(arr):\\n                arr[j] = arr[i]\\n                \\n            if arr[i] == 0: \\n                j -= 1\\n                if j < len(arr):\\n                    arr[j] = 0\\n\\n\\t\\t\\t#moving two pointers one step to the left\\n            i -=1\\n            j -=1\\n```\\n\\nplease **UPVOTE** if you like \\uD83D\\uDE0A",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\t\\tzeroes = arr.count(0) #count the number of zeroes in the arr\\n        i , j = len(arr) - 1, len(arr) -1 + zeroes #define i and j pointers\\n        \\n        while i<j:\\n            if j < len(arr): #if j is within the array\\'s range\\n                arr[j] = arr[i]\\n                \\n            if arr[i] == 0: #if arr[i] has zero \\n                j -= 1\\n                if j < len(arr): #if j is within the array\\'s range\\n                    arr[j] = arr[i]\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t#move one step to the left\\n            i -=1\\n            j -=1\\n```\n```\\n\\t\\tzeroes = arr.count(0) #count the number of zeroes in the arr\\n        i , j = len(arr) - 1, len(arr) -1 + zeroes #define i and j pointers\\n        \\n        while i<j:\\n            if j < len(arr):\\n                arr[j] = arr[i]\\n                \\n            if arr[i] == 0: \\n                j -= 1\\n                if j < len(arr):\\n                    arr[j] = 0\\n\\n\\t\\t\\t#moving two pointers one step to the left\\n            i -=1\\n            j -=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1741074,
                "title": "python3-99-03-faster-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        left = 0\\n        while(left<len(arr)):\\n            if arr[left]==0:\\n                arr.pop()\\n                arr.insert(left,0)\\n                left+=2\\n            else:\\n                left+=1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        left = 0\\n        while(left<len(arr)):\\n            if arr[left]==0:\\n                arr.pop()\\n                arr.insert(left,0)\\n                left+=2\\n            else:\\n                left+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620603,
                "title": "java-0ms-100-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm :\\n     *  1. Create a new array (shifted[]) of the same Size. The correct elements from arr[] will be copied to shifted[]\\n     *  2. Loop with 2 indexes: i over arr[] and j over shifted[].\\n     *     - If arr[i] is != 0, copy it to shifted[j]. Increment i and j\\n     *     - If arr[i] == 0, increment i by 1 and j by 2 as shifted[j,j+1] are already 0.\\n     *     - Incrementing by 2 will simulate the insertion of a 0 in shifted\\n     */\\n    public void duplicateZeros(int[] arr) {\\n        int[] shifted = new int[arr.length];\\n        for (int i = 0, j = 0; i < arr.length && j < arr.length; i++) {\\n            if (arr[i] != 0) {\\n                shifted[j++] = arr[i];\\n            } else {\\n                j += 2;\\n            }\\n        }\\n        System.arraycopy(shifted, 0, arr, 0, arr.length);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm :\\n     *  1. Create a new array (shifted[]) of the same Size. The correct elements from arr[] will be copied to shifted[]\\n     *  2. Loop with 2 indexes: i over arr[] and j over shifted[].\\n     *     - If arr[i] is != 0, copy it to shifted[j]. Increment i and j\\n     *     - If arr[i] == 0, increment i by 1 and j by 2 as shifted[j,j+1] are already 0.\\n     *     - Incrementing by 2 will simulate the insertion of a 0 in shifted\\n     */\\n    public void duplicateZeros(int[] arr) {\\n        int[] shifted = new int[arr.length];\\n        for (int i = 0, j = 0; i < arr.length && j < arr.length; i++) {\\n            if (arr[i] != 0) {\\n                shifted[j++] = arr[i];\\n            } else {\\n                j += 2;\\n            }\\n        }\\n        System.arraycopy(shifted, 0, arr, 0, arr.length);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1463052,
                "title": "easy-javascript-solution",
                "content": "```\\nvar duplicateZeros = function(arr) {\\n    let len = arr.length;\\n    \\n    if(!arr.includes(0)) return arr;\\n    \\n    for(let i = 0; i<len; i++) {\\n        if(arr[i] === 0) {\\n            arr.splice(i, 0, 0);\\n            i++;\\n        }\\n        arr.length = len;\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    let len = arr.length;\\n    \\n    if(!arr.includes(0)) return arr;\\n    \\n    for(let i = 0; i<len; i++) {\\n        if(arr[i] === 0) {\\n            arr.splice(i, 0, 0);\\n            i++;\\n        }\\n        arr.length = len;\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1435919,
                "title": "javascript",
                "content": "```\\nvar duplicateZeros = function(arr) {\\n  const len = arr.length\\n  for ( let i = 0; i < len; i++ ) {\\n      if (arr[i] === 0) {\\n        arr.splice(i, 0, 0)\\n        i++\\n      }\\n  }\\n  arr.length = len\\n};\\n```\\n\\nRuntime: 97 ms\\nMemory Usage: 39.8 MB",
                "solutionTags": [],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n  const len = arr.length\\n  for ( let i = 0; i < len; i++ ) {\\n      if (arr[i] === 0) {\\n        arr.splice(i, 0, 0)\\n        i++\\n      }\\n  }\\n  arr.length = len\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1346853,
                "title": "java-simple-solution-2-approach-o-n-space-o-1-space",
                "content": "Approch One \\n```\\n// Without using extra space \\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n\\t\\t\\t//if we found zero we have to shift all by one place to right till where we found zero\\n                for(int j=arr.length-1;j>i;j--)\\n                {\\n                    arr[j]=arr[j-1];\\n                }\\n\\t\\t\\t\\t// i is incremented because if we shift by one next we be zero only that\\'s we have skip that\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```\\nApproch Two\\n```\\n// Using Extra Space\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        List<Integer> li=new ArrayList<>();\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]!=0)\\n            {\\n                li.add(arr[i]);\\n            }\\n            else\\n            {\\n                li.add(arr[i]);\\n                li.add(arr[i]);\\n            }\\n        }\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            arr[i]=li.get(i);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Without using extra space \\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n\\t\\t\\t//if we found zero we have to shift all by one place to right till where we found zero\\n                for(int j=arr.length-1;j>i;j--)\\n                {\\n                    arr[j]=arr[j-1];\\n                }\\n\\t\\t\\t\\t// i is incremented because if we shift by one next we be zero only that\\'s we have skip that\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```\n```\\n// Using Extra Space\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        List<Integer> li=new ArrayList<>();\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]!=0)\\n            {\\n                li.add(arr[i]);\\n            }\\n            else\\n            {\\n                li.add(arr[i]);\\n                li.add(arr[i]);\\n            }\\n        }\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            arr[i]=li.get(i);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331769,
                "title": "c-solution-brute-force-26-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i = 0; i < n-1; i++)\\n            if(arr[i] == 0){\\n                for(int j = n-1; j > i; j--) \\n                    arr[j] = arr[j-1];\\n                arr[i+1] = 0;\\n                i++;\\n            }     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i = 0; i < n-1; i++)\\n            if(arr[i] == 0){\\n                for(int j = n-1; j > i; j--) \\n                    arr[j] = arr[j-1];\\n                arr[i+1] = 0;\\n                i++;\\n            }     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161240,
                "title": "runtime-52-ms-faster-than-84-20-python-simple-and-easy-to-understand",
                "content": "```\\n\\ni = 0\\nlength = len(arr)\\nwhile(i < length - 1):\\n\\tif arr[i] == 0:\\n\\t\\tarr.pop(-1)\\n\\t\\tarr.insert(i, 0)\\n\\t\\ti+=1\\n\\ti+=1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\ni = 0\\nlength = len(arr)\\nwhile(i < length - 1):\\n\\tif arr[i] == 0:\\n\\t\\tarr.pop(-1)\\n\\t\\tarr.insert(i, 0)\\n\\t\\ti+=1\\n\\ti+=1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1089597,
                "title": "java-commented-o-n-solution-with-two-pointers",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int zeroCount = 0;\\n        int newArraySize = 0;\\n        int iterator = 0;\\n        \\n        // count how many zeros should we duplicate\\n        // when \\'newArraySize\\' is the same as `arr.length` we stop our search because future zeroes will be out the array range\\n        while(iterator < arr.length && newArraySize < arr.length) { \\n            int val = arr[iterator];\\n            \\n            if(val == 0) {\\n                zeroCount++;\\n                newArraySize += 2; // 2 because we should add 2 zeroes to the result array\\n            } else {\\n                newArraySize++;\\n            }\\n            \\n            iterator++;\\n        }\\n        \\n        // two pointers which we will use to copy \\n        // pointer when the first array should be ended after we add necessary zeroes\\n        int copyFrom = iterator - 1; // \"-1\" because we increased \\'iterator\\' at the last step on our previous loop\\n        // where we will copy\\n        int copyTo = arr.length - 1;\\n        \\n        // if the last number is zero and if we copy it our new array will be longer than original one\\n        boolean isTrailingZero = newArraySize > arr.length;\\n        \\n        // go from the tail of array and move numbers\\n        while(copyFrom >= 0) {\\n            int val = arr[copyFrom];\\n            \\n            // if this numer is zero\\n            if(val == 0) {\\n                if(isTrailingZero && copyTo == arr.length - 1) {\\n                    // if it\\'s the last number is zero we shouldn\\'t add two zeroes to the result array\\n                    arr[copyTo] = val;\\n                } else {\\n                    // add two zeroes in a row \\n                    arr[copyTo] = val;\\n                    copyTo--;\\n                    arr[copyTo] = val;\\n                }\\n            } else {\\n                // just copy the number\\n                arr[copyTo] = val;\\n            }\\n            \\n            // move pointers\\n            copyFrom--;\\n            copyTo--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int zeroCount = 0;\\n        int newArraySize = 0;\\n        int iterator = 0;\\n        \\n        // count how many zeros should we duplicate\\n        // when \\'newArraySize\\' is the same as `arr.length` we stop our search because future zeroes will be out the array range\\n        while(iterator < arr.length && newArraySize < arr.length) { \\n            int val = arr[iterator];\\n            \\n            if(val == 0) {\\n                zeroCount++;\\n                newArraySize += 2; // 2 because we should add 2 zeroes to the result array\\n            } else {\\n                newArraySize++;\\n            }\\n            \\n            iterator++;\\n        }\\n        \\n        // two pointers which we will use to copy \\n        // pointer when the first array should be ended after we add necessary zeroes\\n        int copyFrom = iterator - 1; // \"-1\" because we increased \\'iterator\\' at the last step on our previous loop\\n        // where we will copy\\n        int copyTo = arr.length - 1;\\n        \\n        // if the last number is zero and if we copy it our new array will be longer than original one\\n        boolean isTrailingZero = newArraySize > arr.length;\\n        \\n        // go from the tail of array and move numbers\\n        while(copyFrom >= 0) {\\n            int val = arr[copyFrom];\\n            \\n            // if this numer is zero\\n            if(val == 0) {\\n                if(isTrailingZero && copyTo == arr.length - 1) {\\n                    // if it\\'s the last number is zero we shouldn\\'t add two zeroes to the result array\\n                    arr[copyTo] = val;\\n                } else {\\n                    // add two zeroes in a row \\n                    arr[copyTo] = val;\\n                    copyTo--;\\n                    arr[copyTo] = val;\\n                }\\n            } else {\\n                // just copy the number\\n                arr[copyTo] = val;\\n            }\\n            \\n            // move pointers\\n            copyFrom--;\\n            copyTo--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057060,
                "title": "c-few-lines",
                "content": "```public void DuplicateZeros(int[] arr) {        \\n        for(int i = 0; i < arr.Length; i++){\\n            if(arr[i] == 0){\\n                int right = arr.Length - 1;\\n                while(right > i){\\n                    arr[right] = arr[right -1];\\n                    right--;\\n                }\\n                 i = i + 1;\\n            }\\n        }",
                "solutionTags": [],
                "code": "```public void DuplicateZeros(int[] arr) {        \\n        for(int i = 0; i < arr.Length; i++){\\n            if(arr[i] == 0){\\n                int right = arr.Length - 1;\\n                while(right > i){\\n                    arr[right] = arr[right -1];\\n                    right--;\\n                }\\n                 i = i + 1;\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1054947,
                "title": "java-two-pass-easy-to-understand-two-pointers-o-1-space",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int count = 0, n = arr.length;\\n        for(int num : arr) count += (num == 0) ? 1 : 0;\\n        int lastIndex = n + count - 1;\\n        \\n        for(int i = n-1; i >= 0 && lastIndex >= 0; i--) {\\n            if(arr[i] == 0) { // set zeroes and move two places backwards (via lastIndex)\\n                if(lastIndex < n)\\n\\t\\t\\t\\t   arr[lastIndex] = 0;\\n                if((lastIndex-1) < n && lastIndex > 0)\\n\\t\\t\\t\\t   arr[lastIndex-1] = 0;\\n                lastIndex -= 2;\\n            } else { // set same value and move one place backwards (via lastIndex)\\n                if(lastIndex < n)\\n\\t\\t\\t\\t   arr[lastIndex] = arr[i];\\n                lastIndex -= 1;\\n            }\\n        }\\n    }\\n}\\n```\\n\\nIdea using an example:\\n- Consider the array: `[8,4,5,0,0,0,0,7]`\\n- Consider an **imaginary additional length** next to the array that can accommodate the additional zeroes.\\n- With that idea in mind, the `lastIndex` will be at `length(arr) + count(zeroes) - 1` (in this case, it would be `lastIndex = 11` for `[8,4,5,0,0,0,0,7..0,0,0,0]`)\\n- Now loop through backwards with `i` being the last element of **actual** array and update the array with **valid** `lastIndex` value decrements.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int count = 0, n = arr.length;\\n        for(int num : arr) count += (num == 0) ? 1 : 0;\\n        int lastIndex = n + count - 1;\\n        \\n        for(int i = n-1; i >= 0 && lastIndex >= 0; i--) {\\n            if(arr[i] == 0) { // set zeroes and move two places backwards (via lastIndex)\\n                if(lastIndex < n)\\n\\t\\t\\t\\t   arr[lastIndex] = 0;\\n                if((lastIndex-1) < n && lastIndex > 0)\\n\\t\\t\\t\\t   arr[lastIndex-1] = 0;\\n                lastIndex -= 2;\\n            } else { // set same value and move one place backwards (via lastIndex)\\n                if(lastIndex < n)\\n\\t\\t\\t\\t   arr[lastIndex] = arr[i];\\n                lastIndex -= 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944706,
                "title": "python3-solution-hard-to-be-simpler-than-this",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        \\n        n = len(arr)\\n        for i in reversed(range(len(arr))):\\n            if arr[i] == 0:\\n                arr.insert(i, 0)\\n                arr.pop()\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        \\n        n = len(arr)\\n        for i in reversed(range(len(arr))):\\n            if arr[i] == 0:\\n                arr.insert(i, 0)\\n                arr.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939707,
                "title": "java-single-pass",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length-1;i++){\\n            if(arr[i]==0){\\n                for(int j=arr.length-2;j>i;j--){\\n                    arr[j+1]=arr[j];\\n                }\\n                i++;\\n                arr[i]=0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length-1;i++){\\n            if(arr[i]==0){\\n                for(int j=arr.length-2;j>i;j--){\\n                    arr[j+1]=arr[j];\\n                }\\n                i++;\\n                arr[i]=0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916247,
                "title": "javascript-99-simple-short-comments",
                "content": "```\\nvar duplicateZeros = function(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (!arr[i]) {\\n            arr.splice(i, 0, 0); // Insert new 0\\n            i++; // Increase pointer so that newly inserted 0 gets skipped\\n            arr.pop(); // Remove last element to maintain length\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (!arr[i]) {\\n            arr.splice(i, 0, 0); // Insert new 0\\n            i++; // Increase pointer so that newly inserted 0 gets skipped\\n            arr.pop(); // Remove last element to maintain length\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 903520,
                "title": "python-two-pass-in-place-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        w = len(arr) - 1 + arr.count(0)  # \\'write to\\' index\\n        \\n        for r in range(len(arr) - 1, -1, -1): # \\'read from\\' index\\n            if arr[r] == 0:  # insert extra 0\\n                if w < len(arr):\\n                    arr[w] = 0\\n                w -= 1\\n                \\n            if w < len(arr):\\n                arr[w] = arr[r]\\n            w -= 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        w = len(arr) - 1 + arr.count(0)  # \\'write to\\' index\\n        \\n        for r in range(len(arr) - 1, -1, -1): # \\'read from\\' index\\n            if arr[r] == 0:  # insert extra 0\\n                if w < len(arr):\\n                    arr[w] = 0\\n                w -= 1\\n                \\n            if w < len(arr):\\n                arr[w] = arr[r]\\n            w -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772472,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i=0;i<arr.size()-1;i++){\\n            if(arr[i]==0){                   //if we bump into 0 \\n\\t\\t\\t  for(int j=arr.size()-1;j>i+1;j--){  //move all elements (from a[i+2] to end) to the left once \\n                    arr[j]=arr[j-1];\\n                }\\n\\t\\t\\t  arr[i+1]=0;    //duplicate a[i]\\n                i++;    //skip arr[i+1] and go on\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i=0;i<arr.size()-1;i++){\\n            if(arr[i]==0){                   //if we bump into 0 \\n\\t\\t\\t  for(int j=arr.size()-1;j>i+1;j--){  //move all elements (from a[i+2] to end) to the left once \\n                    arr[j]=arr[j-1];\\n                }\\n\\t\\t\\t  arr[i+1]=0;    //duplicate a[i]\\n                i++;    //skip arr[i+1] and go on\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577431,
                "title": "simple-while-loop-python-beginner-solution-48ms-beat-96",
                "content": "```\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: None Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] != 0:\\n                i += 1\\n            else:\\n                arr.insert(i+1,0)\\n                i += 2\\n                arr.pop()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: None Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] != 0:\\n                i += 1\\n            else:\\n                arr.insert(i+1,0)\\n                i += 2\\n                arr.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565310,
                "title": "javascript",
                "content": "```\\nvar duplicateZeros = function(arr) {\\n    let length = arr.length;\\n    let snake = [];\\n    let part = 0;\\n    for (let i = 0; i < length; i++) {\\n        let cur = arr[i];\\n        if (cur === 0) {\\n            snake.push(0);\\n            snake.push(0);\\n        } else {\\n            snake.push(cur);\\n        };\\n        arr[i] = snake[part++];\\n    };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    let length = arr.length;\\n    let snake = [];\\n    let part = 0;\\n    for (let i = 0; i < length; i++) {\\n        let cur = arr[i];\\n        if (cur === 0) {\\n            snake.push(0);\\n            snake.push(0);\\n        } else {\\n            snake.push(cur);\\n        };\\n        arr[i] = snake[part++];\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 369747,
                "title": "simple-c-98-28-100-inplace",
                "content": "Runtime: 16 ms, faster than 98.28% of C++ online submissions for Duplicate Zeros.\\nMemory Usage: 9.1 MB, less than 100.00% of C++ online submissions for Duplicate Zeros.\\n\\n```\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        int countZero = 0;\\n        for(int i=0; i<n; i++)\\n            countZero += (arr[i] == 0 ? 1 : 0);\\n        \\n        int newLen = n + countZero - 1;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(arr[i] == 0)\\n            {\\n                if(newLen < n)\\n                    arr[newLen] = 0;\\n                newLen--;\\n                \\n                if(newLen < n)\\n                    arr[newLen] = 0;\\n                newLen--;\\n            }\\n            else\\n            {\\n                if(newLen < n)\\n                    arr[newLen] = arr[i];\\n                newLen--;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Runtime: 16 ms, faster than 98.28% of C++ online submissions for Duplicate Zeros.\\nMemory Usage: 9.1 MB, less than 100.00% of C++ online submissions for Duplicate Zeros.\\n\\n```\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        int countZero = 0;\\n        for(int i=0; i<n; i++)\\n            countZero += (arr[i] == 0 ? 1 : 0);\\n        \\n        int newLen = n + countZero - 1;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(arr[i] == 0)\\n            {\\n                if(newLen < n)\\n                    arr[newLen] = 0;\\n                newLen--;\\n                \\n                if(newLen < n)\\n                    arr[newLen] = 0;\\n                newLen--;\\n            }\\n            else\\n            {\\n                if(newLen < n)\\n                    arr[newLen] = arr[i];\\n                newLen--;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 369620,
                "title": "java-1ms-2-passes",
                "content": "Sharing my solution, glad to hear opinions\\n```\\n    public void duplicateZeros(int[] arr) {\\n        int numOfZeroes = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) {\\n                numOfZeroes++;\\n            }\\n        }\\n        if (numOfZeroes == 0) {\\n            return;\\n        }\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            if (i + numOfZeroes < arr.length) {\\n\\t\\t\\t\\t//moving number forward by number of remaining zeros\\n                arr[i + numOfZeroes] = arr[i];\\n            }\\n            if (arr[i] == 0) {\\n\\t\\t\\t\\t//decreasing number of zeros to correct future movements\\n                numOfZeroes--;\\n            } else {\\n\\t\\t\\t\\t//making current element 0 (it could be updated later)\\n                arr[i] = 0;\\n            }\\n            if (numOfZeroes == 0) {\\n                break;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "Sharing my solution, glad to hear opinions\\n```\\n    public void duplicateZeros(int[] arr) {\\n        int numOfZeroes = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) {\\n                numOfZeroes++;\\n            }\\n        }\\n        if (numOfZeroes == 0) {\\n            return;\\n        }\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            if (i + numOfZeroes < arr.length) {\\n\\t\\t\\t\\t//moving number forward by number of remaining zeros\\n                arr[i + numOfZeroes] = arr[i];\\n            }\\n            if (arr[i] == 0) {\\n\\t\\t\\t\\t//decreasing number of zeros to correct future movements\\n                numOfZeroes--;\\n            } else {\\n\\t\\t\\t\\t//making current element 0 (it could be updated later)\\n                arr[i] = 0;\\n            }\\n            if (numOfZeroes == 0) {\\n                break;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 354942,
                "title": "python-3-faster-than-98-less-space-than-100",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        \\n        if not arr or len(arr) < 1:\\n            return\\n        \\n        zero_count = arr.count(0)\\n        p_short, p_long = len(arr) - 1, len(arr) + zero_count - 1\\n        while p_short >= 0:\\n            if arr[p_short] != 0:\\n                if p_long < len(arr):\\n                    arr[p_long] = arr[p_short]\\n            else:\\n                if p_long < len(arr):\\n                    arr[p_long] = 0\\n                p_long -= 1\\n                if p_long < len(arr):\\n                    arr[p_long] = 0\\n                    \\n            p_short -= 1\\n            p_long -= 1\\n                    \\n        \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        \\n        if not arr or len(arr) < 1:\\n            return\\n        \\n        zero_count = arr.count(0)\\n        p_short, p_long = len(arr) - 1, len(arr) + zero_count - 1\\n        while p_short >= 0:\\n            if arr[p_short] != 0:\\n                if p_long < len(arr):\\n                    arr[p_long] = arr[p_short]\\n            else:\\n                if p_long < len(arr):\\n                    arr[p_long] = 0\\n                p_long -= 1\\n                if p_long < len(arr):\\n                    arr[p_long] = 0\\n                    \\n            p_short -= 1\\n            p_long -= 1\\n                    \\n        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 332083,
                "title": "python-solution",
                "content": "Python solution using temporary list (100 % in memory)\\n\\t\\t\\t\\n\\t\\tlis=[]\\n        n=len(arr)\\n        for i in range(n):\\n            if(arr[i]==0):\\n                lis.append(0)    \\n            lis.append(arr[i])\\n        \\n        for i in range(n):\\n            arr[i]=lis[i]",
                "solutionTags": [],
                "code": "Python solution using temporary list (100 % in memory)\\n\\t\\t\\t\\n\\t\\tlis=[]\\n        n=len(arr)\\n        for i in range(n):\\n            if(arr[i]==0):\\n                lis.append(0)    \\n            lis.append(arr[i])\\n        \\n        for i in range(n):\\n            arr[i]=lis[i]",
                "codeTag": "Unknown"
            },
            {
                "id": 323122,
                "title": "2ms-java-solution",
                "content": "Ideas:\\n* Hold values from the original array in a queue and pop elements one by one\\n* If a 0 is at the front of the queue when popping, place it in the array twice\\n* This technique can easily be modified for placing zeros 3 times or 4 times or etc. Most of the two pointer \\nsolutions here would require significant changes. Most interviews have follow up questions/requirements so make robust solutions!\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i : arr) queue.add(i);\\n        int i = 0;\\n        while(i <= arr.length - 1) {\\n            int top = queue.poll();\\n            if(top != 0) {\\n                arr[i++] = top;\\n            } else {\\n                arr[i++] = top;\\n                if(i > arr.length - 1) return;\\n                arr[i++] = top;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i : arr) queue.add(i);\\n        int i = 0;\\n        while(i <= arr.length - 1) {\\n            int top = queue.poll();\\n            if(top != 0) {\\n                arr[i++] = top;\\n            } else {\\n                arr[i++] = top;\\n                if(i > arr.length - 1) return;\\n                arr[i++] = top;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312986,
                "title": "c-faster-than-100-of-all-submissions",
                "content": "```\\nvoid duplicateZeros(vector<int>& a) {\\n        \\n        int i,j,n=a.size();\\n        for(i=0;i<n;i++)\\n        {\\n            if(a[i]==0)\\n            {\\n                a.insert(a.begin()+i, 0);\\n                a.pop_back();\\n                i++;\\n            }\\n        }\\n        return;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvoid duplicateZeros(vector<int>& a) {\\n        \\n        int i,j,n=a.size();\\n        for(i=0;i<n;i++)\\n        {\\n            if(a[i]==0)\\n            {\\n                a.insert(a.begin()+i, 0);\\n                a.pop_back();\\n                i++;\\n            }\\n        }\\n        return;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3678498,
                "title": "2-easy-c-solution-beginner-friendly-approach-using-swap-insert-and-resize",
                "content": "\\n\\n# Code\\n```\\n// Solution (using swap())\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==0 && (i+1)<n){\\n                for(int j=n-1; j>i+1; j--)\\n                    swap(nums[j], nums[j-1]);\\n                nums[++i]=0;\\n            }\\n        }\\n    }\\n};\\n\\n// Solution 2 (Using insert and resize)\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int i=0, n=arr.size();\\n        while(i<n)\\n        {\\n            if(arr[i]==0)\\n            {\\n                arr.insert(arr.begin()+i, 0);\\n                i += 2;\\n            }\\n            else\\n                i++;\\n        }\\n        arr.resize(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Solution (using swap())\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==0 && (i+1)<n){\\n                for(int j=n-1; j>i+1; j--)\\n                    swap(nums[j], nums[j-1]);\\n                nums[++i]=0;\\n            }\\n        }\\n    }\\n};\\n\\n// Solution 2 (Using insert and resize)\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int i=0, n=arr.size();\\n        while(i<n)\\n        {\\n            if(arr[i]==0)\\n            {\\n                arr.insert(arr.begin()+i, 0);\\n                i += 2;\\n            }\\n            else\\n                i++;\\n        }\\n        arr.resize(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550951,
                "title": "easy-approach-using-string",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Use String and then update the element of array\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        String s=\"\";\\n        StringBuilder t= new StringBuilder(); \\n        for(int a: arr) s+=a;\\n\\n        for(int i=0;i<s.length();i++){\\n            //if encounter 0 append one more zero and delete the last element\\n\\n            if(s.charAt(i)==\\'0\\'){\\n                t.append(\\'0\\');\\n                t.append(\\'0\\');\\n\\n            }else t.append(s.charAt(i));\\n\\n                    \\n            }\\n            String u= t.toString();\\n            for(int i=0;i<arr.length;i++){\\n                arr[i]=u.charAt(i)-\\'0\\';\\n            }\\n         return ;\\n    }\\n   \\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        String s=\"\";\\n        StringBuilder t= new StringBuilder(); \\n        for(int a: arr) s+=a;\\n\\n        for(int i=0;i<s.length();i++){\\n            //if encounter 0 append one more zero and delete the last element\\n\\n            if(s.charAt(i)==\\'0\\'){\\n                t.append(\\'0\\');\\n                t.append(\\'0\\');\\n\\n            }else t.append(s.charAt(i));\\n\\n                    \\n            }\\n            String u= t.toString();\\n            for(int i=0;i<arr.length;i++){\\n                arr[i]=u.charAt(i)-\\'0\\';\\n            }\\n         return ;\\n    }\\n   \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436746,
                "title": "easy-solution-with-explanation",
                "content": "# Duplicate Zeros Solution\\n\\nWe are going to duplicate each occurrence of zero and shift the remaining elements to the right.\\n\\nTo get started, let\\'s iterate over the array from left to right and check each element. Whenever we come across a zero, we\\'ll need to do a little bit of magic. We\\'ll shift all the remaining elements from one position to the right and the current position is already zero. \\n\\nIt may sound a bit complicated, but trust me, it\\'s easier than it sounds! With just a few lines of code, you\\'ll be able to duplicate those zeros in no time. \\n\\nNow, let\\'s put this into action with some JavaScript code:\\n\\n```\\nfor (let i = 0; i < arr.length; i++) {\\n        if (arr[i] === 0) {\\n            for (let j = arr.length - 1; j > i; j--) arr[j] = arr[j-1];\\n            i++\\n        }\\n    }\\n```\\n\\nThis code will loop through the array and check each element. If it encounters a zero, it will shift all the remaining elements one position to the right and duplicate the zero in the current position.\\n\\nAnd there you have it! With this algorithm, you can easily duplicate each occurrence of zero and shift the remaining elements to the right. Happy coding!",
                "solutionTags": [],
                "code": "```\\nfor (let i = 0; i < arr.length; i++) {\\n        if (arr[i] === 0) {\\n            for (let j = arr.length - 1; j > i; j--) arr[j] = arr[j-1];\\n            i++\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3319754,
                "title": "easy-python-solution-beats-91",
                "content": "# Intuition\\nEasy solution \\n\\n# Approach\\nusing insert in python\\n\\n# Complexity\\n- Time complexity:\\n  O(m) where m = length of final array\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = len(arr)\\n        a= []\\n        for i in range(len(arr)):\\n            if arr[i]==0:\\n                a.append(i)\\n        k =0\\n        for i in range(len(a)):\\n            arr.insert(a[i]+k,0)\\n            k+=1\\n        m = len(arr)\\n        for i in range(m-n):\\n            arr.pop()\\n        return arr\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = len(arr)\\n        a= []\\n        for i in range(len(arr)):\\n            if arr[i]==0:\\n                a.append(i)\\n        k =0\\n        for i in range(len(a)):\\n            arr.insert(a[i]+k,0)\\n            k+=1\\n        m = len(arr)\\n        for i in range(m-n):\\n            arr.pop()\\n        return arr\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123265,
                "title": "java-easy-solution-100-faster-2-approach",
                "content": "\\n\\n# 1st approach (Java Code))\\n```\\nTime complexity: O(n)\\n\\nSpace complexity: O(n)\\n\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int[] nums = new int[arr.length];\\n        int i =0;\\n        int j =0;\\n        while(j<nums.length && i<arr.length) {\\n            if(arr[i] == 0) {\\n                nums[j] =0;\\n                if(j+1<arr.length) {\\n                    nums[j+1] =0;\\n                }\\n                j +=2;\\n                i++;\\n            } \\n            else {\\n                nums[j] = arr[i];\\n                i++;\\n                j++;\\n            }\\n        }\\n        for(int k =0;k<arr.length;k++) {\\n            arr[k] = nums[k];\\n        }\\n        \\n    }\\n}\\n```\\n# 2nd approach (Java Code))\\n```\\nTime complexity: O(n)\\n\\nSpace complexity: O(1)\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int nZe =0;\\n        for(int i : arr) {\\n            if(i==0) nZe++;\\n        }\\n        int i = arr.length-1;\\n        int j = arr.length+nZe-1;\\n        while(i!=j) {\\n            insert(arr,i,j);\\n            j--;\\n            if(arr[i]==0) {\\n                insert(arr,i,j);\\n                j--;\\n            }\\n            i--;\\n        }\\n    }\\n    void insert(int[] arr, int i, int j) {\\n        if(j<arr.length) {\\n            arr[j] = arr[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nTime complexity: O(n)\\n\\nSpace complexity: O(n)\\n\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int[] nums = new int[arr.length];\\n        int i =0;\\n        int j =0;\\n        while(j<nums.length && i<arr.length) {\\n            if(arr[i] == 0) {\\n                nums[j] =0;\\n                if(j+1<arr.length) {\\n                    nums[j+1] =0;\\n                }\\n                j +=2;\\n                i++;\\n            } \\n            else {\\n                nums[j] = arr[i];\\n                i++;\\n                j++;\\n            }\\n        }\\n        for(int k =0;k<arr.length;k++) {\\n            arr[k] = nums[k];\\n        }\\n        \\n    }\\n}\\n```\n```\\nTime complexity: O(n)\\n\\nSpace complexity: O(1)\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int nZe =0;\\n        for(int i : arr) {\\n            if(i==0) nZe++;\\n        }\\n        int i = arr.length-1;\\n        int j = arr.length+nZe-1;\\n        while(i!=j) {\\n            insert(arr,i,j);\\n            j--;\\n            if(arr[i]==0) {\\n                insert(arr,i,j);\\n                j--;\\n            }\\n            i--;\\n        }\\n    }\\n    void insert(int[] arr, int i, int j) {\\n        if(j<arr.length) {\\n            arr[j] = arr[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082372,
                "title": "duplicate-zeros-java-solution",
                "content": "# Complexity\\n- Time complexity: (N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: (1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int len = arr.length;\\n        if(len == 1)\\n            return;\\n       int start = 0, end = len-1;\\n       while(start < end){\\n            if(arr[start] == 0)\\n                end--;\\n            start++;\\n        }\\n        if(end == len-1)\\n            return;\\n        for(int i = len-1; i >= 0 && end >= 0; i--, end--){\\n            arr[i] = arr[end];    \\n            if(arr[end] == 0 && end != start){\\n                arr[i-1] = 0;\\n                i--;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int len = arr.length;\\n        if(len == 1)\\n            return;\\n       int start = 0, end = len-1;\\n       while(start < end){\\n            if(arr[start] == 0)\\n                end--;\\n            start++;\\n        }\\n        if(end == len-1)\\n            return;\\n        for(int i = len-1; i >= 0 && end >= 0; i--, end--){\\n            arr[i] = arr[end];    \\n            if(arr[end] == 0 && end != start){\\n                arr[i-1] = 0;\\n                i--;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952717,
                "title": "java-1-ms-o-n-time-complexity-efficient",
                "content": "\\n# Complexity\\n- Time complexity:\\nO ( n )\\n\\n- Space complexity:\\nO ( n )\\n\\n# Code\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int nums[]=new int[arr.length];\\n        int i=0;\\n        int j=0;\\n        while(j<nums.length && i<arr.length){\\n            if(arr[i]==0){\\n                nums[j]=0;\\n                if(j+1<nums.length){\\n                    nums[j+1]=0;\\n                }\\n                j+=2;\\n                i++;\\n            }\\n            else{\\n                nums[j]=arr[i];\\n                j++;\\n                i++;\\n            }\\n        }\\n        for(int k=0; k<nums.length; k++){\\n            arr[k]=nums[k];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int nums[]=new int[arr.length];\\n        int i=0;\\n        int j=0;\\n        while(j<nums.length && i<arr.length){\\n            if(arr[i]==0){\\n                nums[j]=0;\\n                if(j+1<nums.length){\\n                    nums[j+1]=0;\\n                }\\n                j+=2;\\n                i++;\\n            }\\n            else{\\n                nums[j]=arr[i];\\n                j++;\\n                i++;\\n            }\\n        }\\n        for(int k=0; k<nums.length; k++){\\n            arr[k]=nums[k];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877660,
                "title": "my-solution-i-m-learning-kindly-check-the-code-and-advice-how-can-i-improve",
                "content": "```\\n\\n```class Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        l = len(arr)\\n        lst = []\\n        for i in range(len(arr)):\\n            if arr[i]==0:\\n                lst.append(i)\\n        lst\\n        for x,y in enumerate(lst):\\n            lst[x] = lst[x] + x\\n            arr.insert(lst[x-1],0)\\n        while l != len(arr):\\n            arr.pop(-1)",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734016,
                "title": "duplicate-zeros",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int i =0;\\n        while(i<arr.length){\\n        if(arr[i]==0){\\n        int j=arr.length-1;\\n         while(j>i){\\n         arr[j]=arr[j-1];  \\n         j--;\\n     }\\n         i=i+1;\\n     }\\n         i++;\\n     }\\n    }\\n}\\n      ```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int i =0;\\n        while(i<arr.length){\\n        if(arr[i]==0){\\n        int j=arr.length-1;\\n         while(j>i){\\n         arr[j]=arr[j-1];  \\n         j--;\\n     }\\n         i=i+1;\\n     }\\n         i++;\\n     }\\n    }\\n}\\n      ```",
                "codeTag": "Java"
            },
            {
                "id": 2732666,
                "title": "java-duplicate-zeros",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int a[]=new int[arr.length];\\n        int j=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(j==arr.length)break;\\n            if(arr[i]==0){\\n                a[j++]=0;\\n                 if(j==arr.length)break;\\n                a[j++]=0;\\n            }\\n            else{\\n                a[j++]=arr[i];\\n            }\\n            \\n        }\\n        \\n        j=0;\\n        for(int ele:a){\\n            arr[j++]=ele;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int a[]=new int[arr.length];\\n        int j=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(j==arr.length)break;\\n            if(arr[i]==0){\\n                a[j++]=0;\\n                 if(j==arr.length)break;\\n                a[j++]=0;\\n            }\\n            else{\\n                a[j++]=arr[i];\\n            }\\n            \\n        }\\n        \\n        j=0;\\n        for(int ele:a){\\n            arr[j++]=ele;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705763,
                "title": "python-two-pointers",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        oldLen = len(arr) \\n        i = 0\\n        j = len(arr)\\n        \\n        while i < j :\\n            if arr[i] == 0 :\\n                arr.insert(i+1 , 0)\\n                i += 1\\n            i += 1\\n        \\n        arr[:] = arr[:oldLen]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        oldLen = len(arr) \\n        i = 0\\n        j = len(arr)\\n        \\n        while i < j :\\n            if arr[i] == 0 :\\n                arr.insert(i+1 , 0)\\n                i += 1\\n            i += 1\\n        \\n        arr[:] = arr[:oldLen]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507113,
                "title": "in-place-javascript-solution-using-splice",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar duplicateZeros = function (arr) {\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] === 0) {\\n            arr.splice(i, 0, 0)  \\n            arr.pop()\\n            i++\\n        }\\n    }\\n\\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar duplicateZeros = function (arr) {\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] === 0) {\\n            arr.splice(i, 0, 0)  \\n            arr.pop()\\n            i++\\n        }\\n    }\\n\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2494950,
                "title": "java-simple-and-easy-solution-beats-69",
                "content": "```\\n ArrayList<Integer> ans = new ArrayList<>();\\n        //first we make an arryalist ;\\n        \\n        //then we iterate through the arr and\\n        for(int i = 0 ; i < arr.length ; i++){\\n            //we add the element as it is if it is not equalls to 0 ;\\n            if(arr[i] != 0){\\n                ans.add(arr[i]);\\n            }else{\\n                //if not then we add two zeroes ;\\n                ans.add(0);\\n                ans.add(0);\\n            }\\n        }\\n        \\n        //then we use a for loop for changing the elements of arr array ;\\n        for(int i = 0 ; i < arr.length ;i++){\\n            arr[i] = ans.get(i);\\n        }\\n    //we don\\'t return anything bcz it\\'s a void function",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n ArrayList<Integer> ans = new ArrayList<>();\\n        //first we make an arryalist ;\\n        \\n        //then we iterate through the arr and\\n        for(int i = 0 ; i < arr.length ; i++){\\n            //we add the element as it is if it is not equalls to 0 ;\\n            if(arr[i] != 0){\\n                ans.add(arr[i]);\\n            }else{\\n                //if not then we add two zeroes ;\\n                ans.add(0);\\n                ans.add(0);\\n            }\\n        }\\n        \\n        //then we use a for loop for changing the elements of arr array ;\\n        for(int i = 0 ; i < arr.length ;i++){\\n            arr[i] = ans.get(i);\\n        }\\n    //we don\\'t return anything bcz it\\'s a void function",
                "codeTag": "Unknown"
            },
            {
                "id": 2409322,
                "title": "c-easiest-and-short-solution-for-duplicate-zeros",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==0){\\n                arr.pop_back();\\n                arr.insert(arr.begin()+i,0);\\n                ++i;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==0){\\n                arr.pop_back();\\n                arr.insert(arr.begin()+i,0);\\n                ++i;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400164,
                "title": "java-solution",
                "content": "**If we encounter a zero in the array we move the last but one element to the last position ans the last element is removed automatically so the void place created after zero is filled by zero as defalut int value**\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==0){\\n                for(int j=arr.length-1;j>i;j--){\\n                    arr[j]=arr[j-1];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==0){\\n                for(int j=arr.length-1;j>i;j--){\\n                    arr[j]=arr[j-1];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359986,
                "title": "javascript-solution",
                "content": "The solution is based on the leetcode definition for array insertion and it followed all the criteria from the question.\\n\\n```\\nvar duplicateZeros = function(arr) {\\n    for(let i=arr.length-1; i>=0; i--) {\\n        if(arr[i] === 0) {\\n            for(let j=arr.length-1; j>=i; j--) {\\n             if(j+1 <= arr.length-1) { \\n                 arr[j+1] = arr[j] \\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    for(let i=arr.length-1; i>=0; i--) {\\n        if(arr[i] === 0) {\\n            for(let j=arr.length-1; j>=i; j--) {\\n             if(j+1 <= arr.length-1) { \\n                 arr[j+1] = arr[j] \\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2319878,
                "title": "python-o-n-solution",
                "content": "#### **Final Code:**\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        count = 0\\n        while count < len(arr):\\n            if arr[count] == 0:\\n                arr.insert(count, 0)\\n                arr.pop()\\n                count += 2\\n            else:\\n                count += 1\\n```\\n\\n#### **Steps:**\\n* **Step1:**\\nCreate a count variable and set it to 0 (this will act as out index value)\\n```count = 0```\\n\\n* **Step2:**\\nRun a while loop till the count is not greater than the length of our array.\\n```while count < len(arr):```\\n\\n* **Step2:** At each position check if the element is 0 or not, and\\n**If it is zero**:\\ninsert a 0 in the place element at index value of our count.\\nafter this we will have 2 zeros now we need to jump ahead 2 steps so that we dont encounter the same \\nzero again,\\nAnd we also have to remove the element at last position of the array to kepp it the same size.\\n```\\n            if arr[count] == 0:\\n                arr.insert(count, 0)\\n                arr.pop()\\n                count += 2\\n```\\n**If it is Not zero**:\\njust increase the count by 1 and check again for zeros.\\n```\\n            else:\\n                count += 1\\n```\\n\\n* **Step3:**\\nAfter all this we shoud have modified our array in place : )\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        count = 0\\n        while count < len(arr):\\n            if arr[count] == 0:\\n                arr.insert(count, 0)\\n                arr.pop()\\n                count += 2\\n            else:\\n                count += 1\\n```\n```count = 0```\n```while count < len(arr):```\n```\\n            if arr[count] == 0:\\n                arr.insert(count, 0)\\n                arr.pop()\\n                count += 2\\n```\n```\\n            else:\\n                count += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243218,
                "title": "python-o-n-arr-in-place",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        n = len(arr)\\n        count_zero = 0\\n        for x in arr:\\n            if x ==0:\\n                count_zero +=1\\n        for i in range(n-1,-1, -1):\\n            if i+count_zero < n:\\n                arr[i+count_zero] = arr[i]\\n            if arr[i] == 0:\\n                count_zero -= 1\\n                if i + count_zero < n:\\n                    arr[i + count_zero] = arr[i]\\n```\\t\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        n = len(arr)\\n        count_zero = 0\\n        for x in arr:\\n            if x ==0:\\n                count_zero +=1\\n        for i in range(n-1,-1, -1):\\n            if i+count_zero < n:\\n                arr[i+count_zero] = arr[i]\\n            if arr[i] == 0:\\n                count_zero -= 1\\n                if i + count_zero < n:\\n                    arr[i + count_zero] = arr[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160356,
                "title": "hex-python3-two-pointers",
                "content": "## Solution\\n### Simulation\\n- A combination of python\\'s built-in functions pop and insert is used.\\n\\n- The time complexity of insert is O(n)\\n\\n```\\nLists:\\n                               Complexity\\nOperation     | Example      | Class         | Notes\\n--------------+--------------+---------------+-------------------------------\\nIndex         | l[i]         | O(1)          |\\nStore         | l[i] = 0     | O(1)          |\\nLength        | len(l)       | O(1)          |\\nAppend        | l.append(5)  | O(1)          |\\nClear         | l.clear()    | O(1)          | similar to l = []\\n\\nSlice         | l[a:b]       | O(b-a)        | l[1:5]:O(l)/l[:]:O(len(l)-0)=O(N)\\nExtend        | l.extend(...)| O(len(...))   | depends only on len of extension\\nConstruction  | list(...)    | len(...)      | depends on lenghth of argument\\n\\ncheck ==, !=  | l1 == l2     | O(N)          |\\nInsert        | l[a:b] = ... | O(N)          |\\nDelete        | del l[i]     | O(N)          |\\nRemove        | l.remove(...)| O(N)          |\\nContainment   | x in/not in l| O(N)          | searches list\\nCopy          | l.copy()     | O(N)          | Same as l[:] which is O(N)\\nPop           | l.pop(...)   | O(N)          |\\nPop           | l.pop()      | O(1)          | same as l.pop(-1), popping at end\\nExtreme value | min(l)/max(l)| O(N)          |\\nReverse       | l.reverse()  | O(N)          |\\nIteration     | for v in l:  | O(N)          |\\n\\nSort          | l.sort()     | O(N Log N)    | key/reverse doesn\\'t change this\\nMultiply      | k*l          | O(k N)        | 5*l is O(N): len(l)*l is O(N**2)\\n```\\n\\n```python\\n# O(n^2) time | O(1) space\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        idx = 0\\n        while idx < len(arr):\\n            if arr[idx] == 0:\\n                arr.pop()\\n                arr.insert(idx, 0)\\n                idx+=1\\n            idx+=1\\n```\\n\\n### Two Pointers\\nTraverse the number of zeros and the end position of the data,\\nImagine that each zero is pushed onto the stack twice, and the traversal ends when the stack is as long as the array. Pops elements from the top of the stack in order.\\n\\nA pointer left represents the data position (the top of the stack), and a pointer represents the write position (the current write position of the original array)\\n\\n```python\\n# O(n) time | O(1) space\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        left = -1\\n        top_idx = 0\\n        \\n        while top_idx < len(arr):\\n            left+=1\\n            if arr[left]:\\n                top_idx+=1\\n            else:\\n                top_idx+=2\\n            \\n        right = len(arr)-1\\n        if top_idx == len(arr) +1:\\n            arr[right] = 0\\n            right -=1\\n            left -=1\\n        \\n        while right >=0:\\n            arr[right] = arr[left]\\n            right -=1\\n            if arr[left] == 0:\\n                arr[right] = arr[left]\\n                right -=1\\n            left-=1\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nLists:\\n                               Complexity\\nOperation     | Example      | Class         | Notes\\n--------------+--------------+---------------+-------------------------------\\nIndex         | l[i]         | O(1)          |\\nStore         | l[i] = 0     | O(1)          |\\nLength        | len(l)       | O(1)          |\\nAppend        | l.append(5)  | O(1)          |\\nClear         | l.clear()    | O(1)          | similar to l = []\\n\\nSlice         | l[a:b]       | O(b-a)        | l[1:5]:O(l)/l[:]:O(len(l)-0)=O(N)\\nExtend        | l.extend(...)| O(len(...))   | depends only on len of extension\\nConstruction  | list(...)    | len(...)      | depends on lenghth of argument\\n\\ncheck ==, !=  | l1 == l2     | O(N)          |\\nInsert        | l[a:b] = ... | O(N)          |\\nDelete        | del l[i]     | O(N)          |\\nRemove        | l.remove(...)| O(N)          |\\nContainment   | x in/not in l| O(N)          | searches list\\nCopy          | l.copy()     | O(N)          | Same as l[:] which is O(N)\\nPop           | l.pop(...)   | O(N)          |\\nPop           | l.pop()      | O(1)          | same as l.pop(-1), popping at end\\nExtreme value | min(l)/max(l)| O(N)          |\\nReverse       | l.reverse()  | O(N)          |\\nIteration     | for v in l:  | O(N)          |\\n\\nSort          | l.sort()     | O(N Log N)    | key/reverse doesn\\'t change this\\nMultiply      | k*l          | O(k N)        | 5*l is O(N): len(l)*l is O(N**2)\\n```\n```python\\n# O(n^2) time | O(1) space\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        idx = 0\\n        while idx < len(arr):\\n            if arr[idx] == 0:\\n                arr.pop()\\n                arr.insert(idx, 0)\\n                idx+=1\\n            idx+=1\\n```\n```python\\n# O(n) time | O(1) space\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        left = -1\\n        top_idx = 0\\n        \\n        while top_idx < len(arr):\\n            left+=1\\n            if arr[left]:\\n                top_idx+=1\\n            else:\\n                top_idx+=2\\n            \\n        right = len(arr)-1\\n        if top_idx == len(arr) +1:\\n            arr[right] = 0\\n            right -=1\\n            left -=1\\n        \\n        while right >=0:\\n            arr[right] = arr[left]\\n            right -=1\\n            if arr[left] == 0:\\n                arr[right] = arr[left]\\n                right -=1\\n            left-=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143771,
                "title": "c-easy-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        //int val=count(arr.begin(),arr.end(),1);\\n        \\n        vector<int>aksh;\\n        // just removing the base case ............\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i] !=0)\\n            {\\n             aksh.push_back(arr[i]);\\n            }\\n            else\\n            {\\n                aksh.push_back(0);\\n                aksh.push_back(0);\\n            }\\n            if(aksh.size()==n)\\n            {\\n                break;\\n            }\\n        }\\n        aksh.resize(n);\\n        arr=aksh;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        //int val=count(arr.begin(),arr.end(),1);\\n        \\n        vector<int>aksh;\\n        // just removing the base case ............\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i] !=0)\\n            {\\n             aksh.push_back(arr[i]);\\n            }\\n            else\\n            {\\n                aksh.push_back(0);\\n                aksh.push_back(0);\\n            }\\n            if(aksh.size()==n)\\n            {\\n                break;\\n            }\\n        }\\n        aksh.resize(n);\\n        arr=aksh;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076271,
                "title": "c-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int n = arr.size();\\n        stack<int> st,st2 ;\\n\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            st.push(arr[i]);\\n            if(st.top()==0)\\n            {\\n                st.push(0);\\n            }\\n            \\n        }\\n        int k = st.size();\\n        while(k!=n)\\n        {\\n           st.pop(); \\n            k--;\\n        }\\n        int arr2[n];\\n        int i=0;\\nwhile(st.empty()!=true)\\n{\\n    st2.push(st.top());\\n    st.pop();\\n}\\n          while(st2.empty()!=true)\\n          {\\n              arr[i]=st2.top();\\n              st2.pop();\\n              i++;\\n          }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int n = arr.size();\\n        stack<int> st,st2 ;\\n\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            st.push(arr[i]);\\n            if(st.top()==0)\\n            {\\n                st.push(0);\\n            }\\n            \\n        }\\n        int k = st.size();\\n        while(k!=n)\\n        {\\n           st.pop(); \\n            k--;\\n        }\\n        int arr2[n];\\n        int i=0;\\nwhile(st.empty()!=true)\\n{\\n    st2.push(st.top());\\n    st.pop();\\n}\\n          while(st2.empty()!=true)\\n          {\\n              arr[i]=st2.top();\\n              st2.pop();\\n              i++;\\n          }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025687,
                "title": "java-multiple-approaches-easy-understanding-brute-force-to-optimal",
                "content": "\\n\\tpublic class DuplicateZeros {\\n\\n    public static void main(String[] args) {\\n        int[] arr = {1, 0, 2, 3, 0, 4, 5, 0};\\n        duplicateZerosApproach3Optimal(arr);\\n        System.out.println(\"\");\\n    }\\n\\n    // TC: O(N^2) SC: O(1)\\n    private static void duplicateZerosApproach1(int[] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) {\\n                shiftRight(arr, i);\\n                i++;\\n            }\\n        }\\n    }\\n\\n    private static void shiftRight(int[] arr, int i) {\\n        for (int j = arr.length - 1; j > i; j--) {\\n            arr[j] = arr[j - 1];\\n        }\\n    }\\n\\n    // TC: O(N) SC: O(N)\\n    private static void duplicateZerosApproach2UsingQueue(int[] arr) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            queue.add(arr[i]);\\n            if (arr[i] == 0) {\\n                queue.add(0);\\n            }\\n            arr[i] = queue.remove();\\n        }\\n    }\\n\\n\\n    // TC: O(N) SC: O(1)\\n    private static void duplicateZerosApproach3Optimal(int[] arr) {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==0){\\n                count++;\\n            }\\n        }\\n        int i=arr.length-1, j=arr.length+count-1;\\n        while(i!=j){\\n            insert(arr,i,j--);\\n            if(arr[i]==0){\\n                insert(arr,i,j--);\\n            }\\n            i--;\\n        }\\n\\n    }\\n\\n    private static void insert(int[] arr, int i, int j) {\\n        if(j<arr.length){\\n            arr[j]=arr[i];\\n        }\\n    }\\n\\n\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "\\n\\tpublic class DuplicateZeros {\\n\\n    public static void main(String[] args) {\\n        int[] arr = {1, 0, 2, 3, 0, 4, 5, 0};\\n        duplicateZerosApproach3Optimal(arr);\\n        System.out.println(\"\");\\n    }\\n\\n    // TC: O(N^2) SC: O(1)\\n    private static void duplicateZerosApproach1(int[] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) {\\n                shiftRight(arr, i);\\n                i++;\\n            }\\n        }\\n    }\\n\\n    private static void shiftRight(int[] arr, int i) {\\n        for (int j = arr.length - 1; j > i; j--) {\\n            arr[j] = arr[j - 1];\\n        }\\n    }\\n\\n    // TC: O(N) SC: O(N)\\n    private static void duplicateZerosApproach2UsingQueue(int[] arr) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            queue.add(arr[i]);\\n            if (arr[i] == 0) {\\n                queue.add(0);\\n            }\\n            arr[i] = queue.remove();\\n        }\\n    }\\n\\n\\n    // TC: O(N) SC: O(1)\\n    private static void duplicateZerosApproach3Optimal(int[] arr) {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==0){\\n                count++;\\n            }\\n        }\\n        int i=arr.length-1, j=arr.length+count-1;\\n        while(i!=j){\\n            insert(arr,i,j--);\\n            if(arr[i]==0){\\n                insert(arr,i,j--);\\n            }\\n            i--;\\n        }\\n\\n    }\\n\\n    private static void insert(int[] arr, int i, int j) {\\n        if(j<arr.length){\\n            arr[j]=arr[i];\\n        }\\n    }\\n\\n\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1883014,
                "title": "c-solution",
                "content": "```\\n public void DuplicateZeros(int[] arr) {\\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            if (arr[i] == 0)\\n            {\\n                for(int j = arr.Length - 1; j > i; j--)\\n                {\\n                    arr[j] = arr[j - 1];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public void DuplicateZeros(int[] arr) {\\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            if (arr[i] == 0)\\n            {\\n                for(int j = arr.Length - 1; j > i; j--)\\n                {\\n                    arr[j] = arr[j - 1];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1862515,
                "title": "java-time-o-n-space-o-n",
                "content": "\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int zeroCount = 0;\\n        int n = arr.length;\\n        \\n        //if input = [1,0,2,3,0,4,5,0]\\n            //zeroCount = 3\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 0) {\\n                zeroCount++;\\n            }\\n        }\\n        \\n        // temptArray size = n + 3\\n        int[] temptArray = new int[n + zeroCount];\\n        int index = 0;\\n        \\n        //temptArray = [1,0,0,2,3,0,0,4,5,0,0]\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 0) {\\n                temptArray[++index] = 0;\\n            }\\n            else {\\n                temptArray[index] = arr[i];\\n            }\\n            \\n            index++;\\n        }\\n        \\n        // arr = [1,0,0,2,3,0,0,4]  won\\'t add in [5, 0, 0]\\n        for (int i = 0; i < n; i++) {\\n            arr[i] = temptArray[i];\\n        }\\n        \\n        //Time: O(n)\\n        //Space: O(n)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int zeroCount = 0;\\n        int n = arr.length;\\n        \\n        //if input = [1,0,2,3,0,4,5,0]\\n            //zeroCount = 3\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 0) {\\n                zeroCount++;\\n            }\\n        }\\n        \\n        // temptArray size = n + 3\\n        int[] temptArray = new int[n + zeroCount];\\n        int index = 0;\\n        \\n        //temptArray = [1,0,0,2,3,0,0,4,5,0,0]\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 0) {\\n                temptArray[++index] = 0;\\n            }\\n            else {\\n                temptArray[index] = arr[i];\\n            }\\n            \\n            index++;\\n        }\\n        \\n        // arr = [1,0,0,2,3,0,0,4]  won\\'t add in [5, 0, 0]\\n        for (int i = 0; i < n; i++) {\\n            arr[i] = temptArray[i];\\n        }\\n        \\n        //Time: O(n)\\n        //Space: O(n)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724484,
                "title": "easy-java-solution-in-o-n",
                "content": "```class Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int i = 0 , len = arr.length;\\n        \\n       while(i < len-1){\\n            if(arr[i] == 0){\\n                for(int j = len - 2 ; j > i ; j--){\\n                    arr[j+1] = arr[j];\\n                }\\n                arr[i+1] = 0;\\n                i++;\\n            }\\n           i++;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int i = 0 , len = arr.length;\\n        \\n       while(i < len-1){\\n            if(arr[i] == 0){\\n                for(int j = len - 2 ; j > i ; j--){\\n                    arr[j+1] = arr[j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1688467,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {void} Do not return anything, modify arr in-place instead.\\n */\\nvar duplicateZeros = function(arr) {\\n    for(let i=0; i<arr.length; i++) {\\n        if(arr[i] == 0) {\\n            for(let j=arr.length-1; j>i; j--) {\\n                arr[j] = arr[j - 1];\\n            }\\n            i++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {void} Do not return anything, modify arr in-place instead.\\n */\\nvar duplicateZeros = function(arr) {\\n    for(let i=0; i<arr.length; i++) {\\n        if(arr[i] == 0) {\\n            for(let j=arr.length-1; j>i; j--) {\\n                arr[j] = arr[j - 1];\\n            }\\n            i++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1650941,
                "title": "two-pointers-python-with-easy-to-understand",
                "content": "```py\\nclass Solution:\\n    @staticmethod\\n    def duplicateZeros(arr: List[int]) -> None:\\n        N = len(arr)\\n        cnz = count(arr)\\n\\n        write_idx = N + cnz - 1\\n        curr = N - 1\\n        \\n        while curr >= 0 and write_idx >= 0:\\n            if write_idx < N:\\n                arr[write_idx] = arr[curr]\\n            write_idx -=1\\n            \\n            if arr[curr] == 0:\\n                if write_idx < N:\\n                    arr[write_idx] = arr[curr]\\n                write_idx -= 1\\n            curr-=1\\n    \\n    @staticmethod\\n    def count(arr: List[int]) -> int:\\n        count = 0\\n        for e in arr:\\n            if e == 0:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    @staticmethod\\n    def duplicateZeros(arr: List[int]) -> None:\\n        N = len(arr)\\n        cnz = count(arr)\\n\\n        write_idx = N + cnz - 1\\n        curr = N - 1\\n        \\n        while curr >= 0 and write_idx >= 0:\\n            if write_idx < N:\\n                arr[write_idx] = arr[curr]\\n            write_idx -=1\\n            \\n            if arr[curr] == 0:\\n                if write_idx < N:\\n                    arr[write_idx] = arr[curr]\\n                write_idx -= 1\\n            curr-=1\\n    \\n    @staticmethod\\n    def count(arr: List[int]) -> int:\\n        count = 0\\n        for e in arr:\\n            if e == 0:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622200,
                "title": "javascript-efficient-solution-w-o-splice-beats-99",
                "content": "```\\nvar duplicateZeros = function(arr) {\\n    let zeroesCount = arr.filter(x => x === 0).length;\\n    const len = arr.length;\\n    for (let i = len-1; i>= 0; i--) {\\n        if (i + zeroesCount < len) {\\n            arr[i + zeroesCount] = arr[i];\\n        }\\n        if (arr[i] === 0) {\\n            zeroesCount--;\\n            if (i + zeroesCount < len) {\\n                arr[i + zeroesCount] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    let zeroesCount = arr.filter(x => x === 0).length;\\n    const len = arr.length;\\n    for (let i = len-1; i>= 0; i--) {\\n        if (i + zeroesCount < len) {\\n            arr[i + zeroesCount] = arr[i];\\n        }\\n        if (arr[i] === 0) {\\n            zeroesCount--;\\n            if (i + zeroesCount < len) {\\n                arr[i + zeroesCount] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1584515,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn duplicate_zeros(arr: &mut Vec<i32>) {\\n        let mut i=0;\\n        while i < arr.len()-1{\\n            if arr[i] == 0{\\n                for j in (i+1..=arr.len()-1).rev(){\\n                    arr[j] = arr[j-1]\\n                }\\n                arr[i+1] = 0;\\n                i +=1;\\n            }\\n            i+=1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn duplicate_zeros(arr: &mut Vec<i32>) {\\n        let mut i=0;\\n        while i < arr.len()-1{\\n            if arr[i] == 0{\\n                for j in (i+1..=arr.len()-1).rev(){\\n                    arr[j] = arr[j-1]\\n                }\\n                arr[i+1] = 0;\\n                i +=1;\\n            }\\n            i+=1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1532914,
                "title": "python3-simple-and-easy-one-faster-than-94",
                "content": "class Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \\n        \"\"\"\\n        i = 0 \\n        n = len(arr)\\n        while i < n :\\n            \\n            if arr[i] == 0:\\n                ## remove the last one \\n                arr.pop()\\n                ### insert 0 next to 0 \\n                arr.insert(i+1, 0)\\n                i += 2\\n            else:\\n                i += 1\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \\n        \"\"\"\\n        i = 0 \\n        n = len(arr)\\n        while i < n :\\n            \\n            if arr[i] == 0:\\n                ## remove the last one \\n                arr.pop()\\n                ### insert 0 next to 0 \\n                arr.insert(i+1, 0)\\n                i += 2\\n            else:\\n                i += 1\\n",
                "codeTag": "Java"
            },
            {
                "id": 1421031,
                "title": "c-o-n-o-1-simple-solution-explained-faster-94-25-memory-99-85",
                "content": "Steps:\\n* First find how many elements will cover up the whole array if we duplicate 0. let, till index `i`.\\n* Then try to stretch the subarray `[0,i]` to the right.\\n[ if the value at index `i` is 0, duplicating it may exceed the array length ]\\n\\nConsider the given example:\\n`[1,0,2,3,0,4,5,0]`, array length is 8.\\n\\t\\t\\t\\t\\t\\t\\t\\tindex: `0 1 2 3 4 5 6 7`\\ncontribution in final array: `1 2 1 1 2 1 1 2`\\n\\nSo the  the subarray [0,5] will cover up the array of length 8.\\n\\nNow, stretch the array to the right:\\nput value of index \\n* 5 to index 7              ` [ -, -, -, -, -, -, -, 4]`\\n* 4 to index 6 & 5  ` [ -, -, -, -, -, 0, 0, 4]`\\n*  3 to index 4   `[ -, -, -, -,3, 0, 0, 4]`\\n*   2 to index 3   ` [ -, -, -, 2,3, 0, 0, 4]`\\n*   1 to index 2 & 1  ` [ -, 0, 0, 2,3, 0, 0, 4]`\\n*   0 to index 0   `[ 1, 0, 0, 2,3, 0, 0, 4]`\\n\\nConsider another case: [1,0,2,3,0,4]\\nHere, stretching range [0,4] will cover the full array. But duplicating all 0 will exceed the given array length.\\nI handled this case manually.\\n\\nHere is my solution:\\n```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int n = arr.size();\\n        int cnt = 0, idx;\\n        for(idx=0;idx<n; idx++ ){\\n            cnt++;\\n            if(!arr[idx]) cnt++;\\n            if(cnt>=n) break;\\n        }\\n        int pos = n-1;\\n        if(cnt>n){\\n            arr[pos--] = 0;\\n            idx--;\\n        }\\n        while(idx>=0){\\n            if(arr[i]){\\n                arr[pos--] = arr[i];\\n            }\\n            else{\\n                arr[pos--] = 0;\\n                arr[pos--] = 0;\\n            }\\n            idx--;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int n = arr.size();\\n        int cnt = 0, idx;\\n        for(idx=0;idx<n; idx++ ){\\n            cnt++;\\n            if(!arr[idx]) cnt++;\\n            if(cnt>=n) break;\\n        }\\n        int pos = n-1;\\n        if(cnt>n){\\n            arr[pos--] = 0;\\n            idx--;\\n        }\\n        while(idx>=0){\\n            if(arr[i]){\\n                arr[pos--] = arr[i];\\n            }\\n            else{\\n                arr[pos--] = 0;\\n                arr[pos--] = 0;\\n            }\\n            idx--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399539,
                "title": "simple-and-short-java-solution-must-check",
                "content": "```\\nclass Solution {\\n    public static void duplicateZeros(int[] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) {\\n                for (int j = arr.length - 1; j > i; j--) {\\n                    arr[j] = arr[j - 1];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static void duplicateZeros(int[] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) {\\n                for (int j = arr.length - 1; j > i; j--) {\\n                    arr[j] = arr[j - 1];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352622,
                "title": "java-optimal-solution",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        /*\\n        Ip:[1,0,2,3,0,4,5,0]\\n        convert: [1,0,0,2,3,0,0,4]\\n        */\\n         int i = 0, sh = 0;\\n         for (i = 0; sh + i < arr.length; i++){\\n             sh += arr[i] == 0 ? 1 : 0;  //count shift required because of 0\\n         } \\n        //i at end ..traverse from end \\n        //sh=3 i=8\\n        //System.out.println(sh+\":\"+i);\\n         for (i = i - 1; sh > 0; i--) {\\n            if (i + sh < arr.length){\\n                arr[i + sh] = arr[i];\\n            }\\n            if (arr[i] == 0){\\n                sh--;\\n                arr[i + sh] = arr[i];\\n            } \\n          }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        /*\\n        Ip:[1,0,2,3,0,4,5,0]\\n        convert: [1,0,0,2,3,0,0,4]\\n        */\\n         int i = 0, sh = 0;\\n         for (i = 0; sh + i < arr.length; i++){\\n             sh += arr[i] == 0 ? 1 : 0;  //count shift required because of 0\\n         } \\n        //i at end ..traverse from end \\n        //sh=3 i=8\\n        //System.out.println(sh+\":\"+i);\\n         for (i = i - 1; sh > 0; i--) {\\n            if (i + sh < arr.length){\\n                arr[i + sh] = arr[i];\\n            }\\n            if (arr[i] == 0){\\n                sh--;\\n                arr[i + sh] = arr[i];\\n            } \\n          }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351369,
                "title": "duplicate-zeroes-java-solutiion",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        /*\\n        Ip:[1,0,2,3,0,4,5,0]\\n        convert: [1,0,0,2,3,0,0,4]\\n        */\\n         int i = 0, sh = 0;\\n         for (i = 0; sh + i < arr.length; i++){\\n             sh += arr[i] == 0 ? 1 : 0;  //count shift required because of 0\\n         } \\n        //i at end ..traverse from end \\n        //sh=2 i=6\\n        //System.out.println(sh+\":\"+i);\\n         for (i = i - 1; sh > 0; i--) {\\n            if (i + sh < arr.length){\\n                arr[i + sh] = arr[i];\\n            }\\n            if (arr[i] == 0){\\n                sh--;\\n                arr[i + sh] = arr[i];\\n            } \\n          }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        /*\\n        Ip:[1,0,2,3,0,4,5,0]\\n        convert: [1,0,0,2,3,0,0,4]\\n        */\\n         int i = 0, sh = 0;\\n         for (i = 0; sh + i < arr.length; i++){\\n             sh += arr[i] == 0 ? 1 : 0;  //count shift required because of 0\\n         } \\n        //i at end ..traverse from end \\n        //sh=2 i=6\\n        //System.out.println(sh+\":\"+i);\\n         for (i = i - 1; sh > 0; i--) {\\n            if (i + sh < arr.length){\\n                arr[i + sh] = arr[i];\\n            }\\n            if (arr[i] == 0){\\n                sh--;\\n                arr[i + sh] = arr[i];\\n            } \\n          }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350348,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n    for(int i=0 ; i<arr.size() ; i++)\\n    {if(arr[i]==0)\\n        { arr.pop_back();\\n         arr.insert(arr.begin()+ i , 0 );\\n          i++;}}\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n    for(int i=0 ; i<arr.size() ; i++)\\n    {if(arr[i]==0)\\n        { arr.pop_back();\\n         arr.insert(arr.begin()+ i , 0 );\\n          i++;}}\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332592,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i=0\\n        while i<len(arr):\\n\\n            if arr[i] ==0:\\n                arr.pop()\\n                arr.insert(i+1,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i=0\\n        while i<len(arr):\\n\\n            if arr[i] ==0:\\n                arr.pop()\\n                arr.insert(i+1,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332132,
                "title": "java-solution-beginner-friendly-easy-to-follow",
                "content": "Here is my java solution that made the most sense to me after following the tutorial\\'s train of thinking. Any suggestions or thoughts? And may someone tell me the runtime of this.\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for (int i=0; i<arr.length-1; i++) {\\n            if(arr[i]==0){ \\n                for(int j=arr.length-1; j>i; j--){ \\n                    arr[j]=arr[j-1];\\n                }\\n                i+=1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for (int i=0; i<arr.length-1; i++) {\\n            if(arr[i]==0){ \\n                for(int j=arr.length-1; j>i; j--){ \\n                    arr[j]=arr[j-1];\\n                }\\n                i+=1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300703,
                "title": "javascript-faster-than-96",
                "content": "Runtime: 80 ms, faster than 96.35% of JavaScript online submissions for Duplicate Zeros.\\nMemory Usage: 40.6 MB, less than 25.67% of JavaScript online submissions for Duplicate Zeros.\\n```\\n/**\\n * @param {number[]} arr\\n * @return {void} Do not return anything, modify arr in-place instead.\\n */\\nvar duplicateZeros = function(arr) {\\n    const res = []\\n    let count = 0\\n    let p = 0\\n    while (count < arr.length) {\\n        const cur = arr[p++]\\n        if (cur !== 0) {\\n            res.push(cur)\\n            count++\\n        } else {\\n            res.push(cur)\\n            res.push(cur)\\n            count += 2\\n        }\\n    }\\n    for (let i = 0; i < arr.length; i++) {\\n        arr[i] = res[i]\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {void} Do not return anything, modify arr in-place instead.\\n */\\nvar duplicateZeros = function(arr) {\\n    const res = []\\n    let count = 0\\n    let p = 0\\n    while (count < arr.length) {\\n        const cur = arr[p++]\\n        if (cur !== 0) {\\n            res.push(cur)\\n            count++\\n        } else {\\n            res.push(cur)\\n            res.push(cur)\\n            count += 2\\n        }\\n    }\\n    for (let i = 0; i < arr.length; i++) {\\n        arr[i] = res[i]\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1295323,
                "title": "java-easy-to-understand-for-beginners-space-o-1",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int len = arr.length;\\n        for(int i=0; i<len; i++){\\n            if(arr[i]==0){\\n                for(int j=len-1; j>i; j--){\\n                    arr[j] = arr[j-1];\\n                }\\n                i++;\\n            }\\n            \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int len = arr.length;\\n        for(int i=0; i<len; i++){\\n            if(arr[i]==0){\\n                for(int j=len-1; j>i; j--){\\n                    arr[j] = arr[j-1];\\n                }\\n                i++;\\n            }\\n            \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265119,
                "title": "simple-c-solution",
                "content": "simple c++ solution. Hoping it\\'s helpful for someone.\\n```\\nvoid duplicateZeros(vector<int> &arr)\\n{\\n    for (int i = 0; i < arr.size() - 1; i++)\\n    {\\n        if (arr[i] == 0)\\n        {\\n            for (int j = arr.size() - 1; j > i + 1; j--)\\n            {\\n                arr[j] = arr[j - 1];\\n            }\\n            arr[i + 1] = 0;\\n            i++;\\n        }\\n    }\\n    return;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid duplicateZeros(vector<int> &arr)\\n{\\n    for (int i = 0; i < arr.size() - 1; i++)\\n    {\\n        if (arr[i] == 0)\\n        {\\n            for (int j = arr.size() - 1; j > i + 1; j--)\\n            {\\n                arr[j] = arr[j - 1];\\n            }\\n            arr[i + 1] = 0;\\n            i++;\\n        }\\n    }\\n    return;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1201839,
                "title": "python-simple-solution",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        i=0\\n        n = len(arr)\\n        while i < n-1:\\n            if arr[i]==0:\\n                arr[:] = arr[:i+1] + [0] + arr[i+1: n-1]\\n                i+=1\\n            i+=1\\n\\t\\t\\t\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        i=0\\n        n = len(arr)\\n        while i < n-1:\\n            if arr[i]==0:\\n                arr[:] = arr[:i+1] + [0] + arr[i+1: n-1]\\n                i+=1\\n            i+=1\\n\\t\\t\\t\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1181438,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                arr.insert(i+1,0)\\n                arr.pop()\\n                i = i + 2\\n            else:\\n                i = i + 1\\n                \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                arr.insert(i+1,0)\\n                arr.pop()\\n                i = i + 2\\n            else:\\n                i = i + 1\\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 1172179,
                "title": "python3-simple-and-easy-to-understand-solution-using-while-loop",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                arr.insert(i+1,0)\\n                arr.pop()\\n                i += 2\\n            else:\\n                i += 1\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                arr.insert(i+1,0)\\n                arr.pop()\\n                i += 2\\n            else:\\n                i += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143716,
                "title": "python-a-very-short-simple-and-intuitive-approach",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        n = len(arr)\\n        i=0\\n        while(i<n):\\n            if arr[i] == 0:\\n                for j in range(n-1, i, -1):\\n                    arr[j] = arr[j-1]\\n                i=i+1\\n            i+=1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        n = len(arr)\\n        i=0\\n        while(i<n):\\n            if arr[i] == 0:\\n                for j in range(n-1, i, -1):\\n                    arr[j] = arr[j-1]\\n                i=i+1\\n            i+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143127,
                "title": "javascript-splice-pop",
                "content": "```\\nvar duplicateZeros = function (arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    if (arr[i] === 0) {\\n      arr.splice(i + 1, 0, 0);\\n      arr.pop();\\n      i++;\\n    }\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar duplicateZeros = function (arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    if (arr[i] === 0) {\\n      arr.splice(i + 1, 0, 0);\\n      arr.pop();\\n      i++;\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1110170,
                "title": "rust-solution-o-n-no-extra-space-0ms-2-1mb",
                "content": "Notice: In Rust, we must convert usize to i32 to minus it, if not it will cause error.\\n```\\nimpl Solution {\\n    fn to_usize(value: i32) -> usize {\\n        value as usize\\n    }\\n    pub fn duplicate_zeros(arr: &mut Vec<i32>) {\\n        let mut pos_dups: i32 = 0;\\n        let mut len: i32 = (arr.len() as i32) - 1;\\n        let mut index: i32 = 0;\\n        while index <= len - pos_dups {\\n            if arr[index as usize] == 0 {\\n\\t\\t\\t\\t// Edge-case: Can\\'t add more item. Ex: [0], [0, 0, 3], etc.\\n                if index == len - pos_dups {\\n                    arr[len as usize] = 0;\\n                    len -= 1;\\n                    break;\\n                }\\n                pos_dups += 1;\\n            }\\n            index += 1;\\n        }\\n        \\n        let mut latest = len - pos_dups;\\n        let mut index = latest;\\n        while index >= 0 {\\n            if arr[index as usize] == 0 {\\n                arr[Solution::to_usize(index + pos_dups)] = 0;\\n                pos_dups -= 1;\\n                arr[Solution::to_usize(index + pos_dups)] = 0;\\n            } else {\\n                arr[Solution::to_usize(index + pos_dups)] = arr[index as usize];\\n            }\\n            index -= 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    fn to_usize(value: i32) -> usize {\\n        value as usize\\n    }\\n    pub fn duplicate_zeros(arr: &mut Vec<i32>) {\\n        let mut pos_dups: i32 = 0;\\n        let mut len: i32 = (arr.len() as i32) - 1;\\n        let mut index: i32 = 0;\\n        while index <= len - pos_dups {\\n            if arr[index as usize] == 0 {\\n\\t\\t\\t\\t// Edge-case: Can\\'t add more item. Ex: [0], [0, 0, 3], etc.\\n                if index == len - pos_dups {\\n                    arr[len as usize] = 0;\\n                    len -= 1;\\n                    break;\\n                }\\n                pos_dups += 1;\\n            }\\n            index += 1;\\n        }\\n        \\n        let mut latest = len - pos_dups;\\n        let mut index = latest;\\n        while index >= 0 {\\n            if arr[index as usize] == 0 {\\n                arr[Solution::to_usize(index + pos_dups)] = 0;\\n                pos_dups -= 1;\\n                arr[Solution::to_usize(index + pos_dups)] = 0;\\n            } else {\\n                arr[Solution::to_usize(index + pos_dups)] = arr[index as usize];\\n            }\\n            index -= 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1071588,
                "title": "easy-java-solution",
                "content": "```\\n\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        \\n        for(int i=0 ; i<arr.length-1 ; i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                for(int j=arr.length-1 ; j>i ; j--)\\n                {\\n                    arr[j]=arr[j-1];\\n                }\\n                arr[i+1]=0;\\n                i=i+1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        \\n        for(int i=0 ; i<arr.length-1 ; i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                for(int j=arr.length-1 ; j>i ; j--)\\n                {\\n                    arr[j]=arr[j-1];\\n                }\\n                arr[i+1]=0;\\n                i=i+1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033831,
                "title": "c-simple-o-n-2-time-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr)\\n    {\\n        int n = arr.size();\\n        for (int i = 0; i < n; ++i)\\n        {\\n            if (arr[i] == 0)\\n            {\\n                arr.insert(arr.begin() + i, 0);\\n                ++i;\\n            }\\n        }\\n        arr.erase(arr.begin() + n, arr.end());\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr)\\n    {\\n        int n = arr.size();\\n        for (int i = 0; i < n; ++i)\\n        {\\n            if (arr[i] == 0)\\n            {\\n                arr.insert(arr.begin() + i, 0);\\n                ++i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 997995,
                "title": "go-solution",
                "content": "Simple solution:\\n```\\nfunc duplicateZeros(arr []int)  {\\n    zerosCount := 0\\n    for _, v := range arr {\\n        if v == 0 {\\n            zerosCount++\\n        }\\n    }\\n    \\n    for i := len(arr)-1; i>=0; i-- {\\n        if arr[i] == 0 {\\n            if i + zerosCount < len(arr) {\\n                arr[i+zerosCount] = 0\\n            }\\n            zerosCount--\\n        } \\n        if i + zerosCount < len(arr) {\\n            arr[i+zerosCount] = arr[i]\\n        }\\n    } \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc duplicateZeros(arr []int)  {\\n    zerosCount := 0\\n    for _, v := range arr {\\n        if v == 0 {\\n            zerosCount++\\n        }\\n    }\\n    \\n    for i := len(arr)-1; i>=0; i-- {\\n        if arr[i] == 0 {\\n            if i + zerosCount < len(arr) {\\n                arr[i+zerosCount] = 0\\n            }\\n            zerosCount--\\n        } \\n        if i + zerosCount < len(arr) {\\n            arr[i+zerosCount] = arr[i]\\n        }\\n    } \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 972050,
                "title": "simple-python-code",
                "content": "loop through the list and i am doing this:\\n**when i find zero:** insert zero at next index and increament the index by two as we need to skip the next value. delete the last index from `arr`\\n\\n**when you dont find zero:** just move on to next value and increament the index by one\\n\\n\\n```\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: None Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                arr.insert(i + 1, 0)\\n                i += 1\\n                del arr[-1]\\n            i += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: None Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                arr.insert(i + 1, 0)\\n                i += 1\\n                del arr[-1]\\n            i += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970218,
                "title": "simple-javascript-solution",
                "content": "```\\nvar duplicateZeros = function(arr) {\\n    for (var i = 0; i < arr.length; ++i) {\\n        if (arr[i] == 0) {\\n            arr.splice(arr.indexOf(0, i), 0, 0)\\n            arr.pop()\\n            i ++\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    for (var i = 0; i < arr.length; ++i) {\\n        if (arr[i] == 0) {\\n            arr.splice(arr.indexOf(0, i), 0, 0)\\n            arr.pop()\\n            i ++\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 970156,
                "title": "easy-python-code-w-video-explanation",
                "content": "Easy Python code w/ video explanation!\\n\\nhttps://www.youtube.com/watch?v=FPumX-iLtlo&t=182s\\n\\n```python\\nclass Solution:\\ndef duplicateZeros(self, arr: [int]) -> None:\\n        n = len(arr)\\n        zeros = arr.count(0)\\n\\n        i = n - 1\\n\\n        while i >= 0:\\n            if i + zeros < n:\\n                arr[i + zeros] = arr[i]\\n                if arr[i] == 0 and i + zeros - 1 >= 0:\\n                    zeros -= 1\\n                    arr[i + zeros] = 0\\n            elif arr[i] == 0:\\n                zeros -= 1\\n            else:\\n                arr[i] = 0\\n            i -= 1\\n\\n        return arr\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\ndef duplicateZeros(self, arr: [int]) -> None:\\n        n = len(arr)\\n        zeros = arr.count(0)\\n\\n        i = n - 1\\n\\n        while i >= 0:\\n            if i + zeros < n:\\n                arr[i + zeros] = arr[i]\\n                if arr[i] == 0 and i + zeros - 1 >= 0:\\n                    zeros -= 1\\n                    arr[i + zeros] = 0\\n            elif arr[i] == 0:\\n                zeros -= 1\\n            else:\\n                arr[i] = 0\\n            i -= 1\\n\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967481,
                "title": "python-eye-candy-solution",
                "content": "Looks like a bit repetitive code, but very easy on eyes and brain cells; song to ears, breeze to the face...\\n```\\ndef duplicateZeros(self, arr):\\n        \\n        numzeros = len([n for n in arr if n == 0])\\n        for i in reversed(range(len(arr))):\\n            \\n            if i + numzeros < len(arr):\\n                arr[i + numzeros] = arr[i]\\n                \\n            if arr[i] == 0:\\n                numzeros -= 1\\n                \\n                if i + numzeros < len(arr):\\n                    arr[i + numzeros] = arr[i]\\n```\\n\\nThis one below is a python specific solution since lists are flexible in python. Definitely more flexible than my back... Gosh I should start doing yoga again.\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                arr[i:i] = [0]\\n                arr.pop()\\n                i += 1\\n            i += 1\\n            \\n \\n\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\ndef duplicateZeros(self, arr):\\n        \\n        numzeros = len([n for n in arr if n == 0])\\n        for i in reversed(range(len(arr))):\\n            \\n            if i + numzeros < len(arr):\\n                arr[i + numzeros] = arr[i]\\n                \\n            if arr[i] == 0:\\n                numzeros -= 1\\n                \\n                if i + numzeros < len(arr):\\n                    arr[i + numzeros] = arr[i]\\n```\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                arr[i:i] = [0]\\n                arr.pop()\\n                i += 1\\n            i += 1\\n            \\n \\n\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 902566,
                "title": "python-deque-a-single-forward-pass-time-o-n-space-o-n",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:        \\n        d = deque()\\n        \\n        for idx, n in enumerate(arr):\\n            if n == 0:\\n                d.append(0)                \\n            d.append(n)    \\n            \\n            arr[idx] = d.popleft()\\n            \\n        return arr\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:        \\n        d = deque()\\n        \\n        for idx, n in enumerate(arr):\\n            if n == 0:\\n                d.append(0)                \\n            d.append(n)    \\n            \\n            arr[idx] = d.popleft()\\n            \\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889298,
                "title": "simple-rust-implementation",
                "content": "Haven\\'t seen a rust tagged implementation in the dicussion so wanted to put my basic solution here. Been using leetcode exercises to learn rust and this one was suprisingly difficult if you are a rust newby and don\\'t realize you can\\'t modify iterator value in `for` loops. (like I didn\\'t for an embarssingly long amount of time). \\n\\n```rust\\nimpl Solution {\\n    pub fn duplicate_zeros(arr: &mut Vec<i32>) {\\n        let mut index = 0;\\n        let total_len = arr.len();\\n        \\n        while index < total_len {\\n            if (arr[index] == 0 && (index + 1) <= arr.len()) {\\n                arr.insert(index + 1, 0);\\n                arr.remove(arr.len() - 1);\\n                index += 2;\\n                continue;\\n            }\\n            \\n            index += 1;\\n        }\\n    }\\n}\\n```\\n\\nUsing rust vectors builtin `insert` and `remove` functions felt a bit like cheating the spirit of the exercise (which seems to be to implement those methods). However it seems implementing these requires(?) the use of rust\\'s `unsafe` keyword which I hadn\\'t had experince with yet. See The Rustonomicon section on [implementing vector insert and remove](https://doc.rust-lang.org/nomicon/vec-insert-remove.html) for more details.",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn duplicate_zeros(arr: &mut Vec<i32>) {\\n        let mut index = 0;\\n        let total_len = arr.len();\\n        \\n        while index < total_len {\\n            if (arr[index] == 0 && (index + 1) <= arr.len()) {\\n                arr.insert(index + 1, 0);\\n                arr.remove(arr.len() - 1);\\n                index += 2;\\n                continue;\\n            }\\n            \\n            index += 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 861379,
                "title": "different-python-solution-o-n-time-o-1-with-full-explantion-easier-to-understand",
                "content": "Let\\'s think about all possible scenarios. The tricky part is which one is the last element we need to fill in the array. For example, In `[1,0,2,0]`, we are looking for `2`\\'s position because `[1,0,0,2],0,0]`. In another example, `[1,0,2,0,1]`, we are looking for `0`\\'s position because `[1,0,0,2,0],0,1]`. If we loop from the beginning and increase `zeros` if we met a `0`, then there will be 2 possible scenarios:\\n1. `i+zeros == len(arr)-1`, which is the first example `[1,0,2,0,1]`->`[1,0,0,2],0,0]`. In this situation, `2+1=3`\\n2. `i+zeros > len(arr)-1`, which is the second example  `[1,0,2,0,1]`->`[1,0,0,2,0],0,1]`. In this situation, `3+2>4`. This is because `0` happens to be last one in the array, we increase `zeros` once we immediately found it.\\nBased on these two senarios, we determine the way how we filled in  from backwards. In the second scenario, we don\\'t need to replicate the last `0` .\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        zeros = 0\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                zeros += 1\\n            if i + zeros == len(arr)-1:\\n                last = i\\n                j = len(arr) - 1\\n                break            \\n            elif i + zeros > len(arr)-1:\\n                arr[-1] = arr[i]\\n                last = i - 1\\n                j = len(arr)-2\\n                break\\n        for i in range(last, -1, -1):\\n            if arr[i] == 0:\\n                arr[j] = 0\\n                arr[j-1] = 0\\n                j -= 2\\n            else:\\n                arr[j] = arr[i]\\n                j -= 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        zeros = 0\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                zeros += 1\\n            if i + zeros == len(arr)-1:\\n                last = i\\n                j = len(arr) - 1\\n                break            \\n            elif i + zeros > len(arr)-1:\\n                arr[-1] = arr[i]\\n                last = i - 1\\n                j = len(arr)-2\\n                break\\n        for i in range(last, -1, -1):\\n            if arr[i] == 0:\\n                arr[j] = 0\\n                arr[j-1] = 0\\n                j -= 2\\n            else:\\n                arr[j] = arr[i]\\n                j -= 1\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568350,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1566971,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1740224,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1722995,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 2000211,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1876680,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1822838,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1777965,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 2069360,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 2048224,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1568350,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1566971,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1740224,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1722995,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 2000211,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1876680,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1822838,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1777965,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 2069360,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 2048224,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped \n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 2045622,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 2039475,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 2039474,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 2032837,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 1998212,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 1991616,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 1984861,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 1957691,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 1950692,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 1933071,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 1910065,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            },
            {
                "id": 1841553,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            },
            {
                "id": 1832922,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            },
            {
                "id": 1810742,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            },
            {
                "id": 1803112,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            },
            {
                "id": 1779046,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            },
            {
                "id": 1771851,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            },
            {
                "id": 1750097,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            },
            {
                "id": 1740168,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            },
            {
                "id": 1734362,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Ways Where Square of Number Is Equal to Product of Two Numbers",
        "question_content": "<p>Given two arrays of integers <code>nums1</code> and <code>nums2</code>, return the number of triplets formed (type 1 and type 2) under the following rules:</p>\n\n<ul>\n\t<li>Type 1: Triplet (i, j, k) if <code>nums1[i]<sup>2</sup> == nums2[j] * nums2[k]</code> where <code>0 &lt;= i &lt; nums1.length</code> and <code>0 &lt;= j &lt; k &lt; nums2.length</code>.</li>\n\t<li>Type 2: Triplet (i, j, k) if <code>nums2[i]<sup>2</sup> == nums1[j] * nums1[k]</code> where <code>0 &lt;= i &lt; nums2.length</code> and <code>0 &lt;= j &lt; k &lt; nums1.length</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [7,4], nums2 = [5,2,8,9]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Type 1: (1, 1, 2), nums1[1]<sup>2</sup> = nums2[1] * nums2[2]. (4<sup>2</sup> = 2 * 8). \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,1], nums2 = [1,1,1]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> All Triplets are valid, because 1<sup>2</sup> = 1 * 1.\nType 1: (0,0,1), (0,0,2), (0,1,2), (1,0,1), (1,0,2), (1,1,2).  nums1[i]<sup>2</sup> = nums2[j] * nums2[k].\nType 2: (0,0,1), (1,0,1), (2,0,1). nums2[i]<sup>2</sup> = nums1[j] * nums1[k].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [7,7,8,3], nums2 = [1,2,9,7]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are 2 valid triplets.\nType 1: (3,0,2).  nums1[3]<sup>2</sup> = nums2[0] * nums2[2].\nType 2: (3,0,1).  nums2[3]<sup>2</sup> = nums1[0] * nums1[1].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 831467,
                "title": "c-java-two-sum-o-n-m",
                "content": "This looks very similar to Two Sum, and we will use [Two Sum: Approach 3](https://leetcode.com/problems/two-sum/solution/).\\n\\nWe just need to call our function \"Two Product\" :)\\n\\n> Update: see below for the optimized version!\\n\\n**C++**\\n```cpp\\nint numTriplets(vector<int>& n1, vector<int>& n2) {\\n    return accumulate(begin(n1), end(n1), 0, [&](int s, long n) { return s + twoProduct(n * n, n2); }) \\n        + accumulate(begin(n2), end(n2), 0, [&](int s, long n) { return s +  twoProduct(n * n, n1); });\\n}\\nint twoProduct(long i, vector<int> &n) {\\n    unordered_map<int, int> m;\\n    int cnt = 0;\\n    for (auto v : n) {\\n        if (i % v == 0)\\n            cnt += m[i / v];\\n        ++m[v];\\n    }\\n    return cnt;\\n} \\n```\\n\\n**Java**\\n```java\\npublic int numTriplets(int[] n1, int[] n2) {\\n    long res = 0;\\n    for (long n : n1)\\n        res += twoProduct(n * n, n2);\\n    for (long n : n2)\\n        res += twoProduct(n * n, n1);\\n    return (int)res;\\n}\\nlong twoProduct(long i, int[] n) {\\n    Map<Long, Long> m = new HashMap<>();\\n    long cnt = 0;\\n    for (long v : n) {\\n        if (i % v == 0)\\n            cnt += m.getOrDefault(i / v, 0l);\\n        m.put(v, m.getOrDefault(v, 0l) + 1);\\n    }\\n    return cnt;\\n}  \\n```\\n\\n#### Optimized Version\\nWe can memoise the result for a given `n`. This will speed up things quite a bit if there is a lot of duplicates. We can use a hashmap, or we can sort the array so duplicates are next to each other. The solution below is an improvement from ~800 ms to ~280 ms.\\n\\n**C++**\\n```cpp\\nint numTriplets(vector<int>& n1, vector<int>& n2) {\\n    return countForArray(n1, n2) + countForArray(n2, n1);\\n}\\nint countForArray(vector<int>& n1, vector<int>& n2) {\\n    int res = 0, last_res = 0, last_n = 0;\\n    sort(begin(n1), end(n1));\\n    for (auto i = 0; i < n1.size(); last_n = n1[i++])\\n        if (n1[i] == last_n)\\n            res += last_res;\\n        else\\n            res += last_res = twoProduct((long)n1[i] * n1[i], n2);\\n    return res;\\n}\\nint twoProduct(long i, vector<int> &n) {\\n    unordered_map<int, int> m;\\n    int cnt = 0;\\n    for (auto v : n) {\\n        if (i % v == 0)\\n            cnt += m[i / v];\\n        ++m[v];\\n    }\\n    return cnt;\\n} \\n```",
                "solutionTags": [],
                "code": "```cpp\\nint numTriplets(vector<int>& n1, vector<int>& n2) {\\n    return accumulate(begin(n1), end(n1), 0, [&](int s, long n) { return s + twoProduct(n * n, n2); }) \\n        + accumulate(begin(n2), end(n2), 0, [&](int s, long n) { return s +  twoProduct(n * n, n1); });\\n}\\nint twoProduct(long i, vector<int> &n) {\\n    unordered_map<int, int> m;\\n    int cnt = 0;\\n    for (auto v : n) {\\n        if (i % v == 0)\\n            cnt += m[i / v];\\n        ++m[v];\\n    }\\n    return cnt;\\n} \\n```\n```java\\npublic int numTriplets(int[] n1, int[] n2) {\\n    long res = 0;\\n    for (long n : n1)\\n        res += twoProduct(n * n, n2);\\n    for (long n : n2)\\n        res += twoProduct(n * n, n1);\\n    return (int)res;\\n}\\nlong twoProduct(long i, int[] n) {\\n    Map<Long, Long> m = new HashMap<>();\\n    long cnt = 0;\\n    for (long v : n) {\\n        if (i % v == 0)\\n            cnt += m.getOrDefault(i / v, 0l);\\n        m.put(v, m.getOrDefault(v, 0l) + 1);\\n    }\\n    return cnt;\\n}  \\n```\n```cpp\\nint numTriplets(vector<int>& n1, vector<int>& n2) {\\n    return countForArray(n1, n2) + countForArray(n2, n1);\\n}\\nint countForArray(vector<int>& n1, vector<int>& n2) {\\n    int res = 0, last_res = 0, last_n = 0;\\n    sort(begin(n1), end(n1));\\n    for (auto i = 0; i < n1.size(); last_n = n1[i++])\\n        if (n1[i] == last_n)\\n            res += last_res;\\n        else\\n            res += last_res = twoProduct((long)n1[i] * n1[i], n2);\\n    return res;\\n}\\nint twoProduct(long i, vector<int> &n) {\\n    unordered_map<int, int> m;\\n    int cnt = 0;\\n    for (auto v : n) {\\n        if (i % v == 0)\\n            cnt += m[i / v];\\n        ++m[v];\\n    }\\n    return cnt;\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 831519,
                "title": "c-o-mn-with-explanation",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1.\\n\\nType 1 and Type 2 are symmetrical so we can define a function `count(A, B)` which returns the count of the Type 1 triples. The answer is `count(A, B) + count(B, A)`.\\n\\nFor `count(A, B)`, we can use a `unordered_map<int, int> m` to store the frequency of the numbers in `B`. Then for each number `a` in `A`, the `target` value is `a * a`. We traverse the map `m` to count the triplets.\\n\\nFor each entry `(b, cnt)` in `m`:\\n* If `target` is not divisible by `b` or `target / b` is not in `m`, there is no triplets, skip.\\n* If `target / b == b`, we need to pick 2 out of `cnt` numbers so we can add `cnt * (cnt - 1)` triplets to the answer.\\n* Otherwise, we can add `cnt * m[target / b]` triplets to the answer.\\n\\nSince we count the the pairs in `B` twice, we need to divide the answer by 2 before returning.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/\\n// Author: github.com/lzl124631x\\n// Time: O(N^2)\\n// Space: O(N)\\nclass Solution {\\n    int count(vector<int> &A, vector<int> &B) {\\n        int ans = 0;\\n        unordered_map<int, int> m;\\n        for (int n : B) m[n]++;\\n        for (int a : A) {\\n            long target = (long)a * a;\\n            for (auto &[b, cnt] : m) {\\n                if (target % b || m.count(target / b) == 0) continue;\\n                if (target / b == b) ans += cnt * (cnt - 1);\\n                else ans += cnt * m[target / b];\\n            }\\n        }\\n        return ans / 2;\\n    }\\npublic:\\n    int numTriplets(vector<int>& A, vector<int>& B) {\\n        return count(A, B) + count(B, A);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/\\n// Author: github.com/lzl124631x\\n// Time: O(N^2)\\n// Space: O(N)\\nclass Solution {\\n    int count(vector<int> &A, vector<int> &B) {\\n        int ans = 0;\\n        unordered_map<int, int> m;\\n        for (int n : B) m[n]++;\\n        for (int a : A) {\\n            long target = (long)a * a;\\n            for (auto &[b, cnt] : m) {\\n                if (target % b || m.count(target / b) == 0) continue;\\n                if (target / b == b) ans += cnt * (cnt - 1);\\n                else ans += cnt * m[target / b];\\n            }\\n        }\\n        return ans / 2;\\n    }\\npublic:\\n    int numTriplets(vector<int>& A, vector<int>& B) {\\n        return count(A, B) + count(B, A);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831684,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\td1 = collections.defaultdict(int)\\n\\t\\t\\td2 = collections.defaultdict(int)\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor num1 in nums1:\\n\\t\\t\\t\\td1[num1 * num1] += 1\\n\\t\\t\\tfor num2 in nums2:\\n\\t\\t\\t\\td2[num2 * num2] += 1        \\n\\t\\t\\tfor i in range(len(nums1) - 1):\\n\\t\\t\\t\\tfor j in range(i + 1, len(nums1)):\\n\\t\\t\\t\\t\\tres += d2[nums1[i] * nums1[j]]\\n\\t\\t\\tfor i in range(len(nums2) - 1):\\n\\t\\t\\t\\tfor j in range(i + 1, len(nums2)):\\n\\t\\t\\t\\t\\tres += d1[nums2[i] * nums2[j]]\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\td1 = collections.defaultdict(int)\\n\\t\\t\\td2 = collections.defaultdict(int)\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor num1 in nums1:\\n\\t\\t\\t\\td1[num1 * num1] += 1\\n\\t\\t\\tfor num2 in nums2:\\n\\t\\t\\t\\td2[num2 * num2] += 1        \\n\\t\\t\\tfor i in range(len(nums1) - 1):\\n\\t\\t\\t\\tfor j in range(i + 1, len(nums1)):\\n\\t\\t\\t\\t\\tres += d2[nums1[i] * nums1[j]]\\n\\t\\t\\tfor i in range(len(nums2) - 1):\\n\\t\\t\\t\\tfor j in range(i + 1, len(nums2)):\\n\\t\\t\\t\\t\\tres += d1[nums2[i] * nums2[j]]\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 831566,
                "title": "python-instructions-to-code-intuitive",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        def is_perf_sqrt(n): \\n            \"\"\"\\n            returns bool if a number is a perfect square\\n            like 4, 16, 25 --> True\\n            \"\"\"\\n            return int(math.sqrt(n) + 0.5) ** 2 == n\\n\\n        nums1_cntr, nums2_cntr = Counter(nums1), Counter(nums2)\\n\\n        s = 0\\n        for x, y in itertools.combinations(nums2, 2):\\n            if is_perf_sqrt(x * y): \\n\\t\\t\\t\\t# if product is perfect square, get count of sqrt(of_product)\\n\\t\\t\\t\\ts += nums1_cntr[math.sqrt(x * y)]\\n\\t\\t\\n\\t\\t# similar vice-versa logic\\n        for x, y in itertools.combinations(nums1, 2):\\n            if is_perf_sqrt(x * y): s += nums2_cntr[math.sqrt(x * y)]\\n\\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        def is_perf_sqrt(n): \\n            \"\"\"\\n            returns bool if a number is a perfect square\\n            like 4, 16, 25 --> True\\n            \"\"\"\\n            return int(math.sqrt(n) + 0.5) ** 2 == n\\n\\n        nums1_cntr, nums2_cntr = Counter(nums1), Counter(nums2)\\n\\n        s = 0\\n        for x, y in itertools.combinations(nums2, 2):\\n            if is_perf_sqrt(x * y): \\n\\t\\t\\t\\t# if product is perfect square, get count of sqrt(of_product)\\n\\t\\t\\t\\ts += nums1_cntr[math.sqrt(x * y)]\\n\\t\\t\\n\\t\\t# similar vice-versa logic\\n        for x, y in itertools.combinations(nums1, 2):\\n            if is_perf_sqrt(x * y): s += nums2_cntr[math.sqrt(x * y)]\\n\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831508,
                "title": "java-simple-sort",
                "content": "An easy way to sort and count:\\n1, sort all arrays by non-decreasing order;\\n2, for each i, shrink from left and right as j and k, then find each triples\\n3, handle special case for  dups, such as[1, 1], [1, 1, 1]\\nTime: O(M*N)\\nSpace: O(1)\\n\\n```\\nclass Solution {\\n    public int numTriplets(int[] a, int[] b) {\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        return cnt(a, b) + cnt(b, a);\\n    }\\n    \\n    private int cnt(int[] a, int[] b) {\\n        int res = 0, m = a.length, n = b.length;\\n        for (int i = 0; i < m; i++) {\\n            long t = ((long) a[i]) * ((long) a[i]);\\n            for (int l = 0, r = n - 1; l < n - 1; l++) { // finding pairs for i, l, r;\\n                if (((long) b[l]) * ((long) b[r]) < t) continue;\\n                while (r >= l && ((long) b[l]) * ((long) b[r]) > t) r--;\\n                if (r <= l) break;\\n                if (((long) b[l]) * ((long) b[r]) == t) {\\n                    int orig = r;\\n                    while(r > l && b[r] == b[orig]) {  // [1, 1], [1, 1, 1]\\n                        r--;\\n                        res++;\\n                    }\\n                    r = orig;  // reset to next cont;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nThere is a better solution to use HashMap turn the l, r findings to O(n) 2-sum ones:\\nThat is straightforward and easy understanding.\\nAnother good point is that you don\\'t have to sort the arrays.\\nTime: O(M * N)\\nspace: O(max(M, N));\\n```\\nclass Solution {\\n    public int numTriplets(int[] a, int[] b) {\\n        return cnt(a, b) + cnt(b, a);\\n    }\\n    \\n    private int cnt(int[] a, int[] b) {\\n        int res = 0, m = a.length;\\n        for (int i = 0; i < m; i++) {\\n            Map<Long, Integer> map = new HashMap<>();\\n            long t = ((long) a[i]) * ((long) a[i]);\\n            for (long n : b) {  //must transferred to long\\n                if (t % n == 0) res += map.getOrDefault(t / n, 0); //new pair formed btw n and previous found t / n\\n                map.put(n, map.getOrDefault(n, 0) + 1); // cached the count found;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] a, int[] b) {\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        return cnt(a, b) + cnt(b, a);\\n    }\\n    \\n    private int cnt(int[] a, int[] b) {\\n        int res = 0, m = a.length, n = b.length;\\n        for (int i = 0; i < m; i++) {\\n            long t = ((long) a[i]) * ((long) a[i]);\\n            for (int l = 0, r = n - 1; l < n - 1; l++) { // finding pairs for i, l, r;\\n                if (((long) b[l]) * ((long) b[r]) < t) continue;\\n                while (r >= l && ((long) b[l]) * ((long) b[r]) > t) r--;\\n                if (r <= l) break;\\n                if (((long) b[l]) * ((long) b[r]) == t) {\\n                    int orig = r;\\n                    while(r > l && b[r] == b[orig]) {  // [1, 1], [1, 1, 1]\\n                        r--;\\n                        res++;\\n                    }\\n                    r = orig;  // reset to next cont;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numTriplets(int[] a, int[] b) {\\n        return cnt(a, b) + cnt(b, a);\\n    }\\n    \\n    private int cnt(int[] a, int[] b) {\\n        int res = 0, m = a.length;\\n        for (int i = 0; i < m; i++) {\\n            Map<Long, Integer> map = new HashMap<>();\\n            long t = ((long) a[i]) * ((long) a[i]);\\n            for (long n : b) {  //must transferred to long\\n                if (t % n == 0) res += map.getOrDefault(t / n, 0); //new pair formed btw n and previous found t / n\\n                map.put(n, map.getOrDefault(n, 0) + 1); // cached the count found;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087997,
                "title": "c-solution-o-n-m-using-hash-map",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int find(vector<int>nums1,vector<int>nums2)\\n    {\\n        unordered_map<ll,ll>mp;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            for(int j=i+1;j<nums2.size();j++)\\n            {\\n                ll p=(long long)nums2[i]*nums2[j];\\n                mp[p]++;\\n            }\\n        }\\n        ll count=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            ll p=(long long)nums1[i]*nums1[i];\\n            if(mp.find(p)!=mp.end())\\n            {\\n                count+=mp[p];\\n            }\\n        }\\n        return count;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        return find(nums1,nums2)+find(nums2,nums1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int find(vector<int>nums1,vector<int>nums2)\\n    {\\n        unordered_map<ll,ll>mp;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            for(int j=i+1;j<nums2.size();j++)\\n            {\\n                ll p=(long long)nums2[i]*nums2[j];\\n                mp[p]++;\\n            }\\n        }\\n        ll count=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            ll p=(long long)nums1[i]*nums1[i];\\n            if(mp.find(p)!=mp.end())\\n            {\\n                count+=mp[p];\\n            }\\n        }\\n        return count;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        return find(nums1,nums2)+find(nums2,nums1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831781,
                "title": "java-solution-using-sorting-with-explanation-and-comments-4-ms-faster-than-100",
                "content": "1. Sort both arrays.\\n2. Similar to the Two sum we have to find all the pairs that matches to the target. Target is the Square number. \\n3. Start with left pointer set to 0, and right pointer set to length-1.\\n4. Must handle duplicates. \\n\\t* \\te.g. Target: 4, nums = [1,1,4,4]\\n\\t* \\tSo, total 4 pairs with indexes (0,2), (1,2), (0,3), (1,3)\\n\\t* \\twhen left = 0, and right = 3, we found one pair. (0,3)\\n\\t\\t* \\tNow before updating left or right pointer, travesre through all values from left+1 to right whose value is same as nums[left]. It will give us the multiplication equals to target.\\n\\t\\t* \\tThis way we will find next pair (1,3).\\n\\t* Decrement right pointer, and reset left pointer.\\n4. Repeat this process for all values in both arrays.\\n\\nRead the code comments for some added optimization.\\n\\n```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        int count = 0;\\n        count += triplets(nums1, nums2);\\n        count += triplets(nums2, nums1);\\n        \\n        return count;        \\n    }\\n    \\n    public int triplets(int[] nums1, int[] nums2) {\\n        \\n\\t\\tMap<Long, Integer> seen = new HashMap<>();\\n        int count = 0;\\n        \\n        for(int i=0; i<nums1.length; i++) {\\n            long sqr = (long) nums1[i] * nums1[i];  //Target Value. Don\\'t forget to convert to Long\\n            if(seen.containsKey(sqr)) { //If we have already seen the target value, then no need to repeat the process and find the pairs.  \\n                count += seen.get(sqr);\\n                continue;\\n            }\\n            \\n            int localCount = 0;  //Find the pairs for current Target\\n            int left = 0, right = nums2.length-1; \\n\\t\\t\\t\\n            while(left < right) {  //Similar to Two sum, find all pairs whose multiplication equals to Target\\n                if(nums2[left] > sqr)  // For optimization. If the lowest value is larger than target then break the loop.\\n                    break;\\n                long multiple = (long) nums2[left] * nums2[right];\\n                \\n                if(sqr == multiple) {\\n                    if(nums2[left] == nums2[right]) { //Special Case: when numbers from left to right are same. \\n\\t\\t\\t\\t\\t\\tint n = right - left+1;      // In the case the total pairs will be n*(n-1)/2.\\n                        localCount += n * (n-1)/2;\\n                        break;\\n                    }\\n                    localCount++;  // Found one pair: Increament the counter.\\n                    int newL = left+1;  //To handle duplicates pairs, we will check all numbers from left side. Numbers must be same as the left number for equal multiplication.\\n                    for(newL = left+1; newL < right && nums2[newL] == nums2[left]; newL++) {\\n                            localCount++;                        \\n                    }\\n                    right--;\\n                    \\n                } else if (multiple < sqr)\\n                    left++;\\n                else\\n                    right--;\\n            }\\n\\t\\t\\t\\n\\t\\t\\tcount += localCount;\\n            seen.put(sqr, localCount);  //Add the pairs for target value in seen.\\n\\t\\t\\t\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n** Thanks to nanwu6805 for optimization suggestion. We do no need to repeat the same process and can use the count. I changed it a bit and instead used hashmap.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        int count = 0;\\n        count += triplets(nums1, nums2);\\n        count += triplets(nums2, nums1);\\n        \\n        return count;        \\n    }\\n    \\n    public int triplets(int[] nums1, int[] nums2) {\\n        \\n\\t\\tMap<Long, Integer> seen = new HashMap<>();\\n        int count = 0;\\n        \\n        for(int i=0; i<nums1.length; i++) {\\n            long sqr = (long) nums1[i] * nums1[i];  //Target Value. Don\\'t forget to convert to Long\\n            if(seen.containsKey(sqr)) { //If we have already seen the target value, then no need to repeat the process and find the pairs.  \\n                count += seen.get(sqr);\\n                continue;\\n            }\\n            \\n            int localCount = 0;  //Find the pairs for current Target\\n            int left = 0, right = nums2.length-1; \\n\\t\\t\\t\\n            while(left < right) {  //Similar to Two sum, find all pairs whose multiplication equals to Target\\n                if(nums2[left] > sqr)  // For optimization. If the lowest value is larger than target then break the loop.\\n                    break;\\n                long multiple = (long) nums2[left] * nums2[right];\\n                \\n                if(sqr == multiple) {\\n                    if(nums2[left] == nums2[right]) { //Special Case: when numbers from left to right are same. \\n\\t\\t\\t\\t\\t\\tint n = right - left+1;      // In the case the total pairs will be n*(n-1)/2.\\n                        localCount += n * (n-1)/2;\\n                        break;\\n                    }\\n                    localCount++;  // Found one pair: Increament the counter.\\n                    int newL = left+1;  //To handle duplicates pairs, we will check all numbers from left side. Numbers must be same as the left number for equal multiplication.\\n                    for(newL = left+1; newL < right && nums2[newL] == nums2[left]; newL++) {\\n                            localCount++;                        \\n                    }\\n                    right--;\\n                    \\n                } else if (multiple < sqr)\\n                    left++;\\n                else\\n                    right--;\\n            }\\n\\t\\t\\t\\n\\t\\t\\tcount += localCount;\\n            seen.put(sqr, localCount);  //Add the pairs for target value in seen.\\n\\t\\t\\t\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831720,
                "title": "c-two-pointer-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplet(vector<int>& nums1, vector<int>& nums2) {\\n        int count = 0, left, right;\\n        long num1Val, num2Val;\\n        unordered_map<int, int> freq;\\n        \\n        for(int i = 0; i < nums2.size(); i++) freq[nums2[i]]++;\\n        \\n        for(int i = 0; i < nums1.size(); i++) {\\n            left = 0;\\n            right = nums2.size()-1;\\n            num1Val = (long)nums1[i] * nums1[i];\\n            while(left < right) {\\n                num2Val = (long)nums2[left] * nums2[right];\\n                if(num1Val == num2Val) {\\n                    if(nums2[right] == nums2[left]) {\\n                        count += (freq[nums2[right]] * (freq[nums2[right]]-1))/2;\\n                        break;\\n                    }\\n                    count += freq[nums2[right]] * freq[nums2[left]];\\n                    left  += freq[nums2[left]];\\n                    right -= freq[nums2[right]];\\n                } else if(num1Val > num2Val) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        return countTriplet(nums1, nums2) + countTriplet(nums2, nums1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplet(vector<int>& nums1, vector<int>& nums2) {\\n        int count = 0, left, right;\\n        long num1Val, num2Val;\\n        unordered_map<int, int> freq;\\n        \\n        for(int i = 0; i < nums2.size(); i++) freq[nums2[i]]++;\\n        \\n        for(int i = 0; i < nums1.size(); i++) {\\n            left = 0;\\n            right = nums2.size()-1;\\n            num1Val = (long)nums1[i] * nums1[i];\\n            while(left < right) {\\n                num2Val = (long)nums2[left] * nums2[right];\\n                if(num1Val == num2Val) {\\n                    if(nums2[right] == nums2[left]) {\\n                        count += (freq[nums2[right]] * (freq[nums2[right]]-1))/2;\\n                        break;\\n                    }\\n                    count += freq[nums2[right]] * freq[nums2[left]];\\n                    left  += freq[nums2[left]];\\n                    right -= freq[nums2[right]];\\n                } else if(num1Val > num2Val) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        return countTriplet(nums1, nums2) + countTriplet(nums2, nums1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831642,
                "title": "python3-using-counter",
                "content": "For both nums1 and nums2, aggregate all the squares in nums1 and nums2. We will use this to easily track all occurences of nums1[i] * nums1[j]  in nums2 and nums2[i] * nums2[j] in nums1. Then just use nested loops to generate possible combinations that could be in either frequency table.\\n\\n\\n```\\nimport collections\\n\\nclass Solution:\\n    \\n    # nums will be where nums[j] and nums[k] come from\\n    # Look for nums[j] * nums[k] in counts, if it exists grab count from frequency table \"counts\"\\n    def aggregateType(self, nums, counts):\\n        total = 0\\n        \\n        for i in range(0, len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                target = nums[i] * nums[j]\\n                total += counts[target]\\n                \\n        return total\\n    \\n    def numTriplets(self, nums1, nums2):\\n        \\n        #Build frequency table of the squares you can form from num1 and num2\\n        counter1 = collections.Counter([num ** 2 for num in nums1])\\n        counter2 = collections.Counter([num ** 2 for num in nums2])\\n        \\n        return self.aggregateType(nums1, counter2) + self.aggregateType(nums2, counter1)\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\n\\nclass Solution:\\n    \\n    # nums will be where nums[j] and nums[k] come from\\n    # Look for nums[j] * nums[k] in counts, if it exists grab count from frequency table \"counts\"\\n    def aggregateType(self, nums, counts):\\n        total = 0\\n        \\n        for i in range(0, len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                target = nums[i] * nums[j]\\n                total += counts[target]\\n                \\n        return total\\n    \\n    def numTriplets(self, nums1, nums2):\\n        \\n        #Build frequency table of the squares you can form from num1 and num2\\n        counter1 = collections.Counter([num ** 2 for num in nums1])\\n        counter2 = collections.Counter([num ** 2 for num in nums2])\\n        \\n        return self.aggregateType(nums1, counter2) + self.aggregateType(nums2, counter1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831548,
                "title": "straightforward-solution-brute-force-with-optimized-search-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    bool perfectSquare(long long int n) {\\n        long long int ans = sqrt(n);\\n        return n == ans*ans;\\n    }\\n    \\n    int squareRoot(long long int n) {\\n        int ans = sqrt(n);\\n        return ans;\\n    }\\n    \\n    int findTriplets(vector<int> a, vector<int> b) {\\n        int ans = 0;\\n        unordered_map<int, int> frequency;\\n        for (auto &y: b) {\\n            frequency[y]++;\\n        }\\n        int n = a.size();\\n        for (int i=0; i<n-1; i++) { \\n            for (int j=i+1; j<n; j++) {\\n                long long int num = a[i];\\n                num *= a[j];\\n                if (perfectSquare(num)) {\\n                    ans += frequency[squareRoot(num)];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return findTriplets(nums1, nums2) + findTriplets(nums2, nums1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool perfectSquare(long long int n) {\\n        long long int ans = sqrt(n);\\n        return n == ans*ans;\\n    }\\n    \\n    int squareRoot(long long int n) {\\n        int ans = sqrt(n);\\n        return ans;\\n    }\\n    \\n    int findTriplets(vector<int> a, vector<int> b) {\\n        int ans = 0;\\n        unordered_map<int, int> frequency;\\n        for (auto &y: b) {\\n            frequency[y]++;\\n        }\\n        int n = a.size();\\n        for (int i=0; i<n-1; i++) { \\n            for (int j=i+1; j<n; j++) {\\n                long long int num = a[i];\\n                num *= a[j];\\n                if (perfectSquare(num)) {\\n                    ans += frequency[squareRoot(num)];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return findTriplets(nums1, nums2) + findTriplets(nums2, nums1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531661,
                "title": "c-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplet(vector<int> &nums1,vector<int> &nums2)\\n    {\\n        int ans=0,left,right;\\n        unordered_map<int,int> freq;\\n        for(auto &n:nums2)\\n        {\\n            freq[n]++;\\n        }\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            long long t=(long long)nums1[i]*nums1[i];\\n            left=0;\\n            right=nums2.size()-1;\\n            while(left<right)\\n            {\\n                long long temp=(long long)nums2[left]*nums2[right];\\n                if(t==temp)\\n                {\\n                    if(nums2[left]==nums2[right])\\n                    {\\n                        ans+=(freq[nums2[left]]*(freq[nums2[left]]-1))/2;\\n                            break;\\n                    }\\n                    ans+=freq[nums2[left]]*freq[nums2[right]];\\n                    left+=freq[nums2[left]];\\n                    right-=freq[nums2[right]];\\n                }\\n                else if(t>temp)\\n                {\\n                    left+=freq[nums2[left]];\\n                }\\n                else\\n                {\\n                    right-=freq[nums2[right]];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2)\\n    {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        return countTriplet(nums1,nums2)+countTriplet(nums2,nums1);\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int countTriplet(vector<int> &nums1,vector<int> &nums2)\\n    {\\n        int ans=0,left,right;\\n        unordered_map<int,int> freq;\\n        for(auto &n:nums2)\\n        {\\n            freq[n]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1298187,
                "title": "2-pointer-approach-o-1-space-complexity-98-faster",
                "content": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        return count(nums1 , nums2) + count(nums2 , nums1);\\n    }\\n    \\n    public int count(int a[] , int b[]){\\n        int n = a.length;\\n        int m = b.length;\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            long x = (long)a[i]*a[i];\\n            int j = 0;\\n            int k = m-1;\\n            while(j<k){\\n                long prod = (long)b[j]*b[k];\\n                if(prod<x)\\n                    j++;\\n                else if(prod>x)\\n                    k--;\\n                else if(b[j] != b[k]){\\n                    int jNew = j;\\n                    int kNew = k;\\n                    \\n                    while(b[j] == b[jNew])\\n                        jNew++;\\n                    while(b[k] == b[kNew])\\n                        kNew--;\\n                    count += (jNew-j)*(k-kNew);\\n                    j = jNew;\\n                    k = kNew;\\n                }\\n                else{\\n                    int q = k-j+1;\\n                    count += (q)*(q-1)/2;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        return count(nums1 , nums2) + count(nums2 , nums1);\\n    }\\n    \\n    public int count(int a[] , int b[]){\\n        int n = a.length;\\n        int m = b.length;\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            long x = (long)a[i]*a[i];\\n            int j = 0;\\n            int k = m-1;\\n            while(j<k){\\n                long prod = (long)b[j]*b[k];\\n                if(prod<x)\\n                    j++;\\n                else if(prod>x)\\n                    k--;\\n                else if(b[j] != b[k]){\\n                    int jNew = j;\\n                    int kNew = k;\\n                    \\n                    while(b[j] == b[jNew])\\n                        jNew++;\\n                    while(b[k] == b[kNew])\\n                        kNew--;\\n                    count += (jNew-j)*(k-kNew);\\n                    j = jNew;\\n                    k = kNew;\\n                }\\n                else{\\n                    int q = k-j+1;\\n                    count += (q)*(q-1)/2;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831826,
                "title": "c-20ms-12mb-max-o-n1-n2-o-d1-d2-d1-d2-are-number-of-distinct-numbers-in-nums1-and-nums2",
                "content": "Firstly we count how many times each number appeared in each vector.\\n\\nFor each distinct number n1 in one set, we try to find in the other set:\\n  1. `n2 == n1` and n2 appeared at least twice\\n  2. `n2 < n1` and exists n2x that `n2*n2x == n1*n1` => `n2x == n1*n1/n2`\\n\\nFor `1`, if n1 appeared f1 times and n2 appeared f2 times, the total number of combinations is: `f1 * C(f2, 2)` = `f1 * (f2*(f2-1)/2)`\\nFor `2`, if we can find both n2 and n2x, appeared f2 and f2x times respectively, the total number of combinations is: `f1 * (f2*f2x)` (note when n2 < n1, n2x > n1, we don\\'t want to double count, so only check n2 < n1)\\n\\nWe count for type 1, switch them over and count for type 2, finally return the sum.\\n\\n----\\n\\nComplexity analysis:\\n\\n1. Counting number frequency is `O(n1 + n2)`\\n2. Counting combinations, for each distinct number in one set, we check all numbers in the other set, then switch over and do it again: `O(freq1.size() * freq2.size() * 2)`, let d1=freq1.size(), d2=freq2.size() => `O(d1*d2)`\\n\\nEither `1` or `2` can take longer time, for example, if we have all same numbers like `[1,1,1,1,...,1,1]` and `[1,1,1,1,...,1,1]`, `1` takes much longer time than `2`. On the other hand if we have a lot of distinct numbers then `2` will be longer.\\nSo the overall time complexity is `max(O(n1+n2), O(d1*d2))`.\\n\\nWe use 2 hash maps to store the frequencies, so space complexity is `O(d1+d2)`.\\n\\n```cpp\\nint numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n    unordered_map<int64_t, int> freq1, freq2;\\n    for (int n : nums1) freq1[n]++;\\n    for (int n : nums2) freq2[n]++;\\n\\n    auto Count = [](unordered_map<int64_t, int> &freqX, unordered_map<int64_t, int> &freqY) {\\n        int cnt = 0;\\n        for (auto [n1, f1] : freqX) {\\n            int c = 0;\\n            int64_t n1sq = n1*n1;\\n            for (auto [n2, f2] : freqY) {\\n                if (n2 == n1) {\\n                    if (f2 > 1) c += f2*(f2 - 1)/2;\\n                } else if (n2 < n1 && n1sq % n2 == 0) {\\n                    int n2x = n1sq/n2;\\n                    if (freqY.count(n2x)) c += f2*freqY[n2x];\\n                }\\n            }\\n            cnt += c*f1;\\n        }\\n        return cnt;\\n    };\\n\\n    return Count(freq1, freq2) + Count(freq2, freq1);\\n}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n    unordered_map<int64_t, int> freq1, freq2;\\n    for (int n : nums1) freq1[n]++;\\n    for (int n : nums2) freq2[n]++;\\n\\n    auto Count = [](unordered_map<int64_t, int> &freqX, unordered_map<int64_t, int> &freqY) {\\n        int cnt = 0;\\n        for (auto [n1, f1] : freqX) {\\n            int c = 0;\\n            int64_t n1sq = n1*n1;\\n            for (auto [n2, f2] : freqY) {\\n                if (n2 == n1) {\\n                    if (f2 > 1) c += f2*(f2 - 1)/2;\\n                } else if (n2 < n1 && n1sq % n2 == 0) {\\n                    int n2x = n1sq/n2;\\n                    if (freqY.count(n2x)) c += f2*freqY[n2x];\\n                }\\n            }\\n            cnt += c*f1;\\n        }\\n        return cnt;\\n    };\\n\\n    return Count(freq1, freq2) + Count(freq2, freq1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 831722,
                "title": "5-line-java-solution-using-hashmap-with-explanation",
                "content": "**1. Store the value of num1*num1 from the first Array in a map.\\n2. Using two for loops generate all possible combination of num2 and check if the set contains those value.\\n3. If it contains add it to the sum and return it.**\\n```\\npublic int calculate(int[] num1, int[] num2) {\\n        HashMap<Long, Integer> map = new HashMap<>();\\n        long n = num1.length,  m = num2.length, ans = 0;\\n        for(int i=0; i<n; i++) map.put((long)num1[i]*num1[i],map.getOrDefault((long)num1[i]*num1[i],0)+1);\\n        for(int j=0; j<m; j++)  for(int k=j+1; k<m; k++)   ans += (long)map.getOrDefault((long)num2[j]*num2[k],0);\\n        return (int)ans;\\n    }\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        return calculate(nums1,nums2) + calculate(nums2,nums1);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int calculate(int[] num1, int[] num2) {\\n        HashMap<Long, Integer> map = new HashMap<>();\\n        long n = num1.length,  m = num2.length, ans = 0;\\n        for(int i=0; i<n; i++) map.put((long)num1[i]*num1[i],map.getOrDefault((long)num1[i]*num1[i],0)+1);\\n        for(int j=0; j<m; j++)  for(int k=j+1; k<m; k++)   ans += (long)map.getOrDefault((long)num2[j]*num2[k],0);\\n        return (int)ans;\\n    }\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        return calculate(nums1,nums2) + calculate(nums2,nums1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 831634,
                "title": "c-explanation-approach-and-code-and-time-complexity",
                "content": "Approach\\n    0. Sort the arrays since you need to search\\n    For type 1:\\n\\t\\n    1. select first number from nums1\\n    2. Square it\\n    3. Select number from nums2 and divide it by square of nums1[i]\\n    4. If divisible, search for all occurences of the other pair in nums2\\n    5. Lets there be x occurences then add x to ans.\\n    6. But the intresting thing to note is if the numbers selected in nums2 is square root of \\n    number selected in nums1 then we have one extra occurence, so subtract one from answer.\\n    \\nRepeat this for type 2.\\nFinally return answer.\\n\\nSince we sort the array use upper_bound and lower_bound to search in log(n);\\n\\nOverall time Complexity =mlog(n)+nlog(m)\\nwhich is overall nlog(n)\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int count(vector<int> &arr, long long int x, int n)\\n    {\\n\\n        auto low = lower_bound(arr.begin(), arr.end(), x);\\n        if (low == arr.end() || *low != x)\\n            return 0;\\n        auto high = upper_bound(low, arr.end(), x);\\n        return high - low;\\n    }\\n\\n    int numTriplets(vector<int> &nums1, vector<int> &nums2)\\n    {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        int i, j;\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        int trip = 0;\\n        for (i = 0; i < m; i++)\\n        {\\n            long long toSearch = (long long)nums1[i] * (long long)nums1[i];\\n            for (j = 0; j < n; j++)\\n            {\\n                long long int num1 = nums2[j];\\n                if (toSearch % num1 == 0)\\n                {\\n\\n                    int c = count(nums2, toSearch / num1, n);\\n                    if (c > 0)\\n                        trip += c;\\n                    if (num1 * num1 == toSearch)\\n                        trip -= 1;\\n                }\\n            }\\n        }\\n        for (i = 0; i < n; i++)\\n        {\\n            long long toSearch = (long long)nums2[i] * (long long)nums2[i];\\n            for (j = 0; j < m; j++)\\n            {\\n                long long int num1 = nums1[j];\\n                if (toSearch % num1 == 0)\\n                {\\n\\n                    int c = count(nums1, toSearch / num1, m);\\n                    if (c > 0)\\n                        trip += c;\\n                    if (num1 * num1 == toSearch)\\n                        trip -= 1;\\n                }\\n            }\\n        }\\n        return trip / 2;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution\\n{\\npublic:\\n    int count(vector<int> &arr, long long int x, int n)\\n    {\\n\\n        auto low = lower_bound(arr.begin(), arr.end(), x);\\n        if (low == arr.end() || *low != x)\\n            return 0;\\n        auto high = upper_bound(low, arr.end(), x);\\n        return high - low;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2315875,
                "title": "python-3-o-mn-short-and-concise",
                "content": "\\tclass Solution:\\n\\t\\tdef numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\tdef get_res(a,b):\\n\\t\\t\\t\\tres,n=0,len(b)\\n\\t\\t\\t\\tprod=Counter([x*x for x in a])\\n\\t\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t\\tfor j in range(i+1,n):\\n\\t\\t\\t\\t\\t\\tres+=prod[b[i]*b[j]]\\n\\t\\t\\t\\treturn res\\n\\t\\t\\treturn get_res(nums1,nums2)+get_res(nums2,nums1)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\tdef get_res(a,b):\\n\\t\\t\\t\\tres,n=0,len(b)\\n\\t\\t\\t\\tprod=Counter([x*x for x in a])\\n\\t\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t\\tfor j in range(i+1,n):\\n\\t\\t\\t\\t\\t\\tres+=prod[b[i]*b[j]]\\n\\t\\t\\t\\treturn res\\n\\t\\t\\treturn get_res(nums1,nums2)+get_res(nums2,nums1)",
                "codeTag": "Java"
            },
            {
                "id": 1806238,
                "title": "brute-force-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        unordered_map<long, int> m1, m2;\\n        for(int i : nums1) m1[(long long)i*i]++;\\n        for(int i : nums2) m2[(long long)i*i]++;\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<nums2.size()-1; i++){\\n            for(int j=i+1; j<nums2.size(); j++){\\n                if(m1[(long long)nums2[i] * nums2[j]]){\\n                    ans += m1[(long long)nums2[i] * nums2[j]];\\n                }\\n            }\\n        }\\n        for(int i=0; i<nums1.size()-1; i++){\\n            for(int j=i+1; j<nums1.size(); j++){\\n                if(m2[(long long)nums1[i] * nums1[j]]){\\n                    ans += m2[(long long)nums1[i] * nums1[j]];\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        unordered_map<long, int> m1, m2;\\n        for(int i : nums1) m1[(long long)i*i]++;\\n        for(int i : nums2) m2[(long long)i*i]++;\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<nums2.size()-1; i++){\\n            for(int j=i+1; j<nums2.size(); j++){\\n                if(m1[(long long)nums2[i] * nums2[j]]){\\n                    ans += m1[(long long)nums2[i] * nums2[j]];\\n                }\\n            }\\n        }\\n        for(int i=0; i<nums1.size()-1; i++){\\n            for(int j=i+1; j<nums1.size(); j++){\\n                if(m2[(long long)nums1[i] * nums1[j]]){\\n                    ans += m2[(long long)nums1[i] * nums1[j]];\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658113,
                "title": "python-intuitive-hashmap-solution-o-n-m-time",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        sqr1, sqr2 = defaultdict(int), defaultdict(int)\\n        m, n = len(nums1), len(nums2)\\n        for i in range(m):\\n            sqr1[nums1[i]**2] += 1\\n        for j in range(n):\\n            sqr2[nums2[j]**2] += 1\\n            \\n        res = 0 \\n        for i in range(m-1):\\n            for j in range(i+1, m):\\n                if nums1[i]*nums1[j] in sqr2:\\n                    res += sqr2[nums1[i]*nums1[j]]\\n                    \\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                if nums2[i]*nums2[j] in sqr1:\\n                    res += sqr1[nums2[i]*nums2[j]]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        sqr1, sqr2 = defaultdict(int), defaultdict(int)\\n        m, n = len(nums1), len(nums2)\\n        for i in range(m):\\n            sqr1[nums1[i]**2] += 1\\n        for j in range(n):\\n            sqr2[nums2[j]**2] += 1\\n            \\n        res = 0 \\n        for i in range(m-1):\\n            for j in range(i+1, m):\\n                if nums1[i]*nums1[j] in sqr2:\\n                    res += sqr2[nums1[i]*nums1[j]]\\n                    \\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                if nums2[i]*nums2[j] in sqr1:\\n                    res += sqr1[nums2[i]*nums2[j]]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305961,
                "title": "c-a-very-simple-two-sum-like-approach",
                "content": "```\\n//Approach-1 (Simple solution)\\nclass Solution {\\npublic:\\n    void twoProduct(ull target, vector<int> & nums, int &count) {\\n        unordered_map<int, int> mp;\\n        mp[1] = 0;\\n        for(int i = 0; i<nums.size(); i++) {\\n            if(target%nums[i] == 0) {\\n                int remain= target/nums[i];\\n                count += mp[remain];\\n            }\\n            mp[nums[i]]++;\\n        }\\n    }\\n\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        \\n        int count = 0;\\n        for(int i = 0; i<n1; i++) {\\n            twoProduct((long)nums1[i]*nums1[i], nums2, count);\\n        }\\n        \\n        for(int i = 0; i<n2; i++) {\\n            twoProduct((long)nums2[i]*nums2[i], nums1, count);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Using C++ STL for a concise code)\\n//However the concept of both solution are exactly same.\\n//This approach just teaces on how to use STL in C++ to make life easy\\n\\nclass Solution {\\npublic:\\n    int twoProduct(long target, vector<int> &nums) {\\n        unordered_map<int, int> mp;\\n        int count = 0;\\n        \\n        for(int &x : nums) {\\n            if(target%x == 0) {\\n                count += mp[target/x];\\n            }\\n            mp[x]++;\\n        }\\n        return count;\\n    }\\n\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        auto lambda1 = [&](int s, long n) {\\n            return s + twoProduct(n*n, nums2);\\n        };\\n\\n        auto lambda2 = [&](int s, long n) {\\n            return s + twoProduct(n*n, nums1);\\n        };\\n\\n        return accumulate(begin(nums1), end(nums1), 0, lambda1) +\\n               accumulate(begin(nums2), end(nums2), 0, lambda2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Simple solution)\\nclass Solution {\\npublic:\\n    void twoProduct(ull target, vector<int> & nums, int &count) {\\n        unordered_map<int, int> mp;\\n        mp[1] = 0;\\n        for(int i = 0; i<nums.size(); i++) {\\n            if(target%nums[i] == 0) {\\n                int remain= target/nums[i];\\n                count += mp[remain];\\n            }\\n            mp[nums[i]]++;\\n        }\\n    }\\n\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        \\n        int count = 0;\\n        for(int i = 0; i<n1; i++) {\\n            twoProduct((long)nums1[i]*nums1[i], nums2, count);\\n        }\\n        \\n        for(int i = 0; i<n2; i++) {\\n            twoProduct((long)nums2[i]*nums2[i], nums1, count);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\n//Approach-2 (Using C++ STL for a concise code)\\n//However the concept of both solution are exactly same.\\n//This approach just teaces on how to use STL in C++ to make life easy\\n\\nclass Solution {\\npublic:\\n    int twoProduct(long target, vector<int> &nums) {\\n        unordered_map<int, int> mp;\\n        int count = 0;\\n        \\n        for(int &x : nums) {\\n            if(target%x == 0) {\\n                count += mp[target/x];\\n            }\\n            mp[x]++;\\n        }\\n        return count;\\n    }\\n\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        auto lambda1 = [&](int s, long n) {\\n            return s + twoProduct(n*n, nums2);\\n        };\\n\\n        auto lambda2 = [&](int s, long n) {\\n            return s + twoProduct(n*n, nums1);\\n        };\\n\\n        return accumulate(begin(nums1), end(nums1), 0, lambda1) +\\n               accumulate(begin(nums2), end(nums2), 0, lambda2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177779,
                "title": "javascript-solution",
                "content": "```\\nvar numTriplets = function(nums1, nums2) {\\n    const squaredFreq1 = countSquareFreq(nums1);\\n    const squaredFreq2 = countSquareFreq(nums2);\\n    \\n    return countProdFreq(nums1, squaredFreq2) + countProdFreq(nums2, squaredFreq1);\\n\\t\\n    \\n    function countSquareFreq(nums) {\\n        const freq = new Map();\\n        \\n        for (const num of nums) {\\n            const squared = num * num;\\n        \\n            if (!freq.has(squared)) freq.set(squared, 0);\\n            freq.set(squared, freq.get(squared) + 1);\\n         }\\n       \\n        return freq;\\n    }\\n    \\n    function countProdFreq(nums, freqMap) {\\n        let count = 0;\\n        \\n        for (let i = 0;  i < nums.length - 1; i++) {\\n            for (let j = i + 1; j < nums.length; j++) {\\n                const prod = nums[i] * nums[j];\\n            \\n                if (freqMap.has(prod)) count += freqMap.get(prod);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\nvar numTriplets = function(nums1, nums2) {\\n    const squaredFreq1 = countSquareFreq(nums1);\\n    const squaredFreq2 = countSquareFreq(nums2);\\n    \\n    return countProdFreq(nums1, squaredFreq2) + countProdFreq(nums2, squaredFreq1);\\n\\t\\n    \\n    function countSquareFreq(nums) {\\n        const freq = new Map();\\n        \\n        for (const num of nums) {\\n            const squared = num * num;\\n        \\n            if (!freq.has(squared)) freq.set(squared, 0);\\n            freq.set(squared, freq.get(squared) + 1);\\n         }\\n       \\n        return freq;\\n    }\\n    \\n    function countProdFreq(nums, freqMap) {\\n        let count = 0;\\n        \\n        for (let i = 0;  i < nums.length - 1; i++) {\\n            for (let j = i + 1; j < nums.length; j++) {\\n                const prod = nums[i] * nums[j];\\n            \\n                if (freqMap.has(prod)) count += freqMap.get(prod);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850735,
                "title": "93-91-python3-hash-table",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        def helper(A, B):\\n            ans = 0\\n            C = Counter([a*a for a in A])\\n            D = Counter()\\n            for b in B:\\n                for k, v in D.items():\\n                    if k*b in C:\\n                        ans += v * C[k*b]\\n                D[b] += 1\\n            return ans\\n        \\n        return helper(nums1, nums2) + helper(nums2, nums1)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        def helper(A, B):\\n            ans = 0\\n            C = Counter([a*a for a in A])\\n            D = Counter()\\n            for b in B:\\n                for k, v in D.items():\\n                    if k*b in C:\\n                        ans += v * C[k*b]\\n                D[b] += 1\\n            return ans\\n        \\n        return helper(nums1, nums2) + helper(nums2, nums1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831956,
                "title": "c-code-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int get(vector<int>& nums1, vector<int>& nums2)\\n    {\\n        unordered_map<long long int,long long int>m;int ans=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            m[(long long )nums1[i]*nums1[i]]++;\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            for(int j=i+1;j<nums2.size();j++)\\n            {\\n                if(m.find((long long)nums2[i]*nums2[j])!=m.end())ans+=m[(long long)nums2[i]*nums2[j]];\\n            }\\n        }return ans;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n      return get(nums1,nums2)+get(nums2,nums1);}\\n}; \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int get(vector<int>& nums1, vector<int>& nums2)\\n    {\\n        unordered_map<long long int,long long int>m;int ans=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            m[(long long )nums1[i]*nums1[i]]++;\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            for(int j=i+1;j<nums2.size();j++)\\n            {\\n                if(m.find((long long)nums2[i]*nums2[j])!=m.end())ans+=m[(long long)nums2[i]*nums2[j]];\\n            }\\n        }return ans;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n      return get(nums1,nums2)+get(nums2,nums1);}\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 831557,
                "title": "c-easy-3-sum-2-pointer-with-comments-o-n-m-time-o-1-space",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n\\t// returns count of valids triplets (i, j, K) of type 1\\n\\t// note that to find of type 2, just swap nums1 and nums2 while calling \\n    int returnCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        int count = 0;\\n        \\n        for(int k=0; k<n; k++) {\\n            ll target = nums1[k]*1ll*nums1[k];\\n\\t\\t\\t// we\\'ll find two numbers in nums2 such that their product equals target \\n            int i=0, j=m-1;\\n            while(i<j) {\\n                ll prod = nums2[i]*1ll*nums2[j];\\n                if(prod == target) {\\n\\t\\t\\t\\t\\t// case 1 : nums[i] == nums[j]\\n\\t\\t\\t\\t\\t// this means all numbers in between i & j are same and\\n\\t\\t\\t\\t\\t// we can choose any two out of all of them, hence Nc2 possibilities\\n                    if(nums2[i] == nums2[j]) {\\n                        int len = j-i+1;\\n                        count += len*(len-1)/2;\\n                        i = j+1;\\n                    }\\n\\t\\t\\t\\t\\t// case 2 : if not so\\n\\t\\t\\t\\t\\t// find the number of elements equal to nums2[i] (say n1) and\\n\\t\\t\\t\\t\\t// that equal to nums2[j] ( ssay n2)\\n\\t\\t\\t\\t\\t// add n1*n2 to ans\\n                    else {\\n                        int left_len = 1, right_len = 1;\\n                        while(i<j && nums2[i] == nums2[i+1]) {\\n                            i++;\\n                            left_len++;\\n                        }\\n                        while(j>i && nums2[j-1] == nums2[j]) {\\n                            j--;\\n                            right_len++;\\n                        }\\n                        \\n                        count += left_len * right_len;\\n                        i++; j--;\\n                    }\\n                    \\n                }\\n\\t\\t\\t\\t// accordingly move pointer i or j\\n                else if(prod < target)\\n                    i++;\\n                else\\n                    j--;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        return returnCount(nums1, nums2) + returnCount(nums2, nums1);\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n\\t// returns count of valids triplets (i, j, K) of type 1\\n\\t// note that to find of type 2, just swap nums1 and nums2 while calling \\n    int returnCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        int count = 0;\\n        \\n        for(int k=0; k<n; k++) {\\n            ll target = nums1[k]*1ll*nums1[k];\\n\\t\\t\\t// we\\'ll find two numbers in nums2 such that their product equals target \\n            int i=0, j=m-1;\\n            while(i<j) {\\n                ll prod = nums2[i]*1ll*nums2[j];\\n                if(prod == target) {\\n\\t\\t\\t\\t\\t// case 1 : nums[i] == nums[j]\\n\\t\\t\\t\\t\\t// this means all numbers in between i & j are same and\\n\\t\\t\\t\\t\\t// we can choose any two out of all of them, hence Nc2 possibilities\\n                    if(nums2[i] == nums2[j]) {\\n                        int len = j-i+1;\\n                        count += len*(len-1)/2;\\n                        i = j+1;\\n                    }\\n\\t\\t\\t\\t\\t// case 2 : if not so\\n\\t\\t\\t\\t\\t// find the number of elements equal to nums2[i] (say n1) and\\n\\t\\t\\t\\t\\t// that equal to nums2[j] ( ssay n2)\\n\\t\\t\\t\\t\\t// add n1*n2 to ans\\n                    else {\\n                        int left_len = 1, right_len = 1;\\n                        while(i<j && nums2[i] == nums2[i+1]) {\\n                            i++;\\n                            left_len++;\\n                        }\\n                        while(j>i && nums2[j-1] == nums2[j]) {\\n                            j--;\\n                            right_len++;\\n                        }\\n                        \\n                        count += left_len * right_len;\\n                        i++; j--;\\n                    }\\n                    \\n                }\\n\\t\\t\\t\\t// accordingly move pointer i or j\\n                else if(prod < target)\\n                    i++;\\n                else\\n                    j--;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        return returnCount(nums1, nums2) + returnCount(nums2, nums1);\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831523,
                "title": "python3-solution",
                "content": "```python\\ndef numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\trev, n1, n2 = 0, Counter(nums1), Counter(nums2)\\n\\n\\tfor i in range(len(nums1)-1):\\n\\t\\tfor j in range(i+1, len(nums1)):\\n\\t\\t\\tt = (nums1[i] * nums1[j])**(1/2)\\n\\n\\t\\t\\tif t == int(t) and t in n2:\\n\\t\\t\\t\\trev += n2[t]\\n\\n\\tfor i in range(len(nums2)-1):\\n\\t\\tfor j in range(i+1, len(nums2)):\\n\\t\\t\\tt = (nums2[i] * nums2[j])**(1/2)\\n\\n\\t\\t\\tif t == int(t) and t in n1:\\n\\t\\t\\t\\trev += n1[t]\\n\\n\\treturn rev\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\trev, n1, n2 = 0, Counter(nums1), Counter(nums2)\\n\\n\\tfor i in range(len(nums1)-1):\\n\\t\\tfor j in range(i+1, len(nums1)):\\n\\t\\t\\tt = (nums1[i] * nums1[j])**(1/2)\\n\\n\\t\\t\\tif t == int(t) and t in n2:\\n\\t\\t\\t\\trev += n2[t]\\n\\n\\tfor i in range(len(nums2)-1):\\n\\t\\tfor j in range(i+1, len(nums2)):\\n\\t\\t\\tt = (nums2[i] * nums2[j])**(1/2)\\n\\n\\t\\t\\tif t == int(t) and t in n1:\\n\\t\\t\\t\\trev += n1[t]\\n\\n\\treturn rev\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2387605,
                "title": "c-easy-explanation-o-n-2",
                "content": "//        long long temp,t,help are used to keep the product within limits (prevent overflow)\\n        \\n// The idea is to store all the squares in a map(not set because duplicates may be present an dnot even multiset because we won\\'t get the number of times the duplicates appears)\\n        \\n//         Use nested loop then and check which pairs product is present as square in another map  and add its occurences\\n        \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n            map<long long,int> st1,st2;             \\n            long long temp,t;\\n            for(int i=0;i<nums1.size();i++)\\n            {\\n                    t=nums1[i];\\n                    temp=t*t;\\n                   \\n                    \\n                    \\n                     st1[t*t]++;\\n            }\\n                   \\n            for(int i=0;i<nums2.size();i++)\\n            {\\n                    t=nums2[i];\\n                    temp=t*t;\\n                   \\n                    \\n                     st2[t*t]++;\\n            }\\n            \\n            int cnt=0;\\n            long long help1,help2;\\n           for(int i=0;i<nums1.size();i++)\\n           {\\n                   for(int j=i+1;j<nums1.size();j++)\\n                   {\\n                           help1=nums1[i];\\n                           help2=nums1[j];\\n                           temp=help1*help2;\\n                          \\n                           if(st2.find(temp)!=st2.end())\\n                           {\\n                                   cnt+=st2[temp];\\n                           }\\n                   }\\n           }\\n            \\n             for(int i=0;i<nums2.size();i++)\\n           {\\n                   for(int j=i+1;j<nums2.size();j++)\\n                   {\\n                           help1=nums2[i];\\n                           help2=nums2[j];\\n                           temp=help1*help2;\\n                           \\n                           \\n                           if(st1.find(temp)!=st1.end())\\n                           {\\n                                   cnt+=st1[temp];\\n                           }\\n                   }\\n           }\\n            return cnt;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "//        long long temp,t,help are used to keep the product within limits (prevent overflow)\\n        \\n// The idea is to store all the squares in a map(not set because duplicates may be present an dnot even multiset because we won\\'t get the number of times the duplicates appears)\\n        \\n//         Use nested loop then and check which pairs product is present as square in another map  and add its occurences\\n        \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n            map<long long,int> st1,st2;             \\n            long long temp,t;\\n            for(int i=0;i<nums1.size();i++)\\n            {\\n                    t=nums1[i];\\n                    temp=t*t;\\n                   \\n                    \\n                    \\n                     st1[t*t]++;\\n            }\\n                   \\n            for(int i=0;i<nums2.size();i++)\\n            {\\n                    t=nums2[i];\\n                    temp=t*t;\\n                   \\n                    \\n                     st2[t*t]++;\\n            }\\n            \\n            int cnt=0;\\n            long long help1,help2;\\n           for(int i=0;i<nums1.size();i++)\\n           {\\n                   for(int j=i+1;j<nums1.size();j++)\\n                   {\\n                           help1=nums1[i];\\n                           help2=nums1[j];\\n                           temp=help1*help2;\\n                          \\n                           if(st2.find(temp)!=st2.end())\\n                           {\\n                                   cnt+=st2[temp];\\n                           }\\n                   }\\n           }\\n            \\n             for(int i=0;i<nums2.size();i++)\\n           {\\n                   for(int j=i+1;j<nums2.size();j++)\\n                   {\\n                           help1=nums2[i];\\n                           help2=nums2[j];\\n                           temp=help1*help2;\\n                           \\n                           \\n                           if(st1.find(temp)!=st1.end())\\n                           {\\n                                   cnt+=st1[temp];\\n                           }\\n                   }\\n           }\\n            return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2204732,
                "title": "javascript-two-approaches-hashmap-two-pointers",
                "content": "**Solution 1: Hashmap**\\n\\nThis approach is similar to the two sum problem.\\nWe use a hashmap to keep track of the frequencies of past numbers.\\nCount the number of `target / nums2[j]` in the hashmap.\\n\\n`n = length of nums1`, `m = length of nums2`\\nTime Complexity: `O(nm)` 498ms\\nSpace Complexity: `O(n + m)` 48.3MB\\n```\\nvar numTriplets = function(nums1, nums2) {\\n  return getTriplets(nums1, nums2) + getTriplets(nums2, nums1);\\n  \\n  function getTriplets(nums1, nums2) {\\n    let ans = 0;\\n    for (let i = 0; i < nums1.length; i++) {\\n      let target = nums1[i] * nums1[i], map = new Map();\\n      for (let j = 0; j < nums2.length; j++) {\\n        ans += map.get(target / nums2[j]) || 0;\\n        map.set(nums2[j], (map.get(nums2[j]) || 0) + 1);\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```\\n\\n\\n**Solution 2: Three Pointers**\\n\\n1. Sort both arrays. This is so that we can use two pointers to calculate the pairs.\\n2. For each `nums1[i] `\\n  Use two pointers (`start = 0`, `end = n - 1`) in `nums2`\\n  Count the number of pairs where `nums2[j] * nums2[k] === nums1[i] * nums1[i]`\\n  There are two special cases to consider:\\n\\n    Case 1. `nums2[j] !== nums2[k]`.\\n      An array like `[1,1,3,3]`. \\n      Count the number of repeated `nums2[j]` and repeated `nums2[k]`.\\n      Multiply the two counts together to get the number of combinations.\\n\\n    Case 2. `[nums2[j], ..., nums2[k]]` are all equal\\n      e.g: `[1,1,1,1,1]`\\n      For each `nums2[j]`, we can pair it with any number on the right.\\n      For the above example this would be: `4 + 3 + 2 + 1`\\n      Use the formula `(n-1)*n/2 `to calculate the sum of `1 + 2 + 3 + ... + n-1`\\n\\nTime Complexity: `O(nm + n log(n) + m log(m))` 153ms\\nSpace Complexity: `O(log(n) + log(m))` (space for sorting) 43.1MB\\n```\\nvar numTriplets = function(nums1, nums2) {\\n  nums1.sort((a, b) => a - b);\\n  nums2.sort((a, b) => a - b);\\n  return calc(nums1, nums2) + calc(nums2, nums1);\\n  \\n  function calc(nums1, nums2) {\\n    let ans = 0;\\n    for (let i = 0; i < nums1.length; i++) {\\n      let target = nums1[i] * nums1[i];\\n      let j = 0, k = nums2.length - 1;\\n      while (j < k) {\\n        if (nums2[j] * nums2[k] === target) {\\n          if (nums2[j] === nums2[k]) { // case 2: [nums2[j], ..., nums2[k]] are all equal\\n            ans += (k - j) * (k - j + 1) / 2;\\n            j = k;\\n          } else { // case 1: nums2[j] !== nums2[k]\\n            let left = j, right = k;\\n            while (j < k && nums2[j] === nums2[left]) j++;\\n            while (k >= 0 && nums2[k] === nums2[right]) k--;\\n            ans += (j - left) * (right - k);\\n          }\\n        }\\n        else if (nums2[j] * nums2[k] < target) j++;\\n        else k--;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numTriplets = function(nums1, nums2) {\\n  return getTriplets(nums1, nums2) + getTriplets(nums2, nums1);\\n  \\n  function getTriplets(nums1, nums2) {\\n    let ans = 0;\\n    for (let i = 0; i < nums1.length; i++) {\\n      let target = nums1[i] * nums1[i], map = new Map();\\n      for (let j = 0; j < nums2.length; j++) {\\n        ans += map.get(target / nums2[j]) || 0;\\n        map.set(nums2[j], (map.get(nums2[j]) || 0) + 1);\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```\n```\\nvar numTriplets = function(nums1, nums2) {\\n  nums1.sort((a, b) => a - b);\\n  nums2.sort((a, b) => a - b);\\n  return calc(nums1, nums2) + calc(nums2, nums1);\\n  \\n  function calc(nums1, nums2) {\\n    let ans = 0;\\n    for (let i = 0; i < nums1.length; i++) {\\n      let target = nums1[i] * nums1[i];\\n      let j = 0, k = nums2.length - 1;\\n      while (j < k) {\\n        if (nums2[j] * nums2[k] === target) {\\n          if (nums2[j] === nums2[k]) { // case 2: [nums2[j], ..., nums2[k]] are all equal\\n            ans += (k - j) * (k - j + 1) / 2;\\n            j = k;\\n          } else { // case 1: nums2[j] !== nums2[k]\\n            let left = j, right = k;\\n            while (j < k && nums2[j] === nums2[left]) j++;\\n            while (k >= 0 && nums2[k] === nums2[right]) k--;\\n            ans += (j - left) * (right - k);\\n          }\\n        }\\n        else if (nums2[j] * nums2[k] < target) j++;\\n        else k--;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661853,
                "title": "python-soln",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        hash1=defaultdict(int)\\n        hash2=defaultdict(int)\\n        \\n        for x in nums1:\\n            hash1[x*x]+=1\\n        \\n        for x in nums2:\\n            hash2[x*x]+=1\\n        \\n        res=0\\n        for i in range(len(nums1)-1):\\n            for j in range(i+1,len(nums1)):\\n                \\n                res+=hash2[nums1[i]*nums1[j]]\\n        \\n        for i in range(len(nums2)-1):\\n            for j in range(i+1,len(nums2)):\\n                \\n                res+=hash1[nums2[i]*nums2[j]]\\n        return res\\n        \\n                \\n                \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        hash1=defaultdict(int)\\n        hash2=defaultdict(int)\\n        \\n        for x in nums1:\\n            hash1[x*x]+=1\\n        \\n        for x in nums2:\\n            hash2[x*x]+=1\\n        \\n        res=0\\n        for i in range(len(nums1)-1):\\n            for j in range(i+1,len(nums1)):\\n                \\n                res+=hash2[nums1[i]*nums1[j]]\\n        \\n        for i in range(len(nums2)-1):\\n            for j in range(i+1,len(nums2)):\\n                \\n                res+=hash1[nums2[i]*nums2[j]]\\n        return res\\n        \\n                \\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660254,
                "title": "c-brute-force-using-hash-map",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    \\n    int find(vector<int>nums1,vector<int>nums2)\\n    {\\n        unordered_map<ll,ll>mp;\\n        // O(n^2)\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            for(int j=i+1;j<nums2.size();j++)\\n            {\\n                ll p=(long long)nums2[i]*nums2[j];\\n                mp[p]++;\\n            }\\n        }\\n        \\n        ll count=0;\\n        // square of a number\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            ll p=(long long)nums1[i]*nums1[i]; // square of num1\\n            if(mp.find(p)!=mp.end())\\n            {\\n                count+=mp[p];\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        return find(nums1,nums2)+find(nums2,nums1);\\n    }\\n};\\n```\\n**please hit upvote if you like it : )**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    \\n    int find(vector<int>nums1,vector<int>nums2)\\n    {\\n        unordered_map<ll,ll>mp;\\n        // O(n^2)\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            for(int j=i+1;j<nums2.size();j++)\\n            {\\n                ll p=(long long)nums2[i]*nums2[j];\\n                mp[p]++;\\n            }\\n        }\\n        \\n        ll count=0;\\n        // square of a number\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            ll p=(long long)nums1[i]*nums1[i]; // square of num1\\n            if(mp.find(p)!=mp.end())\\n            {\\n                count+=mp[p];\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        return find(nums1,nums2)+find(nums2,nums1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480249,
                "title": "c-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    int numTriplets(vector<int>& a, vector<int>& b) {\\n        map<ll,ll>mp1;\\n        map<ll,ll>mp2;\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        for(int i = 0 ; i < a.size();i++)\\n        {\\n            ll p = (ll)a[i]*a[i];\\n            mp1[p]++;\\n        }\\n         for(int i = 0 ; i < b.size();i++)\\n        {\\n            ll p = (ll)b[i]*b[i];\\n            mp2[p]++;\\n        }\\n    ll ans = 0  ;\\n        for(int i = 0 ; i  < b.size();i++)\\n        {\\n            for(int j=i+1;j<b.size();j++){\\n            ll p = (ll)b[i]*b[j];\\n                ans+=mp1[p];\\n                }\\n        }\\n        for(int i = 0 ; i  < a.size();i++)\\n        {\\n            for(int j=i+1;j<a.size();j++){\\n            ll p = (ll)a[i]*a[j];\\n                ans+=mp2[p];\\n                }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    #define ll long long int\\n    int numTriplets(vector<int>& a, vector<int>& b) {\\n        map<ll,ll>mp1;\\n        map<ll,ll>mp2;\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        for(int i = 0 ; i < a.size();i++)\\n        {\\n            ll p = (ll)a[i]*a[i];\\n            mp1[p]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1199846,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n       return res(nums1,nums2)+res(nums2,nums1);\\n    }\\n    public static int res(int[] nums1,int[] nums2)\\n    {\\n        int count=0;\\n\\t\\tHashMap<Long,Integer> map=new HashMap<Long,Integer>();\\n\\t\\tfor(long i:nums1)\\n\\t\\t\\tmap.put((i*i), map.getOrDefault(i*i,0)+1);\\n\\t\\tfor(int i=0;i<nums2.length-1;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i+1;j<nums2.length;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong prod=(long)nums2[i]*nums2[j];\\n\\t\\t\\t\\tif(map.containsKey(prod))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount=count+map.get(prod);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n       return res(nums1,nums2)+res(nums2,nums1);\\n    }\\n    public static int res(int[] nums1,int[] nums2)\\n    {\\n        int count=0;\\n\\t\\tHashMap<Long,Integer> map=new HashMap<Long,Integer>();\\n\\t\\tfor(long i:nums1)\\n\\t\\t\\tmap.put((i*i), map.getOrDefault(i*i,0)+1);\\n\\t\\tfor(int i=0;i<nums2.length-1;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i+1;j<nums2.length;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong prod=(long)nums2[i]*nums2[j];\\n\\t\\t\\t\\tif(map.containsKey(prod))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount=count+map.get(prod);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068741,
                "title": "python-o-n-2-function",
                "content": "* How do we approach such a question?\\n* You can try the brute force, but it will TLE\\n* I always try to fall back to the **Two Sum problem**\\n\\t* Can we build dictionaries in linear or n^2 time to avoid n^3 time?\\n\\t\\t* We can count the number of `nums1[i]^2` for example\\n\\t\\t* We can also count the number of `nums2[j] * nums2[k]` too\\n\\t\\t* Then, we can loop in linear time over the `nums1[i]^2` values, and access the count of `j * k` in O(1)\\n\\t\\t* \\n* **Ultimately, don\\'t be afraid of having multiple `O(n)` loops**, or doing anytype of `k * O(n)` or `k * O(n^2)`.\\n\\t* The biggest concern is **reducing the upper bound** as much as possible, e.g, achieving `O(n^2)` instead of `O(n^3)`\\n\\n* So, next time, think of two sum, and see if you can have multiple loops (e.g `k * O(x)`) but reduce the upper bound, (`x` in this case) as much as possible!\\n\\n```python\\nclass Solution:\\n    \\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        \"\"\"\\n        O(n^2)\\n        \"\"\"\\n        \\n        def check(nums1, nums2):\\n            \\n            # Initialize a dict: value->(value^2, count)\\n            a = {}\\n            for i in nums1:\\n                if i not in a:\\n                    a[i] = [i**2, 1]\\n                else:\\n                    a[i][-1] += 1\\n                               \\n            # Initialize a dict: nums2[i] * nums[j] -> count\\n            b = collections.defaultdict(int)\\n            for i in range(len(nums2)):\\n                for j in range(i+1, len(nums2)):\\n                    b[nums2[i]*nums2[j]] += 1\\n                    \\n            # Calculate the result\\n            # result += i^2 count * j*k count for each combination\\n            result = 0            \\n            for (i, amount) in a.values():                \\n                result += b[i]*amount\\n            \\n            return result\\n        \\n                                \\n        # Call above function twice\\n        return check(nums1, nums2) + check(nums2, nums1)\\n```\\n\\n---\\n\\nIf you want to get a bit fancy, you can always spend time trying to optimize or clean up your code two \\uD83D\\uDE06\\n\\n```python\\ndef calculate(a, b):\\n    square_counts = collections.Counter(i**2 for i in a)\\n    return sum(square_counts[b[j] * b[k]] for j in range(len(b)) for k in range(j+1, len(b)))\\n\\nreturn calculate(nums1, nums2) + calculate(nums2, nums1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    \\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        \"\"\"\\n        O(n^2)\\n        \"\"\"\\n        \\n        def check(nums1, nums2):\\n            \\n            # Initialize a dict: value->(value^2, count)\\n            a = {}\\n            for i in nums1:\\n                if i not in a:\\n                    a[i] = [i**2, 1]\\n                else:\\n                    a[i][-1] += 1\\n                               \\n            # Initialize a dict: nums2[i] * nums[j] -> count\\n            b = collections.defaultdict(int)\\n            for i in range(len(nums2)):\\n                for j in range(i+1, len(nums2)):\\n                    b[nums2[i]*nums2[j]] += 1\\n                    \\n            # Calculate the result\\n            # result += i^2 count * j*k count for each combination\\n            result = 0            \\n            for (i, amount) in a.values():                \\n                result += b[i]*amount\\n            \\n            return result\\n        \\n                                \\n        # Call above function twice\\n        return check(nums1, nums2) + check(nums2, nums1)\\n```\n```python\\ndef calculate(a, b):\\n    square_counts = collections.Counter(i**2 for i in a)\\n    return sum(square_counts[b[j] * b[k]] for j in range(len(b)) for k in range(j+1, len(b)))\\n\\nreturn calculate(nums1, nums2) + calculate(nums2, nums1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1039384,
                "title": "python-count-beats-100-o-n-m",
                "content": "First count the elements in each array, then find the number of triplets for each element.\\nIt is faster if there are lots of duplicates.\\n```\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cnt1 = collections.defaultdict(int)\\n        cnt2 = collections.defaultdict(int)\\n        for n in nums1:\\n            cnt1[n] += 1\\n        for n in nums2:\\n            cnt2[n] += 1\\n\\n        def triplets(arr1, arr2):\\n            ans = 0\\n            for t, v in arr1.items():\\n                k = arr2.get(t, 0)\\n                tmp = k * (k - 1) // 2\\n                sq = t * t\\n                for m in arr2:\\n                    if m < t and sq % m == 0:\\n                        tmp += arr2.get(m, 0) * arr2.get(sq // m, 0)\\n                ans += tmp * v\\n            return ans\\n        return triplets(cnt1, cnt2) + triplets(cnt2, cnt1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cnt1 = collections.defaultdict(int)\\n        cnt2 = collections.defaultdict(int)\\n        for n in nums1:\\n            cnt1[n] += 1\\n        for n in nums2:\\n            cnt2[n] += 1\\n\\n        def triplets(arr1, arr2):\\n            ans = 0\\n            for t, v in arr1.items():\\n                k = arr2.get(t, 0)\\n                tmp = k * (k - 1) // 2\\n                sq = t * t\\n                for m in arr2:\\n                    if m < t and sq % m == 0:\\n                        tmp += arr2.get(m, 0) * arr2.get(sq // m, 0)\\n                ans += tmp * v\\n            return ans\\n        return triplets(cnt1, cnt2) + triplets(cnt2, cnt1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835642,
                "title": "python-solution-based-on-binary-search-and-memorization",
                "content": "Time Complexity = O ( N * N * Log N )\\n\\n\\n```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:      \\n        nums1.sort()\\n        nums2.sort()\\n        \\n        def lowerbound(target, left, right, nums):\\n            while left < right:\\n                mid = left + (right - left) // 2\\n\\n                if nums[mid] == target:\\n                    right = mid\\n                elif nums[mid] < target:\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n            \\n            return left\\n        \\n        def higherbound(target, left, right, nums):\\n            while left < right:\\n                mid = left + (right - left) // 2\\n                \\n                if nums[mid] == target:\\n                    left = mid + 1\\n                elif nums[mid] < target:\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n            \\n            return left\\n            \\n    \\n        def helper(n, nums, memo):\\n            if n in memo:\\n                return memo[n]\\n            \\n            result = 0\\n            \\n            for i in range(len(nums)):\\n                if n % nums[i] != 0:\\n                    continue\\n                    \\n                target = n // nums[i]\\n                \\n                # find total number of target in nums[i+1:]\\n                lower = lowerbound(target, i+1, len(nums), nums)\\n                higher = higherbound(target, i+1, len(nums), nums)\\n                \\n                result += (higher - lower)\\n            \\n            memo[n] = result\\n            return result\\n        \\n        result = 0\\n        \\n        memo1 = {}\\n        for n in nums1:\\n            result += helper(n*n, nums2, memo1)\\n        \\n        memo2 = {}\\n        for n in nums2:\\n            result += helper(n*n, nums1, memo2)\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:      \\n        nums1.sort()\\n        nums2.sort()\\n        \\n        def lowerbound(target, left, right, nums):\\n            while left < right:\\n                mid = left + (right - left) // 2\\n\\n                if nums[mid] == target:\\n                    right = mid\\n                elif nums[mid] < target:\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n            \\n            return left\\n        \\n        def higherbound(target, left, right, nums):\\n            while left < right:\\n                mid = left + (right - left) // 2\\n                \\n                if nums[mid] == target:\\n                    left = mid + 1\\n                elif nums[mid] < target:\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n            \\n            return left\\n            \\n    \\n        def helper(n, nums, memo):\\n            if n in memo:\\n                return memo[n]\\n            \\n            result = 0\\n            \\n            for i in range(len(nums)):\\n                if n % nums[i] != 0:\\n                    continue\\n                    \\n                target = n // nums[i]\\n                \\n                # find total number of target in nums[i+1:]\\n                lower = lowerbound(target, i+1, len(nums), nums)\\n                higher = higherbound(target, i+1, len(nums), nums)\\n                \\n                result += (higher - lower)\\n            \\n            memo[n] = result\\n            return result\\n        \\n        result = 0\\n        \\n        memo1 = {}\\n        for n in nums1:\\n            result += helper(n*n, nums2, memo1)\\n        \\n        memo2 = {}\\n        for n in nums2:\\n            result += helper(n*n, nums1, memo2)\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835527,
                "title": "python3-3-liner-number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        sq1 = Counter(map(mul, nums1, nums1))\\n        sq2 = Counter(map(mul, nums2, nums2))\\n        return sum(sq2[a * b] for a, b in combinations(nums1, 2)) +  sum(sq1[a * b] for a, b in combinations(nums2, 2))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        sq1 = Counter(map(mul, nums1, nums1))\\n        sq2 = Counter(map(mul, nums2, nums2))\\n        return sum(sq2[a * b] for a, b in combinations(nums1, 2)) +  sum(sq1[a * b] for a, b in combinations(nums2, 2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834480,
                "title": "java-factorization-solution-o-n-m",
                "content": "Algorithm:\\n1. Create a map  key: (num * num), value: count basing on first array\\n2. Go throug the second array, for every number calculate a key containing factors that are represented odd number of times in number. For example, 60 is 2 * 2 * 3 * 5, the key is \"3,5\"\\n3. Search for the values with the same key processed on previous iterations - they will form squares\\n4. Check if the map based on the first array contains corresponding square. Update count if match is found\\n5. Store store num under the same key\\n\\n<pre>\\nclass Solution {\\n    // Cached factors\\n    private final Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; factorsCache = new HashMap&lt;&gt;();\\n\\n    /*\\n     * Calculates factors for num. Returns a map where\\n     * key is prime factor, value is number of times the factor is used.\\n     *\\n     *  For example, 60 will be represented as\\n     * 2 -&gt; 2\\n     * 3 -&gt; 1\\n     * 5 -&gt; 1\\n     */\\n    private Map&lt;Integer, Integer&gt; factors(int num) {\\n        Map&lt;Integer, Integer&gt; cached = factorsCache.get(num);\\n        if (cached != null) {\\n            // return cached value (if any)\\n            return cached;\\n        }\\n\\n        // handle case num == 1 separately\\n        if (num == 1) {\\n            Map&lt;Integer, Integer&gt; ret = new HashMap&lt;&gt;();\\n            ret.put(1, 1);\\n            factorsCache.put(1, ret);\\n            return ret;\\n        }\\n\\n        // calculate factors recursively\\n        for (int i = 2; i * i &lt;= num; i++) {\\n            if (num % i == 0) {\\n                Map&lt;Integer, Integer&gt; f1 = factors(i);\\n                Map&lt;Integer, Integer&gt; f2 = factors(num / i);\\n\\n                Map&lt;Integer, Integer&gt; ret = new HashMap&lt;&gt;();\\n                for (Map.Entry&lt;Integer, Integer&gt; entry : f1.entrySet()) {\\n                    Integer key = entry.getKey();\\n                    Integer value = entry.getValue();\\n                    ret.put(key, ret.getOrDefault(key, 0) + value);\\n                }\\n                for (Map.Entry&lt;Integer, Integer&gt; entry : f2.entrySet()) {\\n                    Integer key = entry.getKey();\\n                    Integer value = entry.getValue();\\n                    ret.put(key, ret.getOrDefault(key, 0) + value);\\n                }\\n\\n                factorsCache.put(num, ret);\\n                return ret;\\n            }\\n        }\\n\\n        // cache the results\\n        Map&lt;Integer, Integer&gt; ret = new HashMap&lt;&gt;();\\n        ret.put(num, 1);\\n        factorsCache.put(num, ret);\\n        return ret;\\n    }\\n\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Map&lt;Long, Integer&gt; squaresMap1 = new HashMap&lt;&gt;();\\n        Map&lt;Long, Integer&gt; squaresMap2 = new HashMap&lt;&gt;();\\n        for (int n : nums1) {\\n            long sq = ((long) n) * n;\\n            squaresMap1.put(sq, squaresMap1.getOrDefault(sq, 0) + 1);\\n        }\\n        for (int n : nums2) {\\n            long sq = ((long) n) * n;\\n            squaresMap2.put(sq, squaresMap2.getOrDefault(sq, 0) + 1);\\n        }\\n\\n        int ret = 0;\\n\\n        // check nums1 against squares in nums2\\n        ret += count(nums1, squaresMap2);\\n\\n        // check nums2 against squares in nums1\\n        ret += count(nums2, squaresMap1);\\n\\n        return ret;\\n    }\\n\\n    // cached keys\\n    private final Map&lt;Integer, String&gt; keyCache = new HashMap&lt;&gt;();\\n\\n    /*\\n     * Key consists of factors (greater than 1) that are represented odd number of times in num\\n     * For example, 60 is 2 * 2 * 3 * 5, the key is \"3,5\"\\n     * 1 -&gt; \"\"\\n     * 2 -&gt; \"2\"\\n     * 3 -&gt; \"3\"\\n     * 4 -&gt; \"\"\\n     * 5 -&gt; \"5\"\\n     * 6 -&gt; \"2,3\"\\n     * ...\\n     */\\n    private String calculateKey(int num) {\\n        String cachedKey = keyCache.get(num);\\n        if (cachedKey != null) {\\n            return cachedKey;\\n        }\\n\\n        String key = \"\";\\n        if (num &gt; 1) {\\n            Map&lt;Integer, Integer&gt; f = factors(num);\\n            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\\n            for (Map.Entry&lt;Integer, Integer&gt; entry : f.entrySet()) {\\n                if (entry.getValue() % 2 != 0) {\\n                    list.add(entry.getKey());\\n                }\\n            }\\n            Collections.sort(list);\\n            StringBuilder sb = new StringBuilder();\\n            for (int j = 0; j &lt; list.size(); j++) {\\n                if (j &gt; 0) {\\n                    sb.append(\",\");\\n                }\\n                sb.append(list.get(j));\\n            }\\n            key = sb.toString();\\n        }\\n\\n        keyCache.put(num, key);\\n\\n        return key;\\n    }\\n\\n\\n    private int count(int[] nums, Map&lt;Long, Integer&gt; complementary) {\\n        int ret = 0;\\n\\n        // Examples:\\n        // key \"3,5\" -&gt;\\n        //               15 -&gt; 2 (number of times this value was seen previously)\\n        //               60 -&gt; 1 (number of times this value was seen previously)\\n        // key \"3,7\" -&gt;\\n        //               21 -&gt; 1 (number of times this value was seen previously)\\n        //               2100 -&gt; 4 (number of times this value was seen previously)\\n        Map&lt;String, Map&lt;Integer, Integer&gt;&gt; previousNumbers = new HashMap&lt;&gt;();\\n\\n        for (int num : nums) {\\n            String key = calculateKey(num);\\n\\n            // we need to find previously previously seen values with the same key\\n            // if current value is 60, the key is \"3,5\", every value that has the same key will represent a square,\\n            // 15, 60, 135 etc.\\n            Map&lt;Integer, Integer&gt; counts = previousNumbers.computeIfAbsent(key, k -&gt; new HashMap&lt;&gt;());\\n            for (Map.Entry&lt;Integer, Integer&gt; entry : counts.entrySet()) {\\n                Integer previous = entry.getKey();\\n                long product = previous.longValue() * num;\\n\\n                // finding a match in the other array\\n                Integer complementaryCount = complementary.get(product);\\n                if (complementaryCount != null) {\\n                    ret += entry.getValue() * complementaryCount;\\n                }\\n            }\\n\\n            // recording current number in the map\\n            counts.put(num, counts.getOrDefault(num, 0) + 1);\\n        }\\n\\n        return ret;\\n    }\\n}\\n</pre>",
                "solutionTags": [],
                "code": "class Solution {\\n    // Cached factors\\n    private final Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; factorsCache = new HashMap&lt;&gt;();\\n\\n    /*\\n     * Calculates factors for num. Returns a map where\\n     * key is prime factor, value is number of times the factor is used.\\n     *\\n     *  For example, 60 will be represented as\\n     * 2 -&gt; 2\\n     * 3 -&gt; 1\\n     * 5 -&gt; 1\\n     */\\n    private Map&lt;Integer, Integer&gt; factors(int num) {\\n        Map&lt;Integer, Integer&gt; cached = factorsCache.get(num);\\n        if (cached != null) {\\n            // return cached value (if any)\\n            return cached;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 833777,
                "title": "c-o-mn-easiest-solution-with-self-explanatory-code",
                "content": "Please Note that time complexity of find function in unordered_map is O(1)\\n```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& n1, vector<int>& n2) {\\n        int n=n1.size();int m=n2.size();\\n        long ans=0;\\n        //type 1\\n        for(int i=0;i<n;i++)\\n        {\\n            double a=n1[i];\\n            unordered_map<double,int> s;\\n            for(int j=0;j<m;j++)\\n            {\\n                double b=n2[j];\\n                double f=a*a/b;\\n                if(s.find(f)!=s.end()) ans+=s[f];\\n                s[b]++;\\n            }\\n        }\\n        //type 2\\n        for(int i=0;i<m;i++)\\n        {\\n            double a=n2[i];\\n            unordered_map<double,int> s;\\n            for(int j=0;j<n;j++)\\n            {\\n                double b=n1[j];\\n                double f=a*a/b;\\n                if(s.find(f)!=s.end()) ans+=s[f];\\n                s[b]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& n1, vector<int>& n2) {\\n        int n=n1.size();int m=n2.size();\\n        long ans=0;\\n        //type 1\\n        for(int i=0;i<n;i++)\\n        {\\n            double a=n1[i];\\n            unordered_map<double,int> s;\\n            for(int j=0;j<m;j++)\\n            {\\n                double b=n2[j];\\n                double f=a*a/b;\\n                if(s.find(f)!=s.end()) ans+=s[f];\\n                s[b]++;\\n            }\\n        }\\n        //type 2\\n        for(int i=0;i<m;i++)\\n        {\\n            double a=n2[i];\\n            unordered_map<double,int> s;\\n            for(int j=0;j<n;j++)\\n            {\\n                double b=n1[j];\\n                double f=a*a/b;\\n                if(s.find(f)!=s.end()) ans+=s[f];\\n                s[b]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832206,
                "title": "c-solution-using-dictionary",
                "content": "```\\npublic int NumTriplets(int[] nums1, int[] nums2) {\\n        int w1 = GetWays(nums1, nums2);\\n        int w2 = GetWays(nums2, nums1);\\n        return w1 + w2;\\n    }\\n    \\n    public int GetWays(int[] nums1, int[] nums2) {\\n        int numWays = 0;\\n        long product = 0;\\n        \\n        Dictionary<long, int> d = new Dictionary<long, int>();\\n        for(int i = 0; i < nums1.Length; i++) {\\n            product = (long)nums1[i] * (long)nums1[i];\\n            if(d.ContainsKey(product))\\n                d[product]++;\\n            else {\\n                d.Add(product,1);\\n            }\\n        }\\n    \\n        for(int j = 0; j < nums2.Length-1; j++) {\\n            for(int k = j+1; k < nums2.Length; k++) {\\n                product = (long)nums2[j]*(long)nums2[k];\\n                if(d.ContainsKey(product)) {\\n                    numWays += d[product];\\n                } \\n            }\\n\\n        }\\n            \\n        return numWays;\\n    }\\n    \\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int NumTriplets(int[] nums1, int[] nums2) {\\n        int w1 = GetWays(nums1, nums2);\\n        int w2 = GetWays(nums2, nums1);\\n        return w1 + w2;\\n    }\\n    \\n    public int GetWays(int[] nums1, int[] nums2) {\\n        int numWays = 0;\\n        long product = 0;\\n        \\n        Dictionary<long, int> d = new Dictionary<long, int>();\\n        for(int i = 0; i < nums1.Length; i++) {\\n            product = (long)nums1[i] * (long)nums1[i];\\n            if(d.ContainsKey(product))\\n                d[product]++;\\n            else {\\n                d.Add(product,1);\\n            }\\n        }\\n    \\n        for(int j = 0; j < nums2.Length-1; j++) {\\n            for(int k = j+1; k < nums2.Length; k++) {\\n                product = (long)nums2[j]*(long)nums2[k];\\n                if(d.ContainsKey(product)) {\\n                    numWays += d[product];\\n                } \\n            }\\n\\n        }\\n            \\n        return numWays;\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 832007,
                "title": "java-bruteforce-o-n-2",
                "content": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        return getCount(nums1, getMap(nums2)) + getCount(nums2, getMap(nums1));\\n    }\\n    \\n    Map<Long, Integer> getMap(int[] nums){\\n        Map<Long, Integer> map = new HashMap<>();\\n        for(long num: nums)\\n            map.put(num * num, map.getOrDefault(num * num,0)+1);\\n        return map;\\n    }\\n    \\n    int getCount(int[] nums, Map<Long, Integer> map){\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                long prod = (long)nums[i]*(long)nums[j];\\n                if(map.containsKey(prod))\\n                    count += map.get(prod);\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        return getCount(nums1, getMap(nums2)) + getCount(nums2, getMap(nums1));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 831669,
                "title": "why-91-92-tcs-passed-please-suggest-help",
                "content": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        int ans = 0;\\n        int n1 = nums1.length, n2 = nums2.length;\\n        Map<Long, Integer> S1 = new HashMap<>();\\n        Map<Long, Integer> S2 = new HashMap<>();\\n        \\n        for (int i = 0; i < n1; i++) {\\n            long s1 = (nums1[i] * nums1[i]);\\n            S1.put(s1, S1.getOrDefault(s1, 0) + 1);\\n        }\\n        // System.out.println(\"S1 = \" + S1);\\n        \\n        for (int i = 0; i < n2; i++) {\\n            long s2 = ((long)nums2[i] * (long)nums2[i]);\\n            S2.put(s2, S2.getOrDefault(s2, 0) + 1);\\n        }\\n        // System.out.println(\"S2 = \" + S2);\\n        \\n        for (int j = 0; j < n2; j++) {\\n            for (int k = j + 1; k < n2; k++) {\\n                long mul = ((long)nums2[j] * (long)nums2[k]);\\n                // System.out.println(nums2[j] + \" \" + nums2[k] + \" = \" + mul);\\n                if (S1.containsKey(mul)) {\\n                    ans += S1.get(mul);\\n                }\\n            }\\n        }\\n        \\n        for (int j = 0; j < n1; j++) {\\n            for (int k = j + 1; k < n1; k++) {\\n                long mul = ((long)nums1[j] * (long)nums1[k]);\\n                // System.out.println(nums1[j] + \" * \" + nums1[k] + \" = \" + mul);\\n                if (S2.containsKey(mul)) {\\n                    ans += S2.get(mul);\\n                }\\n            }\\n        }\\n         \\n        return ans;\\n    }\\n}\\n```\\n\\n1 blunder as not converted square elements into long. As mentioned below also corrected answer.\\n\\n**long s1 = ((long)nums1[i] * (long)nums1[i]);**",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        int ans = 0;\\n        int n1 = nums1.length, n2 = nums2.length;\\n        Map<Long, Integer> S1 = new HashMap<>();\\n        Map<Long, Integer> S2 = new HashMap<>();\\n        \\n        for (int i = 0; i < n1; i++) {\\n            long s1 = (nums1[i] * nums1[i]);\\n            S1.put(s1, S1.getOrDefault(s1, 0) + 1);\\n        }\\n        // System.out.println(\"S1 = \" + S1);\\n        \\n        for (int i = 0; i < n2; i++) {\\n            long s2 = ((long)nums2[i] * (long)nums2[i]);\\n            S2.put(s2, S2.getOrDefault(s2, 0) + 1);\\n        }\\n        // System.out.println(\"S2 = \" + S2);\\n        \\n        for (int j = 0; j < n2; j++) {\\n            for (int k = j + 1; k < n2; k++) {\\n                long mul = ((long)nums2[j] * (long)nums2[k]);\\n                // System.out.println(nums2[j] + \" \" + nums2[k] + \" = \" + mul);\\n                if (S1.containsKey(mul)) {\\n                    ans += S1.get(mul);\\n                }\\n            }\\n        }\\n        \\n        for (int j = 0; j < n1; j++) {\\n            for (int k = j + 1; k < n1; k++) {\\n                long mul = ((long)nums1[j] * (long)nums1[k]);\\n                // System.out.println(nums1[j] + \" * \" + nums1[k] + \" = \" + mul);\\n                if (S2.containsKey(mul)) {\\n                    ans += S2.get(mul);\\n                }\\n            }\\n        }\\n         \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831584,
                "title": "python-using-counter-o-n-m",
                "content": "```\\n    def numTriplets(self, A: List[int], B: List[int]) -> int:\\n        def getTriplets(A, B):\\n            m, n = len(A), len(B)\\n            ans = 0\\n            counter = Counter()\\n            for j in range(n):\\n                for k in range(j+1,n):\\n                    prod = B[j]*B[k]\\n                    counter[prod] += 1\\n            for i in range(m):\\n                prod = A[i]**2\\n                ans += counter[prod]\\n            return ans \\n        return getTriplets(A,B) + getTriplets(B,A)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def numTriplets(self, A: List[int], B: List[int]) -> int:\\n        def getTriplets(A, B):\\n            m, n = len(A), len(B)\\n            ans = 0\\n            counter = Counter()\\n            for j in range(n):\\n                for k in range(j+1,n):\\n                    prod = B[j]*B[k]\\n                    counter[prod] += 1\\n            for i in range(m):\\n                prod = A[i]**2\\n                ans += counter[prod]\\n            return ans \\n        return getTriplets(A,B) + getTriplets(B,A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 831575,
                "title": "java-use-hashmap-to-maintain-frequencies-o-n-2-m-2",
                "content": "```\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        HashMap<Long, Integer> s1 = new HashMap();\\n        HashMap<Long, Integer> s2 = new HashMap();\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        for(int i=0; i<n1; i++){\\n            for(int j=i+1; j<n1; j++){\\n                long cur = (long)nums1[i]*nums1[j];\\n                s1.put(cur, s1.getOrDefault(cur, 0)+1);\\n            }\\n        }\\n        for(int i=0; i<n2; i++){\\n            for(int j=i+1; j<n2; j++){\\n                long cur = (long)nums2[i]*nums2[j];\\n                s2.put(cur, s2.getOrDefault(cur, 0)+1);\\n            }\\n        }\\n        int res = 0;\\n        for(int num : nums1){\\n            res+=s2.getOrDefault((long)num*num, 0);\\n        }\\n        for(int num : nums2){\\n            res+=s1.getOrDefault((long)num*num, 0);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        HashMap<Long, Integer> s1 = new HashMap();\\n        HashMap<Long, Integer> s2 = new HashMap();\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        for(int i=0; i<n1; i++){\\n            for(int j=i+1; j<n1; j++){\\n                long cur = (long)nums1[i]*nums1[j];\\n                s1.put(cur, s1.getOrDefault(cur, 0)+1);\\n            }\\n        }\\n        for(int i=0; i<n2; i++){\\n            for(int j=i+1; j<n2; j++){\\n                long cur = (long)nums2[i]*nums2[j];\\n                s2.put(cur, s2.getOrDefault(cur, 0)+1);\\n            }\\n        }\\n        int res = 0;\\n        for(int num : nums1){\\n            res+=s2.getOrDefault((long)num*num, 0);\\n        }\\n        for(int num : nums2){\\n            res+=s1.getOrDefault((long)num*num, 0);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 831563,
                "title": "c-30s-faster-than-100",
                "content": "Sort first, and then check whether the 3 numbers can exist accoriding to the condition. For this purpose, we can use a HashMap to expedite the search. Thus, in the beginning, we insert the elements into the HashMap (in C++ ```unordered_map```) and then check for the obvious relationship of ```nums1[i]^2 = nums2[j] * nums2[k]``` . We can increment the count by using the HashMap counts to make it even faster for the cases such as ```nums1 = [1,1,1,1]``` and ```nums2 = [1,1]```.\\n```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        long count = 0;\\n        unordered_map<int,int> mp1;\\n        unordered_map<int,int> mp2;\\n        long num;\\n        for (int i = 0;i<nums1.size();i++){\\n            mp1[nums1[i]]++;\\n        }\\n        for (int i = 0;i<nums2.size();i++){\\n            mp2[nums2[i]]++;\\n        }\\n        for (int i = 0;i<nums1.size();i++){\\n            if (i>0 && nums1[i]==nums1[i-1]){\\n                continue;\\n            }\\n            if (nums1[i]>nums2.back()){\\n                break;\\n            }\\n            if (nums1[i]<nums2[0]){\\n                continue;\\n            }\\n            num = (long)nums1[i]*nums1[i];\\n            for (int j = 0;j<nums2.size();j++){\\n                if (j>0 && nums2[j]==nums2[j-1]){\\n                    continue;\\n                }\\n                if (num/nums2[j]<nums2[0])\\n                    break;\\n                if (num%nums2[j]==0 && num/nums2[j]>=nums2[j] && mp2.find(num/nums2[j])!=mp2.end()){\\n                    if (num/nums2[j]==nums2[j]){\\n                        count += mp1[nums1[i]]*(long)(mp2[nums2[j]]*(mp2[nums2[j]]-1))/2;\\n                        break;\\n                    }else{\\n                        count += mp1[nums1[i]]*(long)mp2[nums2[j]]*mp2[num/nums2[j]];\\n                    }\\n                }\\n            }\\n        }\\n        // cout<<\"--------------------\"<<endl;\\n        for (int i = 0;i<nums2.size();i++){\\n            if (i>0 && nums2[i]==nums2[i-1]){\\n                continue;\\n            }\\n            if (nums2[i]>nums1.back()){\\n                break;\\n            }\\n            if (nums2[i]<nums1[0]){\\n                continue;\\n            }\\n            num = (long)nums2[i]*nums2[i];\\n            for (int j = 0;j<nums1.size();j++){\\n                if (j>0 && nums1[j]==nums1[j-1]){\\n                    continue;\\n                }\\n                if (num/nums1[j]<nums1[0])\\n                    break;\\n                if (num%nums1[j]==0 && num/nums1[j]>=nums1[j] && mp1.find(num/nums1[j])!=mp1.end()){\\n                    if (num/nums1[j]==nums1[j]){\\n                        count += mp2[nums2[i]]*(long)(mp1[nums1[j]]*(mp1[nums1[j]]-1))/2;\\n                        break;\\n                    }else{\\n                        count += mp2[nums2[i]]*(long)mp1[nums1[j]]*mp1[num/nums1[j]];\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "```unordered_map```\n```nums1[i]^2 = nums2[j] * nums2[k]```\n```nums1 = [1,1,1,1]```\n```nums2 = [1,1]```",
                "codeTag": "Unknown"
            },
            {
                "id": 831544,
                "title": "python-hashmap",
                "content": "```\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n\\n        cnt = 0\\n        a = collections.defaultdict(int)\\n        b = collections.defaultdict(int)\\n        \\n        for num in nums1:\\n            a[num*num] += 1\\n        \\n        for num in nums2:\\n            b[num*num] += 1\\n            \\n        for j in range(len(nums2)):\\n            for k in range(j+ 1, len(nums2)):\\n                c = nums2[j]*nums2[k]\\n                if c in a: cnt += a[c] \\n                        \\n        for j in range(len(nums1)):\\n            for k in range(j+1, len(nums1)):\\n                c = nums1[j]*nums1[k]\\n                if c in b: cnt += b[c] \\n        \\n        return cnt\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n\\n        cnt = 0\\n        a = collections.defaultdict(int)\\n        b = collections.defaultdict(int)\\n        \\n        for num in nums1:\\n            a[num*num] += 1\\n        \\n        for num in nums2:\\n            b[num*num] += 1\\n            \\n        for j in range(len(nums2)):\\n            for k in range(j+ 1, len(nums2)):\\n                c = nums2[j]*nums2[k]\\n                if c in a: cnt += a[c] \\n                        \\n        for j in range(len(nums1)):\\n            for k in range(j+1, len(nums1)):\\n                c = nums1[j]*nums1[k]\\n                if c in b: cnt += b[c] \\n        \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831522,
                "title": "python3-frequency-table",
                "content": "\\n```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        cnt1, cnt2 = Counter(nums1), Counter(nums2)\\n        \\n        def fn(x, y, freq): \\n            \"\"\"Return count of triplet of nums[i]**2 = nums[j]*nums[k].\"\"\"\\n            ans = 0\\n            for xx in x: \\n                xx *= xx\\n                ans += sum(freq[xx//yy] - (yy == xx//yy) for yy in y if not xx%yy and xx//yy in freq)\\n            return ans//2\\n\\n        return fn(nums1, nums2, cnt2) + fn(nums2, nums1, cnt1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        cnt1, cnt2 = Counter(nums1), Counter(nums2)\\n        \\n        def fn(x, y, freq): \\n            \"\"\"Return count of triplet of nums[i]**2 = nums[j]*nums[k].\"\"\"\\n            ans = 0\\n            for xx in x: \\n                xx *= xx\\n                ans += sum(freq[xx//yy] - (yy == xx//yy) for yy in y if not xx%yy and xx//yy in freq)\\n            return ans//2\\n\\n        return fn(nums1, nums2, cnt2) + fn(nums2, nums1, cnt1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831511,
                "title": "straightforward-o-n-2-java-solution-with-2-hashmaps",
                "content": "```\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        //hashMap: product -> freq\\n        HashMap<Long, Integer> map1 = new HashMap<>();\\n        HashMap<Long, Integer> map2 = new HashMap<>();\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        for(int i=0;i<n1; i++){\\n            for(int j=i+1; j<n1; j++){\\n                Long prod = (long)nums1[i]*nums1[j];\\n                map1.put(prod, map1.getOrDefault(prod, 0) + 1);\\n            }\\n        }\\n        for(int i=0;i<n2; i++){\\n            for(int j=i+1; j<n2; j++){\\n                Long prod = (long) nums2[i]*nums2[j];\\n                map2.put(prod, map2.getOrDefault(prod, 0) + 1);\\n            }\\n        }\\n        //get res\\n        int res=0;\\n        for(int num : nums1){\\n            Long sqr = (long)num*num;\\n            res += map2.getOrDefault(sqr, 0);\\n        } \\n        for(int num : nums2){\\n            Long sqr = (long)num*num;\\n            res += map1.getOrDefault(sqr, 0);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        //hashMap: product -> freq\\n        HashMap<Long, Integer> map1 = new HashMap<>();\\n        HashMap<Long, Integer> map2 = new HashMap<>();\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        for(int i=0;i<n1; i++){\\n            for(int j=i+1; j<n1; j++){\\n                Long prod = (long)nums1[i]*nums1[j];\\n                map1.put(prod, map1.getOrDefault(prod, 0) + 1);\\n            }\\n        }\\n        for(int i=0;i<n2; i++){\\n            for(int j=i+1; j<n2; j++){\\n                Long prod = (long) nums2[i]*nums2[j];\\n                map2.put(prod, map2.getOrDefault(prod, 0) + 1);\\n            }\\n        }\\n        //get res\\n        int res=0;\\n        for(int num : nums1){\\n            Long sqr = (long)num*num;\\n            res += map2.getOrDefault(sqr, 0);\\n        } \\n        for(int num : nums2){\\n            Long sqr = (long)num*num;\\n            res += map1.getOrDefault(sqr, 0);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047115,
                "title": "reducing-arrays-into-a-sum-of-the-helper-function-results",
                "content": "# Approach\\nCreate a helper function counting possible products of a number in an array. Return the sum of both arrays being mapped to the power of 2 and reduced with the helper function.\\n\\n# Code\\n```\\nclass Solution {\\n\\tfunc countProducts(of: Int, inArray: [Int]) -> Int {\\n\\t\\tguard inArray.count > 1 else { return 0 }\\n\\n\\t\\tvar res = 0\\n\\n\\t\\tfor i in 0...(inArray.count - 2) {\\n\\t\\t\\tfor j in (i + 1)...(inArray.count - 1) {\\n\\t\\t\\t\\tif inArray[i] * inArray[j] == of { res += 1 }\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res\\n\\t}\\n\\n\\tfunc numTriplets(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n\\t\\tnums1.map { num in num * num }.reduce(0, { acc, num in\\n\\t\\t\\tacc + countProducts(of: num, inArray: nums2)\\n\\t\\t}) + nums2.map { num in num * num }.reduce(0, { acc, num in\\n\\t\\t\\tacc + countProducts(of: num, inArray: nums1)\\n\\t\\t})\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\tfunc countProducts(of: Int, inArray: [Int]) -> Int {\\n\\t\\tguard inArray.count > 1 else { return 0 }\\n\\n\\t\\tvar res = 0\\n\\n\\t\\tfor i in 0...(inArray.count - 2) {\\n\\t\\t\\tfor j in (i + 1)...(inArray.count - 1) {\\n\\t\\t\\t\\tif inArray[i] * inArray[j] == of { res += 1 }\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res\\n\\t}\\n\\n\\tfunc numTriplets(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n\\t\\tnums1.map { num in num * num }.reduce(0, { acc, num in\\n\\t\\t\\tacc + countProducts(of: num, inArray: nums2)\\n\\t\\t}) + nums2.map { num in num * num }.reduce(0, { acc, num in\\n\\t\\t\\tacc + countProducts(of: num, inArray: nums1)\\n\\t\\t})\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041028,
                "title": "two-pointer-approch-using-hashmap-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int countways(int[] nums1, int []nums2){\\n        int count = 0;\\n        Map<Long, Integer> map = new HashMap<>();\\n        for (int n : nums2) {\\n            map.put((long) n * n, map.getOrDefault((long) n * n, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < nums1.length; i++) {\\n            for (int j = i + 1; j < nums1.length; j++) {\\n                long prod = (long) nums1[i] * (long) nums1[j];\\n                \\n                if (map.containsKey(prod)) count += map.get(prod);\\n            }\\n        }\\n        return count;\\n    }\\n\\n\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        return countways(nums1, nums2)+countways(nums2, nums1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    private int countways(int[] nums1, int []nums2){\\n        int count = 0;\\n        Map<Long, Integer> map = new HashMap<>();\\n        for (int n : nums2) {\\n            map.put((long) n * n, map.getOrDefault((long) n * n, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < nums1.length; i++) {\\n            for (int j = i + 1; j < nums1.length; j++) {\\n                long prod = (long) nums1[i] * (long) nums1[j];\\n                \\n                if (map.containsKey(prod)) count += map.get(prod);\\n            }\\n        }\\n        return count;\\n    }\\n\\n\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        return countways(nums1, nums2)+countways(nums2, nums1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965845,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar numTriplets = function(nums1, nums2) {\\n    const triplets = (numsA, numsB) => {\\n        const squareMap = numsA.reduce((map, num) => {\\n            const square = num ** 2;\\n            const count = map.get(square) ?? 0;\\n\\n            return map.set(square, count + 1);\\n        }, new Map());\\n        let result = 0;\\n\\n        for (let a = 0; a < numsB.length; a++) {\\n            for (let b = a - 1; b >= 0; b--) {\\n                const product = numsB[a] * numsB[b];\\n                if (!squareMap.has(product)) continue;\\n                result += squareMap.get(product);\\n            }\\n        }\\n        return result;\\n    };\\n\\n    return triplets(nums1, nums2) + triplets(nums2, nums1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numTriplets = function(nums1, nums2) {\\n    const triplets = (numsA, numsB) => {\\n        const squareMap = numsA.reduce((map, num) => {\\n            const square = num ** 2;\\n            const count = map.get(square) ?? 0;\\n\\n            return map.set(square, count + 1);\\n        }, new Map());\\n        let result = 0;\\n\\n        for (let a = 0; a < numsB.length; a++) {\\n            for (let b = a - 1; b >= 0; b--) {\\n                const product = numsB[a] * numsB[b];\\n                if (!squareMap.has(product)) continue;\\n                result += squareMap.get(product);\\n            }\\n        }\\n        return result;\\n    };\\n\\n    return triplets(nums1, nums2) + triplets(nums2, nums1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3958898,
                "title": "only-using-map-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n2)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long long,int>mp1,mp2;\\n        for(auto it:nums1){\\n           long long k=1LL*it*it;\\n            mp1[k]++;\\n        }\\n            for(auto it:nums2){\\n                  long long k=1LL*it*it;\\n            mp2[k]++;\\n        }\\n        \\n        int cnt=0;\\n        for(int i=0;i<nums2.size()-1;i++){\\n            long long p=nums2[i];\\n            for(int j=i+1;j<nums2.size();j++){\\n                  p=p*nums2[j];\\n                  if(mp1.find(p)!=mp1.end())  cnt+=mp1[p];\\n                  p=nums2[i];\\n            }\\n\\n        }\\n        cout<<endl;\\n        for(int i=0;i<nums1.size()-1;i++){\\n            long long q=nums1[i];\\n            for(int j=i+1;j<nums1.size();j++){\\n                  q=q*nums1[j];\\n           \\n                  if(mp2.find(q)!=mp2.end())  cnt+=mp2[q];\\n              \\n                  q=nums1[i];\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long long,int>mp1,mp2;\\n        for(auto it:nums1){\\n           long long k=1LL*it*it;\\n            mp1[k]++;\\n        }\\n            for(auto it:nums2){\\n                  long long k=1LL*it*it;\\n            mp2[k]++;\\n        }\\n        \\n        int cnt=0;\\n        for(int i=0;i<nums2.size()-1;i++){\\n            long long p=nums2[i];\\n            for(int j=i+1;j<nums2.size();j++){\\n                  p=p*nums2[j];\\n                  if(mp1.find(p)!=mp1.end())  cnt+=mp1[p];\\n                  p=nums2[i];\\n            }\\n\\n        }\\n        cout<<endl;\\n        for(int i=0;i<nums1.size()-1;i++){\\n            long long q=nums1[i];\\n            for(int j=i+1;j<nums1.size();j++){\\n                  q=q*nums1[j];\\n           \\n                  if(mp2.find(q)!=mp2.end())  cnt+=mp2[q];\\n              \\n                  q=nums1[i];\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3866784,
                "title": "easy-java-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numTriplets(int[] arr1, int[] arr2) {\\n        int n1 = arr1.length;\\n        int n2 = arr2.length;\\n\\n        HashMap<Long,Integer> hp1 = new HashMap<>();\\n        HashMap<Long,Integer> hp2 = new HashMap<>();\\n\\n        for(int i=0; i<n1; i++){\\n            long a = (long)arr1[i]*(long)arr1[i];\\n            if(hp1.containsKey(a)) hp1.put(a,hp1.get(a)+1);\\n            else hp1.put(a,1);\\n        }\\n\\n        for(int i=0; i<n2; i++){\\n            long a = (long)arr2[i]*(long)arr2[i];\\n            if(hp2.containsKey(a)) hp2.put(a,hp2.get(a)+1);\\n            else hp2.put(a,1);\\n        }\\n\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<n1; i++){\\n            for(int j=i+1; j<n1; j++){\\n                long a = (long)arr1[i]*(long)arr1[j];\\n                if(hp2.containsKey(a)){\\n                    ans=ans+hp2.get(a);\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<n2; i++){\\n            for(int j=i+1; j<n2; j++){\\n                long a = (long)arr2[i]*(long)arr2[j];\\n                if(hp1.containsKey(a)){\\n                    ans=ans+hp1.get(a);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] arr1, int[] arr2) {\\n        int n1 = arr1.length;\\n        int n2 = arr2.length;\\n\\n        HashMap<Long,Integer> hp1 = new HashMap<>();\\n        HashMap<Long,Integer> hp2 = new HashMap<>();\\n\\n        for(int i=0; i<n1; i++){\\n            long a = (long)arr1[i]*(long)arr1[i];\\n            if(hp1.containsKey(a)) hp1.put(a,hp1.get(a)+1);\\n            else hp1.put(a,1);\\n        }\\n\\n        for(int i=0; i<n2; i++){\\n            long a = (long)arr2[i]*(long)arr2[i];\\n            if(hp2.containsKey(a)) hp2.put(a,hp2.get(a)+1);\\n            else hp2.put(a,1);\\n        }\\n\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<n1; i++){\\n            for(int j=i+1; j<n1; j++){\\n                long a = (long)arr1[i]*(long)arr1[j];\\n                if(hp2.containsKey(a)){\\n                    ans=ans+hp2.get(a);\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<n2; i++){\\n            for(int j=i+1; j<n2; j++){\\n                long a = (long)arr2[i]*(long)arr2[j];\\n                if(hp1.containsKey(a)){\\n                    ans=ans+hp1.get(a);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756908,
                "title": "python3-two-pointer-solution-o-1-space-o-n-m-time-with-indepth-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are two types of triples we\\'re looking for: \\n\\n    Type 1: Triplet (i, j, k) if nums1[i]^2 == nums2[j] * nums2[k] \\n    Type 2: Triplet (i, j, k) if nums2[i]^2 == nums1[j] * nums1[k]\\n\\nNotice the symmetry. It\\'s saying we must look for triplets across both arrays. The best way to do this is by running the algorithm twice: once with nums1 as the target (the outer-loop) and again with nums2 as the target.\\n\\nTo do this without using any space (this can be done using a hashmap to count the instances where the conditions are true for both types), we can use two pointers like a 3Sum problem. In 3Sum, we investigate 1 number and then iterate our pointers over the remainder of a single array, squeezing the Left and Right pointers together. Then, iterate to the next number, shortening the remaining subarray. \\n\\nThis has a similar approach, except instead of a singular array, we use each number in Array1 `(a1)` and then search for a multiplicative pair in Array2 `(a2)` that would equal to the target of `a1[i]^2`. This works if `a2` is sorted. The time complexity for a sort is `O(nlogn)`, but this pales in comparison to the `O(mn)` runtime of the overall algorithm, so it\\'s beneficial to do this. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe ```helper``` function will be used twice, once searching the `nums1` array against `nums2`, and then vice versa. \\n\\nIn the general case (with `a1 and a2`), sort `a2`, then go through each number in `a1`; our target number will be `a1[i]^2`. To optimally search for the pair in `a2`, we use 2 pointers, starting from the beginning and at the end: `l, r = 0, len(a2) - 1`. Then we iterate over them while `l < r`. \\n\\nThere are three conditions:\\n* `a2[l] * a2[r] > target`: The pair is too large in comparison to our target. To mitigate this, we decrement `r`. This will move our pointer to a smaller number in the leftside (this is why we sorted), lowering our multiplicative result\\n* `a2[l] * a2[r] < target`: Our pair isn\\'t big enough, so we move our left pointer to the right where larger numbers are sorted, thus growing our multiplicative pair\\n* `else: # we found our target`: This has 2 subconditions, when the left and right pointer are equal (i.e, `a2[l] == a2[r]`), and the other when they\\'re not. \\n    * If they\\'re equal, that means we shouldn\\'t iterate over them to avoid recounting. So, we use the formula for counting pairs:`((n * (n - 1)) // 2)`. This is based on a combination formula, but for only 2 items. Get the size of the window, `n`, and use the formula. We `break` afterward because the numbers are equal, so there are no other pairs to consider between the two numbers.\\n    *  Otherwise, they\\'re not equal (but the pair is successful), so we count how many of each number there are and multiply the two together, `res += rightCount * leftCount`. \\n\\n\\nRun this twice on both arrays. This would result in `O(2nm)` runtime, which reduces to `O(nm)`.\\n\\n# Complexity\\n- Time complexity: `O(nm), where n == len(nums1) and m == len(nums2)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int: \\n        def helper(a1, a2): # a1, a2: array1, array2; symmetry\\n            # sort the searchable array, a2, to make conditions possible\\n            a2.sort()\\n            res = 0\\n            for n in a1:\\n                target = n ** 2\\n                l, r = 0, len(a2) - 1\\n                while l < r: \\n                    if a2[l] * a2[r] > target:\\n                        r -= 1\\n                    elif a2[l] * a2[r] < target:\\n                        l += 1\\n                    else:\\n                        # if l, r are the same, use combination form and break\\n                        if a2[l] == a2[r]:\\n                            n = (r - l + 1)\\n                            res += ((n * (n - 1))//2)\\n                            break\\n                        # count all the numbers at l and r\\n                        # that are successful pairs\\n                        left, right = a2[l], a2[r]\\n                        leftCount, rightCount = 0, 0\\n                        while l < len(a2) and a2[l] == left:\\n                            leftCount += 1\\n                            l += 1\\n                        while r >= 0 and a2[r] == right:\\n                            rightCount += 1\\n                            r -= 1\\n                        res += rightCount * leftCount\\n                    \\n            return res\\n        \\n        # run it twice for the symmetry between type1/type2\\n        return helper(nums1, nums2) + helper(nums2, nums1)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```helper```\n```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int: \\n        def helper(a1, a2): # a1, a2: array1, array2; symmetry\\n            # sort the searchable array, a2, to make conditions possible\\n            a2.sort()\\n            res = 0\\n            for n in a1:\\n                target = n ** 2\\n                l, r = 0, len(a2) - 1\\n                while l < r: \\n                    if a2[l] * a2[r] > target:\\n                        r -= 1\\n                    elif a2[l] * a2[r] < target:\\n                        l += 1\\n                    else:\\n                        # if l, r are the same, use combination form and break\\n                        if a2[l] == a2[r]:\\n                            n = (r - l + 1)\\n                            res += ((n * (n - 1))//2)\\n                            break\\n                        # count all the numbers at l and r\\n                        # that are successful pairs\\n                        left, right = a2[l], a2[r]\\n                        leftCount, rightCount = 0, 0\\n                        while l < len(a2) and a2[l] == left:\\n                            leftCount += 1\\n                            l += 1\\n                        while r >= 0 and a2[r] == right:\\n                            rightCount += 1\\n                            r -= 1\\n                        res += rightCount * leftCount\\n                    \\n            return res\\n        \\n        # run it twice for the symmetry between type1/type2\\n        return helper(nums1, nums2) + helper(nums2, nums1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707006,
                "title": "python3-solution-easy-to-understand-beginner-s-friendly",
                "content": "# Code\\n```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        Map1 = Counter([n * n for n in nums1])\\n        Map2 = Counter([n * n for n in nums2])\\n\\n        res = 0\\n        for i in range(len(nums1) - 1):\\n            for j in range(i + 1, len(nums1)):\\n                res += Map2[nums1[i] * nums1[j]]\\n\\n        for i in range(len(nums2) - 1):\\n            for j in range(i + 1, len(nums2)):\\n                res += Map1[nums2[i] * nums2[j]]\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        Map1 = Counter([n * n for n in nums1])\\n        Map2 = Counter([n * n for n in nums2])\\n\\n        res = 0\\n        for i in range(len(nums1) - 1):\\n            for j in range(i + 1, len(nums1)):\\n                res += Map2[nums1[i] * nums1[j]]\\n\\n        for i in range(len(nums2) - 1):\\n            for j in range(i + 1, len(nums2)):\\n                res += Map1[nums2[i] * nums2[j]]\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665094,
                "title": "easy-understand-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        Count1 = Counter(nums1)\\n        Count2 = Counter(nums2)\\n        res = 0\\n        for i in Count1:\\n            db = Count2.copy()\\n            while db:\\n                item = db.popitem()\\n                Q, r = divmod(i*i, item[0])\\n                if r == 0 and Q in db:\\n                    res += db[Q]*item[1]*Count1[i]\\n                    db.pop(Q)\\n                elif r == 0 and Q == item[0]:\\n                    res += comb(item[1],2)*Count1[i]\\n                    \\n        for i in Count2:\\n            db = Count1.copy()\\n            while db:\\n                item = db.popitem()\\n                Q, r = divmod(i*i, item[0])\\n                if r == 0 and Q in db:\\n                    res += db[Q]*item[1]*Count2[i]\\n                    db.pop(Q)\\n                elif r == 0 and Q == item[0]:\\n                    res += comb(item[1],2)*Count2[i]\\n\\n        return res\\n                    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        Count1 = Counter(nums1)\\n        Count2 = Counter(nums2)\\n        res = 0\\n        for i in Count1:\\n            db = Count2.copy()\\n            while db:\\n                item = db.popitem()\\n                Q, r = divmod(i*i, item[0])\\n                if r == 0 and Q in db:\\n                    res += db[Q]*item[1]*Count1[i]\\n                    db.pop(Q)\\n                elif r == 0 and Q == item[0]:\\n                    res += comb(item[1],2)*Count1[i]\\n                    \\n        for i in Count2:\\n            db = Count1.copy()\\n            while db:\\n                item = db.popitem()\\n                Q, r = divmod(i*i, item[0])\\n                if r == 0 and Q in db:\\n                    res += db[Q]*item[1]*Count2[i]\\n                    db.pop(Q)\\n                elif r == 0 and Q == item[0]:\\n                    res += comb(item[1],2)*Count2[i]\\n\\n        return res\\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664545,
                "title": "unique-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong mod = 1e9+7;\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n\\n        map<long long ,long long>mp1;\\n        for(long long i : nums1){\\n            long long n = (i)%mod*(i)%mod;\\n            n=n%mod;\\n\\n\\n            mp1[n]++;\\n        }\\n        map<long long ,long long>mp2;\\n        for(long long i : nums2){\\n            long long n = (i)%mod * (i)%mod;\\n            n=n%mod;\\n\\n            mp2[n]++;\\n        }\\n        int res = 0;\\n\\n        int i = 0;\\n        while(i<nums2.size()){\\n\\n            int j = i+1;\\n            while(j<nums2.size()){\\n\\n                long long n = (nums2[i])%mod*(nums2[j])%mod;\\n                n=n%mod;\\n\\n                if(mp1.find(n)!=mp1.end()){\\n\\n                    res = res + mp1[n];\\n                }\\n\\n\\n                j++;\\n            }\\n            i++;\\n        }\\n        \\n       \\n        i = 0;\\n        while(i<nums1.size()){\\n            int j = i+1;\\n            while(j<nums1.size()){\\n\\n                long long int n = (nums1[i])%mod*(nums1[j])%mod;\\n                n=n%mod;\\n\\n                if(mp2.find(n)!=mp2.end()){\\n                    res = res + mp2[n];\\n                }\\n                j++;\\n            }\\n            i++;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong mod = 1e9+7;\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n\\n        map<long long ,long long>mp1;\\n        for(long long i : nums1){\\n            long long n = (i)%mod*(i)%mod;\\n            n=n%mod;\\n\\n\\n            mp1[n]++;\\n        }\\n        map<long long ,long long>mp2;\\n        for(long long i : nums2){\\n            long long n = (i)%mod * (i)%mod;\\n            n=n%mod;\\n\\n            mp2[n]++;\\n        }\\n        int res = 0;\\n\\n        int i = 0;\\n        while(i<nums2.size()){\\n\\n            int j = i+1;\\n            while(j<nums2.size()){\\n\\n                long long n = (nums2[i])%mod*(nums2[j])%mod;\\n                n=n%mod;\\n\\n                if(mp1.find(n)!=mp1.end()){\\n\\n                    res = res + mp1[n];\\n                }\\n\\n\\n                j++;\\n            }\\n            i++;\\n        }\\n        \\n       \\n        i = 0;\\n        while(i<nums1.size()){\\n            int j = i+1;\\n            while(j<nums1.size()){\\n\\n                long long int n = (nums1[i])%mod*(nums1[j])%mod;\\n                n=n%mod;\\n\\n                if(mp2.find(n)!=mp2.end()){\\n                    res = res + mp2[n];\\n                }\\n                j++;\\n            }\\n            i++;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607712,
                "title": "python-pass-with-accumulate-frequencys-of-nums-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"     \\n        square1 = map(lambda x : x* x, nums1)\\n        square2 = map(lambda x : x* x, nums2)\\n        #frequency of nums1^2 and nums2^2\\n        freq1, freq2 = defaultdict(int),defaultdict(int)\\n        m1, m2 = range(len(nums1)), range(len(nums2))\\n        for i in m1:\\n            freq1[square1[i]] += 1\\n        for i in m2:\\n            freq2[square2[i]] += 1\\n            \\n        Ans = 0\\n        #type1\\n        for item in freq1:\\n            for j in m2:\\n                if item % nums2[j] == 0: \\n                    k = item / nums2[j]\\n                    Ans += nums2[j+1:].count(k) * freq1[item]\\n        #type2\\n        for item in freq2:\\n            for j in m1:\\n                if item % nums1[j] == 0:\\n                    k = item / nums1[j]\\n                    Ans += nums1[j+1:].count(k) * freq2[item]\\n\\n        return Ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"     \\n        square1 = map(lambda x : x* x, nums1)\\n        square2 = map(lambda x : x* x, nums2)\\n        #frequency of nums1^2 and nums2^2\\n        freq1, freq2 = defaultdict(int),defaultdict(int)\\n        m1, m2 = range(len(nums1)), range(len(nums2))\\n        for i in m1:\\n            freq1[square1[i]] += 1\\n        for i in m2:\\n            freq2[square2[i]] += 1\\n            \\n        Ans = 0\\n        #type1\\n        for item in freq1:\\n            for j in m2:\\n                if item % nums2[j] == 0: \\n                    k = item / nums2[j]\\n                    Ans += nums2[j+1:].count(k) * freq1[item]\\n        #type2\\n        for item in freq2:\\n            for j in m1:\\n                if item % nums1[j] == 0:\\n                    k = item / nums1[j]\\n                    Ans += nums1[j+1:].count(k) * freq2[item]\\n\\n        return Ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562590,
                "title": "c-solution-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    \\n    int count(vector<int> & A,vector<int>& B)\\n    {\\n        map<ll,int> m;\\n        int c=0;\\n        for(auto a :A) m[(ll)a*a]++;\\n\\n        for(int i=0;i<B.size()-1;i++)\\n        {\\n            for(int j{i+1};j<B.size();j++)\\n            {\\n                if(m.count((ll)B[i]*B[j]))\\n                    c+=m[(ll)B[i]*B[j]];\\n            }\\n        }\\n        return c;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        return count(nums1,nums2) + count(nums2,nums1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    \\n    int count(vector<int> & A,vector<int>& B)\\n    {\\n        map<ll,int> m;\\n        int c=0;\\n        for(auto a :A) m[(ll)a*a]++;\\n\\n        for(int i=0;i<B.size()-1;i++)\\n        {\\n            for(int j{i+1};j<B.size();j++)\\n            {\\n                if(m.count((ll)B[i]*B[j]))\\n                    c+=m[(ll)B[i]*B[j]];\\n            }\\n        }\\n        return c;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        return count(nums1,nums2) + count(nums2,nums1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540026,
                "title": "brute-force-slowish",
                "content": "# Code\\n```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        def count_triplets(nums1: List[int], nums2: List[int]) -> int:\\n            count = 0\\n            product_map = defaultdict(int)\\n\\n            for i in range(len(nums1)):\\n                for j in range(i + 1, len(nums1)):\\n                    product_map[nums1[i] * nums1[j]] += 1\\n\\n            for i in range(len(nums2)):\\n                square = nums2[i] * nums2[i]\\n                count += product_map[square]\\n\\n            return count\\n\\n        return count_triplets(nums1, nums2) + count_triplets(nums2, nums1)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        def count_triplets(nums1: List[int], nums2: List[int]) -> int:\\n            count = 0\\n            product_map = defaultdict(int)\\n\\n            for i in range(len(nums1)):\\n                for j in range(i + 1, len(nums1)):\\n                    product_map[nums1[i] * nums1[j]] += 1\\n\\n            for i in range(len(nums2)):\\n                square = nums2[i] * nums2[i]\\n                count += product_map[square]\\n\\n            return count\\n\\n        return count_triplets(nums1, nums2) + count_triplets(nums2, nums1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260804,
                "title": "python3-simplest-solution-beats-96-users-self-explanatory",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1SquareFrequency=defaultdict(int)\\n        nums2SquareFrequency=defaultdict(int)\\n        for num in nums1:\\n            nums1SquareFrequency[num**2]+=1\\n        for num in nums2:\\n            nums2SquareFrequency[num**2]+=1\\n        ans=0\\n        for i in range(len(nums1)-1):\\n            for j in range(i+1,len(nums1)):\\n                ans+=nums2SquareFrequency[nums1[i]*nums1[j]]\\n        for i in range(len(nums2)-1):\\n            for j in range(i+1,len(nums2)):\\n                ans+=nums1SquareFrequency[nums2[i]*nums2[j]]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1SquareFrequency=defaultdict(int)\\n        nums2SquareFrequency=defaultdict(int)\\n        for num in nums1:\\n            nums1SquareFrequency[num**2]+=1\\n        for num in nums2:\\n            nums2SquareFrequency[num**2]+=1\\n        ans=0\\n        for i in range(len(nums1)-1):\\n            for j in range(i+1,len(nums1)):\\n                ans+=nums2SquareFrequency[nums1[i]*nums1[j]]\\n        for i in range(len(nums2)-1):\\n            for j in range(i+1,len(nums2)):\\n                ans+=nums1SquareFrequency[nums2[i]*nums2[j]]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199233,
                "title": "lc-1577-m-python3-a-plain-solution",
                "content": "Use `collections.Counter` and iterations to count.\\n\\n```python3 []\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        sq_cnter1 = Counter([num**2 for num in nums1])\\n        sq_cnter2 = Counter([num**2 for num in nums2])\\n\\n        def count(nums, sq_cnter):\\n            n = len(nums)\\n            cnt = 0\\n            for i in range(n-1):\\n                for j in range(i+1, n):\\n                    cnt += sq_cnter[nums[i]*nums[j]]\\n            return cnt\\n        \\n        return count(nums1, sq_cnter2) + count(nums2, sq_cnter1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        sq_cnter1 = Counter([num**2 for num in nums1])\\n        sq_cnter2 = Counter([num**2 for num in nums2])\\n\\n        def count(nums, sq_cnter):\\n            n = len(nums)\\n            cnt = 0\\n            for i in range(n-1):\\n                for j in range(i+1, n):\\n                    cnt += sq_cnter[nums[i]*nums[j]]\\n            return cnt\\n        \\n        return count(nums1, sq_cnter2) + count(nums2, sq_cnter1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199072,
                "title": "everybody-copies-answers-beats-100-this-issue-is-easy-we-sort-and-use-two-pointers-classic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar numTriplets = function(nums1, nums2) {\\n  var res = 0\\n  nums1.sort((a, b) => a - b < 0 ? -1 : 1)\\n  nums2.sort((a, b) => a - b < 0 ? -1 : 1)\\n\\n  function process(nums1, nums2) {\\n    var len1 = nums1.length\\n    var len2 = nums2.length\\n    for (var i = 0; i < len1; i++) {\\n      var leftPointer = 0\\n      var RightPointer = len2 - 1\\n      var cur = nums1[i]\\n      var curSqr = Math.pow(cur, 2)\\n\\n      while (leftPointer < RightPointer) {\\n        var curMul = nums2[leftPointer] * nums2[RightPointer]\\n        if (curMul > curSqr) {\\n          RightPointer--\\n        } else if (curMul < curSqr) {\\n          leftPointer++\\n        } else {\\n          if (nums2[leftPointer] === nums2[RightPointer]) {\\n            let len = RightPointer - leftPointer + 1\\n            res += (len * (len - 1)) / 2\\n            break\\n          } else {\\n            let right = nums2[RightPointer]\\n            let left = nums2[leftPointer]\\n            let leftSameCount = 0\\n            let rightSameCount = 0\\n            while (right === nums2[RightPointer]) {\\n              RightPointer--\\n              rightSameCount++\\n            }\\n            while (left === nums2[leftPointer]) {\\n              leftPointer++\\n              leftSameCount++\\n            }\\n            res += leftSameCount * rightSameCount\\n          }\\n        }\\n      }\\n    }\\n  }  \\n\\n  process(nums1, nums2)\\n  process(nums2, nums1)\\n\\n  return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar numTriplets = function(nums1, nums2) {\\n  var res = 0\\n  nums1.sort((a, b) => a - b < 0 ? -1 : 1)\\n  nums2.sort((a, b) => a - b < 0 ? -1 : 1)\\n\\n  function process(nums1, nums2) {\\n    var len1 = nums1.length\\n    var len2 = nums2.length\\n    for (var i = 0; i < len1; i++) {\\n      var leftPointer = 0\\n      var RightPointer = len2 - 1\\n      var cur = nums1[i]\\n      var curSqr = Math.pow(cur, 2)\\n\\n      while (leftPointer < RightPointer) {\\n        var curMul = nums2[leftPointer] * nums2[RightPointer]\\n        if (curMul > curSqr) {\\n          RightPointer--\\n        } else if (curMul < curSqr) {\\n          leftPointer++\\n        } else {\\n          if (nums2[leftPointer] === nums2[RightPointer]) {\\n            let len = RightPointer - leftPointer + 1\\n            res += (len * (len - 1)) / 2\\n            break\\n          } else {\\n            let right = nums2[RightPointer]\\n            let left = nums2[leftPointer]\\n            let leftSameCount = 0\\n            let rightSameCount = 0\\n            while (right === nums2[RightPointer]) {\\n              RightPointer--\\n              rightSameCount++\\n            }\\n            while (left === nums2[leftPointer]) {\\n              leftPointer++\\n              leftSameCount++\\n            }\\n            res += leftSameCount * rightSameCount\\n          }\\n        }\\n      }\\n    }\\n  }  \\n\\n  process(nums1, nums2)\\n  process(nums2, nums1)\\n\\n  return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3181098,
                "title": "best-solution-with-full-explanation",
                "content": "1.For each array, create a frequency map that counts the occurrences of each element squared. Since we\\'re looking for pairs of elements that multiply to a square, we need to consider the squares of the elements in the arrays.\\n\\n2.For each pair of elements in nums1, check if their product is present in the frequency map of nums2. If so, add the count of that element to the total count.\\n\\n3.For each pair of elements in nums2, check if their product is present in the frequency map of nums1. If so, add the count of that element to the total count.\\n\\n4.Return the total count as the answer.\\n```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        int count = 0;\\n        count += countTriplets(nums1, nums2);\\n        count += countTriplets(nums2, nums1);\\n        return count;\\n    }\\n\\n    private int countTriplets(int[] nums1, int[] nums2) {\\n        int count = 0;\\n        Map<Long, Integer> freq = new HashMap<>();\\n        for (int n : nums2) {\\n            freq.put((long) n * n, freq.getOrDefault((long) n * n, 0) + 1);\\n        }\\n        for (int i = 0; i < nums1.length; i++) {\\n            for (int j = i + 1; j < nums1.length; j++) {\\n                long prod = (long) nums1[i] * (long) nums1[j];\\n                if (freq.containsKey(prod)) {\\n                    count += freq.get(prod);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        int count = 0;\\n        count += countTriplets(nums1, nums2);\\n        count += countTriplets(nums2, nums1);\\n        return count;\\n    }\\n\\n    private int countTriplets(int[] nums1, int[] nums2) {\\n        int count = 0;\\n        Map<Long, Integer> freq = new HashMap<>();\\n        for (int n : nums2) {\\n            freq.put((long) n * n, freq.getOrDefault((long) n * n, 0) + 1);\\n        }\\n        for (int i = 0; i < nums1.length; i++) {\\n            for (int j = i + 1; j < nums1.length; j++) {\\n                long prod = (long) nums1[i] * (long) nums1[j];\\n                if (freq.containsKey(prod)) {\\n                    count += freq.get(prod);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174636,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn num_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n        use std::collections::HashMap;\\n        let mut ans = 0;\\n        let (mut m1, mut m2) = (HashMap::new(), HashMap::new());\\n        for i in 0..nums1.len() {\\n            for j in i + 1..nums1.len() {\\n                let p = nums1[i] as i64 * nums1[j] as i64;\\n                *m1.entry(p).or_insert(0) += 1;\\n            }\\n        }\\n        for i in 0..nums2.len() {\\n            for j in i + 1..nums2.len() {\\n                let p = nums2[i] as i64 * nums2[j] as i64;\\n                *m2.entry(p).or_insert(0) += 1;\\n            }\\n        }\\n        for &num in nums1.iter() {\\n            if let Some(&v) = m2.get(&(num as i64 * num as i64)) {\\n                ans += v;\\n            }\\n        }\\n        for &num in nums2.iter() {\\n            if let Some(&v) = m1.get(&(num as i64 * num as i64)) {\\n                ans += v;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n        use std::collections::HashMap;\\n        let mut ans = 0;\\n        let (mut m1, mut m2) = (HashMap::new(), HashMap::new());\\n        for i in 0..nums1.len() {\\n            for j in i + 1..nums1.len() {\\n                let p = nums1[i] as i64 * nums1[j] as i64;\\n                *m1.entry(p).or_insert(0) += 1;\\n            }\\n        }\\n        for i in 0..nums2.len() {\\n            for j in i + 1..nums2.len() {\\n                let p = nums2[i] as i64 * nums2[j] as i64;\\n                *m2.entry(p).or_insert(0) += 1;\\n            }\\n        }\\n        for &num in nums1.iter() {\\n            if let Some(&v) = m2.get(&(num as i64 * num as i64)) {\\n                ans += v;\\n            }\\n        }\\n        for &num in nums2.iter() {\\n            if let Some(&v) = m1.get(&(num as i64 * num as i64)) {\\n                ans += v;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3128576,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition here is to find all the triplets that satisfy the given condition. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a two-pointer technique to solve this problem. We can iterate through each array, and for each element we can use two pointers to calculate the product of the other two elements. If the product is equal to the current element, we can add the triplet to our answer.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Note\\nNot the most effient solution\\n\\n# Code\\n```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        freq1 = self.get_freq(nums1)\\n        freq2 = self.get_freq(nums2)\\n        ans = 0\\n        ans += self.count(freq1, nums2)\\n        ans += self.count(freq2, nums1)\\n        return ans\\n    \\n    def get_freq(self, nums):\\n        ans = collections.defaultdict(int)\\n        n = len(nums)\\n        for i in range(n):\\n            ans[nums[i] * nums[i]] += 1\\n        return ans\\n    \\n    def count(self, freq, other):\\n        ans = 0\\n        m = len(other)\\n        for i in range(m):\\n            for j in range(i+1, m):\\n                prod = other[i] * other[j]\\n                if prod in freq:\\n                    ans += freq[prod]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        freq1 = self.get_freq(nums1)\\n        freq2 = self.get_freq(nums2)\\n        ans = 0\\n        ans += self.count(freq1, nums2)\\n        ans += self.count(freq2, nums1)\\n        return ans\\n    \\n    def get_freq(self, nums):\\n        ans = collections.defaultdict(int)\\n        n = len(nums)\\n        for i in range(n):\\n            ans[nums[i] * nums[i]] += 1\\n        return ans\\n    \\n    def count(self, freq, other):\\n        ans = 0\\n        m = len(other)\\n        for i in range(m):\\n            for j in range(i+1, m):\\n                prod = other[i] * other[j]\\n                if prod in freq:\\n                    ans += freq[prod]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047357,
                "title": "python-hash-map-and-straightforward-solution-explained",
                "content": "the problem data size is just 1000. Thus, we can solve this problem with O(n^2) time complexity.\\n\\nStep 1, build a hash map to track the num^2 value count for each array.\\n\\nStep 2, sweep each arrary, find two numbers from it and check if their product is in the hash map.\\n\\nsee details in code:\\n\\n```\\nclass Solution:\\n    def numTriplets(self, nums1, nums2):\\n        # build hash table for both nums1 and nums2\\n        num1_sq_dict = collections.defaultdict(int)\\n        num2_sq_dict = collections.defaultdict(int)\\n\\n        for n in nums1:\\n            num1_sq_dict[n * n] += 1\\n        for n in nums2:\\n            num2_sq_dict[n * n] += 1\\n\\n        ans = 0\\n\\n        len_n1 = len(nums1)\\n        len_n2 = len(nums2)\\n        for i in range(len_n1 - 1):\\n            for j in range(i + 1, len_n1):\\n                prod = nums1[i] * nums1[j]\\n                if prod in num2_sq_dict:\\n                    ans += num2_sq_dict[prod]\\n        for i in range(len_n2 - 1):\\n            for j in range(i + 1, len_n2):\\n                prod = nums2[i] * nums2[j]\\n                if prod in num1_sq_dict:\\n                    ans += num1_sq_dict[prod]\\n\\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1, nums2):\\n        # build hash table for both nums1 and nums2\\n        num1_sq_dict = collections.defaultdict(int)\\n        num2_sq_dict = collections.defaultdict(int)\\n\\n        for n in nums1:\\n            num1_sq_dict[n * n] += 1\\n        for n in nums2:\\n            num2_sq_dict[n * n] += 1\\n\\n        ans = 0\\n\\n        len_n1 = len(nums1)\\n        len_n2 = len(nums2)\\n        for i in range(len_n1 - 1):\\n            for j in range(i + 1, len_n1):\\n                prod = nums1[i] * nums1[j]\\n                if prod in num2_sq_dict:\\n                    ans += num2_sq_dict[prod]\\n        for i in range(len_n2 - 1):\\n            for j in range(i + 1, len_n2):\\n                prod = nums2[i] * nums2[j]\\n                if prod in num1_sq_dict:\\n                    ans += num1_sq_dict[prod]\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032341,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\nunordered_map<long, long> m1,m2;\\n\\nfor(auto a : nums1)\\nm1[(long)a*(long)a]++;\\n\\nfor(auto a: nums2)\\nm2[(long)a*(long)a]++;\\n\\nint ans=0;\\nfor(int i=0; i<nums1.size();i++){\\nfor(int j=i+1; j<nums1.size(); j++){\\n    ans+=m2[(long)nums1[i]*(long)nums1[j]];\\n}\\n}\\n    for(int i=0; i<nums2.size(); i++){\\nfor(int j=i+1; j<nums2.size(); j++){\\n\\n    ans+=m1[(long)nums2[i]*(long)nums2[j]];\\n}\\n   } \\n  return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\nunordered_map<long, long> m1,m2;\\n\\nfor(auto a : nums1)\\nm1[(long)a*(long)a]++;\\n\\nfor(auto a: nums2)\\nm2[(long)a*(long)a]++;\\n\\nint ans=0;\\nfor(int i=0; i<nums1.size();i++){\\nfor(int j=i+1; j<nums1.size(); j++){\\n    ans+=m2[(long)nums1[i]*(long)nums1[j]];\\n}\\n}\\n    for(int i=0; i<nums2.size(); i++){\\nfor(int j=i+1; j<nums2.size(); j++){\\n\\n    ans+=m1[(long)nums2[i]*(long)nums2[j]];\\n}\\n   } \\n  return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942063,
                "title": "cpp-long-long",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin() , nums1.end());\\n        sort(nums2.begin() , nums2.end());\\n        ll ans = 0;\\n        // type : 1;\\n        for(int i = 0 ; i < nums1.size(); i++){\\n            ll val = (ll)nums1[i] * (ll)nums1[i];\\n            unordered_map<int,int>mp;\\n            for(int j = 0 ; j < nums2.size();j++){\\n                if(val % nums2[j] != 0) continue;\\n                ll x = val / nums2[j];\\n                if(mp.count(x)){\\n                    ans += mp[x];\\n                }\\n                mp[nums2[j]]++;\\n            }\\n        }\\n        for(int i = 0 ; i < nums2.size(); i++){\\n            ll val = (ll)nums2[i] * (ll)nums2[i];\\n            unordered_map<int,int>mp;\\n            for(int j = 0 ; j < nums1.size();j++){\\n                if(val % nums1[j] != 0) continue;\\n                ll x = (ll)val / (ll)nums1[j];\\n                if(mp.count(x)){\\n                    ans += mp[x];\\n                }\\n                mp[nums1[j]]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin() , nums1.end());\\n        sort(nums2.begin() , nums2.end());\\n        ll ans = 0;\\n        // type : 1;\\n        for(int i = 0 ; i < nums1.size(); i++){\\n            ll val = (ll)nums1[i] * (ll)nums1[i];\\n            unordered_map<int,int>mp;\\n            for(int j = 0 ; j < nums2.size();j++){\\n                if(val % nums2[j] != 0) continue;\\n                ll x = val / nums2[j];\\n                if(mp.count(x)){\\n                    ans += mp[x];\\n                }\\n                mp[nums2[j]]++;\\n            }\\n        }\\n        for(int i = 0 ; i < nums2.size(); i++){\\n            ll val = (ll)nums2[i] * (ll)nums2[i];\\n            unordered_map<int,int>mp;\\n            for(int j = 0 ; j < nums1.size();j++){\\n                if(val % nums1[j] != 0) continue;\\n                ll x = (ll)val / (ll)nums1[j];\\n                if(mp.count(x)){\\n                    ans += mp[x];\\n                }\\n                mp[nums1[j]]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941753,
                "title": "frequency-table-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrecalculate frequencies of two arrays.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n*m)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nfunc numTriplets(nums1 []int, nums2 []int) int {\\n\\tif len(nums1) == 1 && len(nums2) == 1 {\\n\\t\\treturn 0\\n\\t}\\n\\tcnt1, cnt2 := freqMap(nums1), freqMap(nums2)\\n\\n\\treturn calculate(nums1, nums2, cnt1, cnt2) + calculate(nums2, nums1, cnt2, cnt1)\\n}\\n\\nfunc freqMap(nums []int) *map[int]int {\\n\\tcounts := map[int]int{}\\n\\tfor i := range nums {\\n\\t\\tcounts[nums[i]] += 1\\n\\t}\\n\\treturn &counts\\n}\\n\\nfunc calculate(nums1, nums2 []int, cnt1, cnt2 *map[int]int) int {\\n\\tvar result int\\n\\tvar xSqr, acc int\\n\\tfor x1, c := range *cnt1 {\\n\\t\\tacc = 0\\n\\t\\txSqr = x1 * x1\\n\\t\\tfor _, x2 := range nums2 {\\n\\t\\t\\tif xSqr%x2 != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n        \\ty := xSqr / x2\\n     \\t\\tif val, ok := (*cnt2)[y]; ok {\\n\\t\\t\\t\\tacc += val\\n\\t\\t\\t\\tif y == x2 {\\n\\t\\t\\t\\t\\tacc -= 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult += c * acc / 2\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numTriplets(nums1 []int, nums2 []int) int {\\n\\tif len(nums1) == 1 && len(nums2) == 1 {\\n\\t\\treturn 0\\n\\t}\\n\\tcnt1, cnt2 := freqMap(nums1), freqMap(nums2)\\n\\n\\treturn calculate(nums1, nums2, cnt1, cnt2) + calculate(nums2, nums1, cnt2, cnt1)\\n}\\n\\nfunc freqMap(nums []int) *map[int]int {\\n\\tcounts := map[int]int{}\\n\\tfor i := range nums {\\n\\t\\tcounts[nums[i]] += 1\\n\\t}\\n\\treturn &counts\\n}\\n\\nfunc calculate(nums1, nums2 []int, cnt1, cnt2 *map[int]int) int {\\n\\tvar result int\\n\\tvar xSqr, acc int\\n\\tfor x1, c := range *cnt1 {\\n\\t\\tacc = 0\\n\\t\\txSqr = x1 * x1\\n\\t\\tfor _, x2 := range nums2 {\\n\\t\\t\\tif xSqr%x2 != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n        \\ty := xSqr / x2\\n     \\t\\tif val, ok := (*cnt2)[y]; ok {\\n\\t\\t\\t\\tacc += val\\n\\t\\t\\t\\tif y == x2 {\\n\\t\\t\\t\\t\\tacc -= 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult += c * acc / 2\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2891645,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n       return fun(nums1,nums2)+fun(nums2,nums1);\\n    }\\n    int fun(vector<int>&v1,vector<int>&v2)\\n    {\\n        //a*a=x*y\\n        int ans=0;\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            long long int num=(long long)v1[i]*v1[i];\\n            unordered_map<int,int>mp;\\n            for(int j=0;j<v2.size();j++)\\n            {\\n                if(num%v2[j]!=0)\\n                {\\n                    continue;\\n                }\\n                int t=num/v2[j];\\n                if(mp.find(t)!=mp.end())\\n                {\\n                    ans=ans+mp[t];\\n                }\\n                mp[v2[j]]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n       return fun(nums1,nums2)+fun(nums2,nums1);\\n    }\\n    int fun(vector<int>&v1,vector<int>&v2)\\n    {\\n        //a*a=x*y\\n        int ans=0;\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            long long int num=(long long)v1[i]*v1[i];\\n            unordered_map<int,int>mp;\\n            for(int j=0;j<v2.size();j++)\\n            {\\n                if(num%v2[j]!=0)\\n                {\\n                    continue;\\n                }\\n                int t=num/v2[j];\\n                if(mp.find(t)!=mp.end())\\n                {\\n                    ans=ans+mp[t];\\n                }\\n                mp[v2[j]]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890488,
                "title": "rust-solution",
                "content": "# Code\\n```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn num_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n      let nums1 = nums1.into_iter().map(|v| v as usize).collect::<Vec<usize>>();\\n      let nums2 = nums2.into_iter().map(|v| v as usize).collect::<Vec<usize>>();\\n      let mut m1 = HashMap::new();\\n      let mut m2 = HashMap::new();\\n      let n1 = nums1.len();\\n      let n2 = nums2.len();\\n\\n      for i in 0..n1 {\\n        for j in i+1..n1 {\\n          *m1.entry(nums1[i] * nums1[j]).or_insert(0) += 1;\\n        }\\n      }\\n      for i in 0..n2 {\\n        for j in i+1..n2 {\\n          *m2.entry(nums2[i] * nums2[j]).or_insert(0) += 1;\\n        }\\n      }\\n\\n      let mut result = 0;\\n      for v in nums1 {\\n        if let Some(num) = m2.get(&(v*v)) {\\n          result += num;\\n        }\\n      }\\n      for v in nums2 {\\n        if let Some(num) = m1.get(&(v*v)) {\\n          result += num;\\n        }\\n      }\\n      result as i32\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn num_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n      let nums1 = nums1.into_iter().map(|v| v as usize).collect::<Vec<usize>>();\\n      let nums2 = nums2.into_iter().map(|v| v as usize).collect::<Vec<usize>>();\\n      let mut m1 = HashMap::new();\\n      let mut m2 = HashMap::new();\\n      let n1 = nums1.len();\\n      let n2 = nums2.len();\\n\\n      for i in 0..n1 {\\n        for j in i+1..n1 {\\n          *m1.entry(nums1[i] * nums1[j]).or_insert(0) += 1;\\n        }\\n      }\\n      for i in 0..n2 {\\n        for j in i+1..n2 {\\n          *m2.entry(nums2[i] * nums2[j]).or_insert(0) += 1;\\n        }\\n      }\\n\\n      let mut result = 0;\\n      for v in nums1 {\\n        if let Some(num) = m2.get(&(v*v)) {\\n          result += num;\\n        }\\n      }\\n      for v in nums2 {\\n        if let Some(num) = m1.get(&(v*v)) {\\n          result += num;\\n        }\\n      }\\n      result as i32\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2880481,
                "title": "python-counter",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort()\\n        nums2.sort()\\n        d1 = Counter(nums1)\\n        d2 = Counter(nums2)\\n        def solve(nums1, d2):\\n            res = 0\\n            for num in nums1:\\n                num *= num\\n                for i in sorted(d2.keys()):\\n                    if not num % i:\\n                        if i < num//i:\\n                            res += d2[i]*d2[num//i]\\n                        elif i == num//i:\\n                            res += d2[i]*(d2[i]-1)//2\\n                            break\\n                        else:\\n                            break\\n            return res\\n        return solve(nums1, d2) + solve(nums2, d1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort()\\n        nums2.sort()\\n        d1 = Counter(nums1)\\n        d2 = Counter(nums2)\\n        def solve(nums1, d2):\\n            res = 0\\n            for num in nums1:\\n                num *= num\\n                for i in sorted(d2.keys()):\\n                    if not num % i:\\n                        if i < num//i:\\n                            res += d2[i]*d2[num//i]\\n                        elif i == num//i:\\n                            res += d2[i]*(d2[i]-1)//2\\n                            break\\n                        else:\\n                            break\\n            return res\\n        return solve(nums1, d2) + solve(nums2, d1)",
                "codeTag": "Java"
            },
            {
                "id": 2862975,
                "title": "python-two-sum-algo-faster-than-90-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def twoProduct(self, num: int, nums: List[int]) -> int:\\n        hashMap, count = defaultdict(int), 0\\n        for elem in nums:\\n            if num % elem == 0:\\n                count += hashMap[num // elem]\\n            hashMap[elem] += 1\\n        return count\\n    \\n    def countForArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        res, lastRes, lastNum = 0, 0, 0\\n        nums1.sort()\\n        for idx in range(len(nums1)):\\n            if nums1[idx] == lastNum:\\n                res += lastRes\\n            else:\\n                lastRes = self.twoProduct(nums1[idx] * nums1[idx], nums2)\\n                res += lastRes\\n            lastNum = nums1[idx]\\n        return res\\n    \\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        return self.countForArray(nums1, nums2) + self.countForArray(nums2, nums1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def twoProduct(self, num: int, nums: List[int]) -> int:\\n        hashMap, count = defaultdict(int), 0\\n        for elem in nums:\\n            if num % elem == 0:\\n                count += hashMap[num // elem]\\n            hashMap[elem] += 1\\n        return count\\n    \\n    def countForArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        res, lastRes, lastNum = 0, 0, 0\\n        nums1.sort()\\n        for idx in range(len(nums1)):\\n            if nums1[idx] == lastNum:\\n                res += lastRes\\n            else:\\n                lastRes = self.twoProduct(nums1[idx] * nums1[idx], nums2)\\n                res += lastRes\\n            lastNum = nums1[idx]\\n        return res\\n    \\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        return self.countForArray(nums1, nums2) + self.countForArray(nums2, nums1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802271,
                "title": "c-two-sum-counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need two values whose product can be equal to num*num for any num.\\nThink of solving using two sum approach. \\nStore the counts and solve.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake two maps. Store the count of each element for both arrays in diff maps.\\nNow for any number in map1 we iterate all elements of map2 if map1*map1 can be formed by products of two numbers of map2 which means for the element in map2 map1%map2 == 0 and map2 should also contain map1/map2.\\nNow there will be two cases when `m1*m1 = m2*m2` and `m1*m1 = m2*m3`\\nFor the first case we just take 2 elements out of cnt[m2] using nC2.\\nFor the second case we will have repeated answers as we take `cnt[m2]*cnt[m3]` and then when we reach m3 then we have `cnt[m3]*cnt[m2]` so we store both case in separate variables.\\nDo the same for map2.\\nFinal answer will be case1 + case2/2\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Two maps for nums1 and nums2\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<ll,int> m1, m2;\\n        for(auto i:nums1) m1[i]++;\\n        for(auto i:nums2) m2[i]++;\\n        int ans1 = 0,ans2 = 0;\\n        for(auto i:m1){\\n            ll x1 = i.first*i.first;\\n            int y1 = i.second;\\n            for(auto j:m2){\\n                int x2 = j.first, y2 = j.second;\\n                if(x1%x2 == 0){\\n                    if(x1/x2 == x2) ans1 += y1*(y2*(y2-1))/2;\\n                    else if(m2.find(x1/x2) != m2.end()) ans2 += y1*y2*m2[x1/x2];\\n                }\\n            }\\n            // cout<<i.first<<\" -> \"<<ans1<<\" \";\\n        }\\n        for(auto i:m2){\\n            ll x1 = i.first*i.first;\\n            int y1 = i.second;\\n            for(auto j:m1){\\n                int x2 = j.first, y2 = j.second;\\n                if(x1%x2 == 0){\\n                    if(x1/x2 == x2) ans1 += y1*(y2*(y2-1))/2;\\n                    else if(m1.find(x1/x2) != m1.end()) ans2 += y1*y2*m1[x1/x2];\\n                }\\n            }\\n            // cout<<i.first<<\" -> \"<<ans1<<\" \";\\n        }\\n        return ans1 + ans2/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Counting"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<ll,int> m1, m2;\\n        for(auto i:nums1) m1[i]++;\\n        for(auto i:nums2) m2[i]++;\\n        int ans1 = 0,ans2 = 0;\\n        for(auto i:m1){\\n            ll x1 = i.first*i.first;\\n            int y1 = i.second;\\n            for(auto j:m2){\\n                int x2 = j.first, y2 = j.second;\\n                if(x1%x2 == 0){\\n                    if(x1/x2 == x2) ans1 += y1*(y2*(y2-1))/2;\\n                    else if(m2.find(x1/x2) != m2.end()) ans2 += y1*y2*m2[x1/x2];\\n                }\\n            }\\n            // cout<<i.first<<\" -> \"<<ans1<<\" \";\\n        }\\n        for(auto i:m2){\\n            ll x1 = i.first*i.first;\\n            int y1 = i.second;\\n            for(auto j:m1){\\n                int x2 = j.first, y2 = j.second;\\n                if(x1%x2 == 0){\\n                    if(x1/x2 == x2) ans1 += y1*(y2*(y2-1))/2;\\n                    else if(m1.find(x1/x2) != m1.end()) ans2 += y1*y2*m1[x1/x2];\\n                }\\n            }\\n            // cout<<i.first<<\" -> \"<<ans1<<\" \";\\n        }\\n        return ans1 + ans2/2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2782416,
                "title": "easy-solution-c-beginner-friendly-best-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst thought was like to write three loops . like one to pick the element from first array( int z = arr[i]) then check if the square (z^2) is present in arr2 ( arr[j] * [k]) and so on\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ni am using a map to store the square and then their frquencies . \\nThen iterating over the second array and check if the multiple of 2 ( in arr2 arr2[j]* arr2[k]) is present in the map or not !\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n\\nclass Solution {\\n\\n    private:\\n\\n    int solve( vector<int>& arr1, vector<int>& arr2 ){\\n\\n        int n1 = arr1.size();\\n        int n2 = arr2.size();\\n\\n        int total = 0;\\n\\n        map<long long , long long > mp;\\n\\n        for(int i = 0 ; i < n1 ; i++){\\n            long long ans = (long long)arr1[i]*arr1[i];\\n            mp[ans]++;\\n        }\\n\\n        for(int i = 0 ; i < n2 ; i++){\\n            for(int j = i+1 ; j < n2 ; j++){\\n                long long ans = (long long)arr2[i]*arr2[j];\\n                total+=mp[ans];\\n            }\\n        }\\n\\n        return total;\\n\\n    }\\n    \\npublic:\\n    int numTriplets(vector<int>& arr1, vector<int>& arr2) {\\n        int total = 0;\\n        total+=solve( arr1 , arr2);\\n        total+=solve( arr2 , arr1);\\n        return total;\\n        \\n\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Ordered Map"
                ],
                "code": "class Solution {\\n\\n    private:\\n\\n    int solve( vector<int>& arr1, vector<int>& arr2 ){\\n\\n        int n1 = arr1.size();\\n        int n2 = arr2.size();\\n\\n        int total = 0;\\n\\n        map<long long , long long > mp;\\n\\n        for(int i = 0 ; i < n1 ; i++){\\n            long long ans = (long long)arr1[i]*arr1[i];\\n            mp[ans]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2723277,
                "title": "python-100-faster-o-n-2-check-by-dictionary",
                "content": "![image](https://assets.leetcode.com/users/images/744c1db8-729c-4a4f-b0ef-7c41fcea3d07_1666206032.2742183.png)\\n\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n\\n        dict1, dict2 = {}, {}\\n        \\n        for n in nums1:            \\n            dict1[n] = dict1[n] + 1 if n in dict1 else 1\\n            \\n        for n in nums2:\\n            dict2[n] = dict2[n] + 1 if n in dict2 else 1\\n               \\n        result = 0\\n        \\n        for k in dict1.keys():\\n            k2 = k * k\\n            for m in dict2.keys():\\n                if(k2 % m == 0):\\n                    tmp = k2 / m\\n                    if(tmp in dict2.keys()):\\n                        result += dict1[k] * dict2[m] * dict2[tmp]  if tmp != m else dict2[m] * (dict2[m] - 1) * dict1[k] \\n                        \\n        for k in dict2.keys():\\n            k2 = k * k\\n            for m in dict1.keys():\\n                if(k2 % m == 0):\\n                    tmp = k2 / m\\n                    if(tmp in dict1.keys()):\\n                        result += dict2[k] * dict1[m] * dict1[tmp] if (tmp != m) else dict1[m] * (dict1[m] - 1) * dict2[k]  \\n\\n        return result >> 1",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n\\n        dict1, dict2 = {}",
                "codeTag": "Java"
            },
            {
                "id": 2693874,
                "title": "c",
                "content": "Runtime: 181 ms, faster than 100.00% of C online submissions for Number of Ways Where Square of Number Is Equal to Product of Two Numbers.\\nMemory Usage: 34.5 MB, less than 100.00% of C online submissions for Number of Ways Where Square of Number Is Equal to Product of Two Numbers.\\n```\\nint process(int* nums1, int n1, int* nums2, int n2){\\n    int** hash1 = malloc(n1 * sizeof(int*));\\n\\n    for(int i = 0; i < n1; i++){\\n        hash1[i] = calloc(2 , sizeof(int));\\n    }\\n\\n    int** hash2 = malloc(n2 * sizeof(int*));\\n        \\n    int ans = 0;\\n    for(int i = 0; i < n1; i++){\\n        int a = nums1[i];\\n        int cn = 0;\\n        while(hash1[a % n1][0] != 0){\\n            if(hash1[a % n1][0] == nums1[i]){\\n                cn = hash1[a % n1][1];\\n                goto next;\\n            }\\n            a++;\\n        } \\n        \\n        for(int j = 0; j < n2; j++){\\n            hash2[j] = calloc(2 , sizeof(int));\\n        }\\n        long long k = (long long)nums1[i] * nums1[i];\\n        for(int j = 0; j < n2; j++){\\n            if(k % nums2[j] == 0){\\n                int remain= k/nums2[j];\\n                int b = k/nums2[j];\\n                //find remain in hash2 table\\n                while( hash2[b % n2][0] != 0){\\n                    if(hash2[b % n2][0] == remain){\\n                        cn += hash2[b % n2][1] ;\\n                        break;\\n                    }\\n                    b++;\\n                }\\n                //inset nums2[j] into hash2 table\\n                b = nums2[j];\\n                while(1){\\n                    if(hash2[b % n2][1] == 0){\\n                        hash2[b % n2][0] = nums2[j];\\n                        hash2[b % n2][1] = 1 ;\\n                        break;\\n                    }                    \\n                    if(hash2[b % n2][0] == nums2[j]){\\n                        hash2[b % n2][1]++;\\n                        break;\\n                    }\\n                    b++;\\n                }\\n            }\\n        }\\n\\n        //insert nums1 into hash1 table\\n        hash1[a % n1][0] = nums1[i];\\n        hash1[a % n1][1] = cn;\\n        \\n        next:\\n        ans += cn;\\n\\n    }\\n    \\n    return ans;\\n}\\n\\nint numTriplets(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n\\n\\n    return process(nums1, nums1Size, nums2,nums2Size) + process(nums2, nums2Size, nums1, nums1Size); \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint process(int* nums1, int n1, int* nums2, int n2){\\n    int** hash1 = malloc(n1 * sizeof(int*));\\n\\n    for(int i = 0; i < n1; i++){\\n        hash1[i] = calloc(2 , sizeof(int));\\n    }\\n\\n    int** hash2 = malloc(n2 * sizeof(int*));\\n        \\n    int ans = 0;\\n    for(int i = 0; i < n1; i++){\\n        int a = nums1[i];\\n        int cn = 0;\\n        while(hash1[a % n1][0] != 0){\\n            if(hash1[a % n1][0] == nums1[i]){\\n                cn = hash1[a % n1][1];\\n                goto next;\\n            }\\n            a++;\\n        } \\n        \\n        for(int j = 0; j < n2; j++){\\n            hash2[j] = calloc(2 , sizeof(int));\\n        }\\n        long long k = (long long)nums1[i] * nums1[i];\\n        for(int j = 0; j < n2; j++){\\n            if(k % nums2[j] == 0){\\n                int remain= k/nums2[j];\\n                int b = k/nums2[j];\\n                //find remain in hash2 table\\n                while( hash2[b % n2][0] != 0){\\n                    if(hash2[b % n2][0] == remain){\\n                        cn += hash2[b % n2][1] ;\\n                        break;\\n                    }\\n                    b++;\\n                }\\n                //inset nums2[j] into hash2 table\\n                b = nums2[j];\\n                while(1){\\n                    if(hash2[b % n2][1] == 0){\\n                        hash2[b % n2][0] = nums2[j];\\n                        hash2[b % n2][1] = 1 ;\\n                        break;\\n                    }                    \\n                    if(hash2[b % n2][0] == nums2[j]){\\n                        hash2[b % n2][1]++;\\n                        break;\\n                    }\\n                    b++;\\n                }\\n            }\\n        }\\n\\n        //insert nums1 into hash1 table\\n        hash1[a % n1][0] = nums1[i];\\n        hash1[a % n1][1] = cn;\\n        \\n        next:\\n        ans += cn;\\n\\n    }\\n    \\n    return ans;\\n}\\n\\nint numTriplets(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n\\n\\n    return process(nums1, nums1Size, nums2,nums2Size) + process(nums2, nums2Size, nums1, nums1Size); \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2575647,
                "title": "form-hashmaps-of-squares",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        m = len(nums1)\\n        n = len(nums2)\\n        nums1ctr = Counter([el * el for el in nums1])\\n        nums2ctr = Counter([el * el for el in nums2])\\n        res = 0\\n        for i in range(m):\\n            for j in range(i + 1, m):\\n                res += nums2ctr[nums1[i] * nums1[j]]\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                res += nums1ctr[nums2[i] * nums2[j]]\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        m = len(nums1)\\n        n = len(nums2)\\n        nums1ctr = Counter([el * el for el in nums1])\\n        nums2ctr = Counter([el * el for el in nums2])\\n        res = 0\\n        for i in range(m):\\n            for j in range(i + 1, m):\\n                res += nums2ctr[nums1[i] * nums1[j]]\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                res += nums1ctr[nums2[i] * nums2[j]]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491708,
                "title": "javascript-solution-passed-all-tests-very-simple",
                "content": "I just found this Github repository with solutions to Leetcode problems https://github.com/AnasImloul/Leetcode-solutions\\nIt is very useful, check it out.\\n```\\nvar numTriplets = function(nums1, nums2) {\\n    const nm1 = new Map(), nm2 = new Map();\\n    const n = nums1.length, m = nums2.length;\\n    for(let i = 0; i < n; i++) {\\n        for(let j = i + 1; j < n; j++) {\\n            const product = nums1[i] * nums1[j];\\n            if(!nm1.has(product)) nm1.set(product, 0);\\n            const arr = nm1.get(product);\\n            nm1.set(product, arr + 1);\\n        }\\n    }\\n    for(let i = 0; i < m; i++) {\\n        for(let j = i + 1; j < m; j++) {\\n            const product = nums2[i] * nums2[j];\\n            if(!nm2.has(product)) nm2.set(product, 0);\\n            const arr = nm2.get(product);\\n            nm2.set(product, arr + 1);\\n        }\\n    }\\n    let ans = 0;\\n    \\n    for(let num of nums1) {\\n        const sq = num * num;\\n        if(nm2.has(sq)) {\\n            ans += nm2.get(sq);\\n        }\\n    }\\n    for(let num of nums2) {\\n        const sq = num * num;\\n        if(nm1.has(sq)) {\\n            ans += nm1.get(sq);\\n        }\\n    }\\n    return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numTriplets = function(nums1, nums2) {\\n    const nm1 = new Map(), nm2 = new Map();\\n    const n = nums1.length, m = nums2.length;\\n    for(let i = 0; i < n; i++) {\\n        for(let j = i + 1; j < n; j++) {\\n            const product = nums1[i] * nums1[j];\\n            if(!nm1.has(product)) nm1.set(product, 0);\\n            const arr = nm1.get(product);\\n            nm1.set(product, arr + 1);\\n        }\\n    }\\n    for(let i = 0; i < m; i++) {\\n        for(let j = i + 1; j < m; j++) {\\n            const product = nums2[i] * nums2[j];\\n            if(!nm2.has(product)) nm2.set(product, 0);\\n            const arr = nm2.get(product);\\n            nm2.set(product, arr + 1);\\n        }\\n    }\\n    let ans = 0;\\n    \\n    for(let num of nums1) {\\n        const sq = num * num;\\n        if(nm2.has(sq)) {\\n            ans += nm2.get(sq);\\n        }\\n    }\\n    for(let num of nums2) {\\n        const sq = num * num;\\n        if(nm1.has(sq)) {\\n            ans += nm1.get(sq);\\n        }\\n    }\\n    return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2468458,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0;\\n        unordered_map<long,int> l1,l2;\\n        \\n        for(auto n:nums1) l1[(long)n*(long)n]++;\\n        for(auto n:nums2) l2[(long)n*(long)n]++;\\n        \\n        for(int i=0; i<nums1.size(); i++)\\n        {\\n            for(int j=i+1; j<nums1.size(); j++)\\n            {\\n                ans += l2[(long)nums1[i]*(long)nums1[j]];\\n            }\\n        }\\n        for(int i=0; i<nums2.size(); i++)\\n        {\\n            for(int j=i+1; j<nums2.size(); j++)\\n            {\\n                ans += l1[((long)nums2[i]*(long)nums2[j])];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0;\\n        unordered_map<long,int> l1,l2;\\n        \\n        for(auto n:nums1) l1[(long)n*(long)n]++;\\n        for(auto n:nums2) l2[(long)n*(long)n]++;\\n        \\n        for(int i=0; i<nums1.size(); i++)\\n        {\\n            for(int j=i+1; j<nums1.size(); j++)\\n            {\\n                ans += l2[(long)nums1[i]*(long)nums1[j]];\\n            }\\n        }\\n        for(int i=0; i<nums2.size(); i++)\\n        {\\n            for(int j=i+1; j<nums2.size(); j++)\\n            {\\n                ans += l1[((long)nums2[i]*(long)nums2[j])];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337336,
                "title": "javascript-easy-to-understand",
                "content": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar numTriplets = function(nums1, nums2) {\\n    // construct two empty dictionaries to store all the multiplication numbers\\n    const nums1Dict = {};\\n    const nums2Dict = {};\\n    \\n    // Go over the first set and multiply each number by the other numbers\\n    for(let i=0;i<nums1.length;i++){\\n        for(let j=i+1; j<nums1.length; j++){\\n            const res = nums1[i] * nums1[j];\\n            if(!nums1Dict[res]) nums1Dict[res] = 1;\\n            else nums1Dict[res] += 1;\\n        }\\n    }\\n    \\n    // Go over the second set and multiply each number by the other numbers\\n    for(let i=0;i<nums2.length;i++){\\n        for(let j=i+1; j<nums2.length; j++){\\n            const res = nums2[i] * nums2[j];\\n            if(!nums2Dict[res]) nums2Dict[res] = 1;\\n            else nums2Dict[res] += 1;\\n        }\\n    }\\n    \\n    let total = 0;\\n    \\n    // Go over the first set again and check if the item sq in nums2 multiplication dictionary\\n    nums1.forEach((item)=>{\\n        nums2Dict[item * item] ? total += nums2Dict[item * item]  : total;\\n    });\\n    \\n    // Go over the second set again and check if the item sq in nums1 multiplication dictionary    \\n    nums2.forEach((item)=>{\\n        nums1Dict[item * item] ? total += nums1Dict[item * item]  : total;\\n    });\\n    \\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar numTriplets = function(nums1, nums2) {\\n    // construct two empty dictionaries to store all the multiplication numbers\\n    const nums1Dict = {};\\n    const nums2Dict = {};\\n    \\n    // Go over the first set and multiply each number by the other numbers\\n    for(let i=0;i<nums1.length;i++){\\n        for(let j=i+1; j<nums1.length; j++){\\n            const res = nums1[i] * nums1[j];\\n            if(!nums1Dict[res]) nums1Dict[res] = 1;\\n            else nums1Dict[res] += 1;\\n        }\\n    }\\n    \\n    // Go over the second set and multiply each number by the other numbers\\n    for(let i=0;i<nums2.length;i++){\\n        for(let j=i+1; j<nums2.length; j++){\\n            const res = nums2[i] * nums2[j];\\n            if(!nums2Dict[res]) nums2Dict[res] = 1;\\n            else nums2Dict[res] += 1;\\n        }\\n    }\\n    \\n    let total = 0;\\n    \\n    // Go over the first set again and check if the item sq in nums2 multiplication dictionary\\n    nums1.forEach((item)=>{\\n        nums2Dict[item * item] ? total += nums2Dict[item * item]  : total;\\n    });\\n    \\n    // Go over the second set again and check if the item sq in nums1 multiplication dictionary    \\n    nums2.forEach((item)=>{\\n        nums1Dict[item * item] ? total += nums1Dict[item * item]  : total;\\n    });\\n    \\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2330645,
                "title": "intuitive-just-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long long, int> cnt1;\\n        unordered_map<long long, int> cnt2;\\n        \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            for (int j = i + 1; j < nums1.size(); ++j) {\\n                cnt1[1LL * nums1[i] * nums1[j]]++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums2.size(); ++i) {\\n            for (int j = i + 1; j < nums2.size(); ++j) {\\n                cnt2[1LL * nums2[i] * nums2[j]]++;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (auto n : nums1) {\\n            res += cnt2[1LL * n * n];\\n        }\\n        \\n        for (auto n : nums2) {\\n            res += cnt1[1LL * n * n];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long long, int> cnt1;\\n        unordered_map<long long, int> cnt2;\\n        \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            for (int j = i + 1; j < nums1.size(); ++j) {\\n                cnt1[1LL * nums1[i] * nums1[j]]++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums2.size(); ++i) {\\n            for (int j = i + 1; j < nums2.size(); ++j) {\\n                cnt2[1LL * nums2[i] * nums2[j]]++;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (auto n : nums1) {\\n            res += cnt2[1LL * n * n];\\n        }\\n        \\n        for (auto n : nums2) {\\n            res += cnt1[1LL * n * n];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325781,
                "title": "simple-python-solution-using-dictionary",
                "content": "The idea is to:\\n1. Create a helper function that takes 2 sets of numbers.\\n2. Within this helper funtion: Go through the first set of numbers and store the squares of each number along with the count of \\'how many times you see the same square\\'. \\n**Note:** This count is important for cases like [1,1] &[1,1,1], where different indexes give you the same sqrs. If you don\\'t keep a count of repeated sqrs, you would get 4 instead of 9 for this example. We are required to find the different combinations of indexes, not the different pairs of products and matching sqrs.\\n2. Go through the second set of numbers and see if the products of two numbers (at diff indexes) have a product that\\'s already in the dictionary keys we created above.\\n3. If there\\'s a key that matches, we have the corresponding number (value) of combinations for that product. Add that to the output.\\n4. Feed the helper function both the lists interchangably. Return the sum of their return values.\\n\\n\\n```\\n\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        def cases(n1, n2):\\n            op = 0\\n            sqs = defaultdict(int)\\n            for i in range(len(n1)):\\n                sqs[n1[i] * n1[i]] += 1\\n            for j in range(len(n2) - 1):\\n                for k in range(j + 1, len(n2)):\\n                    if n2[j] * n2[k] in sqs.keys():\\n                        op += sqs[n2[j] * n2[k]]\\n            return op\\n        \\n        return cases(nums1, nums2) + cases(nums2, nums1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "The idea is to:\\n1. Create a helper function that takes 2 sets of numbers.\\n2. Within this helper funtion: Go through the first set of numbers and store the squares of each number along with the count of \\'how many times you see the same square\\'. \\n**Note:** This count is important for cases like [1,1] &[1,1,1], where different indexes give you the same sqrs. If you don\\'t keep a count of repeated sqrs, you would get 4 instead of 9 for this example. We are required to find the different combinations of indexes, not the different pairs of products and matching sqrs.\\n2. Go through the second set of numbers and see if the products of two numbers (at diff indexes) have a product that\\'s already in the dictionary keys we created above.\\n3. If there\\'s a key that matches, we have the corresponding number (value) of combinations for that product. Add that to the output.\\n4. Feed the helper function both the lists interchangably. Return the sum of their return values.\\n\\n\\n```\\n\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        def cases(n1, n2):\\n            op = 0\\n            sqs = defaultdict(int)\\n            for i in range(len(n1)):\\n                sqs[n1[i] * n1[i]] += 1\\n            for j in range(len(n2) - 1):\\n                for k in range(j + 1, len(n2)):\\n                    if n2[j] * n2[k] in sqs.keys():\\n                        op += sqs[n2[j] * n2[k]]\\n            return op\\n        \\n        return cases(nums1, nums2) + cases(nums2, nums1)",
                "codeTag": "Python3"
            },
            {
                "id": 2254504,
                "title": "c-store-count-of-products",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    int solve(vector<int>&nums1 , vector<int>&nums2 ){\\n        unordered_map<ll,ll> mpp ;\\n        \\n        for(int i = 0 ; i < nums2.size() ; ++i)\\n            for(int j = i + 1 ; j < nums2.size() ; ++j)\\n                ++mpp[nums2[i] * 1LL *  nums2[j] * 1LL] ; \\n        int ans = 0 ;\\n        for(int i = 0 ; i < nums1.size() ; ++i ) ans += mpp[nums1[i] * 1LL  * nums1[i] * 1LL] ;\\n        return ans ;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return solve(nums1,nums2) + solve(nums2,nums1) ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    int solve(vector<int>&nums1 , vector<int>&nums2 ){\\n        unordered_map<ll,ll> mpp ;\\n        \\n        for(int i = 0 ; i < nums2.size() ; ++i)\\n            for(int j = i + 1 ; j < nums2.size() ; ++j)\\n                ++mpp[nums2[i] * 1LL *  nums2[j] * 1LL] ; \\n        int ans = 0 ;\\n        for(int i = 0 ; i < nums1.size() ; ++i ) ans += mpp[nums1[i] * 1LL  * nums1[i] * 1LL] ;\\n        return ans ;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return solve(nums1,nums2) + solve(nums2,nums1) ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248334,
                "title": "js",
                "content": "```\\nvar numTriplets = function (nums1, nums2) {\\n\\tconst squares = [],\\n\\t\\taddSquares = arr => {\\n\\t\\t\\tconst sqFreq = {};\\n\\t\\t\\tlet sq;\\n\\t\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\t\\tsq = arr[i] ** 2;\\n\\t\\t\\t\\tsqFreq[sq] ? sqFreq[sq]++ : (sqFreq[sq] = 1);\\n\\t\\t\\t}\\n\\t\\t\\treturn sqFreq;\\n\\t\\t},\\n\\t\\tgetMultiplications = type => {\\n\\t\\t\\tconst arr = type ? nums1 : nums2,\\n\\t\\t\\t\\tsqFreq = squares[type];\\n\\t\\t\\tlet count = 0,\\n\\t\\t\\t\\tm;\\n\\t\\t\\tfor (let i = 0; i < arr.length; i++)\\n\\t\\t\\t\\tfor (let j = i + 1; j < arr.length; j++) {\\n\\t\\t\\t\\t\\tm = arr[i] * arr[j];\\n\\t\\t\\t\\t\\tsqFreq[m] && (count += sqFreq[m]);\\n\\t\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t};\\n\\tsquares.push(addSquares(nums1), addSquares(nums2));\\n\\treturn getMultiplications(0) + getMultiplications(1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numTriplets = function (nums1, nums2) {\\n\\tconst squares = [],\\n\\t\\taddSquares = arr => {\\n\\t\\t\\tconst sqFreq = {};\\n\\t\\t\\tlet sq;\\n\\t\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\t\\tsq = arr[i] ** 2;\\n\\t\\t\\t\\tsqFreq[sq] ? sqFreq[sq]++ : (sqFreq[sq] = 1);\\n\\t\\t\\t}\\n\\t\\t\\treturn sqFreq;\\n\\t\\t},\\n\\t\\tgetMultiplications = type => {\\n\\t\\t\\tconst arr = type ? nums1 : nums2,\\n\\t\\t\\t\\tsqFreq = squares[type];\\n\\t\\t\\tlet count = 0,\\n\\t\\t\\t\\tm;\\n\\t\\t\\tfor (let i = 0; i < arr.length; i++)\\n\\t\\t\\t\\tfor (let j = i + 1; j < arr.length; j++) {\\n\\t\\t\\t\\t\\tm = arr[i] * arr[j];\\n\\t\\t\\t\\t\\tsqFreq[m] && (count += sqFreq[m]);\\n\\t\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t};\\n\\tsquares.push(addSquares(nums1), addSquares(nums2));\\n\\treturn getMultiplications(0) + getMultiplications(1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2233322,
                "title": "easy-js-solution",
                "content": "```\\nvar numTriplets = function(nums1, nums2) {\\n    const nm1 = new Map(), nm2 = new Map();\\n    const n = nums1.length, m = nums2.length;\\n    for(let i = 0; i < n; i++) {\\n        for(let j = i + 1; j < n; j++) {\\n            const product = nums1[i] * nums1[j];\\n            if(!nm1.has(product)) nm1.set(product, 0);\\n            const arr = nm1.get(product);\\n            nm1.set(product, arr + 1);\\n        }\\n    }\\n    for(let i = 0; i < m; i++) {\\n        for(let j = i + 1; j < m; j++) {\\n            const product = nums2[i] * nums2[j];\\n            if(!nm2.has(product)) nm2.set(product, 0);\\n            const arr = nm2.get(product);\\n            nm2.set(product, arr + 1);\\n        }\\n    }\\n    let ans = 0;\\n    \\n    for(let num of nums1) {\\n        const sq = num * num;\\n        if(nm2.has(sq)) {\\n            ans += nm2.get(sq);\\n        }\\n    }\\n    for(let num of nums2) {\\n        const sq = num * num;\\n        if(nm1.has(sq)) {\\n            ans += nm1.get(sq);\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numTriplets = function(nums1, nums2) {\\n    const nm1 = new Map(), nm2 = new Map();\\n    const n = nums1.length, m = nums2.length;\\n    for(let i = 0; i < n; i++) {\\n        for(let j = i + 1; j < n; j++) {\\n            const product = nums1[i] * nums1[j];\\n            if(!nm1.has(product)) nm1.set(product, 0);\\n            const arr = nm1.get(product);\\n            nm1.set(product, arr + 1);\\n        }\\n    }\\n    for(let i = 0; i < m; i++) {\\n        for(let j = i + 1; j < m; j++) {\\n            const product = nums2[i] * nums2[j];\\n            if(!nm2.has(product)) nm2.set(product, 0);\\n            const arr = nm2.get(product);\\n            nm2.set(product, arr + 1);\\n        }\\n    }\\n    let ans = 0;\\n    \\n    for(let num of nums1) {\\n        const sq = num * num;\\n        if(nm2.has(sq)) {\\n            ans += nm2.get(sq);\\n        }\\n    }\\n    for(let num of nums2) {\\n        const sq = num * num;\\n        if(nm1.has(sq)) {\\n            ans += nm1.get(sq);\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2219792,
                "title": "python-3-using-dictionaries-and-calculating-the-freq",
                "content": "```\\n\\n```class Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n    count = 0\\n    precalnums1sq = []\\n    precalnums2sq = []\\n    precaltype1 = {}\\n    precaltype2 = {}\\n    # precalulate the freqs of type 1\\n    for i in range(len(nums1)):\\n        precalnums1sq.append(nums1[i] ** 2)\\n\\n    # these series of for loops will find the type1\\n    for j in range(len(nums2)):\\n        for k in range(j + 1, len(nums2)):\\n            key = nums2[j] * nums2[k]\\n            if key in precaltype1:\\n                precaltype1[key] = precaltype1.get(key) + 1\\n            else:\\n                precaltype1[key] = 1\\n\\n        # precalculate the freq of type2\\n\\n    for i in range(len(nums2)):\\n        precalnums2sq.append(nums2[i] ** 2)\\n\\n        # these series of for loops will find the type2\\n    for j in range(len(nums1)):\\n        for k in range(j + 1, len(nums1)):\\n            key = nums1[j] * nums1[k]\\n            if key in precaltype2:\\n                precaltype2[key] = precaltype2.get(key) + 1\\n            else:\\n                precaltype2[key] = 1\\n\\n    for source in precalnums1sq:\\n        if source in precaltype1:\\n            count += precaltype1[source]\\n\\n    for source in precalnums2sq:\\n        if source in precaltype2:\\n            count += precaltype2[source]\\n    return count``\\n",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2207357,
                "title": "c-easy-to-understand-unordered-map-solution",
                "content": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        unordered_map <ll, int> n1_sq, n2_sq, n1_pro, n2_pro;\\n\\n        //building n1_sq\\n        for(int i=0; i<nums1.size(); i++)\\n            n1_sq[((ll)nums1[i]) *((ll)nums1[i])] ++;\\n\\n        //building n2_sq\\n        for(int i=0; i<nums2.size(); i++)\\n            n2_sq[((ll)nums2[i]) *((ll)nums2[i])] ++;\\n\\n        //bulding n1_pro\\n        for(int j=0; j<nums1.size(); j++)\\n            for(int k=j+1; k<nums1.size(); k++) {\\n                n1_pro[((ll)nums1[j])*((ll)nums1[k])]++;\\n            }\\n\\n        //bulding n2_pro\\n        for(int j=0; j<nums2.size(); j++)\\n            for(int k=j+1; k<nums2.size(); k++) {\\n                n2_pro[((ll)nums2[j])*((ll)nums2[k])]++;\\n            }\\n        \\n        for(auto x : n2_pro)\\n            if(n1_sq[x.first])\\n                ans+=(x.second*n1_sq[x.first]);\\n\\n        for(auto x : n1_pro)\\n            if(n2_sq[x.first])\\n                ans+=(x.second*n2_sq[x.first]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        unordered_map <ll, int> n1_sq, n2_sq, n1_pro, n2_pro;\\n\\n        //building n1_sq\\n        for(int i=0; i<nums1.size(); i++)\\n            n1_sq[((ll)nums1[i]) *((ll)nums1[i])] ++;\\n\\n        //building n2_sq\\n        for(int i=0; i<nums2.size(); i++)\\n            n2_sq[((ll)nums2[i]) *((ll)nums2[i])] ++;\\n\\n        //bulding n1_pro\\n        for(int j=0; j<nums1.size(); j++)\\n            for(int k=j+1; k<nums1.size(); k++) {\\n                n1_pro[((ll)nums1[j])*((ll)nums1[k])]++;\\n            }\\n\\n        //bulding n2_pro\\n        for(int j=0; j<nums2.size(); j++)\\n            for(int k=j+1; k<nums2.size(); k++) {\\n                n2_pro[((ll)nums2[j])*((ll)nums2[k])]++;\\n            }\\n        \\n        for(auto x : n2_pro)\\n            if(n1_sq[x.first])\\n                ans+=(x.second*n1_sq[x.first]);\\n\\n        for(auto x : n1_pro)\\n            if(n2_sq[x.first])\\n                ans+=(x.second*n2_sq[x.first]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194431,
                "title": "two-sum-appraoch-map-c",
                "content": "```\\nint numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<long,int> m1,m2;  //m1 used for tyoe 1 and m2 used for type 2\\n        int ans=0;\\n        \\n        //Filling m1 for checking type 1\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            for(int j=i+1;j<nums2.size();j++)\\n            {\\n                long l=nums2[i];\\n                m1[l*nums2[j]]++;\\n            }\\n        }\\n        \\n        //Filling m2 for checking type 2\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=i+1;j<nums1.size();j++)\\n            {\\n                long l=nums1[i];\\n                m2[l*nums1[j]]++;\\n            }\\n        }\\n        \\n        //Checking no of answers for type 1\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            long l=nums1[i];\\n            l*=nums1[i];\\n            \\n            ans+=m1[l];\\n        }\\n        \\n         //Checking no of answers for type 1\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            long l=nums2[i];\\n            l*=nums2[i];\\n            \\n            ans+=m2[l];\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nint numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<long,int> m1,m2;  //m1 used for tyoe 1 and m2 used for type 2\\n        int ans=0;\\n        \\n        //Filling m1 for checking type 1\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            for(int j=i+1;j<nums2.size();j++)\\n            {\\n                long l=nums2[i];\\n                m1[l*nums2[j]]++;\\n            }\\n        }\\n        \\n        //Filling m2 for checking type 2\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=i+1;j<nums1.size();j++)\\n            {\\n                long l=nums1[i];\\n                m2[l*nums1[j]]++;\\n            }\\n        }\\n        \\n        //Checking no of answers for type 1\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            long l=nums1[i];\\n            l*=nums1[i];\\n            \\n            ans+=m1[l];\\n        }\\n        \\n         //Checking no of answers for type 1\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            long l=nums2[i];\\n            l*=nums2[i];\\n            \\n            ans+=m2[l];\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2137513,
                "title": "c-easy-understanding-hashmap",
                "content": "```\\nusing ll=long long int ;\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        int m=nums2.size();\\n        map<ll,ll> mp;\\n      \\n        int ct=0;\\n        for(int i=0;i<n;i++){\\n            ll ele=(ll)nums1[i]*(ll)nums1[i];\\n            mp.clear();\\n            for(int j=0;j<m;j++){\\n                if((ele%nums2[j])==0){\\n                   if(mp.count(ele/nums2[j])){\\n                       ct+=mp[ele/nums2[j]];\\n                   }\\n                }\\n                mp[nums2[j]]++;\\n            }\\n        }\\n        mp.clear();\\n       \\n        for(int i=0;i<m;i++){\\n            ll ele=(ll)nums2[i]*(ll)nums2[i];\\n            mp.clear();\\n            for(int j=0;j<n;j++){\\n                if((ele%nums1[j])==0){\\n                    if(mp.count(ele/nums1[j])){\\n                        ct+=mp[ele/nums1[j]];\\n                    }\\n                }\\n                mp[nums1[j]]++;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing ll=long long int ;\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        int m=nums2.size();\\n        map<ll,ll> mp;\\n      \\n        int ct=0;\\n        for(int i=0;i<n;i++){\\n            ll ele=(ll)nums1[i]*(ll)nums1[i];\\n            mp.clear();\\n            for(int j=0;j<m;j++){\\n                if((ele%nums2[j])==0){\\n                   if(mp.count(ele/nums2[j])){\\n                       ct+=mp[ele/nums2[j]];\\n                   }\\n                }\\n                mp[nums2[j]]++;\\n            }\\n        }\\n        mp.clear();\\n       \\n        for(int i=0;i<m;i++){\\n            ll ele=(ll)nums2[i]*(ll)nums2[i];\\n            mp.clear();\\n            for(int j=0;j<n;j++){\\n                if((ele%nums1[j])==0){\\n                    if(mp.count(ele/nums1[j])){\\n                        ct+=mp[ele/nums1[j]];\\n                    }\\n                }\\n                mp[nums1[j]]++;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2135421,
                "title": "need-help",
                "content": "```\\ngiving wrong answer for below test case i am unable to figure out where its going wrong ,did dry run thrice \\n\\n[13,4,70,76,11,94,63,86,91,96,2,53,65,14,75,75,13,23,76,96,91,32,55,36,52,32,97,11,48,91,98,36,28,87,24,22,72,89,5,55,35,3,336]\\n[6,96,88,98,78,76,41,81,100,26,89,8,42,28,85,47,74,79,43,69,99,98,86,51,49,60,12,26,21,29,78,84,27,12,31,86,76,69,31,5,40,59]\\n\\nOutput:\\n29\\nExpected:\\n30\\n```\\n```\\nint solution(vector<int>& nums1, vector<int>& nums2){\\n        int count = 0;\\n        for(int i = 0; i<nums1.size(); ++i){\\n            for(int j = 0; j<nums2.size()-1; ++j){\\n                for(int k = j+1; k<nums2.size(); ++k){\\n                    if(nums1[i] == ((double)nums2[j]/nums1[i])*nums2[k]){\\n                        ++count;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return solution(nums1, nums2) + solution(nums2, nums1);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ngiving wrong answer for below test case i am unable to figure out where its going wrong ,did dry run thrice \\n\\n[13,4,70,76,11,94,63,86,91,96,2,53,65,14,75,75,13,23,76,96,91,32,55,36,52,32,97,11,48,91,98,36,28,87,24,22,72,89,5,55,35,3,336]\\n[6,96,88,98,78,76,41,81,100,26,89,8,42,28,85,47,74,79,43,69,99,98,86,51,49,60,12,26,21,29,78,84,27,12,31,86,76,69,31,5,40,59]\\n\\nOutput:\\n29\\nExpected:\\n30\\n```\n```\\nint solution(vector<int>& nums1, vector<int>& nums2){\\n        int count = 0;\\n        for(int i = 0; i<nums1.size(); ++i){\\n            for(int j = 0; j<nums2.size()-1; ++j){\\n                for(int k = j+1; k<nums2.size(); ++k){\\n                    if(nums1[i] == ((double)nums2[j]/nums1[i])*nums2[k]){\\n                        ++count;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return solution(nums1, nums2) + solution(nums2, nums1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2124011,
                "title": "python2-solution-which-beats-100",
                "content": "Use dictionary, and check keys in ascending order.\\n\\n```\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n\\t\\n\\t\\td1, d2 = Counter(nums1), Counter(nums2)\\n        \\n        ret = 0\\n        key1 = sorted(d1.keys())\\n        key2 = sorted(d2.keys())\\n\\t\\t\\n\\t\\t# Type 1\\n        for k1 in key1:\\n            kk = k1 * k1\\n            for k2 in key2:\\n                if k2 > k1: break\\n                if k2 == k1:\\n                    if d2[k2] < 2: break\\n                    ret += d1[k1] * d2[k2] * (d2[k2] - 1)/2\\n                elif kk % k2 == 0 and d2[kk/k2] > 0:\\n                    ret += d1[k1] * d2[k2] * d2[kk/k2]\\n                    \\n\\t\\t# Type 2\\n        for k2 in key2:\\n            kk = k2 * k2\\n            for k1 in key1:\\n                if k1 > k2: break\\n                if k1 == k2:\\n                    if d1[k1] < 2: break\\n                    ret += d2[k2] * d1[k1] * (d1[k1] - 1)/2\\n                elif kk % k1 == 0 and d1[kk/k1] > 0:\\n                    ret += d2[k2] * d1[k1] * d1[kk/k1]\\n                    \\n        return ret\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n\\t\\n\\t\\td1, d2 = Counter(nums1), Counter(nums2)\\n        \\n        ret = 0\\n        key1 = sorted(d1.keys())\\n        key2 = sorted(d2.keys())\\n\\t\\t\\n\\t\\t# Type 1\\n        for k1 in key1:\\n            kk = k1 * k1\\n            for k2 in key2:\\n                if k2 > k1: break\\n                if k2 == k1:\\n                    if d2[k2] < 2: break\\n                    ret += d1[k1] * d2[k2] * (d2[k2] - 1)/2\\n                elif kk % k2 == 0 and d2[kk/k2] > 0:\\n                    ret += d1[k1] * d2[k2] * d2[kk/k2]\\n                    \\n\\t\\t# Type 2\\n        for k2 in key2:\\n            kk = k2 * k2\\n            for k1 in key1:\\n                if k1 > k2: break\\n                if k1 == k2:\\n                    if d1[k1] < 2: break\\n                    ret += d2[k2] * d1[k1] * (d1[k1] - 1)/2\\n                elif kk % k1 == 0 and d1[kk/k1] > 0:\\n                    ret += d2[k2] * d1[k1] * d1[kk/k1]\\n                    \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102584,
                "title": "c-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    #define li long long int\\n    int findT(vector<int>& n1, vector<int>& n2){\\n        unordered_map<li,int>mp;\\n        int c=0;\\n        for(auto&i:n1)mp[(li)i*i]++;\\n        for(int j=0;j<size(n2);++j)\\n            for(int k=j+1;k<size(n2);++k)c+=mp[(li)n2[j]*n2[k]];\\n        return c;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int c=findT(nums1,nums2);\\n        c+=findT(nums2,nums1);\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define li long long int\\n    int findT(vector<int>& n1, vector<int>& n2){\\n        unordered_map<li,int>mp;\\n        int c=0;\\n        for(auto&i:n1)mp[(li)i*i]++;\\n        for(int j=0;j<size(n2);++j)\\n            for(int k=j+1;k<size(n2);++k)c+=mp[(li)n2[j]*n2[k]];\\n        return c;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int c=findT(nums1,nums2);\\n        c+=findT(nums2,nums1);\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997087,
                "title": "easy-nothing-is-crazy-here-only-simplicity",
                "content": "\\ttypedef long long int lli;\\n\\n\\n\\tclass Solution {\\n    \\n    int helper(vector<int> &nums1,vector<int> &nums2)\\n    {\\n        \\n        unordered_map<lli,int> hash;\\n        \\n        int n=nums2.size();\\n        \\n        for(int i=0;i<n;i++)\\n            for(int j=i+1;j<n;j++)\\n                hash[(lli)(nums2[i])*(lli)(nums2[j])]++;\\n        \\n        int res=0;\\n        \\n        for(lli x:nums1)\\n            res+=hash[x*x];\\n        \\n        return res;\\n    }\\n    \\n\\tpublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int res=0;\\n        \\n        res+=helper(nums1,nums2);     \\n        res+=helper(nums2,nums1);\\n        \\n        return res;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    int helper(vector<int> &nums1,vector<int> &nums2)\\n    {\\n        \\n        unordered_map<lli,int> hash;\\n        \\n        int n=nums2.size();\\n        \\n        for(int i=0;i<n;i++)\\n            for(int j=i+1;j<n;j++)\\n                hash[(lli)(nums2[i])*(lli)(nums2[j])]++;\\n        \\n        int res=0;\\n        \\n        for(lli x:nums1)\\n            res+=hash[x*x];\\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1913072,
                "title": "cpp-best-solution-beats-100-percent-online-submissions-hashing",
                "content": "class Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int ,int>m;\\n         unordered_map<int ,int>m1;\\n        int ans =0;\\n        int ans1 =0;\\n        for(int i =0;i<nums2.size();i++){\\n            m[nums2[i]]++;\\n        }\\n         for(int i =0;i<nums1.size();i++){\\n            m1[nums1[i]]++;\\n        }\\n      \\n        for(int i =0;i<nums1.size();i++){\\n            long long target =nums1[i]*1LL*nums1[i];\\n        \\n            for(auto x:m){\\n              \\n                if(target%x.first==0 && x.first!=nums1[i]){\\n                  \\n                    if(m.find(target/x.first)!=m.end()){\\n                    ans+=(m[target/x.first]*x.second);\\n                    }\\n                }\\n                   if(target%x.first==0 && x.first==nums1[i]){\\n                   \\n                    ans+=x.second*(x.second-1);\\n                }\\n                \\n            }\\n            \\n          \\n        }\\n        \\n        ans=ans/2;\\n  \\n             for(int i =0;i<nums2.size();i++){\\n            long long target =nums2[i]*1LL*nums2[i];\\n          for(auto x:m1){\\n                if(target%x.first==0 && x.first!=nums2[i]){\\n                    if(m1.find(target/x.first)!=m1.end()){\\n                    ans1+=m1[target/x.first]*x.second;\\n                    }\\n                }\\n                  else if(target%x.first==0 && x.first==nums2[i]){\\n                    ans1+=x.second*(x.second-1);\\n                }\\n                \\n            }\\n        }\\n      \\n        ans1=ans1/2;\\n      \\n        return ans+ans1;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int ,int>m;\\n         unordered_map<int ,int>m1;\\n        int ans =0;\\n        int ans1 =0;\\n        for(int i =0;i<nums2.size();i++){\\n            m[nums2[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1882680,
                "title": "java-solution",
                "content": "```\\npublic int numTriplets(int[] nums1, int[] nums2) {\\n        return getCount(nums1, nums2) + getCount(nums2, nums1);\\n    }\\n\\n    private int getCount(int[] nums1, int[] nums2) {\\n\\n        int res = 0;\\n        for (int j : nums1) {\\n\\n            final long sqr = (long) j * (long) j; // as range is 10^5\\n            final Map<Long, Long> map = new HashMap<>();\\n\\n            for (final int value : nums2) {\\n                if (sqr % (long) value == 0) {\\n                    res += map.getOrDefault(sqr / (long) value, 0L);\\n                    // if divisible store in map so that next time we can pull count\\n                    map.compute((long) value, (k, v) -> v == null ? 1L : 1L + v);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numTriplets(int[] nums1, int[] nums2) {\\n        return getCount(nums1, nums2) + getCount(nums2, nums1);\\n    }\\n\\n    private int getCount(int[] nums1, int[] nums2) {\\n\\n        int res = 0;\\n        for (int j : nums1) {\\n\\n            final long sqr = (long) j * (long) j; // as range is 10^5\\n            final Map<Long, Long> map = new HashMap<>();\\n\\n            for (final int value : nums2) {\\n                if (sqr % (long) value == 0) {\\n                    res += map.getOrDefault(sqr / (long) value, 0L);\\n                    // if divisible store in map so that next time we can pull count\\n                    map.compute((long) value, (k, v) -> v == null ? 1L : 1L + v);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1880784,
                "title": "easy-to-understand-map-solution",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        result=0\\n        nums_1_products={}\\n        nums_2_products={}\\n\\n        def prod_dict_generation(input_list,prod_dict):\\n            for i in range(len(input_list)-1):\\n                for j in range(i+1,len(input_list)):\\n                    prod=input_list[i]*input_list[j]\\n                    if prod in prod_dict:\\n                        prod_dict[prod]+=1\\n                    else:\\n                        prod_dict[prod]=1\\n\\n        prod_dict_generation(nums1,nums_1_products)\\n        prod_dict_generation(nums2,nums_2_products)\\n\\n        for num in nums1:\\n            if num*num in nums_2_products:\\n                result+= nums_2_products[num*num]\\n\\n        for num in nums2:\\n            if num*num in nums_1_products:\\n                result+= nums_1_products[num*num]\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        result=0\\n        nums_1_products={}\\n        nums_2_products={}\\n\\n        def prod_dict_generation(input_list,prod_dict):\\n            for i in range(len(input_list)-1):\\n                for j in range(i+1,len(input_list)):\\n                    prod=input_list[i]*input_list[j]\\n                    if prod in prod_dict:\\n                        prod_dict[prod]+=1\\n                    else:\\n                        prod_dict[prod]=1\\n\\n        prod_dict_generation(nums1,nums_1_products)\\n        prod_dict_generation(nums2,nums_2_products)\\n\\n        for num in nums1:\\n            if num*num in nums_2_products:\\n                result+= nums_2_products[num*num]\\n\\n        for num in nums2:\\n            if num*num in nums_1_products:\\n                result+= nums_1_products[num*num]\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855285,
                "title": "fast-clear-java-solution",
                "content": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        return numTriplets1(nums1, nums2) + numTriplets1(nums2, nums1);\\n    }\\n\\n    int numTriplets1(int[] nums1, int[] nums2) {\\n        int cnt = 0;\\n        for (int n : nums1) {\\n            long nn = (long) n * n;\\n            for (int i = 0, j = nums2.length-1; i < j;) {\\n                long ij = (long) nums2[i] * nums2[j];\\n                if (ij == nn) {\\n                    if (nums2[i] == nums2[j]) {\\n                        cnt += (j - i + 1) * (j - i) / 2;\\n                        break;\\n                    } else {\\n                        int ci = 1;\\n                        while (nums2[i] == nums2[++i]) {\\n                            ++ci;\\n                        }\\n                        int cj = 1;\\n                        while (nums2[j] == nums2[--j]) {\\n                            ++cj;\\n                        }\\n                        cnt += ci * cj;\\n                    }\\n                } else if (ij < nn) {\\n                    ++i;\\n                } else {\\n                    --j;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}```",
                "solutionTags": [
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        return numTriplets1(nums1, nums2) + numTriplets1(nums2, nums1);\\n    }\\n\\n    int numTriplets1(int[] nums1, int[] nums2) {\\n        int cnt = 0;\\n        for (int n : nums1) {\\n            long nn = (long) n * n;\\n            for (int i = 0, j = nums2.length-1; i < j;) {\\n                long ij = (long) nums2[i] * nums2[j];\\n                if (ij == nn) {\\n                    if (nums2[i] == nums2[j]) {\\n                        cnt += (j - i + 1) * (j - i) / 2;\\n                        break;\\n                    } else {\\n                        int ci = 1;\\n                        while (nums2[i] == nums2[++i]) {\\n                            ++ci;\\n                        }\\n                        int cj = 1;\\n                        while (nums2[j] == nums2[--j]) {\\n                            ++cj;\\n                        }\\n                        cnt += ci * cj;\\n                    }\\n                } else if (ij < nn) {\\n                    ++i;\\n                } else {\\n                    --j;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1782580,
                "title": "o-n-m-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long long,long long>mp,cnt;\\n        for(int i=0;i<nums1.size()-1;i++){\\n            for(int j=i+1;j<nums1.size();j++){\\n                mp[(long long)nums1[i]*nums1[j]]++;\\n            }\\n        }\\n        for(int i=0;i<nums2.size()-1;i++){\\n            for(int j=i+1;j<nums2.size();j++){\\n                cnt[(long long)nums2[i]*nums2[j]]++;\\n            }\\n        }\\n        long long res=0;\\n        for(int i=0;i<nums1.size();i++){\\n            res+=cnt[(long long)nums1[i]*nums1[i]];\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            res+=mp[(long long)nums2[i]*nums2[i]];\\n        }\\n        return res;  \\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long long,long long>mp,cnt;\\n        for(int i=0;i<nums1.size()-1;i++){\\n            for(int j=i+1;j<nums1.size();j++){\\n                mp[(long long)nums1[i]*nums1[j]]++;\\n            }\\n        }\\n        for(int i=0;i<nums2.size()-1;i++){\\n            for(int j=i+1;j<nums2.size();j++){\\n                cnt[(long long)nums2[i]*nums2[j]]++;\\n            }\\n        }\\n        long long res=0;\\n        for(int i=0;i<nums1.size();i++){\\n            res+=cnt[(long long)nums1[i]*nums1[i]];\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            res+=mp[(long long)nums2[i]*nums2[i]];\\n        }\\n        return res;  \\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745095,
                "title": "typecasting-was-so-crazy-like-omg",
                "content": "```\\n#define lli long long int\\nclass Solution {\\npublic:\\n    int triplets(vector<int>&nums1,vector<int>&nums2){\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        unordered_map<lli,lli>mp;\\n        for(int i=0;i<nums2.size();i++)\\n            mp[nums2[i]]++;\\n        int ans=0;\\n        for(int i=0;i<nums1.size();i++){\\n            long long int target=((lli)nums1[i]*(lli)nums1[i]);\\n            int j=0;\\n            int k=nums2.size()-1;\\n            while(j<k){\\n                if((lli)nums2[j]*(lli)nums2[k]==target){\\n                  if(nums2[j]==nums2[k]){\\n                      ans+=((mp[nums2[j]]*(mp[nums2[j]]-1))/2);\\n                  }\\n                else{\\n                    ans+=(mp[nums2[j]]*mp[nums2[k]]);\\n                }\\n                    while(j<k and nums2[j]==nums2[j+1])\\n                        j++;\\n                    while(j<k and nums2[k]==nums2[k-1])\\n                        k--;\\n                    j++;\\n                    k--;\\n                }\\n                else if((lli)nums2[j]*(lli)nums2[k]>target){\\n                    k--;\\n                }\\n                else\\n                    j++;\\n            }\\n        }\\n        return ans;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return triplets(nums1,nums2)+triplets(nums2,nums1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int triplets(vector<int>&nums1,vector<int>&nums2){\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        unordered_map<lli,lli>mp;\\n        for(int i=0;i<nums2.size();i++)\\n            mp[nums2[i]]++;\\n        int ans=0;\\n        for(int i=0;i<nums1.size();i++){\\n            long long int target=((lli)nums1[i]*(lli)nums1[i]);\\n            int j=0;\\n            int k=nums2.size()-1;\\n            while(j<k){\\n                if((lli)nums2[j]*(lli)nums2[k]==target){\\n                  if(nums2[j]==nums2[k]){\\n                      ans+=((mp[nums2[j]]*(mp[nums2[j]]-1))/2);\\n                  }",
                "codeTag": "Java"
            },
            {
                "id": 1714050,
                "title": "java-clean-and-easy-code-o-n-n-time-o-1-space",
                "content": "Time : O(M * N)\\nSpace : O(1)\\n\\n**Feel free to ask in comment, if any doubt.**\\n\\n```\\nclass Solution {\\n    public int helper(int[] ar1, int[] ar2){\\n        int res = 0;\\n        int n = ar2.length;\\n        \\n        for(long num : ar1){\\n            int l = 0;\\n            int r = n-1;\\n            \\n            while(l < r){\\n                long val1 = ar2[l];\\n                long val2 = ar2[r];\\n                \\n                if( val1 == val2){\\n\\t\\t\\t\\t    //          l        r\\n                    //          |        |\\n                    // [..., 1, 2, 2, 2, 2, 4,....]\\n                    res += val1*val2 == num*num ? (r-l)*(r-l+1)/2 : 0;\\n                    break;    \\n                }\\n                \\n                if(num*num == val1*val2){\\n                    int count1 = 0;\\n                    while( l < r && ar2[l] == val1){\\n                        count1++;\\n                        l++;\\n                    }\\n                    while( ar2[r] == val2){\\n                        res += count1;\\n                        r--;\\n                    }\\n                }\\n                else if( val1*val2 > num*num){\\n                    while( l < r && ar2[r] == val2)\\n                        r--;\\n                }\\n                else{\\n                    while( l < r && ar2[l] == val1)\\n                        l++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        return helper(nums1, nums2) + helper(nums2, nums1); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int helper(int[] ar1, int[] ar2){\\n        int res = 0;\\n        int n = ar2.length;\\n        \\n        for(long num : ar1){\\n            int l = 0;\\n            int r = n-1;\\n            \\n            while(l < r){\\n                long val1 = ar2[l];\\n                long val2 = ar2[r];\\n                \\n                if( val1 == val2){\\n\\t\\t\\t\\t    //          l        r\\n                    //          |        |\\n                    // [..., 1, 2, 2, 2, 2, 4,....]\\n                    res += val1*val2 == num*num ? (r-l)*(r-l+1)/2 : 0;\\n                    break;    \\n                }\\n                \\n                if(num*num == val1*val2){\\n                    int count1 = 0;\\n                    while( l < r && ar2[l] == val1){\\n                        count1++;\\n                        l++;\\n                    }\\n                    while( ar2[r] == val2){\\n                        res += count1;\\n                        r--;\\n                    }\\n                }\\n                else if( val1*val2 > num*num){\\n                    while( l < r && ar2[r] == val2)\\n                        r--;\\n                }\\n                else{\\n                    while( l < r && ar2[l] == val1)\\n                        l++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        return helper(nums1, nums2) + helper(nums2, nums1); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665174,
                "title": "python-o-nlog-n-m-mlog-m-n-with-bisect-left-200ms",
                "content": "use bisect to find the `i*i == j*k`\\n\\n```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1,s2 = defaultdict(int),defaultdict(int)\\n        for s in nums1:\\n            s1[s] += 1\\n        for s in nums2:\\n            s2[s] += 1\\n        ans = 0\\n        def find(s1,s2):\\n            ans = 0\\n            for i in sorted(s1.keys()):\\n                s2sort = sorted(s2.keys())\\n                if i<s2sort[0]:\\n                    continue\\n                if i>s2sort[-1]:\\n                    break\\n                # print(sorted(s1.keys()),s2sort,i)\\n                for _j,j in enumerate(s2sort):\\n                    # print(sorted(s1.keys()),s2sort,i,j)\\n                    if j*s2sort[-1]<i*i:\\n                        continue\\n                    elif j>i:\\n                        break\\n                    elif (i*i)%j != 0:\\n                        continue\\n                    elif j == i:\\n                        ans += s1[i]*s2[j]*(s2[j]-1)//2\\n                        continue\\n                    else:\\n                        k = bisect_left(s2sort,i*i//j,_j+1)\\n                        while k<len(s2sort):\\n                            # print(s1.keys(),s2sort,i,j,s2sort[k],i*i-j*s2sort[k])\\n                            if j*s2sort[k] == i*i:\\n                                ans += s1[i]*s2[j]*s2[s2sort[k]]\\n                            k = bisect_left(s2sort,i*i//j,k+1)\\n            return ans\\n        t1,t2 = find(s1,s2),find(s2,s1)\\n        # print(t1,t2)\\n        return t1+t2\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1,s2 = defaultdict(int),defaultdict(int)\\n        for s in nums1:\\n            s1[s] += 1\\n        for s in nums2:\\n            s2[s] += 1\\n        ans = 0\\n        def find(s1,s2):\\n            ans = 0\\n            for i in sorted(s1.keys()):\\n                s2sort = sorted(s2.keys())\\n                if i<s2sort[0]:\\n                    continue\\n                if i>s2sort[-1]:\\n                    break\\n                # print(sorted(s1.keys()),s2sort,i)\\n                for _j,j in enumerate(s2sort):\\n                    # print(sorted(s1.keys()),s2sort,i,j)\\n                    if j*s2sort[-1]<i*i:\\n                        continue\\n                    elif j>i:\\n                        break\\n                    elif (i*i)%j != 0:\\n                        continue\\n                    elif j == i:\\n                        ans += s1[i]*s2[j]*(s2[j]-1)//2\\n                        continue\\n                    else:\\n                        k = bisect_left(s2sort,i*i//j,_j+1)\\n                        while k<len(s2sort):\\n                            # print(s1.keys(),s2sort,i,j,s2sort[k],i*i-j*s2sort[k])\\n                            if j*s2sort[k] == i*i:\\n                                ans += s1[i]*s2[j]*s2[s2sort[k]]\\n                            k = bisect_left(s2sort,i*i//j,k+1)\\n            return ans\\n        t1,t2 = find(s1,s2),find(s2,s1)\\n        # print(t1,t2)\\n        return t1+t2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652793,
                "title": "simple-careful-edge-case-handely-c-code",
                "content": "```\\n    int res = 0;\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        unordered_map<int, int> m1, m2;\\n        for(auto n : nums1) m1[n]++; for(auto n : nums2) m2[n]++;\\n        \\n        for(auto n : nums1) {\\n            \\n            int t = 0;\\n            \\n            for(auto a : nums2)\\n                if(((long long)n * n) % a == 0 && a != n) \\n                    t += m2[((long long)n * n) / a];\\n            \\n            res += t / 2;\\n            res += (m2[n] * (m2[n] - 1)) / 2;\\n        }\\n            \\n        for(auto n : nums2) {\\n            \\n            int t = 0;\\n            \\n            for(auto a : nums1)\\n                if(((long long)n * n) % a == 0 && a != n) \\n                    t += m1[((long long)n * n) / a];\\n            \\n            res += t / 2;\\n            res += (m1[n] * (m1[n] - 1)) / 2;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int res = 0;\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        unordered_map<int, int> m1, m2;\\n        for(auto n : nums1) m1[n]++; for(auto n : nums2) m2[n]++;\\n        \\n        for(auto n : nums1) {\\n            \\n            int t = 0;\\n            \\n            for(auto a : nums2)\\n                if(((long long)n * n) % a == 0 && a != n) \\n                    t += m2[((long long)n * n) / a];\\n            \\n            res += t / 2;\\n            res += (m2[n] * (m2[n] - 1)) / 2;\\n        }\\n            \\n        for(auto n : nums2) {\\n            \\n            int t = 0;\\n            \\n            for(auto a : nums1)\\n                if(((long long)n * n) % a == 0 && a != n) \\n                    t += m1[((long long)n * n) / a];\\n            \\n            res += t / 2;\\n            res += (m1[n] * (m1[n] - 1)) / 2;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1566825,
                "title": "c-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        using lint = long long int;\\n        unordered_map<lint, int> squares1;\\n        unordered_map<lint, int> squares2;\\n        for(lint i : nums1)\\n            ++squares1[i*i];\\n        for(lint i : nums2)\\n            ++squares2[i*i];\\n        auto N1 = nums1.size();\\n        auto N2 = nums2.size();\\n        int ret = 0;\\n        for(size_t i = 0; i < N1; ++i) {\\n            for(size_t j = i + 1; j < N1; ++j) {\\n                lint n = nums1[i];\\n                auto it = squares2.find(n * nums1[j]);\\n                if(it != squares2.end())\\n                    ret += it->second;\\n            }\\n        }\\n        for(size_t i = 0; i < N2; ++i) {\\n            for(size_t j = i + 1; j < N2; ++j) {\\n                lint n = nums2[i];\\n                auto it = squares1.find(n * nums2[j]);\\n                if(it != squares1.end())\\n                    ret += it->second;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        using lint = long long int;\\n        unordered_map<lint, int> squares1;\\n        unordered_map<lint, int> squares2;\\n        for(lint i : nums1)\\n            ++squares1[i*i];\\n        for(lint i : nums2)\\n            ++squares2[i*i];\\n        auto N1 = nums1.size();\\n        auto N2 = nums2.size();\\n        int ret = 0;\\n        for(size_t i = 0; i < N1; ++i) {\\n            for(size_t j = i + 1; j < N1; ++j) {\\n                lint n = nums1[i];\\n                auto it = squares2.find(n * nums1[j]);\\n                if(it != squares2.end())\\n                    ret += it->second;\\n            }\\n        }\\n        for(size_t i = 0; i < N2; ++i) {\\n            for(size_t j = i + 1; j < N2; ++j) {\\n                lint n = nums2[i];\\n                auto it = squares1.find(n * nums2[j]);\\n                if(it != squares1.end())\\n                    ret += it->second;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532039,
                "title": "python-code-beats-100-in-time-and-90-in-space",
                "content": "\\'\\'\\'\\n    def numTriplets(self, nums1, nums2):\\n\\n        dic1 = collections.Counter(nums1)\\n        dic2 = collections.Counter(nums2)\\n        \\n        ans, loop = 0, 2\\n        \\n        # set loop to 2, so we can check # of Type 2 after checking # of Type 1\\n        while loop > 0:\\n        \\n            for key in dic1:\\n                squared = key*key\\n                temp = 0\\n                for k in dic2:\\n                    if squared%k == 0 and squared/k in dic2:\\n                        \\n                        # if squared/k in nums2 and k != squared/k, we should add dic2[k]*dic2[squared/k]/2.0\\n                        # Here I am not adding dic2[k]*dic2[squared/k], because we are looping through keys in dic2\\n                        # we will see squared/k in the future and add another half of dic2[k]*dic2[squared/k]\\n                        if squared/k != k:\\n                            temp += dic2[k]*dic2[squared/k]/2.0\\n                            \\n                        # if squared/k in nums2 and k == squared/k, we will add dic2[k]*(dic2[k]-1)/2.0 since k repeats dic2[k] times in nums2\\n                        # we want to pick any two of those ks, there are dic2[k]*(dic2[k]-1)/2.0 ways to do it.\\n                        else:\\n                            temp += dic2[k]*(dic2[k]-1)/2.0\\n                \\n                # key repeats dic1[key] times in nums1. Each key contributes temp to the final result. We multiply them to get the total contribution from key in num1.\\n                ans += temp*dic1[key]\\n            \\n            loop -= 1\\n            dic1, dic2 = dic2, dic1\\n        \\n        return int(ans)\\n\\'\\'\\'\\nI think the time complexity here is O(m*n), m is the length of nums1 and n is the length of nums2\\nPlease correct me if I am wrong. \\n",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n    def numTriplets(self, nums1, nums2):\\n\\n        dic1 = collections.Counter(nums1)\\n        dic2 = collections.Counter(nums2)\\n        \\n        ans, loop = 0, 2\\n        \\n        # set loop to 2, so we can check # of Type 2 after checking # of Type 1\\n        while loop > 0:\\n        \\n            for key in dic1:\\n                squared = key*key\\n                temp = 0\\n                for k in dic2:\\n                    if squared%k == 0 and squared/k in dic2:\\n                        \\n                        # if squared/k in nums2 and k != squared/k, we should add dic2[k]*dic2[squared/k]/2.0\\n                        # Here I am not adding dic2[k]*dic2[squared/k], because we are looping through keys in dic2\\n                        # we will see squared/k in the future and add another half of dic2[k]*dic2[squared/k]\\n                        if squared/k != k:\\n                            temp += dic2[k]*dic2[squared/k]/2.0\\n                            \\n                        # if squared/k in nums2 and k == squared/k, we will add dic2[k]*(dic2[k]-1)/2.0 since k repeats dic2[k] times in nums2\\n                        # we want to pick any two of those ks, there are dic2[k]*(dic2[k]-1)/2.0 ways to do it.\\n                        else:\\n                            temp += dic2[k]*(dic2[k]-1)/2.0\\n                \\n                # key repeats dic1[key] times in nums1. Each key contributes temp to the final result. We multiply them to get the total contribution from key in num1.\\n                ans += temp*dic1[key]\\n            \\n            loop -= 1\\n            dic1, dic2 = dic2, dic1\\n        \\n        return int(ans)\\n\\'\\'\\'\\nI think the time complexity here is O(m*n), m is the length of nums1 and n is the length of nums2\\nPlease correct me if I am wrong. \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1521021,
                "title": "c-simple-approach-intuitive-approach",
                "content": "```\\nint numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long long,long long>m1;\\n        unordered_map<long long,long long>m2;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n           for(int j=i+1;j<nums1.size();j++)\\n           {\\n               long long  mul=(long long) nums1[i]*nums1[j];\\n               m1[mul]++;\\n           }\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n           for(int j=i+1;j<nums2.size();j++)\\n           {\\n               long long mul=(long long)nums2[i]*nums2[j];\\n               m2[mul]++;\\n           }\\n        }\\n        int count=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            long long square=(long long)nums1[i]*nums1[i];\\n            if(m2.find(square)!=m2.end())\\n            {\\n                count+=m2[square];\\n            }\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            long long square=(long long)nums2[i]*nums2[i];\\n            if(m1.find(square)!=m1.end())\\n            {\\n                count+=m1[square];\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long long,long long>m1;\\n        unordered_map<long long,long long>m2;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n           for(int j=i+1;j<nums1.size();j++)\\n           {\\n               long long  mul=(long long) nums1[i]*nums1[j];\\n               m1[mul]++;\\n           }\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n           for(int j=i+1;j<nums2.size();j++)\\n           {\\n               long long mul=(long long)nums2[i]*nums2[j];\\n               m2[mul]++;\\n           }\\n        }\\n        int count=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            long long square=(long long)nums1[i]*nums1[i];\\n            if(m2.find(square)!=m2.end())\\n            {\\n                count+=m2[square];\\n            }\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            long long square=(long long)nums2[i]*nums2[i];\\n            if(m1.find(square)!=m1.end())\\n            {\\n                count+=m1[square];\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1511939,
                "title": "python-3-easy-to-understand-solution-with-explanation",
                "content": "it is quite easy to give intuitive idea to brute-force it, the only difficult point is duplicate value removal.\\n\\nhere we use set, to remove duplicate easily, also, it is faster to judge if a value exists in a set than list.\\n\\nfor value i in num1, if i^2/j exists in num2,  we can easily get the value thru textbook combination as below\\n\\n1. count number of i in num1 denoted as i_1, number of j in num2 denoted as j_1, number of i^2/j denoted as k in num2 denoted as k_1\\n\\n2. if j = k, we add i_1 * math.comb(j_1, 2) to ans\\n3. else, we add i_1 * j_1 * k_1\\n\\nfor type 2 it is same\\n```\\nimport math\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums_1, nums_2 = set(nums1), set(nums2)\\n        ans = 0\\n        for i in nums_1:\\n            used = set()\\n            for j in nums_2:\\n                if (i**2)%j:continue\\n                temp = (i**2)//j\\n                if temp not in nums_2:\\n                    continue\\n                if j in used:continue\\n                used.add(j)\\n                used.add(temp)\\n                if temp == j:\\n                    ans += nums1.count(i) * math.comb(nums2.count(j), 2)\\n                else:\\n                    ans += nums1.count(i) * nums2.count(j) * nums2.count(temp)\\n        #print(ans)\\n        for i in nums_2:\\n            used = set()\\n            for j in nums_1:\\n                if (i**2)%j:continue\\n                temp = (i**2)//j\\n                if temp not in nums_1:\\n                    continue\\n                if j in used:continue\\n                used.add(j)\\n                used.add(temp)\\n                if temp == j:\\n                    ans += nums2.count(i) * math.comb(nums1.count(j), 2)\\n                else:\\n                    ans += nums2.count(i) * nums1.count(j) * nums1.count(temp)\\n        return ans\\n",
                "solutionTags": [],
                "code": "it is quite easy to give intuitive idea to brute-force it, the only difficult point is duplicate value removal.\\n\\nhere we use set, to remove duplicate easily, also, it is faster to judge if a value exists in a set than list.\\n\\nfor value i in num1, if i^2/j exists in num2,  we can easily get the value thru textbook combination as below\\n\\n1. count number of i in num1 denoted as i_1, number of j in num2 denoted as j_1, number of i^2/j denoted as k in num2 denoted as k_1\\n\\n2. if j = k, we add i_1 * math.comb(j_1, 2) to ans\\n3. else, we add i_1 * j_1 * k_1\\n\\nfor type 2 it is same\\n```\\nimport math\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums_1, nums_2 = set(nums1), set(nums2)\\n        ans = 0\\n        for i in nums_1:\\n            used = set()\\n            for j in nums_2:\\n                if (i**2)%j:continue\\n                temp = (i**2)//j\\n                if temp not in nums_2:\\n                    continue\\n                if j in used:continue\\n                used.add(j)\\n                used.add(temp)\\n                if temp == j:\\n                    ans += nums1.count(i) * math.comb(nums2.count(j), 2)\\n                else:\\n                    ans += nums1.count(i) * nums2.count(j) * nums2.count(temp)\\n        #print(ans)\\n        for i in nums_2:\\n            used = set()\\n            for j in nums_1:\\n                if (i**2)%j:continue\\n                temp = (i**2)//j\\n                if temp not in nums_1:\\n                    continue\\n                if j in used:continue\\n                used.add(j)\\n                used.add(temp)\\n                if temp == j:\\n                    ans += nums2.count(i) * math.comb(nums1.count(j), 2)\\n                else:\\n                    ans += nums2.count(i) * nums1.count(j) * nums1.count(temp)\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1507756,
                "title": "c-solution",
                "content": "```\\n  int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<long long,long long> mp,mp1;\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        \\n        for(auto x: nums1){\\n            mp[(long long)x*x]++;\\n        }\\n        \\n        for(auto x : nums2){\\n            mp1[(long long)x*x]++;\\n        }\\n        \\n        int ans=0;\\n        \\n      \\n        \\n        \\n        \\n        for(int i=0;i<nums2.size();i++){\\n            for(int j=i+1;j<nums2.size();j++){\\n                \\n                if(mp.find(((long long)nums2[i]*(long long)nums2[j]))!=mp.end()){\\n                    ans+=mp[(long long)nums2[i]*(long long)nums2[j]];\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=i+1;j<nums1.size();j++){\\n                \\n                if(mp1.find((long long)nums1[i]*(long long)nums1[j])!=mp1.end()){\\n                    \\n                    ans+=mp1[(long long)nums1[i]*(long long)nums1[j]];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<long long,long long> mp,mp1;\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        \\n        for(auto x: nums1){\\n            mp[(long long)x*x]++;\\n        }\\n        \\n        for(auto x : nums2){\\n            mp1[(long long)x*x]++;\\n        }\\n        \\n        int ans=0;\\n        \\n      \\n        \\n        \\n        \\n        for(int i=0;i<nums2.size();i++){\\n            for(int j=i+1;j<nums2.size();j++){\\n                \\n                if(mp.find(((long long)nums2[i]*(long long)nums2[j]))!=mp.end()){\\n                    ans+=mp[(long long)nums2[i]*(long long)nums2[j]];\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=i+1;j<nums1.size();j++){\\n                \\n                if(mp1.find((long long)nums1[i]*(long long)nums1[j])!=mp1.end()){\\n                    \\n                    ans+=mp1[(long long)nums1[i]*(long long)nums1[j]];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1447289,
                "title": "python-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        count = 0\\n        d = {}\\n        for i in range(len(nums2)):\\n            for j in range(i+1,len(nums2)):\\n                prod = nums2[i]*nums2[j]\\n                if prod not in d:\\n                    d[prod] = 1\\n                    \\n                else:\\n                    d[prod]+=1\\n                    \\n        for i in range(0,len(nums1)):\\n            num = pow(nums1[i],2)\\n            if num in d.keys():\\n                count+=d[num]\\n                \\n                        \\n        d = {}\\n        for i in range(0,len(nums1)):\\n            for j in range(i+1,len(nums1)):\\n                prod = nums1[i]*nums1[j]\\n                if prod not in d:\\n                    d[prod] = 1\\n                    \\n                else:\\n                    d[prod]+=1\\n                    \\n        for i in range(0,len(nums2)):\\n            num = pow(nums2[i],2)\\n            if num in d.keys():\\n                count+=d[num]\\n                \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        count = 0\\n        d = {}\\n        for i in range(len(nums2)):\\n            for j in range(i+1,len(nums2)):\\n                prod = nums2[i]*nums2[j]\\n                if prod not in d:\\n                    d[prod] = 1\\n                    \\n                else:\\n                    d[prod]+=1\\n                    \\n        for i in range(0,len(nums1)):\\n            num = pow(nums1[i],2)\\n            if num in d.keys():\\n                count+=d[num]\\n                \\n                        \\n        d = {}\\n        for i in range(0,len(nums1)):\\n            for j in range(i+1,len(nums1)):\\n                prod = nums1[i]*nums1[j]\\n                if prod not in d:\\n                    d[prod] = 1\\n                    \\n                else:\\n                    d[prod]+=1\\n                    \\n        for i in range(0,len(nums2)):\\n            num = pow(nums2[i],2)\\n            if num in d.keys():\\n                count+=d[num]\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437693,
                "title": "c-easy-solution-91-beat-math",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int>mp1;\\n        unordered_map<int,int>mp2;\\n        unordered_map<int,int>mp3;\\n        unordered_map<int,int>mp4;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            mp1[nums1[i]]++;\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            mp2[nums2[i]]++;\\n        }\\n        int ans=0;\\n        unordered_map<int,int>::iterator itr1;\\n        for(itr1=mp1.begin();itr1!=mp1.end();itr1++)\\n        {\\n            unordered_map<int,int>::iterator itr2;\\n            for(itr2=mp2.begin();itr2!=mp2.end();itr2++)\\n            {\\n                long long t = ((long long)itr1->first*(long long)itr1->first)/(long long)itr2->first;\\n                if((long long)t*(long long)itr2->first==((long long)itr1->first*(long long)itr1->first) && mp2.find(t)!=mp2.end() && mp4.find(itr2->first)==mp4.end())\\n                {\\n                    if(t==itr2->first)\\n                    {\\n                        if(itr2->second==1)\\n                        {\\n                            continue;\\n                        }\\n                        long long n = itr2->second -1;\\n                        long long p = (n*(n+1))/2;\\n                        ans+=(itr1->second*p);\\n                    }\\n                    else\\n                    {\\n                        long long p = (itr2->second*mp2[t]);\\n                        ans+= (p*itr1->second);\\n                        mp4[itr2->first]++;\\n                        mp4[t]++;\\n                    }\\n                }\\n            }\\n            mp4.clear();\\n        }\\n        unordered_map<int,int>::iterator itr3;\\n        for(itr3=mp2.begin();itr3!=mp2.end();itr3++)\\n        {\\n            unordered_map<int,int>::iterator itr4;\\n            for(itr4=mp1.begin();itr4!=mp1.end();itr4++)\\n            {\\n                long long t = ((long long)itr3->first*(long long)itr3->first)/(long long)itr4->first;\\n                if((long long)t*(long long)itr4->first==((long long)itr3->first*(long long)itr3->first) && mp1.find(t)!=mp1.end() && mp3.find(itr4->first)==mp3.end())\\n                {\\n                    if(t==itr4->first)\\n                    {\\n                        if(itr4->second==1)\\n                        {\\n                            continue;\\n                        }\\n                        long long n = itr4->second -1;\\n                        long long p = (n*(n+1))/2;\\n                        ans+=(itr3->second*p);\\n                    }\\n                    else\\n                    {\\n                        long long p = (itr4->second*mp1[t]);\\n                        ans+= (p*itr3->second);\\n                        mp3[itr4->first]++;\\n                        mp3[t]++;\\n                    }\\n                }\\n            }\\n            mp3.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int>mp1;\\n        unordered_map<int,int>mp2;\\n        unordered_map<int,int>mp3;\\n        unordered_map<int,int>mp4;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            mp1[nums1[i]]++;\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            mp2[nums2[i]]++;\\n        }\\n        int ans=0;\\n        unordered_map<int,int>::iterator itr1;\\n        for(itr1=mp1.begin();itr1!=mp1.end();itr1++)\\n        {\\n            unordered_map<int,int>::iterator itr2;\\n            for(itr2=mp2.begin();itr2!=mp2.end();itr2++)\\n            {\\n                long long t = ((long long)itr1->first*(long long)itr1->first)/(long long)itr2->first;\\n                if((long long)t*(long long)itr2->first==((long long)itr1->first*(long long)itr1->first) && mp2.find(t)!=mp2.end() && mp4.find(itr2->first)==mp4.end())\\n                {\\n                    if(t==itr2->first)\\n                    {\\n                        if(itr2->second==1)\\n                        {\\n                            continue;\\n                        }\\n                        long long n = itr2->second -1;\\n                        long long p = (n*(n+1))/2;\\n                        ans+=(itr1->second*p);\\n                    }\\n                    else\\n                    {\\n                        long long p = (itr2->second*mp2[t]);\\n                        ans+= (p*itr1->second);\\n                        mp4[itr2->first]++;\\n                        mp4[t]++;\\n                    }\\n                }\\n            }\\n            mp4.clear();\\n        }\\n        unordered_map<int,int>::iterator itr3;\\n        for(itr3=mp2.begin();itr3!=mp2.end();itr3++)\\n        {\\n            unordered_map<int,int>::iterator itr4;\\n            for(itr4=mp1.begin();itr4!=mp1.end();itr4++)\\n            {\\n                long long t = ((long long)itr3->first*(long long)itr3->first)/(long long)itr4->first;\\n                if((long long)t*(long long)itr4->first==((long long)itr3->first*(long long)itr3->first) && mp1.find(t)!=mp1.end() && mp3.find(itr4->first)==mp3.end())\\n                {\\n                    if(t==itr4->first)\\n                    {\\n                        if(itr4->second==1)\\n                        {\\n                            continue;\\n                        }\\n                        long long n = itr4->second -1;\\n                        long long p = (n*(n+1))/2;\\n                        ans+=(itr3->second*p);\\n                    }\\n                    else\\n                    {\\n                        long long p = (itr4->second*mp1[t]);\\n                        ans+= (p*itr3->second);\\n                        mp3[itr4->first]++;\\n                        mp3[t]++;\\n                    }\\n                }\\n            }\\n            mp3.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421656,
                "title": "c-solution-using-map",
                "content": "class Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        \\nmap<long long ,int>mp1;\\nmap<long long ,int>mp2;\\n        \\n        for(int i=0;i<n1;i++){\\n            long long  val=(long long)nums1[i]*(long long)nums1[i];\\n            mp1[val]++;\\n            \\n        }\\n        \\n        int count1=0,count2=0;\\n        \\n    for(int i=0;i<n2;i++){\\n        for(int j=i+1;j<n2;j++){\\n            long long val=(long long)nums2[j]*(long long)nums2[i];\\n            if(mp1.find(val)!=mp1.end()){\\n                count1+=mp1[val];\\n            }\\n        }\\n    }\\n        \\n        for(int i=0;i<n2;i++){\\n           long long  val=(long long)nums2[i]*(long long)nums2[i];\\n            mp2[val]++;\\n            \\n        }\\n        \\n            \\n    for(int i=0;i<n1;i++){\\n        for(int j=i+1;j<n1;j++){\\n            long long val=(long long)nums1[i]*(long long)nums1[j];\\n            if(mp2.find(val)!=mp2.end()){\\n                count2+=mp2[val];\\n            }\\n        }\\n    }\\n        \\n        \\n       return count1+count2; \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        \\nmap<long long ,int>mp1;\\nmap<long long ,int>mp2;\\n        \\n        for(int i=0;i<n1;i++){\\n            long long  val=(long long)nums1[i]*(long long)nums1[i];\\n            mp1[val]++;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1412612,
                "title": "c-2-pointers-and-map",
                "content": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\nll help1(ll t,vector<int> &ar,unordered_map<ll,ll> &mp){\\n    ll n=ar.size(),ans=0;\\n    for(ll i=0;i<n;i++){\\n        if(t%ar[i]) continue;\\n        ll n1=ar[i],n2=t/ar[i];\\n        if(n2>n1) ans+=mp[n2];              //  choose all possible n2 for a given n1\\n        else if(n2==n1){\\n            ans+=(mp[n2]*(mp[n2]-1))/2;     //  choose any 2 numbers from mp[n2] numbers  \\n            break;\\n        }else break;                        //  break to prevent counting repeated pairs\\n    }\\n    return ans;\\n}\\n\\nll help2(vector<int>& ar1, vector<int>& ar2){\\n    ll n=ar1.size(),ans=0;\\n    unordered_map<ll,ll> mp;\\n    for(auto it:ar2) mp[it]++;\\n    for(ll i=0;i<n;i++) ans+=help1(1LL*ar1[i]*ar1[i],ar2,mp);\\n    return ans;\\n}\\n\\nint numTriplets(vector<int>& ar1, vector<int>& ar2) {\\n    sort(ar1.begin(),ar1.end());\\n    sort(ar2.begin(),ar2.end());\\n    return help2(ar1,ar2)+help2(ar2,ar1);\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\nll help1(ll t,vector<int> &ar,unordered_map<ll,ll> &mp){\\n    ll n=ar.size(),ans=0;\\n    for(ll i=0;i<n;i++){\\n        if(t%ar[i]) continue;\\n        ll n1=ar[i],n2=t/ar[i];\\n        if(n2>n1) ans+=mp[n2];              //  choose all possible n2 for a given n1\\n        else if(n2==n1){\\n            ans+=(mp[n2]*(mp[n2]-1))/2;     //  choose any 2 numbers from mp[n2] numbers  \\n            break;\\n        }else break;                        //  break to prevent counting repeated pairs\\n    }\\n    return ans;\\n}\\n\\nll help2(vector<int>& ar1, vector<int>& ar2){\\n    ll n=ar1.size(),ans=0;\\n    unordered_map<ll,ll> mp;\\n    for(auto it:ar2) mp[it]++;\\n    for(ll i=0;i<n;i++) ans+=help1(1LL*ar1[i]*ar1[i],ar2,mp);\\n    return ans;\\n}\\n\\nint numTriplets(vector<int>& ar1, vector<int>& ar2) {\\n    sort(ar1.begin(),ar1.end());\\n    sort(ar2.begin(),ar2.end());\\n    return help2(ar1,ar2)+help2(ar2,ar1);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409995,
                "title": "python3-use-counter-to-handle-duplicates",
                "content": "a comment in the code\\n\\n```\\ndef numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n\\tdictN1,dictN2 = Counter(nums1),Counter(nums2)\\n\\tlistN1,listN2 = sorted(dictN1.keys()),sorted(dictN2.keys())\\n\\tN1,N2 = len(listN1),len(listN2)\\n\\n\\tretV = 0\\n\\tfor _ in range(2):\\n\\t\\tfor n in listN1:\\n\\t\\t\\tl,r = 0,N2-1\\n\\t\\t\\tif n>listN2[r]:          break\\n\\t\\t\\twhile l<=r:\\n\\t\\t\\t\\tn2,p = n**2,listN2[l]*listN2[r]\\n\\t\\t\\t\\tif n2<p:\\t\\t\\tr -= 1\\n\\t\\t\\t\\telif n2==p:\\n\\t\\t\\t\\t\\tretV += dictN1[n]*(dictN2[listN2[l]]*dictN2[listN2[r]] if l<r else dictN2[listN2[l]]*(dictN2[listN2[l]]-1)//2)\\n\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\telse:\\t\\t\\t\\tl += 1\\n\\n\\t\\tdictN1,dictN2,listN1,listN2,N1,N2 = dictN2,dictN1,listN2,listN1,N2,N1                # switch nums1 and nums2 and repeat to reuse the code\\n\\n\\treturn retV\\n```",
                "solutionTags": [],
                "code": "```\\ndef numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n\\tdictN1,dictN2 = Counter(nums1),Counter(nums2)\\n\\tlistN1,listN2 = sorted(dictN1.keys()),sorted(dictN2.keys())\\n\\tN1,N2 = len(listN1),len(listN2)\\n\\n\\tretV = 0\\n\\tfor _ in range(2):\\n\\t\\tfor n in listN1:\\n\\t\\t\\tl,r = 0,N2-1\\n\\t\\t\\tif n>listN2[r]:          break\\n\\t\\t\\twhile l<=r:\\n\\t\\t\\t\\tn2,p = n**2,listN2[l]*listN2[r]\\n\\t\\t\\t\\tif n2<p:\\t\\t\\tr -= 1\\n\\t\\t\\t\\telif n2==p:\\n\\t\\t\\t\\t\\tretV += dictN1[n]*(dictN2[listN2[l]]*dictN2[listN2[r]] if l<r else dictN2[listN2[l]]*(dictN2[listN2[l]]-1)//2)\\n\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\telse:\\t\\t\\t\\tl += 1\\n\\n\\t\\tdictN1,dictN2,listN1,listN2,N1,N2 = dictN2,dictN1,listN2,listN1,N2,N1                # switch nums1 and nums2 and repeat to reuse the code\\n\\n\\treturn retV\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1401312,
                "title": "python-solution-n-2-time-and-linear-space",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        c=0\\n        #take 1 number from nums2 and two numbers from nums1\\n        nums1Products=defaultdict(int)\\n        for i in range(len(nums1)-1):\\n            for j in range(i+1,len(nums1)):\\n                nums1Products[nums1[i]*nums1[j]]+=1\\n        for i in nums2:\\n            target=i**2\\n            c+=nums1Products[target]\\n                \\n        #take 1 number from nums1 and two numbers from nums2\\n        nums2Products=defaultdict(int)\\n        for i in range(len(nums2)-1):\\n            for j in range(i+1,len(nums2)):\\n                nums2Products[nums2[i]*nums2[j]]+=1\\n        for i in nums1:\\n            target=i**2\\n            c+=nums2Products[target]\\n        \\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        c=0\\n        #take 1 number from nums2 and two numbers from nums1\\n        nums1Products=defaultdict(int)\\n        for i in range(len(nums1)-1):\\n            for j in range(i+1,len(nums1)):\\n                nums1Products[nums1[i]*nums1[j]]+=1\\n        for i in nums2:\\n            target=i**2\\n            c+=nums1Products[target]\\n                \\n        #take 1 number from nums1 and two numbers from nums2\\n        nums2Products=defaultdict(int)\\n        for i in range(len(nums2)-1):\\n            for j in range(i+1,len(nums2)):\\n                nums2Products[nums2[i]*nums2[j]]+=1\\n        for i in nums1:\\n            target=i**2\\n            c+=nums2Products[target]\\n        \\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392942,
                "title": "python3-counter-o-n-2",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        c1=Counter([i**2 for i in nums1])\\n        c2=Counter([i**2 for i in nums2])\\n        ans=0\\n        for i in range(len(nums1)-1):\\n            for j in range(i+1,len(nums1)):\\n                p=nums1[i]*nums1[j]\\n                ans+=c2[p]\\n        for i in range(len(nums2)-1):\\n            for j in range(i+1,len(nums2)):\\n                p=nums2[i]*nums2[j]\\n                ans+=c1[p]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        c1=Counter([i**2 for i in nums1])\\n        c2=Counter([i**2 for i in nums2])\\n        ans=0\\n        for i in range(len(nums1)-1):\\n            for j in range(i+1,len(nums1)):\\n                p=nums1[i]*nums1[j]\\n                ans+=c2[p]\\n        for i in range(len(nums2)-1):\\n            for j in range(i+1,len(nums2)):\\n                p=nums2[i]*nums2[j]\\n                ans+=c1[p]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367641,
                "title": "rust-0ms-100-idea-caveats-and-source",
                "content": "| Theoretical | Test | Beats |\\n| --- | --- | --- |\\n| O(nm) time | 0ms | 100% |\\n| O(n+m) mem | 2.2MB | 100% |\\n\\n*New record?*\\n\\n***\\\\## Idea***\\n\\n**Big picture**: Write code for doing it forward, then call the function reversing its args.\\n\\n**Brute force**: enumerate all i\\'s then j\\'s then k\\'s; compare `n1[i] ** 2` and `n2[j] * n2[k]`.\\n\\n**Optimization**: if for a `n1[i]`, the current `n2[j] * n2[k]` is too small, then next time we don\\'t try a smaller `n2[j]` or `n2[k]`, and vice versa for greater.\\n\\n> You can also do it the other way around, enumerating `j` and `k` while binary-searching for a suitable `i`. Will be O(m<sup>2</sup>log(n)) tho.\\n\\n*How to implement?* Use sorted `n2`; initialize `j` and `k` to 0 and `len - 1`, respectively; decrease `k` if the product is too large, and increase `j` otherwise.\\n\\n*How to count?* If there are repeated elements in `n2`, then there isn\\'t an elegant way of processing them as they lie individually, tho continuously, in `n2`. So we preprocess `n2`, keeping the unique elements and their respective count, `c2`. For `j == k`, add `c2[j] * c2[k]`; otherwise, add `c2[j] * (c2[j] - 1) / 2` (combinations, which is permutations / orderings).\\n\\n**Winding it up**: do the same to `n1` and multiply gains by `c1`.\\n\\n***\\\\## Caveats***\\n\\n**Algorithm level**\\n\\n- loop until `j > k`, not `j >= k`. There can be repeated values, remember?\\n- it\\'s `c2[j] * (c2[j] - 1) / 2`, with the `/ 2`. I fell for it, personally.\\n\\n**Language level**\\n\\n- don\\'t copy the vectors; use references.\\n- data range limit 1e5\\u2014remember to use `i64` for squares and products.\\n- use `i32` or `i64` for indices and cast them to `usize` when indexing. There\\'s a `k -= 1` that is guaranteed not to be used as an index when it\\'s negative (cuz the loop breaks).\\n- and probably some more. I don\\'t remember.\\n\\n***\\\\## Source code***\\n\\nFull source with debug `println`s and tests:\\n\\n```rust\\nstruct Solution;\\n\\nimpl Solution {\\n    fn _ntri(n1: &[i32], c1: &[i32], n2: &[i32], c2: &[i32]) -> i32 {\\n        // Assumes that n1, n2 are sorted and unique, and that c1, c2 hold the\\n        // counts of each unique element in n1, n2\\n        // println!(\"{:?}\", n1);\\n        // println!(\"{:?}\", c1);\\n        // println!(\"{:?}\", n2);\\n        // println!(\"{:?}\", c2);\\n\\n        let mut cnt = 0;\\n        for i in 0..(n1.len()) {\\n            let sq = n1[i] as i64 * n1[i] as i64;\\n            let mut j = 0i32;\\n            let mut k = n2.len() as i32 - 1;\\n            while j <= k {\\n                let pd = n2[j as usize] as i64 * n2[k as usize] as i64;\\n                // println!(\\n                //     \"{} {} {} => {:?}\", i, j, k, sq.partial_cmp(&pd).unwrap());\\n                if sq == pd {\\n                    cnt += c1[i] * if j == k {\\n                        c2[j as usize] * (c2[j as usize] - 1) / 2\\n                    } else {\\n                        c2[j as usize] * c2[k as usize]\\n                    };\\n                    j += 1;\\n                } else if sq < pd {\\n                    k -= 1;\\n                } else {\\n                    j += 1;\\n                }\\n            }\\n        }\\n\\n        cnt\\n    }\\n\\n    pub fn num_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n        const INF: i32 = 0x3f3f3f3f;\\n        let mut nums1 = nums1;\\n        nums1.sort_by(|a, b| a.partial_cmp(b).unwrap());\\n        let mut nums2 = nums2;\\n        nums2.sort_by(|a, b| a.partial_cmp(b).unwrap());\\n\\n        let mut uniq1: Vec<i32> = vec![];\\n        let mut cnts1: Vec<i32> = vec![];\\n        let mut uniq2: Vec<i32> = vec![];\\n        let mut cnts2: Vec<i32> = vec![];\\n\\n        let mut tot = 0;\\n        let mut prev = INF;\\n        for a in nums1.iter() {\\n            if *a != prev {\\n                uniq1.push(*a);\\n                cnts1.push(1);\\n                tot += 1;\\n                prev = *a;\\n            } else {\\n                cnts1[tot - 1] += 1;\\n            }\\n        }\\n\\n        tot = 0;\\n        prev = INF;\\n        for a in nums2.iter() {\\n            if *a != prev {\\n                uniq2.push(*a);\\n                cnts2.push(1);\\n                tot += 1;\\n                prev = *a;\\n            } else {\\n                cnts2[tot - 1] += 1;\\n            }\\n        }\\n\\n        let fw = Self::_ntri(&uniq1[..], &cnts1[..], &uniq2[..], &cnts2[..]);\\n        let bw = Self::_ntri(&uniq2[..], &cnts2[..], &uniq1[..], &cnts1[..]);\\n        // println!(\"{} {}\", fw, bw);\\n        fw + bw\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_sample_1() {\\n        let n1 = vec![7, 4];\\n        let n2 = vec![5, 2, 8, 9];\\n        assert_eq!(Solution::num_triplets(n1, n2), 1);\\n    }\\n\\n    #[test]\\n    fn test_sample_2() {\\n        let n1 = vec![1, 1];\\n        let n2 = vec![1, 1, 1];\\n        assert_eq!(Solution::num_triplets(n1, n2), 9);\\n    }\\n\\n    #[test]\\n    fn test_sample_3() {\\n        let n1 = vec![7, 7, 8, 3];\\n        let n2 = vec![1, 2, 9, 7];\\n        assert_eq!(Solution::num_triplets(n1, n2), 2);\\n    }\\n\\n    #[test]\\n    fn test_sample_4() {\\n        let n1 = vec![4, 7, 9, 11, 23];\\n        let n2 = vec![3, 5, 1024, 12, 18];\\n        assert_eq!(Solution::num_triplets(n1, n2), 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nstruct Solution;\\n\\nimpl Solution {\\n    fn _ntri(n1: &[i32], c1: &[i32], n2: &[i32], c2: &[i32]) -> i32 {\\n        // Assumes that n1, n2 are sorted and unique, and that c1, c2 hold the\\n        // counts of each unique element in n1, n2\\n        // println!(\"{:?}\", n1);\\n        // println!(\"{:?}\", c1);\\n        // println!(\"{:?}\", n2);\\n        // println!(\"{:?}\", c2);\\n\\n        let mut cnt = 0;\\n        for i in 0..(n1.len()) {\\n            let sq = n1[i] as i64 * n1[i] as i64;\\n            let mut j = 0i32;\\n            let mut k = n2.len() as i32 - 1;\\n            while j <= k {\\n                let pd = n2[j as usize] as i64 * n2[k as usize] as i64;\\n                // println!(\\n                //     \"{} {} {} => {:?}\", i, j, k, sq.partial_cmp(&pd).unwrap());\\n                if sq == pd {\\n                    cnt += c1[i] * if j == k {\\n                        c2[j as usize] * (c2[j as usize] - 1) / 2\\n                    } else {\\n                        c2[j as usize] * c2[k as usize]\\n                    };\\n                    j += 1;\\n                } else if sq < pd {\\n                    k -= 1;\\n                } else {\\n                    j += 1;\\n                }\\n            }\\n        }\\n\\n        cnt\\n    }\\n\\n    pub fn num_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n        const INF: i32 = 0x3f3f3f3f;\\n        let mut nums1 = nums1;\\n        nums1.sort_by(|a, b| a.partial_cmp(b).unwrap());\\n        let mut nums2 = nums2;\\n        nums2.sort_by(|a, b| a.partial_cmp(b).unwrap());\\n\\n        let mut uniq1: Vec<i32> = vec![];\\n        let mut cnts1: Vec<i32> = vec![];\\n        let mut uniq2: Vec<i32> = vec![];\\n        let mut cnts2: Vec<i32> = vec![];\\n\\n        let mut tot = 0;\\n        let mut prev = INF;\\n        for a in nums1.iter() {\\n            if *a != prev {\\n                uniq1.push(*a);\\n                cnts1.push(1);\\n                tot += 1;\\n                prev = *a;\\n            } else {\\n                cnts1[tot - 1] += 1;\\n            }\\n        }\\n\\n        tot = 0;\\n        prev = INF;\\n        for a in nums2.iter() {\\n            if *a != prev {\\n                uniq2.push(*a);\\n                cnts2.push(1);\\n                tot += 1;\\n                prev = *a;\\n            } else {\\n                cnts2[tot - 1] += 1;\\n            }\\n        }\\n\\n        let fw = Self::_ntri(&uniq1[..], &cnts1[..], &uniq2[..], &cnts2[..]);\\n        let bw = Self::_ntri(&uniq2[..], &cnts2[..], &uniq1[..], &cnts1[..]);\\n        // println!(\"{} {}\", fw, bw);\\n        fw + bw\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_sample_1() {\\n        let n1 = vec![7, 4];\\n        let n2 = vec![5, 2, 8, 9];\\n        assert_eq!(Solution::num_triplets(n1, n2), 1);\\n    }\\n\\n    #[test]\\n    fn test_sample_2() {\\n        let n1 = vec![1, 1];\\n        let n2 = vec![1, 1, 1];\\n        assert_eq!(Solution::num_triplets(n1, n2), 9);\\n    }\\n\\n    #[test]\\n    fn test_sample_3() {\\n        let n1 = vec![7, 7, 8, 3];\\n        let n2 = vec![1, 2, 9, 7];\\n        assert_eq!(Solution::num_triplets(n1, n2), 2);\\n    }\\n\\n    #[test]\\n    fn test_sample_4() {\\n        let n1 = vec![4, 7, 9, 11, 23];\\n        let n2 = vec![3, 5, 1024, 12, 18];\\n        assert_eq!(Solution::num_triplets(n1, n2), 0);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1342968,
                "title": "c-o-n-2-time-and-o-3n-memory",
                "content": "```\\npublic int NumTriplets(int[] nums1, int[] nums2) {\\n        \\n        var hash1 = new Dictionary<long, int>();\\n        for(int i = 0; i < nums1.Length; i++)\\n        {\\n            var square = (long)nums1[i] * nums1[i];\\n            if (!hash1.ContainsKey(square)) hash1.Add(square, 0);\\n            hash1[square]++;\\n        }\\n        \\n        var hash2 = new Dictionary<long, int>();\\n        for(int i = 0; i < nums2.Length; i++)\\n        {\\n            var square = (long)nums2[i] * nums2[i];\\n            if (!hash2.ContainsKey(square)) hash2.Add(square, 0);\\n            hash2[square]++;\\n        }\\n        \\n        \\n        var count = 0;\\n        \\n        //Type 1\\n        for(int i = 0; i < nums2.Length; i++)\\n        {\\n            for(int j = i + 1; j < nums2.Length; j++)\\n            {\\n                var product = (long)nums2[i] * nums2[j];\\n                if (hash1.ContainsKey(product)) count = count + hash1[product];\\n            }\\n        }\\n        \\n        //Type 2\\n        for(int i = 0; i < nums1.Length; i++)\\n        {\\n            for(int j = i + 1; j < nums1.Length; j++)\\n            {\\n                var product = (long)nums1[i] * nums1[j];\\n                if (hash2.ContainsKey(product)) count = count + hash2[product];\\n            }\\n        }\\n        \\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumTriplets(int[] nums1, int[] nums2) {\\n        \\n        var hash1 = new Dictionary<long, int>();\\n        for(int i = 0; i < nums1.Length; i++)\\n        {\\n            var square = (long)nums1[i] * nums1[i];\\n            if (!hash1.ContainsKey(square)) hash1.Add(square, 0);\\n            hash1[square]++;\\n        }\\n        \\n        var hash2 = new Dictionary<long, int>();\\n        for(int i = 0; i < nums2.Length; i++)\\n        {\\n            var square = (long)nums2[i] * nums2[i];\\n            if (!hash2.ContainsKey(square)) hash2.Add(square, 0);\\n            hash2[square]++;\\n        }\\n        \\n        \\n        var count = 0;\\n        \\n        //Type 1\\n        for(int i = 0; i < nums2.Length; i++)\\n        {\\n            for(int j = i + 1; j < nums2.Length; j++)\\n            {\\n                var product = (long)nums2[i] * nums2[j];\\n                if (hash1.ContainsKey(product)) count = count + hash1[product];\\n            }\\n        }\\n        \\n        //Type 2\\n        for(int i = 0; i < nums1.Length; i++)\\n        {\\n            for(int j = i + 1; j < nums1.Length; j++)\\n            {\\n                var product = (long)nums1[i] * nums1[j];\\n                if (hash2.ContainsKey(product)) count = count + hash2[product];\\n            }\\n        }\\n        \\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1338173,
                "title": "c-o-n-m-time-and-o-1-memory-100-faster-with-100-less-memory-usage",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int numTriplets(vector<int>& a, vector<int>& b) {\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        return fun(a,b)+fun(b,a);\\n    }\\n    int fun(vector<int>& a, vector<int>& b){ //simple O(1) two sum (kinda) for every x in a.\\n        ll n=a.size(),m=b.size(),ans=0;\\n        for(auto &x:a){\\n            ll tar=x; tar=tar*((ll)x);\\n            int i=0,j=m-1;\\n            while(i<j){\\n                ll t=b[i]; t=t*((ll)b[j]);\\n                if(t<tar)\\n                    i++;\\n                else if(t>tar)\\n                    j--;\\n                else{\\n                    if(b[i]==b[j]){\\n                        ll len=j-i+1;\\n                        ans+=((len)*(len-1))/2;\\n                        break;\\n                    }\\n                    ll cnt1=0,cnt2=0,x=b[i],y=b[j];\\n                    while(b[i]==x)\\n                    {i++;cnt1++;}\\n                    while(b[j]==y)\\n                    {j--;cnt2++;}\\n                    ans+=cnt1*cnt2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int numTriplets(vector<int>& a, vector<int>& b) {\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        return fun(a,b)+fun(b,a);\\n    }\\n    int fun(vector<int>& a, vector<int>& b){ //simple O(1) two sum (kinda) for every x in a.\\n        ll n=a.size(),m=b.size(),ans=0;\\n        for(auto &x:a){\\n            ll tar=x; tar=tar*((ll)x);\\n            int i=0,j=m-1;\\n            while(i<j){\\n                ll t=b[i]; t=t*((ll)b[j]);\\n                if(t<tar)\\n                    i++;\\n                else if(t>tar)\\n                    j--;\\n                else{\\n                    if(b[i]==b[j]){\\n                        ll len=j-i+1;\\n                        ans+=((len)*(len-1))/2;\\n                        break;\\n                    }\\n                    ll cnt1=0,cnt2=0,x=b[i],y=b[j];\\n                    while(b[i]==x)\\n                    {i++;cnt1++;}\\n                    while(b[j]==y)\\n                    {j--;cnt2++;}\\n                    ans+=cnt1*cnt2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331579,
                "title": "just-two-passes-on-two-cases",
                "content": "```scala\\n  def numTriplets(num1: Array[Int], num2: Array[Int]): Int = {\\n\\n    def f(dou: Array[Double], opp: Array[Double]): Int = {\\n      var count = 0\\n      dou.foreach(tar => {\\n        var s = 0\\n        var e = opp.length - 1\\n        while (s < e) {\\n          if (opp(s) * opp(e) < tar) {\\n            s += 1\\n          } else if (opp(s) * opp(e) > tar) {\\n            e -= 1\\n          } else {\\n            if (opp(s) == opp(e)) {\\n              var tot = e - s\\n              count += (1 + tot) * tot / 2\\n              s = e + 1\\n            } else {\\n              var a = s\\n              var b = e\\n              while (a < opp.length && opp(a) == opp(s)) a += 1\\n              while (b >= a && opp(e) == opp(b)) b -= 1\\n              count += (a - s) * (e - b)\\n              s = a\\n              e = b\\n            }\\n          }\\n        }\\n      })\\n      count\\n    }\\n\\n    f(num1.map(Math.pow(_, 2)), num2.map(_.toDouble).sortWith(_ < _)) + f(\\n      num2.map(Math.pow(_, 2)),\\n      num1.map(_.toDouble).sortWith(_ < _)\\n    )\\n\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n  def numTriplets(num1: Array[Int], num2: Array[Int]): Int = {\\n\\n    def f(dou: Array[Double], opp: Array[Double]): Int = {\\n      var count = 0\\n      dou.foreach(tar => {\\n        var s = 0\\n        var e = opp.length - 1\\n        while (s < e) {\\n          if (opp(s) * opp(e) < tar) {\\n            s += 1\\n          } else if (opp(s) * opp(e) > tar) {\\n            e -= 1\\n          } else {\\n            if (opp(s) == opp(e)) {\\n              var tot = e - s\\n              count += (1 + tot) * tot / 2\\n              s = e + 1\\n            } else {\\n              var a = s\\n              var b = e\\n              while (a < opp.length && opp(a) == opp(s)) a += 1\\n              while (b >= a && opp(e) == opp(b)) b -= 1\\n              count += (a - s) * (e - b)\\n              s = a\\n              e = b\\n            }\\n          }\\n        }\\n      })\\n      count\\n    }\\n\\n    f(num1.map(Math.pow(_, 2)), num2.map(_.toDouble).sortWith(_ < _)) + f(\\n      num2.map(Math.pow(_, 2)),\\n      num1.map(_.toDouble).sortWith(_ < _)\\n    )\\n\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1293341,
                "title": "golang-solution",
                "content": "```\\nfunc numTriplets(nums1 []int, nums2 []int) int {\\n    m1, m2 := make(map[int]int), make(map[int]int)\\n    for _, v := range nums1 {\\n        m1[v*v]++\\n    }\\n    for _, v := range nums2 {\\n        m2[v*v]++\\n    }\\n    count:=0\\n    fmt.Println(\"m1, m2:\" ,m1,m2)\\n    for k, v := range m1 {\\n        for i:=0 ; i<len(nums2); i++ {\\n            for j:=i+1; j< len(nums2); j++ {\\n                if nums2[i]*nums2[j] == k {\\n                    count+=v\\n                }\\n            }\\n        }\\n    }\\n    for k, v := range m2 {\\n        for i:=0 ; i<len(nums1); i++ {\\n            for j:=i+1; j< len(nums1); j++ {\\n                if nums1[i]*nums1[j] == k {\\n                    count+=v\\n                }\\n            }\\n        }\\n    }\\n    return count\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc numTriplets(nums1 []int, nums2 []int) int {\\n    m1, m2 := make(map[int]int), make(map[int]int)\\n    for _, v := range nums1 {\\n        m1[v*v]++\\n    }\\n    for _, v := range nums2 {\\n        m2[v*v]++\\n    }\\n    count:=0\\n    fmt.Println(\"m1, m2:\" ,m1,m2)\\n    for k, v := range m1 {\\n        for i:=0 ; i<len(nums2); i++ {\\n            for j:=i+1; j< len(nums2); j++ {\\n                if nums2[i]*nums2[j] == k {\\n                    count+=v\\n                }\\n            }\\n        }\\n    }\\n    for k, v := range m2 {\\n        for i:=0 ; i<len(nums1); i++ {\\n            for j:=i+1; j< len(nums1); j++ {\\n                if nums1[i]*nums1[j] == k {\\n                    count+=v\\n                }\\n            }\\n        }\\n    }\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1280561,
                "title": "c-using-2-hashmap-type-casting-to-long-long-everywhere-o-nums1-size-2-nums2-size-2",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2)\\n    {\\n      unordered_map<ll, int> m;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            ll x = (ll) nums1[i] * (ll)nums1[i];\\n            m[x]++;\\n        }\\n        int cnt = 0;\\n        for(int i = 0; i < nums2.size(); i++)\\n        {\\n            for(int j = i + 1; j < nums2.size(); j++)\\n            {\\n                ll val = (ll) nums2[i] * (ll)nums2[j];\\n                if(m.find(val) != m.end())\\n                {\\n                    cnt=cnt+m[val];\\n                }\\n            }\\n        }\\n         unordered_map<ll, int> m1;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            ll x = (ll) nums2[i] * (ll)nums2[i];\\n            m1[x]++;\\n        }\\n        int cnt1 = 0;\\n        for(int i = 0; i < nums1.size(); i++)\\n        {\\n            for(int j = i + 1; j < nums1.size(); j++)\\n            {\\n                ll val = (ll) nums1[i] * (ll)nums1[j];\\n                if(m1.find(val) != m1.end()){\\n                    cnt1 = cnt1 + m1[val];\\n                }\\n            }\\n        }\\n        return cnt+cnt1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2)\\n    {\\n      unordered_map<ll, int> m;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            ll x = (ll) nums1[i] * (ll)nums1[i];\\n            m[x]++;\\n        }\\n        int cnt = 0;\\n        for(int i = 0; i < nums2.size(); i++)\\n        {\\n            for(int j = i + 1; j < nums2.size(); j++)\\n            {\\n                ll val = (ll) nums2[i] * (ll)nums2[j];\\n                if(m.find(val) != m.end())\\n                {\\n                    cnt=cnt+m[val];\\n                }\\n            }\\n        }\\n         unordered_map<ll, int> m1;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            ll x = (ll) nums2[i] * (ll)nums2[i];\\n            m1[x]++;\\n        }\\n        int cnt1 = 0;\\n        for(int i = 0; i < nums1.size(); i++)\\n        {\\n            for(int j = i + 1; j < nums1.size(); j++)\\n            {\\n                ll val = (ll) nums1[i] * (ll)nums1[j];\\n                if(m1.find(val) != m1.end()){\\n                    cnt1 = cnt1 + m1[val];\\n                }\\n            }\\n        }\\n        return cnt+cnt1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276018,
                "title": "ruby-100-100",
                "content": "```\\n# @param {Integer[]} nums1\\n# @param {Integer[]} nums2\\n# @return {Integer}\\ndef num_triplets(nums1, nums2)\\n  (f(nums1, nums2) + f(nums2, nums1)) / 2\\nend\\n\\ndef f(a, b)\\n  h = b.tally\\n  a.sum do |x|\\n    s = x * x\\n    h.sum do |y, c|\\n      s % y == 0 ? c * (x == y ? c - 1 : h.fetch(s / y, 0)) : 0\\n    end\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} nums1\\n# @param {Integer[]} nums2\\n# @return {Integer}\\ndef num_triplets(nums1, nums2)\\n  (f(nums1, nums2) + f(nums2, nums1)) / 2\\nend\\n\\ndef f(a, b)\\n  h = b.tally\\n  a.sum do |x|\\n    s = x * x\\n    h.sum do |y, c|\\n      s % y == 0 ? c * (x == y ? c - 1 : h.fetch(s / y, 0)) : 0\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1238485,
                "title": "typescript-map-o-n-m",
                "content": "```\\nfunction fromSecond(num:number[],target:number){\\n    let mp=new Map(),\\n        len:number=num.length,\\n        ans:number=0;\\n    mp.set(num[len-1],1);\\n    for (let i=len-2;i>=0;i--){\\n        if (target%num[i]==0){\\n            let want:number=Math.floor(target/num[i]);\\n            if (mp.has(want)){\\n                if (want*num[i]==target){\\n                    ans+=mp.get(want);\\n                }\\n            }\\n        }\\n        if (mp.has(num[i])){\\n            mp.set(num[i],mp.get(num[i])+1);\\n        }else{\\n            mp.set(num[i],1);\\n        }\\n    }\\n    return ans;\\n}\\nfunction numTriplets(num1: number[], num2: number[]): number {\\n    let ans:number=0;\\n    for (let value of num1){\\n        ans+=fromSecond(num2,value*value);\\n    }\\n    for (let value of num2){\\n        ans+=fromSecond(num1,value*value);\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction fromSecond(num:number[],target:number){\\n    let mp=new Map(),\\n        len:number=num.length,\\n        ans:number=0;\\n    mp.set(num[len-1],1);\\n    for (let i=len-2;i>=0;i--){\\n        if (target%num[i]==0){\\n            let want:number=Math.floor(target/num[i]);\\n            if (mp.has(want)){\\n                if (want*num[i]==target){\\n                    ans+=mp.get(want);\\n                }\\n            }\\n        }\\n        if (mp.has(num[i])){\\n            mp.set(num[i],mp.get(num[i])+1);\\n        }else{\\n            mp.set(num[i],1);\\n        }\\n    }\\n    return ans;\\n}\\nfunction numTriplets(num1: number[], num2: number[]): number {\\n    let ans:number=0;\\n    for (let value of num1){\\n        ans+=fromSecond(num2,value*value);\\n    }\\n    for (let value of num2){\\n        ans+=fromSecond(num1,value*value);\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1234891,
                "title": "javascript",
                "content": "```\\n\\n/**\\n * @param {number[]} nums\\n * @return {Map} duplets\\n */\\nconst getAllPossibleMultipliedPais = nums => {\\n    const duplets = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = i + 1; j < nums.length; j++) {\\n            const dupletRes = nums[i] * nums[j];\\n            duplets.set(dupletRes, (duplets.get(dupletRes) || 0) + 1);\\n        }\\n    }\\n    \\n    return duplets;\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @return {Map}\\n */\\nconst getAllSquares = nums => {\\n    const squares = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        const squareRes = nums[i] * nums[i];\\n        squares.set(squareRes, (squares.get(squareRes) || 0) + 1);\\n    }\\n    \\n    return squares;\\n}\\n\\nconst getMatchesCount = (dupletsMap, squaresMap) => {\\n    let matches = 0;\\n    for (let [duplet, freq] of dupletsMap) {\\n        const matchedSquareFreq = squaresMap.get(duplet);\\n        if (matchedSquareFreq === undefined) {\\n            continue;\\n        }\\n        \\n        matches += freq * matchedSquareFreq;\\n    }\\n    \\n    return matches;\\n}\\n\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nconst numTriplets = (nums1, nums2) => \\ngetMatchesCount(\\n    getAllPossibleMultipliedPais(nums1),\\n    getAllSquares(nums2)\\n) \\n+ \\ngetMatchesCount(\\n    getAllPossibleMultipliedPais(nums2),\\n    getAllSquares(nums1)\\n)\\n```",
                "solutionTags": [],
                "code": "```\\n\\n/**\\n * @param {number[]} nums\\n * @return {Map} duplets\\n */\\nconst getAllPossibleMultipliedPais = nums => {\\n    const duplets = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = i + 1; j < nums.length; j++) {\\n            const dupletRes = nums[i] * nums[j];\\n            duplets.set(dupletRes, (duplets.get(dupletRes) || 0) + 1);\\n        }\\n    }\\n    \\n    return duplets;\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @return {Map}\\n */\\nconst getAllSquares = nums => {\\n    const squares = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        const squareRes = nums[i] * nums[i];\\n        squares.set(squareRes, (squares.get(squareRes) || 0) + 1);\\n    }\\n    \\n    return squares;\\n}\\n\\nconst getMatchesCount = (dupletsMap, squaresMap) => {\\n    let matches = 0;\\n    for (let [duplet, freq] of dupletsMap) {\\n        const matchedSquareFreq = squaresMap.get(duplet);\\n        if (matchedSquareFreq === undefined) {\\n            continue;\\n        }\\n        \\n        matches += freq * matchedSquareFreq;\\n    }\\n    \\n    return matches;\\n}\\n\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nconst numTriplets = (nums1, nums2) => \\ngetMatchesCount(\\n    getAllPossibleMultipliedPais(nums1),\\n    getAllSquares(nums2)\\n) \\n+ \\ngetMatchesCount(\\n    getAllPossibleMultipliedPais(nums2),\\n    getAllSquares(nums1)\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1222895,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func helper(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        let c2 = nums2.count\\n        var products = [Int: Int]()\\n        for i in 0..<(c2 - 1) {\\n            for j in (i + 1)..<c2 {\\n                products[nums2[i] * nums2[j], default: Int(0)] += 1\\n            }\\n        }\\n        return nums1.reduce(into: Int(0), { if let productCount = products[$1 * $1] { $0 += productCount } })\\n    }\\n    func numTriplets(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        return helper(nums1, nums2) + helper(nums2, nums1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func helper(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        let c2 = nums2.count\\n        var products = [Int: Int]()\\n        for i in 0..<(c2 - 1) {\\n            for j in (i + 1)..<c2 {\\n                products[nums2[i] * nums2[j], default: Int(0)] += 1\\n            }\\n        }\\n        return nums1.reduce(into: Int(0), { if let productCount = products[$1 * $1] { $0 += productCount } })\\n    }\\n    func numTriplets(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        return helper(nums1, nums2) + helper(nums2, nums1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195046,
                "title": "concise-python-solution-similar-to-2-sum",
                "content": "```\\n    def triplets(self, counter, arr):\\n        result = 0\\n        for num in arr:\\n            for k, v in counter.items():\\n                if num == k:\\n                    result += v*(v-1)/2\\n                elif k < num and (num*num)%k == 0:\\n                    result += counter[int((num*num)/k)] * v\\n        return int(result)\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        counter1, counter2, result = Counter(nums1), Counter(nums2), 0\\n        return self.triplets(counter2, nums1) + self.triplets(counter1, nums2)\\n```",
                "solutionTags": [],
                "code": "```\\n    def triplets(self, counter, arr):\\n        result = 0\\n        for num in arr:\\n            for k, v in counter.items():\\n                if num == k:\\n                    result += v*(v-1)/2\\n                elif k < num and (num*num)%k == 0:\\n                    result += counter[int((num*num)/k)] * v\\n        return int(result)\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        counter1, counter2, result = Counter(nums1), Counter(nums2), 0\\n        return self.triplets(counter2, nums1) + self.triplets(counter1, nums2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1162603,
                "title": "i-can-t-understand-what-s-wrong-with-my-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int checkproduct(int a, vector<int>& arr){\\n        int count=0;\\n        int n=arr.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(arr[i]*arr[j]==a)count++;\\n            }\\n        }\\n        return count;   \\n    }   \\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0;\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        for(int i=0;i<n1;i++){\\n            //if(checkproduct(nums1[i]*nums1[i],nums2))\\n                ans+=checkproduct(nums1[i]*nums1[i],nums2);\\n        }\\n        for(int i=0;i<n2;i++){\\n            //if(checkproduct(nums2[i]*nums2[i],nums1))\\n                ans+=checkproduct(nums2[i]*nums2[i],nums2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int checkproduct(int a, vector<int>& arr){\\n        int count=0;\\n        int n=arr.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(arr[i]*arr[j]==a)count++;\\n            }\\n        }\\n        return count;   \\n    }   \\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0;\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        for(int i=0;i<n1;i++){\\n            //if(checkproduct(nums1[i]*nums1[i],nums2))\\n                ans+=checkproduct(nums1[i]*nums1[i],nums2);\\n        }\\n        for(int i=0;i<n2;i++){\\n            //if(checkproduct(nums2[i]*nums2[i],nums1))\\n                ans+=checkproduct(nums2[i]*nums2[i],nums2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150908,
                "title": "java-time-o-m-n-short-98-native-data-structure",
                "content": "```\\n    private int singleNumTriplets(int[] nums1, int[] nums2) {\\n        int[] b = new int[100001];\\n        for (int i = 0; i < nums2.length; i++) {\\n            b[nums2[i]]++;\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < nums1.length - 1; i++) {\\n            for (int j = i + 1; j < nums1.length; j++) {\\n                int st = (int)Math.sqrt((long)nums1[i]*nums1[j]);\\n                if (st*st == nums1[i]*nums1[j]) {\\n                    ans +=b[st];\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        return singleNumTriplets(nums1,nums2) + singleNumTriplets(nums2,nums1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int singleNumTriplets(int[] nums1, int[] nums2) {\\n        int[] b = new int[100001];\\n        for (int i = 0; i < nums2.length; i++) {\\n            b[nums2[i]]++;\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < nums1.length - 1; i++) {\\n            for (int j = i + 1; j < nums1.length; j++) {\\n                int st = (int)Math.sqrt((long)nums1[i]*nums1[j]);\\n                if (st*st == nums1[i]*nums1[j]) {\\n                    ans +=b[st];\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        return singleNumTriplets(nums1,nums2) + singleNumTriplets(nums2,nums1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1150155,
                "title": "javascript-faster-than-50",
                "content": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar numTriplets = function(numsA, numsB) {\\n    function addToMap(val, map) {\\n        map.set(val, 1 + (map.get(val) || 0))\\n    }\\n    \\n    const mapProductsA = new Map()\\n    const mapSquaresA = new Map()\\n    const mapProductsB = new Map()\\n    const mapSquaresB = new Map()\\n    \\n    \\n    for (const val of numsA.values())\\n        addToMap(val ** 2, mapSquaresA)\\n    for (const val of numsB.values())\\n        addToMap(val ** 2, mapSquaresB)\\n    \\n    for (let i = 0, len = numsA.length; i < len; i++) {\\n        const valI = numsA[i]\\n        for (let j = 1 + i; j < len; j++) {\\n            const valJ = numsA[j]\\n            const product = valI * valJ\\n            addToMap(product, mapProductsA)\\n        }\\n    }\\n    \\n    for (let i = 0, len = numsB.length; i < len; i++) {\\n        const valI = numsB[i]\\n        for (let j = 1 + i; j < len; j++) {\\n            const valJ = numsB[j]\\n            const product = valI * valJ\\n            addToMap(product, mapProductsB)\\n        }\\n    }\\n    \\n    \\n    let result = 0\\n    for (const [squareA, countA] of mapSquaresA.entries()) {\\n        const countB = mapProductsB.get(squareA) || 0\\n        let outcome = countA * countB\\n        result += outcome\\n    }\\n    for (const [squareB, countB] of mapSquaresB.entries()) {\\n        const countA = mapProductsA.get(squareB) || 0\\n        let outcome = countB * countA\\n        result += outcome\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar numTriplets = function(numsA, numsB) {\\n    function addToMap(val, map) {\\n        map.set(val, 1 + (map.get(val) || 0))\\n    }\\n    \\n    const mapProductsA = new Map()\\n    const mapSquaresA = new Map()\\n    const mapProductsB = new Map()\\n    const mapSquaresB = new Map()\\n    \\n    \\n    for (const val of numsA.values())\\n        addToMap(val ** 2, mapSquaresA)\\n    for (const val of numsB.values())\\n        addToMap(val ** 2, mapSquaresB)\\n    \\n    for (let i = 0, len = numsA.length; i < len; i++) {\\n        const valI = numsA[i]\\n        for (let j = 1 + i; j < len; j++) {\\n            const valJ = numsA[j]\\n            const product = valI * valJ\\n            addToMap(product, mapProductsA)\\n        }\\n    }\\n    \\n    for (let i = 0, len = numsB.length; i < len; i++) {\\n        const valI = numsB[i]\\n        for (let j = 1 + i; j < len; j++) {\\n            const valJ = numsB[j]\\n            const product = valI * valJ\\n            addToMap(product, mapProductsB)\\n        }\\n    }\\n    \\n    \\n    let result = 0\\n    for (const [squareA, countA] of mapSquaresA.entries()) {\\n        const countB = mapProductsB.get(squareA) || 0\\n        let outcome = countA * countB\\n        result += outcome\\n    }\\n    for (const [squareB, countB] of mapSquaresB.entries()) {\\n        const countA = mapProductsA.get(squareB) || 0\\n        let outcome = countB * countA\\n        result += outcome\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1127152,
                "title": "python-super-brute-force-solution",
                "content": "\\tn1, n2 = len(nums1), len(nums2)\\n\\th1, h2 = {}, {}\\n\\tresult = 0\\n\\tfor i in range(n1):\\n\\t\\tfor j in range(i + 1, n1):\\n\\t\\t\\tp = nums1[i] * nums1[j]\\n\\t\\t\\th1[p] = h1.get(p, 0) + 1\\n\\tfor num in nums2:\\n\\t\\tp = num * num\\n\\t\\tif h1.get(p):\\n\\t\\t\\tresult += h1[p]\\n\\tfor i in range(n2):\\n\\t\\tfor j in range(i + 1, n2):\\n\\t\\t\\tp = nums2[i] * nums2[j]\\n\\t\\t\\th2[p] = h2.get(p, 0) + 1\\n\\tfor num in nums1:\\n\\t\\tp = num * num\\n\\t\\tif h2.get(p):\\n\\t\\t\\tresult += h2[p]\\n\\treturn result",
                "solutionTags": [],
                "code": "\\tn1, n2 = len(nums1), len(nums2)\\n\\th1, h2 = {}, {}\\n\\tresult = 0\\n\\tfor i in range(n1):\\n\\t\\tfor j in range(i + 1, n1):\\n\\t\\t\\tp = nums1[i] * nums1[j]\\n\\t\\t\\th1[p] = h1.get(p, 0) + 1\\n\\tfor num in nums2:\\n\\t\\tp = num * num\\n\\t\\tif h1.get(p):\\n\\t\\t\\tresult += h1[p]\\n\\tfor i in range(n2):\\n\\t\\tfor j in range(i + 1, n2):\\n\\t\\t\\tp = nums2[i] * nums2[j]\\n\\t\\t\\th2[p] = h2.get(p, 0) + 1\\n\\tfor num in nums1:\\n\\t\\tp = num * num\\n\\t\\tif h2.get(p):\\n\\t\\t\\tresult += h2[p]\\n\\treturn result",
                "codeTag": "Unknown"
            },
            {
                "id": 1026856,
                "title": "python3-3-lines-easy-solution",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        C1, C2 = Counter(x*x for x in nums1), Counter(x*x for x in nums2)\\n        f = lambda A, C: sum(C[A[i]*A[j]] for i in range(len(A)) for j in range(i+1, len(A)))\\n        return f(nums1, C2) + f(nums2, C1)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        C1, C2 = Counter(x*x for x in nums1), Counter(x*x for x in nums2)\\n        f = lambda A, C: sum(C[A[i]*A[j]] for i in range(len(A)) for j in range(i+1, len(A)))\\n        return f(nums1, C2) + f(nums2, C1)",
                "codeTag": "Java"
            },
            {
                "id": 1025055,
                "title": "c-13-line",
                "content": "```\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return help(nums1, nums2) + help(nums2, nums1);\\n    }\\n    \\n    int help(vector<int>& v, vector<int>& u){\\n        unordered_map<long,int> mp1, mp2;\\n        for(auto x:v) mp1[long(x)*x]++;\\n        for(auto x:u) mp2[x]++;\\n        int res = 0;\\n        for(auto x:u){\\n            for(auto [y, cnt] : mp1){\\n                if(y % x !=0) continue;\\n                res += cnt * (mp2[y/x] - (x == y/x));\\n            }\\n        }\\n        return res/2;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return help(nums1, nums2) + help(nums2, nums1);\\n    }\\n    \\n    int help(vector<int>& v, vector<int>& u){\\n        unordered_map<long,int> mp1, mp2;\\n        for(auto x:v) mp1[long(x)*x]++;\\n        for(auto x:u) mp2[x]++;\\n        int res = 0;\\n        for(auto x:u){\\n            for(auto [y, cnt] : mp1){\\n                if(y % x !=0) continue;\\n                res += cnt * (mp2[y/x] - (x == y/x));\\n            }\\n        }\\n        return res/2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1020379,
                "title": "c-c-o-mn-with-explanation-translated-to-c",
                "content": "This is my translation of [C++ O(MN) with explanation](https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/discuss/831519/C%2B%2B-O(MN)-with-explanation) into C.\\n\\nWhat a difference a language makes!  In C, you have to do _a lot_ of things by hand.  (FWIW, this is the fastest C implementation so far.)\\n\\n```c\\n/* Approach copied from\\n *   https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/discuss/831519/C%2B%2B-O(MN)-with-explanation\\n *\\n */\\n\\n#include <search.h>\\n\\n/* We need a NUL-terminated key to use with the hash table.  This integer\\n * representation is faster to calculate than calling sprintf().\\n */\\nstatic void\\nint2key (int v, char key[8])\\n{\\n    /* Assumption key is non-negative */\\n    key[0] = 0x80 | (v >> 28);\\n    key[1] = 0x80 | (v >> 21);\\n    key[2] = 0x80 | (v >> 14);\\n    key[3] = 0x80 | (v >> 7);\\n    key[4] = 0x80 | (v >> 0);\\n    key[5] = 0; /* NUL byte needed for termination */\\n}\\n\\nstruct elem\\n{\\n    int         num;        /* Original number */\\n    unsigned    count;      /* Number of occurrences */\\n    char        key[8];     /* NUL-terminated representation of `num\\' */\\n};\\n\\n/* Constraints: */\\n#define MAX_ELEMS 1000\\n#define MAX_NUM 100000\\n\\n#define DEBUG 0\\n\\n\\nstatic int\\nlookup_freq (int v)\\n{\\n    char key[8];\\n    ENTRY *entry;\\n    \\n    int2key(v, key);\\n    entry = hsearch((ENTRY) { .key = key, }, FIND);\\n    if (entry)\\n        return ((struct elem *) entry->data)->count;\\n    else\\n        return 0;\\n}\\n\\n\\nstatic int\\ncount (const int *a, int a_count, const int *b, int b_count)\\n{\\n    /* XXX assume all allocations are successul */\\n    struct elem *elems, *el;\\n    ENTRY *entry;\\n    unsigned n_elems, j;\\n    long target, square;\\n    char key[8];\\n    int i, count;\\n    \\n    if (DEBUG)\\n        printf(\"called %s\\\\n\", __func__);\\n    \\n    /* Calculate frequency table */\\n    elems = malloc(sizeof(elems[0]) * MAX_ELEMS);\\n    n_elems = 0;\\n    hcreate(MAX_ELEMS);\\n    for (i = 0; i < b_count; ++i)\\n    {\\n        el = &elems[n_elems];\\n        int2key(b[i], el->key);\\n        entry = hsearch((ENTRY) { .key = el->key, .data = el}, ENTER);\\n        /* again, assume success */\\n        if (entry->data == el)\\n        {\\n            if (DEBUG)\\n                printf(\"new element for %d\\\\n\", b[i]);\\n            el->count = 1;\\n            el->num = b[i];\\n            ++n_elems;\\n        }\\n        else\\n            ++((struct elem *) entry->data)->count;\\n    }\\n    \\n    count = 0;\\n    for (i = 0; i < a_count; ++i)\\n    {\\n        square = (long) a[i] * (long) a[i];\\n        if (DEBUG)\\n            printf(\"square: %ld\\\\n\", square);\\n        for (j = 0; j < n_elems; ++j)\\n        {\\n            if (DEBUG)\\n                printf(\"elems[%u] = { num: %d, count: %u }\\\\n\", j, elems[j].num, elems[j].count);\\n            if (square % elems[j].num)\\n                continue;\\n            target = square / elems[j].num;\\n            if (target > MAX_NUM)\\n                continue;\\n            int2key((int) target, key);\\n            entry = hsearch((ENTRY) { .key = key, }, FIND);\\n            if (entry)\\n            {\\n                el = entry->data;\\n                if (target == elems[j].num)\\n                    count += el->count * (el->count - 1);\\n                else\\n                    count += el->count * lookup_freq(square / target);\\n                if (DEBUG)\\n                    printf(\"found target %ld, new count: %d\\\\n\", target, count);\\n            }\\n            else if (DEBUG)\\n                printf(\"did not find target %ld\\\\n\", target);\\n        }\\n    }\\n    \\n    hdestroy();\\n    free(elems);\\n    \\n    return count / 2;\\n}\\n\\nint numTriplets(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    return count(nums1, nums1Size, nums2, nums2Size)\\n         + count(nums2, nums2Size, nums1, nums1Size);\\n}\\n```",
                "solutionTags": [],
                "code": "```c\\n/* Approach copied from\\n *   https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/discuss/831519/C%2B%2B-O(MN)-with-explanation\\n *\\n */\\n\\n#include <search.h>\\n\\n/* We need a NUL-terminated key to use with the hash table.  This integer\\n * representation is faster to calculate than calling sprintf().\\n */\\nstatic void\\nint2key (int v, char key[8])\\n{\\n    /* Assumption key is non-negative */\\n    key[0] = 0x80 | (v >> 28);\\n    key[1] = 0x80 | (v >> 21);\\n    key[2] = 0x80 | (v >> 14);\\n    key[3] = 0x80 | (v >> 7);\\n    key[4] = 0x80 | (v >> 0);\\n    key[5] = 0; /* NUL byte needed for termination */\\n}\\n\\nstruct elem\\n{\\n    int         num;        /* Original number */\\n    unsigned    count;      /* Number of occurrences */\\n    char        key[8];     /* NUL-terminated representation of `num\\' */\\n};\\n\\n/* Constraints: */\\n#define MAX_ELEMS 1000\\n#define MAX_NUM 100000\\n\\n#define DEBUG 0\\n\\n\\nstatic int\\nlookup_freq (int v)\\n{\\n    char key[8];\\n    ENTRY *entry;\\n    \\n    int2key(v, key);\\n    entry = hsearch((ENTRY) { .key = key, }, FIND);\\n    if (entry)\\n        return ((struct elem *) entry->data)->count;\\n    else\\n        return 0;\\n}\\n\\n\\nstatic int\\ncount (const int *a, int a_count, const int *b, int b_count)\\n{\\n    /* XXX assume all allocations are successul */\\n    struct elem *elems, *el;\\n    ENTRY *entry;\\n    unsigned n_elems, j;\\n    long target, square;\\n    char key[8];\\n    int i, count;\\n    \\n    if (DEBUG)\\n        printf(\"called %s\\\\n\", __func__);\\n    \\n    /* Calculate frequency table */\\n    elems = malloc(sizeof(elems[0]) * MAX_ELEMS);\\n    n_elems = 0;\\n    hcreate(MAX_ELEMS);\\n    for (i = 0; i < b_count; ++i)\\n    {\\n        el = &elems[n_elems];\\n        int2key(b[i], el->key);\\n        entry = hsearch((ENTRY) { .key = el->key, .data = el}, ENTER);\\n        /* again, assume success */\\n        if (entry->data == el)\\n        {\\n            if (DEBUG)\\n                printf(\"new element for %d\\\\n\", b[i]);\\n            el->count = 1;\\n            el->num = b[i];\\n            ++n_elems;\\n        }\\n        else\\n            ++((struct elem *) entry->data)->count;\\n    }\\n    \\n    count = 0;\\n    for (i = 0; i < a_count; ++i)\\n    {\\n        square = (long) a[i] * (long) a[i];\\n        if (DEBUG)\\n            printf(\"square: %ld\\\\n\", square);\\n        for (j = 0; j < n_elems; ++j)\\n        {\\n            if (DEBUG)\\n                printf(\"elems[%u] = { num: %d, count: %u }\\\\n\", j, elems[j].num, elems[j].count);\\n            if (square % elems[j].num)\\n                continue;\\n            target = square / elems[j].num;\\n            if (target > MAX_NUM)\\n                continue;\\n            int2key((int) target, key);\\n            entry = hsearch((ENTRY) { .key = key, }, FIND);\\n            if (entry)\\n            {\\n                el = entry->data;\\n                if (target == elems[j].num)\\n                    count += el->count * (el->count - 1);\\n                else\\n                    count += el->count * lookup_freq(square / target);\\n                if (DEBUG)\\n                    printf(\"found target %ld, new count: %d\\\\n\", target, count);\\n            }\\n            else if (DEBUG)\\n                printf(\"did not find target %ld\\\\n\", target);\\n        }\\n    }\\n    \\n    hdestroy();\\n    free(elems);\\n    \\n    return count / 2;\\n}\\n\\nint numTriplets(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    return count(nums1, nums1Size, nums2, nums2Size)\\n         + count(nums2, nums2Size, nums1, nums1Size);\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1019760,
                "title": "go-68ms-easy-solution",
                "content": "```\\nfunc gen(nums []int) map[int]int {\\n\\tm := make(map[int]int)\\n\\tfor i := 0; i < len(nums)-1; i++ {\\n\\t\\tfor y := i + 1; y < len(nums); y++ {\\n\\t\\t\\tm[nums[i]*nums[y]]++\\n\\t\\t}\\n\\t}\\n\\treturn m\\n}\\n\\nfunc find(m map[int]int, nums int) int {\\n\\treturn m[nums]\\n}\\n\\nfunc numTriplets(nums1 []int, nums2 []int) int {\\n\\tm1, m2 := gen(nums1), gen(nums2)\\n\\n\\tvar c int\\n\\tfor i := 0; i < len(nums1); i++ {\\n\\t\\tc += find(m2, nums1[i]*nums1[i])\\n\\t}\\n\\n\\tfor i := 0; i < len(nums2); i++ {\\n\\t\\tc += find(m1, nums2[i]*nums2[i])\\n\\t}\\n\\treturn c\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc gen(nums []int) map[int]int {\\n\\tm := make(map[int]int)\\n\\tfor i := 0; i < len(nums)-1; i++ {\\n\\t\\tfor y := i + 1; y < len(nums); y++ {\\n\\t\\t\\tm[nums[i]*nums[y]]++\\n\\t\\t}\\n\\t}\\n\\treturn m\\n}\\n\\nfunc find(m map[int]int, nums int) int {\\n\\treturn m[nums]\\n}\\n\\nfunc numTriplets(nums1 []int, nums2 []int) int {\\n\\tm1, m2 := gen(nums1), gen(nums2)\\n\\n\\tvar c int\\n\\tfor i := 0; i < len(nums1); i++ {\\n\\t\\tc += find(m2, nums1[i]*nums1[i])\\n\\t}\\n\\n\\tfor i := 0; i < len(nums2); i++ {\\n\\t\\tc += find(m1, nums2[i]*nums2[i])\\n\\t}\\n\\treturn c\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1019725,
                "title": "c-260ms-55-100ms-63-two-solution-very-easy-to-anderstand-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n      int ans = 0;\\n      unordered_map<long,int> st1;                   //for all products for arr1\\n      unordered_map<long,int> st2;                   //for all products for arr2\\n      \\n      for(int i = 0; i < nums1.size(); i++)              //contain all products from arr1 to hash\\n        for(int j = i + 1; j < nums1.size(); j++){\\n          long t = long(nums1[i])*nums1[j];\\n          if(st1.count(t)) st1[t]++;\\n          else st1[t] = 1;\\n        }\\n      \\n      for(int i = 0; i < nums2.size(); i++)                  //contain all products from arr2 to hash\\n        for(int j = i + 1; j < nums2.size(); j++){\\n          long t = long(nums2[i])*nums2[j];\\n          if(st2.count(t)) st2[t]++;\\n          else st2[t] = 1;\\n        }\\n      \\n      for(int i = 0; i < nums1.size(); i++){             //and check\\n        long t = long(nums1[i])*nums1[i];\\n        if(st2.count(t)) ans += st2[t];\\n      }\\n      \\n      for(int i = 0; i < nums2.size(); i++){\\n        long t = long(nums2[i])*nums2[i];\\n        if(st1.count(t)) ans += st1[t];\\n      }\\n      \\n      return ans;\\n    }\\n};\\n```\\nif we put in hash squared numbers\\n```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n      int ans = 0;\\n      unordered_map<long,int> st1;\\n      unordered_map<long,int> st2;\\n      \\n      for(int i = 0; i < nums1.size(); i++){\\n        long t = long(nums1[i])*nums1[i];\\n        if(st1.count(t)) st1[t]++;\\n          else st1[t] = 1;\\n      }\\n      \\n      for(int i = 0; i < nums2.size(); i++){\\n        long t = long(nums2[i])*nums2[i];\\n        if(st2.count(t)) st2[t]++;\\n          else st2[t] = 1;\\n      }\\n      \\n      for(int i = 0; i < nums1.size(); i++)\\n        for(int j = i + 1; j < nums1.size(); j++){\\n          long t = long(nums1[i])*nums1[j];\\n          if(st2.count(t)) ans += st2[t];\\n        }\\n      \\n      \\n      for(int i = 0; i < nums2.size(); i++)\\n        for(int j = i + 1; j < nums2.size(); j++){\\n          long t = long(nums2[i])*nums2[j];\\n          if(st1.count(t)) ans += st1[t];\\n        }\\n      \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n      int ans = 0;\\n      unordered_map<long,int> st1;                   //for all products for arr1\\n      unordered_map<long,int> st2;                   //for all products for arr2\\n      \\n      for(int i = 0; i < nums1.size(); i++)              //contain all products from arr1 to hash\\n        for(int j = i + 1; j < nums1.size(); j++){\\n          long t = long(nums1[i])*nums1[j];\\n          if(st1.count(t)) st1[t]++;\\n          else st1[t] = 1;\\n        }\\n      \\n      for(int i = 0; i < nums2.size(); i++)                  //contain all products from arr2 to hash\\n        for(int j = i + 1; j < nums2.size(); j++){\\n          long t = long(nums2[i])*nums2[j];\\n          if(st2.count(t)) st2[t]++;\\n          else st2[t] = 1;\\n        }\\n      \\n      for(int i = 0; i < nums1.size(); i++){             //and check\\n        long t = long(nums1[i])*nums1[i];\\n        if(st2.count(t)) ans += st2[t];\\n      }\\n      \\n      for(int i = 0; i < nums2.size(); i++){\\n        long t = long(nums2[i])*nums2[i];\\n        if(st1.count(t)) ans += st1[t];\\n      }\\n      \\n      return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n      int ans = 0;\\n      unordered_map<long,int> st1;\\n      unordered_map<long,int> st2;\\n      \\n      for(int i = 0; i < nums1.size(); i++){\\n        long t = long(nums1[i])*nums1[i];\\n        if(st1.count(t)) st1[t]++;\\n          else st1[t] = 1;\\n      }\\n      \\n      for(int i = 0; i < nums2.size(); i++){\\n        long t = long(nums2[i])*nums2[i];\\n        if(st2.count(t)) st2[t]++;\\n          else st2[t] = 1;\\n      }\\n      \\n      for(int i = 0; i < nums1.size(); i++)\\n        for(int j = i + 1; j < nums1.size(); j++){\\n          long t = long(nums1[i])*nums1[j];\\n          if(st2.count(t)) ans += st2[t];\\n        }\\n      \\n      \\n      for(int i = 0; i < nums2.size(); i++)\\n        for(int j = i + 1; j < nums2.size(); j++){\\n          long t = long(nums2[i])*nums2[j];\\n          if(st1.count(t)) ans += st1[t];\\n        }\\n      \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011388,
                "title": "c-99-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int a[100001]={0};\\n        int b[100001]={0};\\n        for(int i=0;i<nums1.size();i++)\\n            a[nums1[i]]++;\\n        for(int j=0;j<nums2.size();j++)\\n            b[nums2[j]]++;\\n             \\n        vector<int>::iterator ip;     \\n        ip=unique(nums1.begin(),nums1.end());\\n        nums1.resize(distance(nums1.begin(),ip));\\n        ip=unique(nums2.begin(),nums2.end());\\n        nums2.resize(distance(nums2.begin(),ip));\\n        \\n        int ans=0;\\n        for(int i=0;i<nums1.size();i++)\\n             {\\n                 int start=0,end=nums2.size()-1;\\n                 while(start<=end)\\n                 {\\n                     if(start==end)\\n                     {\\n                         if(nums2[start]==nums1[i] )\\n                         ans+=a[nums1[i]]*((b[nums2[start]]*(b[nums2[start]]-1))/2);\\n                         start++;\\n                     }\\n                     else if(nums1[i]* 1ll *nums1[i]==nums2[start]* 1ll *nums2[end])\\n                     {\\n                         ans+=a[nums1[i]]*b[nums2[start]]*b[nums2[end]];\\n                         start++;\\n                         end--;\\n                     }\\n                     else if(nums1[i]* 1ll *nums1[i]<nums2[start]* 1ll *nums2[end])\\n                         end--;\\n                     else start++;\\n                 }\\n             }\\n        // cout<<ans<<\" \";\\n          for(int i=0;i<nums2.size();i++)\\n             {\\n                 int start=0,end=nums1.size()-1;\\n                 while(start<=end)\\n                 {\\n                     if(start==end)\\n                     {\\n                         if(nums1[start]==nums2[i])\\n                         ans+=b[nums2[i]]*((a[nums1[start]]*(a[nums1[start]]-1))/2);\\n                         start++;\\n                     }\\n                     else if(nums2[i]* 1ll *nums2[i]==nums1[start]* 1ll *nums1[end])\\n                     {\\n                         ans+=b[nums2[i]]*a[nums1[start]]*a[nums1[end]];\\n                         start++;\\n                         end--;\\n                     }\\n                     else if(nums2[i]* 1ll *nums2[i]<nums1[start]* 1ll *nums1[end])\\n                         end--;\\n                     else start++;\\n                 }\\n             }   \\n             return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int a[100001]={0};\\n        int b[100001]={0};\\n        for(int i=0;i<nums1.size();i++)\\n            a[nums1[i]]++;\\n        for(int j=0;j<nums2.size();j++)\\n            b[nums2[j]]++;\\n             \\n        vector<int>::iterator ip;     \\n        ip=unique(nums1.begin(),nums1.end());\\n        nums1.resize(distance(nums1.begin(),ip));\\n        ip=unique(nums2.begin(),nums2.end());\\n        nums2.resize(distance(nums2.begin(),ip));\\n        \\n        int ans=0;\\n        for(int i=0;i<nums1.size();i++)\\n             {\\n                 int start=0,end=nums2.size()-1;\\n                 while(start<=end)\\n                 {\\n                     if(start==end)\\n                     {\\n                         if(nums2[start]==nums1[i] )\\n                         ans+=a[nums1[i]]*((b[nums2[start]]*(b[nums2[start]]-1))/2);\\n                         start++;\\n                     }\\n                     else if(nums1[i]* 1ll *nums1[i]==nums2[start]* 1ll *nums2[end])\\n                     {\\n                         ans+=a[nums1[i]]*b[nums2[start]]*b[nums2[end]];\\n                         start++;\\n                         end--;\\n                     }\\n                     else if(nums1[i]* 1ll *nums1[i]<nums2[start]* 1ll *nums2[end])\\n                         end--;\\n                     else start++;\\n                 }\\n             }\\n        // cout<<ans<<\" \";\\n          for(int i=0;i<nums2.size();i++)\\n             {\\n                 int start=0,end=nums1.size()-1;\\n                 while(start<=end)\\n                 {\\n                     if(start==end)\\n                     {\\n                         if(nums1[start]==nums2[i])\\n                         ans+=b[nums2[i]]*((a[nums1[start]]*(a[nums1[start]]-1))/2);\\n                         start++;\\n                     }\\n                     else if(nums2[i]* 1ll *nums2[i]==nums1[start]* 1ll *nums1[end])\\n                     {\\n                         ans+=b[nums2[i]]*a[nums1[start]]*a[nums1[end]];\\n                         start++;\\n                         end--;\\n                     }\\n                     else if(nums2[i]* 1ll *nums2[i]<nums1[start]* 1ll *nums1[end])\\n                         end--;\\n                     else start++;\\n                 }\\n             }   \\n             return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1010182,
                "title": "c-2sum-like-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int func(vector<int>& nums1, vector<int>& nums2){\\n        int ret = 0;\\n        for(int i=0; i<nums1.size(); i++){\\n            int left = 0;\\n            int right = nums2.size()-1;\\n            long cur1 = (long)nums1[i] * (long)nums1[i];\\n            while(left <= right){\\n                long cur2 = (long)nums2[left] * (long)nums2[right];\\n                if(cur2 < cur1){\\n                    left++;\\n                }\\n                else if(cur2 > cur1){\\n                    right--;\\n                }\\n                else{\\n                    int lcnt = 1;\\n                    int rcnt = 1;\\n                    while(left+1 < nums2.size() && nums2[left] == nums2[left+1]){\\n                        lcnt++;\\n                        left++;\\n                    }\\n                    while(right-1 >= 0 && nums2[right] == nums2[right-1]){\\n                        rcnt++;\\n                        right--;\\n                    }\\n                    \\n                    if(nums2[left] != nums2[right]) ret += lcnt*rcnt;\\n                    else ret += lcnt*(rcnt-1)/2;\\n                    left++;\\n                    right--;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        return func(nums1,nums2)+func(nums2,nums1);\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(vector<int>& nums1, vector<int>& nums2){\\n        int ret = 0;\\n        for(int i=0; i<nums1.size(); i++){\\n            int left = 0;\\n            int right = nums2.size()-1;\\n            long cur1 = (long)nums1[i] * (long)nums1[i];\\n            while(left <= right){\\n                long cur2 = (long)nums2[left] * (long)nums2[right];\\n                if(cur2 < cur1){\\n                    left++;\\n                }\\n                else if(cur2 > cur1){\\n                    right--;\\n                }\\n                else{\\n                    int lcnt = 1;\\n                    int rcnt = 1;\\n                    while(left+1 < nums2.size() && nums2[left] == nums2[left+1]){\\n                        lcnt++;\\n                        left++;\\n                    }\\n                    while(right-1 >= 0 && nums2[right] == nums2[right-1]){\\n                        rcnt++;\\n                        right--;\\n                    }\\n                    \\n                    if(nums2[left] != nums2[right]) ret += lcnt*rcnt;\\n                    else ret += lcnt*(rcnt-1)/2;\\n                    left++;\\n                    right--;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        return func(nums1,nums2)+func(nums2,nums1);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997380,
                "title": "c-short-solution",
                "content": "Run-time is `O(N^2)`, space is `O(N)`.\\n\\n```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return count(nums1, nums2) + count(nums2, nums1);\\n    }\\n    \\n    int count(std::vector<int>& a, std::vector<int>& b) {\\n        std::unordered_map<int64_t,int> m;\\n        for(const auto &n: a) ++m[(int64_t)n*n];\\n        int count{0};\\n        for(int i{0}, size{(int)b.size()}; i < size; ++i)\\n            for(int j{i+1}; j < size; ++j)\\n                if(m.count((int64_t)b[i]*b[j])) count += m[(int64_t)b[i]*b[j]];\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return count(nums1, nums2) + count(nums2, nums1);\\n    }\\n    \\n    int count(std::vector<int>& a, std::vector<int>& b) {\\n        std::unordered_map<int64_t,int> m;\\n        for(const auto &n: a) ++m[(int64_t)n*n];\\n        int count{0};\\n        for(int i{0}, size{(int)b.size()}; i < size; ++i)\\n            for(int j{i+1}; j < size; ++j)\\n                if(m.count((int64_t)b[i]*b[j])) count += m[(int64_t)b[i]*b[j]];\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992805,
                "title": "p23-5",
                "content": "Like two su\\nLike two sum",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 990567,
                "title": "rust-68-ms-beats-100-of-solutions",
                "content": "```\\nimpl Solution {\\n    pub fn num_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n         let mut ans = 0;\\n    let n1 = nums1.len();\\n    let n2 = nums2.len();\\n    let mut nums1_product: std::collections::HashMap<i64, i32> = std::collections::HashMap::new();\\n    let mut nums2_product: std::collections::HashMap<i64, i32> = std::collections::HashMap::new();\\n    for i in 0..n1 {\\n        for j in i + 1..n1 {\\n            let count = nums1_product.entry(nums1[i] as i64 * nums1[j] as i64).or_insert(0);\\n            *count += 1;\\n        }\\n    }\\n    for i in 0..n2 {\\n        for j in i + 1..n2 {\\n            let count = nums2_product.entry(nums2[i] as i64 * nums2[j] as i64).or_insert(0);\\n            *count += 1;\\n        }\\n    }\\n    for num in nums1 {\\n        let num = num as i64;\\n        let target = num.pow(2);\\n        if let Some(value) = nums2_product.get(&target) {\\n            ans += value;\\n        }\\n    }\\n    for num in nums2 {\\n        let num = num as i64;\\n        let target = num.pow(2);\\n        if let Some(value) = nums1_product.get(&target) {\\n            ans += value;\\n        }\\n    }\\n    ans\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn num_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n         let mut ans = 0;\\n    let n1 = nums1.len();\\n    let n2 = nums2.len();\\n    let mut nums1_product: std::collections::HashMap<i64, i32> = std::collections::HashMap::new();\\n    let mut nums2_product: std::collections::HashMap<i64, i32> = std::collections::HashMap::new();\\n    for i in 0..n1 {\\n        for j in i + 1..n1 {\\n            let count = nums1_product.entry(nums1[i] as i64 * nums1[j] as i64).or_insert(0);\\n            *count += 1;\\n        }\\n    }\\n    for i in 0..n2 {\\n        for j in i + 1..n2 {\\n            let count = nums2_product.entry(nums2[i] as i64 * nums2[j] as i64).or_insert(0);\\n            *count += 1;\\n        }\\n    }\\n    for num in nums1 {\\n        let num = num as i64;\\n        let target = num.pow(2);\\n        if let Some(value) = nums2_product.get(&target) {\\n            ans += value;\\n        }\\n    }\\n    for num in nums2 {\\n        let num = num as i64;\\n        let target = num.pow(2);\\n        if let Some(value) = nums1_product.get(&target) {\\n            ans += value;\\n        }\\n    }\\n    ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 976084,
                "title": "my-c-solution-using-two-pointers",
                "content": "```\\n#define REP(i, n) for(int i = 0; i < n; i++)\\n#define REPP(i, n) for(int i = 1; i <= n; i++)\\n#define ALL(obj) (obj).begin(), (obj).end()\\n\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        sort(ALL(nums1)); sort(ALL(nums2));\\n        ans += helper(nums1, nums2);\\n        ans += helper(nums2, nums1);\\n        return ans;       \\n    }\\n    \\n    int helper(vector<int>& nums1, vector<int>& nums2){\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        int res = 0;\\n        REP(i, n1){\\n            long target = (long)nums1[i] * (long)nums1[i];\\n            int l = 0, r = n2 - 1;\\n            while(l <= r){\\n                long now = (long)nums2[l] * (long)nums2[r];\\n                if(now < target){\\n                    l++;\\n                    continue;\\n                }else if(now > target){\\n                    r--;\\n                    continue;\\n                }\\n                int lcnt = 0, rcnt = 0;\\n                int lv = nums2[l], rv = nums2[r];\\n                while(l < n2 && nums2[l] == lv){\\n                    l++;\\n                    lcnt++;\\n                }\\n                while(r >= 0 && nums2[r] == rv){\\n                    r--;\\n                    rcnt++;\\n                }\\n                if(lv != rv) res += lcnt * rcnt;\\n                else res += (lcnt * (rcnt - 1)) / 2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n#define REP(i, n) for(int i = 0; i < n; i++)\\n#define REPP(i, n) for(int i = 1; i <= n; i++)\\n#define ALL(obj) (obj).begin(), (obj).end()\\n\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        sort(ALL(nums1)); sort(ALL(nums2));\\n        ans += helper(nums1, nums2);\\n        ans += helper(nums2, nums1);\\n        return ans;       \\n    }\\n    \\n    int helper(vector<int>& nums1, vector<int>& nums2){\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        int res = 0;\\n        REP(i, n1){\\n            long target = (long)nums1[i] * (long)nums1[i];\\n            int l = 0, r = n2 - 1;\\n            while(l <= r){\\n                long now = (long)nums2[l] * (long)nums2[r];\\n                if(now < target){\\n                    l++;\\n                    continue;\\n                }else if(now > target){\\n                    r--;\\n                    continue;\\n                }\\n                int lcnt = 0, rcnt = 0;\\n                int lv = nums2[l], rv = nums2[r];\\n                while(l < n2 && nums2[l] == lv){\\n                    l++;\\n                    lcnt++;\\n                }\\n                while(r >= 0 && nums2[r] == rv){\\n                    r--;\\n                    rcnt++;\\n                }\\n                if(lv != rv) res += lcnt * rcnt;\\n                else res += (lcnt * (rcnt - 1)) / 2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960288,
                "title": "java-solution-not-a-good-problem",
                "content": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n         int res = 0;   \\n        \\n         res += findTriplesHelper(nums1, nums2);\\n         res += findTriplesHelper(nums2, nums1);\\n         return res;\\n    }\\n    \\n    \\n    public int findTriplesHelper(int[] nums1, int[] nums2){\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int ele: nums2){\\n            map.put(ele, map.getOrDefault(ele,0)+1);\\n        }\\n        \\n        \\n        int res = 0;\\n        \\n        for(int i=0;i<nums1.length;i++){\\n            long temp = (long)nums1[i]*(long)nums1[i];\\n            Set<Integer> set = new HashSet<>();\\n            for(Integer key: map.keySet()){\\n                if(set.contains(key)){\\n                    continue;\\n                }\\n                set.add(key);\\n                if(temp%key==0 && map.containsKey((int)(temp/key))){\\n  \\n                    if((int)(temp/key)!=key){\\n                       res += map.get(key) * map.get((int)(temp/key));\\n                       set.add((int)(temp/key));\\n                    }else{\\n                        res += map.get(key)*(map.get(key)-1)/2;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n         int res = 0;   \\n        \\n         res += findTriplesHelper(nums1, nums2);\\n         res += findTriplesHelper(nums2, nums1);\\n         return res;\\n    }\\n    \\n    \\n    public int findTriplesHelper(int[] nums1, int[] nums2){\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int ele: nums2){\\n            map.put(ele, map.getOrDefault(ele,0)+1);\\n        }\\n        \\n        \\n        int res = 0;\\n        \\n        for(int i=0;i<nums1.length;i++){\\n            long temp = (long)nums1[i]*(long)nums1[i];\\n            Set<Integer> set = new HashSet<>();\\n            for(Integer key: map.keySet()){\\n                if(set.contains(key)){\\n                    continue;\\n                }\\n                set.add(key);\\n                if(temp%key==0 && map.containsKey((int)(temp/key))){\\n  \\n                    if((int)(temp/key)!=key){\\n                       res += map.get(key) * map.get((int)(temp/key));\\n                       set.add((int)(temp/key));\\n                    }else{\\n                        res += map.get(key)*(map.get(key)-1)/2;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937040,
                "title": "python-o-n-2",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        product1 = collections.defaultdict(int)\\n        for i in range(len(nums1)):\\n            for j in range(i+1, len(nums1)):\\n                product1[nums1[i] * nums1[j]] += 1\\n        product2 = collections.defaultdict(int)\\n        for i in range(len(nums2)):\\n            for j in range(i+1, len(nums2)):\\n                product2[nums2[i] * nums2[j]] += 1\\n        count = 0\\n        for num in nums1:\\n            count += product2[num ** 2]\\n        for num in nums2:\\n            count += product1[num ** 2]\\n        return count",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        product1 = collections.defaultdict(int)\\n        for i in range(len(nums1)):\\n            for j in range(i+1, len(nums1)):\\n                product1[nums1[i] * nums1[j]] += 1\\n        product2 = collections.defaultdict(int)\\n        for i in range(len(nums2)):\\n            for j in range(i+1, len(nums2)):\\n                product2[nums2[i] * nums2[j]] += 1\\n        count = 0\\n        for num in nums1:\\n            count += product2[num ** 2]\\n        for num in nums2:\\n            count += product1[num ** 2]\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 889221,
                "title": "simple-solution",
                "content": "\\tfrom collections import Counter\\n\\tclass Solution(object):\\n\\t\\tdef numTriplets(self, nums1, nums2):\\n\\t\\t\\tans,b,c,n1,n2 = 0, Counter([x**2 for x in nums1]) , Counter([x**2 for x in nums2]), len(nums1), len(nums2)\\n\\n\\t\\t\\tfor i in range(n1-1):\\n\\t\\t\\t\\tfor j in range(i+1,n1):\\n\\t\\t\\t\\t\\tans += c[nums1[i]*nums1[j]]\\n\\n\\t\\t\\tfor i in range(n2-1):\\n\\t\\t\\t\\tfor j in range(i+1,n2):\\n\\t\\t\\t\\t\\tans += b[nums2[i]*nums2[j]]\\n\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "\\tfrom collections import Counter\\n\\tclass Solution(object):\\n\\t\\tdef numTriplets(self, nums1, nums2):\\n\\t\\t\\tans,b,c,n1,n2 = 0, Counter([x**2 for x in nums1]) , Counter([x**2 for x in nums2]), len(nums1), len(nums2)\\n\\n\\t\\t\\tfor i in range(n1-1):\\n\\t\\t\\t\\tfor j in range(i+1,n1):\\n\\t\\t\\t\\t\\tans += c[nums1[i]*nums1[j]]\\n\\n\\t\\t\\tfor i in range(n2-1):\\n\\t\\t\\t\\tfor j in range(i+1,n2):\\n\\t\\t\\t\\t\\tans += b[nums2[i]*nums2[j]]\\n\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 889197,
                "title": "simple-o-n-2",
                "content": "\\tfrom collections import Counter\\n\\timport math\\n\\tclass Solution(object):\\n\\t\\tdef numTriplets(self, nums1, nums2):\\n\\n\\t\\t\\tcount =0\\n\\n\\t\\t\\ta =Counter([float(item) for item in nums1])\\n\\t\\t\\tb = Counter([float(item) for item in nums2])\\n\\t\\t\\t#print(a,b)\\n\\n\\t\\t\\tfor i in range(len(nums1)):\\n\\t\\t\\t\\tfor j in range(i+1,len(nums1)):\\n\\t\\t\\t\\t\\tk  = nums1[i]*nums1[j]\\n\\t\\t\\t\\t\\tx = math.sqrt(k) \\n\\n\\t\\t\\t\\t\\tif x in b:\\n\\t\\t\\t\\t\\t\\tcount += b[x]\\n\\n\\t\\t\\tfor i in range(len(nums2)):\\n\\t\\t\\t\\tfor j in range(i+1,len(nums2)):\\n\\t\\t\\t\\t\\tk  = nums2[i]*nums2[j]\\n\\t\\t\\t\\t\\tx = math.sqrt(k)\\n\\n\\t\\t\\t\\t\\tif x in a:\\n\\t\\t\\t\\t\\t\\tcount += a[x]\\n\\t\\t\\treturn count",
                "solutionTags": [],
                "code": "\\tfrom collections import Counter\\n\\timport math\\n\\tclass Solution(object):\\n\\t\\tdef numTriplets(self, nums1, nums2):\\n\\n\\t\\t\\tcount =0\\n\\n\\t\\t\\ta =Counter([float(item) for item in nums1])\\n\\t\\t\\tb = Counter([float(item) for item in nums2])\\n\\t\\t\\t#print(a,b)\\n\\n\\t\\t\\tfor i in range(len(nums1)):\\n\\t\\t\\t\\tfor j in range(i+1,len(nums1)):\\n\\t\\t\\t\\t\\tk  = nums1[i]*nums1[j]\\n\\t\\t\\t\\t\\tx = math.sqrt(k) \\n\\n\\t\\t\\t\\t\\tif x in b:\\n\\t\\t\\t\\t\\t\\tcount += b[x]\\n\\n\\t\\t\\tfor i in range(len(nums2)):\\n\\t\\t\\t\\tfor j in range(i+1,len(nums2)):\\n\\t\\t\\t\\t\\tk  = nums2[i]*nums2[j]\\n\\t\\t\\t\\t\\tx = math.sqrt(k)\\n\\n\\t\\t\\t\\t\\tif x in a:\\n\\t\\t\\t\\t\\t\\tcount += a[x]\\n\\t\\t\\treturn count",
                "codeTag": "Java"
            },
            {
                "id": 882201,
                "title": "simple-c-o-n-2-brute-force-hash-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long int,int> mp1,mp2;\\n        for(int i=0;i<nums1.size()-1;i++){\\n            for(int j=i+1;j<nums1.size();j++)\\n                mp1[(long)nums1[i]*nums1[j]]++;\\n        }\\n        for(int i=0;i<nums2.size()-1;i++){\\n            for(int j=i+1;j<nums2.size();j++)\\n                mp2[(long)nums2[i]*nums2[j]]++;\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums1.size();i++){\\n            if(mp2.find((long)nums1[i]*nums1[i])!=mp2.end())\\n                ans+=mp2[(long)nums1[i]*nums1[i]];\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            if(mp1.find((long)nums2[i]*nums2[i])!=mp1.end())\\n                ans+=mp1[(long)nums2[i]*nums2[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long int,int> mp1,mp2;\\n        for(int i=0;i<nums1.size()-1;i++){\\n            for(int j=i+1;j<nums1.size();j++)\\n                mp1[(long)nums1[i]*nums1[j]]++;\\n        }\\n        for(int i=0;i<nums2.size()-1;i++){\\n            for(int j=i+1;j<nums2.size();j++)\\n                mp2[(long)nums2[i]*nums2[j]]++;\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums1.size();i++){\\n            if(mp2.find((long)nums1[i]*nums1[i])!=mp2.end())\\n                ans+=mp2[(long)nums1[i]*nums1[i]];\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            if(mp1.find((long)nums2[i]*nums2[i])!=mp1.end())\\n                ans+=mp1[(long)nums2[i]*nums2[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871108,
                "title": "concise-python-solution",
                "content": "```\\ndef numTriplets(self, a1: List[int], a2: List[int]) -> int:        \\n\\tans, m1, m2, n1, n2 = 0, Counter([x**2 for x in a1]), Counter([x**2 for x in a2]), len(a1), len(a2)\\n\\tfor i in range(n1-1):\\n\\t\\tfor j in range(i+1, n1):\\n\\t\\t\\tans += m2[a1[i]*a1[j]]\\n\\tfor i in range(n2-1):\\n\\t\\tfor j in range(i+1, n2):\\n\\t\\t\\tans += m1[a2[i]*a2[j]]\\n\\treturn ans",
                "solutionTags": [],
                "code": "```\\ndef numTriplets(self, a1: List[int], a2: List[int]) -> int:        \\n\\tans, m1, m2, n1, n2 = 0, Counter([x**2 for x in a1]), Counter([x**2 for x in a2]), len(a1), len(a2)\\n\\tfor i in range(n1-1):\\n\\t\\tfor j in range(i+1, n1):\\n\\t\\t\\tans += m2[a1[i]*a1[j]]\\n\\tfor i in range(n2-1):\\n\\t\\tfor j in range(i+1, n2):\\n\\t\\t\\tans += m1[a2[i]*a2[j]]\\n\\treturn ans",
                "codeTag": "Python3"
            },
            {
                "id": 852763,
                "title": "kotlin-easy-clean-solution-100-100",
                "content": "```\\nfun numTriplets(nums1: IntArray, nums2: IntArray): Int {\\n    return numTripletsAux(nums1, nums2) + numTripletsAux(nums2, nums1)\\n}\\n\\nprivate fun numTripletsAux(nums1: IntArray, nums2: IntArray): Int {\\n    val squareCounts = mutableMapOf<Long, Int>()\\n\\n    for (n in nums1) {\\n        val square = n.toLong() * n.toLong()\\n        squareCounts[square] = squareCounts.getOrDefault(square, 0) + 1\\n    }\\n\\n    var count = 0\\n    for (i in nums2.indices) {\\n        for (j in i + 1 until nums2.size) {\\n            count += squareCounts.getOrDefault(nums2[i].toLong() * nums2[j].toLong(), 0)\\n        }\\n    }\\n    return count\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun numTriplets(nums1: IntArray, nums2: IntArray): Int {\\n    return numTripletsAux(nums1, nums2) + numTripletsAux(nums2, nums1)\\n}\\n\\nprivate fun numTripletsAux(nums1: IntArray, nums2: IntArray): Int {\\n    val squareCounts = mutableMapOf<Long, Int>()\\n\\n    for (n in nums1) {\\n        val square = n.toLong() * n.toLong()\\n        squareCounts[square] = squareCounts.getOrDefault(square, 0) + 1\\n    }\\n\\n    var count = 0\\n    for (i in nums2.indices) {\\n        for (j in i + 1 until nums2.size) {\\n            count += squareCounts.getOrDefault(nums2[i].toLong() * nums2[j].toLong(), 0)\\n        }\\n    }\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 846653,
                "title": "c-from-o-m-n-2-n-m-2-to-o-n-2-m-2",
                "content": "```\\npublic class Solution {\\n\\n\\t// TLE Time: O(M*N^2 + N*M^2)\\n    public int NumTripletsBF(int[] nums1, int[] nums2) {\\n\\n        if (nums1 == null || nums2 == null) {\\n            return 0;\\n        }\\n        \\n        var numTriplets = 0;\\n        \\n        // Type 1\\n        for (var i = 0; i < nums1.Length; i++) {\\n            for (var j = 0; j < nums2.Length - 1; j++) {\\n                for (var k = j + 1; k < nums2.Length; k++) {\\n                    var exp1 = (long) Math.Pow(nums1[i], 2);\\n                    var exp2 = (long) nums2[j] * nums2[k];\\n                    if (exp1 == exp2) {\\n                        numTriplets++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // Type 2\\n        for (var i = 0; i < nums2.Length; i++) {\\n            for (var j = 0; j < nums1.Length - 1; j++) {\\n                for (var k = j + 1; k < nums1.Length; k++) {\\n                    var exp1 = (long) Math.Pow(nums2[i], 2);\\n                    var exp2 = (long) nums1[j] * nums1[k];\\n                    if (exp1 == exp2) {\\n                        numTriplets++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return numTriplets;\\n    }    \\n    \\n\\t // Time: O(N^2 + M^2)\\n     public int NumTriplets(int[] nums1, int[] nums2) {\\n\\n         if (nums1 == null || nums2 == null) {\\n            return 0;\\n        }\\n        var numTriplets = 0;\\n        \\n\\t\\t// Outer loop can be replaced by compromising on some space complexity\\n\\t\\t// 2 dictionary will keep the result of the left expression in the equations Type 1/2\\n\\t\\t\\n        var n1iDict = new Dictionary<long, int>(); \\n        var n2iDict = new Dictionary<long, int>(); \\n        for (var i = 0; i < nums1.Length; i++) {\\n            var exp1 = (long) Math.Pow(nums1[i], 2);;\\n            if (!n1iDict.ContainsKey(exp1))\\n                n1iDict.Add(exp1, 0);\\n            n1iDict[exp1]++;\\n        }\\n        for (var i = 0; i < nums2.Length; i++) {\\n            var exp1 = (long) Math.Pow(nums2[i], 2);;\\n            if (!n2iDict.ContainsKey(exp1))\\n                n2iDict.Add(exp1, 0);\\n            n2iDict[exp1]++;\\n        }\\n        \\n        // Type 1\\n        for (var j = 0; j < nums2.Length - 1; j++) {\\n            for (var k = j + 1; k < nums2.Length; k++) {\\n                var exp2 = (long) nums2[j] * nums2[k];\\n                if (n1iDict.ContainsKey(exp2)) {\\n                    numTriplets += n1iDict[exp2];\\n                }\\n            }\\n        }\\n        \\n        // Type 2\\n        for (var j = 0; j < nums1.Length - 1; j++) {\\n            for (var k = j + 1; k < nums1.Length; k++) {\\n                var exp2 = (long) nums1[j] * nums1[k];\\n                if (n2iDict.ContainsKey(exp2)) {\\n                    numTriplets += n2iDict[exp2];\\n                }\\n            }\\n        }\\n        \\n        return numTriplets;\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n\\t// TLE Time: O(M*N^2 + N*M^2)\\n    public int NumTripletsBF(int[] nums1, int[] nums2) {\\n\\n        if (nums1 == null || nums2 == null) {\\n            return 0;\\n        }\\n        \\n        var numTriplets = 0;\\n        \\n        // Type 1\\n        for (var i = 0; i < nums1.Length; i++) {\\n            for (var j = 0; j < nums2.Length - 1; j++) {\\n                for (var k = j + 1; k < nums2.Length; k++) {\\n                    var exp1 = (long) Math.Pow(nums1[i], 2);\\n                    var exp2 = (long) nums2[j] * nums2[k];\\n                    if (exp1 == exp2) {\\n                        numTriplets++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // Type 2\\n        for (var i = 0; i < nums2.Length; i++) {\\n            for (var j = 0; j < nums1.Length - 1; j++) {\\n                for (var k = j + 1; k < nums1.Length; k++) {\\n                    var exp1 = (long) Math.Pow(nums2[i], 2);\\n                    var exp2 = (long) nums1[j] * nums1[k];\\n                    if (exp1 == exp2) {\\n                        numTriplets++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return numTriplets;\\n    }    \\n    \\n\\t // Time: O(N^2 + M^2)\\n     public int NumTriplets(int[] nums1, int[] nums2) {\\n\\n         if (nums1 == null || nums2 == null) {\\n            return 0;\\n        }\\n        var numTriplets = 0;\\n        \\n\\t\\t// Outer loop can be replaced by compromising on some space complexity\\n\\t\\t// 2 dictionary will keep the result of the left expression in the equations Type 1/2\\n\\t\\t\\n        var n1iDict = new Dictionary<long, int>(); \\n        var n2iDict = new Dictionary<long, int>(); \\n        for (var i = 0; i < nums1.Length; i++) {\\n            var exp1 = (long) Math.Pow(nums1[i], 2);;\\n            if (!n1iDict.ContainsKey(exp1))\\n                n1iDict.Add(exp1, 0);\\n            n1iDict[exp1]++;\\n        }\\n        for (var i = 0; i < nums2.Length; i++) {\\n            var exp1 = (long) Math.Pow(nums2[i], 2);;\\n            if (!n2iDict.ContainsKey(exp1))\\n                n2iDict.Add(exp1, 0);\\n            n2iDict[exp1]++;\\n        }\\n        \\n        // Type 1\\n        for (var j = 0; j < nums2.Length - 1; j++) {\\n            for (var k = j + 1; k < nums2.Length; k++) {\\n                var exp2 = (long) nums2[j] * nums2[k];\\n                if (n1iDict.ContainsKey(exp2)) {\\n                    numTriplets += n1iDict[exp2];\\n                }\\n            }\\n        }\\n        \\n        // Type 2\\n        for (var j = 0; j < nums1.Length - 1; j++) {\\n            for (var k = j + 1; k < nums1.Length; k++) {\\n                var exp2 = (long) nums1[j] * nums1[k];\\n                if (n2iDict.ContainsKey(exp2)) {\\n                    numTriplets += n2iDict[exp2];\\n                }\\n            }\\n        }\\n        \\n        return numTriplets;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843709,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        count = 0 \\n        \\n        dic1 = dict()\\n        for num in nums1:\\n            if num in dic1:\\n                dic1[num] += 1\\n            else:\\n                dic1[num] = 1\\n                \\n        dic2 = dict()\\n        for num in nums2:\\n            if num in dic2:\\n                dic2[num] += 1\\n            else:\\n                dic2[num] = 1\\n                     \\n        for num1 in nums1:\\n            square = num1 ** 2\\n            for num2 in nums2:\\n                if square / num2 in dic2:\\n                    if square / num2 == num2:\\n                        count += dic2[square / num2] - 1\\n                    else:\\n                        count += dic2[square / num2]\\n                        \\n        for num2 in nums2:\\n            square = num2 ** 2\\n            for num1 in nums1:\\n                if square / num1 in dic1:\\n                    if square / num1 == num1:\\n                        count += dic1[square / num1] - 1\\n                    else:\\n                        count += dic1[square / num1]\\n                        \\n        return int(count / 2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        count = 0 \\n        \\n        dic1 = dict()\\n        for num in nums1:\\n            if num in dic1:\\n                dic1[num] += 1\\n            else:\\n                dic1[num] = 1\\n                \\n        dic2 = dict()\\n        for num in nums2:\\n            if num in dic2:\\n                dic2[num] += 1\\n            else:\\n                dic2[num] = 1\\n                     \\n        for num1 in nums1:\\n            square = num1 ** 2\\n            for num2 in nums2:\\n                if square / num2 in dic2:\\n                    if square / num2 == num2:\\n                        count += dic2[square / num2] - 1\\n                    else:\\n                        count += dic2[square / num2]\\n                        \\n        for num2 in nums2:\\n            square = num2 ** 2\\n            for num1 in nums1:\\n                if square / num1 in dic1:\\n                    if square / num1 == num1:\\n                        count += dic1[square / num1] - 1\\n                    else:\\n                        count += dic1[square / num1]\\n                        \\n        return int(count / 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843537,
                "title": "c-using-dictionary-build-on-someone-else-s-response-in-discussion",
                "content": "I hope it\\'s allowed if I gave credit? \\nUsed this code for baseline - [User: kanchanapy](https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/discuss/832206/C-solution-using-Dictionary)\\nNow, if anyone could tell me the complexity of time / space on this, that would be great...\\n```\\n\\npublic int NumTriplets(int[] nums1, int[] nums2)\\n\\t\\t{\\n\\t\\t//not sure needs sorting\\n\\t\\t\\tArray.Sort(nums1);\\n\\t\\t\\tArray.Sort(nums2);\\n\\t\\t\\t//run the method to identify  how many triplets formed for each array as the product\\n\\t\\t\\tint c1 = getCount(nums1, nums2);\\n\\t\\t\\tint c2 = getCount(nums2, nums1);\\n\\t\\t\\treturn c1 + c2;\\n\\t\\t}\\n\\n\\t\\tpublic int getCount(int[] nums1, int[] nums2)\\n\\t\\t{\\n\\t\\t\\t//store the product for the first array provided to the method\\n\\t\\t\\tlong product = 0;\\n\\t\\t\\t//how many times the triplet appears in the dictionary\\n\\t\\t\\tint count = 0;\\n\\n\\t\\t\\tDictionary<long, int> d = new Dictionary<long, int>();\\n\\n\\t\\t\\t//calc the product of array1\\n\\t\\t\\tfor (int i = 0, l = nums1.Length; i < l; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tproduct = (long)nums1[i] * (long)nums1[i];\\n\\t\\t\\t\\t//check if already appears in dictionary, if it does, increment valu, if not, create key in dictionary\\n\\t\\t\\t\\tif (d.ContainsKey(product))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\td[product] +=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\td.Add(product, 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t//product of 2 values in second array provided\\n\\t\\t\\tfor (int j = 0, l = nums2.Length; j < l; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int k = 0; k < l; k++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t/// there\\'s a constraint that J must be smaller than k!!!\\n\\t\\t\\t\\t\\tif (j == k || j > k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tproduct = (long)nums2[j] * (long)nums2[k];\\n\\t\\t\\t\\t\\t//find all the products of array1 that correspond to products of array2\\n\\t\\t\\t\\t\\tif (d.ContainsKey(product))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcount += d[product];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}",
                "solutionTags": [],
                "code": "I hope it\\'s allowed if I gave credit? \\nUsed this code for baseline - [User: kanchanapy](https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/discuss/832206/C-solution-using-Dictionary)\\nNow, if anyone could tell me the complexity of time / space on this, that would be great...\\n```\\n\\npublic int NumTriplets(int[] nums1, int[] nums2)\\n\\t\\t{\\n\\t\\t//not sure needs sorting\\n\\t\\t\\tArray.Sort(nums1);\\n\\t\\t\\tArray.Sort(nums2);\\n\\t\\t\\t//run the method to identify  how many triplets formed for each array as the product\\n\\t\\t\\tint c1 = getCount(nums1, nums2);\\n\\t\\t\\tint c2 = getCount(nums2, nums1);\\n\\t\\t\\treturn c1 + c2;\\n\\t\\t}\\n\\n\\t\\tpublic int getCount(int[] nums1, int[] nums2)\\n\\t\\t{\\n\\t\\t\\t//store the product for the first array provided to the method\\n\\t\\t\\tlong product = 0;\\n\\t\\t\\t//how many times the triplet appears in the dictionary\\n\\t\\t\\tint count = 0;\\n\\n\\t\\t\\tDictionary<long, int> d = new Dictionary<long, int>();\\n\\n\\t\\t\\t//calc the product of array1\\n\\t\\t\\tfor (int i = 0, l = nums1.Length; i < l; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tproduct = (long)nums1[i] * (long)nums1[i];\\n\\t\\t\\t\\t//check if already appears in dictionary, if it does, increment valu, if not, create key in dictionary\\n\\t\\t\\t\\tif (d.ContainsKey(product))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\td[product] +=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\td.Add(product, 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t//product of 2 values in second array provided\\n\\t\\t\\tfor (int j = 0, l = nums2.Length; j < l; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int k = 0; k < l; k++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t/// there\\'s a constraint that J must be smaller than k!!!\\n\\t\\t\\t\\t\\tif (j == k || j > k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tproduct = (long)nums2[j] * (long)nums2[k];\\n\\t\\t\\t\\t\\t//find all the products of array1 that correspond to products of array2\\n\\t\\t\\t\\t\\tif (d.ContainsKey(product))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcount += d[product];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 842402,
                "title": "my-java-solution-using-hashmap",
                "content": "1. Here we make use of hashmap to solve this problem.\\n2. We initialise a map to store the square of nums1 elements and its frequency.\\n3. So we iterate through the first array, store the square of these numbers as the key and its frequency as value.\\n4. Then now we go through each and every element from the nums2 array and check if there is any key that matches with the product of any 2 number from num2. If yes, we update the result.\\n5. Finally return the answer.\\n\\n```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        return preProcessProblem(nums1, nums2) + preProcessProblem(nums2, nums1);\\n    }\\n    public int preProcessProblem(int [] nums1, int [] nums2) {\\n        int result = 0;\\n        int n1 = nums1.length; \\n        int n2 = nums2.length;\\n        Map<Long, Integer> map = new HashMap<>();\\n        for (int i=0; i<n1; i++) {\\n            map.put((long)nums1[i]*nums1[i], map.getOrDefault((long)nums1[i]*nums1[i], 0) + 1);\\n        }\\n        for (int j=0; j<n2; j++) {\\n            for (int k=j+1; k<n2; k++) {\\n                result += (long)map.getOrDefault((long)nums2[j]*nums2[k], 0);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        return preProcessProblem(nums1, nums2) + preProcessProblem(nums2, nums1);\\n    }\\n    public int preProcessProblem(int [] nums1, int [] nums2) {\\n        int result = 0;\\n        int n1 = nums1.length; \\n        int n2 = nums2.length;\\n        Map<Long, Integer> map = new HashMap<>();\\n        for (int i=0; i<n1; i++) {\\n            map.put((long)nums1[i]*nums1[i], map.getOrDefault((long)nums1[i]*nums1[i], 0) + 1);\\n        }\\n        for (int j=0; j<n2; j++) {\\n            for (int k=j+1; k<n2; k++) {\\n                result += (long)map.getOrDefault((long)nums2[j]*nums2[k], 0);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2003902,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "bruteforce accepted"
                    },
                    {
                        "username": "topswe",
                        "content": " HINT: Two-Sum. Search for nums1[i]^2 / nums2[k]\n\nAlso notice that Type1 and Type2 definitions are symmetric!\n\nOptimal: O(mn) time : O(m + n) space\n"
                    }
                ]
            },
            {
                "id": 1683126,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "bruteforce accepted"
                    },
                    {
                        "username": "topswe",
                        "content": " HINT: Two-Sum. Search for nums1[i]^2 / nums2[k]\n\nAlso notice that Type1 and Type2 definitions are symmetric!\n\nOptimal: O(mn) time : O(m + n) space\n"
                    }
                ]
            }
        ]
    }
]